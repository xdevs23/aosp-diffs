```diff
diff --git a/Android.bp b/Android.bp
index bfc2b3a5d..9cb665dbe 100644
--- a/Android.bp
+++ b/Android.bp
@@ -35,6 +35,8 @@ android_app {
         "SettingsLibProfileSelector",
         "SettingsLibSelectorWithWidgetPreference",
         "mediaprovider_flags_java_lib",
+        "androidx.media3.media3-common",
+        "androidx.media3.media3-transformer",
     ],
 
     libs: [
@@ -103,6 +105,7 @@ android_app {
     apex_available: [
         "com.android.mediaprovider",
     ],
+    updatable: true,
 }
 
 // Used by MediaProvider and MediaProviderTests
diff --git a/TEST_MAPPING b/TEST_MAPPING
index e677599d6..1f37f6d72 100644
--- a/TEST_MAPPING
+++ b/TEST_MAPPING
@@ -244,6 +244,16 @@
             ]
         }
     ],
+    "presubmit-large": [
+        {
+          "name": "CtsScopedStoragePublicVolumeHostTest",
+          "options": [
+                {
+                  "exclude-annotation": "androidx.test.filters.FlakyTest"
+                }
+          ]
+        }
+    ],
     "postsubmit": [
         {
             "name": "MediaProviderClientTests"
diff --git a/apex/Android.bp b/apex/Android.bp
index a82a94753..e0105a136 100644
--- a/apex/Android.bp
+++ b/apex/Android.bp
@@ -123,6 +123,7 @@ bootclasspath_fragment {
             "android.graphics.pdf.models",
             "android.graphics.pdf.utils",
             "android.graphics.pdf.content",
+            "android.graphics.pdf.component",
             "android.graphics.pdf.models.jni",
             "android.graphics.pdf.models.selection",
             "android.graphics.pdf.logging",
diff --git a/apex/framework/Android.bp b/apex/framework/Android.bp
index 1c13ff7ea..17b2829e3 100644
--- a/apex/framework/Android.bp
+++ b/apex/framework/Android.bp
@@ -38,6 +38,11 @@ java_sdk_library {
 
     installable: true,
 
+    stub_only_libs: [
+        // Needed for javadoc references.
+        "framework-media.stubs.module_lib",
+    ],
+
     libs: [
         "androidx.annotation_annotation",
         "framework-media.stubs.module_lib",
diff --git a/apex/framework/api/current.txt b/apex/framework/api/current.txt
index 4248c91f7..f62ec73d9 100644
--- a/apex/framework/api/current.txt
+++ b/apex/framework/api/current.txt
@@ -10,12 +10,19 @@ package android.provider {
     method @NonNull public final String getType(@NonNull android.net.Uri);
     method @NonNull public final android.net.Uri insert(@NonNull android.net.Uri, @NonNull android.content.ContentValues);
     method @Nullable public android.provider.CloudMediaProvider.CloudMediaSurfaceController onCreateCloudMediaSurfaceController(@NonNull android.os.Bundle, @NonNull android.provider.CloudMediaProvider.CloudMediaSurfaceStateChangedCallback);
+    method @FlaggedApi("com.android.providers.media.flags.enable_cloud_media_provider_capabilities") @NonNull public android.provider.CloudMediaProviderContract.Capabilities onGetCapabilities();
     method @NonNull public abstract android.os.Bundle onGetMediaCollectionInfo(@NonNull android.os.Bundle);
     method @NonNull public abstract android.os.ParcelFileDescriptor onOpenMedia(@NonNull String, @Nullable android.os.Bundle, @Nullable android.os.CancellationSignal) throws java.io.FileNotFoundException;
     method @NonNull public abstract android.content.res.AssetFileDescriptor onOpenPreview(@NonNull String, @NonNull android.graphics.Point, @Nullable android.os.Bundle, @Nullable android.os.CancellationSignal) throws java.io.FileNotFoundException;
     method @NonNull public android.database.Cursor onQueryAlbums(@NonNull android.os.Bundle);
     method @NonNull public abstract android.database.Cursor onQueryDeletedMedia(@NonNull android.os.Bundle);
     method @NonNull public abstract android.database.Cursor onQueryMedia(@NonNull android.os.Bundle);
+    method @FlaggedApi("com.android.providers.media.flags.cloud_media_provider_search") @NonNull public android.database.Cursor onQueryMediaCategories(@Nullable String, @NonNull android.os.Bundle, @Nullable android.os.CancellationSignal);
+    method @FlaggedApi("com.android.providers.media.flags.cloud_media_provider_search") @NonNull public android.database.Cursor onQueryMediaInMediaSet(@NonNull String, @NonNull android.os.Bundle, @Nullable android.os.CancellationSignal);
+    method @FlaggedApi("com.android.providers.media.flags.cloud_media_provider_search") @NonNull public android.database.Cursor onQueryMediaSets(@NonNull String, @NonNull android.os.Bundle, @Nullable android.os.CancellationSignal);
+    method @FlaggedApi("com.android.providers.media.flags.cloud_media_provider_search") @NonNull public android.database.Cursor onQuerySearchSuggestions(@NonNull String, @NonNull android.os.Bundle, @Nullable android.os.CancellationSignal);
+    method @FlaggedApi("com.android.providers.media.flags.cloud_media_provider_search") @NonNull public android.database.Cursor onSearchMedia(@NonNull String, @Nullable String, @NonNull android.os.Bundle, @Nullable android.os.CancellationSignal);
+    method @FlaggedApi("com.android.providers.media.flags.cloud_media_provider_search") @NonNull public android.database.Cursor onSearchMedia(@NonNull String, @NonNull android.os.Bundle, @Nullable android.os.CancellationSignal);
     method @NonNull public final android.os.ParcelFileDescriptor openFile(@NonNull android.net.Uri, @NonNull String) throws java.io.FileNotFoundException;
     method @NonNull public final android.os.ParcelFileDescriptor openFile(@NonNull android.net.Uri, @NonNull String, @Nullable android.os.CancellationSignal) throws java.io.FileNotFoundException;
     method @NonNull public final android.content.res.AssetFileDescriptor openTypedAssetFile(@NonNull android.net.Uri, @NonNull String, @Nullable android.os.Bundle) throws java.io.FileNotFoundException;
@@ -59,10 +66,18 @@ package android.provider {
     field public static final String EXTRA_PAGE_SIZE = "android.provider.extra.PAGE_SIZE";
     field public static final String EXTRA_PAGE_TOKEN = "android.provider.extra.PAGE_TOKEN";
     field public static final String EXTRA_PREVIEW_THUMBNAIL = "android.provider.extra.PREVIEW_THUMBNAIL";
+    field @FlaggedApi("com.android.providers.media.flags.cloud_media_provider_search") public static final String EXTRA_SORT_ORDER = "android.provider.extra.SORT_ORDER";
     field public static final String EXTRA_SURFACE_CONTROLLER_AUDIO_MUTE_ENABLED = "android.provider.extra.SURFACE_CONTROLLER_AUDIO_MUTE_ENABLED";
     field public static final String EXTRA_SYNC_GENERATION = "android.provider.extra.SYNC_GENERATION";
     field public static final String MANAGE_CLOUD_MEDIA_PROVIDERS_PERMISSION = "com.android.providers.media.permission.MANAGE_CLOUD_MEDIA_PROVIDERS";
+    field @FlaggedApi("com.android.providers.media.flags.cloud_media_provider_search") public static final String MEDIA_CATEGORY_TYPE_PEOPLE_AND_PETS = "com.android.providers.media.MEDIA_CATEGORY_TYPE_PEOPLE_AND_PETS";
     field public static final String PROVIDER_INTERFACE = "android.content.action.CLOUD_MEDIA_PROVIDER";
+    field @FlaggedApi("com.android.providers.media.flags.cloud_media_provider_search") public static final String SEARCH_SUGGESTION_ALBUM = "com.android.providers.media.SEARCH_SUGGESTION_ALBUM";
+    field @FlaggedApi("com.android.providers.media.flags.cloud_media_provider_search") public static final String SEARCH_SUGGESTION_DATE = "com.android.providers.media.SEARCH_SUGGESTION_DATE";
+    field @FlaggedApi("com.android.providers.media.flags.cloud_media_provider_search") public static final String SEARCH_SUGGESTION_FACE = "com.android.providers.media.SEARCH_SUGGESTION_FACE";
+    field @FlaggedApi("com.android.providers.media.flags.cloud_media_provider_search") public static final String SEARCH_SUGGESTION_LOCATION = "com.android.providers.media.SEARCH_SUGGESTION_LOCATION";
+    field @FlaggedApi("com.android.providers.media.flags.cloud_media_provider_search") public static final String SEARCH_SUGGESTION_TEXT = "com.android.providers.media.SEARCH_SUGGESTION_TEXT";
+    field @FlaggedApi("com.android.providers.media.flags.cloud_media_provider_search") public static final int SORT_ORDER_DESC_DATE_TAKEN = 1; // 0x1
   }
 
   public static final class CloudMediaProviderContract.AlbumColumns {
@@ -73,6 +88,31 @@ package android.provider {
     field public static final String MEDIA_COVER_ID = "album_media_cover_id";
   }
 
+  @FlaggedApi("com.android.providers.media.flags.enable_cloud_media_provider_capabilities") public static final class CloudMediaProviderContract.Capabilities implements android.os.Parcelable {
+    method public int describeContents();
+    method @FlaggedApi("com.android.providers.media.flags.cloud_media_provider_search") public boolean isMediaCategoriesEnabled();
+    method @FlaggedApi("com.android.providers.media.flags.cloud_media_provider_search") public boolean isSearchEnabled();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.provider.CloudMediaProviderContract.Capabilities> CREATOR;
+  }
+
+  @FlaggedApi("com.android.providers.media.flags.enable_cloud_media_provider_capabilities") public static final class CloudMediaProviderContract.Capabilities.Builder {
+    ctor public CloudMediaProviderContract.Capabilities.Builder();
+    method @NonNull public android.provider.CloudMediaProviderContract.Capabilities build();
+    method @FlaggedApi("com.android.providers.media.flags.cloud_media_provider_search") @NonNull public android.provider.CloudMediaProviderContract.Capabilities.Builder setMediaCategoriesEnabled(boolean);
+    method @FlaggedApi("com.android.providers.media.flags.cloud_media_provider_search") @NonNull public android.provider.CloudMediaProviderContract.Capabilities.Builder setSearchEnabled(boolean);
+  }
+
+  @FlaggedApi("com.android.providers.media.flags.cloud_media_provider_search") public static final class CloudMediaProviderContract.MediaCategoryColumns {
+    field public static final String DISPLAY_NAME = "display_name";
+    field public static final String ID = "id";
+    field public static final String MEDIA_CATEGORY_TYPE = "media_category_type";
+    field public static final String MEDIA_COVER_ID1 = "media_cover_id1";
+    field public static final String MEDIA_COVER_ID2 = "media_cover_id2";
+    field public static final String MEDIA_COVER_ID3 = "media_cover_id3";
+    field public static final String MEDIA_COVER_ID4 = "media_cover_id4";
+  }
+
   public static final class CloudMediaProviderContract.MediaCollectionInfo {
     field public static final String ACCOUNT_CONFIGURATION_INTENT = "account_configuration_intent";
     field public static final String ACCOUNT_NAME = "account_name";
@@ -99,6 +139,20 @@ package android.provider {
     field public static final String WIDTH = "width";
   }
 
+  @FlaggedApi("com.android.providers.media.flags.cloud_media_provider_search") public static final class CloudMediaProviderContract.MediaSetColumns {
+    field public static final String DISPLAY_NAME = "display_name";
+    field public static final String ID = "id";
+    field public static final String MEDIA_COUNT = "media_count";
+    field public static final String MEDIA_COVER_ID = "media_cover_id";
+  }
+
+  @FlaggedApi("com.android.providers.media.flags.cloud_media_provider_search") public static final class CloudMediaProviderContract.SearchSuggestionColumns {
+    field public static final String DISPLAY_TEXT = "display_text";
+    field public static final String MEDIA_COVER_ID = "media_cover_id";
+    field public static final String MEDIA_SET_ID = "media_set_id";
+    field public static final String TYPE = "type";
+  }
+
   public final class MediaStore {
     ctor public MediaStore();
     method public static boolean canManageMedia(@NonNull android.content.Context);
@@ -123,6 +177,7 @@ package android.provider {
     method public static boolean isCurrentCloudMediaProviderAuthority(@NonNull android.content.ContentResolver, @NonNull String);
     method public static boolean isCurrentSystemGallery(@NonNull android.content.ContentResolver, int, @NonNull String);
     method public static boolean isSupportedCloudMediaProviderAuthority(@NonNull android.content.ContentResolver, @NonNull String);
+    method @FlaggedApi("com.android.providers.media.flags.enable_mark_is_favorite_status_api") public static void markIsFavoriteStatus(@NonNull android.content.ContentResolver, @NonNull java.util.Collection<android.net.Uri>, boolean);
     method public static void notifyCloudMediaChangedEvent(@NonNull android.content.ContentResolver, @NonNull String, @NonNull String) throws java.lang.SecurityException;
     method @FlaggedApi("com.android.providers.media.flags.media_store_open_file") @Nullable public static android.content.res.AssetFileDescriptor openAssetFileDescriptor(@NonNull android.content.ContentResolver, @NonNull android.net.Uri, @NonNull String, @Nullable android.os.CancellationSignal) throws java.io.FileNotFoundException;
     method @FlaggedApi("com.android.providers.media.flags.media_store_open_file") @Nullable public static android.os.ParcelFileDescriptor openFileDescriptor(@NonNull android.content.ContentResolver, @NonNull android.net.Uri, @NonNull String, @Nullable android.os.CancellationSignal) throws java.io.FileNotFoundException;
@@ -133,6 +188,8 @@ package android.provider {
     field @FlaggedApi("com.android.providers.media.flags.enable_oem_metadata") public static final String ACCESS_OEM_METADATA_PERMISSION = "com.android.providers.media.permission.ACCESS_OEM_METADATA";
     field public static final String ACTION_IMAGE_CAPTURE = "android.media.action.IMAGE_CAPTURE";
     field public static final String ACTION_IMAGE_CAPTURE_SECURE = "android.media.action.IMAGE_CAPTURE_SECURE";
+    field @FlaggedApi("com.android.providers.media.flags.motion_photo_intent") public static final String ACTION_MOTION_PHOTO_CAPTURE = "android.provider.action.MOTION_PHOTO_CAPTURE";
+    field @FlaggedApi("com.android.providers.media.flags.motion_photo_intent") public static final String ACTION_MOTION_PHOTO_CAPTURE_SECURE = "android.provider.action.MOTION_PHOTO_CAPTURE_SECURE";
     field public static final String ACTION_PICK_IMAGES = "android.provider.action.PICK_IMAGES";
     field public static final String ACTION_PICK_IMAGES_SETTINGS = "android.provider.action.PICK_IMAGES_SETTINGS";
     field public static final String ACTION_REVIEW = "android.provider.action.REVIEW";
diff --git a/apex/framework/java/android/provider/CloudMediaProvider.java b/apex/framework/java/android/provider/CloudMediaProvider.java
index 7875fdf3b..4fbe6c664 100644
--- a/apex/framework/java/android/provider/CloudMediaProvider.java
+++ b/apex/framework/java/android/provider/CloudMediaProvider.java
@@ -22,19 +22,32 @@ import static android.provider.CloudMediaProviderContract.EXTRA_ERROR_MESSAGE;
 import static android.provider.CloudMediaProviderContract.EXTRA_FILE_DESCRIPTOR;
 import static android.provider.CloudMediaProviderContract.EXTRA_LOOPING_PLAYBACK_ENABLED;
 import static android.provider.CloudMediaProviderContract.EXTRA_MEDIASTORE_THUMB;
+import static android.provider.CloudMediaProviderContract.EXTRA_PROVIDER_CAPABILITIES;
 import static android.provider.CloudMediaProviderContract.EXTRA_SURFACE_CONTROLLER;
 import static android.provider.CloudMediaProviderContract.EXTRA_SURFACE_CONTROLLER_AUDIO_MUTE_ENABLED;
 import static android.provider.CloudMediaProviderContract.EXTRA_SURFACE_STATE_CALLBACK;
+import static android.provider.CloudMediaProviderContract.KEY_MEDIA_CATEGORY_ID;
+import static android.provider.CloudMediaProviderContract.KEY_MEDIA_SET_ID;
+import static android.provider.CloudMediaProviderContract.KEY_PARENT_CATEGORY_ID;
+import static android.provider.CloudMediaProviderContract.KEY_PREFIX_TEXT;
+import static android.provider.CloudMediaProviderContract.KEY_SEARCH_TEXT;
 import static android.provider.CloudMediaProviderContract.METHOD_CREATE_SURFACE_CONTROLLER;
 import static android.provider.CloudMediaProviderContract.METHOD_GET_ASYNC_CONTENT_PROVIDER;
+import static android.provider.CloudMediaProviderContract.METHOD_GET_CAPABILITIES;
 import static android.provider.CloudMediaProviderContract.METHOD_GET_MEDIA_COLLECTION_INFO;
 import static android.provider.CloudMediaProviderContract.URI_PATH_ALBUM;
 import static android.provider.CloudMediaProviderContract.URI_PATH_DELETED_MEDIA;
 import static android.provider.CloudMediaProviderContract.URI_PATH_MEDIA;
+import static android.provider.CloudMediaProviderContract.URI_PATH_MEDIA_CATEGORY;
 import static android.provider.CloudMediaProviderContract.URI_PATH_MEDIA_COLLECTION_INFO;
+import static android.provider.CloudMediaProviderContract.URI_PATH_MEDIA_SET;
+import static android.provider.CloudMediaProviderContract.URI_PATH_MEDIA_IN_MEDIA_SET;
+import static android.provider.CloudMediaProviderContract.URI_PATH_SEARCH_MEDIA;
+import static android.provider.CloudMediaProviderContract.URI_PATH_SEARCH_SUGGESTION;
 import static android.provider.CloudMediaProviderContract.URI_PATH_SURFACE_CONTROLLER;
 
 import android.annotation.DurationMillisLong;
+import android.annotation.FlaggedApi;
 import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
@@ -62,6 +75,8 @@ import android.util.Log;
 import android.view.Surface;
 import android.view.SurfaceHolder;
 
+import com.android.providers.media.flags.Flags;
+
 import java.io.FileNotFoundException;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
@@ -118,6 +133,11 @@ public abstract class CloudMediaProvider extends ContentProvider {
     private static final int MATCH_ALBUMS = 3;
     private static final int MATCH_MEDIA_COLLECTION_INFO = 4;
     private static final int MATCH_SURFACE_CONTROLLER = 5;
+    private static final int MATCH_MEDIA_CATEGORIES = 6;
+    private static final int MATCH_MEDIA_SETS = 7;
+    private static final int MATCH_SEARCH_SUGGESTION = 8;
+    private static final int MATCH_SEARCH = 9;
+    private static final int MATCH_MEDIAS_IN_MEDIA_SET = 10;
 
     private static final boolean DEFAULT_LOOPING_PLAYBACK_ENABLED = true;
     private static final boolean DEFAULT_SURFACE_CONTROLLER_AUDIO_MUTE_ENABLED = false;
@@ -145,6 +165,11 @@ public abstract class CloudMediaProvider extends ContentProvider {
         mMatcher.addURI(authority, URI_PATH_ALBUM, MATCH_ALBUMS);
         mMatcher.addURI(authority, URI_PATH_MEDIA_COLLECTION_INFO, MATCH_MEDIA_COLLECTION_INFO);
         mMatcher.addURI(authority, URI_PATH_SURFACE_CONTROLLER, MATCH_SURFACE_CONTROLLER);
+        mMatcher.addURI(authority, URI_PATH_MEDIA_CATEGORY, MATCH_MEDIA_CATEGORIES);
+        mMatcher.addURI(authority, URI_PATH_MEDIA_SET, MATCH_MEDIA_SETS);
+        mMatcher.addURI(authority, URI_PATH_SEARCH_SUGGESTION, MATCH_SEARCH_SUGGESTION);
+        mMatcher.addURI(authority, URI_PATH_SEARCH_MEDIA, MATCH_SEARCH);
+        mMatcher.addURI(authority, URI_PATH_MEDIA_IN_MEDIA_SET, MATCH_MEDIAS_IN_MEDIA_SET);
     }
 
     /**
@@ -160,6 +185,27 @@ public abstract class CloudMediaProvider extends ContentProvider {
         return bundle;
     }
 
+    /**
+     * Returns the {@link CloudMediaProviderContract.Capabilities} of this
+     * CloudMediaProvider.
+     *
+     * This object is used to determine which APIs can be safely invoked during
+     * runtime.
+     *
+     * If not overridden the default capabilities are used.
+     *
+     * IMPORTANT: This method is performance critical and should avoid long running
+     * or expensive operations.
+     *
+     * @see CloudMediaProviderContract.Capabilities
+     *
+     */
+    @NonNull
+    @FlaggedApi(Flags.FLAG_ENABLE_CLOUD_MEDIA_PROVIDER_CAPABILITIES)
+    public CloudMediaProviderContract.Capabilities onGetCapabilities() {
+        return new CloudMediaProviderContract.Capabilities.Builder().build();
+    }
+
     /**
      * Returns metadata about the media collection itself.
      * <p>
@@ -254,6 +300,7 @@ public abstract class CloudMediaProvider extends ContentProvider {
      * {@link CloudMediaProviderContract#EXTRA_MEDIA_COLLECTION_ID} as part of the returned
      * {@link Cursor#setExtras} {@link Bundle}. Not setting this is an error and invalidates the
      * returned {@link Cursor}.
+     *
      * <p>
      * If the provider handled any filters in {@code extras}, it must add the key to
      * the {@link ContentResolver#EXTRA_HONORED_ARGS} as part of the returned
@@ -264,6 +311,7 @@ public abstract class CloudMediaProvider extends ContentProvider {
      * <li> {@link CloudMediaProviderContract#EXTRA_SYNC_GENERATION}
      * <li> {@link CloudMediaProviderContract#EXTRA_PAGE_TOKEN}
      * <li> {@link CloudMediaProviderContract#EXTRA_PAGE_SIZE}
+     * <li> {@link android.content.Intent#EXTRA_MIME_TYPES}
      * </ul>
      * @return cursor representing album items containing all
      * {@link CloudMediaProviderContract.AlbumColumns} columns
@@ -274,6 +322,327 @@ public abstract class CloudMediaProvider extends ContentProvider {
         throw new UnsupportedOperationException("queryAlbums not supported");
     }
 
+    /**
+     * Queries for the available MediaCategories under the given {@code parentCategoryId},
+     * filtered by {@code extras}. The columns of MediaCategories are
+     * in the class {@link CloudMediaProviderContract.MediaCategoryColumns}.
+     *
+     * <p>
+     * When {@code parentCategoryId} is null, this returns the root categories.
+     *
+     * <p>
+     * The order in which media categories are sorted in the cursor
+     * will be retained when displaying results to the user.
+     *
+     * <p>
+     * The cloud media provider must set the
+     * {@link CloudMediaProviderContract#EXTRA_MEDIA_COLLECTION_ID} as part of the returned cursor
+     * by using {@link Cursor#setExtras}. Not setting this is an error and invalidates the
+     * returned {@link Cursor}, meaning photo picker will not use the cursor for any operation.
+     *
+     * <p>
+     * {@code extras} may contain some key-value pairs which should be used to filter the results.
+     * If the provider handled any filters in {@code extras}, it must add the key to
+     * the {@link ContentResolver#EXTRA_HONORED_ARGS} as part of the returned cursor by using
+     * {@link Cursor#setExtras}. If not honored, photo picker will assume the result of the query is
+     * without the extra being used.
+     * Note: Currently this function does not pass any params in {@code extras}.
+     *
+     * @param parentCategoryId   the ID of the parent category to filter media categories.
+     * @param extras             containing keys to filter media categories:
+     *                           <ul>
+     *                           <li> {@link android.content.Intent#EXTRA_MIME_TYPES}
+     *                           </ul>
+     * @param cancellationSignal {@link CancellationSignal} to check if request has been cancelled.
+     * @return cursor with {@link CloudMediaProviderContract.MediaCategoryColumns} columns
+     */
+    @FlaggedApi(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+    @NonNull
+    public Cursor onQueryMediaCategories(@Nullable String parentCategoryId,
+            @NonNull Bundle extras, @Nullable CancellationSignal cancellationSignal) {
+        throw new UnsupportedOperationException("onQueryMediaCategories is not supported");
+    }
+
+    /**
+     * Queries for the available MediaSets under a given {@code mediaCategoryId},
+     * filtered by {@code extras}. The columns of MediaSet are in the class
+     * {@link CloudMediaProviderContract.MediaSetColumns}.
+     *
+     * <p>
+     * This returns MediaSets directly inside the given MediaCategoryId.
+     * If the passed mediaCategoryId has some more nested mediaCategories, the mediaSets inside
+     * the nested mediaCategories must not be returned in this response.
+     *
+     * <p>
+     * The order in which media sets are sorted in the cursor
+     * will be retained when displaying results to the user.
+     *
+     * <p>
+     * The cloud media provider must set the
+     * {@link CloudMediaProviderContract#EXTRA_MEDIA_COLLECTION_ID} as part of the returned cursor
+     * by using {@link Cursor#setExtras} . Not setting this is an error and invalidates the
+     * returned {@link Cursor}, meaning photo picker will not use the cursor for any operation.
+     *
+     * <p>
+     * {@code extras} may contain some key-value pairs which should be used to prepare the results.
+     * If the provider handled any filters in {@code extras}, it must add the key to
+     * the {@link ContentResolver#EXTRA_HONORED_ARGS} as part of the returned cursor by using
+     * {@link Cursor#setExtras}. If not honored, photo picker will assume the result of the query is
+     * without the extra being used.
+     *
+     * <p>
+     * If the cloud media provider supports pagination, they can set
+     * {@link CloudMediaProviderContract#EXTRA_PAGE_TOKEN} as the next page token,
+     * as part of the returned cursor by using {@link Cursor#setExtras}.
+     * If a token is set, the OS will pass it as a  key-value pair in {@code extras}
+     * when querying for query media sets for subsequent pages.
+     * The provider can keep returning pagination tokens in the returned cursor
+     * by using {@link Cursor#setExtras} until the last page at which point it should not
+     * set a token in the returned cursor.
+     *
+     * @param mediaCategoryId    the ID of the media category to filter media sets.
+     * @param extras             containing keys to filter media sets:
+     *                           <ul>
+     *                           <li> {@link CloudMediaProviderContract#EXTRA_PAGE_TOKEN}
+     *                           <li> {@link CloudMediaProviderContract#EXTRA_PAGE_SIZE}
+     *                           <li> {@link android.content.Intent#EXTRA_MIME_TYPES}
+     *                           </ul>
+     * @param cancellationSignal {@link CancellationSignal} to check if request has been cancelled.
+     * @return cursor representing {@link CloudMediaProviderContract.MediaSetColumns} columns
+     */
+    @FlaggedApi(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+    @NonNull
+    public Cursor onQueryMediaSets(@NonNull String mediaCategoryId,
+            @NonNull Bundle extras, @Nullable CancellationSignal cancellationSignal) {
+        throw new UnsupportedOperationException("onQueryMediaSets is not supported");
+    }
+
+    /**
+     * Queries for the available SearchSuggestions based on a {@code prefixText},
+     * filtered by {@code extras}. The columns of SearchSuggestions are in the class
+     * {@link CloudMediaProviderContract.SearchSuggestionColumns}
+     *
+     * <p>
+     * If the user has not started typing, this is considered as zero state suggestion.
+     * In this case {@code prefixText} will be empty string.
+     *
+     * <p>
+     * The order in which suggestions are sorted in the cursor
+     * will be retained when displaying results to the user.
+     *
+     * <p>
+     * The cloud media provider must set the
+     * {@link CloudMediaProviderContract#EXTRA_MEDIA_COLLECTION_ID} as part of the returned cursor
+     * by using {@link Cursor#setExtras} . Not setting this is an error and invalidates the
+     * returned {@link Cursor}, meaning photo picker will not use the cursor for any operation.
+     *
+     * <p>
+     * {@code extras} may contain some key-value pairs which should be used to prepare
+     * the results.
+     * If the provider handled any params in {@code extras}, it must add the key to
+     * the {@link ContentResolver#EXTRA_HONORED_ARGS} as part of the returned cursor by using
+     * {@link Cursor#setExtras}. If not honored, photo picker will assume the result of the query is
+     * without the extra being used.
+     * Note: Currently this function does not pass any key-value params in {@code extras}.
+     *
+     * <p>
+     * Results may not be displayed if it takes longer than 300 milliseconds to get a response from
+     * the cloud media provider.
+     *
+     * @param prefixText         the prefix text to filter search suggestions.
+     * @param extras             containing keys to filter search suggestions.
+     *                           <ul>
+     *                           <li> {@link CloudMediaProviderContract#EXTRA_PAGE_SIZE}
+     *                           </ul>
+     * @param cancellationSignal {@link CancellationSignal} to check if request has been cancelled.
+     * @return cursor representing search suggestions containing all
+     * {@see CloudMediaProviderContract.SearchSuggestionColumns} columns
+     */
+    @FlaggedApi(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+    @NonNull
+    public Cursor onQuerySearchSuggestions(@NonNull String prefixText,
+            @NonNull Bundle extras, @Nullable CancellationSignal cancellationSignal) {
+        throw new UnsupportedOperationException("onQuerySearchSuggestions is not supported");
+    }
+
+    /**
+     * Queries for the available media items under a given {@code mediaSetId},
+     * filtered by {@code extras}. The columns of Media are in the class
+     * {@link CloudMediaProviderContract.MediaColumns}. {@code mediaSetId} is the ID given
+     * as part of {@link CloudMediaProviderContract.MediaSetColumns#ID}
+     *
+     * <p>
+     * The order in which media items are sorted in the cursor
+     * will be retained when displaying results to the user.
+     *
+     * <p>
+     * The cloud media provider must set the
+     * {@link CloudMediaProviderContract#EXTRA_MEDIA_COLLECTION_ID} as part of the returned
+     * {@link Cursor} by using {@link Cursor#setExtras}.
+     * Not setting this is an error and invalidates the
+     * returned {@link Cursor}, meaning photo picker will not use the cursor for any operation.
+     *
+     * <p>
+     * {@code extras} may contain some key-value pairs which should be used to prepare the results.
+     * If the provider handled any filters in {@code extras}, it must add the key to
+     * the {@link ContentResolver#EXTRA_HONORED_ARGS} as part of the returned cursor by using
+     * {@link Cursor#setExtras}. If not honored, photo picker will assume the result of the query is
+     * without the extra being used.
+     *
+     * <p>
+     * If the cloud media provider supports pagination, they can set
+     * {@link CloudMediaProviderContract#EXTRA_PAGE_TOKEN} as the next page token,
+     * as part of the returned cursor by using {@link Cursor#setExtras}.
+     * If a token is set, the OS will pass it as a  key-value pair in {@code extras}
+     * when querying for media for subsequent pages.
+     * The provider can keep returning pagination tokens in the returned cursor
+     * by using {@link Cursor#setExtras} until the last page at which point it should not
+     * set a token in the returned cursor.
+     *
+     * @param mediaSetId         the ID of the media set to filter media items.
+     * @param extras             containing keys to filter media items:
+     *                           <ul>
+     *                           <li> {@link CloudMediaProviderContract#EXTRA_PAGE_TOKEN}
+     *                           <li> {@link CloudMediaProviderContract#EXTRA_PAGE_SIZE}
+     *                           <li> {@link CloudMediaProviderContract#EXTRA_SORT_ORDER}
+     *                           <li> {@link android.content.Intent#EXTRA_MIME_TYPES}
+     *                           </ul>
+     * @param cancellationSignal {@link CancellationSignal} to check if request has been cancelled.
+     * @return cursor representing {@link CloudMediaProviderContract.MediaColumns} columns
+     */
+    @FlaggedApi(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+    @NonNull
+    public Cursor onQueryMediaInMediaSet(@NonNull String mediaSetId,
+            @NonNull Bundle extras, @Nullable CancellationSignal cancellationSignal) {
+        throw new UnsupportedOperationException("onQueryMediaInMediaSet is not supported");
+    }
+
+    /**
+     * Searches media items based on a selected suggestion, managed by {@code extras} and
+     * returns a cursor of {@link CloudMediaProviderContract.MediaColumns} based on the match.
+     *
+     * <p>
+     * The cloud media provider must set the
+     * {@link CloudMediaProviderContract#EXTRA_MEDIA_COLLECTION_ID} as part of the returned cursor
+     * by using {@link Cursor#setExtras} . Not setting this is an error and invalidates the
+     * returned {@link Cursor}, meaning photo picker will not use the cursor for any operation.
+     * <p>
+     *
+     * {@code extras} may contain some key-value pairs which should be used to prepare the results.
+     * If the provider handled any params in {@code extras}, it must add the key to
+     * the {@link ContentResolver#EXTRA_HONORED_ARGS} as part of the returned cursor by using
+     * {@link Cursor#setExtras}. If not honored, photo picker will assume the result of the query is
+     * without the extra being used.
+     *
+     * <p>
+     * An example user journey:
+     * <ol>
+     *     <li>User enters the search prompt.</li>
+     *     <li>Using {@link #onQuerySearchSuggestions}, photo picker display suggestions as the user
+     *     keeps typing.</li>
+     *     <li>User selects a suggestion, Photo picker calls:
+     *     {@code onSearchMedia(suggestedMediaSetId, fallbackSearchText, extras)}
+     *     with the {@code suggestedMediaSetId} corresponding to the user chosen suggestion.
+     *     {@link CloudMediaProviderContract.SearchSuggestionColumns#MEDIA_SET_ID}</li>
+     * </ol>
+     *
+     *
+     * <p>
+     * If the cloud media provider supports pagination, they can set
+     * {@link CloudMediaProviderContract#EXTRA_PAGE_TOKEN} as the next page token,
+     * as part of the returned cursor by using {@link Cursor#setExtras}.
+     * If a token is set, the OS will pass it as a key value pair in {@code extras}
+     * when querying for search media for subsequent pages.
+     * The provider can keep returning pagination tokens in the returned cursor
+     * by using {@link Cursor#setExtras} until the last page at which point it should not
+     * set a token in the returned cursor
+     *
+     * <p>
+     * Results may not be displayed if it takes longer than 3 seconds to get a paged response from
+     * the cloud media provider.
+     *
+     * @param suggestedMediaSetId the media set ID of the suggestion that the user wants to search.
+     * @param fallbackSearchText  optional search text to be used when {@code suggestedMediaSetId}
+     *                            is not useful.
+     * @param extras              containing keys to manage the search results:
+     *                            <ul>
+     *                            <li>{@link CloudMediaProviderContract#EXTRA_PAGE_TOKEN}
+     *                            <li>{@link CloudMediaProviderContract#EXTRA_PAGE_SIZE}
+     *                            <li>{@link CloudMediaProviderContract#EXTRA_SORT_ORDER}
+     *                            <li> {@link android.content.Intent#EXTRA_MIME_TYPES}
+     *                            </ul>
+     * @param cancellationSignal  {@link CancellationSignal} to check if request has been cancelled.
+     * @return cursor of {@link CloudMediaProviderContract.MediaColumns} based on the match.
+     * @see CloudMediaProviderContract.SearchSuggestionColumns#MEDIA_SET_ID
+     */
+    @FlaggedApi(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+    @NonNull
+    public Cursor onSearchMedia(@NonNull String suggestedMediaSetId,
+            @Nullable String fallbackSearchText,
+            @NonNull Bundle extras, @Nullable CancellationSignal cancellationSignal) {
+        throw new UnsupportedOperationException("onSearchMedia for"
+                + " suggestion media set id is not supported");
+    }
+
+    /**
+     * Searches media items based on entered search text, managed by {@code extras} and
+     * returns a cursor of {@link CloudMediaProviderContract.MediaColumns} based on the match.
+     *
+     * <p>
+     * The cloud media provider must set the
+     * {@link CloudMediaProviderContract#EXTRA_MEDIA_COLLECTION_ID} as part of the returned cursor
+     * by using {@link Cursor#setExtras} . Not setting this is an error and invalidates the
+     * returned {@link Cursor}, meaning photo picker will not use the cursor for any operation.
+     *
+     * <p>
+     * {@code extras} may contain some key-value pairs which should be used to prepare the results.
+     * If the provider handled any params in {@code extras}, it must add the key to
+     * the {@link ContentResolver#EXTRA_HONORED_ARGS} as part of the returned cursor by using
+     * {@link Cursor#setExtras}. If not honored, photo picker will assume the result of the query is
+     * without the extra being used.
+     *
+     * <p>
+     * An example user journey:
+     * <ol>
+     *     <li>User enters the search prompt.</li>
+     *     <li>Using {@link #onQuerySearchSuggestions}, photo picker display suggestions as the user
+     *     keeps typing.</li>
+     *     <li>User types completely and then enters search,
+     *     Photo picker calls: {@code onSearchMedia(searchText, extras)}</li>
+     * </ol>
+     *
+     * <p>
+     * If the cloud media provider supports pagination, they can set
+     * {@link CloudMediaProviderContract#EXTRA_PAGE_TOKEN} as the next page token,
+     * as part of the returned cursor by using {@link Cursor#setExtras}.
+     * If a token is set, the OS will pass it as a key value pair in {@code extras}
+     * when querying for search media for subsequent pages.
+     * The provider can keep returning pagination tokens in the returned cursor
+     * by using {@link Cursor#setExtras} until the last page at which point it should not
+     * set a token in the returned cursor.
+     *
+     * <p>
+     * Results may not be displayed if it takes longer than 3 seconds to get a paged response from
+     * the cloud media provider.
+     *
+     * @param searchText         search text to be used.
+     * @param extras             containing keys to manage the search results:
+     *                           <ul>
+     *                           <li> {@link CloudMediaProviderContract#EXTRA_PAGE_TOKEN}
+     *                           <li> {@link CloudMediaProviderContract#EXTRA_PAGE_SIZE}
+     *                           <li> {@link CloudMediaProviderContract#EXTRA_SORT_ORDER}
+     *                           <li> {@link android.content.Intent#EXTRA_MIME_TYPES}
+     *                           </ul>
+     * @param cancellationSignal {@link CancellationSignal} to check if request has been cancelled.
+     * @return cursor of {@link CloudMediaProviderContract.MediaColumns} based on the match.
+     */
+    @FlaggedApi(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+    @NonNull
+    public Cursor onSearchMedia(@NonNull String searchText,
+            @NonNull Bundle extras, @Nullable CancellationSignal cancellationSignal) {
+        throw new UnsupportedOperationException("onSearchMedia for search text is not supported");
+    }
+
     /**
      * Returns a thumbnail of {@code size} for a media item identified by {@code mediaId}
      * <p>The cloud media provider should strictly return thumbnail in the original
@@ -363,7 +732,7 @@ public abstract class CloudMediaProvider extends ContentProvider {
     }
 
     private Bundle callUnchecked(@NonNull String method, @Nullable String arg,
-                                 @Nullable Bundle extras)
+            @Nullable Bundle extras)
             throws FileNotFoundException {
         if (extras == null) {
             extras = new Bundle();
@@ -373,12 +742,22 @@ public abstract class CloudMediaProvider extends ContentProvider {
             long startTime = System.currentTimeMillis();
             result = onGetMediaCollectionInfo(extras);
             CmpApiVerifier.verifyApiResult(new CmpApiResult(
-                            CmpApiVerifier.CloudMediaProviderApis.OnGetMediaCollectionInfo, result),
+                    CmpApiVerifier.CloudMediaProviderApis.OnGetMediaCollectionInfo, result),
                     System.currentTimeMillis() - startTime, mAuthority);
         } else if (METHOD_CREATE_SURFACE_CONTROLLER.equals(method)) {
             result = onCreateCloudMediaSurfaceController(extras);
         } else if (METHOD_GET_ASYNC_CONTENT_PROVIDER.equals(method)) {
             result = onGetAsyncContentProvider();
+        } else if (Flags.enableCloudMediaProviderCapabilities()
+                    && METHOD_GET_CAPABILITIES.equals(method)) {
+            long startTime = System.currentTimeMillis();
+
+            CloudMediaProviderContract.Capabilities capabilities = onGetCapabilities();
+            result.putParcelable(EXTRA_PROVIDER_CAPABILITIES, capabilities);
+
+            CmpApiVerifier.verifyApiResult(new CmpApiResult(
+                    CmpApiVerifier.CloudMediaProviderApis.OnGetCapabilities, result),
+                    System.currentTimeMillis() - startTime, mAuthority);
         } else {
             throw new UnsupportedOperationException("Method not supported " + method);
         }
@@ -538,6 +917,62 @@ public abstract class CloudMediaProvider extends ContentProvider {
                                 CmpApiVerifier.CloudMediaProviderApis.OnQueryAlbums, result),
                         System.currentTimeMillis() - startTime, mAuthority);
                 break;
+            case MATCH_MEDIA_CATEGORIES:
+                final String parentCategoryId = queryArgs.getString(KEY_PARENT_CATEGORY_ID);
+                queryArgs.remove(KEY_PARENT_CATEGORY_ID);
+                result = onQueryMediaCategories(parentCategoryId, queryArgs, cancellationSignal
+                );
+                CmpApiVerifier.verifyApiResult(new CmpApiResult(
+                                CmpApiVerifier.CloudMediaProviderApis.OnQueryMediaCategories,
+                                result),
+                        System.currentTimeMillis() - startTime, mAuthority);
+                break;
+            case MATCH_MEDIA_SETS:
+                final String mediaCategoryId = queryArgs.getString(KEY_MEDIA_CATEGORY_ID);
+                queryArgs.remove(KEY_MEDIA_CATEGORY_ID);
+                result = onQueryMediaSets(mediaCategoryId, queryArgs, cancellationSignal);
+                CmpApiVerifier.verifyApiResult(new CmpApiResult(
+                                CmpApiVerifier.CloudMediaProviderApis.OnQueryMediaSets,
+                                result),
+                        System.currentTimeMillis() - startTime, mAuthority);
+                break;
+            case MATCH_SEARCH_SUGGESTION:
+                final String prefixText = queryArgs.getString(KEY_PREFIX_TEXT);
+                queryArgs.remove(KEY_PREFIX_TEXT);
+                result = onQuerySearchSuggestions(prefixText, queryArgs, cancellationSignal);
+                CmpApiVerifier.verifyApiResult(new CmpApiResult(
+                                CmpApiVerifier.CloudMediaProviderApis.OnQuerySearchSuggestions,
+                                result),
+                        System.currentTimeMillis() - startTime, mAuthority);
+                break;
+            case MATCH_MEDIAS_IN_MEDIA_SET:
+                final String mediaSetId = queryArgs.getString(KEY_MEDIA_SET_ID);
+                queryArgs.remove(KEY_MEDIA_SET_ID);
+                result = onQueryMediaInMediaSet(mediaSetId, queryArgs, cancellationSignal);
+                CmpApiVerifier.verifyApiResult(new CmpApiResult(
+                                CmpApiVerifier.CloudMediaProviderApis.OnQueryMediaInMediaSet,
+                                result),
+                        System.currentTimeMillis() - startTime, mAuthority);
+                break;
+            case MATCH_SEARCH:
+                final String searchText = queryArgs.getString(KEY_SEARCH_TEXT);
+                queryArgs.remove(KEY_SEARCH_TEXT);
+                final String searchMediaSetId = queryArgs.getString(KEY_MEDIA_SET_ID);
+                queryArgs.remove(KEY_MEDIA_SET_ID);
+                if (searchMediaSetId != null) {
+                    result = onSearchMedia(
+                            searchMediaSetId, searchText, queryArgs, cancellationSignal);
+                } else if (searchText != null) {
+                    result = onSearchMedia(searchText, queryArgs, cancellationSignal);
+                } else {
+                    throw new IllegalArgumentException("both suggested media set id "
+                            + "and search text can not be null together");
+                }
+                CmpApiVerifier.verifyApiResult(new CmpApiResult(
+                                CmpApiVerifier.CloudMediaProviderApis.OnSearchMedia,
+                                result),
+                        System.currentTimeMillis() - startTime, mAuthority);
+                break;
             default:
                 throw new UnsupportedOperationException("Unsupported Uri " + uri);
         }
diff --git a/apex/framework/java/android/provider/CloudMediaProviderContract.java b/apex/framework/java/android/provider/CloudMediaProviderContract.java
index 5e610a86c..3bf0fed96 100644
--- a/apex/framework/java/android/provider/CloudMediaProviderContract.java
+++ b/apex/framework/java/android/provider/CloudMediaProviderContract.java
@@ -16,12 +16,23 @@
 
 package android.provider;
 
+import static java.lang.annotation.RetentionPolicy.SOURCE;
+
+import android.annotation.FlaggedApi;
+import android.annotation.IntDef;
+import android.annotation.NonNull;
+import android.annotation.StringDef;
 import android.app.Activity;
 import android.content.ContentResolver;
 import android.content.Intent;
 import android.database.Cursor;
 import android.os.Bundle;
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import com.android.providers.media.flags.Flags;
 
+import java.lang.annotation.Retention;
 import java.util.UUID;
 
 /**
@@ -51,6 +62,235 @@ public final class CloudMediaProviderContract {
     public static final String MANAGE_CLOUD_MEDIA_PROVIDERS_PERMISSION =
             "com.android.providers.media.permission.MANAGE_CLOUD_MEDIA_PROVIDERS";
 
+    /**
+     * Information about what capabilities a CloudMediaProvider can support. This
+     * will be used by the system to inform which APIs should be expected to return
+     * data. This object is returned from {@link CloudMediaProvider#onGetCapabilities}.
+     *
+     * This object enumerates which capabilities are provided by the
+     * CloudMediaProvider implementation that supplied this object.
+     *
+     * @see CloudMediaProvider#onGetCapabilities()
+     */
+    @FlaggedApi(Flags.FLAG_ENABLE_CLOUD_MEDIA_PROVIDER_CAPABILITIES)
+    public static final class Capabilities implements Parcelable {
+
+        private boolean mSearchEnabled;
+        private boolean mMediaCategoriesEnabled;
+        private boolean mAlbumsAsCategory;
+
+        Capabilities(@NonNull Builder builder) {
+            this.mSearchEnabled = builder.mSearchEnabled;
+            this.mMediaCategoriesEnabled = builder.mMediaCategoriesEnabled;
+            this.mAlbumsAsCategory = builder.mAlbumsAsCategoryEnabled;
+        }
+
+
+        /**
+         * If the CloudMediaProvider supports Search functionality.
+         *
+         * In order for search to be enabled the CloudMediaProvider needs to
+         * implement the following APIs:
+         *
+         * @see CloudMediaProvider#onSearchMedia
+         * @see CloudMediaProvider#onQuerySearchSuggestions
+         *
+         * This capability is disabled by default.
+         *
+         * @return true if search is enabled for this CloudMediaProvider.
+         */
+        @FlaggedApi(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+        public boolean isSearchEnabled() {
+            return mSearchEnabled;
+        }
+
+        /**
+         * If the CloudMediaProvider supports MediaCategories.
+         *
+         * In order for MediaCategories to be enabled the CloudMediaProvider needs to
+         * implement the following APIs:
+         *
+         * @see CloudMediaProvider#onQueryMediaCategories
+         * @see CloudMediaProvider#onQueryMediaSets
+         *
+         * This capability is disabled by default.
+         *
+         * @return true if media categories are enabled for this CloudMediaProvider.
+         */
+        @FlaggedApi(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+        public boolean isMediaCategoriesEnabled() {
+            return mMediaCategoriesEnabled;
+        }
+
+        /**
+        * If the CloudMediaProvider will return user albums as a grouped category.
+        *
+        * When this capability is enabled, {@link CloudMediaProvider#onQueryAlbums} will
+        * no longer be called to sync the users albums, and it is expected that a
+        * category with the type {@link #MEDIA_CATEGORY_TYPE_USER_ALBUMS} will be
+        * provided in the {@link CloudMediaProvider#onQueryMediaCategories} for
+        * providing the user's custom albums. If no such category is returned,
+        * then there will be no data for user custom albums.
+        *
+        * NOTE: This capability requires the
+        * {@link Capabilities#isMediaCategoriesEnabled} capability to also be enabled
+        * for the CloudMediaProvider. If it is not, this Capability has no effect and
+        * will be ignored.
+        *
+        * @see CloudMediaProvider#onQueryMediaCategories
+        * @see #MEDIA_CATEGORY_TYPE_USER_ALBUMS
+        *
+        * This capability is disabled by default.
+        *
+        * @return true if albums will be returned as a MediaCategory.
+        *
+        * @hide
+        */
+        public boolean isAlbumsAsCategoryEnabled() {
+            return mAlbumsAsCategory;
+        }
+
+        /**
+         * Implemented for {@link Parcelable}
+         */
+        @Override
+        public int describeContents() {
+            return 0;
+        }
+
+        /**
+         * Implemented for {@link Parcelable}
+         */
+        @Override
+        public void writeToParcel(@NonNull Parcel dest, int flags) {
+            dest.writeBoolean(mSearchEnabled);
+            dest.writeBoolean(mMediaCategoriesEnabled);
+            dest.writeBoolean(mAlbumsAsCategory);
+        }
+
+        /**
+         * Implemented for {@link Parcelable}
+         */
+        @NonNull
+        public static final Parcelable.Creator<Capabilities> CREATOR =
+                new Parcelable.Creator<Capabilities>() {
+
+                    @NonNull
+                    @Override
+                    public Capabilities createFromParcel(Parcel source) {
+                        boolean searchEnabled = source.readBoolean();
+                        boolean mediaCategoriesEnabled = source.readBoolean();
+                        boolean mAlbumsAsCategoryEnabled = source.readBoolean();
+
+                        Capabilities.Builder builder = new Capabilities.Builder();
+
+                        if (Flags.cloudMediaProviderSearch()) {
+                            builder
+                                    .setSearchEnabled(searchEnabled)
+                                    .setMediaCategoriesEnabled(mediaCategoriesEnabled)
+                                    .setAlbumsAsCategoryEnabled(mAlbumsAsCategoryEnabled);
+                        }
+
+                        return builder.build();
+                    }
+
+                    @NonNull
+                    @Override
+                    public Capabilities[] newArray(int size) {
+                        return new Capabilities[size];
+                    }
+                };
+
+        /**
+         * Builder for a {@link CloudMediaProviderContract.Capabilities} object.
+         *
+         * @see Capabilities
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_CLOUD_MEDIA_PROVIDER_CAPABILITIES)
+        public static final class Builder {
+
+            // Default values for each capability. These are used if not explicitly changed.
+            private boolean mSearchEnabled = false;
+            private boolean mMediaCategoriesEnabled = false;
+            private boolean mAlbumsAsCategoryEnabled = false;
+
+            public Builder() {
+            }
+
+
+            /**
+             * The SearchEnabled capability informs that search related APIs are supported
+             * and can be invoked on this provider.
+             *
+             * @see CloudMediaProvider#onSearchMedia
+             * @see CloudMediaProvider#onQuerySearchSuggestions
+             *
+             * @param enabled true if this capability is supported, the default value is false.
+             */
+            @NonNull
+            @FlaggedApi(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+            public Builder setSearchEnabled(boolean enabled) {
+                mSearchEnabled = enabled;
+                return this;
+            }
+
+            /**
+             * The MediaCategories capability informs that category related APIs are
+             * supported and can be invoked on this provider.
+             *
+             * @see CloudMediaProvider#onQueryMediaCategories
+             * @see CloudMediaProvider#onQueryMediaSets
+             *
+             * @param enabled true if this capability is supported, the default value is false.
+             */
+            @NonNull
+            @FlaggedApi(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+            public Builder setMediaCategoriesEnabled(boolean enabled) {
+                mMediaCategoriesEnabled = enabled;
+                return this;
+            }
+
+            /**
+             * If the CloudMediaProvider will return user albums as a grouped category.
+             *
+             * When this capability is enabled, {@link CloudMediaProvider#onQueryAlbums} will
+             * no longer be called to sync the users albums, and it is expected that a
+             * category with the type {@link #MEDIA_CATEGORY_TYPE_USER_ALBUMS} will be
+             * provided in the {@link CloudMediaProvider#onQueryMediaCategories} for
+             * providing the user's custom albums. If no such category is returned,
+             * then there will be no data for user custom albums.
+             *
+             * NOTE: This capability requires the
+             * {@link Capabilities#isMediaCategoriesEnabled} capability to also be enabled
+             * for the CloudMediaProvider. If it is not, this Capability has no effect and
+             * will be ignored.
+             *
+             * @see CloudMediaProvider#onQueryMediaCategories
+             * @see #MEDIA_CATEGORY_TYPE_USER_ALBUMS
+             *
+             * @param enabled true if this capability is supported, the default value is false.
+             *
+             * @hide
+             */
+            @NonNull
+            public Builder setAlbumsAsCategoryEnabled(boolean enabled) {
+                mAlbumsAsCategoryEnabled = enabled;
+                return this;
+            }
+
+            /**
+             * Create a new {@link CloudMediaProviderContract.Capabilities} object with the
+             * current builder's Capabilities.
+             */
+            @NonNull
+            public Capabilities build() {
+                return new Capabilities(this);
+            }
+
+        }
+
+    }
+
     /** Constants related to a media item, including {@link Cursor} column names */
     public static final class MediaColumns {
         private MediaColumns() {}
@@ -592,6 +832,37 @@ public final class CloudMediaProviderContract {
     public static final String EXTRA_PREVIEW_THUMBNAIL =
             "android.provider.extra.PREVIEW_THUMBNAIL";
 
+    /**
+     * Extra used to specify the sorting behavior when querying from {@link CloudMediaProvider}.
+     * The value associated with this extra should be one of the integer constants
+     * defined in the {@link SortOrders}.
+     * <p>
+     * Type: INTEGER
+     *
+     * @see CloudMediaProvider#onSearchMedia
+     */
+    @FlaggedApi(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+    public static final String EXTRA_SORT_ORDER = "android.provider.extra.SORT_ORDER";
+
+    /**
+     * Sort items in descending order by the {@code DATE_TAKEN_MILLIS}.
+     * <p>
+     * This means the most recently taken photos or videos will appear first.
+     * <p>
+     * Type: INTEGER
+     */
+    @FlaggedApi(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+    public static final int SORT_ORDER_DESC_DATE_TAKEN = 1;
+
+    /**
+     * Defines integer constants to be used with the {@link #EXTRA_SORT_ORDER} extra
+     * for specifying the sorting order of media items.
+     * @hide
+     */
+    @IntDef(value = {SORT_ORDER_DESC_DATE_TAKEN})
+    @Retention(SOURCE)
+    public @interface SortOrder {}
+
     /**
      * A boolean to indicate {@link com.android.providers.media.photopicker.PhotoPickerProvider}
      * this request is requesting a cached thumbnail file from MediaStore.
@@ -671,6 +942,23 @@ public final class CloudMediaProviderContract {
     public static final String METHOD_GET_ASYNC_CONTENT_PROVIDER =
             "android:getAsyncContentProvider";
 
+    /**
+     * Constant used to execute {@link CloudMediaProvider#onGetCapabilities()} via
+     * {@link android.content.ContentProvider#call}.
+     *
+     * {@hide}
+     */
+    public static final String METHOD_GET_CAPABILITIES = "android:getCapabilities";
+
+    /**
+     * Constant used to get/set {@link Capabilities} in {@link Bundle}.
+     *
+     * {@hide}
+     */
+    public static final String EXTRA_PROVIDER_CAPABILITIES =
+            "android.provider.extra.PROVIDER_CAPABILITIES";
+
+
     /**
      * Constant used to get/set {@link IAsyncContentProvider} in {@link Bundle}.
      *
@@ -734,4 +1022,468 @@ public final class CloudMediaProviderContract {
      * {@hide}
      */
     public static final String URI_PATH_SURFACE_CONTROLLER = "surface_controller";
+
+    /**
+     * URI path for {@link CloudMediaProvider#onQueryMediaCategories}
+     *
+     * @hide
+     */
+    public static final String URI_PATH_MEDIA_CATEGORY = "media_category";
+
+    /**
+     * URI path for {@link CloudMediaProvider#onQueryMediaSets}
+     *
+     * @hide
+     */
+    public static final String URI_PATH_MEDIA_SET = "media_set";
+
+    /**
+     * URI path for {@link CloudMediaProvider#onQuerySearchSuggestions}
+     *
+     * @hide
+     */
+    public static final String URI_PATH_SEARCH_SUGGESTION = "search_suggestion";
+
+    /**
+     * URI path for {@link CloudMediaProvider#onSearchMedia}
+     *
+     * @hide
+     */
+    public static final String URI_PATH_SEARCH_MEDIA = "search_media";
+
+    /**
+     * URI path for {@link CloudMediaProvider#onQueryMediaInMediaSet}
+     *
+     * @hide
+     */
+    public static final String URI_PATH_MEDIA_IN_MEDIA_SET =
+            "query_media_in_media_set";
+
+    /**
+     * Key for passing parent category Id as a parameter in the bundle
+     *
+     * @hide
+     */
+    public static final String KEY_PARENT_CATEGORY_ID = "parent_category_id";
+
+    /**
+     * Key for passing media category Id as a parameter in the bundle
+     *
+     * @hide
+     */
+    public static final String KEY_MEDIA_CATEGORY_ID = "media_category_id";
+
+    /**
+     * Key for passing media set Id as a parameter in the bundle
+     *
+     * @hide
+     */
+    public static final String KEY_MEDIA_SET_ID = "media_set_id";
+
+    /**
+     * Key for passing prefix text as a parameter in the bundle
+     *
+     * @hide
+     */
+    public static final String KEY_PREFIX_TEXT = "prefix_text";
+
+    /**
+     * Key for passing search query as a parameter in the bundle
+     *
+     * @hide
+     */
+    public static final String KEY_SEARCH_TEXT = "search_text";
+
+    /**
+     * MediaSet represents a cohesive collection of related unique media items,
+     * sharing a common meaningful context or theme.
+     * This is the basic and fundamental unit for organizing related media items.
+     *
+     * MediaSet in this context is represented
+     * by a set of columns present in {@link MediaSetColumns}
+     *
+     * Examples of media sets include:
+     * <ul>
+     *   <li>Faces of the same person</li>
+     *   <li>Photos of a specific location</li>
+     *   <li>All media as a search result to mountains</li>
+     * </ul>
+     *
+     *  Note: {@link AlbumColumns} which denotes an album can also be represented
+     *  using {@link MediaSetColumns}. But, it is recommended to keep using {@link AlbumColumns}
+     *  for existing user albums and use MediaSet only for supported MediaCategories .
+     *
+     * The currently supported MediaCategory in photo picker are
+     * {@link #MEDIA_CATEGORY_TYPE_PEOPLE_AND_PETS}.
+     *
+     * These are the fields of a MediaSet.
+     *
+     * @see MediaCategoryColumns
+     */
+    @FlaggedApi(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+    public static final class MediaSetColumns {
+
+        private MediaSetColumns() {}
+
+        /**
+         * Unique ID of the media set. This ID is both provided by and interpreted
+         * by the {@link CloudMediaProvider}.
+         *
+         * Each media set must have a unique ID.
+         *
+         * A provider should return IDs which are stable,
+         * meaning it remains the same if nothing inside it changes,
+         * since they will be used to cache media set information in the OS.
+         *
+         * Type: STRING
+         */
+        public static final String ID = "id";
+
+        /**
+         * Display name of the media set.
+         * This display name provided should match the current devices locale settings.
+         * If there is no display name, pass {@code null} in this column.
+         *
+         * Type: STRING
+         */
+        public static final String DISPLAY_NAME = "display_name";
+
+        /**
+         * Total count of all media within the media set, including photos and videos.
+         *
+         * If this field is not provided,
+         * media sets will be shown without a count in the Photo Picker.
+         *
+         * Type: LONG
+         */
+        public static final String MEDIA_COUNT = "media_count";
+
+        /**
+         * Media ID to use as the media set cover photo.
+         *
+         * If this field is not provided,
+         * media sets will be shown in the Photo Picker with a default icon.
+         *
+         * Type: STRING
+         *
+         * @see CloudMediaProviderContract.MediaColumns#ID
+         */
+        public static final String MEDIA_COVER_ID = "media_cover_id";
+
+        /**
+         * Contains all column names for {@link MediaSetColumns} as an array.
+         * @hide
+         */
+        public static final String[] ALL_PROJECTION = new String[] {
+                MediaSetColumns.ID,
+                MediaSetColumns.DISPLAY_NAME,
+                MediaSetColumns.MEDIA_COUNT,
+                MediaSetColumns.MEDIA_COVER_ID
+        };
+    }
+
+    /**
+     * MediaCategory represents a broader structure
+     * that a {@link MediaSetColumns} or another {@link MediaCategoryColumns} belongs to.
+     *
+     * A MediaCategory in this context is represented by a set of columns present in
+     * {@link MediaCategoryColumns}
+     *
+     * A MediaCategory can have instances of other MediaCategories
+     * to support a multilevel hierarchy.
+     * Examples of MediaCategory:
+     * <ul>
+     *   <li>A MediaCategory of people and pet faces which contains instances of MediaSets
+     *   for different faces</li>
+     *   <li>A MediaCategory of locations which contains instances of MediaSets for
+     *   different locations</li>
+     * </ul>
+     *
+     * The currently supported MediaCategory in photo picker are
+     * {@link #MEDIA_CATEGORY_TYPE_PEOPLE_AND_PETS}.
+     *
+     * These are the fields of MediaCategory.
+     * @see CloudMediaProvider#onQueryMediaCategories
+     */
+    @FlaggedApi(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+    public static final class MediaCategoryColumns {
+
+        private MediaCategoryColumns() {}
+
+        /**
+         * The unique identifier of the media category.
+         * This ID is both provided by and interpreted by the {@link CloudMediaProvider}.
+         *
+         * A provider should return IDs which are stable,
+         * meaning it remains the same if nothing inside it changes,
+         * since they will be used to cache information in the OS.
+         *
+         * Type: STRING
+         */
+        public static final String ID = "id";
+
+        /**
+         * The display name of the media category.
+         * This display name provided should match the current devices locale settings.
+         *
+         * If there is no display name, pass {@code null} in this column.
+         *
+         * Type: STRING
+         */
+        public static final String DISPLAY_NAME = "display_name";
+
+        /**
+         * The type of the media category.
+         * This must contain one of the values from the supported media category types.
+         * Currently supported types are:
+         *      {@link #MEDIA_CATEGORY_TYPE_PEOPLE_AND_PETS}
+         *      {@link #MEDIA_CATEGORY_TYPE_USER_ALBUMS}
+         *
+         * Type: INTEGER
+         */
+        public static final String MEDIA_CATEGORY_TYPE = "media_category_type";
+
+        /**
+         * The first cover media ID for displaying.
+         * <p>
+         * If none of the MEDIA_COVER_ID is provided,
+         * media category will be shown in the Photo Picker with a default icon.
+         * Otherwise, Photo Picker will show as many MEDIA_COVER_IDs as provided.
+         * <p>
+         * Type: STRING
+         */
+        public static final String MEDIA_COVER_ID1 = "media_cover_id1";
+
+        /**
+         * The second cover media ID for displaying.
+         * <p>
+         * If none of the MEDIA_COVER_ID is provided,
+         * media category will be shown in the Photo Picker with a default icon.
+         * Otherwise, Photo Picker will show as many MEDIA_COVER_IDs as provided.
+         * <p>
+         * Type: STRING
+         */
+        public static final String MEDIA_COVER_ID2 = "media_cover_id2";
+
+        /**
+         * The third cover media ID for displaying.
+         * <p>
+         * If none of the MEDIA_COVER_ID is provided,
+         * media category will be shown in the Photo Picker with a default icon.
+         * Otherwise, Photo Picker will show as many MEDIA_COVER_IDs as provided.
+         * <p>
+         * Type: STRING
+         */
+        public static final String MEDIA_COVER_ID3 = "media_cover_id3";
+
+        /**
+         * The fourth cover media ID for displaying.
+         * <p>
+         * If none of the MEDIA_COVER_ID is provided,
+         * media category will be shown in the Photo Picker with a default icon.
+         * Otherwise, Photo Picker will show as many MEDIA_COVER_IDs as provided.
+         * <p>
+         * Type: STRING
+         */
+        public static final String MEDIA_COVER_ID4 = "media_cover_id4";
+
+        /**
+         * Contains all column names for {@link MediaCategoryColumns} as an array.
+         *
+         * @hide
+         */
+        public static final String[] ALL_PROJECTION = new String[] {
+                MediaCategoryColumns.ID,
+                MediaCategoryColumns.DISPLAY_NAME,
+                MediaCategoryColumns.MEDIA_CATEGORY_TYPE,
+                MediaCategoryColumns.MEDIA_COVER_ID1,
+                MediaCategoryColumns.MEDIA_COVER_ID2,
+                MediaCategoryColumns.MEDIA_COVER_ID3,
+                MediaCategoryColumns.MEDIA_COVER_ID4
+        };
+
+    }
+
+    /**
+     * Represents media category related to faces of people and pets.
+     * @see MediaCategoryColumns#MEDIA_CATEGORY_TYPE
+     * Type: STRING
+     */
+    @FlaggedApi(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+    public static final String MEDIA_CATEGORY_TYPE_PEOPLE_AND_PETS =
+            "com.android.providers.media.MEDIA_CATEGORY_TYPE_PEOPLE_AND_PETS";
+
+    /**
+     * Represents media category related to a user's custom albums.
+     * @see MediaCategoryColumns#MEDIA_CATEGORY_TYPE
+     * Type: STRING
+     *
+     * @hide
+     */
+    public static final String MEDIA_CATEGORY_TYPE_USER_ALBUMS =
+            "com.android.providers.media.MEDIA_CATEGORY_TYPE_USER_ALBUMS";
+
+    /**
+     * Defines the types of media categories available and supported in photo picker.
+     * All MediaCategories returned must be of any type from the fields available in this class.
+     *
+     * @see MediaCategoryColumns#MEDIA_CATEGORY_TYPE
+     * @hide
+     */
+    @StringDef(value = {
+            MEDIA_CATEGORY_TYPE_PEOPLE_AND_PETS,
+            MEDIA_CATEGORY_TYPE_USER_ALBUMS
+    })
+    @Retention(SOURCE)
+    public @interface MediaCategoryType {}
+
+    /**
+     * Represents a search suggestion provided by the {@link CloudMediaProvider}.
+     * This is based on the user entered query.
+     * When the input query is empty (zero state), the provider can still return suggestions.
+     * Photo picker will show these zero state suggestions to the user,
+     * when nothing has been typed for search.
+     *
+     * This class contains the fields of SearchSuggestion.
+     *
+     * @see CloudMediaProvider#onQuerySearchSuggestions
+     */
+    @FlaggedApi(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+    public static final class SearchSuggestionColumns {
+
+        private SearchSuggestionColumns() {}
+
+        /**
+         * The unique identifier of the media set associated with the search suggestion.
+         * This will be used to query media items if user clicked on this suggestion.
+         *
+         * <p>
+         * Type: STRING
+         *
+         * @see MediaSetColumns#ID
+         */
+        public static final String MEDIA_SET_ID = "media_set_id";
+        /**
+         * The display text for the search suggestion.
+         * <p>
+         * This is the text shown to the user as a suggestion.
+         * Display text provided should match the current devices locale settings.
+         *
+         * If no display text, pass {@code null} in this column.
+         *
+         * <p>
+         * Type: STRING
+         */
+        public static final String DISPLAY_TEXT = "display_text";
+        /**
+         * The type of the search suggestion.
+         * <p>
+         * This must contain one of the values from various supported search suggestion types.
+         * These are: {@link #SEARCH_SUGGESTION_TEXT},  {@link #SEARCH_SUGGESTION_FACE},
+         *  {@link #SEARCH_SUGGESTION_DATE},  {@link #SEARCH_SUGGESTION_LOCATION},
+         *  {@link #SEARCH_SUGGESTION_ALBUM}
+         * <p>
+         * This will be used to display to user different suggestions in different way.
+         * As examples: for Location type, a thumbnail of location will be used.
+         * For faces, face cover id (if provided) will be used.
+         * Type: INTEGER
+         */
+        public static final String TYPE = "type";
+
+        /**
+         * Media ID to use as the cover image for the search suggestion.
+         * <p>
+         * If this field is not provided,
+         * the search suggestion will be shown with a default cover.
+         * <p>
+         * Type: LONG
+         */
+        public static final String MEDIA_COVER_ID = "media_cover_id";
+
+        /**
+         * Contains all column names for {@link SearchSuggestionColumns} as an array.
+         *
+         * @hide
+         */
+        public static final String[] ALL_PROJECTION = new String[] {
+                SearchSuggestionColumns.MEDIA_SET_ID,
+                SearchSuggestionColumns.DISPLAY_TEXT,
+                SearchSuggestionColumns.TYPE,
+                SearchSuggestionColumns.MEDIA_COVER_ID
+        };
+    }
+
+    /**
+     * Represents a generic text search suggestion. This can be treated as a default when the type
+     * of search suggestions is unknown.
+     * @see SearchSuggestionColumns#TYPE
+     * Type: STRING
+     */
+    @FlaggedApi(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+    public static final String SEARCH_SUGGESTION_TEXT =
+            "com.android.providers.media.SEARCH_SUGGESTION_TEXT";
+
+    /**
+     * Suggestion based on faces detected in photos.
+     * @see SearchSuggestionColumns#TYPE
+     * Type: STRING
+     */
+    @FlaggedApi(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+    public static final String SEARCH_SUGGESTION_FACE =
+            "com.android.providers.media.SEARCH_SUGGESTION_FACE";
+
+    /**
+     * Suggestion based on location data associated with photos.
+     * @see SearchSuggestionColumns#TYPE
+     * Type: STRING
+     */
+    @FlaggedApi(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+    public static final String SEARCH_SUGGESTION_LOCATION =
+            "com.android.providers.media.SEARCH_SUGGESTION_LOCATION";
+
+    /**
+     * Suggestion based on the date photos were taken.
+     * @see SearchSuggestionColumns#TYPE
+     * Type: STRING
+     */
+    @FlaggedApi(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+    public static final String SEARCH_SUGGESTION_DATE =
+            "com.android.providers.media.SEARCH_SUGGESTION_DATE";
+
+
+    /**
+     * Suggestion based on user albums.
+     * @see SearchSuggestionColumns#TYPE
+     * Type: STRING
+     */
+    @FlaggedApi(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+    public static final String SEARCH_SUGGESTION_ALBUM =
+            "com.android.providers.media.SEARCH_SUGGESTION_ALBUM";
+
+    /**
+     * Suggestion based on user's search history.
+     * @see SearchSuggestionColumns#TYPE
+     * Type: STRING
+     *
+     * @hide
+     */
+    public static final String SEARCH_SUGGESTION_HISTORY =
+            "com.android.providers.media.SEARCH_SUGGESTION_HISTORY";
+
+    /**
+     * Defines the different types of search suggestions available and supported in photo picker.
+     *
+     * @see SearchSuggestionColumns#TYPE
+     * @hide
+     */
+    @StringDef(value = {
+            SEARCH_SUGGESTION_TEXT,
+            SEARCH_SUGGESTION_FACE,
+            SEARCH_SUGGESTION_LOCATION,
+            SEARCH_SUGGESTION_DATE,
+            SEARCH_SUGGESTION_ALBUM,
+            SEARCH_SUGGESTION_HISTORY
+    })
+    @Retention(SOURCE)
+    public @interface SearchSuggestionType {}
 }
diff --git a/apex/framework/java/android/provider/CmpApiVerifier.java b/apex/framework/java/android/provider/CmpApiVerifier.java
index dc948d4f1..592246e84 100644
--- a/apex/framework/java/android/provider/CmpApiVerifier.java
+++ b/apex/framework/java/android/provider/CmpApiVerifier.java
@@ -36,10 +36,13 @@ import android.os.ParcelFileDescriptor;
 import android.os.SystemProperties;
 import android.util.Log;
 
+import com.android.providers.media.flags.Flags;
+
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
@@ -77,6 +80,10 @@ final class CmpApiVerifier {
                         CMP_API_TO_THRESHOLD_MAP.get(result.getApi()), errors);
 
                 switch (result.getApi()) {
+                    case CloudMediaProviderApis.OnGetCapabilities: {
+                        verifyOnGetCapabilities(result.getBundle(), verificationResult, errors);
+                        break;
+                    }
                     case CloudMediaProviderApis.OnGetMediaCollectionInfo: {
                         verifyOnGetMediaCollectionInfo(result.getBundle(), verificationResult,
                                 errors);
@@ -104,6 +111,30 @@ final class CmpApiVerifier {
                                 errors);
                         break;
                     }
+                    case CloudMediaProviderApis.OnQueryMediaCategories: {
+                        verifyOnQueryMediaCategories(result.getCursor(),
+                                verificationResult, errors);
+                        break;
+                    }
+                    case CloudMediaProviderApis.OnQueryMediaSets: {
+                        verifyOnQueryMediaSets(result.getCursor(),
+                                verificationResult, errors);
+                        break;
+                    }
+                    case CloudMediaProviderApis.OnQuerySearchSuggestions: {
+                        verifyOnQuerySearchSuggestions(result.getCursor(),
+                                verificationResult, errors);
+                        break;
+                    }
+                    case CloudMediaProviderApis.OnSearchMedia: {
+                        verifyOnSearchMedia(result.getCursor(),
+                                verificationResult, errors);
+                        break;
+                    }
+                    case CloudMediaProviderApis.OnQueryMediaInMediaSet: {
+                        verifyOnQueryMediaInMediaSet(result.getCursor(),
+                                verificationResult, errors);
+                    }
                     default:
                         throw new UnsupportedOperationException(
                                 "The verification for requested API is not supported.");
@@ -116,6 +147,44 @@ final class CmpApiVerifier {
         }
     }
 
+    /**
+     * Verifies the {@link CloudMediaProvider#onGetCapabilities()} API.
+     *
+     * Verifies the Capabilities object returned is non-null.
+     */
+    static void verifyOnGetCapabilities(
+            Bundle outputBundle, List<String> verificationResult, List<String> errors) {
+
+        // Only Verify if the flag for capabilities is on.
+        if (Flags.enableCloudMediaProviderCapabilities()) {
+
+            if (outputBundle != null
+                    && outputBundle.containsKey(
+                            CloudMediaProviderContract.EXTRA_PROVIDER_CAPABILITIES)) {
+
+                verificationResult.add("Capabilities is present.");
+
+                CloudMediaProviderContract.Capabilities capabilities = outputBundle
+                        .getParcelable(CloudMediaProviderContract.EXTRA_PROVIDER_CAPABILITIES);
+
+                // Verify CMP search capabilities if the search flag is on.
+                if (Flags.cloudMediaProviderSearch()) {
+                    if (capabilities.isAlbumsAsCategoryEnabled()
+                            && !capabilities.isMediaCategoriesEnabled()) {
+                        errors.add(createIsNotValidLog("Declared capabilities are invalid. "
+                                + "AlbumsAsCategory capability can only be enabled when "
+                                + "MediaCollections is enabled."));
+                    } else {
+                        verificationResult.add("Declared Capabilities are valid.");
+                    }
+
+                }
+            } else {
+                errors.add(createIsNullLog("Capabilities were not returned by OnGetCapabilities"));
+            }
+        }
+    }
+
     /**
      * Verifies OnGetMediaCollectionInfo API by performing and logging the following checks:
      *
@@ -314,6 +383,135 @@ final class CmpApiVerifier {
         }
     }
 
+    /**
+     * Verifies OnQueryMediaCategories API by performing and logging the following checks:
+     *
+     * <ul>
+     * <li>Received Cursor is not null.</li>
+     * <li>Cursor contains non empty media collection ID:
+     * {@link CloudMediaProviderContract#EXTRA_MEDIA_COLLECTION_ID}</li>
+     * <li>Projection for cursor is as expected:
+     * {@link CloudMediaProviderContract.MediaCategoryColumns#ALL_PROJECTION}</li>
+     * </ul>
+     */
+    static void verifyOnQueryMediaCategories(
+            Cursor cursor, List<String> verificationResult, List<String> errors
+    ) {
+        verifyCursorNotNullAndMediaCollectionIdPresent(cursor, verificationResult, errors);
+        if (cursor != null && Flags.cloudMediaProviderSearch()) {
+
+            verifyProjectionForCursor(
+                    cursor,
+                    Arrays.asList(CloudMediaProviderContract.MediaCategoryColumns.ALL_PROJECTION),
+                    errors
+            );
+        }
+    }
+
+    /**
+     * Verifies OnQueryMediaSets API by performing and logging the following checks:
+     *
+     * <ul>
+     * <li>Received Cursor is not null.</li>
+     * <li>Cursor contains non empty media collection ID:
+     * {@link CloudMediaProviderContract#EXTRA_MEDIA_COLLECTION_ID}</li>
+     * <li>Projection for cursor is as expected:
+     * {@link CloudMediaProviderContract.MediaSetColumns#ALL_PROJECTION}</li>
+     * </ul>
+     */
+    static void verifyOnQueryMediaSets(
+            Cursor cursor, List<String> verificationResult, List<String> errors
+    ) {
+        verifyCursorNotNullAndMediaCollectionIdPresent(cursor, verificationResult, errors);
+        if (cursor != null && Flags.cloudMediaProviderSearch()) {
+
+            verifyProjectionForCursor(
+                    cursor,
+                    Arrays.asList(CloudMediaProviderContract.MediaSetColumns.ALL_PROJECTION),
+                    errors
+            );
+        }
+    }
+
+    /**
+     * Verifies OnQuerySearchSuggestions API by performing and logging the following checks:
+     *
+     * <ul>
+     * <li>Received Cursor is not null.</li>
+     * <li>Cursor contains non empty media collection ID:
+     * {@link CloudMediaProviderContract#EXTRA_MEDIA_COLLECTION_ID}</li>
+     * <li>Projection for cursor is as expected:
+     * {@link CloudMediaProviderContract.SearchSuggestionColumns#ALL_PROJECTION}</li>
+     * </ul>
+     */
+    static void verifyOnQuerySearchSuggestions(
+            Cursor cursor, List<String> verificationResult, List<String> errors
+    ) {
+        verifyCursorNotNullAndMediaCollectionIdPresent(cursor, verificationResult, errors);
+        if (cursor != null && Flags.cloudMediaProviderSearch()) {
+
+            verifyProjectionForCursor(
+                    cursor,
+                    Arrays.asList(
+                            CloudMediaProviderContract.SearchSuggestionColumns.ALL_PROJECTION),
+                    errors
+            );
+        }
+    }
+
+    /**
+     * Verifies OnSearchMedia API by performing and logging the following checks:
+     *
+     * <ul>
+     * <li>Received Cursor is not null.</li>
+     * <li>Cursor contains non empty media collection ID:
+     * {@link CloudMediaProviderContract#EXTRA_MEDIA_COLLECTION_ID}</li>
+     * <li>Projection for cursor is as expected:
+     * {@link CloudMediaProviderContract.MediaColumns#ALL_PROJECTION}</li>
+     * </ul>
+     */
+    static void verifyOnSearchMedia(
+            Cursor cursor, List<String> verificationResult, List<String> errors
+    ) {
+        verifyCursorNotNullAndMediaCollectionIdPresent(cursor, verificationResult, errors);
+        if (cursor != null && Flags.cloudMediaProviderSearch()) {
+
+            verifyProjectionForCursor(
+                    cursor,
+                    Arrays.asList(
+                            CloudMediaProviderContract.MediaColumns.ALL_PROJECTION),
+                    errors
+            );
+        }
+    }
+
+    /**
+     * Verifies OnQueryMediaInMediaSet by performing and logging the following checks:
+     *
+     * <ul>
+     * <li>Received Cursor is not null.</li>
+     * <li>Cursor contains non empty media collection ID:
+     * {@link CloudMediaProviderContract#EXTRA_MEDIA_COLLECTION_ID}</li>
+     * <li>Projection for cursor is as expected:
+     * {@link CloudMediaProviderContract.MediaColumns#ALL_PROJECTION}</li>
+     * </ul>
+     */
+    static void verifyOnQueryMediaInMediaSet(
+            Cursor cursor, List<String> verificationResult, List<String> errors
+    ) {
+        verifyCursorNotNullAndMediaCollectionIdPresent(cursor, verificationResult, errors);
+        if (cursor != null && Flags.cloudMediaProviderSearch()) {
+
+            verifyProjectionForCursor(
+                    cursor,
+                    Arrays.asList(
+                            CloudMediaProviderContract.MediaColumns.ALL_PROJECTION),
+                    errors
+            );
+        }
+    }
+
+
 
     /**
      * Verifies OnOpenPreview API by performing and logging the following checks:
@@ -364,29 +562,48 @@ final class CmpApiVerifier {
     }
 
     @StringDef({
+            CloudMediaProviderApis.OnGetCapabilities,
             CloudMediaProviderApis.OnGetMediaCollectionInfo,
             CloudMediaProviderApis.OnQueryMedia,
             CloudMediaProviderApis.OnQueryDeletedMedia,
             CloudMediaProviderApis.OnQueryAlbums,
             CloudMediaProviderApis.OnOpenPreview,
-            CloudMediaProviderApis.OnOpenMedia
+            CloudMediaProviderApis.OnOpenMedia,
+            CloudMediaProviderApis.OnQueryMediaCategories,
+            CloudMediaProviderApis.OnQueryMediaSets,
+            CloudMediaProviderApis.OnQuerySearchSuggestions,
+            CloudMediaProviderApis.OnSearchMedia,
+            CloudMediaProviderApis.OnQueryMediaInMediaSet,
     })
     @Retention(RetentionPolicy.SOURCE)
     @interface CloudMediaProviderApis {
+        String OnGetCapabilities = "OnGetCapabilities";
         String OnGetMediaCollectionInfo = "onGetMediaCollectionInfo";
         String OnQueryMedia = "onQueryMedia";
         String OnQueryDeletedMedia = "onQueryDeletedMedia";
         String OnQueryAlbums = "onQueryAlbums";
         String OnOpenPreview = "onOpenPreview";
         String OnOpenMedia = "onOpenMedia";
+        String OnQueryMediaCategories = "onQueryMediaCategories";
+        String OnQueryMediaSets = "onQueryMediaSets";
+        String OnQuerySearchSuggestions = "onQuerySearchSuggestions";
+        String OnSearchMedia = "onSearchMedia";
+        String OnQueryMediaInMediaSet = "onQueryMediaInMediaSet";
     }
 
-    private static final Map<String, Long> CMP_API_TO_THRESHOLD_MAP = Map.of(
-            CloudMediaProviderApis.OnGetMediaCollectionInfo, 200L,
-            CloudMediaProviderApis.OnQueryMedia, 500L,
-            CloudMediaProviderApis.OnQueryDeletedMedia, 500L,
-            CloudMediaProviderApis.OnQueryAlbums, 500L,
-            CloudMediaProviderApis.OnOpenPreview, 1000L,
-            CloudMediaProviderApis.OnOpenMedia, 1000L
-    );
+    private static final Map<String, Long> CMP_API_TO_THRESHOLD_MAP = new HashMap<>(Map.ofEntries(
+            Map.entry(CloudMediaProviderApis.OnGetCapabilities, 200L),
+            Map.entry(CloudMediaProviderApis.OnGetMediaCollectionInfo, 200L),
+            Map.entry(CloudMediaProviderApis.OnQueryMedia, 500L),
+            Map.entry(CloudMediaProviderApis.OnQueryDeletedMedia, 500L),
+            Map.entry(CloudMediaProviderApis.OnQueryAlbums, 500L),
+            Map.entry(CloudMediaProviderApis.OnOpenPreview, 1000L),
+            Map.entry(CloudMediaProviderApis.OnOpenMedia, 1000L),
+            Map.entry(CloudMediaProviderApis.OnQueryMediaCategories, 500L),
+            Map.entry(CloudMediaProviderApis.OnQueryMediaSets, 500L),
+            Map.entry(CloudMediaProviderApis.OnQuerySearchSuggestions, 300L),
+            Map.entry(CloudMediaProviderApis.OnSearchMedia, 3000L),
+            Map.entry(CloudMediaProviderApis.OnQueryMediaInMediaSet, 500L)
+    ));
+
 }
diff --git a/apex/framework/java/android/provider/MediaStore.java b/apex/framework/java/android/provider/MediaStore.java
index 50c242404..1b8d50152 100644
--- a/apex/framework/java/android/provider/MediaStore.java
+++ b/apex/framework/java/android/provider/MediaStore.java
@@ -198,6 +198,8 @@ public final class MediaStore {
     /** {@hide} */
     public static final String CREATE_FAVORITE_REQUEST_CALL = "create_favorite_request";
     /** {@hide} */
+    public static final String MARK_MEDIA_AS_FAVORITE = "mark_media_as_favorite";
+    /** {@hide} */
     public static final String CREATE_DELETE_REQUEST_CALL = "create_delete_request";
 
     /** {@hide} */
@@ -332,6 +334,16 @@ public final class MediaStore {
     /** {@hide} */
     public static final String PICKER_MEDIA_INIT_CALL = "picker_media_init";
     /** {@hide} */
+    public static final String PICKER_INTERNAL_SEARCH_MEDIA_INIT_CALL =
+            "picker_internal_search_media_init";
+    /** {@hide} */
+    public static final String PICKER_MEDIA_SETS_INIT_CALL =
+            "picker_media_sets_init_call";
+    /** {@hide} */
+    public static final String PICKER_TRANSCODE_CALL = "picker_transcode";
+    /** {@hide} */
+    public static final String PICKER_TRANSCODE_RESULT = "picker_transcode_result";
+    /** {@hide} */
     public static final String EXTRA_LOCAL_ONLY = "is_local_only";
     /** {@hide} */
     public static final String EXTRA_ALBUM_ID = "album_id";
@@ -705,6 +717,56 @@ public final class MediaStore {
     public static final String ACTION_IMAGE_CAPTURE_SECURE =
             "android.media.action.IMAGE_CAPTURE_SECURE";
 
+    /**
+     * Standard Intent action that can be sent to have the camera application
+     * capture a
+     * <a href="{@docRoot}media/platform/motion-photo-format">motion photo</a> and
+     * return it.
+     * <p>
+     * The caller must either pass an extra EXTRA_OUTPUT to control where the image will be written,
+     * or a uri through {@link android.content.Intent#setClipData(ClipData)}. If you don't set a
+     * ClipData, it will be copied there for you when calling {@link Context#startActivity(Intent)}.
+     * <p>
+     * When an image is captured via this intent, {@link android.hardware.Camera#ACTION_NEW_PICTURE}
+     * won't be broadcasted.
+     * <p>
+     * Note: If your app declares as using the {@link android.Manifest.permission#CAMERA} permission
+     * which is not granted, then attempting to use this action will result in a {@link
+     * java.lang.SecurityException}.
+     *
+     * @see #EXTRA_OUTPUT
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    @FlaggedApi(com.android.providers.media.flags.Flags.FLAG_MOTION_PHOTO_INTENT)
+    public static final String ACTION_MOTION_PHOTO_CAPTURE =
+            "android.provider.action.MOTION_PHOTO_CAPTURE";
+
+    /**
+     * Intent action that can be sent to have the camera application capture a
+     * <a href="{@docRoot}media/platform/motion-photo-format">motion photo</a> and
+     * return it when the device is secured (e.g. with a pin, password, pattern, or face unlock).
+     * Applications responding to this intent must not expose any personal content like existing
+     * photos or videos on the device. The applications should be careful not to share any photo
+     * or video with other applications or Internet. The activity should use {@link
+     * Activity#setShowWhenLocked} to display on top of the
+     * lock screen while secured. There is no activity stack when this flag is used, so
+     * launching more than one activity is strongly discouraged.
+     * <p>
+     * The caller must either pass an extra EXTRA_OUTPUT to control where the image will be written,
+     * or a uri through {@link android.content.Intent#setClipData(ClipData)}. If you don't set a
+     * ClipData, it will be copied there for you when calling {@link Context#startActivity(Intent)}.
+     * <p>
+     * When an image is captured via this intent, {@link android.hardware.Camera#ACTION_NEW_PICTURE}
+     * won't be broadcasted.
+     *
+     * @see #ACTION_MOTION_PHOTO_CAPTURE
+     * @see #EXTRA_OUTPUT
+     */
+    @SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)
+    @FlaggedApi(com.android.providers.media.flags.Flags.FLAG_MOTION_PHOTO_INTENT)
+    public static final String ACTION_MOTION_PHOTO_CAPTURE_SECURE =
+            "android.provider.action.MOTION_PHOTO_CAPTURE_SECURE";
+
     /**
      * Standard Intent action that can be sent to have the camera application
      * capture a video and return it.
@@ -837,6 +899,14 @@ public final class MediaStore {
      * is returned. Use {@link MediaStore#EXTRA_PICK_IMAGES_IN_ORDER} in multiple selection mode to
      * allow the user to pick images in order.
      *
+     * <p>If the caller needs to specify the {@link ApplicationMediaCapabilities} that should be
+     * used while picking video files, use {@link MediaStore#EXTRA_MEDIA_CAPABILITIES} to indicate
+     * this.
+     *
+     * <p>When the requested file format does not match the capabilities specified by caller and
+     * the video duration is within the range that the system can handle, it will get transcoded to
+     * a default supported format, otherwise, the caller will receive the original file.
+     *
      * <p>Callers may use {@link Intent#EXTRA_LOCAL_ONLY} to limit content selection to local data.
      *
      * <p>For system stability, it is preferred to open the URIs obtained from using this action
@@ -1029,20 +1099,23 @@ public final class MediaStore {
             "android.provider.extra.ACCEPT_ORIGINAL_MEDIA_FORMAT";
 
     /**
-     * Specify the {@link ApplicationMediaCapabilities} that should be used while opening a media.
+     * Specify the {@link ApplicationMediaCapabilities} that should be used while opening a media
+     * or picking media files.
      *
-     * If the capabilities specified matches the format of the original file, the app will receive
-     * the original file, otherwise, it will get transcoded to a default supported format.
+     * <p>If the capabilities specified matches the format of the original file, the app will
+     * receive the original file, otherwise, it will get transcoded to a default supported format.
      *
-     * This flag takes higher precedence over the applications declared
-     * {@code media_capabilities.xml} and is useful for apps that want to have more granular control
-     * over their supported media capabilities.
+     * <p>When used while opening a media, add this option to the {@code opts} {@link Bundle} in
+     * various {@link ContentResolver} {@code open} methods. This flag takes higher precedence over
+     * the applications declared {@code media_capabilities.xml} and is useful for apps that want to
+     * have more granular control over their supported media capabilities.
      *
-     * <p>This option can be added to the {@code opts} {@link Bundle} in various
-     * {@link ContentResolver} {@code open} methods.
+     * <p>When used while picking media files, add this option to the intent-extra of
+     * {@link MediaStore#ACTION_PICK_IMAGES}.
      *
      * @see ContentResolver#openTypedAssetFileDescriptor(Uri, String, Bundle)
      * @see ContentResolver#openTypedAssetFile(Uri, String, Bundle, CancellationSignal)
+     * @see MediaStore#ACTION_PICK_IMAGES
      */
     public final static String EXTRA_MEDIA_CAPABILITIES =
             "android.provider.extra.MEDIA_CAPABILITIES";
@@ -1577,6 +1650,45 @@ public final class MediaStore {
         return createRequest(resolver, CREATE_FAVORITE_REQUEST_CALL, uris, values);
     }
 
+    /**
+     * Sets the media isFavorite status if the calling app has wider read permission on media
+     * files for given type. Calling app should have one of READ_EXTERNAL_STORAGE or
+     * WRITE_EXTERNAL_STORAGE if target sdk <= T. For target sdk > T, it
+     * should have READ_MEDIA_IMAGES for images, READ_MEDIA_VIDEOS for videos or READ_MEDIA_AUDIO
+     * for audio files or MANAGE_EXTERNAL_STORAGE permission.
+     *
+     * @param resolver used to connect with {@link MediaStore#AUTHORITY}
+     * @param uris a collection of media items to include in this request. Each item
+     *            must be hosted by {@link MediaStore#AUTHORITY} and must
+     *            reference a specific media item by {@link BaseColumns#_ID}
+     *            sample uri - content://media/external_primary/images/media/24
+     * @param areFavorites the {@link MediaColumns#IS_FAVORITE} value to apply.
+     */
+    @FlaggedApi(Flags.FLAG_ENABLE_MARK_IS_FAVORITE_STATUS_API)
+    public static void markIsFavoriteStatus(@NonNull ContentResolver resolver,
+            @NonNull Collection<Uri> uris, boolean areFavorites) {
+        Objects.requireNonNull(resolver);
+        Objects.requireNonNull(uris);
+
+        final ContentValues values = new ContentValues();
+        if (areFavorites) {
+            values.put(MediaColumns.IS_FAVORITE, 1);
+        } else {
+            values.put(MediaColumns.IS_FAVORITE, 0);
+        }
+        final Iterator<Uri> it = uris.iterator();
+        final ClipData clipData = ClipData.newRawUri(null, it.next());
+        while (it.hasNext()) {
+            clipData.addItem(new ClipData.Item(it.next()));
+        }
+
+        final Bundle extras = new Bundle();
+        extras.putParcelable(EXTRA_CLIP_DATA, clipData);
+        extras.putParcelable(EXTRA_CONTENT_VALUES, values);
+        resolver.call(AUTHORITY, MARK_MEDIA_AS_FAVORITE, null, extras);
+    }
+
+
     /**
      * Create a {@link PendingIntent} that will prompt the user to permanently
      * delete the requested media items. When the user approves this request,
diff --git a/errorprone/Android.bp b/errorprone/Android.bp
index fc3d67f9e..917e96f32 100644
--- a/errorprone/Android.bp
+++ b/errorprone/Android.bp
@@ -18,6 +18,7 @@ java_library_host {
 
     static_libs: [
         "//external/error_prone:error_prone_core",
+        "jsr305",
     ],
 
     libs: [
@@ -28,5 +29,13 @@ java_library_host {
         "//external/auto:auto_service_plugin",
     ],
 
-    javacflags: ["-verbose"],
+    javacflags: [
+        "-verbose",
+
+        // These exports are needed because this errorprone plugin access some private classes
+        // of the java compiler.
+        "--add-exports=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED",
+        "--add-exports=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED",
+        "--add-exports=jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED",
+    ],
 }
diff --git a/jni/FuseDaemon.cpp b/jni/FuseDaemon.cpp
index e77fe5705..fb0468c5b 100644
--- a/jni/FuseDaemon.cpp
+++ b/jni/FuseDaemon.cpp
@@ -124,11 +124,6 @@ const std::regex PATTERN_BPF_BACKING_PATH("^/storage/[^/]+/[0-9]+/Android/(data|
 
 static constexpr char TRANSFORM_SYNTHETIC_DIR[] = "synthetic";
 static constexpr char TRANSFORM_TRANSCODE_DIR[] = "transcode";
-static constexpr char PRIMARY_VOLUME_PREFIX[] = "/storage/emulated";
-static constexpr char STORAGE_PREFIX[] = "/storage";
-
-static constexpr char VOLUME_INTERNAL[] = "internal";
-static constexpr char VOLUME_EXTERNAL_PRIMARY[] = "external_primary";
 
 static constexpr char OWNERSHIP_RELATION[] = "ownership";
 
@@ -274,6 +269,7 @@ struct fuse {
           zero_addr(0),
           disable_dentry_cache(false),
           passthrough(false),
+          upstream_passthrough(false),
           bpf(_bpf),
           bpf_fd(std::move(_bpf_fd)),
           supported_transcoding_relative_paths(_supported_transcoding_relative_paths),
@@ -282,7 +278,7 @@ struct fuse {
     inline bool IsRoot(const node* node) const { return node == root; }
 
     inline string GetEffectiveRootPath() {
-        if (android::base::StartsWith(path, PRIMARY_VOLUME_PREFIX)) {
+        if (android::base::StartsWith(path, mediaprovider::fuse::PRIMARY_VOLUME_PREFIX)) {
             return path + "/" + MY_USER_ID_STRING;
         }
         return path;
@@ -356,7 +352,7 @@ struct fuse {
             return false;
         }
 
-        if (!android::base::StartsWithIgnoreCase(path, PRIMARY_VOLUME_PREFIX)) {
+        if (!android::base::StartsWithIgnoreCase(path, mediaprovider::fuse::PRIMARY_VOLUME_PREFIX)) {
             // Uncached path config applies only to primary volumes.
             return false;
         }
@@ -396,6 +392,7 @@ struct fuse {
     std::atomic_bool* active;
     std::atomic_bool disable_dentry_cache;
     std::atomic_bool passthrough;
+    std::atomic_bool upstream_passthrough;
     std::atomic_bool bpf;
 
     const android::base::unique_fd bpf_fd;
@@ -755,6 +752,10 @@ static void pf_init(void* userdata, struct fuse_conn_info* conn) {
             //   b. Files requiring redaction are still faster than no-passthrough devices that use
             //      direct_io
             disable_splice_write = true;
+        } else if (conn->capable & FUSE_CAP_PASSTHROUGH_UPSTREAM) {
+            mask |= FUSE_CAP_PASSTHROUGH_UPSTREAM;
+            disable_splice_write = true;
+            fuse->upstream_passthrough = true;
         } else {
             LOG(WARNING) << "Passthrough feature not supported by the kernel";
             fuse->passthrough = false;
@@ -999,7 +1000,10 @@ static void do_forget(fuse_req_t req, struct fuse* fuse, fuse_ino_t ino, uint64_
         // This is a narrowing conversion from an unsigned 64bit to a 32bit value. For
         // some reason we only keep 32 bit refcounts but the kernel issues
         // forget requests with a 64 bit counter.
-        node->Release(static_cast<uint32_t>(nlookup));
+        int backing_id = node->GetBackingId();
+        if (node->Release(static_cast<uint32_t>(nlookup))) {
+            if (backing_id) fuse_passthrough_close(req, backing_id);
+        }
     }
 }
 
@@ -1447,7 +1451,7 @@ static handle* create_handle_for_node(struct fuse* fuse, const string& path, int
     }
 
     if (fuse->passthrough && allow_passthrough) {
-        *keep_cache = transforms_complete;
+        *keep_cache = transforms_complete && !fuse->upstream_passthrough;
         // We only enabled passthrough iff these 2 conditions hold
         // 1. Redaction is not needed
         // 2. Node transforms are completed, e.g transcoding.
@@ -1495,14 +1499,33 @@ static handle* create_handle_for_node(struct fuse* fuse, const string& path, int
     return handle;
 }
 
-static bool do_passthrough_enable(fuse_req_t req, struct fuse_file_info* fi, unsigned int fd) {
-    int passthrough_fh = fuse_passthrough_enable(req, fd);
+static bool do_passthrough_enable(fuse_req_t req, struct fuse_file_info* fi, unsigned int fd,
+                                  node* node) {
+    struct fuse* fuse = get_fuse(req);
 
-    if (passthrough_fh <= 0) {
-        return false;
-    }
+    if (fuse->upstream_passthrough) {
+        int backing_id = node->GetBackingId();
+        if (!backing_id) {
+            backing_id = fuse_passthrough_open(req, fd);
+            if (!backing_id) return false;
+            // We only ever want one backing id per backed file
+            if (!node->SetBackingId(backing_id)) {
+                fuse_passthrough_close(req, backing_id);
+                backing_id = node->GetBackingId();
+                if (!backing_id) return false;
+            }
+        }
 
-    fi->passthrough_fh = passthrough_fh;
+        fi->backing_id = backing_id;
+    } else {
+        int passthrough_fh = fuse_passthrough_enable(req, fd);
+
+        if (passthrough_fh <= 0) {
+            return false;
+        }
+
+        fi->passthrough_fh = passthrough_fh;
+    }
     return true;
 }
 
@@ -1611,7 +1634,7 @@ static void pf_open(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info* fi) {
     // TODO(b/173190192) ensuring that h->cached must be enabled in order to
     // user FUSE passthrough is a conservative rule and might be dropped as
     // soon as demonstrated its correctness.
-    if (h->passthrough && !do_passthrough_enable(req, fi, fd)) {
+    if (h->passthrough && !do_passthrough_enable(req, fi, fd, node)) {
         // TODO: Should we crash here so we can find errors easily?
         PLOG(ERROR) << "Passthrough OPEN failed for " << io_path;
         fuse_reply_err(req, EFAULT);
@@ -1998,7 +2021,7 @@ static void do_readdir_common(fuse_req_t req,
         if (used + entry_size > len) {
             // When an entry is rejected, lookup called by readdir_plus will not be tracked by
             // kernel. Call forget on the rejected node to decrement the reference count.
-            if (plus) {
+            if (plus && e.ino > 0) {
                 do_forget(req, fuse, e.ino, 1);
             }
             break;
@@ -2258,7 +2281,7 @@ static void pf_create(fuse_req_t req,
     // TODO(b/173190192) ensuring that h->cached must be enabled in order to
     // user FUSE passthrough is a conservative rule and might be dropped as
     // soon as demonstrated its correctness.
-    if (h->passthrough && !do_passthrough_enable(req, fi, fd)) {
+    if (h->passthrough && !do_passthrough_enable(req, fi, fd, node)) {
         PLOG(ERROR) << "Passthrough CREATE failed for " << child_path;
         fuse_reply_err(req, EFAULT);
         return;
@@ -2639,7 +2662,7 @@ void FuseDaemon::SetupLevelDbInstances() {
         // Setup leveldb instance for both external primary and internal volume.
         fuse->level_db_mutex.lock();
         // Create level db instance for internal volume
-        SetupLevelDbConnection(VOLUME_INTERNAL);
+        SetupLevelDbConnection(mediaprovider::fuse::VOLUME_INTERNAL);
         // Create level db instance for external primary volume
         SetupLevelDbConnection(VOLUME_EXTERNAL_PRIMARY);
         // Create level db instance to store owner id to owner package name and vice versa relation
@@ -2657,16 +2680,11 @@ void FuseDaemon::SetupPublicVolumeLevelDbInstance(const std::string& volume_name
 }
 
 std::string deriveVolumeName(const std::string& path) {
-    std::string volume_name;
-    if (!android::base::StartsWith(path, STORAGE_PREFIX)) {
-        volume_name = VOLUME_INTERNAL;
-    } else if (android::base::StartsWith(path, PRIMARY_VOLUME_PREFIX)) {
-        volume_name = VOLUME_EXTERNAL_PRIMARY;
+    std::string volume_name = mediaprovider::fuse::getVolumeNameFromPath(path);
+    if (volume_name.empty()) {
+        LOG(ERROR) << "Invalid input URI for extracting volume name." << path;
     } else {
-        // Return "C58E-1702" from the path like "/storage/C58E-1702/Download/1935694997673.png"
-        volume_name = path.substr(9, 9);
-        // Convert to lowercase
-        std::transform(volume_name.begin(), volume_name.end(), volume_name.begin(), ::tolower);
+        LOG(DEBUG) << "Volume name from input path: " << path << " ,  volName: " + volume_name;
     }
     return volume_name;
 }
diff --git a/jni/FuseUtils.cpp b/jni/FuseUtils.cpp
index 7b0816488..a74b56033 100644
--- a/jni/FuseUtils.cpp
+++ b/jni/FuseUtils.cpp
@@ -16,6 +16,7 @@
 
 #include "include/libfuse_jni/FuseUtils.h"
 
+#include <regex>
 #include <string>
 #include <vector>
 
@@ -51,5 +52,24 @@ bool containsMount(const string& path) {
            android::base::EqualsIgnoreCase(path_suffix, obb_suffix);
 }
 
+string getVolumeNameFromPath(const std::string& path) {
+    std::string volume_name = "";
+    if (!android::base::StartsWith(path, STORAGE_PREFIX)) {
+        volume_name = VOLUME_INTERNAL;
+    } else if (android::base::StartsWith(path, PRIMARY_VOLUME_PREFIX) || path == STORAGE_PREFIX) {
+        volume_name = VOLUME_EXTERNAL_PRIMARY;
+    } else {
+        // Use regex to extract volume name
+        std::regex volumeRegex(R"(/storage/([a-zA-Z0-9-]+)/)");
+        std::smatch match;
+        if (std::regex_search(path, match, volumeRegex)) {
+            volume_name = match[1].str();
+            // Convert to lowercase
+            std::transform(volume_name.begin(), volume_name.end(), volume_name.begin(), ::tolower);
+        }
+    }
+    return volume_name;
+}
+
 }  // namespace fuse
 }  // namespace mediaprovider
diff --git a/jni/FuseUtilsTest.cpp b/jni/FuseUtilsTest.cpp
index d76a89c6f..a1b03e0c2 100644
--- a/jni/FuseUtilsTest.cpp
+++ b/jni/FuseUtilsTest.cpp
@@ -59,4 +59,18 @@ TEST(FuseUtilsTest, testContainsMount_isFalseForPathWithAdditionalSlash) {
     EXPECT_FALSE(containsMount("/storage/emulated/1234//Android/data"));
 }
 
+TEST(FuseUtilsTest, getVolumeNameFromPath) {
+    EXPECT_EQ(getVolumeNameFromPath("/storage/emulated/0/Pictures"), VOLUME_EXTERNAL_PRIMARY);
+    EXPECT_EQ(getVolumeNameFromPath("/storage/emulated/0/DCIM"), VOLUME_EXTERNAL_PRIMARY);
+    EXPECT_EQ(getVolumeNameFromPath("/storage/emulated/0/"), VOLUME_EXTERNAL_PRIMARY);
+    EXPECT_EQ(getVolumeNameFromPath("/storage/emulated/0"), VOLUME_EXTERNAL_PRIMARY);
+    EXPECT_EQ(getVolumeNameFromPath("/storage/1234-5678/Music"), "1234-5678");
+    EXPECT_EQ(getVolumeNameFromPath("/storage/ABCD-EFGH/Movies"), "abcd-efgh");
+    EXPECT_EQ(getVolumeNameFromPath("/storage/AB12-E34g/Movies"), "ab12-e34g");
+    EXPECT_EQ(getVolumeNameFromPath("/storage/"), "");
+    EXPECT_EQ(getVolumeNameFromPath("/storage"), VOLUME_EXTERNAL_PRIMARY);
+    EXPECT_EQ(getVolumeNameFromPath("/data/media/0/"), VOLUME_INTERNAL);
+    EXPECT_EQ(getVolumeNameFromPath("/data/user_de/0/com.example.app/"), VOLUME_INTERNAL);
+}
+
 }  // namespace mediaprovider::fuse
diff --git a/jni/MediaProviderWrapper.cpp b/jni/MediaProviderWrapper.cpp
index 253dbbef7..32913aeb8 100644
--- a/jni/MediaProviderWrapper.cpp
+++ b/jni/MediaProviderWrapper.cpp
@@ -184,6 +184,15 @@ int renameInternal(JNIEnv* env, jobject media_provider_object, jmethodID mid_ren
     return res;
 }
 
+int validatePathIfUnicodeCheckEnabled(JNIEnv* env, jobject media_provider_object,
+                                      jmethodID mid_unicode_check_enabled_, const string& path) {
+    bool flagEnabled = env->CallBooleanMethod(media_provider_object, mid_unicode_check_enabled_);
+    if (flagEnabled && path != env->GetStringUTFChars(env->NewStringUTF(path.c_str()), nullptr)) {
+        return EPERM;
+    }
+    return 0;
+}
+
 void onFileCreatedInternal(JNIEnv* env, jobject media_provider_object,
                            jmethodID mid_on_file_created, const string& path) {
     ScopedLocalRef<jstring> j_path(env, env->NewStringUTF(path.c_str()));
@@ -224,6 +233,7 @@ MediaProviderWrapper::MediaProviderWrapper(JNIEnv* env, jobject media_provider)
     // Cache methods - Before calling a method, make sure you cache it here
     mid_insert_file_ = CacheMethod(env, "insertFileIfNecessary", "(Ljava/lang/String;I)I");
     mid_delete_file_ = CacheMethod(env, "deleteFile", "(Ljava/lang/String;I)I");
+    mid_unicode_check_enabled_ = CacheMethod(env, "isUnicodeCheckEnabled", "()Z");
     mid_on_file_open_ = CacheMethod(env, "onFileOpen",
                                     "(Ljava/lang/String;Ljava/lang/String;IIIZZZ)Lcom/android/"
                                     "providers/media/FileOpenResult;");
@@ -280,21 +290,37 @@ MediaProviderWrapper::~MediaProviderWrapper() {
 }
 
 int MediaProviderWrapper::InsertFile(const string& path, uid_t uid) {
+    JNIEnv* env = MaybeAttachCurrentThread();
+
+    int errCode = validatePathIfUnicodeCheckEnabled(env, media_provider_object_,
+                                                    mid_unicode_check_enabled_, path);
+    if (errCode != 0) {
+        LOG(ERROR) << "Invalid chars used in file name for creating new file";
+        return errCode;
+    }
+
     if (uid == ROOT_UID) {
         return 0;
     }
 
-    JNIEnv* env = MaybeAttachCurrentThread();
     return insertFileInternal(env, media_provider_object_, mid_insert_file_, path, uid);
 }
 
 int MediaProviderWrapper::DeleteFile(const string& path, uid_t uid) {
+    JNIEnv* env = MaybeAttachCurrentThread();
+
+    int errCode = validatePathIfUnicodeCheckEnabled(env, media_provider_object_,
+                                                    mid_unicode_check_enabled_, path);
+    if (errCode != 0) {
+        LOG(ERROR) << "Invalid chars used in file name while deleting file";
+        return errCode;
+    }
+
     if (uid == ROOT_UID) {
         int res = unlink(path.c_str());
         return res;
     }
 
-    JNIEnv* env = MaybeAttachCurrentThread();
     return deleteFileInternal(env, media_provider_object_, mid_delete_file_, path, uid);
 }
 
@@ -418,13 +444,27 @@ bool MediaProviderWrapper::isUidAllowedAccessToDataOrObbPath(uid_t uid, const st
 int MediaProviderWrapper::Rename(const string& old_path, const string& new_path, uid_t uid) {
     // Rename from SHELL_UID should go through MediaProvider to update database rows, so only bypass
     // MediaProvider for ROOT_UID.
+    JNIEnv* env = MaybeAttachCurrentThread();
+    int errCodeForOldPath = validatePathIfUnicodeCheckEnabled(env, media_provider_object_,
+                                                              mid_unicode_check_enabled_, old_path);
+    if (errCodeForOldPath != 0) {
+        LOG(ERROR) << "Invalid chars used in old file name";
+        return errCodeForOldPath;
+    }
+
+    int errCodeForNewPath = validatePathIfUnicodeCheckEnabled(env, media_provider_object_,
+                                                              mid_unicode_check_enabled_, new_path);
+    if (errCodeForNewPath != 0) {
+        LOG(ERROR) << "Invalid chars used in new file name";
+        return errCodeForNewPath;
+    }
+
     if (uid == ROOT_UID) {
         int res = rename(old_path.c_str(), new_path.c_str());
         if (res != 0) res = -errno;
         return res;
     }
 
-    JNIEnv* env = MaybeAttachCurrentThread();
     return renameInternal(env, media_provider_object_, mid_rename_, old_path, new_path, uid);
 }
 
diff --git a/jni/MediaProviderWrapper.h b/jni/MediaProviderWrapper.h
index 9fa6c4e4c..1975d8164 100644
--- a/jni/MediaProviderWrapper.h
+++ b/jni/MediaProviderWrapper.h
@@ -262,6 +262,7 @@ class MediaProviderWrapper final {
     /** Cached MediaProvider method IDs **/
     jmethodID mid_insert_file_;
     jmethodID mid_delete_file_;
+    jmethodID mid_unicode_check_enabled_;
     jmethodID mid_on_file_open_;
     jmethodID mid_scan_file_;
     jmethodID mid_is_diraccess_allowed_;
diff --git a/jni/include/libfuse_jni/FuseUtils.h b/jni/include/libfuse_jni/FuseUtils.h
index 0e350995e..11f880f7a 100644
--- a/jni/include/libfuse_jni/FuseUtils.h
+++ b/jni/include/libfuse_jni/FuseUtils.h
@@ -21,6 +21,10 @@
 
 namespace mediaprovider {
 namespace fuse {
+static constexpr char STORAGE_PREFIX[] = "/storage";
+static constexpr char VOLUME_INTERNAL[] = "internal";
+static constexpr char VOLUME_EXTERNAL_PRIMARY[] = "external_primary";
+static constexpr char PRIMARY_VOLUME_PREFIX[] = "/storage/emulated";
 
 /**
  * Returns true if the given path (ignoring case) is mounted for any
@@ -31,6 +35,11 @@ namespace fuse {
  */
 bool containsMount(const std::string& path);
 
+/**
+ * Returns the volume name extracted from a given path.
+ */
+std::string getVolumeNameFromPath(const std::string& path);
+
 }  // namespace fuse
 }  // namespace mediaprovider
 
diff --git a/jni/node-inl.h b/jni/node-inl.h
index ba3d9268f..e6b67b0a4 100644
--- a/jni/node-inl.h
+++ b/jni/node-inl.h
@@ -408,6 +408,19 @@ class node {
     // Looks up for the node with the given ino rooted at |root|, or nullptr if no such node exists.
     static const node* LookupInode(const node* root, ino_t ino);
 
+    int GetBackingId() {
+        std::lock_guard<std::recursive_mutex> guard(*lock_);
+        return backing_id_;
+    }
+
+    // A Node should only have one backing id.
+    bool SetBackingId(int new_id) {
+        std::lock_guard<std::recursive_mutex> guard(*lock_);
+        if (backing_id_) return false;
+        backing_id_ = new_id;
+        return true;
+    }
+
   private:
     node(node* parent, const std::string& name, const std::string& io_path,
          const bool transforms_complete, const int transforms, const int transforms_reason,
@@ -423,6 +436,7 @@ class node {
           deleted_(false),
           lock_(lock),
           ino_(ino),
+          backing_id_(0),
           tracker_(tracker) {
         tracker_->NodeCreated(this);
         Acquire();
@@ -573,6 +587,8 @@ class node {
     std::recursive_mutex* lock_;
     // Inode number of the file represented by this node.
     const ino_t ino_;
+    // Backing identifier for upstream passthrough
+    int backing_id_;
 
     NodeTracker* const tracker_;
 
diff --git a/mediaprovider_flags.aconfig b/mediaprovider_flags.aconfig
index d71fbb068..bcccc0eba 100644
--- a/mediaprovider_flags.aconfig
+++ b/mediaprovider_flags.aconfig
@@ -156,3 +156,84 @@ flag {
     bug: "361026918"
     is_fixed_read_only: true
 }
+
+flag {
+    name: "cloud_media_provider_search"
+    is_exported: true
+    namespace: "mediaprovider"
+    is_fixed_read_only: true
+    description: "This flag will enable the apis for cloud media provider to donate search results"
+    bug: "316356081"
+}
+
+flag {
+    name: "enable_malicious_app_detector"
+    is_exported: true
+    namespace: "mediaprovider"
+    description: "This flag will enable malicious app detector, putting limits on file creation"
+    bug: "293301664"
+    is_fixed_read_only: true
+ }
+
+flag {
+    name: "enable_mark_media_as_favorite_api"
+    is_exported: true
+    namespace: "mediaprovider"
+    description: "Enables mark media as favorite API"
+    bug: "294364218"
+    is_fixed_read_only: true
+}
+
+flag {
+    name: "enable_unicode_check"
+    is_exported: true
+    namespace: "mediaprovider"
+    description: "This flag controls whether the unicode check is enabled"
+    bug: "263914218"
+    is_fixed_read_only: true
+}
+
+flag {
+    name: "index_media_latitude_longitude"
+    is_exported: true
+    namespace: "mediaprovider"
+    description: "This flag controls the indexing of latitude and longitude for both new and existing on-device media items"
+    bug: "361019344"
+    is_fixed_read_only: true
+}
+
+flag {
+    name: "enable_photopicker_transcoding"
+    is_exported: true
+    namespace: "mediaprovider"
+    description: "This flag controls whether to enable transcoding feature in photopicker"
+    bug: "367886883"
+    is_fixed_read_only: true
+}
+
+flag {
+    name: "enable_cloud_media_provider_capabilities"
+    namespace: "mediaprovider"
+    description: "This flag controls the Capabilities APIs in CloudMediaProvider and the contract."
+    bug: "370445733"
+    is_fixed_read_only: true
+    is_exported: true
+}
+
+flag {
+    name: "motion_photo_intent"
+    is_exported: true
+    namespace: "mediaprovider"
+    is_fixed_read_only: true
+    description: "This flag will enable the motion photo capture intents."
+    bug: "362580165"
+}
+
+flag {
+    name: "enable_mark_is_favorite_status_api"
+    is_exported: true
+    namespace: "mediaprovider"
+    description: "Enables mark media as favorite API"
+    is_fixed_read_only: true
+    bug: "294364218"
+}
diff --git a/pdf/TEST_MAPPING b/pdf/TEST_MAPPING
index 678418b85..6defc84b2 100644
--- a/pdf/TEST_MAPPING
+++ b/pdf/TEST_MAPPING
@@ -4,9 +4,14 @@
           "name": "CtsPdfModuleTestCases[com.google.android.mediaprovider.apex]"
     }
   ],
+  "mediaprovider-mainline-presubmit": [
+    {
+          "name": "CtsPdfModuleTestCases"
+    }
+  ],
   "presubmit": [
     {
       "name": "CtsPdfModuleTestCases"
     }
   ]
-}
\ No newline at end of file
+}
diff --git a/pdf/framework-v/api/current.txt b/pdf/framework-v/api/current.txt
index 2d431268b..0f5aa7ffb 100644
--- a/pdf/framework-v/api/current.txt
+++ b/pdf/framework-v/api/current.txt
@@ -20,6 +20,8 @@ package android.graphics.pdf {
   }
 
   public final class PdfRenderer.Page implements java.lang.AutoCloseable {
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") public int addPageAnnotation(@NonNull android.graphics.pdf.component.PdfAnnotation);
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") public int addPageObject(@NonNull android.graphics.pdf.component.PdfPageObject);
     method @FlaggedApi("android.graphics.pdf.flags.enable_form_filling") @NonNull public java.util.List<android.graphics.Rect> applyEdit(@NonNull android.graphics.pdf.models.FormEditRecord);
     method public void close();
     method @FlaggedApi("android.graphics.pdf.flags.enable_form_filling") @NonNull public android.graphics.pdf.models.FormWidgetInfo getFormWidgetInfoAtIndex(@IntRange(from=0) int);
@@ -31,12 +33,18 @@ package android.graphics.pdf {
     method @FlaggedApi("android.graphics.pdf.flags.enable_pdf_viewer") @NonNull public java.util.List<android.graphics.pdf.content.PdfPageImageContent> getImageContents();
     method @IntRange(from=0) public int getIndex();
     method @FlaggedApi("android.graphics.pdf.flags.enable_pdf_viewer") @NonNull public java.util.List<android.graphics.pdf.content.PdfPageLinkContent> getLinkContents();
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") @NonNull public java.util.List<android.graphics.pdf.component.PdfAnnotation> getPageAnnotations();
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") @NonNull public java.util.List<android.graphics.pdf.component.PdfPageObject> getPageObjects();
     method @FlaggedApi("android.graphics.pdf.flags.enable_pdf_viewer") @NonNull public java.util.List<android.graphics.pdf.content.PdfPageTextContent> getTextContents();
     method @IntRange(from=0) public int getWidth();
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") @NonNull public android.graphics.pdf.component.PdfAnnotation removePageAnnotation(int);
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") @NonNull public android.graphics.pdf.component.PdfPageObject removePageObject(int);
     method public void render(@NonNull android.graphics.Bitmap, @Nullable android.graphics.Rect, @Nullable android.graphics.Matrix, int);
     method @FlaggedApi("android.graphics.pdf.flags.enable_pdf_viewer") public void render(@NonNull android.graphics.Bitmap, @Nullable android.graphics.Rect, @Nullable android.graphics.Matrix, @NonNull android.graphics.pdf.RenderParams);
     method @FlaggedApi("android.graphics.pdf.flags.enable_pdf_viewer") @NonNull public java.util.List<android.graphics.pdf.models.PageMatchBounds> searchText(@NonNull String);
     method @FlaggedApi("android.graphics.pdf.flags.enable_pdf_viewer") @Nullable public android.graphics.pdf.models.selection.PageSelection selectContent(@NonNull android.graphics.pdf.models.selection.SelectionBoundary, @NonNull android.graphics.pdf.models.selection.SelectionBoundary);
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") public boolean updatePageAnnotation(@NonNull android.graphics.pdf.component.PdfAnnotation);
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") public boolean updatePageObject(@NonNull android.graphics.pdf.component.PdfPageObject);
     field public static final int RENDER_MODE_FOR_DISPLAY = 1; // 0x1
     field public static final int RENDER_MODE_FOR_PRINT = 2; // 0x2
   }
diff --git a/pdf/framework-v/java/android/graphics/pdf/PdfRenderer.java b/pdf/framework-v/java/android/graphics/pdf/PdfRenderer.java
index 113545ad8..bf0125881 100644
--- a/pdf/framework-v/java/android/graphics/pdf/PdfRenderer.java
+++ b/pdf/framework-v/java/android/graphics/pdf/PdfRenderer.java
@@ -27,12 +27,15 @@ import android.annotation.SuppressLint;
 import android.app.compat.CompatChanges;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledAfter;
-import android.compat.annotation.EnabledSince;
 import android.compat.annotation.UnsupportedAppUsage;
 import android.graphics.Bitmap;
 import android.graphics.Bitmap.Config;
 import android.graphics.Matrix;
 import android.graphics.Rect;
+import android.graphics.pdf.component.PdfAnnotation;
+import android.graphics.pdf.component.PdfAnnotationType;
+import android.graphics.pdf.component.PdfPageObject;
+import android.graphics.pdf.component.PdfPageObjectType;
 import android.graphics.pdf.content.PdfPageGotoLinkContent;
 import android.graphics.pdf.content.PdfPageImageContent;
 import android.graphics.pdf.content.PdfPageLinkContent;
@@ -778,6 +781,200 @@ public final class PdfRenderer implements AutoCloseable {
             return mPdfProcessor.applyEdit(mIndex, editRecord);
         }
 
+        /**
+         * Return a list of supported {@link PdfAnnotation} present on the
+         * page. See {@link PdfAnnotationType} for the supported types
+         * <p>
+         * The list will be empty if there are no supported
+         * annotations present on the page, even if the page
+         * contains other annotation types.
+         *
+         * @return list of supported annotations present on the page
+         * @throws IllegalStateException if {@link PdfRenderer} or {@link PdfRenderer.Page}
+         *         is closed before invocation.
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_ANNOTATIONS)
+        @NonNull
+        public List<PdfAnnotation> getPageAnnotations() {
+            throwIfDocumentOrPageClosed();
+            return mPdfProcessor.getPageAnnotations(mIndex);
+
+        }
+
+        /**
+         * Adds the given annotation to the page. The annotation should be of
+         * supported type. See {@link PdfAnnotationType} for the supported types
+         *
+         * @param annotation the {@link PdfAnnotation} object to
+         *        add
+         * @return id of the added annotation,
+         *         or -1 if the annotation cannot be added. The
+         *         id is guaranteed to be non-negative if
+         *         the annotation is added successfully.
+         * @throws IllegalArgumentException if the provided
+         *         annotation is null or of unsupported type i.e.-
+         *         {@link PdfAnnotationType#UNKNOWN} or if the annotation is already
+         *         added in this page or some other page of the document.
+         * @throws IllegalStateException if {@link PdfRenderer} or {@link PdfRenderer.Page}
+         *         is closed before invocation.
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_ANNOTATIONS)
+        public int addPageAnnotation(@androidx.annotation.NonNull PdfAnnotation annotation) {
+            throwIfDocumentOrPageClosed();
+            Preconditions.checkNotNull(annotation, "Annotation should not be null");
+            Preconditions.checkArgument(
+                    annotation.getPdfAnnotationType() != PdfAnnotationType.UNKNOWN,
+                    "Annotation should be of valid type");
+            Preconditions.checkArgument(annotation.getId() != -1,
+                    "Annotation already added");
+            return mPdfProcessor.addPageAnnotation(mIndex, annotation);
+        }
+
+        /**
+         * Removes the annotation with the specified id.
+         *
+         * @param annotationId id of the annotation to remove from the page
+         * @return the removed annotation
+         *
+         * @throws IllegalArgumentException if annotationId ie negative
+         *
+         * @throws IllegalStateException if {@link PdfRendererPreV} or
+         *        {@link PdfRendererPreV.Page} is closed before invocation or if
+         *        annotation is failed to get removed from the page.
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_ANNOTATIONS)
+        @androidx.annotation.NonNull
+        public PdfAnnotation removePageAnnotation(int annotationId) {
+            throwIfDocumentOrPageClosed();
+            Preconditions.checkArgument(annotationId >= 0,
+                    "Annotation id should be non-negative");
+            PdfAnnotation removedAnnotation = mPdfProcessor.removePageAnnotation(mIndex,
+                    annotationId);
+            if (removedAnnotation == null) {
+                throw new IllegalStateException(
+                        "Failed to remove annotation with id " + annotationId);
+            }
+            return removedAnnotation;
+        }
+
+        /**
+         * Update the given {@link PdfAnnotation} to the page.
+         *
+         * @param annotation the annotation to update
+         *
+         * @return true if annotation is updated, false otherwise
+         *
+         * @throws IllegalArgumentException if the provided annotation is null or of
+         *         unsupported type i.e. {@link PdfAnnotationType#UNKNOWN}
+         *
+         * @throws IllegalStateException if {@link PdfRendererPreV} or
+         *         {@link PdfRendererPreV.Page}  is closed before invocation
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_ANNOTATIONS)
+        public boolean updatePageAnnotation(@androidx.annotation.NonNull PdfAnnotation annotation) {
+            throwIfDocumentOrPageClosed();
+            Preconditions.checkNotNull(annotation, "PdfAnnotation should not be null");
+            Preconditions.checkArgument(
+                    annotation.getPdfAnnotationType() != PdfAnnotationType.UNKNOWN,
+                    "Annotation should be of valid type");
+
+            Preconditions.checkArgument(annotation.getId() >= 0,
+                    "Annotation id should be greater than equal to 0");
+            return mPdfProcessor.updatePageAnnotation(mIndex, annotation);
+        }
+
+        /**
+         * Returns list of supported {@link PdfPageObject} present on
+         * the page.
+         * The list will be empty if there are no supported page
+         * objects present on the page, even if the page contains
+         * other page object types.
+         *
+         * @return list of page objects present on the page
+         *
+         * @throws IllegalStateException    if the {@link PdfRenderer.Page} is closed before
+         *                                  invocation.
+         */
+        @NonNull
+        @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
+        public List<PdfPageObject> getPageObjects() {
+            throwIfDocumentOrPageClosed();
+            return mPdfProcessor.getPageObjects(mIndex);
+        }
+
+        /**
+         * Adds the given {@link PdfPageObject} to the page.
+         *
+         * @param pageObject the {@code PdfPageObject} object to
+         *                   add, existing page object cannot be used (i.e. it should not have
+         *                   objectId)
+         * @return object id of added page object, -1 otherwise
+         * @throws IllegalArgumentException if the provided {@link PdfPageObject} is unknown, null
+         *                                  or if the object is already added to a page or an
+         *                                  annotation.
+         * @throws IllegalStateException    if the {@link PdfRenderer.Page} is closed before
+         *                                  invocation.
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
+        public int addPageObject(@NonNull PdfPageObject pageObject) {
+            throwIfDocumentOrPageClosed();
+            Preconditions.checkNotNull(pageObject, "PdfPageObject should not be null");
+            Preconditions.checkArgument(
+                    PdfPageObjectType.isValidType(pageObject.getPdfObjectType()),
+                    "PageObject should be of valid type");
+            Preconditions.checkArgument(pageObject.getObjectId() == -1,
+                    "PageObject should not have an object id");
+            Preconditions.checkArgument(!pageObject.isAddedInAnnotation(),
+                    "PageObject already added to an annotation");
+            return mPdfProcessor.addPageObject(mIndex, pageObject);
+        }
+
+        /**
+         * Update the given {@link PdfPageObject} to the page.
+         *
+         * @param pageObject the {@code PdfPageObject} object to
+         *                   add
+         * @return true if page object is updated, false otherwise
+         * @throws IllegalArgumentException if the provided {@link PdfPageObject} is unknown or
+         *                                  null.
+         * @throws IllegalStateException    if the {@link PdfRenderer.Page} is closed before
+         *                                  invocation.
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
+        public boolean updatePageObject(@NonNull PdfPageObject pageObject) {
+            throwIfDocumentOrPageClosed();
+            Preconditions.checkNotNull(pageObject, "PdfPageObject should not be null");
+            Preconditions.checkArgument(
+                    PdfPageObjectType.isValidType(pageObject.getPdfObjectType()),
+                    "PageObject should be of valid type");
+            Preconditions.checkArgument(pageObject.getObjectId() >= 0,
+                    "Page object id should be greater than equal to 0");
+            return mPdfProcessor.updatePageObject(mIndex, pageObject);
+        }
+
+        /**
+         * Removes the {@link PdfPageObject} with the specified ID.
+         *
+         * @param objectId the id of the page object to remove
+         *                 from the page.
+         * @return {@link PdfPageObject} that is removed.
+         * @throws IllegalArgumentException if the provided
+         *                                  objectId doesn't exist.
+         * @throws IllegalStateException    if the page object cannot be removed.
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
+        @NonNull
+        public PdfPageObject removePageObject(int objectId) {
+            throwIfDocumentOrPageClosed();
+            Preconditions.checkArgument(objectId >= 0,
+                    "Page object id should be greater than equal to 0");
+            PdfPageObject pageObject = mPdfProcessor.removePageObject(mIndex, objectId);
+            if (pageObject == null) {
+                throw new IllegalStateException("Page object cannot be removed.");
+            }
+            return pageObject;
+        }
+
         /**
          * Closes this page.
          *
@@ -805,7 +1002,7 @@ public final class PdfRenderer implements AutoCloseable {
         }
 
         private void doClose() {
-            if (mPdfProcessor != null) {
+            if (mPdfProcessor != null && mIndex != -1) {
                 mPdfProcessor.releasePage(mIndex);
                 mIndex = -1;
             }
diff --git a/pdf/framework/Android.bp b/pdf/framework/Android.bp
index 72d220ea7..05db621c7 100644
--- a/pdf/framework/Android.bp
+++ b/pdf/framework/Android.bp
@@ -73,6 +73,7 @@ aconfig_declarations {
         "pdf_viewer_flags.aconfig",
     ],
     container: "com.android.mediaprovider",
+    exportable: true,
 }
 
 java_aconfig_library {
@@ -86,7 +87,6 @@ java_aconfig_library {
         "com.android.mediaprovider",
     ],
     defaults: ["framework-minus-apex-aconfig-java-defaults"],
-
 }
 
 // To generate the Stats log classes for the Android Pdf.
diff --git a/pdf/framework/api/current.txt b/pdf/framework/api/current.txt
index 71fc9d866..ce0238453 100644
--- a/pdf/framework/api/current.txt
+++ b/pdf/framework/api/current.txt
@@ -29,6 +29,8 @@ package android.graphics.pdf {
   }
 
   public final class PdfRendererPreV.Page implements java.lang.AutoCloseable {
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") public int addPageAnnotation(@NonNull android.graphics.pdf.component.PdfAnnotation);
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") public int addPageObject(@NonNull android.graphics.pdf.component.PdfPageObject);
     method @FlaggedApi("android.graphics.pdf.flags.enable_form_filling") @NonNull public java.util.List<android.graphics.Rect> applyEdit(@NonNull android.graphics.pdf.models.FormEditRecord);
     method public void close();
     method @FlaggedApi("android.graphics.pdf.flags.enable_form_filling") @NonNull public android.graphics.pdf.models.FormWidgetInfo getFormWidgetInfoAtIndex(@IntRange(from=0) int);
@@ -40,11 +42,17 @@ package android.graphics.pdf {
     method @NonNull public java.util.List<android.graphics.pdf.content.PdfPageImageContent> getImageContents();
     method @IntRange(from=0) public int getIndex();
     method @NonNull public java.util.List<android.graphics.pdf.content.PdfPageLinkContent> getLinkContents();
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") @NonNull public java.util.List<android.graphics.pdf.component.PdfAnnotation> getPageAnnotations();
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") @NonNull public java.util.List<android.graphics.pdf.component.PdfPageObject> getPageObjects();
     method @NonNull public java.util.List<android.graphics.pdf.content.PdfPageTextContent> getTextContents();
     method @IntRange(from=0) public int getWidth();
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") @NonNull public android.graphics.pdf.component.PdfAnnotation removePageAnnotation(int);
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") @NonNull public android.graphics.pdf.component.PdfPageObject removePageObject(int);
     method public void render(@NonNull android.graphics.Bitmap, @Nullable android.graphics.Rect, @Nullable android.graphics.Matrix, @NonNull android.graphics.pdf.RenderParams);
     method @NonNull public java.util.List<android.graphics.pdf.models.PageMatchBounds> searchText(@NonNull String);
     method @Nullable public android.graphics.pdf.models.selection.PageSelection selectContent(@NonNull android.graphics.pdf.models.selection.SelectionBoundary, @NonNull android.graphics.pdf.models.selection.SelectionBoundary);
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") public boolean updatePageAnnotation(@NonNull android.graphics.pdf.component.PdfAnnotation);
+    method @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") public boolean updatePageObject(@NonNull android.graphics.pdf.component.PdfPageObject);
   }
 
   @FlaggedApi("android.graphics.pdf.flags.enable_pdf_viewer") public final class RenderParams {
@@ -65,6 +73,102 @@ package android.graphics.pdf {
 
 }
 
+package android.graphics.pdf.component {
+
+  @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_text_annotations") public final class FreeTextAnnotation extends android.graphics.pdf.component.PdfAnnotation {
+    ctor public FreeTextAnnotation(@NonNull android.graphics.RectF, @NonNull String);
+    method @ColorInt public int getBackgroundColor();
+    method @ColorInt public int getTextColor();
+    method @NonNull public String getTextContent();
+    method public void setBackgroundColor(@ColorInt int);
+    method public void setTextColor(@ColorInt int);
+    method public void setTextContent(@NonNull String);
+  }
+
+  @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") public final class HighlightAnnotation extends android.graphics.pdf.component.PdfAnnotation {
+    ctor public HighlightAnnotation(@NonNull android.graphics.RectF);
+    method @ColorInt public int getColor();
+    method public void setColor(@ColorInt int);
+  }
+
+  @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") public abstract class PdfAnnotation {
+    method @NonNull public android.graphics.RectF getBounds();
+    method public int getId();
+    method public int getPdfAnnotationType();
+    method public void setBounds(@NonNull android.graphics.RectF);
+  }
+
+  @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_annotations") public final class PdfAnnotationType {
+    field @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_text_annotations") public static final int FREETEXT = 1; // 0x1
+    field public static final int HIGHLIGHT = 2; // 0x2
+    field public static final int STAMP = 3; // 0x3
+    field public static final int UNKNOWN = 0; // 0x0
+  }
+
+  @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") public final class PdfPageImageObject extends android.graphics.pdf.component.PdfPageObject {
+    ctor public PdfPageImageObject(@NonNull android.graphics.Bitmap);
+    method @NonNull public android.graphics.Bitmap getBitmap();
+    method public void setBitmap(@NonNull android.graphics.Bitmap);
+  }
+
+  @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") public abstract class PdfPageObject {
+    method @NonNull public android.graphics.RectF getBounds();
+    method @NonNull public float[] getMatrix();
+    method public int getObjectId();
+    method public int getPdfObjectType();
+    method public boolean isAddedInAnnotation();
+    method public void setBounds(@NonNull android.graphics.RectF);
+    method public void setMatrix(@NonNull android.graphics.Matrix);
+    method public void transform(float, float, float, float, float, float);
+  }
+
+  @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") public final class PdfPageObjectType {
+    method public static boolean isValidType(int);
+    field public static final int IMAGE = 3; // 0x3
+    field public static final int PATH = 2; // 0x2
+    field @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_text_objects") public static final int TEXT = 1; // 0x1
+    field public static final int UNKNOWN = 0; // 0x0
+  }
+
+  @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") public final class PdfPagePathObject extends android.graphics.pdf.component.PdfPageObject {
+    ctor public PdfPagePathObject();
+    method @Nullable public android.graphics.Color getFillColor();
+    method @Nullable public android.graphics.PathEffect getLineStyle();
+    method @NonNull public android.graphics.Path getPath();
+    method @NonNull public android.graphics.Color getStrokeColor();
+    method public float getStrokeWidth();
+    method public void setFillColor(@Nullable android.graphics.Color);
+    method public void setLineStyle(int);
+    method public void setPath(@NonNull android.graphics.Path);
+    method public void setStrokeColor(@NonNull android.graphics.Color);
+    method public void setStrokeWidth(float);
+  }
+
+  @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_page_objects") public final class PdfPageTextObject extends android.graphics.pdf.component.PdfPageObject {
+    ctor @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_text_objects") public PdfPageTextObject(@NonNull String, @NonNull android.graphics.Typeface, float);
+    method @Nullable public android.graphics.Color getFillColor();
+    method public float getFontSize();
+    method @NonNull public android.graphics.Color getStrokeColor();
+    method public float getStrokeWidth();
+    method @NonNull public String getText();
+    method @NonNull public android.graphics.Typeface getTypeface();
+    method public void setFillColor(@Nullable android.graphics.Color);
+    method public void setFontSize(float);
+    method public void setStrokeColor(@NonNull android.graphics.Color);
+    method public void setStrokeWidth(float);
+    method public void setText(@NonNull String);
+    method public void setTypeface(@NonNull android.graphics.Typeface);
+  }
+
+  @FlaggedApi("android.graphics.pdf.flags.enable_edit_pdf_stamp_annotations") public final class StampAnnotation extends android.graphics.pdf.component.PdfAnnotation {
+    ctor public StampAnnotation(@NonNull android.graphics.RectF);
+    method public void addObject(@NonNull android.graphics.pdf.component.PdfPageObject);
+    method @NonNull public java.util.List<android.graphics.pdf.component.PdfPageObject> getObjects();
+    method public void removeObject(int);
+  }
+
+}
+
 package android.graphics.pdf.content {
 
   @FlaggedApi("android.graphics.pdf.flags.enable_pdf_viewer") public final class PdfPageGotoLinkContent implements android.os.Parcelable {
diff --git a/pdf/framework/java/android/graphics/pdf/PdfDocumentProxy.java b/pdf/framework/java/android/graphics/pdf/PdfDocumentProxy.java
index 30b891911..b5b866d50 100644
--- a/pdf/framework/java/android/graphics/pdf/PdfDocumentProxy.java
+++ b/pdf/framework/java/android/graphics/pdf/PdfDocumentProxy.java
@@ -16,8 +16,12 @@
 
 package android.graphics.pdf;
 
+import android.annotation.IntRange;
+import android.annotation.NonNull;
 import android.graphics.Bitmap;
 import android.graphics.Rect;
+import android.graphics.pdf.component.PdfAnnotation;
+import android.graphics.pdf.component.PdfPageObject;
 import android.graphics.pdf.content.PdfPageGotoLinkContent;
 import android.graphics.pdf.models.FormWidgetInfo;
 import android.graphics.pdf.models.jni.LinkRects;
@@ -118,18 +122,18 @@ public class PdfDocumentProxy {
     /**
      * Renders a page to a bitmap.
      *
-     * @param pageNum the page number of the page to be rendered
-     * @param clipLeft the left coordinate of the clipping boundary in bitmap coordinates
-     * @param clipTop the top coordinate of the clipping boundary in bitmap coordinates
-     * @param clipRight the right coordinate of the clipping boundary in bitmap coordinates
-     * @param clipBottom the bottom coordinate of the clipping boundary in bitmap coordinates
-     * @param transform an affine transform matrix in the form of an array.
-     * @see android.graphics.Matrix#getValues(float[])
-     * @param renderMode the render mode
-     * @param showAnnotTypes Bitmask of renderFlags to indicate the types of annotations to
-     *                       be rendered
+     * @param pageNum          the page number of the page to be rendered
+     * @param clipLeft         the left coordinate of the clipping boundary in bitmap coordinates
+     * @param clipTop          the top coordinate of the clipping boundary in bitmap coordinates
+     * @param clipRight        the right coordinate of the clipping boundary in bitmap coordinates
+     * @param clipBottom       the bottom coordinate of the clipping boundary in bitmap coordinates
+     * @param transform        an affine transform matrix in the form of an array.
+     * @param renderMode       the render mode
+     * @param showAnnotTypes   Bitmask of renderFlags to indicate the types of annotations to
+     *                         be rendered
      * @param renderFormFields true to included PDF form content in the output
      * @return true if the page was rendered into the destination bitmap
+     * @see android.graphics.Matrix#getValues(float[])
      */
     public native boolean render(
             int pageNum,
@@ -253,4 +257,92 @@ public class PdfDocumentProxy {
      */
     public native List<Rect> setFormFieldSelectedIndices(
             int pageNum, int annotIndex, int[] selectedIndices);
+
+    /**
+     * Gets the list of annotations of supported types (freetext, image, stamp) present
+     * on the page
+     *
+     * @param pageNum - page number of the page whose annotations list is to be returned
+     */
+    public native @NonNull List<PdfAnnotation> getPageAnnotations(
+            @IntRange(from = 0) int pageNum);
+
+    /**
+     * Adds an annotation to the given page
+     *
+     * @param pageNum    - page number of the page to which annotation is to be added
+     * @param annotation - annotation to be added to the given page
+     * @return index of the annotation added and -1 in case of failure
+     */
+    public native int addPageAnnotation(@IntRange(from = 0) int pageNum,
+            @NonNull PdfAnnotation annotation);
+
+    /**
+     * Removes an annotation from the given page
+     *
+     * @param pageNum         - page number of the page from which annotation is to be removed
+     * @param annotationId - id of the annotation to be removed
+     */
+    public native PdfAnnotation removePageAnnotation(@IntRange(from = 0) int pageNum,
+            @IntRange(from = 0) int annotationId);
+
+    /**
+     * Updates an annotation on the given page
+     *
+     * @param pageNum     page number of the page on which annotation is to be updated
+     * @param annotation  annotation to be updated
+     */
+    public native boolean updatePageAnnotation(@IntRange(from = 0) int pageNum,
+            PdfAnnotation annotation);
+
+
+    /**
+     * Return list of supported {@link PdfPageObject} present on
+     * the page.
+     * The list will be empty  if there are no supported page
+     * objects present on the page, even if the page contains
+     * other page object types.
+     *
+     * @param pageNum - page number of the page whose annotations list is returned
+     * @return list of {@link PdfPageObject} present on the page
+     * @throws IllegalStateException if the document/page is
+     *                               closed before invocation
+     */
+    public native List<PdfPageObject> getPageObjects(int pageNum);
+
+    /**
+     * Adds the given page object to the page.
+     *
+     * @param pageNum    - page number of the page to which pageObject is to be added
+     * @param pageObject the {@link PdfPageObject} object to
+     *                   add
+     * @return object id of added page object, -1 otherwise
+     * @throws IllegalArgumentException if the provided {@link PdfPageObject} is unknown or null.
+     * @throws IllegalStateException    if the {@link PdfRenderer.Page} is closed before invocation.
+     */
+    public native int addPageObject(int pageNum, @NonNull PdfPageObject pageObject);
+
+    /**
+     * Update the given {@link PdfPageObject} to the page.
+     *
+     * @param pageObject the {@code PdfPageObject} object to
+     *                   add
+     * @return true if page object is updated, false otherwise
+     * @throws IllegalArgumentException if the provided {@link PdfPageObject} is unknown or null.
+     * @throws IllegalStateException    if the {@link PdfRenderer.Page} is closed before invocation.
+     */
+    public native boolean updatePageObject(int pageNum,
+            @NonNull PdfPageObject pageObject);
+
+    /**
+     * Removes the {@link PdfPageObject} with the specified ID.
+     *
+     * @param pageNum  - page number of the page from which annotation is to be removed
+     * @param objectId the ID of the page object to remove
+     *                 from the page
+     * @return {@link PdfPageObject} that is removed.
+     * @throws IllegalStateException if the provided
+     *                               objectId doesn't exist.
+     */
+    public native PdfPageObject removePageObject(int pageNum, int objectId);
 }
diff --git a/pdf/framework/java/android/graphics/pdf/PdfProcessor.java b/pdf/framework/java/android/graphics/pdf/PdfProcessor.java
index 55965eaae..bf2ece386 100644
--- a/pdf/framework/java/android/graphics/pdf/PdfProcessor.java
+++ b/pdf/framework/java/android/graphics/pdf/PdfProcessor.java
@@ -20,12 +20,16 @@ import static android.graphics.pdf.PdfLinearizationTypes.PDF_DOCUMENT_TYPE_LINEA
 import static android.graphics.pdf.PdfLinearizationTypes.PDF_DOCUMENT_TYPE_NON_LINEARIZED;
 
 import android.annotation.FlaggedApi;
+import android.annotation.IntRange;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.graphics.Bitmap;
 import android.graphics.Matrix;
 import android.graphics.Point;
 import android.graphics.Rect;
+import android.graphics.pdf.component.PdfAnnotation;
+import android.graphics.pdf.component.PdfAnnotationType;
+import android.graphics.pdf.component.PdfPageObject;
 import android.graphics.pdf.content.PdfPageGotoLinkContent;
 import android.graphics.pdf.content.PdfPageImageContent;
 import android.graphics.pdf.content.PdfPageLinkContent;
@@ -401,8 +405,7 @@ public class PdfProcessor {
             int pdfFormType = mPdfDocument.getFormType();
             return switch (pdfFormType) {
                 case PDF_FORM_TYPE_ACRO_FORM, PDF_FORM_TYPE_XFA_FULL,
-                        PDF_FORM_TYPE_XFA_FOREGROUND ->
-                        pdfFormType;
+                     PDF_FORM_TYPE_XFA_FOREGROUND -> pdfFormType;
                 default -> PDF_FORM_TYPE_NONE;
             };
         }
@@ -563,6 +566,152 @@ public class PdfProcessor {
         }
     }
 
+    /**
+     * Return list of supported {@link PdfAnnotation} present on the
+     * page. See {@link PdfAnnotationType} for the supported types
+     * <p>
+     * The list will be empty if there are no supported
+     * annotations present on the page, even if the page
+     * contains other annotation types.
+     *
+     * @param pageNum page number whose annotations' list to be retrieved
+     * @return list of supported annotations present on the page
+     */
+    @NonNull
+    public List<PdfAnnotation> getPageAnnotations(@IntRange(from = 0) int pageNum) {
+        synchronized (sPdfiumLock) {
+            assertPdfDocumentNotNull();
+            return mPdfDocument.getPageAnnotations(pageNum);
+        }
+    }
+    /**
+     * Adds the given annotation to the page. The annotation should be of
+     * supported type. See {@link PdfAnnotationType} for the supported types
+     *
+     * @param annotation the {@link PdfAnnotation} object to
+     *        add
+     * @param pageNum the page number where the annotation to be added
+     * @return the index of the added annotation,
+     *         or -1 if the annotation cannot be added. The
+     *         index is guaranteed to be non-negative if
+     *         the annotation is added successfully.
+     */
+    public int addPageAnnotation(@IntRange(from = 0) int pageNum,
+            PdfAnnotation annotation) {
+        synchronized (sPdfiumLock) {
+            assertPdfDocumentNotNull();
+            return mPdfDocument.addPageAnnotation(pageNum, annotation);
+        }
+    }
+
+    /**
+     * Removes the annotation with the specified index.
+     *
+     * @param annotationIndex the index of the annotation to remove
+     * from the page
+     * @param pageNum page number from which annotation is to be removed
+     * @return the removed annotation
+     *
+     */
+    public PdfAnnotation removePageAnnotation(@IntRange(from = 0) int pageNum,
+            int annotationIndex) {
+        synchronized (sPdfiumLock) {
+            assertPdfDocumentNotNull();
+            return mPdfDocument.removePageAnnotation(pageNum, annotationIndex);
+        }
+    }
+
+    /**
+     * Update the given {@link PdfAnnotation} to the page.
+     *
+     * @param annotation the annotation to update
+     *
+     * @return true if annotation is updated, false otherwise
+     *
+     * @throws IllegalArgumentException f the provided annotation is null or of
+     *         unsupported type i.e. {@link PdfAnnotationType#UNKNOWN}
+     *
+     **/
+    @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
+    public boolean updatePageAnnotation(int pageNum,
+            @NonNull PdfAnnotation annotation) {
+        synchronized (sPdfiumLock) {
+            assertPdfDocumentNotNull();
+            return mPdfDocument.updatePageAnnotation(pageNum, annotation);
+        }
+    }
+
+    /**
+     * Return list of supported {@link PdfPageObject} present on
+     * the page.
+     * The list will be empty  if there are no supported page
+     * objects present on the page, even if the page contains
+     * other page object types.
+     *
+     * @return list of page objects present on the page
+     * @throws IllegalStateException if the {@link PdfRenderer.Page} is
+     *                               closed before invocation
+     */
+    @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
+    public List<PdfPageObject> getPageObjects(int pageNum) {
+        synchronized (sPdfiumLock) {
+            assertPdfDocumentNotNull();
+            return mPdfDocument.getPageObjects(pageNum);
+        }
+    }
+
+    /**
+     * Adds the given {@link PdfPageObject} to the page.
+     *
+     * @param pageObject the {@link PdfPageObject} object to
+     *                   add
+     * @return object id of added page object, -1 otherwise
+     * @throws IllegalArgumentException if the provided {@link PdfPageObject} is unknown or null.
+     * @throws IllegalStateException    if the {@link PdfRenderer.Page} is closed before invocation.
+     */
+    @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
+    public int addPageObject(int pageNum, @NonNull PdfPageObject pageObject) {
+        synchronized (sPdfiumLock) {
+            assertPdfDocumentNotNull();
+            return mPdfDocument.addPageObject(pageNum, pageObject);
+        }
+    }
+
+    /**
+     * Update the given {@link PdfPageObject} to the page.
+     *
+     * @param pageObject the {@link PdfPageObject} object to
+     *                   add
+     * @return true if page object is updated, false otherwise
+     * @throws IllegalArgumentException if the provided {@link PdfPageObject} is unknown or null.
+     * @throws IllegalStateException    if the {@link PdfRenderer.Page} is closed before invocation.
+     */
+    @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
+    public boolean updatePageObject(int pageNum,
+            @NonNull PdfPageObject pageObject) {
+        synchronized (sPdfiumLock) {
+            assertPdfDocumentNotNull();
+            return mPdfDocument.updatePageObject(pageNum, pageObject);
+        }
+    }
+
+    /**
+     * Removes the {@link PdfPageObject} with the specified ID.
+     *
+     * @param objectId the id of the page object to remove
+     *                 from the page
+     * @return {@link PdfPageObject} that is removed.
+     * @throws IllegalStateException if the provided
+     *                               objectId doesn't exist.
+     */
+    @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
+    public PdfPageObject removePageObject(int pageNum, int objectId) {
+        synchronized (sPdfiumLock) {
+            assertPdfDocumentNotNull();
+            return mPdfDocument.removePageObject(pageNum, objectId);
+        }
+    }
+
     /**
      * Creates a copy of the current document without security, if it is password protected. This
      * may be necessary for the PrintManager which can't handle password-protected files.
diff --git a/pdf/framework/java/android/graphics/pdf/PdfRendererPreV.java b/pdf/framework/java/android/graphics/pdf/PdfRendererPreV.java
index 40e0d0921..104061a36 100644
--- a/pdf/framework/java/android/graphics/pdf/PdfRendererPreV.java
+++ b/pdf/framework/java/android/graphics/pdf/PdfRendererPreV.java
@@ -21,11 +21,16 @@ import static android.graphics.pdf.PdfLinearizationTypes.PDF_DOCUMENT_TYPE_LINEA
 import android.annotation.FlaggedApi;
 import android.annotation.IntDef;
 import android.annotation.IntRange;
+import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.SuppressLint;
 import android.graphics.Bitmap;
 import android.graphics.Matrix;
 import android.graphics.Rect;
+import android.graphics.pdf.component.PdfAnnotation;
+import android.graphics.pdf.component.PdfAnnotationType;
+import android.graphics.pdf.component.PdfPageObject;
+import android.graphics.pdf.component.PdfPageObjectType;
 import android.graphics.pdf.content.PdfPageGotoLinkContent;
 import android.graphics.pdf.content.PdfPageImageContent;
 import android.graphics.pdf.content.PdfPageLinkContent;
@@ -39,7 +44,6 @@ import android.graphics.pdf.models.selection.SelectionBoundary;
 import android.graphics.pdf.utils.Preconditions;
 import android.os.ParcelFileDescriptor;
 
-import androidx.annotation.NonNull;
 import androidx.annotation.RestrictTo;
 
 import java.io.IOException;
@@ -608,6 +612,202 @@ public final class PdfRendererPreV implements AutoCloseable {
             return mPdfProcessor.applyEdit(mIndex, editRecord);
         }
 
+        /**
+         * Return list of supported {@link PdfAnnotation} present on the
+         * page. See {@link PdfAnnotationType} for the supported types
+         * <p>
+         * The list will be empty if there are no supported
+         * annotations present on the page, even if the page
+         * contains other annotation types.
+         *
+         * @return list of supported annotations present on the page
+         * @throws IllegalStateException if {@link PdfRendererPreV} or
+         *         {@link PdfRendererPreV.Page} is closed before invocation.
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_ANNOTATIONS)
+        @NonNull
+        public List<PdfAnnotation> getPageAnnotations() {
+            throwIfDocumentOrPageClosed();
+            return mPdfProcessor.getPageAnnotations(mIndex);
+        }
+
+        /**
+         * Adds the given annotation to the page. The annotation should be of
+         * supported type. See {@link PdfAnnotationType} for the supported types
+         *
+         * @param annotation the {@link PdfAnnotation} object to
+         *        add
+         * @return id of the added annotation,
+         *         or -1 if the annotation cannot be added. The
+         *         id is guaranteed to be non-negative if
+         *         the annotation is added successfully.
+         * @throws IllegalArgumentException if the provided
+         *         {@code annotation} is null or of unsupported type i.e.-
+         *         {@link PdfAnnotationType#UNKNOWN} or if the annotation is already
+         *          added in this page or some other page of the document.
+         *
+         * @throws IllegalStateException if {@link PdfRendererPreV} or
+         *         {@link PdfRendererPreV.Page} is closed before invocation.
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_ANNOTATIONS)
+        public int addPageAnnotation(@NonNull PdfAnnotation annotation) {
+            throwIfDocumentOrPageClosed();
+            Preconditions.checkNotNull(annotation, "Annotation should not be null");
+            Preconditions.checkArgument(
+                    annotation.getPdfAnnotationType() != PdfAnnotationType.UNKNOWN,
+                    "Annotation should be of valid type");
+            Preconditions.checkArgument(annotation.getId() != -1,
+                    "Annotation already added");
+            return mPdfProcessor.addPageAnnotation(mIndex, annotation);
+
+        }
+
+        /**
+         * Removes the annotation with the specified id.
+         *
+         * @param annotationId id of the annotation to remove from the page
+         * @return the removed annotation
+         *
+         * @throws IllegalArgumentException if annotationId ie negative
+         *
+         * @throws IllegalStateException if {@link PdfRendererPreV} or
+         *        {@link PdfRendererPreV.Page} is closed before invocation or if
+         *        annotation is failed to get removed from the page.
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_ANNOTATIONS)
+        @NonNull
+        public PdfAnnotation removePageAnnotation(int annotationId) {
+            throwIfDocumentOrPageClosed();
+            Preconditions.checkArgument(annotationId >= 0,
+                    "Annotation id should be non-negative");
+            PdfAnnotation removedAnnotation = mPdfProcessor.removePageAnnotation(mIndex,
+                    annotationId);
+            if (removedAnnotation == null) {
+                throw new IllegalStateException(
+                        "Failed to remove annotation with id " + annotationId);
+            }
+            return removedAnnotation;
+        }
+
+
+        /**
+         * Update the given {@link PdfAnnotation} to the page.
+         *
+         * @param annotation the annotation to update
+         *
+         * @return true if annotation is updated, false otherwise
+         *
+         * @throws IllegalArgumentException f the provided annotation is null or of
+         *         unsupported type i.e. {@link PdfAnnotationType#UNKNOWN}
+         *
+         * @throws IllegalStateException if {@link PdfRendererPreV} or
+         *         {@link PdfRendererPreV.Page}  is closed before invocation
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_ANNOTATIONS)
+        public boolean updatePageAnnotation(@NonNull PdfAnnotation annotation) {
+            throwIfDocumentOrPageClosed();
+            Preconditions.checkNotNull(annotation, "PdfAnnotation should not be null");
+            Preconditions.checkArgument(
+                    annotation.getPdfAnnotationType() != PdfAnnotationType.UNKNOWN,
+                    "Annotation should be of valid type");
+
+            Preconditions.checkArgument(annotation.getId() >= 0,
+                    "Annotation id should be greater than equal to 0");
+            return mPdfProcessor.updatePageAnnotation(mIndex, annotation);
+        }
+
+        /**
+         * Return list of supported {@link PdfPageObject} present on
+         * the page.
+         * The list will be empty if there are no supported page
+         * objects present on the page, even if the page contains
+         * other page object types.
+         *
+         * @return list of page objects present on the page
+         *
+         * @throws IllegalStateException    if the {@link PdfRenderer.Page} is closed before
+         *                                  invocation.
+         */
+        @android.annotation.NonNull
+        @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
+        public List<PdfPageObject> getPageObjects() {
+            throwIfDocumentOrPageClosed();
+            return mPdfProcessor.getPageObjects(mIndex);
+        }
+
+        /**
+         * Adds the given {@link PdfPageObject} to the page.
+         *
+         * @param pageObject the {@code PdfPageObject} object to
+         *                   add, existing page object cannot be used (i.e. it should not have
+         *                   objectId).
+         * @return object id of added page object, -1 otherwise
+         * @throws IllegalArgumentException if the provided {@link PdfPageObject} is unknown, null
+         *                                  or if the object is already added to a page or an
+         *                                  annotation.
+         * @throws IllegalStateException    if the {@link PdfRenderer.Page} is closed before
+         *                                  invocation.
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
+        public int addPageObject(@android.annotation.NonNull PdfPageObject pageObject) {
+            throwIfDocumentOrPageClosed();
+            Preconditions.checkNotNull(pageObject, "PdfPageObject should not be null.");
+            Preconditions.checkArgument(
+                    pageObject.getPdfObjectType() != PdfPageObjectType.UNKNOWN,
+                    "PageObject should be of valid type.");
+            Preconditions.checkArgument(pageObject.getObjectId() == -1,
+                    "PageObject should not have an object id.");
+            Preconditions.checkArgument(!pageObject.isAddedInAnnotation(),
+                    "PageObject already added to an annotation");
+            return mPdfProcessor.addPageObject(mIndex, pageObject);
+        }
+
+        /**
+         * Update the given {@link PdfPageObject} to the page.
+         *
+         * @param pageObject the {@code PdfPageObject} object to
+         *                   add.
+         * @return true if page object is updated, false otherwise.
+         * @throws IllegalArgumentException if the provided {@link PdfPageObject} is unknown or
+         *                                  null.
+         * @throws IllegalStateException    if the {@link PdfRenderer.Page} is closed before
+         *                                  invocation.
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
+        public boolean updatePageObject(@NonNull PdfPageObject pageObject) {
+            throwIfDocumentOrPageClosed();
+            Preconditions.checkNotNull(pageObject, "PdfPageObject should not be null");
+            Preconditions.checkArgument(
+                    pageObject.getPdfObjectType() != PdfPageObjectType.UNKNOWN,
+                    "PageObject should be of valid type");
+            Preconditions.checkArgument(pageObject.getObjectId() >= 0,
+                    "Page object id should be greater than equal to 0.");
+            return mPdfProcessor.updatePageObject(mIndex, pageObject);
+        }
+
+        /**
+         * Removes the {@link PdfPageObject} with the specified ID.
+         *
+         * @param objectId the id of the page object to remove
+         *                 from the page.
+         * @return {@link PdfPageObject} that is removed.
+         * @throws IllegalArgumentException if the provided
+         *                                  objectId doesn't exist.
+         * @throws IllegalStateException    if the page object cannot be removed.
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
+        @NonNull
+        public PdfPageObject removePageObject(int objectId) {
+            throwIfDocumentOrPageClosed();
+            Preconditions.checkArgument(objectId >= 0,
+                    "Page object id should be greater than equal to 0.");
+            PdfPageObject pageObject = mPdfProcessor.removePageObject(mIndex, objectId);
+            if (pageObject == null) {
+                throw new IllegalStateException("Page object cannot be removed.");
+            }
+            return pageObject;
+        }
+
         /**
          * Closes this page.
          *
@@ -632,7 +832,7 @@ public final class PdfRendererPreV implements AutoCloseable {
         }
 
         private void doClose() {
-            if (mPdfProcessor != null) {
+            if (mPdfProcessor != null && mIndex != -1) {
                 mPdfProcessor.releasePage(mIndex);
                 mIndex = -1;
             }
diff --git a/pdf/framework/java/android/graphics/pdf/component/FreeTextAnnotation.java b/pdf/framework/java/android/graphics/pdf/component/FreeTextAnnotation.java
new file mode 100644
index 000000000..32d0762f6
--- /dev/null
+++ b/pdf/framework/java/android/graphics/pdf/component/FreeTextAnnotation.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.graphics.pdf.component;
+
+import android.annotation.ColorInt;
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.graphics.Color;
+import android.graphics.RectF;
+import android.graphics.pdf.flags.Flags;
+
+/**
+ * Represents a free text annotation in a PDF document.
+ * <p>
+ * This class allows creating and manipulating free text
+ * annotations. A free text annotation in a PDF is a type of
+ * annotation that allows you to add text directly onto the page.
+ * <p>
+ * If text color is not set using
+ * {@link #setTextColor(int)}, the default text color is
+ * black and if the background color is not set using
+ * {@link #setBackgroundColor(int)}, the default background color is
+ * white.
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_TEXT_ANNOTATIONS)
+public final class FreeTextAnnotation extends PdfAnnotation {
+    @NonNull private String mTextContent;
+    private @ColorInt int mTextColor;
+    private @ColorInt int mBackgroundColor;
+
+    /**
+     * Creates a new free text annotation with the specified bounds and text content.
+     * <p>
+     * The default text color and background color will be black and white respectively
+     *
+     * @param bounds The bounding rectangle of the annotation.
+     * @param textContent The text content of the annotation
+     */
+    public FreeTextAnnotation(@NonNull RectF bounds, @NonNull String textContent) {
+        super(PdfAnnotationType.FREETEXT, bounds);
+        this.mTextContent = textContent;
+        this.mTextColor = Color.BLACK;
+        this.mBackgroundColor = Color.WHITE;
+    }
+
+    /**
+     * Sets the text content of the annotation.
+     *
+     * @param text The new text content.
+     */
+    public void setTextContent(@NonNull String text) {
+        mTextContent = text;
+    }
+
+    /**
+     * Returns the text content of the freetext annotation.
+     *
+     * @return The text content.
+     */
+    @NonNull public String getTextContent() {
+        return mTextContent;
+    }
+
+    /**
+     * Sets the text color of the annotation.
+     *
+     * @param color The new text color.
+     */
+    public void setTextColor(@ColorInt int color) {
+        this.mTextColor = color;
+    }
+
+    /**
+     * Returns the text color of the freetext annotation.
+     *
+     * @return The text color.
+     */
+    public @ColorInt int getTextColor() {
+        return mTextColor;
+    }
+
+    /**
+     * Sets the background color of the freetext annotation.
+     *
+     * @param color The new background color.
+     */
+    public void setBackgroundColor(@ColorInt int color) {
+        this.mBackgroundColor = color;
+    }
+
+    /**
+     * Returns the background color of the freetext annotation.
+     *
+     * @return The background color.
+     */
+    public @ColorInt int getBackgroundColor() {
+        return this.mBackgroundColor;
+    }
+
+}
diff --git a/pdf/framework/java/android/graphics/pdf/component/HighlightAnnotation.java b/pdf/framework/java/android/graphics/pdf/component/HighlightAnnotation.java
new file mode 100644
index 000000000..d3f5d27af
--- /dev/null
+++ b/pdf/framework/java/android/graphics/pdf/component/HighlightAnnotation.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.graphics.pdf.component;
+
+import android.annotation.ColorInt;
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.graphics.Color;
+import android.graphics.RectF;
+import android.graphics.pdf.flags.Flags;
+
+/**
+ * Represents a highlight annotation in a PDF document.
+ *
+ * <p>If the highlight color is not explicitly set using {@link #setColor(Color)},
+ * the default color is yellow.</p>
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_ANNOTATIONS)
+public final class HighlightAnnotation extends PdfAnnotation {
+    private @ColorInt int mColor;
+
+    /**
+     * Creates a new highlight annotation with the specified bounds.
+     * <p>
+     * The default highlight color is yellow
+     *
+     * @param bounds The bounding rectangle of the annotation.
+     */
+    public HighlightAnnotation(@NonNull RectF bounds) {
+        super(PdfAnnotationType.HIGHLIGHT, bounds);
+        this.mColor = Color.YELLOW;
+    }
+
+    /**
+     * Returns the highlight color of the annotation.
+     *
+     * @return The highlight color.
+     */
+    public @ColorInt int getColor() {
+        return mColor;
+    }
+
+    /**
+     * Sets the highlight color of the annotation.
+     *
+     * @param color The new highlight color.
+     */
+    public void setColor(@ColorInt int color) {
+        this.mColor = color;
+    }
+
+}
diff --git a/pdf/framework/java/android/graphics/pdf/component/PdfAnnotation.java b/pdf/framework/java/android/graphics/pdf/component/PdfAnnotation.java
new file mode 100644
index 000000000..73a4d437d
--- /dev/null
+++ b/pdf/framework/java/android/graphics/pdf/component/PdfAnnotation.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.graphics.pdf.component;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.graphics.RectF;
+import android.graphics.pdf.flags.Flags;
+import android.graphics.pdf.utils.Preconditions;
+
+/**
+ * Represents a PDF annotation on a page of a PDF document.
+ * This abstract class provides a base implementation for different types of PDF annotations
+ * such as text ({@link FreeTextAnnotation}),
+ * highlight ({@link HighlightAnnotation}) etc
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_ANNOTATIONS)
+public abstract class PdfAnnotation {
+    private int mId;
+    private int mType;
+    @NonNull  private RectF mBounds;
+
+    /**
+     * Creates a new PDF annotation with the specified type and bounds.
+     *
+     * @param type   The type of annotation. See {@link PdfAnnotationType} for possible values.
+     * @param bounds The bounding rectangle of the annotation.
+     */
+    PdfAnnotation(@PdfAnnotationType.Type int type, @NonNull RectF bounds) {
+        Preconditions.checkNotNull(bounds, "Bounds cannot be null");
+        Preconditions.checkArgument(type == PdfAnnotationType.UNKNOWN
+                || type == PdfAnnotationType.FREETEXT
+                || type == PdfAnnotationType.HIGHLIGHT
+                || type == PdfAnnotationType.STAMP, "Invalid Annotation Type");
+
+        this.mId = -1;
+        this.mType = type;
+        this.mBounds = bounds;
+    }
+
+    /**
+     * Returns the id of the annotation.
+     * <p>
+     * Id of an annotation will be unique in a page.
+     *
+     * @return The annotation ID.
+     */
+    public int getId() {
+        return mId;
+    }
+
+    /**
+     * Sets the id of the annotation.
+     * <p>
+     * When the annotation is created, it's assigned default id as -1, when it will
+     * added to a page using
+     * {@link  android.graphics.pdf.PdfRenderer.Page#addPageAnnotation(PdfAnnotation)}
+     * or {@link android.graphics.pdf.PdfRendererPreV.Page#addPageAnnotation(PdfAnnotation)},
+     * it will get assigned a unique id in the page.
+     * </p>
+     *
+     * @param id to be assigned to the annotation
+     * @hide
+     */
+    protected void setId(int id) {
+        mId = id;
+    }
+
+    /**
+     * Returns the type of the annotation.
+     *
+     * @return The annotation type. See {@link PdfAnnotationType} for possible values.
+     */
+    public @PdfAnnotationType.Type int getPdfAnnotationType() {
+        return mType;
+    }
+
+    /**
+     * Sets the bounding rectangle of the annotation.
+     *
+     * @param bounds The new bounding rectangle.
+     */
+    public void setBounds(@NonNull RectF bounds) {
+        this.mBounds = bounds;
+    }
+
+    /**
+     * Returns the bounding rectangle of the annotation.
+     *
+     * @return The bounding rectangle.
+     */
+    @NonNull public RectF getBounds() {
+        return mBounds;
+    }
+
+}
diff --git a/pdf/framework/java/android/graphics/pdf/component/PdfAnnotationType.java b/pdf/framework/java/android/graphics/pdf/component/PdfAnnotationType.java
new file mode 100644
index 000000000..6c60a1e29
--- /dev/null
+++ b/pdf/framework/java/android/graphics/pdf/component/PdfAnnotationType.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.graphics.pdf.component;
+
+import android.annotation.FlaggedApi;
+import android.annotation.IntDef;
+import android.graphics.pdf.flags.Flags;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * This class holds the set of constants representing the types of a PDF annotation.
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_ANNOTATIONS)
+public final class PdfAnnotationType {
+
+    // Private constructor
+    private PdfAnnotationType() {
+    }
+
+
+    /**
+     * Represents the type of annotation that cannot be determined
+     */
+    public static final int UNKNOWN = 0;
+
+    /**
+     * Represents a freetext annotation
+     */
+    // Todo: b/382076427 - Add test for validating the behavior for this flag enabled/disabled
+    @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_TEXT_ANNOTATIONS)
+    public static final int FREETEXT = 1;
+
+    /**
+     * Represents a highlight annotation
+     */
+    public static final int HIGHLIGHT = 2;
+
+    /**
+     * Represents a stamp annotation
+     */
+    // Todo: b/382036496 - Add stamp annotation class in a follow up cl
+    public static final int STAMP = 3;
+
+    /** @hide */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({UNKNOWN, FREETEXT, HIGHLIGHT, STAMP})
+    public @interface Type {
+    }
+}
+
+
diff --git a/pdf/framework/java/android/graphics/pdf/component/PdfPageImageObject.java b/pdf/framework/java/android/graphics/pdf/component/PdfPageImageObject.java
new file mode 100644
index 000000000..5ed71c348
--- /dev/null
+++ b/pdf/framework/java/android/graphics/pdf/component/PdfPageImageObject.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.graphics.pdf.component;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.graphics.Bitmap;
+import android.graphics.pdf.flags.Flags;
+
+/**
+ * Represents an image object on a PDF page. This class extends
+ * {@link PdfPageObject} and provides methods to access and modify the
+ * image content.
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
+public final class PdfPageImageObject extends PdfPageObject {
+    private Bitmap mImage;
+
+    /**
+     * Constructor for the PdfPageImageObject. Sets the object type
+     * to IMAGE.
+     */
+    public PdfPageImageObject(@NonNull Bitmap image) {
+        super(PdfPageObjectType.IMAGE);
+        this.mImage = image;
+    }
+
+    /**
+     * Returns the bitmap image of the object.
+     *
+     * @return The bitmap image of the object.
+     */
+    @NonNull
+    public Bitmap getBitmap() {
+        return mImage;
+    }
+
+    /**
+     * Sets the bitmap image of the object.
+     *
+     * @param image The bitmap image to set.
+     */
+    public void setBitmap(@NonNull Bitmap image) {
+        this.mImage = image;
+    }
+
+}
diff --git a/pdf/framework/java/android/graphics/pdf/component/PdfPageObject.java b/pdf/framework/java/android/graphics/pdf/component/PdfPageObject.java
new file mode 100644
index 000000000..7a2fc6431
--- /dev/null
+++ b/pdf/framework/java/android/graphics/pdf/component/PdfPageObject.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.graphics.pdf.component;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.graphics.Matrix;
+import android.graphics.RectF;
+import android.graphics.pdf.flags.Flags;
+
+/**
+ * Represents a page object on a page of a pdf document.
+ * This abstract class provides a base implementation for
+ * different types of PDF page objects.
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
+public abstract class PdfPageObject {
+    // Possible Values are {@link PdfPageObjectType}
+    private final int mType;
+
+    // Id of page object
+    private int mObjectId;
+
+    // Bound of page object
+    private RectF mBounds;
+
+    // Transformation matrix of page object
+    private Matrix mTransform;
+
+    private boolean mIsAddedInAnnotation;
+
+    /**
+     * Constructor for the PageObject.
+     *
+     * @param type The type of the page object.
+     */
+    PdfPageObject(int type) {
+        this.mType = type;
+        this.mTransform = new Matrix(); // Initialize with identity matrix
+        this.mObjectId = -1; // Initialize with -1
+        this.mIsAddedInAnnotation = false;
+    }
+
+    /**
+     * Returns the type of the page object.
+     *
+     * @return The type of the page object.
+     */
+    public int getPdfObjectType() {
+        return mType;
+    }
+
+    /**
+     * Returns the ID of the object.
+     *
+     * @return The ID of the object.
+     */
+    public int getObjectId() {
+        return mObjectId;
+    }
+
+    /**
+     * Sets the objectIndex of the object.
+     *
+     * @param objectId The objectIndex of the object.
+     * @hide
+     */
+    protected void setObjectId(int objectId) {
+        this.mObjectId = objectId;
+    }
+
+    /**
+     * Returns the bounding rectangle of the object.
+     *
+     * @return The bounding rectangle of the object.
+     */
+    @NonNull
+    public RectF getBounds() {
+        return mBounds;
+    }
+
+    /**
+     * Sets the bounding rectangle of the object.
+     *
+     * @param bounds The bounding rectangle of the object.
+     */
+    public void setBounds(@NonNull RectF bounds) {
+        this.mBounds = bounds;
+    }
+
+    /**
+     * Transform the page object
+     * The matrix is composed as:
+     * |a c e|
+     * |b d f|
+     * and can be used to scale, rotate, shear and translate the |page_object|.
+     */
+    public void transform(float a, float b, float c, float d, float e, float f) {
+        Matrix matrix = new Matrix();
+        matrix.setValues(new float[]{a, e, d, c, b, f, 0, 0, 1}); // Set the matrix values
+        this.mTransform.postConcat(matrix); // Apply the transformation
+
+        // Update the objectRect based on the new transformation
+        if (this.mBounds != null) {
+            RectF newRect = new RectF(this.mBounds);
+            matrix.mapRect(newRect);
+            this.mBounds.set(newRect);
+        }
+    }
+
+    /**
+     * Returns the transformation matrix of the object.
+     *
+     * @return The transformation matrix of the object.
+     */
+    @NonNull
+    public float[] getMatrix() {
+        float[] value = new float[9];
+        this.mTransform.getValues(value);
+        return value;
+    }
+
+    /**
+     * Sets the transformation matrix of the object.
+     *
+     * @param matrix The transformation matrix of the object.
+     */
+    public void setMatrix(@NonNull Matrix matrix) {
+        this.mTransform = matrix;
+    }
+
+    /*
+     * Returns {@code true} if the page object is added to an annotation, else false
+     */
+    public boolean isAddedInAnnotation() {
+        return mIsAddedInAnnotation;
+    }
+
+    /*
+    * Sets that this page object is added to an annotation
+    * @hide
+    */
+    void setAddedInAnnotation() {
+        mIsAddedInAnnotation = true;
+    }
+}
diff --git a/pdf/framework/java/android/graphics/pdf/component/PdfPageObjectType.java b/pdf/framework/java/android/graphics/pdf/component/PdfPageObjectType.java
new file mode 100644
index 000000000..b6a48cd6d
--- /dev/null
+++ b/pdf/framework/java/android/graphics/pdf/component/PdfPageObjectType.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.graphics.pdf.component;
+
+import android.annotation.FlaggedApi;
+import android.annotation.IntDef;
+import android.graphics.pdf.flags.Flags;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * This class holds the set of constants representing the types of a PDF page objects.
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
+public final class PdfPageObjectType {
+    // Private constructor
+    private PdfPageObjectType() {
+    }
+
+    /**
+     * Represents the type of page object that cannot be determined
+     */
+    public static final int UNKNOWN = 0;
+
+    /**
+     * Represents a text page object
+     */
+    @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_TEXT_OBJECTS)
+    public static final int TEXT = 1;
+    /**
+     * Represents a path page object
+     */
+    public static final int PATH = 2;
+
+    /**
+     * Represents an image page object
+     */
+    public static final int IMAGE = 3;
+
+
+    /** @hide */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({UNKNOWN, TEXT, PATH, IMAGE})
+    public @interface Type {
+    }
+
+    /**
+     * Checks if the given type is a valid PDF page object type.
+     *
+     * @param type The type to check.
+     * @return {@code true} if the type is valid, {@code false} otherwise.
+     */
+    public static boolean isValidType(int type) {
+        if (Flags.enableEditPdfTextObjects()) {
+            return type == TEXT || type == PATH || type == IMAGE;
+        }
+        return type == PATH || type == IMAGE;
+    }
+}
diff --git a/pdf/framework/java/android/graphics/pdf/component/PdfPagePathObject.java b/pdf/framework/java/android/graphics/pdf/component/PdfPagePathObject.java
new file mode 100644
index 000000000..e3d5d8020
--- /dev/null
+++ b/pdf/framework/java/android/graphics/pdf/component/PdfPagePathObject.java
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.graphics.pdf.component;
+
+import android.annotation.FlaggedApi;
+import android.annotation.IntDef;
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.graphics.Color;
+import android.graphics.DashPathEffect;
+import android.graphics.Matrix;
+import android.graphics.Path;
+import android.graphics.PathEffect;
+import android.graphics.RectF;
+import android.graphics.pdf.flags.Flags;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * Represents a path object on a PDF page. This class extends
+ * {@link PdfPageObject} and provides methods to access and modify the
+ * path's content, such as its shape, fill color, stroke color, line width,
+ * and line style.
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
+public final class PdfPagePathObject extends PdfPageObject {
+    private Path mPath;
+    private PathEffect mLineStyle;
+    private Color mStrokeColor;
+    private float mStrokeWidth;
+    private Color mFillColor;
+
+    /**
+     * Constructor for the PdfPagePathObject. Sets the object type
+     * to {@link PdfPageObjectType#PATH}.
+     */
+    public PdfPagePathObject() {
+        super(PdfPageObjectType.PATH);
+        this.mPath = new Path();
+        this.mStrokeColor = new Color(); // Default is opaque black in the sRGB color space.
+        this.mStrokeWidth = 1.0f;
+    }
+
+    /**
+     * Returns the path of the object.
+     *
+     * @return The path.
+     */
+    @NonNull
+    public Path getPath() {
+        return mPath;
+    }
+
+    /**
+     * Sets the path of the object.
+     *
+     * @param path The path to set.
+     */
+    public void setPath(@NonNull Path path) {
+        this.mPath = path;
+    }
+
+    /**
+     * Returns the line style of the object's stroke.
+     *
+     * @return The {@link PathEffect} representing the line style, or null if no
+     * style is set.
+     */
+    @Nullable
+    public PathEffect getLineStyle() {
+        return mLineStyle;
+    }
+
+    /**
+     * Returns the stroke color of the object.
+     *
+     * @return The stroke color of the object.
+     */
+    @NonNull
+    public Color getStrokeColor() {
+        return mStrokeColor;
+    }
+
+    /**
+     * Sets the stroke color of the object.
+     *
+     * @param strokeColor The stroke color of the object.
+     */
+    public void setStrokeColor(@NonNull Color strokeColor) {
+        this.mStrokeColor = strokeColor;
+    }
+
+    /**
+     * Returns the stroke width of the object.
+     *
+     * @return The stroke width of the object.
+     */
+    public float getStrokeWidth() {
+        return mStrokeWidth;
+    }
+
+    /**
+     * Sets the stroke width of the object.
+     *
+     * @param strokeWidth The stroke width of the object.
+     */
+    public void setStrokeWidth(float strokeWidth) {
+        this.mStrokeWidth = strokeWidth;
+    }
+
+    /**
+     * Sets the line style of the object's stroke.
+     *
+     * @param lineStyle An integer representing the line style to set.
+     */
+    public void setLineStyle(int lineStyle) {
+        switch (lineStyle) {
+            case LineStyle.DASHED: // Example: Dashed line
+                this.mLineStyle = new DashPathEffect(new float[]{10, 5}, 0);
+                break;
+            case LineStyle.DOTTED: // Example: Dotted line
+                this.mLineStyle = new DashPathEffect(new float[]{2, 2}, 0);
+                break;
+            default: // Solid line (no effect)
+                this.mLineStyle = null;
+                break;
+        }
+    }
+
+    /**
+     * Returns the fill color of the object.
+     *
+     * @return The fill color of the object.
+     */
+    @Nullable
+    public Color getFillColor() {
+        return mFillColor;
+    }
+
+    /**
+     * Sets the fill color of the object.
+     *
+     * @param fillColor The fill color of the object.
+     */
+    public void setFillColor(@Nullable Color fillColor) {
+        this.mFillColor = fillColor;
+    }
+
+    /**
+     * Overrides the
+     * {@link PdfPageObject#transform(float, float, float, float, float, float)}
+     * method to correctly transform the Path object.
+     *
+     * This method applies the given affine transformation matrix to the path and
+     * also updates the object's bounding rectangle.
+     *
+     * @param a The a value of the transformation matrix.
+     * @param b The b value of the transformation matrix.
+     * @param c The c value of the transformation matrix.
+     * @param d The d value of the transformation matrix.
+     * @param e The e value of the transformation matrix.
+     * @param f The f value of the transformation matrix.
+     */
+    @Override
+    public void transform(float a, float b, float c, float d, float e, float f) {
+        Matrix matrix = new Matrix();
+        matrix.setValues(new float[]{a, c, e, b, d, f, 0, 0, 1});
+        this.mPath.transform(matrix);
+
+        // Also transform the objectRect
+        RectF newRect = new RectF(this.getBounds());
+        matrix.mapRect(newRect);
+        this.getBounds().set(newRect);
+    }
+
+    /** @hide */
+    @IntDef({LineStyle.SOLID, LineStyle.DASHED, LineStyle.DOTTED})
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface LineStyle {
+        /** Solid line (no effect). */
+        int SOLID = 0;
+        /** Dashed line. */
+        int DASHED = 1;
+        /** Dotted line. */
+        int DOTTED = 2;
+    }
+}
diff --git a/pdf/framework/java/android/graphics/pdf/component/PdfPageTextObject.java b/pdf/framework/java/android/graphics/pdf/component/PdfPageTextObject.java
new file mode 100644
index 000000000..c004af2a6
--- /dev/null
+++ b/pdf/framework/java/android/graphics/pdf/component/PdfPageTextObject.java
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.graphics.pdf.component;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.graphics.Color;
+import android.graphics.Typeface;
+import android.graphics.pdf.flags.Flags;
+
+/**
+ * Represents a text object on a PDF page.
+ * This class extends PageObject and provides methods to access and modify the text content.
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_PAGE_OBJECTS)
+public final class PdfPageTextObject extends PdfPageObject {
+    private String mText;
+    private Typeface mTypeface;
+    private float mFontSize;
+    private Color mStrokeColor = new Color(); // Default is opaque black in the sRGB color space.
+    private float mStrokeWidth = 1.0f;
+    private Color mFillColor;
+
+    /**
+     * Constructor for the PdfPageTextObject.
+     * Sets the object type to TEXT and initializes the text color to black.
+     *
+     * @param typeface The font of the text.
+     * @param fontSize The font size of the text.
+     */
+    @FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_TEXT_OBJECTS)
+    public PdfPageTextObject(@NonNull String text, @NonNull Typeface typeface, float fontSize) {
+        super(PdfPageObjectType.TEXT);
+        this.mText = text;
+        this.mTypeface = typeface;
+        this.mFontSize = fontSize;
+    }
+
+    /**
+     * Returns the text content of the object.
+     *
+     * @return The text content.
+     */
+    @NonNull
+    public String getText() {
+        return mText;
+    }
+
+    /**
+     * Sets the text content of the object.
+     *
+     * @param text The text content to set.
+     */
+    public void setText(@NonNull String text) {
+        this.mText = text;
+    }
+
+    /**
+     * Returns the font size of the object.
+     *
+     * @return The font size.
+     */
+    public float getFontSize() {
+        return mFontSize;
+    }
+
+    /**
+     * Sets the font size of the object.
+     *
+     * @param fontSize The font size to set.
+     */
+    public void setFontSize(float fontSize) {
+        mFontSize = fontSize;
+    }
+
+    /**
+     * Returns the stroke color of the object.
+     *
+     * @return The stroke color of the object.
+     */
+    @NonNull
+    public Color getStrokeColor() {
+        return mStrokeColor;
+    }
+
+    /**
+     * Sets the stroke color of the object.
+     *
+     * @param strokeColor The stroke color of the object.
+     */
+    public void setStrokeColor(@NonNull Color strokeColor) {
+        this.mStrokeColor = strokeColor;
+    }
+
+    /**
+     * Returns the stroke width of the object.
+     *
+     * @return The stroke width of the object.
+     */
+    public float getStrokeWidth() {
+        return mStrokeWidth;
+    }
+
+    /**
+     * Sets the stroke width of the object.
+     *
+     * @param strokeWidth The stroke width of the object.
+     */
+    public void setStrokeWidth(float strokeWidth) {
+        this.mStrokeWidth = strokeWidth;
+    }
+
+    /**
+     * Returns the font of the text.
+     *
+     * @return The font.
+     */
+    @NonNull
+    public Typeface getTypeface() {
+        return mTypeface;
+    }
+
+    /**
+     * Sets the font of the text.
+     *
+     * @param typeface The font to set.
+     */
+    public void setTypeface(@NonNull Typeface typeface) {
+        this.mTypeface = typeface;
+    }
+
+    /**
+     * Returns the fill color of the object.
+     *
+     * @return The fill color of the object.
+     */
+    @Nullable
+    public Color getFillColor() {
+        return mFillColor;
+    }
+
+    /**
+     * Sets the fill color of the object.
+     *
+     * @param fillColor The fill color of the object.
+     */
+    public void setFillColor(@Nullable Color fillColor) {
+        this.mFillColor = fillColor;
+    }
+}
diff --git a/pdf/framework/java/android/graphics/pdf/component/StampAnnotation.java b/pdf/framework/java/android/graphics/pdf/component/StampAnnotation.java
new file mode 100644
index 000000000..70dfbd4a6
--- /dev/null
+++ b/pdf/framework/java/android/graphics/pdf/component/StampAnnotation.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.graphics.pdf.component;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.graphics.RectF;
+import android.graphics.pdf.flags.Flags;
+import android.graphics.pdf.utils.Preconditions;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Represents a stamp annotation in a PDF document.
+ * <p>
+ * Only path, image, or text objects created using the {@link PdfPagePathObject},
+ * {@link PdfPageImageObject}, or {@link PdfPageTextObject} constructors respectively
+ * can be added to a stamp annotation.
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_EDIT_PDF_STAMP_ANNOTATIONS)
+public final class StampAnnotation extends PdfAnnotation {
+    @NonNull private List<PdfPageObject> mObjects;
+
+    /**
+     * Creates a new stamp annotation with the specified bounds
+     *
+     * @param bounds The bounding rectangle of the annotation.
+     */
+    public StampAnnotation(@NonNull RectF bounds) {
+        super(PdfAnnotationType.STAMP, bounds);
+        mObjects = new ArrayList<>();
+    }
+
+    /**
+     * Adds a PDF page object to the stamp annotation.
+     * <p>
+     * The page object should be a path, text or an image. The page object which has been
+     * already added to a page can't be added to the annotation and one page object can be added
+     * to one annotation only.
+     * When the annotation will be added to the page using
+     * @link android.graphics.pdf.PdfRenderer.Page#addPageAnnotation(PdfAnnotation)} or
+     * {@link android.graphics.pdf.PdfRendererPreV.Page#addPageAnnotation(PdfAnnotation)}, the
+     * page object will get assigned a unique id.
+     *
+     * @param pageObject The PDF page object to add.
+     * @throws IllegalArgumentException if the page object is already added to a page or an
+     *         annotation.
+     */
+    public void addObject(@NonNull PdfPageObject pageObject) {
+        Preconditions.checkArgument(pageObject.getObjectId() == -1,
+                "This page object is already added to the page");
+        Preconditions.checkArgument(pageObject.isAddedInAnnotation(),
+                "This page object is already added to an annotation");
+        mObjects.add(pageObject);
+        pageObject.setAddedInAnnotation();
+    }
+
+
+    /**
+     * Returns all the known PDF page objects in the stamp annotation.
+     *
+     * @return The list of page objects in the annotation.
+     */
+    @NonNull
+    public List<PdfPageObject> getObjects() {
+        return mObjects;
+    }
+
+    /**
+     * Remove the page object from the stamp annotation.
+     *
+     * @param id - id of the object to be removed
+     * @throws IllegalArgumentException if there is no object in the annotation with the given
+     *         id
+     */
+    public void removeObject(int id) {
+        throwIfIdNotPresentInAnnotation(id);
+        mObjects.remove(id);
+    }
+
+    private boolean throwIfIdNotPresentInAnnotation(int id) {
+        for (PdfPageObject pageObject : mObjects) {
+            if (pageObject.getObjectId() == id) {
+                return true;
+            }
+        }
+        return false;
+    }
+}
diff --git a/pdf/framework/libs/pdfClient/page.cc b/pdf/framework/libs/pdfClient/page.cc
index cd9b7ef03..b7db016e1 100644
--- a/pdf/framework/libs/pdfClient/page.cc
+++ b/pdf/framework/libs/pdfClient/page.cc
@@ -59,7 +59,8 @@ Page::Page(FPDF_DOCUMENT doc, int page_num, FormFiller* form_filler)
     : document_(doc),
       page_(FPDF_LoadPage(doc, page_num)),
       form_filler_(form_filler),
-      invalid_rect_(kEmptyIntRectangle) {}
+      invalid_rect_(kEmptyIntRectangle),
+      page_num_(page_num) {}
 
 Page::Page(Page&& p) = default;
 
@@ -287,7 +288,12 @@ vector<GotoLink> Page::GetGotoLinks() const {
 
         // Get and parse the destination
         FPDF_DEST fpdf_dest = FPDFLink_GetDest(document_, link);
-        goto_link_dest->set_page_number(FPDFDest_GetDestPageIndex(document_, fpdf_dest));
+        int dest_page_index = FPDFDest_GetDestPageIndex(document_, fpdf_dest);
+        if (dest_page_index < 0) {
+            LOGE("Goto Link has invalid destination page index");
+            continue;
+        }
+        goto_link_dest->set_page_number(dest_page_index);
 
         FPDF_BOOL has_x_coord;
         FPDF_BOOL has_y_coord;
@@ -445,7 +451,19 @@ void Page::EnsureTextPageInitialized() {
     if (text_page_) {
         return;
     }
+    if (!page_.get()) {
+        // Page should never be null but a partner has an unexplained bug b/376796346
+        LOGE("Null page (err=%lu). for (page_num=%d)", FPDF_GetLastError(), page_num_);
+        // since the text_page_ would not have a page to load from
+        return;
+    }
+
     text_page_.reset(FPDFText_LoadPage(page_.get()));
+    if (!text_page_) {
+        // This will get into infinite recursion if not returned - b/376796346
+        LOGE("Failed to load text (err=%lu). for (page_num=%d)", FPDF_GetLastError(), page_num_);
+        return;
+    }
 
     int num_chars = NumChars();
 
diff --git a/pdf/framework/libs/pdfClient/page.h b/pdf/framework/libs/pdfClient/page.h
index b5ccc1046..02de344c2 100644
--- a/pdf/framework/libs/pdfClient/page.h
+++ b/pdf/framework/libs/pdfClient/page.h
@@ -323,6 +323,9 @@ class Page {
     // Rectangles are invalidated due to form filling operations.
     // Rectangle is in Device Coordinates.
     Rectangle_i invalid_rect_;
+
+    // Page number that is opened.
+    int page_num_;
 };
 
 }  // namespace pdfClient
diff --git a/pdf/framework/libs/pdfClient/page_test.cc b/pdf/framework/libs/pdfClient/page_test.cc
index 4035fcd5e..2d1d4ffcb 100644
--- a/pdf/framework/libs/pdfClient/page_test.cc
+++ b/pdf/framework/libs/pdfClient/page_test.cc
@@ -17,6 +17,7 @@
 #include "page.h"
 
 #include <android-base/file.h>
+#include <android/api-level.h>
 #include <gtest/gtest.h>
 
 #include <memory>
@@ -165,4 +166,37 @@ TEST(Test, ConsumeInvalidRectResetsRectTest) {
     ASSERT_EQ(expected, page->ConsumeInvalidRect());
 }
 
+TEST(Test, InvalidPageNumberTest) {
+    if (android_get_device_api_level() < __ANDROID_API_S__) {
+        // Pdf client is not exposed on R and for some unknown reason this test fails
+        // on non-64 architectures. See - b/381994039
+        // We could disable all the tests here for R.
+        GTEST_SKIP();
+    }
+    Document doc(LoadTestDocument(kSekretNoPassword), false);
+    // The document has only one page but we fetch the second one.
+    std::shared_ptr<Page> page = doc.GetPage(1);
+
+    // The above call succeeds and returns a non-null ptr.
+    ASSERT_NE(nullptr, page);
+    // Even though the underlying pointer is null.
+    ASSERT_EQ(nullptr, page->page());
+
+    // Rest of the calls should give some default values.
+    EXPECT_EQ(-1, page->NumChars());
+    std::string str_with_null = "\0";
+    EXPECT_EQ(1, page->GetTextUtf8().size());  // Returns "\0"
+    EXPECT_EQ('\0', page->GetUnicode(0));
+    EXPECT_EQ(0, page->Width());
+    EXPECT_EQ(0, page->Height());
+
+    Rectangle_i expected = Rectangle_i{0, 0, 0, 0};
+    EXPECT_EQ(expected, page->Dimensions());
+    EXPECT_EQ(false, page->HasInvalidRect());
+    EXPECT_EQ(0, page->GetGotoLinks().size());
+    // The following should not crash, we do not expect anything in return.
+    page->InitializeFormFilling();
+    page->TerminateFormFilling();
+}
+
 }  // namespace
\ No newline at end of file
diff --git a/pdf/framework/pdf_viewer_flags.aconfig b/pdf/framework/pdf_viewer_flags.aconfig
index deb5ea771..0759473be 100644
--- a/pdf/framework/pdf_viewer_flags.aconfig
+++ b/pdf/framework/pdf_viewer_flags.aconfig
@@ -19,4 +19,50 @@ flag {
     description: "This flag controls whether to enable pdf viewer form filling APIs."
     bug: "319561098"
     is_fixed_read_only: true
-}
\ No newline at end of file
+}
+
+flag {
+    name: "enable_edit_pdf_annotations"
+    is_exported: true
+    namespace: "pdf_viewer"
+    description: "This flag controls whether to enable highlight and stamp annotations editing support."
+    bug: "379008090"
+    is_fixed_read_only: true
+}
+
+flag {
+    name: "enable_edit_pdf_page_objects"
+    is_exported: true
+    namespace: "pdf_viewer"
+    description: "This flag controls whether to enable path and image page object editing support."
+    bug: "379008090"
+    is_fixed_read_only: true
+}
+
+flag {
+    name: "enable_edit_pdf_text_objects"
+    is_exported: true
+    namespace: "pdf_viewer"
+    description: "This flag controls whether to enable page text object editing support."
+    bug: "379008090"
+    is_fixed_read_only: true
+}
+
+flag {
+    name: "enable_edit_pdf_text_annotations"
+    is_exported: true
+    namespace: "pdf_viewer"
+    description: "This flag controls whether to enable text annotations editing support."
+    bug: "379008090"
+    is_fixed_read_only: true
+}
+
+
+flag {
+    name: "enable_edit_pdf_stamp_annotations"
+    is_exported: true
+    namespace: "pdf_viewer"
+    description: "This flag controls whether to enable stamp annotations editing support."
+    bug: "379008090"
+    is_fixed_read_only: true
+}
diff --git a/photopicker/Android.bp b/photopicker/Android.bp
index 219fbdab2..a3d85d5c9 100644
--- a/photopicker/Android.bp
+++ b/photopicker/Android.bp
@@ -16,6 +16,7 @@ android_library {
     libs: [
         "framework-configinfrastructure.stubs.module_lib",
         "framework-connectivity.stubs.module_lib",
+        "framework-media.stubs.module_lib",
         "framework-mediaprovider.impl",
         "framework-photopicker.impl",
         "framework-statsd.stubs.module_lib",
@@ -65,6 +66,8 @@ android_library {
         "kotlinx_coroutines",
         "mediaprovider_flags_java_lib",
         "modules-utils-build",
+        "androidx.media3.media3-common",
+        "androidx.media3.media3-exoplayer",
     ],
     apex_available: [
         "//apex_available:platform",
@@ -102,5 +105,6 @@ android_app {
         "//apex_available:platform",
         "com.android.mediaprovider",
     ],
+    updatable: true,
 
 }
diff --git a/photopicker/AndroidManifest.xml b/photopicker/AndroidManifest.xml
index 602b14c41..ff0e86a3d 100644
--- a/photopicker/AndroidManifest.xml
+++ b/photopicker/AndroidManifest.xml
@@ -36,10 +36,17 @@
    <!-- Permissions required for fetching User profiles -->
   <uses-permission android:name="android.permission.INTERACT_ACROSS_USERS"/>
 
+  <!--
+    Required for resolving packages based on their UID for privacy banner
+    Also required for resolving DocumentsUI and CloudMediaProviders.
+  -->
+  <uses-permission android:name="android.permission.QUERY_ALL_PACKAGES"/>
+
   <application
           android:name="com.android.photopicker.PhotopickerApplication"
           android:icon="@mipmap/photopicker_app_icon"
           android:label="@string/photopicker_application_label"
+          android:crossProfile="true"
           android:allowBackup="false"
           android:supportsRtl="true">
 
@@ -111,6 +118,7 @@
     -->
     <receiver android:name="com.android.photopicker.PhotopickerDeviceConfigReceiver"
               android:exported="true"
+              android:enabled="@bool/config_enablePhotopickerDeviceConfigReceiver"
               android:permission="com.android.providers.media.permission.MANAGE_CLOUD_MEDIA_PROVIDERS">
       <intent-filter>
         <action android:name="android.intent.action.MAIN" />
@@ -132,28 +140,4 @@
 
   </application>
 
-
-  <queries>
-    <!--
-      Ensure that all CLOUD_MEDIA_PROVIDER packages are visible to this app.
-      Since Photopicker does not hold QUERY_ALL_PACKAGES, but it queries the
-      CloudMediaProviders directly when loading media, declare the intent
-      action that all CloudMediaProviders use to identify themselves so their
-      packages are visible to Photopicker.
-    -->
-    <intent>
-      <action android:name="android.content.action.CLOUD_MEDIA_PROVIDER" />
-    </intent>
-
-    <!--
-      Ensure that Photopicker can resolve DocumentsUI which is the
-      default handler of [OPEN_DOCUMENT]. Photopicker uses this to redirect
-      the user to DocumentsUI in some ACTION_GET_CONTENT cases.
-    -->
-    <intent>
-      <action android:name="android.intent.action.OPEN_DOCUMENT" />
-      <data android:mimeType="*/*" />
-    </intent>
-  </queries>
-
 </manifest>
diff --git a/photopicker/framework/java/android/widget/photopicker/EmbeddedPhotoPickerSessionWrapper.java b/photopicker/framework/java/android/widget/photopicker/EmbeddedPhotoPickerSessionWrapper.java
index 20172dd8c..9a2f3370c 100644
--- a/photopicker/framework/java/android/widget/photopicker/EmbeddedPhotoPickerSessionWrapper.java
+++ b/photopicker/framework/java/android/widget/photopicker/EmbeddedPhotoPickerSessionWrapper.java
@@ -65,7 +65,7 @@ class EmbeddedPhotoPickerSessionWrapper implements EmbeddedPhotoPickerSession,
         try {
             mSession.asBinder().linkToDeath(this, 0 /* flags*/);
         } catch (RemoteException e) {
-            this.binderDied(mSession.asBinder());
+            this.binderDied();
         }
     }
 
@@ -130,16 +130,10 @@ class EmbeddedPhotoPickerSessionWrapper implements EmbeddedPhotoPickerSession,
 
     @Override
     public void binderDied() {
-        // Overridden by binderDied(IBinder who)
+        mClientWrapper.onSessionError(new ParcelableException(
+                new RuntimeException("Binder object hosting this session has died. "
+                        + "Clean up resources.")));
     }
 
-    @Override
-    public void binderDied(@NonNull IBinder who) {
-        if (mSession.asBinder().equals(who)) {
-            mClientWrapper.onSessionError(new ParcelableException(
-                    new RuntimeException("Binder object hosting this session has died. "
-                            + "Clean up resources.")));
-        }
-    }
 }
 
diff --git a/photopicker/res/values-af/core_strings.xml b/photopicker/res/values-af/core_strings.xml
index de2fdc7fd..2aef9aa04 100644
--- a/photopicker/res/values-af/core_strings.xml
+++ b/photopicker/res/values-af/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Fotos en videos"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Media"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> is op <xliff:g id="TIME">%2$s</xliff:g> geneem"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Video geneem op <xliff:g id="TIME">%1$s</xliff:g> se tydsduur is <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Foto"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Bewegingfoto"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Gekies"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Nie gekies nie"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Kies"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Ontkies"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Klaar"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Ontkies almal"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> fotos of videos is gekies"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Kies tot <xliff:g id="COUNT">%1$s</xliff:g> items"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Fotos"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albums"</string>
diff --git a/photopicker/res/values-af/feature_preview_strings.xml b/photopicker/res/values-af/feature_preview_strings.xml
index 8cafd4349..037231690 100644
--- a/photopicker/res/values-af/feature_preview_strings.xml
+++ b/photopicker/res/values-af/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Kies alles <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Kies alles (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Kies"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Ontkies alles <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Ontkies alles (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Voorbeskou"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Sukkel om video te speel"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Gaan jou internetverbinding na en probeer weer"</string>
diff --git a/photopicker/res/values-af/feature_profiles_strings.xml b/photopicker/res/values-af/feature_profiles_strings.xml
index 27f3dfc22..6c1c2ca4e 100644
--- a/photopicker/res/values-af/feature_profiles_strings.xml
+++ b/photopicker/res/values-af/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Werk"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Ander"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Wissel gebruikerprofiel"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Het <xliff:g id="PROFILE_NAME">%1$s</xliff:g> gekies"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>-apps is onderbreek"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Deur jou admin geblokkeer"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Skakel jou <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>-apps aan en probeer dan weer om jou <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>-fotos oop te maak"</string>
diff --git a/photopicker/res/values-af/feature_search_strings.xml b/photopicker/res/values-af/feature_search_strings.xml
index 07a1e7832..0a008ed65 100644
--- a/photopicker/res/values-af/feature_search_strings.xml
+++ b/photopicker/res/values-af/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Soek"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Deursoek jou fotos"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Deursoek jou fotos"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Deursoek jou video\'s"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Geen resultate gekry nie"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Probeer om vir soortgelyke woorde te soek"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Voorstelle"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Soektog gedeaktiveer."</string>
 </resources>
diff --git a/photopicker/res/values-am/core_strings.xml b/photopicker/res/values-am/core_strings.xml
index 22b1bd224..bffdfc41e 100644
--- a/photopicker/res/values-am/core_strings.xml
+++ b/photopicker/res/values-am/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> <xliff:g id="TIME">%2$s</xliff:g>  "</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"<xliff:g id="TIME">%1$s</xliff:g>  <xliff:g id="DURATION">%2$s</xliff:g>    "</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">""</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">""</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">" "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g>    "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">" <xliff:g id="COUNT">%1$s</xliff:g>   "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-am/feature_preview_strings.xml b/photopicker/res/values-am/feature_preview_strings.xml
index eeac575de..5134f4234 100644
--- a/photopicker/res/values-am/feature_preview_strings.xml
+++ b/photopicker/res/values-am/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">" <xliff:g id="COUNT">(%1$s)</xliff:g> "</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">" <xliff:g id="COUNT">(%1$s)</xliff:g> "</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"-"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"   "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"     "</string>
diff --git a/photopicker/res/values-am/feature_profiles_strings.xml b/photopicker/res/values-am/feature_profiles_strings.xml
index 3a1d71bf4..9362d8ad1 100644
--- a/photopicker/res/values-am/feature_profiles_strings.xml
+++ b/photopicker/res/values-am/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"  "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> "</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>   "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">" "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>    <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>     "</string>
diff --git a/photopicker/res/values-am/feature_search_strings.xml b/photopicker/res/values-am/feature_search_strings.xml
index 0cc7617c1..5638946f3 100644
--- a/photopicker/res/values-am/feature_search_strings.xml
+++ b/photopicker/res/values-am/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">" "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">" "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">" "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"   "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">" "</string>
 </resources>
diff --git a/photopicker/res/values-ar/core_strings.xml b/photopicker/res/values-ar/core_strings.xml
index 6cd0d3812..702f38e9f 100644
--- a/photopicker/res/values-ar/core_strings.xml
+++ b/photopicker/res/values-ar/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">" "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"  <xliff:g id="ITEM_NAME">%1$s</xliff:g>  <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"    <xliff:g id="TIME">%1$s</xliff:g>  <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">" GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"  "</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"  "</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">" "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"  "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"  <xliff:g id="COUNT">%1$s</xliff:g>    "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"  <xliff:g id="COUNT">%1$s</xliff:g>    "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-ar/feature_preview_strings.xml b/photopicker/res/values-ar/feature_preview_strings.xml
index b90736aef..9efc9a022 100644
--- a/photopicker/res/values-ar/feature_preview_strings.xml
+++ b/photopicker/res/values-ar/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"  <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"   <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"   (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">""</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"   "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"       "</string>
diff --git a/photopicker/res/values-ar/feature_profiles_strings.xml b/photopicker/res/values-ar/feature_profiles_strings.xml
index ac5ecdc8f..5d583266d 100644
--- a/photopicker/res/values-ar/feature_profiles_strings.xml
+++ b/photopicker/res/values-ar/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">" "</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">" "</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"    "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"  <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">" \"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>\"  "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"   "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"  \"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>\"    \"<xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>\"  "</string>
diff --git a/photopicker/res/values-ar/feature_search_strings.xml b/photopicker/res/values-ar/feature_search_strings.xml
index 5d45a36e6..b2ac5ad30 100644
--- a/photopicker/res/values-ar/feature_search_strings.xml
+++ b/photopicker/res/values-ar/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"  "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"    "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"    "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  ."</string>
 </resources>
diff --git a/photopicker/res/values-as/core_strings.xml b/photopicker/res/values-as/core_strings.xml
index 5519732b0..ffa78e65e 100644
--- a/photopicker/res/values-as/core_strings.xml
+++ b/photopicker/res/values-as/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>  <xliff:g id="TIME">%2$s</xliff:g>  "</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"<xliff:g id="TIME">%1$s</xliff:g> <xliff:g id="DURATION">%2$s</xliff:g>    "</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"  "</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"   "</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">" "</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"  "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"   "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g>       "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"<xliff:g id="COUNT">%1$s</xliff:g>     "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-as/feature_preview_strings.xml b/photopicker/res/values-as/feature_preview_strings.xml
index 356f681ed..d0b765a87 100644
--- a/photopicker/res/values-as/feature_preview_strings.xml
+++ b/photopicker/res/values-as/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"<xliff:g id="COUNT">(%1$s)</xliff:g>    "</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">" (<xliff:g id="COUNT">%1$s</xliff:g> )  "</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">" "</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"<xliff:g id="COUNT">(%1$s)</xliff:g>     "</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">" (<xliff:g id="COUNT">%1$s</xliff:g> )   "</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">" "</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"    "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"        "</string>
diff --git a/photopicker/res/values-as/feature_profiles_strings.xml b/photopicker/res/values-as/feature_profiles_strings.xml
index 76305d80c..82c15c9af 100644
--- a/photopicker/res/values-as/feature_profiles_strings.xml
+++ b/photopicker/res/values-as/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"   "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>   "</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>    "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"   "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>  ,  <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>       "</string>
diff --git a/photopicker/res/values-as/feature_search_strings.xml b/photopicker/res/values-as/feature_search_strings.xml
index be00db5a3..63ce1d998 100644
--- a/photopicker/res/values-as/feature_search_strings.xml
+++ b/photopicker/res/values-as/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">" "</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"   "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"   "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"   "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"   "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"    "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"    "</string>
 </resources>
diff --git a/photopicker/res/values-az/core_strings.xml b/photopicker/res/values-az/core_strings.xml
index b5f15ef55..07fb85de4 100644
--- a/photopicker/res/values-az/core_strings.xml
+++ b/photopicker/res/values-az/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Foto v videolar"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Media"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> <xliff:g id="TIME">%2$s</xliff:g> tarixind kilib"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Video <xliff:g id="DURATION">%2$s</xliff:g> mddtind bu vaxt kilib: <xliff:g id="TIME">%1$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Foto"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Hrktli Foto"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Seilib"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Seilmyib"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Sein"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Seimi silin"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Hazrdr"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Btn seimlri silin"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> foto v ya video seilib"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Maksimum <xliff:g id="COUNT">%1$s</xliff:g> element sein"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Foto"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albomlar"</string>
diff --git a/photopicker/res/values-az/feature_preview_strings.xml b/photopicker/res/values-az/feature_preview_strings.xml
index e5fb2c4c6..768436689 100644
--- a/photopicker/res/values-az/feature_preview_strings.xml
+++ b/photopicker/res/values-az/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Hamsn sein <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Hamsn sein (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Sein"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Hamsnn seimini silin <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Hamsnn seimini silin (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"nizlm"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Videonu i salarkn xta oldu"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"nternet balantsn yoxlayn v yenidn chd edin"</string>
diff --git a/photopicker/res/values-az/feature_profiles_strings.xml b/photopicker/res/values-az/feature_profiles_strings.xml
index 35da25226..da286a544 100644
--- a/photopicker/res/values-az/feature_profiles_strings.xml
+++ b/photopicker/res/values-az/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Digr"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"stifadi Profilini dyidirin"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> seildi"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> ttbiqlri durdurulub"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Admin trfindn bloklanb"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g> fotolarn amaq n <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> ttbiqlrini aktiv edib, yenidn chd edin"</string>
diff --git a/photopicker/res/values-az/feature_search_strings.xml b/photopicker/res/values-az/feature_search_strings.xml
index 7e713a766..94f0f0e2f 100644
--- a/photopicker/res/values-az/feature_search_strings.xml
+++ b/photopicker/res/values-az/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Axtar"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Fotolar axtarn"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Fotolar axtarn"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Videolar axtarn"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Ntic taplmad"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Bnzr szlri axtarmaa aln"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Tkliflr"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Axtar deaktiv edildi."</string>
 </resources>
diff --git a/photopicker/res/values-b+sr+Latn/core_strings.xml b/photopicker/res/values-b+sr+Latn/core_strings.xml
index 7d98fc853..6cc97babe 100644
--- a/photopicker/res/values-b+sr+Latn/core_strings.xml
+++ b/photopicker/res/values-b+sr+Latn/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Slike i videi"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Mediji"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>: snimljeno <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Video je snimljen <xliff:g id="TIME">%1$s</xliff:g> i traje <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Slika"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Slika u pokretu"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Izabrano"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Nije izabrano"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Izaberi"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Poniti izbor"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Gotovo"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Ponitite sve"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"Izabrano slika i videa: <xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Najvei broj stavki koje moete da izaberete je <xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Slike"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albumi"</string>
diff --git a/photopicker/res/values-b+sr+Latn/feature_preview_strings.xml b/photopicker/res/values-b+sr+Latn/feature_preview_strings.xml
index 811759c0a..367fa2630 100644
--- a/photopicker/res/values-b+sr+Latn/feature_preview_strings.xml
+++ b/photopicker/res/values-b+sr+Latn/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Izaberi sve <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Izaberi sve (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Izaberi"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Poniti izbor <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Poniti izbor svih stavki (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Pregled"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Dolo je do greke pri putanju videa"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Proverite internet vezu i probajte ponovo"</string>
diff --git a/photopicker/res/values-b+sr+Latn/feature_profiles_strings.xml b/photopicker/res/values-b+sr+Latn/feature_profiles_strings.xml
index 004e0bf63..1e3c6df29 100644
--- a/photopicker/res/values-b+sr+Latn/feature_profiles_strings.xml
+++ b/photopicker/res/values-b+sr+Latn/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Poslovni profil"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Drugo"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Promenite korisniki profil"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Izabrano: <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Aplikacije profila <xliff:g id="PROFILE_NAME">%1$s</xliff:g> su pauzirane"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Blokira administrator"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Da biste otvorili slike profila <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>, ukljuite aplikacije profila <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> i probajte ponovo"</string>
diff --git a/photopicker/res/values-b+sr+Latn/feature_search_strings.xml b/photopicker/res/values-b+sr+Latn/feature_search_strings.xml
index 6ff175c0d..9bdc6550d 100644
--- a/photopicker/res/values-b+sr+Latn/feature_search_strings.xml
+++ b/photopicker/res/values-b+sr+Latn/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Pretraite"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Pretraite slike"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Pretraite slike"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Pretraite video snimke"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Nije pronaen nijedan rezultat"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Potraite sline rei"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Predlozi"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Pretraga je onemoguena."</string>
 </resources>
diff --git a/photopicker/res/values-be/core_strings.xml b/photopicker/res/values-be/core_strings.xml
index fa6ceba08..1ec0b517c 100644
--- a/photopicker/res/values-be/core_strings.xml
+++ b/photopicker/res/values-be/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>  <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"  <xliff:g id="TIME">%1$s</xliff:g>    <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">" GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"  "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">" "</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">" "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">" "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"    : <xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"  (   <xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-be/feature_preview_strings.xml b/photopicker/res/values-be/feature_preview_strings.xml
index 958efdd93..b513b353a 100644
--- a/photopicker/res/values-be/feature_preview_strings.xml
+++ b/photopicker/res/values-be/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"  <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"    <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"    (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">""</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"   "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"      "</string>
diff --git a/photopicker/res/values-be/feature_profiles_strings.xml b/photopicker/res/values-be/feature_profiles_strings.xml
index 4324bf89d..6831f0351 100644
--- a/photopicker/res/values-be/feature_profiles_strings.xml
+++ b/photopicker/res/values-be/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"  "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">": <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"   \"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>\" "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"  "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"     \"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>\",     \"<xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>\"   "</string>
diff --git a/photopicker/res/values-be/feature_search_strings.xml b/photopicker/res/values-be/feature_search_strings.xml
index 6c329d7c2..c90fc7b44 100644
--- a/photopicker/res/values-be/feature_search_strings.xml
+++ b/photopicker/res/values-be/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"  "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"   "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">" ."</string>
 </resources>
diff --git a/photopicker/res/values-bg/core_strings.xml b/photopicker/res/values-bg/core_strings.xml
index a40955167..c7984b152 100644
--- a/photopicker/res/values-bg/core_strings.xml
+++ b/photopicker/res/values-bg/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>  <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">",   <xliff:g id="TIME">%1$s</xliff:g>,    <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF "</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"  "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"  "</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"  "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"    "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"  <xliff:g id="COUNT">%1$s</xliff:g>   "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">" - <xliff:g id="COUNT">%1$s</xliff:g> "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-bg/feature_preview_strings.xml b/photopicker/res/values-bg/feature_preview_strings.xml
index 174e992d7..d436dcb51 100644
--- a/photopicker/res/values-bg/feature_preview_strings.xml
+++ b/photopicker/res/values-bg/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"   <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"   (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"     <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"     (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">""</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"    "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"       "</string>
diff --git a/photopicker/res/values-bg/feature_profiles_strings.xml b/photopicker/res/values-bg/feature_profiles_strings.xml
index a01d84a44..84be5b308 100644
--- a/photopicker/res/values-bg/feature_profiles_strings.xml
+++ b/photopicker/res/values-bg/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"   "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">" <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"  <xliff:g id="PROFILE_NAME">%1$s</xliff:g>    "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"   "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"       <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>,    <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>     "</string>
diff --git a/photopicker/res/values-bg/feature_search_strings.xml b/photopicker/res/values-bg/feature_search_strings.xml
index 377207fb2..988ab4f53 100644
--- a/photopicker/res/values-bg/feature_search_strings.xml
+++ b/photopicker/res/values-bg/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"   "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"   "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"   "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"    "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  ."</string>
 </resources>
diff --git a/photopicker/res/values-bn/core_strings.xml b/photopicker/res/values-bn/core_strings.xml
index 7cc81956e..b43df6578 100644
--- a/photopicker/res/values-bn/core_strings.xml
+++ b/photopicker/res/values-bn/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">" &amp; "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>, <xliff:g id="TIME">%2$s</xliff:g>-  "</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"<xliff:g id="TIME">%1$s</xliff:g>-       <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"  "</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"  "</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">" "</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">" "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">" "</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"  "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g>      "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">" <xliff:g id="COUNT">%1$s</xliff:g>   "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-bn/feature_preview_strings.xml b/photopicker/res/values-bn/feature_preview_strings.xml
index a79708466..0d3f1e018 100644
--- a/photopicker/res/values-bn/feature_preview_strings.xml
+++ b/photopicker/res/values-bn/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"<xliff:g id="COUNT">(%1$s)</xliff:g>   "</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">" (<xliff:g id="COUNT">%1$s</xliff:g>)  "</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">" "</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"<xliff:g id="COUNT">(%1$s)</xliff:g>   "</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">" (<xliff:g id="COUNT">%1$s</xliff:g>)  "</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">" "</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"   "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"          "</string>
diff --git a/photopicker/res/values-bn/feature_profiles_strings.xml b/photopicker/res/values-bn/feature_profiles_strings.xml
index 692013520..d154f366d 100644
--- a/photopicker/res/values-bn/feature_profiles_strings.xml
+++ b/photopicker/res/values-bn/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"   "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>   "</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>    "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"   "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>    <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>      "</string>
diff --git a/photopicker/res/values-bn/feature_search_strings.xml b/photopicker/res/values-bn/feature_search_strings.xml
index e2629a409..155d50f33 100644
--- a/photopicker/res/values-bn/feature_search_strings.xml
+++ b/photopicker/res/values-bn/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">" "</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"   "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"   "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"   "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"      "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"   "</string>
 </resources>
diff --git a/photopicker/res/values-bs/core_strings.xml b/photopicker/res/values-bs/core_strings.xml
index 8b04c879b..8c9eaac2b 100644
--- a/photopicker/res/values-bs/core_strings.xml
+++ b/photopicker/res/values-bs/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Fotografije i videozapisi"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Mediji"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> je snimljena <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Videozapis je snimljen <xliff:g id="TIME">%1$s</xliff:g> i traje <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Fotografija"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Fotografija s videom"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Odabrano"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Nije odabrano"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Odabir"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Ponitavanje odabira"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Gotovo"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Ponitavanje svih odabira"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"Odabrano je vie fotografija ili videozapisa (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"<xliff:g id="COUNT">%1$s</xliff:g> je maksimalni broj stavki koje moete odabrati"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Fotografije"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albumi"</string>
diff --git a/photopicker/res/values-bs/feature_preview_strings.xml b/photopicker/res/values-bs/feature_preview_strings.xml
index 2a97156f4..2eefc8405 100644
--- a/photopicker/res/values-bs/feature_preview_strings.xml
+++ b/photopicker/res/values-bs/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Odaberi sve (<xliff:g id="COUNT">(%1$s)</xliff:g>)"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Odaberi sve (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Odaberi"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Poniti odabir svega (<xliff:g id="COUNT">(%1$s)</xliff:g>)"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Poniti odabir svega (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Pregled"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Potekoe prilikom reprodukcije videozapisa"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Provjerite internetsku vezu i pokuajte ponovo"</string>
diff --git a/photopicker/res/values-bs/feature_profiles_strings.xml b/photopicker/res/values-bs/feature_profiles_strings.xml
index d504b65e6..5def727fc 100644
--- a/photopicker/res/values-bs/feature_profiles_strings.xml
+++ b/photopicker/res/values-bs/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Poslovno"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Drugo"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Promjena korisnikog profila"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Odabrano: <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Aplikacije profila <xliff:g id="PROFILE_NAME">%1$s</xliff:g> su pauzirane"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Blokirao je administrator"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Da otvorite fotografije s profila <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>, ukljuite aplikacije profila <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>, a zatim pokuajte ponovo"</string>
diff --git a/photopicker/res/values-bs/feature_search_strings.xml b/photopicker/res/values-bs/feature_search_strings.xml
index 5dd1cb4cf..e10cb46e3 100644
--- a/photopicker/res/values-bs/feature_search_strings.xml
+++ b/photopicker/res/values-bs/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Pretraite"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Pretraite fotografije"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Pretraite fotografije"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Pretraite videozapise"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Nije pronaen nijedan rezultat"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Pokuajte pretraiti sline rijei"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Prijedlozi"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Pretraivanje je onemogueno."</string>
 </resources>
diff --git a/photopicker/res/values-ca/core_strings.xml b/photopicker/res/values-ca/core_strings.xml
index b5b35dc24..6fdbed8af 100644
--- a/photopicker/res/values-ca/core_strings.xml
+++ b/photopicker/res/values-ca/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Fotos i vdeos"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Contingut multimdia"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>, data de creaci: <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Vdeo gravat el dia <xliff:g id="TIME">%1$s</xliff:g> que dura <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Foto"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Foto amb moviment"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Seleccionat"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"No seleccionat"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Selecciona"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Desselecciona"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Fet"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Desselecciona-ho tot"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"S\'han seleccionat <xliff:g id="COUNT">%1$s</xliff:g> fotos o vdeos"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Selecciona fins a <xliff:g id="COUNT">%1$s</xliff:g> elements"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Fotos"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"lbums"</string>
diff --git a/photopicker/res/values-ca/feature_preview_strings.xml b/photopicker/res/values-ca/feature_preview_strings.xml
index 70be904c5..2139d93e1 100644
--- a/photopicker/res/values-ca/feature_preview_strings.xml
+++ b/photopicker/res/values-ca/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Selecciona-ho tot (<xliff:g id="COUNT">(%1$s)</xliff:g>)"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Selecciona-ho tot (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Selecciona"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Desselecciona-ho tot <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Desselecciona-ho tot (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Previsualitza"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Hi ha hagut un problema en reproduir el vdeo"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Comprova la connexi a Internet i torna-ho a provar"</string>
diff --git a/photopicker/res/values-ca/feature_profiles_strings.xml b/photopicker/res/values-ca/feature_profiles_strings.xml
index 276dc53b9..e282dd710 100644
--- a/photopicker/res/values-ca/feature_profiles_strings.xml
+++ b/photopicker/res/values-ca/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Feina"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Altres"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Canvia el perfil d\'usuari"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"S\'ha seleccionat <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Les aplicacions de <xliff:g id="PROFILE_NAME">%1$s</xliff:g> s\'han posat en pausa"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Bloquejat per l\'administrador"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Per obrir les fotos de <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>, activa les aplicacions de <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> i torna-ho a provar"</string>
diff --git a/photopicker/res/values-ca/feature_search_strings.xml b/photopicker/res/values-ca/feature_search_strings.xml
index 2c1bbdd90..e10120469 100644
--- a/photopicker/res/values-ca/feature_search_strings.xml
+++ b/photopicker/res/values-ca/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Cerca"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Cerca a les teves fotos"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Cerca a les teves fotos"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Cerca als teus vdeos"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"No s\'ha trobat cap resultat"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Prova de cercar paraules similars"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Suggeriments"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Cerca desactivada."</string>
 </resources>
diff --git a/photopicker/res/values-cs/core_strings.xml b/photopicker/res/values-cs/core_strings.xml
index 5dff1a9c0..1aefb9e89 100644
--- a/photopicker/res/values-cs/core_strings.xml
+++ b/photopicker/res/values-cs/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Fotky avidea"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Mdia"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> pozeno <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Video pozen <xliff:g id="TIME">%1$s</xliff:g> odlce <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Fotka"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Pohybliv fotka"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Vybrno"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Nevybrno"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Vybrat"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Zruit vbr"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Hotovo"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Zruit vbr vech"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"Vybran fotky nebo videa: <xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Vyberte maximln <xliff:g id="COUNT">%1$s</xliff:g>poloky"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Fotky"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Alba"</string>
diff --git a/photopicker/res/values-cs/feature_preview_strings.xml b/photopicker/res/values-cs/feature_preview_strings.xml
index 410ed1fa9..16a9d3b96 100644
--- a/photopicker/res/values-cs/feature_preview_strings.xml
+++ b/photopicker/res/values-cs/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Vybrat ve (<xliff:g id="COUNT">(%1$s)</xliff:g>)"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Vybrat ve (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Vybrat"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Zruit vbr vech <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Zruit vbr vech (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Zobrazit nhled"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Pi pehrvn videa dolo kpotm"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Zkontrolujte pipojen kinternetu azkuste to znovu"</string>
diff --git a/photopicker/res/values-cs/feature_profiles_strings.xml b/photopicker/res/values-cs/feature_profiles_strings.xml
index 288bdc13f..a4521c2c2 100644
--- a/photopicker/res/values-cs/feature_profiles_strings.xml
+++ b/photopicker/res/values-cs/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Pracovn"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Jin"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Pepnout uivatelsk profil"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Vybrno: <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> aplikace jsou pozastaveny"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Blokovno administrtorem"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Pokud chcete otevt <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>fotky, zapnte <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> aplikace azkuste to znovu"</string>
diff --git a/photopicker/res/values-cs/feature_search_strings.xml b/photopicker/res/values-cs/feature_search_strings.xml
index aa7a91ecc..07fddb9c5 100644
--- a/photopicker/res/values-cs/feature_search_strings.xml
+++ b/photopicker/res/values-cs/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Hledat"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Hledejte ve svch fotkch"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Hledat ve vaich fotkch"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Hledat ve vaich videch"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"dn vsledky"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Zkuste vyhledat podobn slova"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Nvrhy"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Vyhledvn vypnuto."</string>
 </resources>
diff --git a/photopicker/res/values-da/core_strings.xml b/photopicker/res/values-da/core_strings.xml
index 061221b93..1fbeb1dd0 100644
--- a/photopicker/res/values-da/core_strings.xml
+++ b/photopicker/res/values-da/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Billeder og videoer"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Medier"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> blev taget <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Videoen blev optaget <xliff:g id="TIME">%1$s</xliff:g> og er <xliff:g id="DURATION">%2$s</xliff:g> lang"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Billede"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"Gif"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Levende billede"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Valgt"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Ikke valgt"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Vlg"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Fravlg"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Udfr"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Fravlg alle"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> billeder eller videoer er valgt"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Vlg hjst <xliff:g id="COUNT">%1$s</xliff:g> elementer"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Billeder"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Album"</string>
diff --git a/photopicker/res/values-da/feature_preview_strings.xml b/photopicker/res/values-da/feature_preview_strings.xml
index 0f71a586e..88e46c442 100644
--- a/photopicker/res/values-da/feature_preview_strings.xml
+++ b/photopicker/res/values-da/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Markr alle <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Vlg alle (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Vlg"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Fjern markeringen af alle <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Fravlg alle (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Forhndsvisning"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Problemer med at afspille video"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Tjek din internetforbindelse, og prv igen"</string>
diff --git a/photopicker/res/values-da/feature_profiles_strings.xml b/photopicker/res/values-da/feature_profiles_strings.xml
index 19a35355c..c64eac172 100644
--- a/photopicker/res/values-da/feature_profiles_strings.xml
+++ b/photopicker/res/values-da/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Arbejde"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Andet"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Skift brugerprofil"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> er valgt"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Apps fra profilen <xliff:g id="PROFILE_NAME">%1$s</xliff:g> er sat p pause"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Blokeret af din administrator"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Hvis du vil bne billeder fra profilen <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>, skal du aktivere dine apps fra profilen <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> og derefter prve igen"</string>
diff --git a/photopicker/res/values-da/feature_search_strings.xml b/photopicker/res/values-da/feature_search_strings.xml
index 2fd1cd7f0..54db9cc6c 100644
--- a/photopicker/res/values-da/feature_search_strings.xml
+++ b/photopicker/res/values-da/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Sg"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Sg i dine billeder"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Sg i dine billeder"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Sg i dine videoer"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Ingen resultater fundet"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Prv at sge efter lignende ord"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Forslag"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Sgning er deaktiveret."</string>
 </resources>
diff --git a/photopicker/res/values-de/core_strings.xml b/photopicker/res/values-de/core_strings.xml
index 95a490ffa..750cf36a3 100644
--- a/photopicker/res/values-de/core_strings.xml
+++ b/photopicker/res/values-de/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Fotos&amp; Videos"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Medium"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> wurde am <xliff:g id="TIME">%2$s</xliff:g> aufgenommen"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Video vom <xliff:g id="TIME">%1$s</xliff:g> mit einer Dauer von <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Foto"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Foto mit Bewegtbild"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Ausgewhlt"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Nicht ausgewhlt"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Auswhlen"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Auswahl aufheben"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Fertig"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Auswahl fr alle aufheben"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g>Fotos oder Videos ausgewhlt"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Maximal <xliff:g id="COUNT">%1$s</xliff:g>Elemente auswhlen"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Fotos"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Alben"</string>
diff --git a/photopicker/res/values-de/feature_preview_strings.xml b/photopicker/res/values-de/feature_preview_strings.xml
index 24d082eff..e4ae01d84 100644
--- a/photopicker/res/values-de/feature_preview_strings.xml
+++ b/photopicker/res/values-de/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Alleauswhlen <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Alle(<xliff:g id="COUNT">%1$s</xliff:g>) auswhlen"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Auswhlen"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Auswahl fr alleaufheben <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Auswahl fr alle(<xliff:g id="COUNT">%1$s</xliff:g>) aufheben"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Vorschau anzeigen"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Probleme bei der Wiedergabe des Videos"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Prfe deine Internetverbindung und versuch es noch einmal"</string>
diff --git a/photopicker/res/values-de/feature_profiles_strings.xml b/photopicker/res/values-de/feature_profiles_strings.xml
index f57a1c1a5..eace843bc 100644
--- a/photopicker/res/values-de/feature_profiles_strings.xml
+++ b/photopicker/res/values-de/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Geschftlich"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Sonstiges"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Nutzerprofil wechseln"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> ausgewhlt"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Apps aus dem Profil <xliff:g id="PROFILE_NAME">%1$s</xliff:g> sind pausiert"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Vom Administrator blockiert"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Wenn du Fotos aus dem Profil <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g> ffnen mchtest, aktiviere deine Apps aus dem Profil <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> und versuche es noch einmal"</string>
diff --git a/photopicker/res/values-de/feature_search_strings.xml b/photopicker/res/values-de/feature_search_strings.xml
index c5f55c3c5..cbbeedece 100644
--- a/photopicker/res/values-de/feature_search_strings.xml
+++ b/photopicker/res/values-de/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Suchen"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"In Fotos suchen"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"In Fotos suchen"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Deine Videos durchsuchen"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Keine Ergebnisse gefunden"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Versuche es mit einer Suche anhand hnlicher Wrter"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Vorschlge"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Suche deaktiviert."</string>
 </resources>
diff --git a/photopicker/res/values-el/core_strings.xml b/photopicker/res/values-el/core_strings.xml
index e699ed6f7..d9b753760 100644
--- a/photopicker/res/values-el/core_strings.xml
+++ b/photopicker/res/values-el/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>   <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"    <xliff:g id="TIME">%1$s</xliff:g>    <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"  "</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">""</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">" "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"  <xliff:g id="COUNT">%1$s</xliff:g>   "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"   <xliff:g id="COUNT">%1$s</xliff:g> "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-el/feature_preview_strings.xml b/photopicker/res/values-el/feature_preview_strings.xml
index 540fc03fd..b523ea8d1 100644
--- a/photopicker/res/values-el/feature_preview_strings.xml
+++ b/photopicker/res/values-el/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"   <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"   <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">""</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"    "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"        "</string>
diff --git a/photopicker/res/values-el/feature_profiles_strings.xml b/photopicker/res/values-el/feature_profiles_strings.xml
index 66f86fb11..8fff05882 100644
--- a/photopicker/res/values-el/feature_profiles_strings.xml
+++ b/photopicker/res/values-el/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"  "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"   <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"    <xliff:g id="PROFILE_NAME">%1$s</xliff:g>    "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"    "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"      <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>,      <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>    "</string>
diff --git a/photopicker/res/values-el/feature_search_strings.xml b/photopicker/res/values-el/feature_search_strings.xml
index 093f0cd0c..0d735c6f4 100644
--- a/photopicker/res/values-el/feature_search_strings.xml
+++ b/photopicker/res/values-el/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"   "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"   "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"   "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"    "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  ."</string>
 </resources>
diff --git a/photopicker/res/values-en-rAU/core_strings.xml b/photopicker/res/values-en-rAU/core_strings.xml
index d1d8f3eb4..773c8c262 100644
--- a/photopicker/res/values-en-rAU/core_strings.xml
+++ b/photopicker/res/values-en-rAU/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Photos and videos"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Media"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> taken on <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Video taken on <xliff:g id="TIME">%1$s</xliff:g> with duration <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Photo"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Motion photo"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Selected"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Not selected"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Select"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Deselect"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Done"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Deselect all"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> photos or videos selected"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Select up to <xliff:g id="COUNT">%1$s</xliff:g> items"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Photos"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albums"</string>
diff --git a/photopicker/res/values-en-rAU/feature_preview_strings.xml b/photopicker/res/values-en-rAU/feature_preview_strings.xml
index b56340a8b..e1979db42 100644
--- a/photopicker/res/values-en-rAU/feature_preview_strings.xml
+++ b/photopicker/res/values-en-rAU/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Select all <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Select all (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Select"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Unselect all <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Unselect all (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Preview"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Trouble playing video"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Please check your Internet connection and try again"</string>
diff --git a/photopicker/res/values-en-rAU/feature_profiles_strings.xml b/photopicker/res/values-en-rAU/feature_profiles_strings.xml
index 0a3a427f1..d17ed1589 100644
--- a/photopicker/res/values-en-rAU/feature_profiles_strings.xml
+++ b/photopicker/res/values-en-rAU/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Work"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Other"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Switch user profile"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Selected <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> apps are paused"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Blocked by your admin"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"To open <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g> photos, turn on your <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> apps, then try again"</string>
diff --git a/photopicker/res/values-en-rAU/feature_search_strings.xml b/photopicker/res/values-en-rAU/feature_search_strings.xml
index 5ab508532..48623b657 100644
--- a/photopicker/res/values-en-rAU/feature_search_strings.xml
+++ b/photopicker/res/values-en-rAU/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Search"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Search your photos"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Search your photos"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Search your videos"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"No results found"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Try searching for similar words"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Suggestions"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Search disabled."</string>
 </resources>
diff --git a/photopicker/res/values-en-rCA/core_strings.xml b/photopicker/res/values-en-rCA/core_strings.xml
index bb2fd02c0..d40dad299 100644
--- a/photopicker/res/values-en-rCA/core_strings.xml
+++ b/photopicker/res/values-en-rCA/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Photos &amp; videos"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Media"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> taken on <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Video taken on <xliff:g id="TIME">%1$s</xliff:g> with duration <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Photo"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Motion Photo"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Selected"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Not selected"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Select"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Deselect"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Done"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Deselect all"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> photos or videos selected"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Select up to <xliff:g id="COUNT">%1$s</xliff:g> items"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Photos"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albums"</string>
diff --git a/photopicker/res/values-en-rCA/feature_preview_strings.xml b/photopicker/res/values-en-rCA/feature_preview_strings.xml
index 49342b388..4d7b57613 100644
--- a/photopicker/res/values-en-rCA/feature_preview_strings.xml
+++ b/photopicker/res/values-en-rCA/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Select all <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Select all (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Select"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Unselect all <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Unselect all (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Preview"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Trouble playing video"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Check your internet connection and try again"</string>
diff --git a/photopicker/res/values-en-rCA/feature_profiles_strings.xml b/photopicker/res/values-en-rCA/feature_profiles_strings.xml
index a361a7c9f..5047a5aa6 100644
--- a/photopicker/res/values-en-rCA/feature_profiles_strings.xml
+++ b/photopicker/res/values-en-rCA/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Work"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Other"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Switch User Profile"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Selected <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> apps are paused"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Blocked by your admin"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"To open <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g> photos turn on your <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> apps, then try again"</string>
diff --git a/photopicker/res/values-en-rCA/feature_search_strings.xml b/photopicker/res/values-en-rCA/feature_search_strings.xml
index 5ab508532..48623b657 100644
--- a/photopicker/res/values-en-rCA/feature_search_strings.xml
+++ b/photopicker/res/values-en-rCA/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Search"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Search your photos"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Search your photos"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Search your videos"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"No results found"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Try searching for similar words"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Suggestions"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Search disabled."</string>
 </resources>
diff --git a/photopicker/res/values-en-rGB/core_strings.xml b/photopicker/res/values-en-rGB/core_strings.xml
index d1d8f3eb4..773c8c262 100644
--- a/photopicker/res/values-en-rGB/core_strings.xml
+++ b/photopicker/res/values-en-rGB/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Photos and videos"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Media"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> taken on <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Video taken on <xliff:g id="TIME">%1$s</xliff:g> with duration <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Photo"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Motion photo"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Selected"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Not selected"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Select"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Deselect"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Done"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Deselect all"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> photos or videos selected"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Select up to <xliff:g id="COUNT">%1$s</xliff:g> items"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Photos"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albums"</string>
diff --git a/photopicker/res/values-en-rGB/feature_preview_strings.xml b/photopicker/res/values-en-rGB/feature_preview_strings.xml
index b56340a8b..e1979db42 100644
--- a/photopicker/res/values-en-rGB/feature_preview_strings.xml
+++ b/photopicker/res/values-en-rGB/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Select all <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Select all (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Select"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Unselect all <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Unselect all (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Preview"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Trouble playing video"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Please check your Internet connection and try again"</string>
diff --git a/photopicker/res/values-en-rGB/feature_profiles_strings.xml b/photopicker/res/values-en-rGB/feature_profiles_strings.xml
index 0a3a427f1..d17ed1589 100644
--- a/photopicker/res/values-en-rGB/feature_profiles_strings.xml
+++ b/photopicker/res/values-en-rGB/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Work"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Other"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Switch user profile"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Selected <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> apps are paused"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Blocked by your admin"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"To open <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g> photos, turn on your <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> apps, then try again"</string>
diff --git a/photopicker/res/values-en-rGB/feature_search_strings.xml b/photopicker/res/values-en-rGB/feature_search_strings.xml
index 5ab508532..48623b657 100644
--- a/photopicker/res/values-en-rGB/feature_search_strings.xml
+++ b/photopicker/res/values-en-rGB/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Search"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Search your photos"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Search your photos"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Search your videos"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"No results found"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Try searching for similar words"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Suggestions"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Search disabled."</string>
 </resources>
diff --git a/photopicker/res/values-en-rIN/core_strings.xml b/photopicker/res/values-en-rIN/core_strings.xml
index d1d8f3eb4..773c8c262 100644
--- a/photopicker/res/values-en-rIN/core_strings.xml
+++ b/photopicker/res/values-en-rIN/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Photos and videos"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Media"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> taken on <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Video taken on <xliff:g id="TIME">%1$s</xliff:g> with duration <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Photo"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Motion photo"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Selected"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Not selected"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Select"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Deselect"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Done"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Deselect all"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> photos or videos selected"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Select up to <xliff:g id="COUNT">%1$s</xliff:g> items"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Photos"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albums"</string>
diff --git a/photopicker/res/values-en-rIN/feature_preview_strings.xml b/photopicker/res/values-en-rIN/feature_preview_strings.xml
index b56340a8b..e1979db42 100644
--- a/photopicker/res/values-en-rIN/feature_preview_strings.xml
+++ b/photopicker/res/values-en-rIN/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Select all <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Select all (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Select"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Unselect all <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Unselect all (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Preview"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Trouble playing video"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Please check your Internet connection and try again"</string>
diff --git a/photopicker/res/values-en-rIN/feature_profiles_strings.xml b/photopicker/res/values-en-rIN/feature_profiles_strings.xml
index 0a3a427f1..d17ed1589 100644
--- a/photopicker/res/values-en-rIN/feature_profiles_strings.xml
+++ b/photopicker/res/values-en-rIN/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Work"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Other"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Switch user profile"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Selected <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> apps are paused"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Blocked by your admin"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"To open <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g> photos, turn on your <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> apps, then try again"</string>
diff --git a/photopicker/res/values-en-rIN/feature_search_strings.xml b/photopicker/res/values-en-rIN/feature_search_strings.xml
index 5ab508532..48623b657 100644
--- a/photopicker/res/values-en-rIN/feature_search_strings.xml
+++ b/photopicker/res/values-en-rIN/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Search"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Search your photos"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Search your photos"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Search your videos"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"No results found"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Try searching for similar words"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Suggestions"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Search disabled."</string>
 </resources>
diff --git a/photopicker/res/values-en-rXC/feature_search_strings.xml b/photopicker/res/values-en-rXC/feature_search_strings.xml
index d30e8ed39..6e654bdc5 100644
--- a/photopicker/res/values-en-rXC/feature_search_strings.xml
+++ b/photopicker/res/values-en-rXC/feature_search_strings.xml
@@ -18,5 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Search"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Search your photos"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Search your photos"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Search your videos"</string>
 </resources>
diff --git a/photopicker/res/values-es-rUS/core_strings.xml b/photopicker/res/values-es-rUS/core_strings.xml
index 71fa9ee13..c1c02cbb5 100644
--- a/photopicker/res/values-es-rUS/core_strings.xml
+++ b/photopicker/res/values-es-rUS/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Fotos y videos"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Contenido multimedia"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> tomado el <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Video creado el <xliff:g id="TIME">%1$s</xliff:g> de <xliff:g id="DURATION">%2$s</xliff:g> de duracin"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Foto"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Foto en movimiento"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Seleccionado"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Sin seleccionar"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Seleccionar"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Anular seleccin"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Listo"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Anular toda la seleccin"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> fotos o videos seleccionados"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Elige <xliff:g id="COUNT">%1$s</xliff:g> elementos como mximo"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Fotos"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"lbumes"</string>
diff --git a/photopicker/res/values-es-rUS/feature_preview_strings.xml b/photopicker/res/values-es-rUS/feature_preview_strings.xml
index 0221d4c0b..a3f660ae3 100644
--- a/photopicker/res/values-es-rUS/feature_preview_strings.xml
+++ b/photopicker/res/values-es-rUS/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Seleccionar todo <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Seleccionar todos (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Seleccionar"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Anular toda la seleccin <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Anular la seleccin de todos (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Vista previa"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Se produjo un error al reproducir el video"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Revisa la conexin a Internet y vuelve a intentarlo"</string>
diff --git a/photopicker/res/values-es-rUS/feature_profiles_strings.xml b/photopicker/res/values-es-rUS/feature_profiles_strings.xml
index 19716d188..cb2541775 100644
--- a/photopicker/res/values-es-rUS/feature_profiles_strings.xml
+++ b/photopicker/res/values-es-rUS/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Trabajo"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Otro"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Cambiar perfil de usuario"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Se seleccion <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Se pausaron las apps de <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Bloqueado por tu administrador"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Para abrir las fotos de <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>, activa tus apps de <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> y vuelve a intentarlo"</string>
diff --git a/photopicker/res/values-es-rUS/feature_search_strings.xml b/photopicker/res/values-es-rUS/feature_search_strings.xml
index ec89d7d0a..97bc545d4 100644
--- a/photopicker/res/values-es-rUS/feature_search_strings.xml
+++ b/photopicker/res/values-es-rUS/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Buscar"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Buscar fotos"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Buscar fotos"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Buscar en tus videos"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"No se encontraron resultados"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Intenta buscar palabras similares"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Sugerencias"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Bsqueda inhabilitada."</string>
 </resources>
diff --git a/photopicker/res/values-es/core_strings.xml b/photopicker/res/values-es/core_strings.xml
index d04088349..dfa3deb3c 100644
--- a/photopicker/res/values-es/core_strings.xml
+++ b/photopicker/res/values-es/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Fotos y vdeos"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Contenido multimedia"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> hecha el <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Vdeo grabado el <xliff:g id="TIME">%1$s</xliff:g> con una duracin de <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Foto"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Foto con movimiento"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Seleccionado"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"No seleccionado"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Seleccionar"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Desmarcar"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Hecho"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Desmarcar todo"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> fotos o vdeos seleccionados"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Selecciona hasta <xliff:g id="COUNT">%1$s</xliff:g> elementos"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Fotos"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"lbumes"</string>
diff --git a/photopicker/res/values-es/feature_cloud_strings.xml b/photopicker/res/values-es/feature_cloud_strings.xml
index 508968954..cdea0a463 100644
--- a/photopicker/res/values-es/feature_cloud_strings.xml
+++ b/photopicker/res/values-es/feature_cloud_strings.xml
@@ -27,6 +27,6 @@
     <string name="photopicker_banner_cloud_choose_account_message" msgid="5173210485511611652">"Para incluir fotos de <xliff:g id="APP_NAME">%1$s</xliff:g> aqu, elige una cuenta en la aplicacin"</string>
     <string name="photopicker_banner_cloud_choose_account_button" msgid="3407910358624445230">"Elegir cuenta"</string>
     <string name="photopicker_banner_cloud_choose_provider_title" msgid="992613053341538886">"Elige una aplicacin de almacenamiento de contenido en la nube"</string>
-    <string name="photopicker_banner_cloud_choose_provider_message" msgid="1102889303996108506">"Para incluir aqu la copia de seguridad de las fotos, elige una aplicacin multimedia en la nube desde Ajustes"</string>
+    <string name="photopicker_banner_cloud_choose_provider_message" msgid="1102889303996108506">"Para incluir aqu las fotos de las que tienes copia de seguridad, elige una aplicacin de fotos en la nube desde Ajustes"</string>
     <string name="photopicker_banner_cloud_choose_app_button" msgid="8228365266860220123">"Elegir aplicacin"</string>
 </resources>
diff --git a/photopicker/res/values-es/feature_overflow_menu_strings.xml b/photopicker/res/values-es/feature_overflow_menu_strings.xml
index 57d2c3aef..3bb693e47 100644
--- a/photopicker/res/values-es/feature_overflow_menu_strings.xml
+++ b/photopicker/res/values-es/feature_overflow_menu_strings.xml
@@ -18,6 +18,6 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_overflow_menu_description" msgid="6548535301621140571">"Ms"</string>
-    <string name="photopicker_overflow_cloud_media_app" msgid="1790591881463404779">"Aplicacin multimedia en la nube"</string>
+    <string name="photopicker_overflow_cloud_media_app" msgid="1790591881463404779">"Aplicacin de fotos en la nube"</string>
     <string name="photopicker_overflow_browse" msgid="6764715084773515122">"Buscar"</string>
 </resources>
diff --git a/photopicker/res/values-es/feature_preview_strings.xml b/photopicker/res/values-es/feature_preview_strings.xml
index 921a2c4ae..36dd411b3 100644
--- a/photopicker/res/values-es/feature_preview_strings.xml
+++ b/photopicker/res/values-es/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Seleccionar todo (<xliff:g id="COUNT">(%1$s)</xliff:g>)"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Seleccionar todo (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Seleccionar"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Deseleccionar todo (<xliff:g id="COUNT">(%1$s)</xliff:g>)"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Deseleccionar todo (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Vista previa"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Hay problemas para reproducir el vdeo"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Comprueba tu conexin a Internet y vuelve a intentarlo"</string>
diff --git a/photopicker/res/values-es/feature_profiles_strings.xml b/photopicker/res/values-es/feature_profiles_strings.xml
index 6316b1cb8..27d8a6a48 100644
--- a/photopicker/res/values-es/feature_profiles_strings.xml
+++ b/photopicker/res/values-es/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Trabajo"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Otro"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Cambiar perfil de usuario"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Seleccionado: <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Las aplicaciones de <xliff:g id="PROFILE_NAME">%1$s</xliff:g> estn pausadas"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Bloqueado por tu administrador"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Para abrir las fotos de <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>, activa tus aplicaciones de <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> e intntalo de nuevo"</string>
diff --git a/photopicker/res/values-es/feature_search_strings.xml b/photopicker/res/values-es/feature_search_strings.xml
index ec89d7d0a..4efc06bd5 100644
--- a/photopicker/res/values-es/feature_search_strings.xml
+++ b/photopicker/res/values-es/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Buscar"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Buscar fotos"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Buscar en tus fotos"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Buscar en tus vdeos"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"No hay resultados"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Prueba a buscar palabras similares"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Sugerencias"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Bsqueda inhabilitada."</string>
 </resources>
diff --git a/photopicker/res/values-et/core_strings.xml b/photopicker/res/values-et/core_strings.xml
index 3e55cce94..a00d8706f 100644
--- a/photopicker/res/values-et/core_strings.xml
+++ b/photopicker/res/values-et/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Fotod ja videod"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Meedia"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> jdvustati: <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Video jdvustati: <xliff:g id="TIME">%1$s</xliff:g>. Video kestus: <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Foto"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Liikuv foto"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Valitud"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Pole valitud"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Vali"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Thista valik"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Valmis"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Thista kogu valik"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"Valitud <xliff:g id="COUNT">%1$s</xliff:g> fotot vi videot"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Valige kuni <xliff:g id="COUNT">%1$s</xliff:g> ksust"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Fotod"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albumid"</string>
diff --git a/photopicker/res/values-et/feature_preview_strings.xml b/photopicker/res/values-et/feature_preview_strings.xml
index df29c6545..a2da29b6a 100644
--- a/photopicker/res/values-et/feature_preview_strings.xml
+++ b/photopicker/res/values-et/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Vali kik <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Vali kik (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Vali"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Thista kigi <xliff:g id="COUNT">(%1$s)</xliff:g> valik"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Thista kigi valik (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Eelvaade"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Probleem video esitamisel"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Kontrollige oma internetihendust ja proovige uuesti"</string>
diff --git a/photopicker/res/values-et/feature_profiles_strings.xml b/photopicker/res/values-et/feature_profiles_strings.xml
index cb2fd452e..8859f214a 100644
--- a/photopicker/res/values-et/feature_profiles_strings.xml
+++ b/photopicker/res/values-et/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"T"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Muu"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Kasutajaprofiili vahetamine"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Valitud on <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Profiili <xliff:g id="PROFILE_NAME">%1$s</xliff:g> rakendused on peatatud"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Blokeeris teie administraator"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Profiili <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g> fotode avamiseks llitage sisse profiili <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> rakendused ja proovige siis uuesti."</string>
diff --git a/photopicker/res/values-et/feature_search_strings.xml b/photopicker/res/values-et/feature_search_strings.xml
index 926ac9fd0..924881fea 100644
--- a/photopicker/res/values-et/feature_search_strings.xml
+++ b/photopicker/res/values-et/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Otsing"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Otsige oma fotosid"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Otsige oma fotosid"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Otsige oma videoid"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Tulemusi ei leitud"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Proovige otsida sarnaseid snu"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Soovitused"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Otsing keelatud"</string>
 </resources>
diff --git a/photopicker/res/values-eu/core_strings.xml b/photopicker/res/values-eu/core_strings.xml
index 0cec70fbe..3015023f5 100644
--- a/photopicker/res/values-eu/core_strings.xml
+++ b/photopicker/res/values-eu/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Argazkiak eta bideoak"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Multimedia-edukia"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> (<xliff:g id="TIME">%2$s</xliff:g>)"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"<xliff:g id="TIME">%1$s</xliff:g> datan grabatutako bideoa; <xliff:g id="DURATION">%2$s</xliff:g> irauten du"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Argazkia"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIFa"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Argazki mugimenduduna"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Hautatuta"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Hautatu gabea"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Hautatu"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Desautatu"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Eginda"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Desautatu guztiak"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> argazki edo bideo hautatu dira"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Hautatu <xliff:g id="COUNT">%1$s</xliff:g> elementu, gehienez"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Argazkiak"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albumak"</string>
diff --git a/photopicker/res/values-eu/feature_preview_strings.xml b/photopicker/res/values-eu/feature_preview_strings.xml
index 08b295ac0..c1c21a6f6 100644
--- a/photopicker/res/values-eu/feature_preview_strings.xml
+++ b/photopicker/res/values-eu/feature_preview_strings.xml
@@ -17,11 +17,11 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Hautatu guztiak <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Hautatu guztiak (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Hautatu"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Desautatu guztiak (<xliff:g id="COUNT">(%1$s)</xliff:g>)"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Desautatu guztiak (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Aurreikusi"</string>
-    <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Arazoren bat izan da bideoa erreproduzitzean"</string>
+    <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Arazoak daude bideoa erreproduzitzeko"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Egiaztatu Internetera konektatuta zaudela eta saiatu berriro"</string>
     <string name="photopicker_preview_dialog_error_retry_button_label" msgid="6246977209614737255">"Saiatu berriro"</string>
     <string name="photopicker_preview_video_error_snackbar" msgid="5090849265316922614">"Ezin da erreproduzitu bideoa"</string>
diff --git a/photopicker/res/values-eu/feature_profiles_strings.xml b/photopicker/res/values-eu/feature_profiles_strings.xml
index 2a5a86bfc..ce7a11f0d 100644
--- a/photopicker/res/values-eu/feature_profiles_strings.xml
+++ b/photopicker/res/values-eu/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Lanekoa"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Beste bat"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Aldatu erabiltzaile-profila"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> dago hautatuta"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"\"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>\" profileko aplikazioak pausatuta daude"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Administratzaileak blokeatu du"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"\"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>\" profileko datuak ireki nahi badituzu, aktibatu \"<xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>\" profileko aplikazioak eta saiatu berriro"</string>
diff --git a/photopicker/res/values-eu/feature_search_strings.xml b/photopicker/res/values-eu/feature_search_strings.xml
index af6060fa4..cf4346e81 100644
--- a/photopicker/res/values-eu/feature_search_strings.xml
+++ b/photopicker/res/values-eu/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Bilatu"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Bilatu argazkietan"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Bilatu argazkietan"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Bilatu bideoetan"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Ez da aurkitu emaitzarik"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Bilatu antzeko hitzak"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Iradokizunak"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Bilaketa desgaituta dago."</string>
 </resources>
diff --git a/photopicker/res/values-fa/core_strings.xml b/photopicker/res/values-fa/core_strings.xml
index bd5633830..dfe7224e0 100644
--- a/photopicker/res/values-fa/core_strings.xml
+++ b/photopicker/res/values-fa/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>  <xliff:g id="TIME">%2$s</xliff:g>   "</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"  <xliff:g id="TIME">%1$s</xliff:g>   <xliff:g id="DURATION">%2$s</xliff:g>   "</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">""</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">" "</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"  "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"   "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g>      "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">" <xliff:g id="COUNT">%1$s</xliff:g>   "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Photos"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-fa/feature_preview_strings.xml b/photopicker/res/values-fa/feature_preview_strings.xml
index d16f12ef0..d1abcf9c7 100644
--- a/photopicker/res/values-fa/feature_preview_strings.xml
+++ b/photopicker/res/values-fa/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"  <xliff:g id="COUNT">(%1$s)</xliff:g> "</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">" "</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"   <xliff:g id="COUNT">(%1$s)</xliff:g> "</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"   (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">""</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"     "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"        "</string>
diff --git a/photopicker/res/values-fa/feature_profiles_strings.xml b/photopicker/res/values-fa/feature_profiles_strings.xml
index 879b2463f..301bf4daf 100644
--- a/photopicker/res/values-fa/feature_profiles_strings.xml
+++ b/photopicker/res/values-fa/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"   "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>  "</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">" <xliff:g id="PROFILE_NAME">%1$s</xliff:g>    "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"     "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"    <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>  <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>       "</string>
diff --git a/photopicker/res/values-fa/feature_search_strings.xml b/photopicker/res/values-fa/feature_search_strings.xml
index 708976c94..8e2d1cb2e 100644
--- a/photopicker/res/values-fa/feature_search_strings.xml
+++ b/photopicker/res/values-fa/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">" "</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"  "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">" "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">" "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"    "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  ."</string>
 </resources>
diff --git a/photopicker/res/values-fi/core_strings.xml b/photopicker/res/values-fi/core_strings.xml
index 92d4329f5..1915f8625 100644
--- a/photopicker/res/values-fi/core_strings.xml
+++ b/photopicker/res/values-fi/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Kuvat ja videot"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Media"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> on otettu <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Video kuvattu <xliff:g id="TIME">%1$s</xliff:g>, kesto <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Kuva"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Liikkuva kuva"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Valittu"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Ei valittu"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Valitse"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Poista valinta"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Valmis"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Poista valinta kaikista"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> kuvaa tai videota valittu"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Valitse enintn <xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Kuvat"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albumit"</string>
diff --git a/photopicker/res/values-fi/feature_preview_strings.xml b/photopicker/res/values-fi/feature_preview_strings.xml
index 5debc370c..1ae9f361f 100644
--- a/photopicker/res/values-fi/feature_preview_strings.xml
+++ b/photopicker/res/values-fi/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Valitse kaikki <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Valitse kaikki (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Valitse"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Poista kaikki <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Poista kaikki valinnat (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Esikatsele"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Ongelma videon toistamisessa"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Tarkista internetyhteys ja yrit uudelleen"</string>
diff --git a/photopicker/res/values-fi/feature_profiles_strings.xml b/photopicker/res/values-fi/feature_profiles_strings.xml
index 5d7b0a1fe..32673d169 100644
--- a/photopicker/res/values-fi/feature_profiles_strings.xml
+++ b/photopicker/res/values-fi/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Typaikka"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Muu"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Vaihda kyttjprofiilia"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> valittu"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Sovellukset on keskeytetty: <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Jrjestelmnvalvojan estm"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>-kuvien avaamiseksi valitse ensin <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>-sovellukset ja yrit sitten uudelleen"</string>
diff --git a/photopicker/res/values-fi/feature_search_strings.xml b/photopicker/res/values-fi/feature_search_strings.xml
index 7ac64b590..11fe5b16a 100644
--- a/photopicker/res/values-fi/feature_search_strings.xml
+++ b/photopicker/res/values-fi/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Haku"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Etsi kuvistasi"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Etsi kuvistasi"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Hae omia videoitasi"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Ei tuloksia"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Kokeile hakea samankaltaisia sanoja"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Ehdotukset"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Haku poistettu kytst."</string>
 </resources>
diff --git a/photopicker/res/values-fr-rCA/core_strings.xml b/photopicker/res/values-fr-rCA/core_strings.xml
index 22d1764d0..4cfb3d8e5 100644
--- a/photopicker/res/values-fr-rCA/core_strings.xml
+++ b/photopicker/res/values-fr-rCA/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Photos et vidos"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Contenu multimdia"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> prise le <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Vido prise le <xliff:g id="TIME">%1$s</xliff:g> d\'une dure de <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Photo"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Photo anime"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Slectionn"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Non slectionn"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Slectionner"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Dslectionner"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"OK"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Tout dslectionner"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g>photos ou vidos slectionnes"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Slectionnez jusqu\' <xliff:g id="COUNT">%1$s</xliff:g>lments"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Photos"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albums"</string>
diff --git a/photopicker/res/values-fr-rCA/feature_preview_strings.xml b/photopicker/res/values-fr-rCA/feature_preview_strings.xml
index 5082f5e82..9f4f20502 100644
--- a/photopicker/res/values-fr-rCA/feature_preview_strings.xml
+++ b/photopicker/res/values-fr-rCA/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Slectionner les <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Tout slectionner (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Slectionner"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Tout dslectionner <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Tout dslectionner (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Aperu"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Difficult  faire jouer la vido"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Vrifiez votre connexion Internet et ressayez"</string>
diff --git a/photopicker/res/values-fr-rCA/feature_profiles_strings.xml b/photopicker/res/values-fr-rCA/feature_profiles_strings.xml
index 1c138c74a..260ceadac 100644
--- a/photopicker/res/values-fr-rCA/feature_profiles_strings.xml
+++ b/photopicker/res/values-fr-rCA/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Professionnel"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Autre"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Changer de profil utilisateur"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> slectionn"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Les applis du profil <xliff:g id="PROFILE_NAME">%1$s</xliff:g> sont interrompues"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Option bloque par votre administrateur"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Pour ouvrir des photos du profil <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>, activez les applis de votre profil <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> et ressayez"</string>
diff --git a/photopicker/res/values-fr-rCA/feature_search_strings.xml b/photopicker/res/values-fr-rCA/feature_search_strings.xml
index d4be3f03f..2f4e78c42 100644
--- a/photopicker/res/values-fr-rCA/feature_search_strings.xml
+++ b/photopicker/res/values-fr-rCA/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Rechercher"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Rechercher des photos"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Rechercher des photos"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Rechercher des vidos"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Aucun rsultat trouv"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Essayez de rechercher des mots semblables"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Suggestions"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Recherche dsactive."</string>
 </resources>
diff --git a/photopicker/res/values-fr/core_strings.xml b/photopicker/res/values-fr/core_strings.xml
index a1249c3cd..20315291b 100644
--- a/photopicker/res/values-fr/core_strings.xml
+++ b/photopicker/res/values-fr/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Photos et vidos"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Contenus multimdias"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> prise le <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Vido d\'une dure de <xliff:g id="DURATION">%2$s</xliff:g> filme le <xliff:g id="TIME">%1$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Photo"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Photo anime"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Slectionne"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Non slectionn"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Slectionner"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Dslectionner"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"OK"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Tout dslectionner"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g>photo(s) ou vido(s) slectionne(s)"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Slectionnez <xliff:g id="COUNT">%1$s</xliff:g>lments maximum"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Photos"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albums"</string>
diff --git a/photopicker/res/values-fr/feature_preview_strings.xml b/photopicker/res/values-fr/feature_preview_strings.xml
index b1cbede77..48c64aa07 100644
--- a/photopicker/res/values-fr/feature_preview_strings.xml
+++ b/photopicker/res/values-fr/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Tout slectionner <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Tout slectionner (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Slectionner"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Tout dslectionner <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Tout dslectionner (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Prvisualiser"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Problme de lecture vido"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Vrifiez votre connexion Internet, puis ressayez"</string>
diff --git a/photopicker/res/values-fr/feature_profiles_strings.xml b/photopicker/res/values-fr/feature_profiles_strings.xml
index ecd65d48f..15cc34ab8 100644
--- a/photopicker/res/values-fr/feature_profiles_strings.xml
+++ b/photopicker/res/values-fr/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Professionnel"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Autre"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Changer de profil utilisateur"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> slectionn"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Les applis du profil <xliff:g id="PROFILE_NAME">%1$s</xliff:g> sont mises en pause"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Bloqu par votre administrateur"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Pour ouvrir les photos du profil <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>, activez les applis du profil <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> et ressayez"</string>
diff --git a/photopicker/res/values-fr/feature_search_strings.xml b/photopicker/res/values-fr/feature_search_strings.xml
index d4be3f03f..a14aa300b 100644
--- a/photopicker/res/values-fr/feature_search_strings.xml
+++ b/photopicker/res/values-fr/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Rechercher"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Rechercher des photos"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Rechercher des photos"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Rechercher des vidos"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Aucun rsultat"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Essayez de rechercher des mots similaires"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Suggestions"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Recherche dsactive."</string>
 </resources>
diff --git a/photopicker/res/values-gl/core_strings.xml b/photopicker/res/values-gl/core_strings.xml
index f9704108e..18395296c 100644
--- a/photopicker/res/values-gl/core_strings.xml
+++ b/photopicker/res/values-gl/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Fotos e vdeos"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Multimedia"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>, data en que se fixo: <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Vdeo gravado o <xliff:g id="TIME">%1$s</xliff:g>. Duracin: <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Foto"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Foto con movemento"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Elemento seleccionado"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Elemento non seleccionado"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Seleccionar"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Anular a seleccin"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Feito"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Anular toda a seleccin"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> fotos ou vdeos seleccionados"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Selecciona ata <xliff:g id="COUNT">%1$s</xliff:g> elementos"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Fotos"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"lbums"</string>
diff --git a/photopicker/res/values-gl/feature_preview_strings.xml b/photopicker/res/values-gl/feature_preview_strings.xml
index 75ed68c48..aeb04b97e 100644
--- a/photopicker/res/values-gl/feature_preview_strings.xml
+++ b/photopicker/res/values-gl/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Seleccionar todo (<xliff:g id="COUNT">(%1$s)</xliff:g>)"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Seleccionar todo (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Seleccionar"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Anular seleccin (<xliff:g id="COUNT">(%1$s)</xliff:g>)"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Anular seleccin (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Previsualizar"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Produciuse un problema ao reproducir o vdeo"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Comproba a ta conexin a Internet e tntao de novo"</string>
diff --git a/photopicker/res/values-gl/feature_profiles_strings.xml b/photopicker/res/values-gl/feature_profiles_strings.xml
index 413a72497..875630e6e 100644
--- a/photopicker/res/values-gl/feature_profiles_strings.xml
+++ b/photopicker/res/values-gl/feature_profiles_strings.xml
@@ -21,10 +21,11 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Traballo"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Outro"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Cambiar de perfil de usuario"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Perfil seleccionado: <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"As aplicacins do perfil <xliff:g id="PROFILE_NAME">%1$s</xliff:g> estn en pausa"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Bloqueado pola persoa administradora"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Para abrir as fotos de <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>, activa as aplicacins do perfil <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> e tntao de novo"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_message" msgid="7978497980448982863">"A persoa administradora non permite acceder aos datos desde este perfil."</string>
     <string name="photopicker_profile_banner_switch_button_label" msgid="1652041405540769126">"Cambiar"</string>
-    <string name="photopicker_profile_switch_banner_message" msgid="2969185213956642828">"Ests usando o seguinte perfil: <xliff:g id="CURRENT_PROFILE_NAME">%1$s</xliff:g>. Queres cambiar a estoutro: <xliff:g id="TARGET_PROFILE_NAME">%2$s</xliff:g>?"</string>
+    <string name="photopicker_profile_switch_banner_message" msgid="2969185213956642828">"Ests usando o perfil <xliff:g id="CURRENT_PROFILE_NAME">%1$s</xliff:g>. Queres cambiar ao perfil <xliff:g id="TARGET_PROFILE_NAME">%2$s</xliff:g>?"</string>
 </resources>
diff --git a/photopicker/res/values-gl/feature_search_strings.xml b/photopicker/res/values-gl/feature_search_strings.xml
index 6013b331c..ecbc5bd17 100644
--- a/photopicker/res/values-gl/feature_search_strings.xml
+++ b/photopicker/res/values-gl/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Fai buscas"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Fai buscas nas tas fotos"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Fai buscas nas tas fotos"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Fai buscas nos teus vdeos"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Non se atopou ningn resultado"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Proba a buscar palabras semellantes"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Suxestins"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"A busca est desactivada."</string>
 </resources>
diff --git a/photopicker/res/values-gu/core_strings.xml b/photopicker/res/values-gu/core_strings.xml
index 2f203c9f9..ec2d00ed0 100644
--- a/photopicker/res/values-gu/core_strings.xml
+++ b/photopicker/res/values-gu/core_strings.xml
@@ -19,11 +19,20 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> <xliff:g id="TIME">%2$s</xliff:g>  "</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"<xliff:g id="TIME">%1$s</xliff:g>    <xliff:g id="DURATION">%2$s</xliff:g>  "</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"  "</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"  "</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">" "</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">" "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">" "</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"  "</string>
-    <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"<xliff:g id="COUNT">%1$s</xliff:g>    "</string>
-    <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g>     "</string>
+    <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"  <xliff:g id="COUNT">%1$s</xliff:g>   "</string>
+    <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
     <string name="photopicker_photos_empty_state_title" msgid="7018770515431149456">"    "</string>
     <string name="photopicker_photos_empty_state_body" msgid="5959729294856198675">"      "</string>
diff --git a/photopicker/res/values-gu/feature_preview_strings.xml b/photopicker/res/values-gu/feature_preview_strings.xml
index 7845db131..ca567c000 100644
--- a/photopicker/res/values-gu/feature_preview_strings.xml
+++ b/photopicker/res/values-gu/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">" <xliff:g id="COUNT">(%1$s)</xliff:g>  "</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">" (<xliff:g id="COUNT">%1$s</xliff:g>)  "</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">" "</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">" <xliff:g id="COUNT">(%1$s)</xliff:g>  "</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">" (<xliff:g id="COUNT">%1$s</xliff:g>)  "</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">" "</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"   "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"        "</string>
diff --git a/photopicker/res/values-gu/feature_profiles_strings.xml b/photopicker/res/values-gu/feature_profiles_strings.xml
index 420aa72e7..e2d4892fd 100644
--- a/photopicker/res/values-gu/feature_profiles_strings.xml
+++ b/photopicker/res/values-gu/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"   "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>   "</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>    "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"     "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>   ,  <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>       "</string>
diff --git a/photopicker/res/values-gu/feature_search_strings.xml b/photopicker/res/values-gu/feature_search_strings.xml
index dafb31822..a6f7575c7 100644
--- a/photopicker/res/values-gu/feature_search_strings.xml
+++ b/photopicker/res/values-gu/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"  "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"   "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"    "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"    ."</string>
 </resources>
diff --git a/photopicker/res/values-hi/core_strings.xml b/photopicker/res/values-hi/core_strings.xml
index 8cf7fe3d1..5ec0e7712 100644
--- a/photopicker/res/values-hi/core_strings.xml
+++ b/photopicker/res/values-hi/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>    <xliff:g id="TIME">%2$s</xliff:g> "</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"    <xliff:g id="TIME">%1$s</xliff:g>      <xliff:g id="DURATION">%2$s</xliff:g> "</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">" "</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"  "</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"    "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">" "</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"      "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g>     "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"   <xliff:g id="COUNT">%1$s</xliff:g>  "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-hi/feature_preview_strings.xml b/photopicker/res/values-hi/feature_preview_strings.xml
index 14f097b32..d19b8d273 100644
--- a/photopicker/res/values-hi/feature_preview_strings.xml
+++ b/photopicker/res/values-hi/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"  <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"       <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"       (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">""</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"      "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"          "</string>
diff --git a/photopicker/res/values-hi/feature_profiles_strings.xml b/photopicker/res/values-hi/feature_profiles_strings.xml
index 02e147bd2..95d2c90f8 100644
--- a/photopicker/res/values-hi/feature_profiles_strings.xml
+++ b/photopicker/res/values-hi/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">" "</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"  "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>  "</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>    "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"     "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>       , <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>        "</string>
diff --git a/photopicker/res/values-hi/feature_search_strings.xml b/photopicker/res/values-hi/feature_search_strings.xml
index d9236bc54..70628fe72 100644
--- a/photopicker/res/values-hi/feature_search_strings.xml
+++ b/photopicker/res/values-hi/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"  "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"   "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"-  "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"       ."</string>
 </resources>
diff --git a/photopicker/res/values-hr/core_strings.xml b/photopicker/res/values-hr/core_strings.xml
index 5a3179e51..2e61773e6 100644
--- a/photopicker/res/values-hr/core_strings.xml
+++ b/photopicker/res/values-hr/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Fotografije i videozapisi"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Mediji"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>, snimljeno: <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Videozapis snimljen <xliff:g id="TIME">%1$s</xliff:g> u trajanju od <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Fotografija"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Fotografija s videom"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Odabrano"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Nije odabrano"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Odaberi"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Poniti odabir"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Gotovo"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Poniti odabir za sve"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"Odabrano fotografija ili videozapisa: <xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Odaberite najvie ovoliko stavki: <xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Fotografije"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albumi"</string>
diff --git a/photopicker/res/values-hr/feature_preview_strings.xml b/photopicker/res/values-hr/feature_preview_strings.xml
index 166e18555..c52c37e39 100644
--- a/photopicker/res/values-hr/feature_preview_strings.xml
+++ b/photopicker/res/values-hr/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Odaberi sve <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Odaberi sve (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Odaberi"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Poniti odabir za sve <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Poniti odabir za sve (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Pregled"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Potekoe s reprodukcijom videozapisa"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Provjerite internetsku vezu i pokuajte ponovo"</string>
diff --git a/photopicker/res/values-hr/feature_profiles_strings.xml b/photopicker/res/values-hr/feature_profiles_strings.xml
index 43e2e9328..24ed552a0 100644
--- a/photopicker/res/values-hr/feature_profiles_strings.xml
+++ b/photopicker/res/values-hr/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Posao"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Drugo"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Promijeni korisniki profil"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Odabrali ste <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Pauzirane su aplikacije profila <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Blokirao va administrator"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Da biste otvorili fotografije profila <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>, ukljuite aplikacije profila <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>, a zatim pokuajte ponovno"</string>
diff --git a/photopicker/res/values-hr/feature_search_strings.xml b/photopicker/res/values-hr/feature_search_strings.xml
index 216b8e6e7..0b2b07e73 100644
--- a/photopicker/res/values-hr/feature_search_strings.xml
+++ b/photopicker/res/values-hr/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Pretraivanje"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Pretraivanje fotografija"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Pretraite fotografije"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Pretraivanje videozapisa"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Nema rezultata"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Pokuajte potraiti sline rijei"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Prijedlozi"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Pretraivanje je onemogueno."</string>
 </resources>
diff --git a/photopicker/res/values-hu/core_strings.xml b/photopicker/res/values-hu/core_strings.xml
index 2310b27aa..a2b29c3fd 100644
--- a/photopicker/res/values-hu/core_strings.xml
+++ b/photopicker/res/values-hu/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Fotk s videk"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Mdia"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>, kszts idpontja: <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Vide ksztsnek ideje s hossza: <xliff:g id="TIME">%1$s</xliff:g>, <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Fot"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Mozg fot"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Kijellve"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Nincs kivlasztva"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Kivlaszts"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Kivlaszts megszntetse"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Ksz"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"sszes kijells megszntetse"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> fot vagy vide kijellve"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Legfeljebb <xliff:g id="COUNT">%1$s</xliff:g> elemet jellhet ki"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Fotk"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albumok"</string>
diff --git a/photopicker/res/values-hu/feature_preview_strings.xml b/photopicker/res/values-hu/feature_preview_strings.xml
index 882ea0a3f..cc1ceca9e 100644
--- a/photopicker/res/values-hu/feature_preview_strings.xml
+++ b/photopicker/res/values-hu/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"sszes (<xliff:g id="COUNT">(%1$s)</xliff:g>) kijellse"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"sszes (<xliff:g id="COUNT">%1$s</xliff:g>) kijellse"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Kivlaszts"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"sszes <xliff:g id="COUNT">(%1$s)</xliff:g> kijells megszntetse"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"sszes (<xliff:g id="COUNT">%1$s</xliff:g>) kijellsnek megszntetse"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Elnzet"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Problma merlt fel a vide lejtszsakor"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Ellenrizze az internetkapcsolatot, s prblja jra"</string>
diff --git a/photopicker/res/values-hu/feature_profiles_strings.xml b/photopicker/res/values-hu/feature_profiles_strings.xml
index 3916285dd..95db8d401 100644
--- a/photopicker/res/values-hu/feature_profiles_strings.xml
+++ b/photopicker/res/values-hu/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Munkahely"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Egyb"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Felhasznli profil vltsa"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Kivlasztva: <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"A(z) <xliff:g id="PROFILE_NAME">%1$s</xliff:g> alkalmazsok szneteltetve vannak"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Rendszergazda ltal letiltva"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"A(z) <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g> fotk megnyitshoz kapcsolja be a(z) <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> alkalmazsokat, majd prblja jra."</string>
diff --git a/photopicker/res/values-hu/feature_search_strings.xml b/photopicker/res/values-hu/feature_search_strings.xml
index 87f94fb7f..216f5352a 100644
--- a/photopicker/res/values-hu/feature_search_strings.xml
+++ b/photopicker/res/values-hu/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Keress"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Fotk keresse"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Fotk keresse"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Keress a sajt videk kztt"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Nincs tallat"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Prblkozzon hasonl szavak keressvel"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Javaslatok"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Keress letiltva."</string>
 </resources>
diff --git a/photopicker/res/values-hy/core_strings.xml b/photopicker/res/values-hy/core_strings.xml
index 7ac1c21b2..aef5d1437 100644
--- a/photopicker/res/values-hy/core_strings.xml
+++ b/photopicker/res/values-hy/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>,     <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"     <xliff:g id="TIME">%1$s</xliff:g>,  <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">" "</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">" "</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">" "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">" "</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">" "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"  <xliff:g id="COUNT">%1$s</xliff:g>   "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"  <xliff:g id="COUNT">%1$s</xliff:g> "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-hy/feature_preview_strings.xml b/photopicker/res/values-hy/feature_preview_strings.xml
index b7cb55168..d408f4248 100644
--- a/photopicker/res/values-hy/feature_preview_strings.xml
+++ b/photopicker/res/values-hy/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"  (<xliff:g id="COUNT">(%1$s)</xliff:g>)"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"  (<xliff:g id="COUNT">(%1$s)</xliff:g>)"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">""</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"  "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"      "</string>
diff --git a/photopicker/res/values-hy/feature_profiles_strings.xml b/photopicker/res/values-hy/feature_profiles_strings.xml
index 43e205da1..afcc828f4 100644
--- a/photopicker/res/values-hy/feature_profiles_strings.xml
+++ b/photopicker/res/values-hy/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"  "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"  <xliff:g id="PROFILE_NAME">%1$s</xliff:g> "</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>   "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"    "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"  <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g> ,   <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> ,   "</string>
diff --git a/photopicker/res/values-hy/feature_search_strings.xml b/photopicker/res/values-hy/feature_search_strings.xml
index a8dcd5543..3b11e9055 100644
--- a/photopicker/res/values-hy/feature_search_strings.xml
+++ b/photopicker/res/values-hy/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"  "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"   "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  "</string>
 </resources>
diff --git a/photopicker/res/values-in/core_strings.xml b/photopicker/res/values-in/core_strings.xml
index a6e896f3a..8ae0fca56 100644
--- a/photopicker/res/values-in/core_strings.xml
+++ b/photopicker/res/values-in/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Foto &amp; video"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Media"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> diambil pada <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Video diambil pada <xliff:g id="TIME">%1$s</xliff:g> dengan durasi <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Foto"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Foto Motion"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Dipilih"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Tidak dipilih"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Pilih"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Batalkan pilihan"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Selesai"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Batalkan semua pilihan"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> foto atau video dipilih"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Pilih hingga <xliff:g id="COUNT">%1$s</xliff:g> item"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Foto"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Album"</string>
diff --git a/photopicker/res/values-in/feature_preview_strings.xml b/photopicker/res/values-in/feature_preview_strings.xml
index be5e700a6..383abe22d 100644
--- a/photopicker/res/values-in/feature_preview_strings.xml
+++ b/photopicker/res/values-in/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Pilih semua <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Pilih semua (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Pilih"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Batalkan semua pilihan <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Batalkan semua pilihan (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Pratinjau"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Terjadi masalah saat memutar video"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Periksa koneksi internet Anda, lalu coba lagi"</string>
diff --git a/photopicker/res/values-in/feature_profiles_strings.xml b/photopicker/res/values-in/feature_profiles_strings.xml
index 0c0c1c3e8..18264bdd2 100644
--- a/photopicker/res/values-in/feature_profiles_strings.xml
+++ b/photopicker/res/values-in/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Kerja"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Lainnya"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Beralih Profil Pengguna"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> dipilih"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Aplikasi <xliff:g id="PROFILE_NAME">%1$s</xliff:g> dijeda"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Diblokir oleh admin Anda"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Untuk membuka foto <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>, aktifkan aplikasi <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> Anda, lalu coba lagi"</string>
diff --git a/photopicker/res/values-in/feature_search_strings.xml b/photopicker/res/values-in/feature_search_strings.xml
index 7fe078417..3d61b0a00 100644
--- a/photopicker/res/values-in/feature_search_strings.xml
+++ b/photopicker/res/values-in/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Telusuri"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Telusuri foto Anda"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Telusuri foto Anda"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Telusuri video Anda"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Tidak ditemukan hasil"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Coba telusuri kata yang serupa"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Saran"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Penelusuran nonaktif."</string>
 </resources>
diff --git a/photopicker/res/values-is/core_strings.xml b/photopicker/res/values-is/core_strings.xml
index e161aa693..74a215f68 100644
--- a/photopicker/res/values-is/core_strings.xml
+++ b/photopicker/res/values-is/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Myndir og vde"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Efni"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> tekin <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"<xliff:g id="DURATION">%2$s</xliff:g> langt vde teki upp <xliff:g id="TIME">%1$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Mynd"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Lifandi mynd"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Vali"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Ekki vali"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Velja"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Afvelja"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Loki"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Afvelja allt"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> myndir ea vde valin"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Veldu allt a <xliff:g id="COUNT">%1$s</xliff:g> atrii"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Myndir"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albm"</string>
diff --git a/photopicker/res/values-is/feature_preview_strings.xml b/photopicker/res/values-is/feature_preview_strings.xml
index 304e22bc0..9de2d72b0 100644
--- a/photopicker/res/values-is/feature_preview_strings.xml
+++ b/photopicker/res/values-is/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Velja allt (<xliff:g id="COUNT">(%1$s)</xliff:g>)"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Velja allt (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Velja"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Afturkalla val  llu <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Afturkalla val  llu (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Forskoa"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Vandaml vi spilun vdes"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Athugau nettenginguna og reyndu aftur"</string>
diff --git a/photopicker/res/values-is/feature_profiles_strings.xml b/photopicker/res/values-is/feature_profiles_strings.xml
index 198ddf14c..fd99e4bc8 100644
--- a/photopicker/res/values-is/feature_profiles_strings.xml
+++ b/photopicker/res/values-is/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Vinna"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Anna"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Skipta um notandaprfl"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> valinn"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Hl var gert  forritum  <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"tiloka af stjrnanda"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Til a opna myndir  <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g> skaltu kveikja  forritum  <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> og reyna aftur"</string>
diff --git a/photopicker/res/values-is/feature_search_strings.xml b/photopicker/res/values-is/feature_search_strings.xml
index a547233fd..a23c423ea 100644
--- a/photopicker/res/values-is/feature_search_strings.xml
+++ b/photopicker/res/values-is/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Leita"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Leitau  myndasafninu nu"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Leitau  myndasafninu nu"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Leitau  vdeunum num"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Engar niurstur fundust"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Prfau a leita a svipuum orum"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Tillgur"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Slkkt  leit."</string>
 </resources>
diff --git a/photopicker/res/values-it/core_strings.xml b/photopicker/res/values-it/core_strings.xml
index 980dcd958..82cb910c7 100644
--- a/photopicker/res/values-it/core_strings.xml
+++ b/photopicker/res/values-it/core_strings.xml
@@ -19,14 +19,23 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Foto e video"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Contenuti multimediali"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> scattata il giorno <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Video del giorno <xliff:g id="TIME">%1$s</xliff:g> della durata di <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Foto"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Foto in movimento"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Opzione selezionata"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Non selezionato"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Seleziona"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Deseleziona"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Fine"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Deseleziona tutto"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> foto o video selezionati"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Seleziona massimo <xliff:g id="COUNT">%1$s</xliff:g> elementi"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Foto"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Album"</string>
     <string name="photopicker_photos_empty_state_title" msgid="7018770515431149456">"Ancora nessuna foto"</string>
-    <string name="photopicker_photos_empty_state_body" msgid="5959729294856198675">"Inizia ad acquisire foto e video"</string>
+    <string name="photopicker_photos_empty_state_body" msgid="5959729294856198675">"Inizia a scattare foto e registrare video"</string>
     <string name="photopicker_camera_empty_state_body" msgid="858373882699294081">"Le foto e i video acquisiti dall\'app Fotocamera verranno visualizzati qui"</string>
     <string name="photopicker_favorites_empty_state_title" msgid="3855048169943856242">"Ancora nessun preferito"</string>
     <string name="photopicker_favorites_empty_state_body" msgid="4206436541083780797">"Le foto e i video aggiunti ai preferiti o contrassegnati come speciali verranno visualizzati qui"</string>
diff --git a/photopicker/res/values-it/feature_preview_strings.xml b/photopicker/res/values-it/feature_preview_strings.xml
index fde287843..3c0d28ac2 100644
--- a/photopicker/res/values-it/feature_preview_strings.xml
+++ b/photopicker/res/values-it/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Seleziona tutti <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Seleziona tutto (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Seleziona"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Deseleziona tutti <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Deseleziona tutto (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Anteprima"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Errore durante la riproduzione del video"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Controlla la connessione a internet e riprova"</string>
diff --git a/photopicker/res/values-it/feature_profiles_strings.xml b/photopicker/res/values-it/feature_profiles_strings.xml
index 8f4246237..b8b26ea64 100644
--- a/photopicker/res/values-it/feature_profiles_strings.xml
+++ b/photopicker/res/values-it/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Lavoro"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Altro"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Cambia profilo utente"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Profilo selezionato: <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Le app del profilo <xliff:g id="PROFILE_NAME">%1$s</xliff:g> sono in pausa"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Accesso bloccato dall\'amministratore"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Per aprire le foto del profilo <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>, attiva le app del profilo <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>, quindi riprova"</string>
diff --git a/photopicker/res/values-it/feature_search_strings.xml b/photopicker/res/values-it/feature_search_strings.xml
index 54d691bf1..8e435b211 100644
--- a/photopicker/res/values-it/feature_search_strings.xml
+++ b/photopicker/res/values-it/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Cerca"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Cerca nelle tue foto"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Cerca nelle tue foto"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Cerca nei tuoi video"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Nessun risultato trovato"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Prova a cercare parole simili"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Suggerimenti"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Ricerca disattivata."</string>
 </resources>
diff --git a/photopicker/res/values-iw/core_strings.xml b/photopicker/res/values-iw/core_strings.xml
index b0f692fb0..0feb62abc 100644
--- a/photopicker/res/values-iw/core_strings.xml
+++ b/photopicker/res/values-iw/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">" "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">" <xliff:g id="ITEM_NAME">%1$s</xliff:g>  -<xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"  -<xliff:g id="TIME">%1$s</xliff:g>    <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"  "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">" "</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">" "</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">" "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"   "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">" <xliff:g id="COUNT">%1$s</xliff:g>   "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"   <xliff:g id="COUNT">%1$s</xliff:g> "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-iw/feature_preview_strings.xml b/photopicker/res/values-iw/feature_preview_strings.xml
index f463ecaff..bdd74ebf4 100644
--- a/photopicker/res/values-iw/feature_preview_strings.xml
+++ b/photopicker/res/values-iw/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"  (<xliff:g id="COUNT">(%1$s)</xliff:g>)"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"    (<xliff:g id="COUNT">(%1$s)</xliff:g>)"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"    (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">" "</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"  "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"      "</string>
diff --git a/photopicker/res/values-iw/feature_profiles_strings.xml b/photopicker/res/values-iw/feature_profiles_strings.xml
index 4a57e8b08..451427dbc 100644
--- a/photopicker/res/values-iw/feature_profiles_strings.xml
+++ b/photopicker/res/values-iw/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">" "</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"   "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">" : <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"  <xliff:g id="PROFILE_NAME">%1$s</xliff:g> "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"    "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"     <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>,      <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>  "</string>
diff --git a/photopicker/res/values-iw/feature_search_strings.xml b/photopicker/res/values-iw/feature_search_strings.xml
index e004cf4c4..45c65a9d2 100644
--- a/photopicker/res/values-iw/feature_search_strings.xml
+++ b/photopicker/res/values-iw/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">" "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">" "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">" "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"    "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">" ."</string>
 </resources>
diff --git a/photopicker/res/values-ja/core_strings.xml b/photopicker/res/values-ja/core_strings.xml
index be41d8fbf..1ab868629 100644
--- a/photopicker/res/values-ja/core_strings.xml
+++ b/photopicker/res/values-ja/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">""</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="TIME">%2$s</xliff:g><xliff:g id="ITEM_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"<xliff:g id="TIME">%1$s</xliff:g>: <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">""</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">""</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">""</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"<xliff:g id="COUNT">%1$s</xliff:g> "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-ja/feature_preview_strings.xml b/photopicker/res/values-ja/feature_preview_strings.xml
index 8dec1c326..bf0b1f5dd 100644
--- a/photopicker/res/values-ja/feature_preview_strings.xml
+++ b/photopicker/res/values-ja/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"<xliff:g id="COUNT">(%1$s)</xliff:g> "</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"<xliff:g id="COUNT">%1$s</xliff:g> "</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"<xliff:g id="COUNT">(%1$s)</xliff:g> "</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"<xliff:g id="COUNT">%1$s</xliff:g> "</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">""</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">""</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">""</string>
diff --git a/photopicker/res/values-ja/feature_profiles_strings.xml b/photopicker/res/values-ja/feature_profiles_strings.xml
index c6f6d0663..6e2e757c9 100644
--- a/photopicker/res/values-ja/feature_profiles_strings.xml
+++ b/photopicker/res/values-ja/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">" "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">""</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g><xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>"</string>
diff --git a/photopicker/res/values-ja/feature_search_strings.xml b/photopicker/res/values-ja/feature_search_strings.xml
index 14cf2f066..6ff343663 100644
--- a/photopicker/res/values-ja/feature_search_strings.xml
+++ b/photopicker/res/values-ja/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">""</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">""</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">""</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">""</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">""</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">""</string>
 </resources>
diff --git a/photopicker/res/values-ka/core_strings.xml b/photopicker/res/values-ka/core_strings.xml
index 525393471..af192c112 100644
--- a/photopicker/res/values-ka/core_strings.xml
+++ b/photopicker/res/values-ka/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>  <xliff:g id="TIME">%2$s</xliff:g>-"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"  : <xliff:g id="TIME">%1$s</xliff:g>, : <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"  "</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">" "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"  "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">" <xliff:g id="COUNT">%1$s</xliff:g>   "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">" <xliff:g id="COUNT">%1$s</xliff:g>- "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-ka/feature_preview_strings.xml b/photopicker/res/values-ka/feature_preview_strings.xml
index c6ef5143e..cf6479403 100644
--- a/photopicker/res/values-ka/feature_preview_strings.xml
+++ b/photopicker/res/values-ka/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"<xliff:g id="COUNT">(%1$s)</xliff:g>- "</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"<xliff:g id="COUNT">(%1$s)</xliff:g>-  "</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"   (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">""</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"   "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">" -   "</string>
diff --git a/photopicker/res/values-ka/feature_profiles_strings.xml b/photopicker/res/values-ka/feature_profiles_strings.xml
index 267051b23..eadd04ccc 100644
--- a/photopicker/res/values-ka/feature_profiles_strings.xml
+++ b/photopicker/res/values-ka/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"  "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">" <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>-  "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"   "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>-    <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>-    "</string>
diff --git a/photopicker/res/values-ka/feature_search_strings.xml b/photopicker/res/values-ka/feature_search_strings.xml
index af601ec18..f84d2f8b2 100644
--- a/photopicker/res/values-ka/feature_search_strings.xml
+++ b/photopicker/res/values-ka/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"  "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"   "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">" ."</string>
 </resources>
diff --git a/photopicker/res/values-kk/core_strings.xml b/photopicker/res/values-kk/core_strings.xml
index 9f61a356a..d9306f052 100644
--- a/photopicker/res/values-kk/core_strings.xml
+++ b/photopicker/res/values-kk/core_strings.xml
@@ -19,11 +19,20 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Me"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>  : <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"  : <xliff:g id="TIME">%1$s</xliff:g>, : <xliff:g id="DURATION">%2$s</xliff:g>."</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">""</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">" "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"   "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g>    ."</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"<xliff:g id="COUNT">%1$s</xliff:g>   ."</string>
-    <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Photos"</string>
+    <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"A"</string>
     <string name="photopicker_photos_empty_state_title" msgid="7018770515431149456">"  "</string>
     <string name="photopicker_photos_empty_state_body" msgid="5959729294856198675">"   ."</string>
diff --git a/photopicker/res/values-kk/feature_preview_strings.xml b/photopicker/res/values-kk/feature_preview_strings.xml
index 2fbfb3e30..d6694ecd3 100644
--- a/photopicker/res/values-kk/feature_preview_strings.xml
+++ b/photopicker/res/values-kk/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">" <xliff:g id="COUNT">(%1$s)</xliff:g> "</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">" (<xliff:g id="COUNT">%1$s</xliff:g>) "</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">" <xliff:g id="COUNT">(%1$s)</xliff:g>   "</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">" (<xliff:g id="COUNT">%1$s</xliff:g>)  "</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"  "</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"    "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"  ,   ."</string>
diff --git a/photopicker/res/values-kk/feature_profiles_strings.xml b/photopicker/res/values-kk/feature_profiles_strings.xml
index 62e17e78f..47b959dc1 100644
--- a/photopicker/res/values-kk/feature_profiles_strings.xml
+++ b/photopicker/res/values-kk/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"  "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">" : <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>   "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">" "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>    <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>  ,   ."</string>
diff --git a/photopicker/res/values-kk/feature_search_strings.xml b/photopicker/res/values-kk/feature_search_strings.xml
index c6a0b8239..bb77223e9 100644
--- a/photopicker/res/values-kk/feature_search_strings.xml
+++ b/photopicker/res/values-kk/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">" "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">" "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">" "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"   ."</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  ."</string>
 </resources>
diff --git a/photopicker/res/values-km/core_strings.xml b/photopicker/res/values-km/core_strings.xml
index 08cbbcb80..06d1840f9 100644
--- a/photopicker/res/values-km/core_strings.xml
+++ b/photopicker/res/values-km/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">" "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">" <xliff:g id="TIME">%1$s</xliff:g>  <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">""</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">""</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">""</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">""</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"  <xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">" <xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-km/feature_preview_strings.xml b/photopicker/res/values-km/feature_preview_strings.xml
index 96e4060bd..97e11a6fc 100644
--- a/photopicker/res/values-km/feature_preview_strings.xml
+++ b/photopicker/res/values-km/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">" <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">" (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">" <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">" (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">""</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">""</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">" "</string>
diff --git a/photopicker/res/values-km/feature_profiles_strings.xml b/photopicker/res/values-km/feature_profiles_strings.xml
index 4c1f97c62..69240428d 100644
--- a/photopicker/res/values-km/feature_profiles_strings.xml
+++ b/photopicker/res/values-km/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">""</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">" <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">""</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g> <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> "</string>
diff --git a/photopicker/res/values-km/feature_search_strings.xml b/photopicker/res/values-km/feature_search_strings.xml
index f94349eff..977d13f42 100644
--- a/photopicker/res/values-km/feature_search_strings.xml
+++ b/photopicker/res/values-km/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">""</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">""</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">""</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">""</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">""</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">""</string>
 </resources>
diff --git a/photopicker/res/values-kn/core_strings.xml b/photopicker/res/values-kn/core_strings.xml
index 228f0806c..519b3c72a 100644
--- a/photopicker/res/values-kn/core_strings.xml
+++ b/photopicker/res/values-kn/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>  <xliff:g id="TIME">%2$s</xliff:g>  "</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"<xliff:g id="DURATION">%2$s</xliff:g>   <xliff:g id="TIME">%1$s</xliff:g>  "</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">""</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">" "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"  "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g>    "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"<xliff:g id="COUNT">%1$s</xliff:g>  "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-kn/feature_preview_strings.xml b/photopicker/res/values-kn/feature_preview_strings.xml
index f72763e16..78701c441 100644
--- a/photopicker/res/values-kn/feature_preview_strings.xml
+++ b/photopicker/res/values-kn/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">" <xliff:g id="COUNT">(%1$s)</xliff:g>  "</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"   <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"   (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">""</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"   "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"       "</string>
diff --git a/photopicker/res/values-kn/feature_profiles_strings.xml b/photopicker/res/values-kn/feature_profiles_strings.xml
index bc5aa8134..f9378d6ce 100644
--- a/photopicker/res/values-kn/feature_profiles_strings.xml
+++ b/photopicker/res/values-kn/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"  "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>  "</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>  "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"  "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>  ,  <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>      "</string>
diff --git a/photopicker/res/values-kn/feature_search_strings.xml b/photopicker/res/values-kn/feature_search_strings.xml
index e24a4348c..b9e4a7342 100644
--- a/photopicker/res/values-kn/feature_search_strings.xml
+++ b/photopicker/res/values-kn/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"  "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"    "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"   ."</string>
 </resources>
diff --git a/photopicker/res/values-ko/core_strings.xml b/photopicker/res/values-ko/core_strings.xml
index 83d0d6d3b..f6677d2cd 100644
--- a/photopicker/res/values-ko/core_strings.xml
+++ b/photopicker/res/values-ko/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="TIME">%2$s</xliff:g>  <xliff:g id="ITEM_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"<xliff:g id="TIME">%1$s</xliff:g> <xliff:g id="DURATION">%2$s</xliff:g>   "</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">" "</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">" "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"  "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"   <xliff:g id="COUNT">%1$s</xliff:g> "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">" <xliff:g id="COUNT">%1$s</xliff:g>  "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-ko/feature_preview_strings.xml b/photopicker/res/values-ko/feature_preview_strings.xml
index b8f22e4bf..28fe75cee 100644
--- a/photopicker/res/values-ko/feature_preview_strings.xml
+++ b/photopicker/res/values-ko/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"<xliff:g id="COUNT">(%1$s)</xliff:g>  "</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">" (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"<xliff:g id="COUNT">(%1$s)</xliff:g>   "</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">""</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"    "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"      "</string>
diff --git a/photopicker/res/values-ko/feature_profiles_strings.xml b/photopicker/res/values-ko/feature_profiles_strings.xml
index 2183f6845..791b4069a 100644
--- a/photopicker/res/values-ko/feature_profiles_strings.xml
+++ b/photopicker/res/values-ko/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"  "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> "</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>  "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">" "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>   <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>      ."</string>
diff --git a/photopicker/res/values-ko/feature_search_strings.xml b/photopicker/res/values-ko/feature_search_strings.xml
index 9b848330d..ba8e91a61 100644
--- a/photopicker/res/values-ko/feature_search_strings.xml
+++ b/photopicker/res/values-ko/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"  "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"   ."</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  ."</string>
 </resources>
diff --git a/photopicker/res/values-ky/core_strings.xml b/photopicker/res/values-ky/core_strings.xml
index dfd960a28..05d8823b1 100644
--- a/photopicker/res/values-ky/core_strings.xml
+++ b/photopicker/res/values-ky/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="TIME">%2$s</xliff:g>  <xliff:g id="ITEM_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">" <xliff:g id="TIME">%1$s</xliff:g>  <xliff:g id="DURATION">%2$s</xliff:g>  "</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">" "</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">" "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"  "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g>    "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"<xliff:g id="COUNT">%1$s</xliff:g>  "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-ky/feature_preview_strings.xml b/photopicker/res/values-ky/feature_preview_strings.xml
index cafbe9e8d..9edcbb843 100644
--- a/photopicker/res/values-ky/feature_preview_strings.xml
+++ b/photopicker/res/values-ky/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"<xliff:g id="COUNT">(%1$s)</xliff:g>  "</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"<xliff:g id="COUNT">(%1$s)</xliff:g>   "</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"   (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"  "</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"    "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"  ,  "</string>
diff --git a/photopicker/res/values-ky/feature_profiles_strings.xml b/photopicker/res/values-ky/feature_profiles_strings.xml
index 26c9d43c9..d7878fef6 100644
--- a/photopicker/res/values-ky/feature_profiles_strings.xml
+++ b/photopicker/res/values-ky/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"  "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> "</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>  "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"  "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>    <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>  ,  "</string>
diff --git a/photopicker/res/values-ky/feature_search_strings.xml b/photopicker/res/values-ky/feature_search_strings.xml
index 6551789d6..18a01a912 100644
--- a/photopicker/res/values-ky/feature_search_strings.xml
+++ b/photopicker/res/values-ky/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">" "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">" "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">" "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"   "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"   "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">" ."</string>
 </resources>
diff --git a/photopicker/res/values-lo/core_strings.xml b/photopicker/res/values-lo/core_strings.xml
index 5ed3fdd28..1d56fd551 100644
--- a/photopicker/res/values-lo/core_strings.xml
+++ b/photopicker/res/values-lo/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>  <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">" <xliff:g id="TIME">%1$s</xliff:g>  <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">""</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">""</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">""</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">""</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">" <xliff:g id="COUNT">%1$s</xliff:g>   "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">" <xliff:g id="COUNT">%1$s</xliff:g> "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-lo/feature_preview_strings.xml b/photopicker/res/values-lo/feature_preview_strings.xml
index 19571454d..8fc826f63 100644
--- a/photopicker/res/values-lo/feature_preview_strings.xml
+++ b/photopicker/res/values-lo/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">" <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">" (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">" <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">" (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">""</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">""</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">""</string>
diff --git a/photopicker/res/values-lo/feature_profiles_strings.xml b/photopicker/res/values-lo/feature_profiles_strings.xml
index 0167362ba..29a6b5176 100644
--- a/photopicker/res/values-lo/feature_profiles_strings.xml
+++ b/photopicker/res/values-lo/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">""</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">" <xliff:g id="PROFILE_NAME">%1$s</xliff:g> "</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">" <xliff:g id="PROFILE_NAME">%1$s</xliff:g> "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">""</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">" <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>,  <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> "</string>
diff --git a/photopicker/res/values-lo/feature_search_strings.xml b/photopicker/res/values-lo/feature_search_strings.xml
index f9ae28a52..ab12d63aa 100644
--- a/photopicker/res/values-lo/feature_search_strings.xml
+++ b/photopicker/res/values-lo/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">""</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">""</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">""</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">""</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">""</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"."</string>
 </resources>
diff --git a/photopicker/res/values-lt/core_strings.xml b/photopicker/res/values-lt/core_strings.xml
index a3ae010ec..06ceb2d57 100644
--- a/photopicker/res/values-lt/core_strings.xml
+++ b/photopicker/res/values-lt/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Nuotraukos ir vaizdo raai"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Medija"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> ufiksuota <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Vaizdo raas sukurtas <xliff:g id="TIME">%1$s</xliff:g>, trukm: <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Nuotrauka"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Judanioji nuotrauka"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Pasirinkta"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Nepasirinkta"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Pasirinkti"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Panaikinti pasirinkim"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Atlikta"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Panaikinti visus pasirinkimus"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"Pasirinkta tiek nuotrauk ar vaizdo ra: <xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Pasirinkite iki <xliff:g id="COUNT">%1$s</xliff:g> elemen."</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Nuotraukos"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albumai"</string>
diff --git a/photopicker/res/values-lt/feature_preview_strings.xml b/photopicker/res/values-lt/feature_preview_strings.xml
index a6bc930c9..f596811c2 100644
--- a/photopicker/res/values-lt/feature_preview_strings.xml
+++ b/photopicker/res/values-lt/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Pasirinkti visk <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Pasirinkti visk (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Pasirinkti"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Ataukti vis <xliff:g id="COUNT">(%1$s)</xliff:g> pasirinkim"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Ataukti vis (<xliff:g id="COUNT">%1$s</xliff:g>) pasirinkim"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Perirti"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Paleidiant vaizdo ra kilo problema"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Patikrinkite interneto ry ir bandykite dar kart"</string>
diff --git a/photopicker/res/values-lt/feature_profiles_strings.xml b/photopicker/res/values-lt/feature_profiles_strings.xml
index 9b973fce0..364231dcf 100644
--- a/photopicker/res/values-lt/feature_profiles_strings.xml
+++ b/photopicker/res/values-lt/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Darbo"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Kita"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Perjungti naudotojo profil"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Pasirinkta: <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Profilio <xliff:g id="PROFILE_NAME">%1$s</xliff:g> programos pristabdytos"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Ublokavo js administratorius"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Jei norite atidaryti profilio <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g> nuotraukas, junkite profilio <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> programas ir bandykite dar kart"</string>
diff --git a/photopicker/res/values-lt/feature_search_strings.xml b/photopicker/res/values-lt/feature_search_strings.xml
index e94155794..2333566c5 100644
--- a/photopicker/res/values-lt/feature_search_strings.xml
+++ b/photopicker/res/values-lt/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Paieka"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Iekokite nuotraukose"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Iekokite nuotraukose"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Iekokite savo vaizdo ra"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Nerasta joki rezultat"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Pabandykite iekoti panai odi"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Pasilymai"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Paieka ijungta."</string>
 </resources>
diff --git a/photopicker/res/values-lv/core_strings.xml b/photopicker/res/values-lv/core_strings.xml
index 507d712b1..0bd82f772 100644
--- a/photopicker/res/values-lv/core_strings.xml
+++ b/photopicker/res/values-lv/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Fotoattli un videoklipi"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Multivides vienums"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>; uzemanas laiks: <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Videoklipa uzemanas laiks: <xliff:g id="TIME">%1$s</xliff:g>; ilgums: <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Fotoattls"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Kustbas fotoattls"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Atlasts"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Nav atlasts"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Atlast"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Noemt atlasi"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Gatavs"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Noemt visu atlasi"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"Atlasto fotoattlu vai videoklipu skaits ir <xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Varat atlast ne vairk k <xliff:g id="COUNT">%1$s</xliff:g>vienumu(-us)."</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Fotoattli"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albumi"</string>
diff --git a/photopicker/res/values-lv/feature_preview_strings.xml b/photopicker/res/values-lv/feature_preview_strings.xml
index e530169dd..432d8670f 100644
--- a/photopicker/res/values-lv/feature_preview_strings.xml
+++ b/photopicker/res/values-lv/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Atlast visu(<xliff:g id="COUNT">(%1$s)</xliff:g>)"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Atlast visu (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Atlast"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Noemt visu atlasi (<xliff:g id="COUNT">(%1$s)</xliff:g>)"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Noemt visu atlasi (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Priekskatt"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Atskaojot videoklipu, rads kda"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Prbaudiet interneta savienojumu un miniet vlreiz."</string>
diff --git a/photopicker/res/values-lv/feature_profiles_strings.xml b/photopicker/res/values-lv/feature_profiles_strings.xml
index 0d1f227b8..e2ec58116 100644
--- a/photopicker/res/values-lv/feature_profiles_strings.xml
+++ b/photopicker/res/values-lv/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Darba"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Cits"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Maint lietotja profilu"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Atlastais profils: <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"da profila lietotu darbba ir prtraukta: <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Blojis jsu administrators"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Lai atvrtu profila <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g> fotoattlus, iesldziet profila <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> lietotnes un pc tam miniet vlreiz."</string>
diff --git a/photopicker/res/values-lv/feature_search_strings.xml b/photopicker/res/values-lv/feature_search_strings.xml
index 036768e34..c2fc5b1ce 100644
--- a/photopicker/res/values-lv/feature_search_strings.xml
+++ b/photopicker/res/values-lv/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Meklt"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Mekljiet savus fotoattlus"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Meklt savos fotoattlos"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Meklt savos video"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Netika atrasti rezultti"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Miniet meklt ldzgus vrdus"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Ieteikumi"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Meklana atspjota."</string>
 </resources>
diff --git a/photopicker/res/values-mk/core_strings.xml b/photopicker/res/values-mk/core_strings.xml
index f37ca0fe0..c16ef7fce 100644
--- a/photopicker/res/values-mk/core_strings.xml
+++ b/photopicker/res/values-mk/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">" "</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>   <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"    <xliff:g id="TIME">%1$s</xliff:g>    <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"  "</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"  "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"    "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"  <xliff:g id="COUNT">%1$s</xliff:g>   "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"  <xliff:g id="COUNT">%1$s</xliff:g> "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-mk/feature_preview_strings.xml b/photopicker/res/values-mk/feature_preview_strings.xml
index 847417d85..fadd2737b 100644
--- a/photopicker/res/values-mk/feature_preview_strings.xml
+++ b/photopicker/res/values-mk/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"   <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"   (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"     <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"     (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">""</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"    "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"  -    "</string>
diff --git a/photopicker/res/values-mk/feature_profiles_strings.xml b/photopicker/res/values-mk/feature_profiles_strings.xml
index 9b3a2f67b..b74219eb1 100644
--- a/photopicker/res/values-mk/feature_profiles_strings.xml
+++ b/photopicker/res/values-mk/feature_profiles_strings.xml
@@ -17,10 +17,11 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_profile_primary_label" msgid="4757455689901820680">""</string>
+    <string name="photopicker_profile_primary_label" msgid="4757455689901820680">""</string>
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"   "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">": <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"   <xliff:g id="PROFILE_NAME">%1$s</xliff:g>  "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"  "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"       <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>,      <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>,    "</string>
diff --git a/photopicker/res/values-mk/feature_search_strings.xml b/photopicker/res/values-mk/feature_search_strings.xml
index 6a532818c..07ef55612 100644
--- a/photopicker/res/values-mk/feature_search_strings.xml
+++ b/photopicker/res/values-mk/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"  "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">" "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"   "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"     "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  ."</string>
 </resources>
diff --git a/photopicker/res/values-ml/core_strings.xml b/photopicker/res/values-ml/core_strings.xml
index e3f5d55c0..eb3b98217 100644
--- a/photopicker/res/values-ml/core_strings.xml
+++ b/photopicker/res/values-ml/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">" "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="TIME">%2$s</xliff:g>-  <xliff:g id="ITEM_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"<xliff:g id="TIME">%1$s</xliff:g>-  <xliff:g id="DURATION">%2$s</xliff:g>  "</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">""</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">" "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"  "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g>   "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"<xliff:g id="COUNT">%1$s</xliff:g>   "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-ml/feature_preview_strings.xml b/photopicker/res/values-ml/feature_preview_strings.xml
index 11d0254c8..30bc8f024 100644
--- a/photopicker/res/values-ml/feature_preview_strings.xml
+++ b/photopicker/res/values-ml/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"  (<xliff:g id="COUNT">(%1$s)</xliff:g> )"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"(<xliff:g id="COUNT">%1$s</xliff:g>)  "</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"  (<xliff:g id="COUNT">(%1$s)</xliff:g> )"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"(<xliff:g id="COUNT">%1$s</xliff:g>)   "</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">" "</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"   "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"     "</string>
diff --git a/photopicker/res/values-ml/feature_profiles_strings.xml b/photopicker/res/values-ml/feature_profiles_strings.xml
index 4ef67b028..23ad6209e 100644
--- a/photopicker/res/values-ml/feature_profiles_strings.xml
+++ b/photopicker/res/values-ml/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"  "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> "</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>   "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"   "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>  ,  <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>     "</string>
diff --git a/photopicker/res/values-ml/feature_search_strings.xml b/photopicker/res/values-ml/feature_search_strings.xml
index ede4aef9f..8720a872c 100644
--- a/photopicker/res/values-ml/feature_search_strings.xml
+++ b/photopicker/res/values-ml/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"  "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">" "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"  "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">" ."</string>
 </resources>
diff --git a/photopicker/res/values-mn/core_strings.xml b/photopicker/res/values-mn/core_strings.xml
index 5fca1d93e..8672cda66 100644
--- a/photopicker/res/values-mn/core_strings.xml
+++ b/photopicker/res/values-mn/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>- <xliff:g id="TIME">%2$s</xliff:g>- "</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"<xliff:g id="TIME">%1$s</xliff:g>- , <xliff:g id="DURATION">%2$s</xliff:g>-   "</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">""</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">" "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"  "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> ,  "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"<xliff:g id="COUNT">%1$s</xliff:g>    "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-mn/feature_preview_strings.xml b/photopicker/res/values-mn/feature_preview_strings.xml
index 56ef8c645..664aa7663 100644
--- a/photopicker/res/values-mn/feature_preview_strings.xml
+++ b/photopicker/res/values-mn/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">" <xliff:g id="COUNT">(%1$s)</xliff:g>  "</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">" <xliff:g id="COUNT">(%1$s)</xliff:g>  "</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"   (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">" "</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"   "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"  ,   "</string>
diff --git a/photopicker/res/values-mn/feature_profiles_strings.xml b/photopicker/res/values-mn/feature_profiles_strings.xml
index e286b4e76..52568cf9c 100644
--- a/photopicker/res/values-mn/feature_profiles_strings.xml
+++ b/photopicker/res/values-mn/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"  "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>- "</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>-   "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"  "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>-    <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>-  ,     "</string>
diff --git a/photopicker/res/values-mn/feature_search_strings.xml b/photopicker/res/values-mn/feature_search_strings.xml
index bb6822ed8..cc13ebcc7 100644
--- a/photopicker/res/values-mn/feature_search_strings.xml
+++ b/photopicker/res/values-mn/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">" "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">" "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">" "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">" "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"    "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  ."</string>
 </resources>
diff --git a/photopicker/res/values-mr/core_strings.xml b/photopicker/res/values-mr/core_strings.xml
index 260e6e638..dd48bf4cd 100644
--- a/photopicker/res/values-mr/core_strings.xml
+++ b/photopicker/res/values-mr/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> <xliff:g id="TIME">%2$s</xliff:g>  "</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"<xliff:g id="TIME">%1$s</xliff:g>   <xliff:g id="DURATION">%2$s</xliff:g>  "</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">" "</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">" "</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"  "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">" "</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"   "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"    <xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">" <xliff:g id="COUNT">%1$s</xliff:g>  "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-mr/feature_preview_strings.xml b/photopicker/res/values-mr/feature_preview_strings.xml
index bfdc55685..4109c4a40 100644
--- a/photopicker/res/values-mr/feature_preview_strings.xml
+++ b/photopicker/res/values-mr/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"  <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"    <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"    (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">" "</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"    "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"       "</string>
diff --git a/photopicker/res/values-mr/feature_profiles_strings.xml b/photopicker/res/values-mr/feature_profiles_strings.xml
index 05fd691dc..0a1356a93 100644
--- a/photopicker/res/values-mr/feature_profiles_strings.xml
+++ b/photopicker/res/values-mr/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"   "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> "</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>   "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"    "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>    ,  <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>   ,    "</string>
diff --git a/photopicker/res/values-mr/feature_search_strings.xml b/photopicker/res/values-mr/feature_search_strings.xml
index e9262c214..e0969983f 100644
--- a/photopicker/res/values-mr/feature_search_strings.xml
+++ b/photopicker/res/values-mr/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"  "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"   "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"    "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"   ."</string>
 </resources>
diff --git a/photopicker/res/values-ms/core_strings.xml b/photopicker/res/values-ms/core_strings.xml
index 3b3fda3d7..794e6074e 100644
--- a/photopicker/res/values-ms/core_strings.xml
+++ b/photopicker/res/values-ms/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Foto &amp; video"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Media"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> diambil pada <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Video diambil pada <xliff:g id="TIME">%1$s</xliff:g> dengan tempoh <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Foto"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Foto dengan Gerakan"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Dipilih"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Tidak dipilih"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Pilih"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Nyahpilih"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Selesai"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Nyahpilih semua"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> foto atau video dipilih"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Pilih hingga <xliff:g id="COUNT">%1$s</xliff:g> item"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Photos"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Album"</string>
diff --git a/photopicker/res/values-ms/feature_preview_strings.xml b/photopicker/res/values-ms/feature_preview_strings.xml
index a6dbc9502..4c6fb80de 100644
--- a/photopicker/res/values-ms/feature_preview_strings.xml
+++ b/photopicker/res/values-ms/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Pilih semua <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Pilih semua (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Pilih"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Nyahpilih semua <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Nyahpilih semua (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Pratonton"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Berlaku masalah semasa memainkan video"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Semak sambungan Internet anda, kemudian cuba lagi"</string>
diff --git a/photopicker/res/values-ms/feature_profiles_strings.xml b/photopicker/res/values-ms/feature_profiles_strings.xml
index 6db0e1fa5..482ba5a5a 100644
--- a/photopicker/res/values-ms/feature_profiles_strings.xml
+++ b/photopicker/res/values-ms/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Kerja"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Lain-lain"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Tukar Profil Pengguna"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> dipilih"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Apl <xliff:g id="PROFILE_NAME">%1$s</xliff:g> dijeda"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Disekat oleh pentadbir anda"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Untuk membuka foto <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>, hidupkan apl <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> anda, kemudian cuba lagi"</string>
diff --git a/photopicker/res/values-ms/feature_search_strings.xml b/photopicker/res/values-ms/feature_search_strings.xml
index 93ea2731d..9f3142b88 100644
--- a/photopicker/res/values-ms/feature_search_strings.xml
+++ b/photopicker/res/values-ms/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Carian"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Cari foto anda"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Cari foto anda"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Cari video anda"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Tiada hasil carian ditemukan"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Cuba cari perkataan yang serupa"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Cadangan"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Carian dilumpuhkan."</string>
 </resources>
diff --git a/photopicker/res/values-my/core_strings.xml b/photopicker/res/values-my/core_strings.xml
index f5841fdfa..da61ae561 100644
--- a/photopicker/res/values-my/core_strings.xml
+++ b/photopicker/res/values-my/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">" "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="TIME">%2$s</xliff:g>   <xliff:g id="ITEM_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">" <xliff:g id="TIME">%1$s</xliff:g>  <xliff:g id="DURATION">%2$s</xliff:g>  "</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">""</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">""</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">" "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"/ <xliff:g id="COUNT">%1$s</xliff:g>  "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">" <xliff:g id="COUNT">%1$s</xliff:g>  "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-my/feature_preview_strings.xml b/photopicker/res/values-my/feature_preview_strings.xml
index 6a4f28a49..b9d3b81da 100644
--- a/photopicker/res/values-my/feature_preview_strings.xml
+++ b/photopicker/res/values-my/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"<xliff:g id="COUNT">(%1$s)</xliff:g>  "</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">" (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"<xliff:g id="COUNT">(%1$s)</xliff:g>  "</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">" (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">""</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">" "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"  "</string>
diff --git a/photopicker/res/values-my/feature_profiles_strings.xml b/photopicker/res/values-my/feature_profiles_strings.xml
index c169dcf5a..7cf4e3d6b 100644
--- a/photopicker/res/values-my/feature_profiles_strings.xml
+++ b/photopicker/res/values-my/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">" "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> "</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>  "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">" "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>    <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>   "</string>
diff --git a/photopicker/res/values-my/feature_search_strings.xml b/photopicker/res/values-my/feature_search_strings.xml
index 95b4cdf15..2c2057591 100644
--- a/photopicker/res/values-my/feature_search_strings.xml
+++ b/photopicker/res/values-my/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">" "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">" "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">" "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">""</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">" "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">" "</string>
 </resources>
diff --git a/photopicker/res/values-nb/core_strings.xml b/photopicker/res/values-nb/core_strings.xml
index 0b5b5e0e8..5c06dc1ae 100644
--- a/photopicker/res/values-nb/core_strings.xml
+++ b/photopicker/res/values-nb/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Bilder og videoer"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Medieinnhold"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>  tatt <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Videoen ble spilt inn <xliff:g id="TIME">%1$s</xliff:g> med varigheten <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Bilde"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Levende bilde"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Valgt"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Ikke valgt"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Velg"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Fjern merkingen"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Ferdig"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Fjern alle valg"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g>bilder eller videoer er valgt"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Velg opptil <xliff:g id="COUNT">%1$s</xliff:g>elementer"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Bilder"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Album"</string>
diff --git a/photopicker/res/values-nb/feature_preview_strings.xml b/photopicker/res/values-nb/feature_preview_strings.xml
index 0b1272dd8..34991f69b 100644
--- a/photopicker/res/values-nb/feature_preview_strings.xml
+++ b/photopicker/res/values-nb/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Merk av alle <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Merk alle (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Velg"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Fjern merkingen av alle <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Fjern merkingen av alle (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Se forhndsvisning"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Problem med avspilling av videoen"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Sjekk internettilkoblingen og prv p nytt"</string>
diff --git a/photopicker/res/values-nb/feature_profiles_strings.xml b/photopicker/res/values-nb/feature_profiles_strings.xml
index f791e98c2..5bf9a4314 100644
--- a/photopicker/res/values-nb/feature_profiles_strings.xml
+++ b/photopicker/res/values-nb/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Jobb"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Annet"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Bytt brukerprofil"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Valgte <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>-appene er satt p pause"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Blokkert av administratoren din"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"For  pne <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>-bilder, sl p <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>-appene og prv p nytt"</string>
diff --git a/photopicker/res/values-nb/feature_search_strings.xml b/photopicker/res/values-nb/feature_search_strings.xml
index 8785185bf..ff80a3ea1 100644
--- a/photopicker/res/values-nb/feature_search_strings.xml
+++ b/photopicker/res/values-nb/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Sk"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Sk i bildene dine"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Sk i bildene dine"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Sk i videoene dine"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Fant ingen resultater"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Prv  ske etter lignende ord"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Forslag"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Skefunksjonen er sltt av."</string>
 </resources>
diff --git a/photopicker/res/values-ne/core_strings.xml b/photopicker/res/values-ne/core_strings.xml
index d1a06020b..477090a60 100644
--- a/photopicker/res/values-ne/core_strings.xml
+++ b/photopicker/res/values-ne/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="TIME">%2$s</xliff:g>   <xliff:g id="ITEM_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"<xliff:g id="TIME">%1$s</xliff:g>   <xliff:g id="DURATION">%2$s</xliff:g>  "</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">" "</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"  "</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">" "</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"  "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">" "</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"   "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g>       "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">" <xliff:g id="COUNT">%1$s</xliff:g>    "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-ne/feature_preview_strings.xml b/photopicker/res/values-ne/feature_preview_strings.xml
index 95c7a45de..b5a0d7ca6 100644
--- a/photopicker/res/values-ne/feature_preview_strings.xml
+++ b/photopicker/res/values-ne/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">" <xliff:g id="COUNT">(%1$s)</xliff:g>   "</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">" (<xliff:g id="COUNT">%1$s</xliff:g>)  "</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">" "</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">" <xliff:g id="COUNT">(%1$s)</xliff:g>    "</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">" (<xliff:g id="COUNT">%1$s</xliff:g>)    "</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">" "</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"    "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"      "</string>
diff --git a/photopicker/res/values-ne/feature_profiles_strings.xml b/photopicker/res/values-ne/feature_profiles_strings.xml
index 9d3003384..e6a714d65 100644
--- a/photopicker/res/values-ne/feature_profiles_strings.xml
+++ b/photopicker/res/values-ne/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"  "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>   "</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>    "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"    "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>     <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>        "</string>
diff --git a/photopicker/res/values-ne/feature_search_strings.xml b/photopicker/res/values-ne/feature_search_strings.xml
index d9be84b11..dd8c0b030 100644
--- a/photopicker/res/values-ne/feature_search_strings.xml
+++ b/photopicker/res/values-ne/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"  "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"   "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"   "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"     "</string>
 </resources>
diff --git a/photopicker/res/values-nl/core_strings.xml b/photopicker/res/values-nl/core_strings.xml
index def2182c4..fb4a07ea4 100644
--- a/photopicker/res/values-nl/core_strings.xml
+++ b/photopicker/res/values-nl/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Foto\'s en video\'s"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Media"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> gemaakt op <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Video opgenomen op <xliff:g id="TIME">%1$s</xliff:g> met een duur van <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Foto"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"Gif"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Bewegingsfoto"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Geselecteerd"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Niet geselecteerd"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Selecteren"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Deselecteren"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Klaar"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Alles deselecteren"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> foto\'s of video\'s geselecteerd"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Selecteer maximaal <xliff:g id="COUNT">%1$s</xliff:g> items"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Foto\'s"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albums"</string>
diff --git a/photopicker/res/values-nl/feature_preview_strings.xml b/photopicker/res/values-nl/feature_preview_strings.xml
index 1f9bdd1a9..90561be79 100644
--- a/photopicker/res/values-nl/feature_preview_strings.xml
+++ b/photopicker/res/values-nl/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Alle <xliff:g id="COUNT">(%1$s)</xliff:g> selecteren"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Alles selecteren (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Selecteren"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Alles deselecteren <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Alles deselecteren (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Voorbeeld"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Probleem bij video afspelen"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Check de internetverbinding en probeer het opnieuw"</string>
diff --git a/photopicker/res/values-nl/feature_profiles_strings.xml b/photopicker/res/values-nl/feature_profiles_strings.xml
index 261120cfe..d12ab2dc0 100644
--- a/photopicker/res/values-nl/feature_profiles_strings.xml
+++ b/photopicker/res/values-nl/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Werk"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Anders"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Gebruikersprofiel wisselen"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> geselecteerd"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Apps in je <xliff:g id="PROFILE_NAME">%1$s</xliff:g>-profiel zijn gepauzeerd"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Geblokkeerd door je beheerder"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Als je foto\'s uit je <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>-profiel wilt openen, zet je de apps in je <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>-profiel aan en probeer je het opnieuw"</string>
diff --git a/photopicker/res/values-nl/feature_search_strings.xml b/photopicker/res/values-nl/feature_search_strings.xml
index 1759edd13..4a21667cc 100644
--- a/photopicker/res/values-nl/feature_search_strings.xml
+++ b/photopicker/res/values-nl/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Zoeken"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Doorzoek je foto\'s"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Doorzoek je foto\'s"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Doorzoek je video\'s"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Geen resultaten gevonden"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Zoek naar vergelijkbare woorden"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Suggesties"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Zoekfunctie staat uit"</string>
 </resources>
diff --git a/photopicker/res/values-or/core_strings.xml b/photopicker/res/values-or/core_strings.xml
index 0e277ecb9..c8183ce39 100644
--- a/photopicker/res/values-or/core_strings.xml
+++ b/photopicker/res/values-or/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="TIME">%2$s</xliff:g> <xliff:g id="ITEM_NAME">%1$s</xliff:g> "</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"<xliff:g id="TIME">%1$s</xliff:g> <xliff:g id="DURATION">%2$s</xliff:g>   "</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">" "</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">" "</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">" "</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">" "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"  "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g>     "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"<xliff:g id="COUNT">%1$s</xliff:g>    "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-or/feature_preview_strings.xml b/photopicker/res/values-or/feature_preview_strings.xml
index a7b32e89c..1522d5651 100644
--- a/photopicker/res/values-or/feature_preview_strings.xml
+++ b/photopicker/res/values-or/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">" <xliff:g id="COUNT">(%1$s)</xliff:g>  "</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"   (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">" "</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">" <xliff:g id="COUNT">(%1$s)</xliff:g>  "</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"   (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">""</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"   "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"       "</string>
diff --git a/photopicker/res/values-or/feature_profiles_strings.xml b/photopicker/res/values-or/feature_profiles_strings.xml
index ba817d4d1..d7b46540d 100644
--- a/photopicker/res/values-or/feature_profiles_strings.xml
+++ b/photopicker/res/values-or/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"   "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>  "</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>   "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"    "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>     <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>      "</string>
diff --git a/photopicker/res/values-or/feature_search_strings.xml b/photopicker/res/values-or/feature_search_strings.xml
index f5cfad26b..b7c035aa2 100644
--- a/photopicker/res/values-or/feature_search_strings.xml
+++ b/photopicker/res/values-or/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">" "</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"   "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"   "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"   "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"   "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"     "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  "</string>
 </resources>
diff --git a/photopicker/res/values-pa/core_strings.xml b/photopicker/res/values-pa/core_strings.xml
index 857cb462a..0e40ce35b 100644
--- a/photopicker/res/values-pa/core_strings.xml
+++ b/photopicker/res/values-pa/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> <xliff:g id="TIME">%2$s</xliff:g>   "</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"<xliff:g id="DURATION">%2$s</xliff:g>     <xliff:g id="TIME">%1$s</xliff:g>   "</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">" "</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"  "</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"- "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">" "</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">" - "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g>     "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"<xliff:g id="COUNT">%1$s</xliff:g>   "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-pa/feature_preview_strings.xml b/photopicker/res/values-pa/feature_preview_strings.xml
index 65e15aa73..141780458 100644
--- a/photopicker/res/values-pa/feature_preview_strings.xml
+++ b/photopicker/res/values-pa/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">" <xliff:g id="COUNT">(%1$s)</xliff:g> "</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">" <xliff:g id="COUNT">(%1$s)</xliff:g>   "</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"    (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"- "</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"      "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"         "</string>
diff --git a/photopicker/res/values-pa/feature_profiles_strings.xml b/photopicker/res/values-pa/feature_profiles_strings.xml
index eb39e8017..8d7ec09c0 100644
--- a/photopicker/res/values-pa/feature_profiles_strings.xml
+++ b/photopicker/res/values-pa/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">" "</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"    "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>   "</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>     "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"     "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>   ,  <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>         "</string>
diff --git a/photopicker/res/values-pa/feature_search_strings.xml b/photopicker/res/values-pa/feature_search_strings.xml
index 7787727db..0b75aae3d 100644
--- a/photopicker/res/values-pa/feature_search_strings.xml
+++ b/photopicker/res/values-pa/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"  "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"   "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"-    "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  "</string>
 </resources>
diff --git a/photopicker/res/values-pl/core_strings.xml b/photopicker/res/values-pl/core_strings.xml
index 7c175f713..d98962fb4 100644
--- a/photopicker/res/values-pl/core_strings.xml
+++ b/photopicker/res/values-pl/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Zdjcia ifilmy"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Multimedia"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>  utworzono <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Film nagrany <xliff:g id="TIME">%1$s</xliff:g>, odugoci <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Zdjcie"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Zdjcie ruchome"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Wybrano"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Nie wybrano"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Wybierz"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Odznacz"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Gotowe"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Odznacz wszystkie"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"Liczba wybranych zdj/filmw: <xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Maksymalna liczba elementw, ktre mona wybra:<xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Zdjcia"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albumy"</string>
diff --git a/photopicker/res/values-pl/feature_preview_strings.xml b/photopicker/res/values-pl/feature_preview_strings.xml
index baee957b5..1e392c181 100644
--- a/photopicker/res/values-pl/feature_preview_strings.xml
+++ b/photopicker/res/values-pl/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Zaznacz wszystkie<xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Zaznacz wszystkie (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Zaznacz"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Odznacz wszystkie<xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Odznacz wszystkie (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Podgld"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Wystpiy problemy przy odtwarzaniu filmu"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Sprawd poczenie zinternetem isprbuj ponownie"</string>
diff --git a/photopicker/res/values-pl/feature_profiles_strings.xml b/photopicker/res/values-pl/feature_profiles_strings.xml
index 55c6b5352..f69ae6e4c 100644
--- a/photopicker/res/values-pl/feature_profiles_strings.xml
+++ b/photopicker/res/values-pl/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Subowy"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Inny"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Zmie profil uytkownika"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Wybrano: <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Aplikacje wprofilu <xliff:g id="PROFILE_NAME">%1$s</xliff:g> zostay wstrzymane"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Czynno zablokowana przez administratora"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Aby otworzy zdjcia zprofilu <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>, wcz aplikacje wprofilu <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> isprbuj ponownie"</string>
diff --git a/photopicker/res/values-pl/feature_search_strings.xml b/photopicker/res/values-pl/feature_search_strings.xml
index 5a98f24bd..97f2406b4 100644
--- a/photopicker/res/values-pl/feature_search_strings.xml
+++ b/photopicker/res/values-pl/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Szukaj"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Przeszukaj swoje zdjcia"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Przeszukaj swoje zdjcia"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Przeszukaj swoje filmy"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Brak wynikw"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Sprbuj wyszuka podobne sowa"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Sugestie"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Wyszukiwanie wyczone."</string>
 </resources>
diff --git a/photopicker/res/values-pt-rBR/core_strings.xml b/photopicker/res/values-pt-rBR/core_strings.xml
index 3ed895728..671940483 100644
--- a/photopicker/res/values-pt-rBR/core_strings.xml
+++ b/photopicker/res/values-pt-rBR/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Fotos e vdeos"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Mdia"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"Item <xliff:g id="ITEM_NAME">%1$s</xliff:g> criado em <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Vdeo gravado em <xliff:g id="TIME">%1$s</xliff:g>, com <xliff:g id="DURATION">%2$s</xliff:g> de durao"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Foto"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Foto com movimento"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Selecionado"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"No selecionado"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Selecionar"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Desmarcar"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Concluir"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Desmarcar tudo"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> fotos ou vdeos selecionados"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Selecione at <xliff:g id="COUNT">%1$s</xliff:g> itens"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Fotos"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"lbuns"</string>
diff --git a/photopicker/res/values-pt-rBR/feature_preview_strings.xml b/photopicker/res/values-pt-rBR/feature_preview_strings.xml
index fa887b2e4..655fd9e4c 100644
--- a/photopicker/res/values-pt-rBR/feature_preview_strings.xml
+++ b/photopicker/res/values-pt-rBR/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Selecionar tudo (<xliff:g id="COUNT">(%1$s)</xliff:g>)"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Selecionar tudo (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Selecionar"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Desmarcar tudo <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Desmarcar tudo (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Visualizar"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Ocorreu um problema ao iniciar o vdeo"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Confira sua conexo de Internet e tente de novo"</string>
diff --git a/photopicker/res/values-pt-rBR/feature_profiles_strings.xml b/photopicker/res/values-pt-rBR/feature_profiles_strings.xml
index 0a0356915..87c770b58 100644
--- a/photopicker/res/values-pt-rBR/feature_profiles_strings.xml
+++ b/photopicker/res/values-pt-rBR/feature_profiles_strings.xml
@@ -18,13 +18,14 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_profile_primary_label" msgid="4757455689901820680">"Pessoal"</string>
-    <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Trabalho"</string>
+    <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"de trabalho"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Outro"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Mudar o perfil de usurio"</string>
-    <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Apps do perfil <xliff:g id="PROFILE_NAME">%1$s</xliff:g> esto pausados"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Perfil <xliff:g id="PROFILE_NAME">%1$s</xliff:g> selecionado"</string>
+    <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Os apps do perfil <xliff:g id="PROFILE_NAME">%1$s</xliff:g> esto pausados"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Interao bloqueada pelo administrador"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Para abrir fotos do perfil <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>, ative os apps do perfil <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> e tente de novo"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_message" msgid="7978497980448982863">"O acesso aos dados deste perfil no  permitido pelo seu administrador."</string>
     <string name="photopicker_profile_banner_switch_button_label" msgid="1652041405540769126">"Trocar"</string>
-    <string name="photopicker_profile_switch_banner_message" msgid="2969185213956642828">"Voc est no perfil <xliff:g id="CURRENT_PROFILE_NAME">%1$s</xliff:g>. Trocar para seu perfil <xliff:g id="TARGET_PROFILE_NAME">%2$s</xliff:g>?"</string>
+    <string name="photopicker_profile_switch_banner_message" msgid="2969185213956642828">"Voc est no perfil <xliff:g id="CURRENT_PROFILE_NAME">%1$s</xliff:g>. Quer trocar para seu perfil <xliff:g id="TARGET_PROFILE_NAME">%2$s</xliff:g>?"</string>
 </resources>
diff --git a/photopicker/res/values-pt-rBR/feature_search_strings.xml b/photopicker/res/values-pt-rBR/feature_search_strings.xml
index 2dfb69bc7..6b59fa098 100644
--- a/photopicker/res/values-pt-rBR/feature_search_strings.xml
+++ b/photopicker/res/values-pt-rBR/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Pesquisar"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Pesquise suas fotos"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Pesquise nas suas fotos"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Pesquise nos seus vdeos"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Nenhum resultado encontrado"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Tente pesquisar palavras semelhantes"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Sugestes"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Pesquisa desativada."</string>
 </resources>
diff --git a/photopicker/res/values-pt-rPT/core_strings.xml b/photopicker/res/values-pt-rPT/core_strings.xml
index c9dd7417e..a35f15dfa 100644
--- a/photopicker/res/values-pt-rPT/core_strings.xml
+++ b/photopicker/res/values-pt-rPT/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Fotos e vdeos"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Multimdia"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> criado(a) a <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Vdeo filmado a <xliff:g id="TIME">%1$s</xliff:g> com a durao de <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Foto"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Foto em movimento"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Selecionado"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"No selecionado"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Selecionar"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Desmarcar"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Concluir"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Desmarcar tudo"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> fotos ou vdeos selecionados"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Selecione at <xliff:g id="COUNT">%1$s</xliff:g> itens"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Fotos"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"lbuns"</string>
diff --git a/photopicker/res/values-pt-rPT/feature_preview_strings.xml b/photopicker/res/values-pt-rPT/feature_preview_strings.xml
index d4fee998e..f2152e974 100644
--- a/photopicker/res/values-pt-rPT/feature_preview_strings.xml
+++ b/photopicker/res/values-pt-rPT/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Selecionar tudo <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Selecionar tudo (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Selecionar"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Desmarcar tudo <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Desmarcar tudo (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Pr-visualizar"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Dificuldades em reproduzir o vdeo"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Verifique a ligao  Internet e tente novamente"</string>
diff --git a/photopicker/res/values-pt-rPT/feature_profiles_strings.xml b/photopicker/res/values-pt-rPT/feature_profiles_strings.xml
index dfe51c3ab..db2cf9902 100644
--- a/photopicker/res/values-pt-rPT/feature_profiles_strings.xml
+++ b/photopicker/res/values-pt-rPT/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Trabalho"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Outro"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Mudar perfil do utilizador"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Selecionou <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"As apps do perfil <xliff:g id="PROFILE_NAME">%1$s</xliff:g> esto pausadas"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Bloqueado pelo administrador"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Para abrir as fotos do perfil <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>, ative as suas apps do perfil <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> e tente novamente"</string>
diff --git a/photopicker/res/values-pt-rPT/feature_search_strings.xml b/photopicker/res/values-pt-rPT/feature_search_strings.xml
index e699cad81..c2bfdba41 100644
--- a/photopicker/res/values-pt-rPT/feature_search_strings.xml
+++ b/photopicker/res/values-pt-rPT/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Pesquisar"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Pesquisar as suas fotos"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Pesquise as suas fotos"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Pesquise os seus vdeos"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"No foram encontrados resultados"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Experimente pesquisar palavras semelhantes"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Sugestes"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Pesquisa desativada."</string>
 </resources>
diff --git a/photopicker/res/values-pt/core_strings.xml b/photopicker/res/values-pt/core_strings.xml
index 3ed895728..671940483 100644
--- a/photopicker/res/values-pt/core_strings.xml
+++ b/photopicker/res/values-pt/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Fotos e vdeos"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Mdia"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"Item <xliff:g id="ITEM_NAME">%1$s</xliff:g> criado em <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Vdeo gravado em <xliff:g id="TIME">%1$s</xliff:g>, com <xliff:g id="DURATION">%2$s</xliff:g> de durao"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Foto"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Foto com movimento"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Selecionado"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"No selecionado"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Selecionar"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Desmarcar"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Concluir"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Desmarcar tudo"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> fotos ou vdeos selecionados"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Selecione at <xliff:g id="COUNT">%1$s</xliff:g> itens"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Fotos"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"lbuns"</string>
diff --git a/photopicker/res/values-pt/feature_preview_strings.xml b/photopicker/res/values-pt/feature_preview_strings.xml
index fa887b2e4..655fd9e4c 100644
--- a/photopicker/res/values-pt/feature_preview_strings.xml
+++ b/photopicker/res/values-pt/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Selecionar tudo (<xliff:g id="COUNT">(%1$s)</xliff:g>)"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Selecionar tudo (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Selecionar"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Desmarcar tudo <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Desmarcar tudo (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Visualizar"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Ocorreu um problema ao iniciar o vdeo"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Confira sua conexo de Internet e tente de novo"</string>
diff --git a/photopicker/res/values-pt/feature_profiles_strings.xml b/photopicker/res/values-pt/feature_profiles_strings.xml
index 0a0356915..87c770b58 100644
--- a/photopicker/res/values-pt/feature_profiles_strings.xml
+++ b/photopicker/res/values-pt/feature_profiles_strings.xml
@@ -18,13 +18,14 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_profile_primary_label" msgid="4757455689901820680">"Pessoal"</string>
-    <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Trabalho"</string>
+    <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"de trabalho"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Outro"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Mudar o perfil de usurio"</string>
-    <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Apps do perfil <xliff:g id="PROFILE_NAME">%1$s</xliff:g> esto pausados"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Perfil <xliff:g id="PROFILE_NAME">%1$s</xliff:g> selecionado"</string>
+    <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Os apps do perfil <xliff:g id="PROFILE_NAME">%1$s</xliff:g> esto pausados"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Interao bloqueada pelo administrador"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Para abrir fotos do perfil <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>, ative os apps do perfil <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> e tente de novo"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_message" msgid="7978497980448982863">"O acesso aos dados deste perfil no  permitido pelo seu administrador."</string>
     <string name="photopicker_profile_banner_switch_button_label" msgid="1652041405540769126">"Trocar"</string>
-    <string name="photopicker_profile_switch_banner_message" msgid="2969185213956642828">"Voc est no perfil <xliff:g id="CURRENT_PROFILE_NAME">%1$s</xliff:g>. Trocar para seu perfil <xliff:g id="TARGET_PROFILE_NAME">%2$s</xliff:g>?"</string>
+    <string name="photopicker_profile_switch_banner_message" msgid="2969185213956642828">"Voc est no perfil <xliff:g id="CURRENT_PROFILE_NAME">%1$s</xliff:g>. Quer trocar para seu perfil <xliff:g id="TARGET_PROFILE_NAME">%2$s</xliff:g>?"</string>
 </resources>
diff --git a/photopicker/res/values-pt/feature_search_strings.xml b/photopicker/res/values-pt/feature_search_strings.xml
index 2dfb69bc7..6b59fa098 100644
--- a/photopicker/res/values-pt/feature_search_strings.xml
+++ b/photopicker/res/values-pt/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Pesquisar"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Pesquise suas fotos"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Pesquise nas suas fotos"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Pesquise nos seus vdeos"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Nenhum resultado encontrado"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Tente pesquisar palavras semelhantes"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Sugestes"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Pesquisa desativada."</string>
 </resources>
diff --git a/photopicker/res/values-ro/core_strings.xml b/photopicker/res/values-ro/core_strings.xml
index 04425409f..ca48889be 100644
--- a/photopicker/res/values-ro/core_strings.xml
+++ b/photopicker/res/values-ro/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Fotografii i videoclipuri"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Media"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"S-a creat <xliff:g id="ITEM_NAME">%1$s</xliff:g> pe <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Videoclip nregistrat pe <xliff:g id="TIME">%1$s</xliff:g> cu durata de <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Fotografie"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Fotografie animat"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Selectat"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Neselectat"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Selecteaz"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Debifeaz"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Gata"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Deselecteaz tot"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> fotografii sau videoclipuri selectate"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Selecteaz maximum <xliff:g id="COUNT">%1$s</xliff:g> elemente"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Fotografii"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albume"</string>
diff --git a/photopicker/res/values-ro/feature_preview_strings.xml b/photopicker/res/values-ro/feature_preview_strings.xml
index f1a2569ae..4da5d0179 100644
--- a/photopicker/res/values-ro/feature_preview_strings.xml
+++ b/photopicker/res/values-ro/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Selecteaz-le pe toate cele <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Selecteaz-le pe toate (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Selecteaz"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Deselecteaz-le pe toate cele <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Deselecteaz-le pe toate (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Previzualizeaz"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Probleme la redarea videoclipului"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Verific-i conexiunea la internet i ncearc din nou"</string>
diff --git a/photopicker/res/values-ro/feature_profiles_strings.xml b/photopicker/res/values-ro/feature_profiles_strings.xml
index b3de9a65a..9b9fac511 100644
--- a/photopicker/res/values-ro/feature_profiles_strings.xml
+++ b/photopicker/res/values-ro/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Serviciu"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Altele"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Schimb profilul de utilizator"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"S-a selectat <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Aplicaiile <xliff:g id="PROFILE_NAME">%1$s</xliff:g> sunt ntrerupte"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Blocat de administrator"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Ca s deschizi fotografiile din <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>, activeaz aplicaiile <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> i ncearc din nou"</string>
diff --git a/photopicker/res/values-ro/feature_search_strings.xml b/photopicker/res/values-ro/feature_search_strings.xml
index a65d324c1..436899085 100644
--- a/photopicker/res/values-ro/feature_search_strings.xml
+++ b/photopicker/res/values-ro/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Caut"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Caut n fotografii"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Caut n fotografii"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Caut n videoclipuri"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Niciun rezultat"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"ncearc s caui cuvinte similare"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Sugestii"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Cutarea a fost dezactivat."</string>
 </resources>
diff --git a/photopicker/res/values-ru/core_strings.xml b/photopicker/res/values-ru/core_strings.xml
index 859c58a01..e0951ff38 100644
--- a/photopicker/res/values-ru/core_strings.xml
+++ b/photopicker/res/values-ru/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>,    : <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"   : <xliff:g id="TIME">%1$s</xliff:g>. : <xliff:g id="DURATION">%2$s</xliff:g>."</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF-"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"  "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">" "</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">" "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">" "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"   : <xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"  (  <xliff:g id="COUNT">%1$s</xliff:g>)."</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-ru/feature_preview_strings.xml b/photopicker/res/values-ru/feature_preview_strings.xml
index 3b2f0252f..75758c3c3 100644
--- a/photopicker/res/values-ru/feature_preview_strings.xml
+++ b/photopicker/res/values-ru/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"  <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"   <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"   (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">""</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"   "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"      ."</string>
diff --git a/photopicker/res/values-ru/feature_profiles_strings.xml b/photopicker/res/values-ru/feature_profiles_strings.xml
index 8d6f04d5a..96d52a3bb 100644
--- a/photopicker/res/values-ru/feature_profiles_strings.xml
+++ b/photopicker/res/values-ru/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"  "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">" : <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"    \"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>\" "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">" "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"     \"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>\",    \"<xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>\"   ."</string>
diff --git a/photopicker/res/values-ru/feature_search_strings.xml b/photopicker/res/values-ru/feature_search_strings.xml
index 2e10249d9..5d5c6db5e 100644
--- a/photopicker/res/values-ru/feature_search_strings.xml
+++ b/photopicker/res/values-ru/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">" "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"   "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">" ."</string>
 </resources>
diff --git a/photopicker/res/values-si/core_strings.xml b/photopicker/res/values-si/core_strings.xml
index b9a01b8d0..b82181691 100644
--- a/photopicker/res/values-si/core_strings.xml
+++ b/photopicker/res/values-si/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="TIME">%2$s</xliff:g>   <xliff:g id="ITEM_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"<xliff:g id="TIME">%1$s</xliff:g> <xliff:g id="DURATION">%2$s</xliff:g>      "</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">" "</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">""</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">" "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"   <xliff:g id="COUNT">%1$s</xliff:g>  "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">" <xliff:g id="COUNT">%1$s</xliff:g>  "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-si/feature_preview_strings.xml b/photopicker/res/values-si/feature_preview_strings.xml
index ed7c7fac4..48e59e742 100644
--- a/photopicker/res/values-si/feature_preview_strings.xml
+++ b/photopicker/res/values-si/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"  <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"  <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">""</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"   "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"       "</string>
diff --git a/photopicker/res/values-si/feature_profiles_strings.xml b/photopicker/res/values-si/feature_profiles_strings.xml
index 7a329c750..3ce4664e3 100644
--- a/photopicker/res/values-si/feature_profiles_strings.xml
+++ b/photopicker/res/values-si/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"   "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>  "</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>   "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"     "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>   ,  <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>      "</string>
diff --git a/photopicker/res/values-si/feature_search_strings.xml b/photopicker/res/values-si/feature_search_strings.xml
index bad720f5b..eb5c9b021 100644
--- a/photopicker/res/values-si/feature_search_strings.xml
+++ b/photopicker/res/values-si/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"  "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"    "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">" ."</string>
 </resources>
diff --git a/photopicker/res/values-sk/core_strings.xml b/photopicker/res/values-sk/core_strings.xml
index 0f492f078..419b64eb9 100644
--- a/photopicker/res/values-sk/core_strings.xml
+++ b/photopicker/res/values-sk/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Fotky avide"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Mdi"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"Fotka <xliff:g id="ITEM_NAME">%1$s</xliff:g> nasnman <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Video bolo zaznamenan <xliff:g id="TIME">%1$s</xliff:g> atrv <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Fotka"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Pohybliv fotka"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Vybran"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Nevybran"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Vybra"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Zrui vber"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Hotovo"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Zrui vber vetkho"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"Bolo vybranch viacero fotiek alebo vide (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Maximlny povolen poet vybratch poloiek: <xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Fotky"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albumy"</string>
diff --git a/photopicker/res/values-sk/feature_preview_strings.xml b/photopicker/res/values-sk/feature_preview_strings.xml
index 942be8bb3..040f59773 100644
--- a/photopicker/res/values-sk/feature_preview_strings.xml
+++ b/photopicker/res/values-sk/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Vybra vetky poloky <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Vybra vetko (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Vybra"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Zrui vber vetkch poloiek <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Zrui vber vetkch poloiek (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Zobrazi ukku"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"akosti sprehrvanm videa"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Skontrolujte internetov pripojenie askste to znova"</string>
diff --git a/photopicker/res/values-sk/feature_profiles_strings.xml b/photopicker/res/values-sk/feature_profiles_strings.xml
index 0a2611c96..aa69251cc 100644
--- a/photopicker/res/values-sk/feature_profiles_strings.xml
+++ b/photopicker/res/values-sk/feature_profiles_strings.xml
@@ -17,10 +17,11 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_profile_primary_label" msgid="4757455689901820680">"Osobn"</string>
+    <string name="photopicker_profile_primary_label" msgid="4757455689901820680">"Osobn"</string>
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Pracovn"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"In"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Prepn profil pouvatea"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Vybran profil: <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Aplikcie profilu <xliff:g id="PROFILE_NAME">%1$s</xliff:g> s pozastaven"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Blokovan vam sprvcom"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Ak chcete otvori fotky profilu <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>, zapnite aplikcie profilu <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> askste to znova"</string>
diff --git a/photopicker/res/values-sk/feature_search_strings.xml b/photopicker/res/values-sk/feature_search_strings.xml
index 7ed219676..d7dac5ccf 100644
--- a/photopicker/res/values-sk/feature_search_strings.xml
+++ b/photopicker/res/values-sk/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Hada"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Vyhadajte vo svojich fotkch"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Hadajte vo fotkch"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Hadajte vo videch"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Nenali sa iadne vsledky"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Skste vyhada podobn slov"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Nvrhy"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Vyhadvanie je zakzan."</string>
 </resources>
diff --git a/photopicker/res/values-sl/core_strings.xml b/photopicker/res/values-sl/core_strings.xml
index d2e476423..18ac15d27 100644
--- a/photopicker/res/values-sl/core_strings.xml
+++ b/photopicker/res/values-sl/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Fotografije in videoposnetki"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Predstavnost"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>: posneto dne <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Videoposnetek posnet dne <xliff:g id="TIME">%1$s</xliff:g>, trajanje <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Fotografija"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Fotografija z videom"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Izbrano"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Ni izbrano"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Izberi"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Poisti izbiro"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Konano"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Preklic celotnega izbora"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"tevilo izbranih fotografij ali videoposnetkov: <xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Izberite najve toliko elementov: <xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Fotografije"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albumi"</string>
diff --git a/photopicker/res/values-sl/feature_preview_strings.xml b/photopicker/res/values-sl/feature_preview_strings.xml
index b291f3efa..dc753c29e 100644
--- a/photopicker/res/values-sl/feature_preview_strings.xml
+++ b/photopicker/res/values-sl/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Izberi vse <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Izberi vse (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Izberi"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Odznai vse <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Odznai vse (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Predogled"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Teave pri predvajanju videoposnetka"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Preverite internetno povezavo in poskusite znova"</string>
diff --git a/photopicker/res/values-sl/feature_profiles_strings.xml b/photopicker/res/values-sl/feature_profiles_strings.xml
index ba1ce3dff..b9826ff80 100644
--- a/photopicker/res/values-sl/feature_profiles_strings.xml
+++ b/photopicker/res/values-sl/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Slubeno"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Drugo"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Preklopi profil uporabnika"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Izbrano: <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Aplikacije profila <xliff:g id="PROFILE_NAME">%1$s</xliff:g> so zaasno zaustavljene"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Blokiral skrbnik"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"e elite odpreti fotografije profila <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>, vklopite aplikacije profila <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> in nato poskusite znova"</string>
diff --git a/photopicker/res/values-sl/feature_search_strings.xml b/photopicker/res/values-sl/feature_search_strings.xml
index a27be00c2..b1f8ac518 100644
--- a/photopicker/res/values-sl/feature_search_strings.xml
+++ b/photopicker/res/values-sl/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Iskanje"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Iskanje po fotografijah"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Iite po svojih fotografijah"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Iite po svojih videoposnetkih"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Ni rezultatov"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Poskusite poiskati podobne besede"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Predlogi"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Iskanje je onemogoeno."</string>
 </resources>
diff --git a/photopicker/res/values-sq/core_strings.xml b/photopicker/res/values-sq/core_strings.xml
index dcbcbc1c9..ed38d7178 100644
--- a/photopicker/res/values-sq/core_strings.xml
+++ b/photopicker/res/values-sq/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Fotografit dhe videot"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Media"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> br n <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Video e regjistruar n <xliff:g id="TIME">%1$s</xliff:g> me kohzgjatje <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Fotografi"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Fotografi me lvizje"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Zgjedhur"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Nuk sht zgjedhur"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Zgjidh"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Hiq przgjedhjen"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"U krye"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Anulo zgjedhjen pr t gjitha"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"Jan zgjedhur <xliff:g id="COUNT">%1$s</xliff:g> fotografi ose video"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Zgjidh deri n <xliff:g id="COUNT">%1$s</xliff:g> artikuj"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Fotografit"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albumet"</string>
diff --git a/photopicker/res/values-sq/feature_preview_strings.xml b/photopicker/res/values-sq/feature_preview_strings.xml
index 3511ef706..a4db9754a 100644
--- a/photopicker/res/values-sq/feature_preview_strings.xml
+++ b/photopicker/res/values-sq/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Zgjidh t gjitha <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Zgjidh t gjitha (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Zgjidh"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Anulo zgjedhjen pr t gjitha <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Anulo zgjedhjen pr t gjitha (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Shiko paraprakisht"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Problem me luajtjen e videos"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Kontrollo lidhjen e internetit dhe provo prsri"</string>
diff --git a/photopicker/res/values-sq/feature_profiles_strings.xml b/photopicker/res/values-sq/feature_profiles_strings.xml
index a14f7514e..1d227df94 100644
--- a/photopicker/res/values-sq/feature_profiles_strings.xml
+++ b/photopicker/res/values-sq/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Puna"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Tjetr"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Ndrro profilin e prdoruesit"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"sht zgjedhur: <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Aplikacionet e profilit \"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>\" jan vendosur n pauz"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Bllokuar nga administratori yt"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Pr t hapur fotografit e profilit \"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>\", aktivizo aplikacionet e profilit \"<xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>\" dhe m pas provo prsri"</string>
diff --git a/photopicker/res/values-sq/feature_search_strings.xml b/photopicker/res/values-sq/feature_search_strings.xml
index 167925549..53752c22e 100644
--- a/photopicker/res/values-sq/feature_search_strings.xml
+++ b/photopicker/res/values-sq/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Krko"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Krko te fotografit"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Krko te fotografit e tua"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Krko te videot e tua"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Nuk u gjet asnj rezultat"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Provo t krkosh pr fjal t ngjashme"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Sugjerime"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Krkimi sht aktivizuar."</string>
 </resources>
diff --git a/photopicker/res/values-sr/core_strings.xml b/photopicker/res/values-sr/core_strings.xml
index c40c2c5e0..21c79b7a5 100644
--- a/photopicker/res/values-sr/core_strings.xml
+++ b/photopicker/res/values-sr/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>:  <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"   <xliff:g id="TIME">%1$s</xliff:g>   <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"  "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">" "</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">" "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">" "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"   : <xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"        <xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-sr/feature_preview_strings.xml b/photopicker/res/values-sr/feature_preview_strings.xml
index 385286bda..553e34ff8 100644
--- a/photopicker/res/values-sr/feature_preview_strings.xml
+++ b/photopicker/res/values-sr/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"  <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"  <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"    (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">""</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"      "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"     "</string>
diff --git a/photopicker/res/values-sr/feature_profiles_strings.xml b/photopicker/res/values-sr/feature_profiles_strings.xml
index 7b982d199..8288fd71b 100644
--- a/photopicker/res/values-sr/feature_profiles_strings.xml
+++ b/photopicker/res/values-sr/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">" "</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"  "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">": <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"  <xliff:g id="PROFILE_NAME">%1$s</xliff:g>  "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">" "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"     <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>,    <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>   "</string>
diff --git a/photopicker/res/values-sr/feature_search_strings.xml b/photopicker/res/values-sr/feature_search_strings.xml
index 2e943b4fa..7a3cdaf82 100644
--- a/photopicker/res/values-sr/feature_search_strings.xml
+++ b/photopicker/res/values-sr/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">" "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">" "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"   "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"  "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  ."</string>
 </resources>
diff --git a/photopicker/res/values-sv/core_strings.xml b/photopicker/res/values-sv/core_strings.xml
index 42f0ec0c6..2f6b3075d 100644
--- a/photopicker/res/values-sv/core_strings.xml
+++ b/photopicker/res/values-sv/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Foton och videor"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Media"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> togs <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Videon spelades in <xliff:g id="TIME">%1$s</xliff:g>. Lngd: <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Foto"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"Gif"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Rrelsefoto"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Markerat"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Inte markerad"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Markera"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Avmarkera"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Klar"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Avmarkera alla"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> foton eller videor har markerats"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Vlj upp till <xliff:g id="COUNT">%1$s</xliff:g>objekt"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Foton"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Album"</string>
diff --git a/photopicker/res/values-sv/feature_preview_strings.xml b/photopicker/res/values-sv/feature_preview_strings.xml
index 1eaec6a5b..3f7a339a9 100644
--- a/photopicker/res/values-sv/feature_preview_strings.xml
+++ b/photopicker/res/values-sv/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Markera alla <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Markera alla (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Vlj"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Avmarkera alla <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Avmarkera alla (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Frhandsgranska"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Det gick inte att spela upp videon"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Kontrollera internetanslutningen och frsk igen"</string>
diff --git a/photopicker/res/values-sv/feature_profiles_strings.xml b/photopicker/res/values-sv/feature_profiles_strings.xml
index ef5e96f51..752612f94 100644
--- a/photopicker/res/values-sv/feature_profiles_strings.xml
+++ b/photopicker/res/values-sv/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Jobb"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Annat"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Byt anvndarprofil"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> har markerats"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Appar fr profilen <xliff:g id="PROFILE_NAME">%1$s</xliff:g> har pausats"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Blockeras av administratren"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Om du vill ppna foton fr profilen <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g> aktiverar du dina appar fr <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> och frsker igen"</string>
diff --git a/photopicker/res/values-sv/feature_search_strings.xml b/photopicker/res/values-sv/feature_search_strings.xml
index 10897a83d..b2b179617 100644
--- a/photopicker/res/values-sv/feature_search_strings.xml
+++ b/photopicker/res/values-sv/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Sk"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Sk bland dina foton"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Sk bland dina foton"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Sk bland dina videor"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Inga resultat hittades"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Testa att ska efter liknande ord"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Frslag"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Skning inaktiverad."</string>
 </resources>
diff --git a/photopicker/res/values-sw/core_strings.xml b/photopicker/res/values-sw/core_strings.xml
index 84c234569..d3582b40e 100644
--- a/photopicker/res/values-sw/core_strings.xml
+++ b/photopicker/res/values-sw/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Picha na video"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Maudhui"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> uliyopiga <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Video uliyorekodi mnamo <xliff:g id="TIME">%1$s</xliff:g> ikiwa na muda wa <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Picha"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Picha yenye Video"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Imechaguliwa"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Haijachaguliwa"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Chagua"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Acha kuchagua"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Nimemaliza"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Acha kuchagua zote"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"Umechagua picha au video <xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Chagua hadi vipengee <xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Picha"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albamu"</string>
diff --git a/photopicker/res/values-sw/feature_preview_strings.xml b/photopicker/res/values-sw/feature_preview_strings.xml
index 7cd57cbfe..f493a2e23 100644
--- a/photopicker/res/values-sw/feature_preview_strings.xml
+++ b/photopicker/res/values-sw/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Chagua zote <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Chagua zote (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Chagua"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Acha kuchagua zote <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Acha kuchagua zote (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Kagua kwanza"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Tatizo limetokea wakati wa kucheza video"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Angalia muunganisho wako wa intaneti kisha ujaribu tena"</string>
diff --git a/photopicker/res/values-sw/feature_profiles_strings.xml b/photopicker/res/values-sw/feature_profiles_strings.xml
index d784f84c9..a0ec25af7 100644
--- a/photopicker/res/values-sw/feature_profiles_strings.xml
+++ b/photopicker/res/values-sw/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Kazini"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Mengineyo"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Badilisha Wasifu wa Mtumiaji"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Umechagua <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Programu za <xliff:g id="PROFILE_NAME">%1$s</xliff:g> zimesitishwa"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Umezuiwa na msimamizi wako"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Ili ufungue picha za <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g> washa programu zako za <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> kisha ujaribu tena"</string>
diff --git a/photopicker/res/values-sw/feature_search_strings.xml b/photopicker/res/values-sw/feature_search_strings.xml
index 65cee55c4..054dc3e49 100644
--- a/photopicker/res/values-sw/feature_search_strings.xml
+++ b/photopicker/res/values-sw/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Tafuta"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Tafuta kwenye picha zako"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Tafuta picha zako"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Tafuta video zako"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Hakuna matokeo yaliyopatikana"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Jaribu kutafuta maneno yanayofanana"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Mapendekezo"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Umezima kipengele cha utafutaji."</string>
 </resources>
diff --git a/photopicker/res/values-ta/core_strings.xml b/photopicker/res/values-ta/core_strings.xml
index 5cfb0ed02..cd9df7f7e 100644
--- a/photopicker/res/values-ta/core_strings.xml
+++ b/photopicker/res/values-ta/core_strings.xml
@@ -19,11 +19,20 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">" &amp; "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="TIME">%2$s</xliff:g>  <xliff:g id="ITEM_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"<xliff:g id="TIME">%1$s</xliff:g>   ( : <xliff:g id="DURATION">%2$s</xliff:g>)"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">""</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">" "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"  "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> / "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"<xliff:g id="COUNT">%1$s</xliff:g>   "</string>
-    <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Photos"</string>
+    <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
     <string name="photopicker_photos_empty_state_title" msgid="7018770515431149456">"  "</string>
     <string name="photopicker_photos_empty_state_body" msgid="5959729294856198675">"   "</string>
diff --git a/photopicker/res/values-ta/feature_preview_strings.xml b/photopicker/res/values-ta/feature_preview_strings.xml
index 0313f0220..0b02fa2a1 100644
--- a/photopicker/res/values-ta/feature_preview_strings.xml
+++ b/photopicker/res/values-ta/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"<xliff:g id="COUNT">(%1$s)</xliff:g> "</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"<xliff:g id="COUNT">(%1$s)</xliff:g> "</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">""</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"   "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"    "</string>
diff --git a/photopicker/res/values-ta/feature_profiles_strings.xml b/photopicker/res/values-ta/feature_profiles_strings.xml
index 063e908ac..6aea8e57f 100644
--- a/photopicker/res/values-ta/feature_profiles_strings.xml
+++ b/photopicker/res/values-ta/feature_profiles_strings.xml
@@ -17,10 +17,11 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_profile_primary_label" msgid="4757455689901820680">""</string>
+    <string name="photopicker_profile_primary_label" msgid="4757455689901820680">""</string>
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"  "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> "</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>  "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"  "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>  ,  <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>    "</string>
diff --git a/photopicker/res/values-ta/feature_search_strings.xml b/photopicker/res/values-ta/feature_search_strings.xml
index c6e40fe6a..2e0f629a1 100644
--- a/photopicker/res/values-ta/feature_search_strings.xml
+++ b/photopicker/res/values-ta/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"  "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"  "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"  "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">" "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"   "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  ."</string>
 </resources>
diff --git a/photopicker/res/values-te/core_strings.xml b/photopicker/res/values-te/core_strings.xml
index 946281d04..8a1276aac 100644
--- a/photopicker/res/values-te/core_strings.xml
+++ b/photopicker/res/values-te/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">" &amp; "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="TIME">%2$s</xliff:g>  <xliff:g id="ITEM_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"<xliff:g id="DURATION">%2$s</xliff:g>  <xliff:g id="TIME">%1$s</xliff:g>  "</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">""</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">" "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"  "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g>    "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">" <xliff:g id="COUNT">%1$s</xliff:g>  "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-te/feature_preview_strings.xml b/photopicker/res/values-te/feature_preview_strings.xml
index beacbf824..7e9a242c6 100644
--- a/photopicker/res/values-te/feature_preview_strings.xml
+++ b/photopicker/res/values-te/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">" <xliff:g id="COUNT">(%1$s)</xliff:g> "</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">" <xliff:g id="COUNT">(%1$s)</xliff:g>   "</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"    (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">" "</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"    "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"    ,   "</string>
diff --git a/photopicker/res/values-te/feature_profiles_strings.xml b/photopicker/res/values-te/feature_profiles_strings.xml
index d1fcf2814..74adb1d51 100644
--- a/photopicker/res/values-te/feature_profiles_strings.xml
+++ b/photopicker/res/values-te/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"  "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> "</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>   "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"    "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>    <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>   ,    "</string>
diff --git a/photopicker/res/values-te/feature_search_strings.xml b/photopicker/res/values-te/feature_search_strings.xml
index 22488760d..1de73c3ee 100644
--- a/photopicker/res/values-te/feature_search_strings.xml
+++ b/photopicker/res/values-te/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">" "</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"  "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"   "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"   "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"       "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"  ."</string>
 </resources>
diff --git a/photopicker/res/values-th/core_strings.xml b/photopicker/res/values-th/core_strings.xml
index c7f0d0b34..8e232791a 100644
--- a/photopicker/res/values-th/core_strings.xml
+++ b/photopicker/res/values-th/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">""</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g>  <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">" <xliff:g id="TIME">%1$s</xliff:g>  <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">""</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">""</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">""</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">""</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">" <xliff:g id="COUNT">%1$s</xliff:g> "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">" <xliff:g id="COUNT">%1$s</xliff:g> "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-th/feature_preview_strings.xml b/photopicker/res/values-th/feature_preview_strings.xml
index 68a0b4931..d955920fd 100644
--- a/photopicker/res/values-th/feature_preview_strings.xml
+++ b/photopicker/res/values-th/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">" <xliff:g id="COUNT">(%1$s)</xliff:g> "</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">" (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">" <xliff:g id="COUNT">(%1$s)</xliff:g> "</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">" (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">""</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">""</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">""</string>
diff --git a/photopicker/res/values-th/feature_profiles_strings.xml b/photopicker/res/values-th/feature_profiles_strings.xml
index 489c89419..e0738de37 100644
--- a/photopicker/res/values-th/feature_profiles_strings.xml
+++ b/photopicker/res/values-th/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">""</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">" <xliff:g id="PROFILE_NAME">%1$s</xliff:g> "</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">" \"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>\" "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">""</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">" \"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>\"  \"<xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>\" "</string>
diff --git a/photopicker/res/values-th/feature_search_strings.xml b/photopicker/res/values-th/feature_search_strings.xml
index dc00a0a80..1bde329ae 100644
--- a/photopicker/res/values-th/feature_search_strings.xml
+++ b/photopicker/res/values-th/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">""</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">""</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">""</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">""</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">""</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">""</string>
 </resources>
diff --git a/photopicker/res/values-tl/core_strings.xml b/photopicker/res/values-tl/core_strings.xml
index 9c32e604c..1a6aaa09f 100644
--- a/photopicker/res/values-tl/core_strings.xml
+++ b/photopicker/res/values-tl/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Mga larawan at video"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Media"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> na kinuha noong <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Kinuha ang video na may tagal na <xliff:g id="DURATION">%2$s</xliff:g> noong <xliff:g id="TIME">%1$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Larawan"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Gumagalaw na Larawan"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Napili"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Hindi napili"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Piliin"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"I-deselect"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Tapos na"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"I-deselect lahat"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> ang napiling larawan o video"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Pumili ng hanggang <xliff:g id="COUNT">%1$s</xliff:g> (na) item"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Mga Larawan"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Mga Album"</string>
diff --git a/photopicker/res/values-tl/feature_preview_strings.xml b/photopicker/res/values-tl/feature_preview_strings.xml
index 1542431e3..0f81bfe5a 100644
--- a/photopicker/res/values-tl/feature_preview_strings.xml
+++ b/photopicker/res/values-tl/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Piliin lahat <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Piliin lahat (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Piliin"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"I-unselect lahat <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"I-unselect lahat (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"I-preview"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Nagkaproblema sa pag-play ng video"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Suriin ang iyong koneksyon sa internet at subukan ulit"</string>
diff --git a/photopicker/res/values-tl/feature_profiles_strings.xml b/photopicker/res/values-tl/feature_profiles_strings.xml
index 94f9c944c..60388cf10 100644
--- a/photopicker/res/values-tl/feature_profiles_strings.xml
+++ b/photopicker/res/values-tl/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Trabaho"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Iba pa"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Lumipat ng Profile ng User"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Pinili ang <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Naka-pause ang mga app sa <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Na-block ng iyong admin"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Para buksan ang mga larawan sa <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>, i-on ang iyong mga app sa <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>, pagkatapos ay subukan ulit"</string>
diff --git a/photopicker/res/values-tl/feature_search_strings.xml b/photopicker/res/values-tl/feature_search_strings.xml
index d54dc71f8..69d537ee3 100644
--- a/photopicker/res/values-tl/feature_search_strings.xml
+++ b/photopicker/res/values-tl/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Maghanap"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Maghanap sa iyong mga larawan"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Maghanap sa iyong mga larawan"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Hanapin ang iyong mga video"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Walang nakitang resulta"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Subukang maghanap ng mga katulad na salita"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Mga Suhestyon"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Naka-disable ang paghahanap"</string>
 </resources>
diff --git a/photopicker/res/values-tr/core_strings.xml b/photopicker/res/values-tr/core_strings.xml
index 638210886..7a9f45cdb 100644
--- a/photopicker/res/values-tr/core_strings.xml
+++ b/photopicker/res/values-tr/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Fotoraflar ve videolar"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Medya"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="TIME">%2$s</xliff:g> tarihinde ekilen <xliff:g id="ITEM_NAME">%1$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Video <xliff:g id="TIME">%1$s</xliff:g> tarihinde <xliff:g id="DURATION">%2$s</xliff:g> sreyle kaydedildi"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Fotoraf"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Hareketli Fotoraf"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Seili"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Seili deil"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Se"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Seimi kaldr"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Bitti"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Tmnn seimini kaldr"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> fotoraf veya video seildi"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"En fazla <xliff:g id="COUNT">%1$s</xliff:g> e sein"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Fotoraflar"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albmler"</string>
diff --git a/photopicker/res/values-tr/feature_preview_strings.xml b/photopicker/res/values-tr/feature_preview_strings.xml
index e79e574fe..1a482149b 100644
--- a/photopicker/res/values-tr/feature_preview_strings.xml
+++ b/photopicker/res/values-tr/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Tmn se <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Tmn se (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Se"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Tmnn seimini kaldr <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Tmnn seimini kaldr (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"nizle"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Video oynatlrken sorun olutu"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"nternet balantnz kontrol edip tekrar deneyin"</string>
diff --git a/photopicker/res/values-tr/feature_profiles_strings.xml b/photopicker/res/values-tr/feature_profiles_strings.xml
index 54bdac2ac..5fa0682bf 100644
--- a/photopicker/res/values-tr/feature_profiles_strings.xml
+++ b/photopicker/res/values-tr/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Dier"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Baka kullanc profiline ge"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> seildi"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> uygulamalar duraklatld"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Yneticiniz tarafndan engellendi"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g> fotoraflarn amak iin <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> uygulamalarnz etkinletirip tekrar deneyin"</string>
diff --git a/photopicker/res/values-tr/feature_search_strings.xml b/photopicker/res/values-tr/feature_search_strings.xml
index 26e5dd10d..b31569881 100644
--- a/photopicker/res/values-tr/feature_search_strings.xml
+++ b/photopicker/res/values-tr/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Ara"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Fotoraflarnzda arama yapn"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Fotoraflarnzda arama yapn"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Videolarnzda arayma yapn"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Sonu bulunamad"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Benzer kelimeleri aramay deneyin"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"neriler"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Arama devre d brakld"</string>
 </resources>
diff --git a/photopicker/res/values-uk/core_strings.xml b/photopicker/res/values-uk/core_strings.xml
index 06f54ed10..8805f6106 100644
--- a/photopicker/res/values-uk/core_strings.xml
+++ b/photopicker/res/values-uk/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> ( <xliff:g id="TIME">%2$s</xliff:g>)"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">" : <xliff:g id="TIME">%1$s</xliff:g>, : <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"  "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">" "</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">" "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"  "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">" <xliff:g id="COUNT">%1$s</xliff:g>   "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"    : <xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-uk/feature_preview_strings.xml b/photopicker/res/values-uk/feature_preview_strings.xml
index cc006541e..55884c9fd 100644
--- a/photopicker/res/values-uk/feature_preview_strings.xml
+++ b/photopicker/res/values-uk/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"  <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"  (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"   <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"   (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">""</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"   "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">" -   "</string>
diff --git a/photopicker/res/values-uk/feature_profiles_strings.xml b/photopicker/res/values-uk/feature_profiles_strings.xml
index ce5cc7c6e..a598e4a69 100644
--- a/photopicker/res/values-uk/feature_profiles_strings.xml
+++ b/photopicker/res/values-uk/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"   "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">" \"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>\""</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"  \"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>\" "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">" "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"     \"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>\",    \"<xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>\"   "</string>
diff --git a/photopicker/res/values-uk/feature_search_strings.xml b/photopicker/res/values-uk/feature_search_strings.xml
index 9c5169c2e..76a1bf936 100644
--- a/photopicker/res/values-uk/feature_search_strings.xml
+++ b/photopicker/res/values-uk/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">" "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">" "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">" "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"  "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"    "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">" ."</string>
 </resources>
diff --git a/photopicker/res/values-ur/core_strings.xml b/photopicker/res/values-ur/core_strings.xml
index 72c5c8034..c2b436945 100644
--- a/photopicker/res/values-ur/core_strings.xml
+++ b/photopicker/res/values-ur/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"  "</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="TIME">%2$s</xliff:g>  <xliff:g id="ITEM_NAME">%1$s</xliff:g>  "</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"<xliff:g id="TIME">%1$s</xliff:g>  <xliff:g id="DURATION">%2$s</xliff:g>      "</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">" "</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">" "</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"  "</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">" "</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"  "</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">" "</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"    "</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g>      "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"<xliff:g id="COUNT">%1$s</xliff:g>    "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-ur/feature_preview_strings.xml b/photopicker/res/values-ur/feature_preview_strings.xml
index b6403c977..094f1fb29 100644
--- a/photopicker/res/values-ur/feature_preview_strings.xml
+++ b/photopicker/res/values-ur/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">" <xliff:g id="COUNT">(%1$s)</xliff:g>   "</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">" (<xliff:g id="COUNT">%1$s</xliff:g>)   "</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">" "</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">" <xliff:g id="COUNT">(%1$s)</xliff:g>    "</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">" (<xliff:g id="COUNT">%1$s</xliff:g>)    "</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"  "</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"   "</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"        "</string>
diff --git a/photopicker/res/values-ur/feature_profiles_strings.xml b/photopicker/res/values-ur/feature_profiles_strings.xml
index b124ef085..ef442002c 100644
--- a/photopicker/res/values-ur/feature_profiles_strings.xml
+++ b/photopicker/res/values-ur/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"    "</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>   "</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>   "</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"      "</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>      <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>        "</string>
diff --git a/photopicker/res/values-ur/feature_search_strings.xml b/photopicker/res/values-ur/feature_search_strings.xml
index b6ccd252c..186fdd20e 100644
--- a/photopicker/res/values-ur/feature_search_strings.xml
+++ b/photopicker/res/values-ur/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">" "</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"   "</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"   "</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"   "</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"   "</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"       "</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"   "</string>
 </resources>
diff --git a/photopicker/res/values-uz/core_strings.xml b/photopicker/res/values-uz/core_strings.xml
index d384fda1b..25ed253ce 100644
--- a/photopicker/res/values-uz/core_strings.xml
+++ b/photopicker/res/values-uz/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Suratlar va videolar"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Media"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> olingan sana: <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Video tasvirga olingan sana: <xliff:g id="TIME">%1$s</xliff:g>, davomiyligi: <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Surat"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Harakatli surat"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Tanlangan"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Tanlanmagan"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Tanlash"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Tanlovni bekor qilish"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Tayyor"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Hammasini bekor qilish"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"<xliff:g id="COUNT">%1$s</xliff:g> ta surat yoki video tanlandi"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"<xliff:g id="COUNT">%1$s</xliff:g> tagacha elementni tanlang"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Suratlar"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Albomlar"</string>
diff --git a/photopicker/res/values-uz/feature_preview_strings.xml b/photopicker/res/values-uz/feature_preview_strings.xml
index e6ec9519e..9c8980b4b 100644
--- a/photopicker/res/values-uz/feature_preview_strings.xml
+++ b/photopicker/res/values-uz/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Hammasini tanlash (<xliff:g id="COUNT">(%1$s)</xliff:g>)"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Hammasini tanlash (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Tanlash"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Hammasini bekor qilish (<xliff:g id="COUNT">(%1$s)</xliff:g>)"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Hammasini bekor qilish (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Razm solish"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Video ijrosida muammo"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Internet aloqasini tekshiring va qayta urining"</string>
diff --git a/photopicker/res/values-uz/feature_profiles_strings.xml b/photopicker/res/values-uz/feature_profiles_strings.xml
index 78b7a9d0e..ca3229a2a 100644
--- a/photopicker/res/values-uz/feature_profiles_strings.xml
+++ b/photopicker/res/values-uz/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Ish"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Boshqa"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Foydalanuvchi profiliga almashish"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Belgilandi: <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g> ilovalari pauzada"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Administratoringiz tomonidan bloklangan"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g> suratlarni ochish uchun <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> ilovalarni yoqib, qayta urining"</string>
diff --git a/photopicker/res/values-uz/feature_search_strings.xml b/photopicker/res/values-uz/feature_search_strings.xml
index 2b7ff2d2f..1824a3302 100644
--- a/photopicker/res/values-uz/feature_search_strings.xml
+++ b/photopicker/res/values-uz/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Qidiruv"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Suratlar ichidan qidirish"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Suratlardan qidirish"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Videolardan qidiring"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Hech narsa topilmadi"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Oxshash sozlarni qidiring"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Takliflar"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Qidiruv faolsizlantirildi."</string>
 </resources>
diff --git a/photopicker/res/values-vi/core_strings.xml b/photopicker/res/values-vi/core_strings.xml
index 9dd88e515..574d7ad23 100644
--- a/photopicker/res/values-vi/core_strings.xml
+++ b/photopicker/res/values-vi/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"nh v video"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Ni dung nghe nhn"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> c chp lc <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Video c quay lc <xliff:g id="TIME">%1$s</xliff:g> vi thi lng <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"nh"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"nh chuyn ng"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">" chn"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Cha chn"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Chn"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"B chn"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Xong"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"B chn tt c"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">" chn <xliff:g id="COUNT">%1$s</xliff:g> nh hoc video"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Chn ti a <xliff:g id="COUNT">%1$s</xliff:g> mc"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"nh"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Album"</string>
diff --git a/photopicker/res/values-vi/feature_preview_strings.xml b/photopicker/res/values-vi/feature_preview_strings.xml
index 09450662c..48da89c91 100644
--- a/photopicker/res/values-vi/feature_preview_strings.xml
+++ b/photopicker/res/values-vi/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Chn tt c <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Chn tt c (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Chn"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"B chn tt c <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"B chn tt c (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Xem trc"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"S c khi pht video"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Hy kim tra kt ni Internet ri th li"</string>
diff --git a/photopicker/res/values-vi/feature_profiles_strings.xml b/photopicker/res/values-vi/feature_profiles_strings.xml
index 24660602e..5eca34099 100644
--- a/photopicker/res/values-vi/feature_profiles_strings.xml
+++ b/photopicker/res/values-vi/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Cng vic"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Khc"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Chuyn i h s ngi dng"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">" chn <xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Cc ng dng trong <xliff:g id="PROFILE_NAME">%1$s</xliff:g> b tm dng"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"B qun tr vin chn"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">" m nh trong h s <xliff:g id="PROFILE_NAME_0">%1$s</xliff:g>, hy bt cc ng dng trong h s <xliff:g id="PROFILE_NAME_1">%1$s</xliff:g> ri th li"</string>
diff --git a/photopicker/res/values-vi/feature_search_strings.xml b/photopicker/res/values-vi/feature_search_strings.xml
index 6347fdf91..27b4277d5 100644
--- a/photopicker/res/values-vi/feature_search_strings.xml
+++ b/photopicker/res/values-vi/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Tm kim"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Tm kim nh ca bn"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Tm kim nh ca bn"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Tm kim video ca bn"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Khng tm thy kt qu"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Hy th tm nhng t tng t"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Ni dung  xut"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Tnh nng tm kim  tt."</string>
 </resources>
diff --git a/photopicker/res/values-zh-rCN/core_strings.xml b/photopicker/res/values-zh-rCN/core_strings.xml
index a17b19aa8..65db989f2 100644
--- a/photopicker/res/values-zh-rCN/core_strings.xml
+++ b/photopicker/res/values-zh-rCN/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">""</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">" <xliff:g id="TIME">%1$s</xliff:g> <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">""</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">""</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">""</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">""</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">" <xliff:g id="COUNT">%1$s</xliff:g> "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">" <xliff:g id="COUNT">%1$s</xliff:g> "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-zh-rCN/feature_preview_strings.xml b/photopicker/res/values-zh-rCN/feature_preview_strings.xml
index 224dfb1d0..79fb6ec97 100644
--- a/photopicker/res/values-zh-rCN/feature_preview_strings.xml
+++ b/photopicker/res/values-zh-rCN/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">" <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">" (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">" <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">" (<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">""</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">""</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">""</string>
diff --git a/photopicker/res/values-zh-rCN/feature_profiles_strings.xml b/photopicker/res/values-zh-rCN/feature_profiles_strings.xml
index 1f84f7d73..e9af2b3f4 100644
--- a/photopicker/res/values-zh-rCN/feature_profiles_strings.xml
+++ b/photopicker/res/values-zh-rCN/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">""</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">""</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g><xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>"</string>
diff --git a/photopicker/res/values-zh-rCN/feature_search_strings.xml b/photopicker/res/values-zh-rCN/feature_search_strings.xml
index dce9f1e32..c4cb150af 100644
--- a/photopicker/res/values-zh-rCN/feature_search_strings.xml
+++ b/photopicker/res/values-zh-rCN/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">""</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">""</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">""</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">""</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">""</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">""</string>
 </resources>
diff --git a/photopicker/res/values-zh-rHK/core_strings.xml b/photopicker/res/values-zh-rHK/core_strings.xml
index 2c6ed6416..5c48e63ed 100644
--- a/photopicker/res/values-zh-rHK/core_strings.xml
+++ b/photopicker/res/values-zh-rHK/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">""</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g><xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"<xliff:g id="TIME">%1$s</xliff:g><xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">""</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">""</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">""</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">""</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">" <xliff:g id="COUNT">%1$s</xliff:g> "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">" <xliff:g id="COUNT">%1$s</xliff:g> "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-zh-rHK/feature_preview_strings.xml b/photopicker/res/values-zh-rHK/feature_preview_strings.xml
index 695004879..f156f794b 100644
--- a/photopicker/res/values-zh-rHK/feature_preview_strings.xml
+++ b/photopicker/res/values-zh-rHK/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">" <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">" <xliff:g id="COUNT">%1$s</xliff:g> "</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">" <xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">" <xliff:g id="COUNT">%1$s</xliff:g> "</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">""</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">""</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">""</string>
diff --git a/photopicker/res/values-zh-rHK/feature_profiles_strings.xml b/photopicker/res/values-zh-rHK/feature_profiles_strings.xml
index ab91205df..440d3bbbe 100644
--- a/photopicker/res/values-zh-rHK/feature_profiles_strings.xml
+++ b/photopicker/res/values-zh-rHK/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">""</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">""</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g><xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>"</string>
diff --git a/photopicker/res/values-zh-rHK/feature_search_strings.xml b/photopicker/res/values-zh-rHK/feature_search_strings.xml
index 244c3a097..48aa842e1 100644
--- a/photopicker/res/values-zh-rHK/feature_search_strings.xml
+++ b/photopicker/res/values-zh-rHK/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">""</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">""</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">""</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">""</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">""</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">""</string>
 </resources>
diff --git a/photopicker/res/values-zh-rTW/core_strings.xml b/photopicker/res/values-zh-rTW/core_strings.xml
index 487034f65..5e61346ea 100644
--- a/photopicker/res/values-zh-rTW/core_strings.xml
+++ b/photopicker/res/values-zh-rTW/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">""</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">""</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> <xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">" <xliff:g id="TIME">%1$s</xliff:g> <xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">""</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">""</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">""</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">""</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">""</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">""</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">""</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">""</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">" <xliff:g id="COUNT">%1$s</xliff:g> "</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">" <xliff:g id="COUNT">%1$s</xliff:g> "</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">""</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">""</string>
diff --git a/photopicker/res/values-zh-rTW/feature_preview_strings.xml b/photopicker/res/values-zh-rTW/feature_preview_strings.xml
index babfd4353..21de10b04 100644
--- a/photopicker/res/values-zh-rTW/feature_preview_strings.xml
+++ b/photopicker/res/values-zh-rTW/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">" <xliff:g id="COUNT">(%1$s)</xliff:g> "</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">" <xliff:g id="COUNT">%1$s</xliff:g> "</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">""</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">" <xliff:g id="COUNT">(%1$s)</xliff:g> "</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">" <xliff:g id="COUNT">%1$s</xliff:g> "</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">""</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">""</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">""</string>
diff --git a/photopicker/res/values-zh-rTW/feature_profiles_strings.xml b/photopicker/res/values-zh-rTW/feature_profiles_strings.xml
index 206cf9c82..3492d8276 100644
--- a/photopicker/res/values-zh-rTW/feature_profiles_strings.xml
+++ b/photopicker/res/values-zh-rTW/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">""</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">""</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">""</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"<xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">""</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g><xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>"</string>
diff --git a/photopicker/res/values-zh-rTW/feature_search_strings.xml b/photopicker/res/values-zh-rTW/feature_search_strings.xml
index 244c3a097..c9d5b2cc6 100644
--- a/photopicker/res/values-zh-rTW/feature_search_strings.xml
+++ b/photopicker/res/values-zh-rTW/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">""</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">""</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">""</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">""</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">""</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">""</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">""</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">""</string>
 </resources>
diff --git a/photopicker/res/values-zu/core_strings.xml b/photopicker/res/values-zu/core_strings.xml
index 9e96b77eb..a6cfde57b 100644
--- a/photopicker/res/values-zu/core_strings.xml
+++ b/photopicker/res/values-zu/core_strings.xml
@@ -19,9 +19,18 @@
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_application_label" msgid="7272391964836190376">"Izithombe namavidiyo"</string>
     <string name="photopicker_media_item" msgid="3592234718212377636">"Imidiya"</string>
+    <string name="photopicker_item_content_desc" msgid="8606023869442295434">"<xliff:g id="ITEM_NAME">%1$s</xliff:g> ithathwe ngo-<xliff:g id="TIME">%2$s</xliff:g>"</string>
+    <string name="photopicker_video_item_content_desc" msgid="7771015154523467435">"Ividiyo ethathwe ngo-<xliff:g id="TIME">%1$s</xliff:g> yobude besikhathi esingu-<xliff:g id="DURATION">%2$s</xliff:g>"</string>
+    <string name="photopicker_photo" msgid="3161869302699043679">"Isithombe"</string>
+    <string name="photopicker_gif" msgid="8915160998232097958">"I-GIF"</string>
+    <string name="photopicker_motion_photo" msgid="5932343665148103014">"Isithombe Esinyakazayo"</string>
     <string name="photopicker_item_selected" msgid="3741045642641682375">"Okukhethiwe"</string>
+    <string name="photopicker_item_not_selected" msgid="4036054099514100702">"Ayikhethiwe"</string>
+    <string name="photopicker_select_action_description" msgid="5369819457862091225">"Khetha"</string>
+    <string name="photopicker_deselect_action_description" msgid="4986504797441859297">"Susa ukukhetha"</string>
     <string name="photopicker_done_button_label" msgid="2641444126618862287">"Kwenziwe"</string>
     <string name="photopicker_clear_selection_button_description" msgid="8614016909754648208">"Ungakhethi konke"</string>
+    <string name="photopicker_selection_size_description" msgid="1142474949774463967">"Kukhethwe izithombe noma amavidiyo angu-<xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_selection_limit_exceeded_snackbar" msgid="9136196524514670280">"Khetha izinto ezifika kwezingu-<xliff:g id="COUNT">%1$s</xliff:g>"</string>
     <string name="photopicker_photos_nav_button_label" msgid="8716403708343738371">"Izithombe"</string>
     <string name="photopicker_albums_nav_button_label" msgid="4738165281285221320">"Ama-albhamu"</string>
diff --git a/photopicker/res/values-zu/feature_preview_strings.xml b/photopicker/res/values-zu/feature_preview_strings.xml
index 77d843274..29c6581dd 100644
--- a/photopicker/res/values-zu/feature_preview_strings.xml
+++ b/photopicker/res/values-zu/feature_preview_strings.xml
@@ -17,9 +17,9 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="photopicker_select_button_label" msgid="658102027531907034">"Khetha konke okungu-<xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_select_button_label" msgid="8663207309796656185">"Khetha konke (okungu-<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_select_current_button_label" msgid="5328497370795781055">"Khetha"</string>
-    <string name="photopicker_deselect_button_label" msgid="7353310112181878711">"Yekisa ukukhetha konke okungu-<xliff:g id="COUNT">(%1$s)</xliff:g>"</string>
+    <string name="photopicker_deselect_button_label" msgid="4730476375060939835">"Yekisa ukukhetha konke (okungu-<xliff:g id="COUNT">%1$s</xliff:g>)"</string>
     <string name="photopicker_preview_button_label" msgid="3567318300811305531">"Ukuhlola kuqala"</string>
     <string name="photopicker_preview_dialog_error_title" msgid="3285599941790002206">"Inkinga yokudlala ividiyo"</string>
     <string name="photopicker_preview_dialog_error_message" msgid="1945612118302563356">"Hlola ukuxhumeka kwe-inthanethi kwakho uphinde uzame futhi"</string>
diff --git a/photopicker/res/values-zu/feature_profiles_strings.xml b/photopicker/res/values-zu/feature_profiles_strings.xml
index 1bf568fa4..cb5ffaf0d 100644
--- a/photopicker/res/values-zu/feature_profiles_strings.xml
+++ b/photopicker/res/values-zu/feature_profiles_strings.xml
@@ -21,6 +21,7 @@
     <string name="photopicker_profile_managed_label" msgid="8223788467673917191">"Umsebenzi"</string>
     <string name="photopicker_profile_unknown_label" msgid="4794151597112747338">"Okunye"</string>
     <string name="photopicker_profile_switch_button_description" msgid="136797665427675773">"Shintsha Iphrofayela Yomsebenzisi"</string>
+    <string name="photopicker_selected_profile_description" msgid="4038233039178326677">"Kukhethwe i-<xliff:g id="PROFILE_NAME">%1$s</xliff:g>"</string>
     <string name="photopicker_profile_unavailable_dialog_title" msgid="1198925313401075806">"Ama-app e-<xliff:g id="PROFILE_NAME">%1$s</xliff:g> amisiwe"</string>
     <string name="photopicker_profile_blocked_by_admin_dialog_title" msgid="3210828020946868217">"Kuvinjwe ngumphathi wakho"</string>
     <string name="photopicker_profile_unavailable_dialog_message" msgid="7075601941628320907">"Ukuze uvule izithombe ze-<xliff:g id="PROFILE_NAME_0">%1$s</xliff:g> vula ama-app wakho e-<xliff:g id="PROFILE_NAME_1">%1$s</xliff:g>, bese uzama futhi"</string>
diff --git a/photopicker/res/values-zu/feature_search_strings.xml b/photopicker/res/values-zu/feature_search_strings.xml
index 3df34c426..c28fb27bd 100644
--- a/photopicker/res/values-zu/feature_search_strings.xml
+++ b/photopicker/res/values-zu/feature_search_strings.xml
@@ -18,5 +18,10 @@
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="photopicker_search_placeholder_text" msgid="2056650487029735317">"Sesha"</string>
-    <string name="photopicker_searchView_placeholder_text" msgid="4851664928178114364">"Sesha izithombe zakho"</string>
+    <string name="photopicker_search_photos_placeholder_text" msgid="4193624269605283280">"Sesha izithombe zakho"</string>
+    <string name="photopicker_search_videos_placeholder_text" msgid="6373176950925263103">"Sesha amavidiyo akho"</string>
+    <string name="photopicker_search_result_empty_state_title" msgid="5464851093908453867">"Akunamiphumela etholakele"</string>
+    <string name="photopicker_search_result_empty_state_body" msgid="1732249539645056618">"Zama ukusesha amagama afanayo"</string>
+    <string name="photopicker_search_suggestions_text" msgid="1758802235973720586">"Iziphakamiso"</string>
+    <string name="photopicker_search_disabled_hint" msgid="4049451515025551462">"Usesho lukhutshaziwe."</string>
 </resources>
diff --git a/photopicker/res/values/config.xml b/photopicker/res/values/config.xml
new file mode 100644
index 000000000..f30f35563
--- /dev/null
+++ b/photopicker/res/values/config.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2024 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<resources>
+    <!-- This allows overlays to prevent the kotlin picker from monitoring
+         device config updates, and disabling this will prevent the kotlin
+         picker from being enabled.
+    -->
+    <bool name="config_enablePhotopickerDeviceConfigReceiver">true</bool>
+</resources>
\ No newline at end of file
diff --git a/photopicker/res/values/core_strings.xml b/photopicker/res/values/core_strings.xml
index ed3035e4f..71b13936c 100644
--- a/photopicker/res/values/core_strings.xml
+++ b/photopicker/res/values/core_strings.xml
@@ -22,15 +22,42 @@
   <!-- Content description for an individual piece of media in the photopicker's media grid -->
   <string name="photopicker_media_item" translation_description="Accessibility text denoting an element that represents an individual photo or video in a grid of selectable media. [CHAR_LIMIT=NONE]">Media</string>
 
+  <!-- Content description of when a photo was taken on [CHAR LIMIT=NONE] -->
+  <string name="photopicker_item_content_desc"><xliff:g id="item_name" example="Photo">%1$s</xliff:g> taken on <xliff:g id="time" example="Jul 7, 2020, 12:00:00 AM">%2$s</xliff:g></string>
+
+  <!-- Content description of a video item [CHAR LIMIT=NONE] -->
+  <string name="photopicker_video_item_content_desc">Video taken on <xliff:g id="time" example="Jul 7, 2020, 12:00:00 AM">%1$s</xliff:g> with duration <xliff:g id="duration" example="00:03">%2$s</xliff:g></string>
+
+  <!-- Title of the picker photo item [CHAR LIMIT=40] -->
+  <string name="photopicker_photo">Photo</string>
+
+  <!-- Title of the picker GIF item [CHAR LIMIT=40] -->
+  <string name="photopicker_gif">GIF</string>
+
+  <!-- Title of the picker motion photo item [CHAR LIMIT=60] -->
+  <string name="photopicker_motion_photo">Motion Photo</string>
+
   <!-- Content description for the selected checkmark in the media grid -->
   <string name="photopicker_item_selected" translation_description="Accessibility text denoting an individual photo is selected in a grid of photos. [CHAR_LIMIT=NONE]">Selected</string>
 
+  <!-- Content description for the not selected empty circle in the media grid -->
+  <string name="photopicker_item_not_selected" translation_description="Accessibility text denoting an individual photo is not selected in a grid of photos. [CHAR_LIMIT=NONE]">Not selected</string>
+
+  <!-- Content description for action to select an item -->
+  <string name="photopicker_select_action_description" translation_description="Accessibility text for describing the action to select. [CHAR_LIMIT=NONE]">Select</string>
+
+  <!-- Content description for action to deselect an item -->
+  <string name="photopicker_deselect_action_description" translation_description="Accessibility text for describing the action to deselect. [CHAR_LIMIT=NONE]">Deselect</string>
+
   <!-- Button label for the "Done" button in the selection bar -->
   <string name="photopicker_done_button_label" translation_description="Button label that confirms the selected items and closes the photopicker.">Done</string>
 
   <!-- Accessibility description for the X (deselect all) button in the selection bar -->
   <string name="photopicker_clear_selection_button_description" translation_description="Button Accessibility description that unselects all selected media items.">Deselect all</string>
 
+  <!-- Accessibility description for the count in the selection bar -->
+  <string name="photopicker_selection_size_description" translation_description="Accessibility description for selection count in the selection bar."><xliff:g id="count" example="5">%1$s</xliff:g> photos or videos selected</string>
+
   <!-- Snackbar message when new items can't be selected because the selection is full -->
   <string name="photopicker_selection_limit_exceeded_snackbar" translation_description="">Select up to <xliff:g id="count" example="42">%1$s</xliff:g> items</string>
 
diff --git a/photopicker/res/values/feature_preview_strings.xml b/photopicker/res/values/feature_preview_strings.xml
index 5c7d017d7..560d68c16 100644
--- a/photopicker/res/values/feature_preview_strings.xml
+++ b/photopicker/res/values/feature_preview_strings.xml
@@ -17,13 +17,13 @@
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
 
   <!-- Button label for the "Select" button in the preview screen bottom bar -->
-  <string name="photopicker_select_button_label" translation_description="Button label to select the previewed photo.">Select all <xliff:g id="count" example="42">(%1$s)</xliff:g></string>
+  <string name="photopicker_select_button_label" translation_description="Button label to select the previewed photo.">Select all (<xliff:g id="count" example="42">%1$s</xliff:g>)</string>
 
   <!-- Button label for the "Select" button in the selection bar -->
   <string name="photopicker_select_current_button_label" translation_description="Button label that selects the current item.">Select</string>
 
   <!-- Button label for the "Deselect" button in the preview screen bottom bar -->
-  <string name="photopicker_deselect_button_label" translation_description="Button label to deselect the previewed photo.">Unselect all <xliff:g id="count" example="42">(%1$s)</xliff:g></string>
+  <string name="photopicker_deselect_button_label" translation_description="Button label to deselect the previewed photo.">Unselect all (<xliff:g id="count" example="42">%1$s</xliff:g>)</string>
 
   <!-- Button label for the "Preview" button in the selection bar -->
   <string name="photopicker_preview_button_label" translation_description="Button label to navigate to a screen and preview the selected media.">Preview</string>
diff --git a/photopicker/res/values/feature_profiles_strings.xml b/photopicker/res/values/feature_profiles_strings.xml
index 365abbf87..3587b01f3 100644
--- a/photopicker/res/values/feature_profiles_strings.xml
+++ b/photopicker/res/values/feature_profiles_strings.xml
@@ -26,6 +26,9 @@
   <!-- Button accessibility description -->
   <string name="photopicker_profile_switch_button_description" translation_description="Button accessibility description for switching user profiles">Switch User Profile</string>
 
+  <!-- Selected profile accessibility description -->
+  <string name="photopicker_selected_profile_description" translation_description="Profile selector menu description prefix for the currently selected user profile">Selected <xliff:g id="profile_name" example="Personal">%1$s</xliff:g></string>
+
   <!-- Profile unavailable dialog title -->
   <string name="photopicker_profile_unavailable_dialog_title" translation_description="Dialog title stating a user profile cannot be switched to due to it being unavailable."><xliff:g id="profile_name" example="Personal">%1$s</xliff:g> apps are paused</string>
   <string name="photopicker_profile_blocked_by_admin_dialog_title" translation_description="Dialog title stating a user profile cannot be switched to due to admin policy.">Blocked by your admin</string>
diff --git a/photopicker/res/values/feature_search_strings.xml b/photopicker/res/values/feature_search_strings.xml
index 75c0f2366..09fde82ae 100644
--- a/photopicker/res/values/feature_search_strings.xml
+++ b/photopicker/res/values/feature_search_strings.xml
@@ -19,5 +19,20 @@
     <string name="photopicker_search_placeholder_text" translation_description="Place holder text shown in Search Bar">Search</string>
 
     <!-- Search view placeholder text -->
-    <string name="photopicker_searchView_placeholder_text" translation_description="Place holder text shown in Search Bar">Search your photos</string>
+    <string name="photopicker_search_photos_placeholder_text" translation_description="Place holder text shown in Search Bar">Search your photos</string>
+
+    <!-- Search view placeholder text when videos MIME type filter is applied-->
+    <string name="photopicker_search_videos_placeholder_text" translation_description="Place holder text shown in Search Bar for videos MIME type filter">Search your videos</string>
+
+    <!-- Empty state title when the search has no results -->
+    <string name="photopicker_search_result_empty_state_title" translation_description="Title of the message shown to the user when there are no search results to show">No results found</string>
+
+    <!-- Empty state message when search has no results -->
+    <string name="photopicker_search_result_empty_state_body" translation_description="Message shown to the user when no search results are able to be shown underneath the primary message title">Try searching for similar words</string>
+
+    <!-- Suggestions title in the search view suggestions list -->
+    <string name="photopicker_search_suggestions_text" translation_description="Title in the search suggestions list">Suggestions</string>
+
+    <!-- Search disabled hint message -->
+    <string name="photopicker_search_disabled_hint" translation_description="Hint message shown on search bar click when search state is not enabled">Search disabled.</string>
 </resources>
diff --git a/photopicker/res/values/overlayable.xml b/photopicker/res/values/overlayable.xml
new file mode 100644
index 000000000..a81d4b389
--- /dev/null
+++ b/photopicker/res/values/overlayable.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8" ?>
+<!-- Copyright (C) 2024 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<resources xmlns:android="http://schemas.android.com/apk/res/android">
+    <overlayable name="PhotoPickerConfig">
+        <policy type="product|system|vendor">
+            <item type="bool" name="config_enablePhotopickerDeviceConfigReceiver"/>
+        </policy>
+    </overlayable>
+</resources>
\ No newline at end of file
diff --git a/photopicker/src/com/android/photopicker/MainActivity.kt b/photopicker/src/com/android/photopicker/MainActivity.kt
index 6eb1c5426..0d35f0c50 100644
--- a/photopicker/src/com/android/photopicker/MainActivity.kt
+++ b/photopicker/src/com/android/photopicker/MainActivity.kt
@@ -48,29 +48,30 @@ import com.android.photopicker.core.banners.BannerManager
 import com.android.photopicker.core.configuration.ConfigurationManager
 import com.android.photopicker.core.configuration.IllegalIntentExtraException
 import com.android.photopicker.core.configuration.LocalPhotopickerConfiguration
-import com.android.photopicker.core.configuration.PhotopickerRuntimeEnv
 import com.android.photopicker.core.events.Event
 import com.android.photopicker.core.events.Events
 import com.android.photopicker.core.events.LocalEvents
 import com.android.photopicker.core.events.PhotopickerEventLogger
 import com.android.photopicker.core.events.Telemetry
+import com.android.photopicker.core.events.dispatchReportPhotopickerApiInfoEvent
+import com.android.photopicker.core.events.dispatchReportPhotopickerMediaItemStatusEvent
+import com.android.photopicker.core.events.dispatchReportPhotopickerSessionInfoEvent
 import com.android.photopicker.core.features.FeatureManager
-import com.android.photopicker.core.features.FeatureToken
 import com.android.photopicker.core.features.LocalFeatureManager
-import com.android.photopicker.core.navigation.PhotopickerDestinations
 import com.android.photopicker.core.selection.GrantsAwareSelectionImpl
 import com.android.photopicker.core.selection.LocalSelection
 import com.android.photopicker.core.selection.Selection
-import com.android.photopicker.core.theme.AccentColorHelper
 import com.android.photopicker.core.theme.PhotopickerTheme
 import com.android.photopicker.core.user.UserMonitor
-import com.android.photopicker.core.user.UserProfile
 import com.android.photopicker.data.DataService
 import com.android.photopicker.data.model.Media
-import com.android.photopicker.data.model.MediaSource
 import com.android.photopicker.extensions.canHandleGetContentIntentMimeTypes
-import com.android.photopicker.extensions.getUserProfilesVisibleToPhotopicker
-import com.android.photopicker.features.cloudmedia.CloudMediaFeature
+import com.android.photopicker.features.preparemedia.PrepareMediaFeature
+import com.android.photopicker.features.preparemedia.PrepareMediaResult
+import com.android.photopicker.features.preparemedia.PrepareMediaResult.PrepareMediaFailed
+import com.android.photopicker.features.preparemedia.PrepareMediaResult.PreparedMedia
+import com.android.photopicker.util.LocalLocalizationHelper
+import com.android.photopicker.util.rememberLocalizationHelper
 import dagger.Lazy
 import dagger.hilt.android.AndroidEntryPoint
 import dagger.hilt.android.scopes.ActivityRetainedScoped
@@ -127,27 +128,27 @@ class MainActivity : Hilt_MainActivity() {
     private lateinit var photopickerEventLogger: PhotopickerEventLogger
 
     /**
-     * A flow used to trigger the preloader. When media is ready to be preloaded it should be
-     * provided to the preloader by emitting into this flow.
+     * A flow used to trigger the preparer. When media is ready to be prepared it should be provided
+     * to the preparer by emitting into this flow.
      *
-     * The main activity should create a new [_preloadDeferred] before emitting, and then monitor
-     * that deferred to obtain the result of the preload operation that this flow will trigger.
+     * The main activity should create a new [_prepareDeferred] before emitting, and then monitor
+     * that deferred to obtain the result of the prepare operation that this flow will trigger.
      */
-    private val preloadMedia: MutableSharedFlow<Set<Media>> = MutableSharedFlow()
+    private val prepareMedia: MutableSharedFlow<Set<Media>> = MutableSharedFlow()
 
     /**
-     * A deferred which tracks the current state of any preload operation requested by the main
+     * A deferred which tracks the current state of any prepare operation requested by the main
      * activity.
      */
-    private var _preloadDeferred: CompletableDeferred<Boolean> = CompletableDeferred()
+    private var _prepareDeferred: CompletableDeferred<PrepareMediaResult> = CompletableDeferred()
 
     /**
      * Public access to the deferred, behind a getter. (To ensure any access to this property always
      * obtains the latest value)
      */
-    val preloadDeferred: CompletableDeferred<Boolean>
+    val prepareDeferred: CompletableDeferred<PrepareMediaResult>
         get() {
-            return _preloadDeferred
+            return _prepareDeferred
         }
 
     /**
@@ -222,6 +223,7 @@ class MainActivity : Hilt_MainActivity() {
                 LocalPhotopickerConfiguration provides photopickerConfiguration,
                 LocalSelection provides selection.get(),
                 LocalEvents provides events.get(),
+                LocalLocalizationHelper provides rememberLocalizationHelper(),
             ) {
                 PhotopickerTheme(config = photopickerConfiguration) {
                     PhotopickerAppWithBottomSheet(
@@ -232,8 +234,8 @@ class MainActivity : Hilt_MainActivity() {
                                 withContext(background) { onMediaSelectionConfirmed() }
                             }
                         },
-                        preloadMedia = preloadMedia,
-                        obtainPreloaderDeferred = { preloadDeferred },
+                        prepareMedia = prepareMedia,
+                        obtainPreparerDeferred = { prepareDeferred },
                         disruptiveDataNotification,
                     )
                 }
@@ -246,7 +248,7 @@ class MainActivity : Hilt_MainActivity() {
                 override fun handleOnBackPressed() {
                     isPickerClosedByBackGesture = true
                 }
-            }
+            },
         )
 
         // Log the picker launch details
@@ -271,9 +273,6 @@ class MainActivity : Hilt_MainActivity() {
 
     /** Dispatches an event to log all details with which the photopicker launched */
     private fun reportPhotopickerApiInfo() {
-        val intent = getIntent()
-        val dispatcherToken = FeatureToken.CORE.token
-        val sessionId = configurationManager.configuration.value.sessionId
         val intentAction =
             when (intent.action) {
                 MediaStore.ACTION_PICK_IMAGES -> Telemetry.PickerIntentAction.ACTION_PICK_IMAGES
@@ -282,81 +281,13 @@ class MainActivity : Hilt_MainActivity() {
                     Telemetry.PickerIntentAction.ACTION_USER_SELECT
                 else -> Telemetry.PickerIntentAction.UNSET_PICKER_INTENT_ACTION
             }
-        // We always launch the picker in collapsed state. We track change in the picker bottom
-        // sheet as UI event
-        val pickerSize = Telemetry.PickerSize.COLLAPSED
-        val mediaFilters = configurationManager.configuration.value.mimeTypes
-        val pickItemsMax = configurationManager.configuration.value.selectionLimit
-        val pickerConfig = configurationManager.configuration.value
-        val launchTab = configurationManager.configuration.value.startDestination
-        val selectedTab =
-            when (launchTab) {
-                PhotopickerDestinations.PHOTO_GRID -> Telemetry.SelectedTab.PHOTOS
-                PhotopickerDestinations.ALBUM_GRID -> Telemetry.SelectedTab.ALBUMS
-                else -> Telemetry.SelectedTab.UNSET_SELECTED_TAB
-            }
 
-        val selectedAlbum = Telemetry.SelectedAlbum.UNSET_SELECTED_ALBUM
-        val isOrderedSelectionSet = pickerConfig.pickImagesInOrder
-        // TODO Creating a new instance of AccentColorHelper() to check color seems unnecessary.
-        // Fix later
-        val isAccentColorSet = AccentColorHelper.withIntent(intent).isValidAccentColorSet()
-        val isLaunchTabSet = pickerConfig.startDestination != PhotopickerDestinations.DEFAULT
-        // TODO Update when search is added
-        val isSearchEnabled = false
-        var mediaFilter = Telemetry.MediaType.UNSET_MEDIA_TYPE
-        if (mediaFilters.size > 1) {
-            for (filter in mediaFilters) {
-                if (filter.contains("image") && filter.contains("video")) {
-                    mediaFilter = Telemetry.MediaType.PHOTO_VIDEO
-                } else if (filter.startsWith("image/")) {
-                    mediaFilter = Telemetry.MediaType.PHOTO
-                } else if (filter.startsWith("video/")) {
-                    mediaFilter = Telemetry.MediaType.VIDEO
-                }
-                lifecycleScope.launch {
-                    events
-                        .get()
-                        .dispatch(
-                            Event.ReportPhotopickerApiInfo(
-                                dispatcherToken,
-                                sessionId,
-                                intentAction,
-                                pickerSize,
-                                mediaFilter,
-                                pickItemsMax,
-                                selectedTab,
-                                selectedAlbum,
-                                isOrderedSelectionSet,
-                                isAccentColorSet,
-                                isLaunchTabSet,
-                                isSearchEnabled
-                            )
-                        )
-                }
-            }
-        } else {
-            lifecycleScope.launch {
-                events
-                    .get()
-                    .dispatch(
-                        Event.ReportPhotopickerApiInfo(
-                            dispatcherToken,
-                            sessionId,
-                            intentAction,
-                            pickerSize,
-                            mediaFilter,
-                            pickItemsMax,
-                            selectedTab,
-                            selectedAlbum,
-                            isOrderedSelectionSet,
-                            isAccentColorSet,
-                            isLaunchTabSet,
-                            isSearchEnabled
-                        )
-                    )
-            }
-        }
+        dispatchReportPhotopickerApiInfoEvent(
+            coroutineScope = lifecycleScope,
+            lazyEvents = events,
+            photopickerConfiguration = configurationManager.configuration.value,
+            pickerIntentAction = intentAction,
+        )
     }
 
     /**
@@ -398,50 +329,12 @@ class MainActivity : Hilt_MainActivity() {
 
     /** Dispatches an event to log all the final state details of the picker */
     private fun reportSessionInfo() {
-        val configuration = configurationManager.configuration.value
-        val pickerSelection =
-            if (configuration.selectionLimit == 1) {
-                Telemetry.PickerSelection.SINGLE
-            } else {
-                Telemetry.PickerSelection.MULTIPLE
-            }
-        val cloudProviderUid =
-            dataService
-                .get()
-                .availableProviders
-                .value
-                .filter { provider -> provider.mediaSource == MediaSource.REMOTE }
-                .firstOrNull()
-                ?.uid ?: -1
-        val userProfileType = userMonitor.get().userStatus.value.activeUserProfile.profileType
-        val currentActiveProfile =
-            when (userProfileType) {
-                UserProfile.ProfileType.PRIMARY -> Telemetry.UserProfile.PERSONAL
-                UserProfile.ProfileType.MANAGED -> Telemetry.UserProfile.WORK
-                else -> Telemetry.UserProfile.UNKNOWN
-            }
-        val pickedMediaItemsSet = selection.get().flow.value
         val pickerStatus =
             if (activityResultSet == RESULT_CANCELED) {
                 Telemetry.PickerStatus.CANCELED
             } else {
                 Telemetry.PickerStatus.CONFIRMED
             }
-        val pickedItemsCount = pickedMediaItemsSet.size
-        var pickedItemsSize = 0
-        for (mediaItem in pickedMediaItemsSet) {
-            pickedItemsSize += mediaItem.sizeInBytes.toInt()
-        }
-        val pickerMode =
-            when {
-                configuration.action.equals(MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP) ->
-                    Telemetry.PickerMode.PERMISSION_MODE_PICKER
-                configuration.runtimeEnv.equals(PhotopickerRuntimeEnv.ACTIVITY) ->
-                    Telemetry.PickerMode.REGULAR_PICKER
-                configuration.runtimeEnv.equals(PhotopickerRuntimeEnv.EMBEDDED) ->
-                    Telemetry.PickerMode.EMBEDDED_PICKER
-                else -> Telemetry.PickerMode.UNSET_PICKER_MODE
-            }
         val pickerCloseMethod =
             if (isPickerClosedByBackGesture) {
                 Telemetry.PickerCloseMethod.BACK_BUTTON
@@ -451,28 +344,16 @@ class MainActivity : Hilt_MainActivity() {
                 Telemetry.PickerCloseMethod.SWIPE_DOWN
             }
 
-        lifecycleScope.launch {
-            val profileSwitchButtonVisible =
-                userMonitor.get().userStatus.getUserProfilesVisibleToPhotopicker().first().size > 1
-            events
-                .get()
-                .dispatch(
-                    Event.ReportPhotopickerSessionInfo(
-                        FeatureToken.CORE.token,
-                        configuration.sessionId,
-                        configuration.callingPackageUid ?: -1,
-                        pickerSelection,
-                        cloudProviderUid,
-                        currentActiveProfile,
-                        pickerStatus,
-                        pickedItemsCount,
-                        pickedItemsSize,
-                        profileSwitchButtonVisible,
-                        pickerMode,
-                        pickerCloseMethod
-                    )
-                )
-        }
+        dispatchReportPhotopickerSessionInfoEvent(
+            coroutineScope = lifecycleScope,
+            lazyEvents = events,
+            photopickerConfiguration = configurationManager.configuration.value,
+            lazyDataService = dataService,
+            lazyUserMonitor = userMonitor,
+            lazyMediaSelection = selection,
+            pickerStatus = pickerStatus,
+            pickerCloseMethod = pickerCloseMethod,
+        )
     }
 
     /**
@@ -562,33 +443,40 @@ class MainActivity : Hilt_MainActivity() {
     suspend fun onMediaSelectionConfirmed() {
 
         val snapshot = selection.get().snapshot()
-        // Determine if any preload of the selected media needs to happen, and
-        // await the result of the preloader before proceeding.
-        if (featureManager.get().isFeatureEnabled(CloudMediaFeature::class.java)) {
+        var selection = snapshot
+        // Determine if any prepare of the selected media needs to happen, and
+        // await the result of the preparer before proceeding.
+        if (featureManager.get().isFeatureEnabled(PrepareMediaFeature::class.java)) {
 
             // Create a new [CompletableDeferred] that represents the result of this
-            // preload operation
-            _preloadDeferred = CompletableDeferred()
-            preloadMedia.emit(snapshot)
+            // prepare operation
+            _prepareDeferred = CompletableDeferred()
+            prepareMedia.emit(snapshot)
 
             // Await a response from the deferred before proceeding.
             // This will suspend until the response is available.
-            val preloadSuccessful = _preloadDeferred.await()
+            val prepareResult = _prepareDeferred.await()
+            if (prepareResult is PreparedMedia) {
+                selection = prepareResult.preparedMedia
+            } else {
+                if (prepareResult !is PrepareMediaFailed) {
+                    Log.e(TAG, "Expected prepare result object was not a PrepareMediaFailed")
+                }
 
-            // The preload failed, so the activity cannot be completed.
-            if (!preloadSuccessful) {
+                // The prepare failed, so the activity cannot be completed.
                 return
             }
         }
-        val deselectionSnapshot = selection.get().getDeselection().toHashSet()
-        onMediaSelectionReady(snapshot, deselectionSnapshot)
+
+        val deselectionSnapshot = this.selection.get().getDeselection().toHashSet()
+        onMediaSelectionReady(selection, deselectionSnapshot)
     }
 
     /**
      * This will end the activity.
      *
      * This method should be called when the user has confirmed their selection of media and would
-     * like to exit the Photopicker. All Media preloading should be completed before this method is
+     * like to exit the Photopicker. All Media preparing should be completed before this method is
      * invoked. This method will then arrange for the correct data to be returned based on the
      * configuration Photopicker is running under.
      *
@@ -649,7 +537,7 @@ class MainActivity : Hilt_MainActivity() {
                 ClipData(
                     /* label= */ null,
                     /* mimeTypes= */ selection.map { it.mimeType }.distinct().toTypedArray(),
-                    /* item= */ ClipData.Item(uris.removeFirst())
+                    /* item= */ ClipData.Item(uris.removeFirst()),
                 )
 
             // If there are any remaining items in the list, attach those as additional
@@ -675,50 +563,16 @@ class MainActivity : Hilt_MainActivity() {
 
     /** Dispatches an Event to log details of all the picked media items */
     private fun dispatchSelectedMediaItemsStatusEvent(selection: Set<Media>) {
-        val sessionId = configurationManager.configuration.value.sessionId
         val mediaStatus = Telemetry.MediaStatus.SELECTED
 
         for (mediaItem in selection) {
-            // TODO Update the media item position here once the Media class holds the resultIndex
-            //  property: b/342555096
-            val itemPosition = 0
-            val mimeType = mediaItem.mimeType
-            // TODO find live photo format
-            val mediaType =
-                if (mimeType.startsWith("image/")) {
-                    if (mimeType.contains("gif")) {
-                        Telemetry.MediaType.GIF
-                    } else {
-                        Telemetry.MediaType.PHOTO
-                    }
-                } else if (mimeType.startsWith("video/")) {
-                    Telemetry.MediaType.VIDEO
-                } else {
-                    Telemetry.MediaType.OTHER
-                }
-
-            val cloudOnly = mediaItem.mediaSource == MediaSource.REMOTE
-            // TODO Keeping for now while the field still exists in the actual atom to prevent the
-            // picker from crashing on selection with a null value
-            val pickerSize = Telemetry.PickerSize.EXPANDED
-            lifecycleScope.launch {
-                events
-                    .get()
-                    .dispatch(
-                        Event.ReportPhotopickerMediaItemStatus(
-                            FeatureToken.CORE.token,
-                            sessionId,
-                            mediaStatus,
-                            mediaItem.selectionSource
-                                ?: Telemetry.MediaLocation.UNSET_MEDIA_LOCATION,
-                            itemPosition,
-                            mediaItem.mediaItemAlbum,
-                            mediaType,
-                            cloudOnly,
-                            pickerSize
-                        )
-                    )
-            }
+            dispatchReportPhotopickerMediaItemStatusEvent(
+                coroutineScope = lifecycleScope,
+                lazyEvents = events,
+                photopickerConfiguration = configurationManager.configuration.value,
+                mediaItem = mediaItem,
+                mediaStatus = mediaStatus,
+            )
         }
     }
 
@@ -742,7 +596,7 @@ class MainActivity : Hilt_MainActivity() {
     private suspend fun updateGrantsForApp(
         currentSelection: Set<Media>,
         currentDeSelection: Set<Media>,
-        uid: Int
+        uid: Int,
     ) {
 
         val selection = selection.get()
@@ -761,7 +615,7 @@ class MainActivity : Hilt_MainActivity() {
             MediaStore.revokeMediaReadForPackages(
                 getApplicationContext(),
                 uid,
-                urisForItemsToBeRevoked
+                urisForItemsToBeRevoked,
             )
         }
         // Adding grants for items selected by the user.
diff --git a/photopicker/src/com/android/photopicker/core/PhotopickerApp.kt b/photopicker/src/com/android/photopicker/core/PhotopickerApp.kt
index 7a508e27d..881270e34 100644
--- a/photopicker/src/com/android/photopicker/core/PhotopickerApp.kt
+++ b/photopicker/src/com/android/photopicker/core/PhotopickerApp.kt
@@ -73,6 +73,7 @@ import com.android.photopicker.core.navigation.PhotopickerNavGraph
 import com.android.photopicker.core.selection.LocalSelection
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.extensions.transferTouchesToHostInEmbedded
+import com.android.photopicker.features.preparemedia.PrepareMediaResult
 import kotlinx.coroutines.CompletableDeferred
 import kotlinx.coroutines.flow.Flow
 import kotlinx.coroutines.launch
@@ -98,9 +99,9 @@ private val NAV_BAR_EMBEDDED_EXIT_ANIMATION =
  * @param onDismissRequest handler for when the BottomSheet is dismissed.
  * @param onMediaSelectionConfirmed A callback to pass to the [Location.SELECTION_BAR] to indicate
  *   the user has indicated the media selection is final.
- * @param preloadMedia A flow of Media that the [MEDIA_PRELOADER] should begin preloading.
- * @param obtainPreloaderDeferred A callback to obtain a deferred for the currently requested media
- *   preload.
+ * @param prepareMedia A flow of Media that the [MEDIA_PREPARER] should begin preparing.
+ * @param obtainPreparerDeferred A callback to obtain a deferred for the currently requested media
+ *   prepare.
  * @param disruptiveDataNotification The data disruption flow that emits when the underlying data
  *   the UI has been created with is invalid
  */
@@ -109,8 +110,8 @@ private val NAV_BAR_EMBEDDED_EXIT_ANIMATION =
 fun PhotopickerAppWithBottomSheet(
     onDismissRequest: () -> Unit,
     onMediaSelectionConfirmed: () -> Unit,
-    preloadMedia: Flow<Set<Media>>,
-    obtainPreloaderDeferred: () -> CompletableDeferred<Boolean>,
+    prepareMedia: Flow<Set<Media>>,
+    obtainPreparerDeferred: () -> CompletableDeferred<PrepareMediaResult>,
     disruptiveDataNotification: Flow<Int>,
 ) {
     // Initialize and remember the NavController. This needs to be provided before the call to
@@ -199,7 +200,12 @@ fun PhotopickerAppWithBottomSheet(
                         modifier = Modifier.fillMaxHeight(),
                         contentAlignment = Alignment.BottomCenter,
                     ) {
-                        PhotopickerMain(disruptiveDataNotification)
+                        PhotopickerMain(
+                            disruptiveDataNotification,
+                            onSearchBarClicked = {
+                                scope.launch { state.bottomSheetState.expand() }
+                            },
+                        )
                         Column(
                             modifier =
                                 // Some elements needs to be drawn over the UI inside of the
@@ -225,20 +231,21 @@ fun PhotopickerAppWithBottomSheet(
                             )
                         }
                     }
-                    // If a [MEDIA_PRELOADER] is configured in the current session, attach it
+                    // If a [MEDIA_PREPARER] is configured in the current session, attach it
                     // to the compose UI here, so that any dialogs it shows are drawn overtop
                     // of the application.
+                    val params =
+                        object : LocationParams.WithMediaPreparer {
+                            override fun obtainDeferred(): CompletableDeferred<PrepareMediaResult> {
+                                return obtainPreparerDeferred()
+                            }
+
+                            override val prepareMedia = prepareMedia
+                        }
                     LocalFeatureManager.current.composeLocation(
-                        Location.MEDIA_PRELOADER,
+                        Location.MEDIA_PREPARER,
                         maxSlots = 1,
-                        params =
-                            object : LocationParams.WithMediaPreloader {
-                                override fun obtainDeferred(): CompletableDeferred<Boolean> {
-                                    return obtainPreloaderDeferred()
-                                }
-
-                                override val preloadMedia = preloadMedia
-                            },
+                        params = params,
                     )
                 },
             ) {
@@ -302,9 +309,11 @@ fun PhotopickerApp(disruptiveDataNotification: Flow<Int>, onMediaSelectionConfir
  *
  * @param disruptiveDataNotification The data disruption flow that emits when the underlying data
  *   the UI has been created with is invalid
+ * @param onSearchBarClicked A callback to pass to the [Location.SEARCH_BAR] from
+ *   [Location.NAVIGATION_BAR] to indicate the user has clicked on Search Bar.
  */
 @Composable
-fun PhotopickerMain(disruptiveDataNotification: Flow<Int>) {
+fun PhotopickerMain(disruptiveDataNotification: Flow<Int>, onSearchBarClicked: () -> Unit = {}) {
 
     // Collect the data disrupt flow so that Photopicker will navigate on disruptive data changes.
     // The data service can detect when the providers that are supplying grid data have changed
@@ -338,6 +347,7 @@ fun PhotopickerMain(disruptiveDataNotification: Flow<Int>) {
                         } else {
                             Modifier.fillMaxWidth()
                         },
+                    params = LocationParams.WithClickAction { onSearchBarClicked() },
                 )
             }
 
diff --git a/photopicker/src/com/android/photopicker/core/animations/Animations.kt b/photopicker/src/com/android/photopicker/core/animations/Animations.kt
index e23ce4893..87e1e248e 100644
--- a/photopicker/src/com/android/photopicker/core/animations/Animations.kt
+++ b/photopicker/src/com/android/photopicker/core/animations/Animations.kt
@@ -19,19 +19,43 @@ package com.android.photopicker.core.animations
 import android.view.animation.PathInterpolator
 import androidx.compose.animation.core.Easing
 import androidx.compose.animation.core.FiniteAnimationSpec
+import androidx.compose.animation.core.spring
 import androidx.compose.animation.core.tween
 import androidx.compose.ui.unit.IntOffset
+import androidx.compose.ui.unit.IntSize
 
 /** From the material-3 emphasized easing set */
 val emphasizedDecelerate: FiniteAnimationSpec<IntOffset> =
     tween(
         durationMillis = 400,
-        easing = Easing { PathInterpolator(0.05f, 0.7f, 0.1f, 1f).getInterpolation(it) }
+        easing = Easing { PathInterpolator(0.05f, 0.7f, 0.1f, 1f).getInterpolation(it) },
     )
 
 /** From the material-3 emphasized easing set */
 val emphasizedAccelerate: FiniteAnimationSpec<IntOffset> =
     tween(
         durationMillis = 200,
-        easing = Easing { PathInterpolator(0.03f, 0f, 0.8f, 0.15f).getInterpolation(it) }
+        easing = Easing { PathInterpolator(0.03f, 0f, 0.8f, 0.15f).getInterpolation(it) },
+    )
+
+/** From the material-3 motion physics system */
+val springDefaultEffectFloat: FiniteAnimationSpec<Float> =
+    spring(dampingRatio = 0.8f, stiffness = 380f)
+
+/** From the material-3 motion physics system */
+val springDefaultEffectOffset: FiniteAnimationSpec<IntOffset> =
+    spring(dampingRatio = 0.8f, stiffness = 380f)
+
+/** From the material-3 emphasized easing set */
+val emphasizedAccelerateFloat: FiniteAnimationSpec<Float> =
+    tween(
+        durationMillis = 150,
+        easing = Easing { PathInterpolator(0.3f, 0f, 0.8f, 0.15f).getInterpolation(it) },
+    )
+
+/** From the material-3 standard easing set */
+fun standardDecelerate(durationMillis: Int = 200): FiniteAnimationSpec<IntSize> =
+    tween(
+        durationMillis = durationMillis,
+        easing = Easing { PathInterpolator(0f, 0f, 0f, 1f).getInterpolation(it) },
     )
diff --git a/photopicker/src/com/android/photopicker/core/components/mediagrid/MediaGrid.kt b/photopicker/src/com/android/photopicker/core/components/mediagrid/MediaGrid.kt
index bf4e9d2f4..c3a94ba88 100644
--- a/photopicker/src/com/android/photopicker/core/components/mediagrid/MediaGrid.kt
+++ b/photopicker/src/com/android/photopicker/core/components/mediagrid/MediaGrid.kt
@@ -25,10 +25,10 @@ import android.provider.MediaStore.Files.FileColumns._SPECIAL_FORMAT_GIF
 import android.provider.MediaStore.Files.FileColumns._SPECIAL_FORMAT_MOTION_PHOTO
 import android.text.format.DateUtils
 import androidx.compose.animation.AnimatedVisibility
-import androidx.compose.animation.ExitTransition
 import androidx.compose.animation.core.animateDpAsState
 import androidx.compose.animation.core.tween
 import androidx.compose.animation.scaleIn
+import androidx.compose.animation.scaleOut
 import androidx.compose.foundation.background
 import androidx.compose.foundation.border
 import androidx.compose.foundation.gestures.animateScrollBy
@@ -70,6 +70,7 @@ import androidx.compose.runtime.getValue
 import androidx.compose.runtime.mutableStateOf
 import androidx.compose.runtime.remember
 import androidx.compose.runtime.rememberUpdatedState
+import androidx.compose.runtime.setValue
 import androidx.compose.ui.AbsoluteAlignment
 import androidx.compose.ui.Alignment
 import androidx.compose.ui.Modifier
@@ -79,6 +80,7 @@ import androidx.compose.ui.graphics.vector.ImageVector
 import androidx.compose.ui.input.pointer.pointerInput
 import androidx.compose.ui.res.stringResource
 import androidx.compose.ui.res.vectorResource
+import androidx.compose.ui.semantics.clearAndSetSemantics
 import androidx.compose.ui.semantics.contentDescription
 import androidx.compose.ui.semantics.onClick
 import androidx.compose.ui.semantics.onLongClick
@@ -92,6 +94,8 @@ import androidx.paging.compose.LazyPagingItems
 import androidx.paging.compose.collectAsLazyPagingItems
 import com.android.modules.utils.build.SdkLevel
 import com.android.photopicker.R
+import com.android.photopicker.core.animations.emphasizedAccelerateFloat
+import com.android.photopicker.core.animations.springDefaultEffectFloat
 import com.android.photopicker.core.components.MediaGridItem.Companion.defaultBuildContentType
 import com.android.photopicker.core.configuration.LocalPhotopickerConfiguration
 import com.android.photopicker.core.configuration.PhotopickerRuntimeEnv
@@ -106,6 +110,9 @@ import com.android.photopicker.extensions.insertMonthSeparators
 import com.android.photopicker.extensions.toMediaGridItemFromAlbum
 import com.android.photopicker.extensions.toMediaGridItemFromMedia
 import com.android.photopicker.extensions.transferGridTouchesToHostInEmbedded
+import com.android.photopicker.util.LocalLocalizationHelper
+import com.android.photopicker.util.getMediaContentDescription
+import java.text.DateFormat
 import java.text.NumberFormat
 
 /** The number of grid cells per row for Phone / narrow layouts */
@@ -212,8 +219,9 @@ fun mediaGrid(
             isSelected: Boolean,
             onClick: ((item: MediaGridItem) -> Unit)?,
             onLongPress: ((item: MediaGridItem) -> Unit)?,
+            dateFormat: DateFormat,
         ) -> Unit =
-        { item, isSelected, onClick, onLongPress ->
+        { item, isSelected, onClick, onLongPress, dateFormat ->
             when (item) {
                 is MediaGridItem.MediaItem ->
                     defaultBuildMediaItem(
@@ -222,6 +230,7 @@ fun mediaGrid(
                         selectedPosition = selection.indexOf(item.media),
                         onClick = onClick,
                         onLongPress = onLongPress,
+                        dateFormat = dateFormat,
                     )
 
                 is MediaGridItem.AlbumItem -> defaultBuildAlbumItem(item, onClick)
@@ -237,6 +246,11 @@ fun mediaGrid(
     val isEmbedded =
         LocalPhotopickerConfiguration.current.runtimeEnv == PhotopickerRuntimeEnv.EMBEDDED
     val host = LocalEmbeddedState.current?.host
+    val dateFormat =
+        LocalLocalizationHelper.current.getLocalizedDateTimeFormatter(
+            dateStyle = DateFormat.MEDIUM,
+            timeStyle = DateFormat.SHORT,
+        )
 
     /**
      * Bottom sheet current state in runtime Embedded Photopicker. This assignment is necessary to
@@ -287,6 +301,7 @@ fun mediaGrid(
                             selection.contains(item.media),
                             onItemClick,
                             onItemLongPress,
+                            dateFormat,
                         )
 
                     is MediaGridItem.AlbumItem ->
@@ -295,6 +310,7 @@ fun mediaGrid(
                             /* isSelected */ false,
                             onItemClick,
                             onItemLongPress,
+                            dateFormat,
                         )
 
                     is MediaGridItem.SeparatorItem -> contentSeparatorFactory(item)
@@ -357,6 +373,7 @@ private fun defaultBuildMediaItem(
     selectedPosition: Int,
     onClick: ((item: MediaGridItem) -> Unit)?,
     onLongPress: ((item: MediaGridItem) -> Unit)?,
+    dateFormat: DateFormat,
 ) {
     when (item) {
         is MediaGridItem.MediaItem -> {
@@ -383,7 +400,7 @@ private fun defaultBuildMediaItem(
             val selectedModifier =
                 baseModifier.clip(RoundedCornerShape(MEASUREMENT_SELECTED_CORNER_RADIUS))
 
-            val mediaDescription = stringResource(R.string.photopicker_media_item)
+            val mediaDescription = getMediaContentDescription(item.media, dateFormat)
 
             // Wrap the entire Grid cell in a box for handling aspectRatio and clicks.
             Box(
@@ -468,6 +485,7 @@ private fun MimeTypeOverlay(item: MediaGridItem.MediaItem) {
                 Text(
                     text = DateUtils.formatElapsedTime(item.media.duration / 1000L),
                     style = MaterialTheme.typography.labelSmall,
+                    modifier = Modifier.clearAndSetSemantics {},
                 )
                 Spacer(Modifier.size(MEASUREMENT_DURATION_TEXT_SPACER_SIZE))
                 Icon(Icons.Filled.PlayCircle, contentDescription = null)
@@ -513,20 +531,26 @@ private fun SelectedIconOverlay(isSelected: Boolean, selectedIndex: Int) {
                         y = -MEASUREMENT_SELECTED_ICON_OFFSET,
                     ),
             visible = isSelected,
-            enter = scaleIn(),
-            // No exit transition so it disappears on the next frame.
-            exit = ExitTransition.None,
+            enter = scaleIn(animationSpec = springDefaultEffectFloat),
+            exit = scaleOut(animationSpec = emphasizedAccelerateFloat),
         ) {
             val configuration = LocalPhotopickerConfiguration.current
-            val shouldIndicateSelected = isSelected && configuration.selectionLimit > 1
+            val shouldIndicateSelected = configuration.selectionLimit > 1
             if (shouldIndicateSelected) {
                 when (configuration.pickImagesInOrder) {
                     true -> {
                         val numberFormatter = remember { NumberFormat.getInstance() }
+                        var rememberedIndex by remember { mutableStateOf(selectedIndex) }
+
+                        LaunchedEffect(isSelected, selectedIndex) {
+                            if (isSelected) {
+                                rememberedIndex = selectedIndex
+                            }
+                        }
                         Text(
                             // Since this is a 0-based index, increment it by 1 for displaying
                             // to the user.
-                            text = numberFormatter.format(selectedIndex + 1),
+                            text = numberFormatter.format(rememberedIndex + 1),
                             textAlign = TextAlign.Center,
                             modifier =
                                 Modifier.circleBackground(
diff --git a/photopicker/src/com/android/photopicker/core/configuration/ConfigurationManager.kt b/photopicker/src/com/android/photopicker/core/configuration/ConfigurationManager.kt
index 64327ad06..5054f17c7 100644
--- a/photopicker/src/com/android/photopicker/core/configuration/ConfigurationManager.kt
+++ b/photopicker/src/com/android/photopicker/core/configuration/ConfigurationManager.kt
@@ -23,8 +23,10 @@ import android.util.Log
 import android.widget.photopicker.EmbeddedPhotoPickerFeatureInfo
 import androidx.annotation.RequiresApi
 import androidx.compose.ui.graphics.isUnspecified
+import com.android.modules.utils.build.SdkLevel
 import com.android.photopicker.core.navigation.PhotopickerDestinations
 import com.android.photopicker.core.theme.AccentColorHelper
+import com.android.photopicker.extensions.getApplicationMediaCapabilities
 import com.android.photopicker.extensions.getPhotopickerMimeTypes
 import com.android.photopicker.extensions.getPhotopickerSelectionLimitOrDefault
 import com.android.photopicker.extensions.getPickImagesInOrderEnabled
@@ -38,7 +40,6 @@ import kotlinx.coroutines.channels.awaitClose
 import kotlinx.coroutines.flow.MutableStateFlow
 import kotlinx.coroutines.flow.StateFlow
 import kotlinx.coroutines.flow.callbackFlow
-import kotlinx.coroutines.flow.collect
 import kotlinx.coroutines.flow.debounce
 import kotlinx.coroutines.flow.updateAndGet
 import kotlinx.coroutines.launch
@@ -224,6 +225,18 @@ class ConfigurationManager(
         // get preSelection URIs from intent.
         val pickerPreSelectionUris = intent.getPickImagesPreSelectedUris()
 
+        // Get application media capabilities from intent. While ApplicationMediaCapabilities
+        // requires S+, we limit it use for transcoding to T+ for two reasons:
+        // 1. Underlying Transformer doesn't support S and S v2 due to inaccessible audio services.
+        // 2. HDR video, introduced in Android T, is where the need for transcoding comes from.
+        // For details, see b/365988031.
+        val applicationMediaCapabilities =
+            if (SdkLevel.isAtLeastT()) {
+                intent.getApplicationMediaCapabilities()
+            } else {
+                null
+            }
+
         // Use updateAndGet to ensure the value is set before this method returns so the new
         // intent is immediately available to new subscribers.
         _configuration.updateAndGet {
@@ -236,6 +249,7 @@ class ConfigurationManager(
                 pickImagesInOrder = pickImagesInOrder,
                 startDestination = startDestination,
                 preSelectedUris = pickerPreSelectionUris,
+                callingPackageMediaCapabilities = applicationMediaCapabilities,
             )
         }
     }
@@ -248,11 +262,7 @@ class ConfigurationManager(
      * @param callingPackageUid the uid of the caller
      * @param callingPackageLabel the display label of the caller
      */
-    fun setCaller(
-        callingPackage: String?,
-        callingPackageUid: Int?,
-        callingPackageLabel: String?,
-    ) {
+    fun setCaller(callingPackage: String?, callingPackageUid: Int?, callingPackageLabel: String?) {
         Log.d(TAG, "Caller information updated : Configuration will now update.")
         _configuration.updateAndGet {
             it.copy(
@@ -292,14 +302,14 @@ class ConfigurationManager(
                     deviceConfigProxy.getFlag(
                         NAMESPACE_MEDIAPROVIDER,
                         /* key= */ FEATURE_CLOUD_MEDIA_PROVIDER_ALLOWLIST.first,
-                        /* defaultValue= */ FEATURE_CLOUD_MEDIA_PROVIDER_ALLOWLIST.second
+                        /* defaultValue= */ FEATURE_CLOUD_MEDIA_PROVIDER_ALLOWLIST.second,
                     )
                 ),
             CLOUD_ENFORCE_PROVIDER_ALLOWLIST =
                 deviceConfigProxy.getFlag(
                     NAMESPACE_MEDIAPROVIDER,
                     /* key= */ FEATURE_CLOUD_ENFORCE_PROVIDER_ALLOWLIST.first,
-                    /* defaultValue= */ FEATURE_CLOUD_ENFORCE_PROVIDER_ALLOWLIST.second
+                    /* defaultValue= */ FEATURE_CLOUD_ENFORCE_PROVIDER_ALLOWLIST.second,
                 ),
             CLOUD_MEDIA_ENABLED =
                 deviceConfigProxy.getFlag(
@@ -320,6 +330,7 @@ class ConfigurationManager(
                     /* defaultValue= */ FEATURE_PICKER_CHOICE_MANAGED_SELECTION.second,
                 ),
             PICKER_SEARCH_ENABLED = Flags.enablePhotopickerSearch(),
+            PICKER_TRANSCODING_ENABLED = Flags.enablePhotopickerTranscoding(),
         )
     }
 
diff --git a/photopicker/src/com/android/photopicker/core/configuration/PhotopickerConfiguration.kt b/photopicker/src/com/android/photopicker/core/configuration/PhotopickerConfiguration.kt
index 52f3d1bc4..2b169311e 100644
--- a/photopicker/src/com/android/photopicker/core/configuration/PhotopickerConfiguration.kt
+++ b/photopicker/src/com/android/photopicker/core/configuration/PhotopickerConfiguration.kt
@@ -19,6 +19,7 @@ package com.android.photopicker.core.configuration
 import android.content.Intent
 import android.content.pm.PackageManager
 import android.content.pm.ResolveInfo
+import android.media.ApplicationMediaCapabilities
 import android.net.Uri
 import android.os.SystemProperties
 import android.provider.MediaStore
@@ -46,6 +47,8 @@ enum class PhotopickerRuntimeEnv {
  * @property callingPackage the package name of the caller
  * @property callingPackageUid the uid of the caller
  * @property callingPackageLabel the display label of the caller that can be shown to the user
+ * @property callingPackageMediaCapabilities the value of [MediaStore.EXTRA_MEDIA_CAPABILITIES]. If
+ *   set, represents the [ApplicationMediaCapabilities] of the calling package.
  * @property accentColor the accent color (if valid) from
  *   [MediaStore.EXTRA_PICK_IMAGES_ACCENT_COLOR]
  * @property mimeTypes the mimetypes to filter all media requests with for the current session.
@@ -70,6 +73,7 @@ data class PhotopickerConfiguration(
     val callingPackage: String? = null,
     val callingPackageUid: Int? = null,
     val callingPackageLabel: String? = null,
+    val callingPackageMediaCapabilities: ApplicationMediaCapabilities? = null,
     val accentColor: Long? = null,
     val mimeTypes: ArrayList<String> = arrayListOf("image/*", "video/*"),
     val pickImagesInOrder: Boolean = false,
@@ -127,9 +131,19 @@ data class PhotopickerConfiguration(
             // Log a warning that the intent was null, but probably shouldn't have been.
             ?: Log.w(
                 ConfigurationManager.TAG,
-                "No intent available for checking cross-profile access."
+                "No intent available for checking cross-profile access.",
             )
 
         return false
     }
+
+    /**
+     * Checks if mimeTypes contains only video MIME types and no image MIME types.
+     *
+     * @return `true` if mimeTypes list contains only video MIME types (starting with "video/") and
+     *   no image MIME types (starting with "image/"), `false` otherwise.
+     */
+    fun hasOnlyVideoMimeTypes(): Boolean {
+        return mimeTypes.isNotEmpty() && mimeTypes.all { it.startsWith("video/") }
+    }
 }
diff --git a/photopicker/src/com/android/photopicker/core/configuration/PhotopickerFlags.kt b/photopicker/src/com/android/photopicker/core/configuration/PhotopickerFlags.kt
index c446b5e11..e28fa83a8 100644
--- a/photopicker/src/com/android/photopicker/core/configuration/PhotopickerFlags.kt
+++ b/photopicker/src/com/android/photopicker/core/configuration/PhotopickerFlags.kt
@@ -44,7 +44,8 @@ data class PhotopickerFlags(
     val CLOUD_MEDIA_ENABLED: Boolean = FEATURE_CLOUD_MEDIA_FEATURE_ENABLED.second,
     val PRIVATE_SPACE_ENABLED: Boolean = FEATURE_PRIVATE_SPACE_ENABLED.second,
     val MANAGED_SELECTION_ENABLED: Boolean = FEATURE_PICKER_CHOICE_MANAGED_SELECTION.second,
-    val PICKER_SEARCH_ENABLED: Boolean = Flags.enablePhotopickerSearch()
+    val PICKER_SEARCH_ENABLED: Boolean = Flags.enablePhotopickerSearch(),
+    val PICKER_TRANSCODING_ENABLED: Boolean = Flags.enablePhotopickerTranscoding(),
 ) {
     /**
      * Implement a custom equals method to correctly check the equality of the Array member
@@ -59,6 +60,7 @@ data class PhotopickerFlags(
         if (PRIVATE_SPACE_ENABLED != other.PRIVATE_SPACE_ENABLED) return false
         if (MANAGED_SELECTION_ENABLED != other.MANAGED_SELECTION_ENABLED) return false
         if (PICKER_SEARCH_ENABLED != other.PICKER_SEARCH_ENABLED) return false
+        if (PICKER_TRANSCODING_ENABLED != other.PICKER_TRANSCODING_ENABLED) return false
 
         return true
     }
@@ -74,6 +76,7 @@ data class PhotopickerFlags(
             CLOUD_MEDIA_ENABLED,
             PRIVATE_SPACE_ENABLED,
             MANAGED_SELECTION_ENABLED,
-            PICKER_SEARCH_ENABLED
+            PICKER_SEARCH_ENABLED,
+            PICKER_TRANSCODING_ENABLED,
         )
 }
diff --git a/photopicker/src/com/android/photopicker/core/embedded/EmbeddedService.kt b/photopicker/src/com/android/photopicker/core/embedded/EmbeddedService.kt
index 5240526c5..34a04695f 100644
--- a/photopicker/src/com/android/photopicker/core/embedded/EmbeddedService.kt
+++ b/photopicker/src/com/android/photopicker/core/embedded/EmbeddedService.kt
@@ -68,7 +68,7 @@ class EmbeddedService : Hilt_EmbeddedService() {
         if (SdkLevel.isAtLeastU() && enableEmbeddedPhotopicker()) {
             EmbeddedPhotopickerImpl(
                 sessionFactory = ::buildSession,
-                verifyCaller = ::verifyCallerIdentity
+                verifyCaller = ::verifyCallerIdentity,
             )
         } else {
             // Embedded Photopicker is only available on U+ devices when the build flag is enabled.
@@ -105,7 +105,7 @@ class EmbeddedService : Hilt_EmbeddedService() {
     @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
     private fun cleanupSessions() {
         for (session in allSessions) {
-            if (session.isActive) {
+            if (session.isActive.get()) {
                 session.close()
             }
         }
@@ -184,7 +184,7 @@ class EmbeddedService : Hilt_EmbeddedService() {
      */
     enum class GrantResult {
         SUCCESS,
-        FAILURE
+        FAILURE,
     }
 
     /** Verify that package belongs to caller by mapping their uids */
diff --git a/photopicker/src/com/android/photopicker/core/embedded/EmbeddedViewModelFactory.kt b/photopicker/src/com/android/photopicker/core/embedded/EmbeddedViewModelFactory.kt
index 1f101a68f..37fa6fa8a 100644
--- a/photopicker/src/com/android/photopicker/core/embedded/EmbeddedViewModelFactory.kt
+++ b/photopicker/src/com/android/photopicker/core/embedded/EmbeddedViewModelFactory.kt
@@ -15,7 +15,6 @@
  */
 package com.android.photopicker.core.embedded
 
-import androidx.compose.runtime.getValue
 import androidx.lifecycle.ViewModel
 import androidx.lifecycle.ViewModelProvider
 import com.android.photopicker.core.Background
@@ -28,10 +27,12 @@ import com.android.photopicker.core.user.UserMonitor
 import com.android.photopicker.data.DataService
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.features.albumgrid.AlbumGridViewModel
-import com.android.photopicker.features.cloudmedia.MediaPreloaderViewModel
 import com.android.photopicker.features.photogrid.PhotoGridViewModel
+import com.android.photopicker.features.preparemedia.MediaPreparerViewModel
 import com.android.photopicker.features.preview.PreviewViewModel
 import com.android.photopicker.features.profileselector.ProfileSelectorViewModel
+import com.android.photopicker.features.search.SearchViewModel
+import com.android.photopicker.features.search.data.SearchDataService
 import dagger.Lazy
 import kotlinx.coroutines.CoroutineDispatcher
 
@@ -67,6 +68,7 @@ class EmbeddedViewModelFactory(
     val configurationManager: Lazy<ConfigurationManager>,
     val bannerManager: Lazy<BannerManager>,
     val dataService: Lazy<DataService>,
+    val searchDataService: Lazy<SearchDataService>,
     val events: Lazy<Events>,
     val featureManager: Lazy<FeatureManager>,
     val selection: Lazy<Selection<Media>>,
@@ -77,8 +79,8 @@ class EmbeddedViewModelFactory(
             return when {
                 isAssignableFrom(AlbumGridViewModel::class.java) ->
                     AlbumGridViewModel(null, selection.get(), dataService.get(), events.get()) as T
-                isAssignableFrom(MediaPreloaderViewModel::class.java) ->
-                    MediaPreloaderViewModel(
+                isAssignableFrom(MediaPreparerViewModel::class.java) ->
+                    MediaPreparerViewModel(
                         null,
                         backgroundDispatcher,
                         selection.get(),
@@ -112,7 +114,17 @@ class EmbeddedViewModelFactory(
                         selection.get(),
                         userMonitor.get(),
                         events.get(),
-                        configurationManager.get()
+                        configurationManager.get(),
+                    )
+                        as T
+                isAssignableFrom(SearchViewModel::class.java) ->
+                    SearchViewModel(
+                        null,
+                        backgroundDispatcher,
+                        searchDataService.get(),
+                        selection.get(),
+                        events.get(),
+                        configurationManager.get(),
                     )
                         as T
                 else ->
diff --git a/photopicker/src/com/android/photopicker/core/embedded/Session.kt b/photopicker/src/com/android/photopicker/core/embedded/Session.kt
index 2ecda1635..b02da977f 100644
--- a/photopicker/src/com/android/photopicker/core/embedded/Session.kt
+++ b/photopicker/src/com/android/photopicker/core/embedded/Session.kt
@@ -23,6 +23,7 @@ import android.hardware.display.DisplayManager
 import android.net.Uri
 import android.os.Build
 import android.os.IBinder
+import android.os.RemoteException
 import android.util.Log
 import android.view.SurfaceControlViewHost
 import android.widget.photopicker.EmbeddedPhotoPickerFeatureInfo
@@ -46,8 +47,15 @@ import com.android.photopicker.core.PhotopickerApp
 import com.android.photopicker.core.banners.BannerManager
 import com.android.photopicker.core.configuration.ConfigurationManager
 import com.android.photopicker.core.configuration.LocalPhotopickerConfiguration
+import com.android.photopicker.core.events.Event
 import com.android.photopicker.core.events.Events
 import com.android.photopicker.core.events.LocalEvents
+import com.android.photopicker.core.events.PhotopickerEventLogger
+import com.android.photopicker.core.events.Telemetry
+import com.android.photopicker.core.events.dispatchPhotopickerExpansionStateChangedEvent
+import com.android.photopicker.core.events.dispatchReportPhotopickerApiInfoEvent
+import com.android.photopicker.core.events.dispatchReportPhotopickerMediaItemStatusEvent
+import com.android.photopicker.core.events.dispatchReportPhotopickerSessionInfoEvent
 import com.android.photopicker.core.features.FeatureManager
 import com.android.photopicker.core.features.LocalFeatureManager
 import com.android.photopicker.core.selection.LocalSelection
@@ -57,10 +65,13 @@ import com.android.photopicker.core.user.UserMonitor
 import com.android.photopicker.data.DataService
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.extensions.requireSystemService
+import com.android.photopicker.util.LocalLocalizationHelper
+import com.android.photopicker.util.rememberLocalizationHelper
 import dagger.Lazy
 import dagger.hilt.EntryPoint
 import dagger.hilt.EntryPoints
 import dagger.hilt.InstallIn
+import java.util.concurrent.atomic.AtomicBoolean
 import kotlinx.coroutines.CoroutineDispatcher
 import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.flow.Flow
@@ -126,7 +137,7 @@ open class Session(
     private val grantUriPermission: (packageName: String, uri: Uri) -> EmbeddedService.GrantResult,
     private val revokeUriPermission: (packageName: String, uri: Uri) -> EmbeddedService.GrantResult,
     // TODO(b/354929684): Replace AIDL implementations with wrapper classes.
-) : IEmbeddedPhotoPickerSession.Stub() {
+) : IEmbeddedPhotoPickerSession.Stub(), IBinder.DeathRecipient {
 
     companion object {
         val TAG: String = "PhotopickerEmbeddedSession"
@@ -144,6 +155,8 @@ open class Session(
     @InstallIn(EmbeddedServiceComponent::class)
     interface EmbeddedEntryPoint {
 
+        @Background fun backgroundDispatcher(): CoroutineDispatcher
+
         fun bannerManager(): Lazy<BannerManager>
 
         fun configurationManager(): Lazy<ConfigurationManager>
@@ -202,7 +215,7 @@ open class Session(
      * Whether the session is currently active and has active resources. Sessions cannot be
      * restarted once closed.
      */
-    var isActive = true
+    var isActive = AtomicBoolean(true)
 
     init {
 
@@ -248,6 +261,10 @@ open class Session(
         // NOTE: Do not update the configuration after this line, it will cause the UI to
         // re-initialize.
         Log.d(TAG, "EmbeddedConfiguration is stable, UI will now start.")
+
+        // Picker event logger starts listening for events dispatched throughout the session
+        startListeningToTelemetryEvents()
+
         _view = createPhotopickerComposeView(context)
         _host = createSurfaceControlViewHost(context, displayId, hostToken)
         // This initialization should happen only after receiving the [_host]
@@ -255,27 +272,56 @@ open class Session(
             EmbeddedStateManager(host = _host, themeNightMode = featureInfo.themeNightMode)
         runBlocking(_main) { _host.setView(_view, width, height) }
 
+        // Log the picker launch details
+        reportPhotopickerApiInfo()
+
         // Start listening to selection/deselection events for this Session so
         // we can grant/revoke permission to selected/deselected uris immediately.
         listenForSelectionEvents()
+
+        // Initialize / Refresh the banner state.
+        refreshBannerState()
+
+        // Link death recipient on client callback to clean up the session resources
+        // when client dies
+        try {
+            clientCallback.asBinder()?.linkToDeath(this, 0 /* flags*/)
+        } catch (e: RemoteException) {
+            this.binderDied()
+        }
     }
 
     override fun close() {
-        if (!isActive) {
-            callClosedSessionError()
+        if (!isActive.get()) {
+            // session is already closed and the binder is still alive
+            if (clientCallback.asBinder()?.isBinderAlive() ?: false) {
+                callClosedSessionError()
+            }
             return
         }
-        Log.d(TAG, "Session close was requested.")
+        Log.d(TAG, "Session close was requested")
+
+        // Closing this session, and it can never be reactivated.
+        isActive.set(false)
+
+        // Log the final state of the session
+        reportSessionInfo()
+
         // Mark the [EmbeddedLifecycle] associated with the session as destroyed when this class is
         // closed. Block until the call is complete to ensure the lifecycle is marked as destroyed.
         runBlocking(_main) {
             _host.release()
-            _host.surfacePackage?.release()
             _embeddedViewLifecycle.onDestroy()
         }
+    }
 
-        // This session is now closed, and can never be reactivated.
-        isActive = false
+    override fun binderDied() {
+        Log.d(TAG, "Client is no longer active. Cleaning up the session resources")
+        if (isActive.get()) {
+            // Binder died here, so close session
+            close()
+        }
+        clientCallback.asBinder()?.unlinkToDeath(this, 0)
     }
 
     /**
@@ -346,6 +392,7 @@ open class Session(
                             LocalViewModelStoreOwner provides _embeddedViewLifecycle,
                             LocalOnBackPressedDispatcherOwner provides _embeddedViewLifecycle,
                             LocalEmbeddedState provides embeddedState,
+                            LocalLocalizationHelper provides rememberLocalizationHelper(),
                         ) {
                             val currentEmbeddedState =
                                 checkNotNull(LocalEmbeddedState.current) {
@@ -408,6 +455,9 @@ open class Session(
                         val result = grantUriPermission(clientPackageName, item.mediaUri)
                         if (result == EmbeddedService.GrantResult.SUCCESS) {
                             selectedUris.add(item.mediaUri)
+
+                            // Report media item selected
+                            reportMediaItemStatus(item, Telemetry.MediaStatus.SELECTED)
                         } else {
                             Log.w(
                                 TAG,
@@ -422,6 +472,9 @@ open class Session(
                         val result = revokeUriPermission(clientPackageName, item.mediaUri)
                         if (result == EmbeddedService.GrantResult.SUCCESS) {
                             deselectedUris.add(item.mediaUri)
+
+                            // Report media item unselected
+                            reportMediaItemStatus(item, Telemetry.MediaStatus.UNSELECTED)
                         } else {
                             Log.w(
                                 TAG,
@@ -447,19 +500,26 @@ open class Session(
     }
 
     override fun notifyVisibilityChanged(isVisible: Boolean) {
-        if (!isActive) {
+        if (!isActive.get()) {
             callClosedSessionError()
             return
         }
         Log.d(TAG, "Session visibility has changed: $isVisible")
         when (isVisible) {
-            true -> runBlocking(_main) { _embeddedViewLifecycle.onResume() }
+            true ->
+                runBlocking(_main) {
+                    _embeddedViewLifecycle.onResume()
+
+                    // Refresh the banner state, it's possible that the external state has changed
+                    // if the activity is returning from the background.
+                    refreshBannerState()
+                }
             false -> runBlocking(_main) { _embeddedViewLifecycle.onStop() }
         }
     }
 
     override fun notifyResized(width: Int, height: Int) {
-        if (!isActive) {
+        if (!isActive.get()) {
             callClosedSessionError()
             return
         }
@@ -468,7 +528,7 @@ open class Session(
     }
 
     override fun notifyConfigurationChanged(configuration: Configuration?) {
-        if (!isActive) {
+        if (!isActive.get()) {
             callClosedSessionError()
             return
         }
@@ -491,15 +551,19 @@ open class Session(
     }
 
     override fun notifyPhotopickerExpanded(isExpanded: Boolean) {
-        if (!isActive) {
+        if (!isActive.get()) {
             callClosedSessionError()
             return
         }
+
+        // Log picker expanded / collapsed
+        reportPhotopickerExpansionStateChanged(isExpanded)
+
         _stateManager.setIsExpanded(isExpanded)
     }
 
     override fun requestRevokeUriPermission(uris: List<Uri>) {
-        if (!isActive) {
+        if (!isActive.get()) {
             callClosedSessionError()
             return
         }
@@ -511,6 +575,11 @@ open class Session(
                 }
 
             _dependencies.selection().get().removeAll(deselectedMediaItems)
+
+            // Report media item unselected
+            deselectedMediaItems.forEach { item ->
+                reportMediaItemStatus(item, Telemetry.MediaStatus.UNSELECTED)
+            }
         }
     }
 
@@ -521,4 +590,84 @@ open class Session(
     private fun onMediaSelectionConfirmed() {
         clientCallback.onSelectionComplete()
     }
+
+    private fun refreshBannerState() {
+        _backgroundScope.launch {
+            // Always ensure providers before requesting a banner refresh, banners depend on
+            // having accurate provider information to generate the correct banners.
+            _dependencies.dataService().get().ensureProviders()
+            _dependencies.bannerManager().get().refreshBanners()
+        }
+    }
+
+    // ---------- Begin Telemetry event functions ----------
+
+    /** Picker event logger starts listening for events dispatched throughout the session */
+    private fun startListeningToTelemetryEvents() {
+        PhotopickerEventLogger(_dependencies.dataService())
+            .start(
+                scope = _backgroundScope,
+                backgroundDispatcher = _dependencies.backgroundDispatcher(),
+                events = _dependencies.events().get(),
+            )
+    }
+
+    /** Log the picker launch details by dispatching [Event.ReportPhotopickerApiInfo] */
+    private fun reportPhotopickerApiInfo() {
+        dispatchReportPhotopickerApiInfoEvent(
+            coroutineScope = _backgroundScope,
+            lazyEvents = _dependencies.events(),
+            photopickerConfiguration =
+                _dependencies.configurationManager().get().configuration.value,
+        )
+    }
+
+    /** Dispatch [Event.ReportPhotopickerSessionInfo] to log the final state of the session */
+    private fun reportSessionInfo() {
+        val pickerStatus =
+            if (_dependencies.selection().get().flow.value.isNotEmpty())
+                Telemetry.PickerStatus.CONFIRMED
+            else Telemetry.PickerStatus.CANCELED
+
+        dispatchReportPhotopickerSessionInfoEvent(
+            coroutineScope = _backgroundScope,
+            lazyEvents = _dependencies.events(),
+            photopickerConfiguration =
+                _dependencies.configurationManager().get().configuration.value,
+            lazyDataService = _dependencies.dataService(),
+            lazyUserMonitor = _dependencies.userMonitor(),
+            lazyMediaSelection = _dependencies.selection(),
+            pickerStatus = pickerStatus,
+        )
+    }
+
+    /** Dispatch [Event.ReportPhotopickerMediaItemStatus] to log media item selected / unselected */
+    private fun reportMediaItemStatus(item: Media, mediaStatus: Telemetry.MediaStatus) {
+        val pickerSize =
+            if (_stateManager.state.value.isExpanded) Telemetry.PickerSize.EXPANDED
+            else Telemetry.PickerSize.COLLAPSED
+
+        dispatchReportPhotopickerMediaItemStatusEvent(
+            coroutineScope = _backgroundScope,
+            lazyEvents = _dependencies.events(),
+            photopickerConfiguration =
+                _dependencies.configurationManager().get().configuration.value,
+            mediaItem = item,
+            mediaStatus = mediaStatus,
+            pickerSize = pickerSize,
+        )
+    }
+
+    /** Dispatch [Event.LogPhotopickerUIEvent] to log picker expanded / collapsed */
+    private fun reportPhotopickerExpansionStateChanged(isExpanded: Boolean) {
+        dispatchPhotopickerExpansionStateChangedEvent(
+            coroutineScope = _backgroundScope,
+            lazyEvents = _dependencies.events(),
+            photopickerConfiguration =
+                _dependencies.configurationManager().get().configuration.value,
+            isExpanded = isExpanded,
+        )
+    }
+
+    // ---------- End Telemetry event functions ----------
 }
diff --git a/photopicker/src/com/android/photopicker/core/events/Dispatchers.kt b/photopicker/src/com/android/photopicker/core/events/Dispatchers.kt
new file mode 100644
index 000000000..a349d181f
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/core/events/Dispatchers.kt
@@ -0,0 +1,252 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.core.events
+
+import android.provider.MediaStore
+import com.android.photopicker.core.configuration.PhotopickerConfiguration
+import com.android.photopicker.core.configuration.PhotopickerRuntimeEnv
+import com.android.photopicker.core.features.FeatureToken
+import com.android.photopicker.core.navigation.PhotopickerDestinations
+import com.android.photopicker.core.selection.Selection
+import com.android.photopicker.core.theme.AccentColorHelper
+import com.android.photopicker.core.user.UserMonitor
+import com.android.photopicker.core.user.UserProfile
+import com.android.photopicker.data.DataService
+import com.android.photopicker.data.model.Media
+import com.android.photopicker.data.model.MediaSource
+import com.android.photopicker.extensions.getUserProfilesVisibleToPhotopicker
+import dagger.Lazy
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.flow.first
+import kotlinx.coroutines.launch
+
+/** Dispatches an event to log all details with which the photopicker launched */
+fun dispatchReportPhotopickerApiInfoEvent(
+    coroutineScope: CoroutineScope,
+    lazyEvents: Lazy<Events>,
+    photopickerConfiguration: PhotopickerConfiguration,
+    pickerIntentAction: Telemetry.PickerIntentAction =
+        Telemetry.PickerIntentAction.UNSET_PICKER_INTENT_ACTION,
+) {
+    val dispatcherToken = FeatureToken.CORE.token
+    val sessionId = photopickerConfiguration.sessionId
+    // We always launch the picker in collapsed state. We track the state change as UI event.
+    val pickerSize = Telemetry.PickerSize.COLLAPSED
+    val mediaFilters =
+        photopickerConfiguration.mimeTypes
+            .map { mimeType ->
+                when {
+                    mimeType.contains("image") && mimeType.contains("video") ->
+                        Telemetry.MediaType.PHOTO_VIDEO
+                    mimeType.startsWith("image/") -> Telemetry.MediaType.PHOTO
+                    mimeType.startsWith("video/") -> Telemetry.MediaType.VIDEO
+                    else -> Telemetry.MediaType.UNSET_MEDIA_TYPE
+                }
+            }
+            .ifEmpty { listOf(Telemetry.MediaType.UNSET_MEDIA_TYPE) }
+    val maxPickedItemsCount = photopickerConfiguration.selectionLimit
+    val selectedTab =
+        when (photopickerConfiguration.startDestination) {
+            PhotopickerDestinations.PHOTO_GRID -> Telemetry.SelectedTab.PHOTOS
+            PhotopickerDestinations.ALBUM_GRID -> Telemetry.SelectedTab.ALBUMS
+            else -> Telemetry.SelectedTab.UNSET_SELECTED_TAB
+        }
+    val selectedAlbum = Telemetry.SelectedAlbum.UNSET_SELECTED_ALBUM
+    val isOrderedSelectionSet = photopickerConfiguration.pickImagesInOrder
+    // TODO(b/376822503): Creating a new instance of AccentColorHelper() to check color seems
+    //  unnecessary. Fix later
+    val isAccentColorSet =
+        AccentColorHelper(inputColor = photopickerConfiguration.accentColor ?: -1)
+            .isValidAccentColorSet()
+    val isDefaultTabSet =
+        photopickerConfiguration.startDestination != PhotopickerDestinations.DEFAULT
+    // TODO(b/376822503): Update when search is added
+    val isCloudSearchEnabled = false
+    val isLocalSearchEnabled = false
+    for (mediaFilter in mediaFilters) {
+        coroutineScope.launch {
+            lazyEvents
+                .get()
+                .dispatch(
+                    Event.ReportPhotopickerApiInfo(
+                        dispatcherToken = dispatcherToken,
+                        sessionId = sessionId,
+                        pickerIntentAction = pickerIntentAction,
+                        pickerSize = pickerSize,
+                        mediaFilter = mediaFilter,
+                        maxPickedItemsCount = maxPickedItemsCount,
+                        selectedTab = selectedTab,
+                        selectedAlbum = selectedAlbum,
+                        isOrderedSelectionSet = isOrderedSelectionSet,
+                        isAccentColorSet = isAccentColorSet,
+                        isDefaultTabSet = isDefaultTabSet,
+                        isCloudSearchEnabled = isCloudSearchEnabled,
+                        isLocalSearchEnabled = isLocalSearchEnabled,
+                    )
+                )
+        }
+    }
+}
+
+/** Dispatches an event to log all the final state details of the picker */
+fun dispatchReportPhotopickerSessionInfoEvent(
+    coroutineScope: CoroutineScope,
+    lazyEvents: Lazy<Events>,
+    photopickerConfiguration: PhotopickerConfiguration,
+    lazyDataService: Lazy<DataService>,
+    lazyUserMonitor: Lazy<UserMonitor>,
+    lazyMediaSelection: Lazy<Selection<Media>>,
+    pickerStatus: Telemetry.PickerStatus = Telemetry.PickerStatus.UNSET_PICKER_STATUS,
+    pickerCloseMethod: Telemetry.PickerCloseMethod =
+        Telemetry.PickerCloseMethod.UNSET_PICKER_CLOSE_METHOD,
+) {
+    val dispatcherToken = FeatureToken.CORE.token
+    val sessionId = photopickerConfiguration.sessionId
+    val packageUid = photopickerConfiguration.callingPackageUid ?: -1
+    val pickerSelection =
+        if (photopickerConfiguration.selectionLimit == 1) {
+            Telemetry.PickerSelection.SINGLE
+        } else {
+            Telemetry.PickerSelection.MULTIPLE
+        }
+    val cloudProviderUid =
+        lazyDataService
+            .get()
+            .availableProviders
+            .value
+            .firstOrNull { provider -> provider.mediaSource == MediaSource.REMOTE }
+            ?.uid ?: -1
+    val userProfile =
+        when (lazyUserMonitor.get().userStatus.value.activeUserProfile.profileType) {
+            UserProfile.ProfileType.PRIMARY -> Telemetry.UserProfile.PERSONAL
+            UserProfile.ProfileType.MANAGED -> Telemetry.UserProfile.WORK
+            else -> Telemetry.UserProfile.UNKNOWN
+        }
+    val pickedMediaItemsSet = lazyMediaSelection.get().flow.value
+    val pickedItemsCount = pickedMediaItemsSet.size
+    val pickedItemsSize = pickedMediaItemsSet.sumOf { it.sizeInBytes.toInt() }
+    val pickerMode =
+        when {
+            photopickerConfiguration.action == MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP ->
+                Telemetry.PickerMode.PERMISSION_MODE_PICKER
+            photopickerConfiguration.runtimeEnv == PhotopickerRuntimeEnv.ACTIVITY ->
+                Telemetry.PickerMode.REGULAR_PICKER
+            photopickerConfiguration.runtimeEnv == PhotopickerRuntimeEnv.EMBEDDED ->
+                Telemetry.PickerMode.EMBEDDED_PICKER
+            else -> Telemetry.PickerMode.UNSET_PICKER_MODE
+        }
+
+    coroutineScope.launch {
+        val profileSwitchButtonVisible =
+            lazyUserMonitor.get().userStatus.getUserProfilesVisibleToPhotopicker().first().size > 1
+        lazyEvents
+            .get()
+            .dispatch(
+                Event.ReportPhotopickerSessionInfo(
+                    dispatcherToken = dispatcherToken,
+                    sessionId = sessionId,
+                    packageUid = packageUid,
+                    pickerSelection = pickerSelection,
+                    cloudProviderUid = cloudProviderUid,
+                    userProfile = userProfile,
+                    pickerStatus = pickerStatus,
+                    pickedItemsCount = pickedItemsCount,
+                    pickedItemsSize = pickedItemsSize,
+                    profileSwitchButtonVisible = profileSwitchButtonVisible,
+                    pickerMode = pickerMode,
+                    pickerCloseMethod = pickerCloseMethod,
+                )
+            )
+    }
+}
+
+/** Dispatches an event to log media item status as selected / unselected */
+fun dispatchReportPhotopickerMediaItemStatusEvent(
+    coroutineScope: CoroutineScope,
+    lazyEvents: Lazy<Events>,
+    photopickerConfiguration: PhotopickerConfiguration,
+    mediaItem: Media,
+    mediaStatus: Telemetry.MediaStatus,
+    pickerSize: Telemetry.PickerSize = Telemetry.PickerSize.UNSET_PICKER_SIZE,
+) {
+    val dispatcherToken = FeatureToken.CORE.token
+    val sessionId = photopickerConfiguration.sessionId
+    val selectionSource = mediaItem.selectionSource ?: Telemetry.MediaLocation.UNSET_MEDIA_LOCATION
+    val itemPosition = mediaItem.index ?: -1
+    val selectedAlbum = mediaItem.mediaItemAlbum
+    val mimeType = mediaItem.mimeType
+    // TODO(b/376822503): find live photo format
+    val mediaType =
+        if (mimeType.startsWith("image/")) {
+            if (mimeType.contains("gif")) {
+                Telemetry.MediaType.GIF
+            } else {
+                Telemetry.MediaType.PHOTO
+            }
+        } else if (mimeType.startsWith("video/")) {
+            Telemetry.MediaType.VIDEO
+        } else {
+            Telemetry.MediaType.OTHER
+        }
+    val cloudOnly = mediaItem.mediaSource == MediaSource.REMOTE
+    coroutineScope.launch {
+        lazyEvents
+            .get()
+            .dispatch(
+                Event.ReportPhotopickerMediaItemStatus(
+                    dispatcherToken = dispatcherToken,
+                    sessionId = sessionId,
+                    mediaStatus = mediaStatus,
+                    selectionSource = selectionSource,
+                    itemPosition = itemPosition,
+                    selectedAlbum = selectedAlbum,
+                    mediaType = mediaType,
+                    cloudOnly = cloudOnly,
+                    pickerSize = pickerSize,
+                )
+            )
+    }
+}
+
+/**
+ * Dispatches an event to log the expansion state change event in picker. If [isExpanded], logs
+ * [Telemetry.UiEvent.EXPAND_PICKER], else logs [Telemetry.UiEvent.COLLAPSE_PICKER].
+ */
+fun dispatchPhotopickerExpansionStateChangedEvent(
+    coroutineScope: CoroutineScope,
+    lazyEvents: Lazy<Events>,
+    photopickerConfiguration: PhotopickerConfiguration,
+    isExpanded: Boolean,
+) {
+    val dispatcherToken = FeatureToken.CORE.token
+    val sessionId = photopickerConfiguration.sessionId
+    val packageUid = photopickerConfiguration.callingPackageUid ?: -1
+    val uiEvent =
+        if (isExpanded) Telemetry.UiEvent.EXPAND_PICKER else Telemetry.UiEvent.COLLAPSE_PICKER
+    coroutineScope.launch {
+        lazyEvents
+            .get()
+            .dispatch(
+                Event.LogPhotopickerUIEvent(
+                    dispatcherToken = dispatcherToken,
+                    sessionId = sessionId,
+                    packageUid = packageUid,
+                    uiEvent = uiEvent,
+                )
+            )
+    }
+}
diff --git a/photopicker/src/com/android/photopicker/core/events/Event.kt b/photopicker/src/com/android/photopicker/core/events/Event.kt
index 3dfb854a6..8426a55bb 100644
--- a/photopicker/src/com/android/photopicker/core/events/Event.kt
+++ b/photopicker/src/com/android/photopicker/core/events/Event.kt
@@ -75,7 +75,7 @@ interface Event {
         val pickedItemsSize: Int,
         val profileSwitchButtonVisible: Boolean,
         val pickerMode: Telemetry.PickerMode,
-        val pickerCloseMethod: Telemetry.PickerCloseMethod
+        val pickerCloseMethod: Telemetry.PickerCloseMethod,
     ) : Event
 
     /**
@@ -94,7 +94,8 @@ interface Event {
         val isOrderedSelectionSet: Boolean,
         val isAccentColorSet: Boolean,
         val isDefaultTabSet: Boolean,
-        val isSearchEnabled: Boolean
+        val isCloudSearchEnabled: Boolean,
+        val isLocalSearchEnabled: Boolean,
     ) : Event
 
     /**
@@ -105,14 +106,14 @@ interface Event {
         override val dispatcherToken: String,
         val sessionId: Int,
         val packageUid: Int,
-        val uiEvent: Telemetry.UiEvent
+        val uiEvent: Telemetry.UiEvent,
     ) : Event
 
     data class LogPhotopickerAlbumOpenedUIEvent(
         override val dispatcherToken: String,
         val sessionId: Int,
         val packageUid: Int,
-        val albumOpened: Group.Album
+        val albumOpened: Group.Album,
     ) : Event
 
     /** Details out the information of a picker media item */
@@ -125,7 +126,7 @@ interface Event {
         val selectedAlbum: Group.Album?,
         val mediaType: Telemetry.MediaType,
         val cloudOnly: Boolean,
-        val pickerSize: Telemetry.PickerSize
+        val pickerSize: Telemetry.PickerSize,
     ) : Event
 
     /** Captures details of the picker's preview mode */
@@ -135,7 +136,7 @@ interface Event {
         val previewModeEntry: Telemetry.PreviewModeEntry,
         val previewItemCount: Int,
         val mediaType: Telemetry.MediaType,
-        val videoInteraction: Telemetry.VideoPlayBackInteractions
+        val videoInteraction: Telemetry.VideoPlayBackInteractions,
     ) : Event
 
     /** Logs the user's interaction with the photopicker menu */
@@ -143,7 +144,7 @@ interface Event {
         override val dispatcherToken: String,
         val sessionId: Int,
         val packageUid: Int,
-        val menuItem: Telemetry.MenuItemSelected
+        val menuItem: Telemetry.MenuItemSelected,
     ) : Event
 
     /** Logs the user's interaction with different picker banners */
@@ -151,7 +152,7 @@ interface Event {
         override val dispatcherToken: String,
         val sessionId: Int,
         val bannerType: Telemetry.BannerType,
-        val userInteraction: Telemetry.UserBannerInteraction
+        val userInteraction: Telemetry.UserBannerInteraction,
     ) : Event
 
     /** Logs details of the picker media library size */
@@ -160,7 +161,7 @@ interface Event {
         val sessionId: Int,
         val cloudProviderUid: Int,
         val librarySize: Int,
-        val mediaCount: Int
+        val mediaCount: Int,
     ) : Event
 
     /**
@@ -171,7 +172,7 @@ interface Event {
         override val dispatcherToken: String,
         val sessionId: Int,
         val pageNumber: Int,
-        val itemsLoadedInPage: Int
+        val itemsLoadedInPage: Int,
     ) : Event
 
     /** Logs picker media sync information: both sync start/end and incremental syncs. */
@@ -185,7 +186,7 @@ interface Event {
         val incrementalMediaSyncStartTime: Int,
         val incrementalMediaSyncEndTime: Int,
         val incrementalDeletedMediaSyncStartTime: Int,
-        val incrementalDeletedMediaSyncEndTime: Int
+        val incrementalDeletedMediaSyncEndTime: Int,
     ) : Event
 
     /** Logs sync information for picker albums: both the album details and its content */
@@ -195,7 +196,7 @@ interface Event {
         val getAlbumsStartTime: Int,
         val getAlbumsEndTime: Int,
         val getAlbumMediaStartTime: Int,
-        val getAlbumMediaEndTime: Int
+        val getAlbumMediaEndTime: Int,
     ) : Event
 
     /** Logs information about the picker's search functionality */
@@ -203,9 +204,6 @@ interface Event {
         override val dispatcherToken: String,
         val sessionId: Int,
         val searchMethod: Telemetry.SearchMethod,
-        val pickedItems: Int,
-        val startTime: Int,
-        val endTime: Int
     ) : Event
 
     /** Logs details about the requests made for extracting search data */
@@ -216,7 +214,7 @@ interface Event {
         val processingStartTime: Int,
         val processingEndTime: Int,
         val isProcessingSuccessful: Boolean,
-        val isResponseReceived: Boolean
+        val isResponseReceived: Boolean,
     ) : Event
 
     /** Logs information about the embedded photopicker(implementation details) */
@@ -225,7 +223,7 @@ interface Event {
         val sessionId: Int,
         val isSurfacePackageCreationSuccessful: Boolean,
         val surfacePackageDeliveryStartTime: Int,
-        val surfacePackageDeliveryEndTime: Int
+        val surfacePackageDeliveryEndTime: Int,
     ) : Event
 }
 
@@ -251,7 +249,7 @@ interface Telemetry {
         UNSET_PICKER_SELECTION(
             MediaProviderStatsLog
                 .PHOTOPICKER_SESSION_INFO_REPORTED__PICKER_PERMITTED_SELECTION__UNSET_PICKER_PERMITTED_SELECTION
-        )
+        ),
     }
 
     /*
@@ -267,7 +265,7 @@ interface Telemetry {
         UNSET_USER_PROFILE(
             MediaProviderStatsLog
                 .PHOTOPICKER_SESSION_INFO_REPORTED__USER_PROFILE__UNSET_USER_PROFILE
-        )
+        ),
     }
 
     /*
@@ -282,7 +280,7 @@ interface Telemetry {
         UNSET_PICKER_STATUS(
             MediaProviderStatsLog
                 .PHOTOPICKER_SESSION_INFO_REPORTED__PICKER_STATUS__UNSET_PICKER_STATUS
-        )
+        ),
     }
 
     /*
@@ -302,7 +300,7 @@ interface Telemetry {
         ),
         UNSET_PICKER_MODE(
             MediaProviderStatsLog.PHOTOPICKER_SESSION_INFO_REPORTED__PICKER_MODE__UNSET_PICKER_MODE
-        )
+        ),
     }
 
     /*
@@ -328,7 +326,7 @@ interface Telemetry {
         UNSET_PICKER_CLOSE_METHOD(
             MediaProviderStatsLog
                 .PHOTOPICKER_SESSION_INFO_REPORTED__PICKER_CLOSE_METHOD__UNSET_PICKER_CLOSE_METHOD
-        )
+        ),
     }
 
     /*
@@ -339,7 +337,7 @@ interface Telemetry {
         EXPANDED(MediaProviderStatsLog.PHOTOPICKER_API_INFO_REPORTED__SCREEN_SIZE__EXPANDED),
         UNSET_PICKER_SIZE(
             MediaProviderStatsLog.PHOTOPICKER_API_INFO_REPORTED__SCREEN_SIZE__UNSET_PICKER_SIZE
-        )
+        ),
     }
 
     /*
@@ -361,7 +359,7 @@ interface Telemetry {
         UNSET_PICKER_INTENT_ACTION(
             MediaProviderStatsLog
                 .PHOTOPICKER_API_INFO_REPORTED__PICKER_INTENT_ACTION__UNSET_PICKER_INTENT_ACTION
-        )
+        ),
     }
 
     /*
@@ -381,7 +379,7 @@ interface Telemetry {
         UNSET_MEDIA_TYPE(
             MediaProviderStatsLog
                 .PHOTOPICKER_MEDIA_ITEM_STATUS_REPORTED__MEDIA_TYPE__UNSET_MEDIA_TYPE
-        )
+        ),
     }
 
     /*
@@ -393,7 +391,7 @@ interface Telemetry {
         COLLECTIONS(MediaProviderStatsLog.PHOTOPICKER_API_INFO_REPORTED__SELECTED_TAB__COLLECTIONS),
         UNSET_SELECTED_TAB(
             MediaProviderStatsLog.PHOTOPICKER_API_INFO_REPORTED__SELECTED_TAB__UNSET_SELECTED_TAB
-        )
+        ),
     }
 
     /*
@@ -416,7 +414,7 @@ interface Telemetry {
         UNSET_SELECTED_ALBUM(
             MediaProviderStatsLog
                 .PHOTOPICKER_API_INFO_REPORTED__SELECTED_ALBUM__UNSET_SELECTED_ALBUM
-        )
+        ),
     }
 
     /*
@@ -524,7 +522,7 @@ interface Telemetry {
         SELECT_SEARCH_CATEGORY(
             MediaProviderStatsLog.PHOTOPICKER_UIEVENT_LOGGED__UI_EVENT__SELECT_SEARCH_CATEGORY
         ),
-        UNSET_UI_EVENT(MediaProviderStatsLog.PHOTOPICKER_UIEVENT_LOGGED__UI_EVENT__UNSET_UI_EVENT)
+        UNSET_UI_EVENT(MediaProviderStatsLog.PHOTOPICKER_UIEVENT_LOGGED__UI_EVENT__UNSET_UI_EVENT),
     }
 
     /*
@@ -540,7 +538,7 @@ interface Telemetry {
         UNSET_MEDIA_STATUS(
             MediaProviderStatsLog
                 .PHOTOPICKER_MEDIA_ITEM_STATUS_REPORTED__MEDIA_STATUS__UNSET_MEDIA_STATUS
-        )
+        ),
     }
 
     /*
@@ -551,11 +549,17 @@ interface Telemetry {
             MediaProviderStatsLog.PHOTOPICKER_MEDIA_ITEM_STATUS_REPORTED__MEDIA_LOCATION__MAIN_GRID
         ),
         ALBUM(MediaProviderStatsLog.PHOTOPICKER_MEDIA_ITEM_STATUS_REPORTED__MEDIA_LOCATION__ALBUM),
-        GROUP(MediaProviderStatsLog.PHOTOPICKER_MEDIA_ITEM_STATUS_REPORTED__MEDIA_LOCATION__GROUP),
         UNSET_MEDIA_LOCATION(
             MediaProviderStatsLog
                 .PHOTOPICKER_MEDIA_ITEM_STATUS_REPORTED__MEDIA_LOCATION__UNSET_MEDIA_LOCATION
-        )
+        ),
+        CATEGORY(
+            MediaProviderStatsLog.PHOTOPICKER_MEDIA_ITEM_STATUS_REPORTED__MEDIA_LOCATION__CATEGORY
+        ),
+        SEARCH_GRID(
+            MediaProviderStatsLog
+                .PHOTOPICKER_MEDIA_ITEM_STATUS_REPORTED__MEDIA_LOCATION__SEARCH_GRID
+        ),
     }
 
     /*
@@ -571,7 +575,7 @@ interface Telemetry {
         UNSET_PREVIEW_MODE_ENTRY(
             MediaProviderStatsLog
                 .PHOTOPICKER_PREVIEW_INFO_LOGGED__PREVIEW_MODE_ENTRY__UNSET_PREVIEW_MODE_ENTRY
-        )
+        ),
     }
 
     /*
@@ -585,7 +589,7 @@ interface Telemetry {
         UNSET_VIDEO_PLAYBACK_INTERACTION(
             MediaProviderStatsLog
                 .PHOTOPICKER_PREVIEW_INFO_LOGGED__VIDEO_INTERACTIONS__UNSET_VIDEO_PLAYBACK_INTERACTION
-        )
+        ),
     }
 
     /*
@@ -602,7 +606,7 @@ interface Telemetry {
         UNSET_MENU_ITEM_SELECTED(
             MediaProviderStatsLog
                 .PHOTOPICKER_MENU_INTERACTION_LOGGED__MENU_ITEM_SELECTED__UNSET_MENU_ITEM_SELECTED
-        )
+        ),
     }
 
     /*
@@ -673,7 +677,7 @@ interface Telemetry {
         UNSET_BANNER_INTERACTION(
             MediaProviderStatsLog
                 .PHOTOPICKER_BANNER_INTERACTION_LOGGED__BANNER_TYPE__UNSET_BANNER_TYPE
-        )
+        ),
     }
 
     /*
@@ -683,9 +687,6 @@ interface Telemetry {
         SEARCH_QUERY(
             MediaProviderStatsLog.PHOTOPICKER_SEARCH_INFO_REPORTED__SEARCH_METHOD__SEARCH_QUERY
         ),
-        COLLECTION(
-            MediaProviderStatsLog.PHOTOPICKER_SEARCH_INFO_REPORTED__SEARCH_METHOD__COLLECTION
-        ),
         SUGGESTED_SEARCHES(
             MediaProviderStatsLog
                 .PHOTOPICKER_SEARCH_INFO_REPORTED__SEARCH_METHOD__SUGGESTED_SEARCHES
@@ -693,6 +694,9 @@ interface Telemetry {
         UNSET_SEARCH_METHOD(
             MediaProviderStatsLog
                 .PHOTOPICKER_SEARCH_INFO_REPORTED__SEARCH_METHOD__UNSET_SEARCH_METHOD
-        )
+        ),
+        CATEGORY_SEARCH(
+            MediaProviderStatsLog.PHOTOPICKER_SEARCH_INFO_REPORTED__SEARCH_METHOD__CATEGORY_SEARCH
+        ),
     }
 }
diff --git a/photopicker/src/com/android/photopicker/core/events/PhotopickerEventLogger.kt b/photopicker/src/com/android/photopicker/core/events/PhotopickerEventLogger.kt
index b547d9692..6b81b426c 100644
--- a/photopicker/src/com/android/photopicker/core/events/PhotopickerEventLogger.kt
+++ b/photopicker/src/com/android/photopicker/core/events/PhotopickerEventLogger.kt
@@ -47,7 +47,7 @@ class PhotopickerEventLogger(val dataService: Lazy<DataService>) {
             ALBUM_ID_SCREENSHOTS to Telemetry.SelectedAlbum.SCREENSHOTS,
             ALBUM_ID_FAVORITES to Telemetry.SelectedAlbum.FAVOURITES,
             ALBUM_ID_VIDEOS to Telemetry.SelectedAlbum.VIDEOS,
-            ALBUM_ID_DOWNLOADS to Telemetry.SelectedAlbum.DOWNLOADS
+            ALBUM_ID_DOWNLOADS to Telemetry.SelectedAlbum.DOWNLOADS,
         )
 
     /** Maps album id to the corresponding selected album enum values */
@@ -57,13 +57,13 @@ class PhotopickerEventLogger(val dataService: Lazy<DataService>) {
             ALBUM_ID_SCREENSHOTS to Telemetry.UiEvent.ALBUM_SCREENSHOTS_OPEN,
             ALBUM_ID_FAVORITES to Telemetry.UiEvent.ALBUM_FAVOURITES_OPEN,
             ALBUM_ID_VIDEOS to Telemetry.UiEvent.ALBUM_VIDEOS_OPEM,
-            ALBUM_ID_DOWNLOADS to Telemetry.UiEvent.ALBUM_DOWNLOADS_OPEN
+            ALBUM_ID_DOWNLOADS to Telemetry.UiEvent.ALBUM_DOWNLOADS_OPEN,
         )
 
     fun start(
         scope: CoroutineScope,
         @Background backgroundDispatcher: CoroutineDispatcher,
-        events: Events
+        events: Events,
     ) {
         scope.launch(backgroundDispatcher) {
             events.flow.collect { event ->
@@ -81,7 +81,7 @@ class PhotopickerEventLogger(val dataService: Lazy<DataService>) {
                             event.pickedItemsSize,
                             event.profileSwitchButtonVisible,
                             event.pickerMode.mode,
-                            event.pickerCloseMethod.method
+                            event.pickerCloseMethod.method,
                         )
                     }
                     is Event.ReportPhotopickerApiInfo -> {
@@ -97,7 +97,9 @@ class PhotopickerEventLogger(val dataService: Lazy<DataService>) {
                             event.isOrderedSelectionSet,
                             event.isAccentColorSet,
                             event.isDefaultTabSet,
-                            event.isSearchEnabled
+                            /* is_search_enabled */ false,
+                            event.isCloudSearchEnabled,
+                            event.isLocalSearchEnabled,
                         )
                     }
                     is Event.LogPhotopickerUIEvent -> {
@@ -105,7 +107,7 @@ class PhotopickerEventLogger(val dataService: Lazy<DataService>) {
                             MediaProviderStatsLog.PHOTOPICKER_UI_EVENT_LOGGED,
                             event.sessionId,
                             event.packageUid,
-                            event.uiEvent.event
+                            event.uiEvent.event,
                         )
                     }
                     is Event.LogPhotopickerAlbumOpenedUIEvent -> {
@@ -117,13 +119,13 @@ class PhotopickerEventLogger(val dataService: Lazy<DataService>) {
                                     MediaSource.REMOTE -> Telemetry.UiEvent.ALBUM_FROM_CLOUD_OPEN
                                     // TODO replace with LOCAL value once added
                                     MediaSource.LOCAL -> Telemetry.UiEvent.ALBUM_FROM_CLOUD_OPEN
-                                }
+                                },
                             )
                         MediaProviderStatsLog.write(
                             MediaProviderStatsLog.PHOTOPICKER_UI_EVENT_LOGGED,
                             event.sessionId,
                             event.packageUid,
-                            albumOpened.event
+                            albumOpened.event,
                         )
                     }
                     is Event.ReportPhotopickerMediaItemStatus -> {
@@ -139,7 +141,7 @@ class PhotopickerEventLogger(val dataService: Lazy<DataService>) {
                                         MediaSource.REMOTE ->
                                             Telemetry.SelectedAlbum.UNDEFINED_CLOUD
                                         MediaSource.LOCAL -> Telemetry.SelectedAlbum.UNDEFINED_LOCAL
-                                    }
+                                    },
                                 )
                             } else {
                                 Telemetry.SelectedAlbum.UNSET_SELECTED_ALBUM
@@ -154,7 +156,7 @@ class PhotopickerEventLogger(val dataService: Lazy<DataService>) {
                             selectedAlbum.album,
                             event.mediaType.type,
                             event.cloudOnly,
-                            event.pickerSize.size
+                            event.pickerSize.size,
                         )
                     }
                     is Event.LogPhotopickerPreviewInfo -> {
@@ -164,7 +166,7 @@ class PhotopickerEventLogger(val dataService: Lazy<DataService>) {
                             event.previewModeEntry.entry,
                             event.previewItemCount,
                             event.mediaType.type,
-                            event.videoInteraction.interaction
+                            event.videoInteraction.interaction,
                         )
                     }
                     is Event.LogPhotopickerMenuInteraction -> {
@@ -172,7 +174,7 @@ class PhotopickerEventLogger(val dataService: Lazy<DataService>) {
                             MediaProviderStatsLog.PHOTOPICKER_MENU_INTERACTION_LOGGED,
                             event.sessionId,
                             event.packageUid,
-                            event.menuItem.item
+                            event.menuItem.item,
                         )
                     }
                     is Event.LogPhotopickerBannerInteraction -> {
@@ -180,7 +182,7 @@ class PhotopickerEventLogger(val dataService: Lazy<DataService>) {
                             MediaProviderStatsLog.PHOTOPICKER_BANNER_INTERACTION_LOGGED,
                             event.sessionId,
                             event.bannerType.type,
-                            event.userInteraction.interaction
+                            event.userInteraction.interaction,
                         )
                     }
                     is Event.LogPhotopickerMediaLibraryInfo -> {
@@ -189,7 +191,7 @@ class PhotopickerEventLogger(val dataService: Lazy<DataService>) {
                             event.sessionId,
                             event.cloudProviderUid,
                             event.librarySize,
-                            event.mediaCount
+                            event.mediaCount,
                         )
                     }
                     is Event.LogPhotopickerPageInfo -> {
@@ -197,7 +199,7 @@ class PhotopickerEventLogger(val dataService: Lazy<DataService>) {
                             MediaProviderStatsLog.PHOTOPICKER_PAGE_INFO_LOGGED,
                             event.sessionId,
                             event.pageNumber,
-                            event.itemsLoadedInPage
+                            event.itemsLoadedInPage,
                         )
                     }
                     is Event.ReportPhotopickerMediaGridSyncInfo -> {
@@ -211,7 +213,7 @@ class PhotopickerEventLogger(val dataService: Lazy<DataService>) {
                             event.incrementalMediaSyncStartTime,
                             event.incrementalMediaSyncEndTime,
                             event.incrementalDeletedMediaSyncStartTime,
-                            event.incrementalDeletedMediaSyncEndTime
+                            event.incrementalDeletedMediaSyncEndTime,
                         )
                     }
                     is Event.ReportPhotopickerAlbumSyncInfo -> {
@@ -221,7 +223,7 @@ class PhotopickerEventLogger(val dataService: Lazy<DataService>) {
                             event.getAlbumsStartTime,
                             event.getAlbumsEndTime,
                             event.getAlbumMediaStartTime,
-                            event.getAlbumMediaEndTime
+                            event.getAlbumMediaEndTime,
                         )
                     }
                     is Event.ReportPhotopickerSearchInfo -> {
@@ -229,9 +231,9 @@ class PhotopickerEventLogger(val dataService: Lazy<DataService>) {
                             MediaProviderStatsLog.PHOTOPICKER_SESSION_INFO_REPORTED,
                             event.sessionId,
                             event.searchMethod.method,
-                            event.pickedItems,
-                            event.startTime,
-                            event.endTime
+                            /* picked_items */ 0,
+                            /* startTime */ 0,
+                            /* endTime */ 0,
                         )
                     }
                     is Event.ReportSearchDataExtractionDetails -> {
@@ -242,7 +244,7 @@ class PhotopickerEventLogger(val dataService: Lazy<DataService>) {
                             event.processingStartTime,
                             event.processingEndTime,
                             event.isProcessingSuccessful,
-                            event.isResponseReceived
+                            event.isResponseReceived,
                         )
                     }
                     is Event.ReportEmbeddedPhotopickerInfo -> {
@@ -251,7 +253,7 @@ class PhotopickerEventLogger(val dataService: Lazy<DataService>) {
                             event.sessionId,
                             event.isSurfacePackageCreationSuccessful,
                             event.surfacePackageDeliveryStartTime,
-                            event.surfacePackageDeliveryEndTime
+                            event.surfacePackageDeliveryEndTime,
                         )
                     }
                 }
@@ -276,7 +278,7 @@ class PhotopickerEventLogger(val dataService: Lazy<DataService>) {
                 album.displayName +
                 " with authority " +
                 album.authority +
-                " while fetching the album data source"
+                " while fetching the album data source",
         )
         return MediaSource.LOCAL
     }
diff --git a/photopicker/src/com/android/photopicker/core/features/FeatureManager.kt b/photopicker/src/com/android/photopicker/core/features/FeatureManager.kt
index 454a927a7..e3bf347fd 100644
--- a/photopicker/src/com/android/photopicker/core/features/FeatureManager.kt
+++ b/photopicker/src/com/android/photopicker/core/features/FeatureManager.kt
@@ -22,22 +22,29 @@ import androidx.compose.ui.Modifier
 import com.android.photopicker.core.configuration.PhotopickerConfiguration
 import com.android.photopicker.core.events.Event
 import com.android.photopicker.core.events.RegisteredEventClass
+import com.android.photopicker.data.PrefetchDataService
 import com.android.photopicker.features.albumgrid.AlbumGridFeature
 import com.android.photopicker.features.browse.BrowseFeature
 import com.android.photopicker.features.cloudmedia.CloudMediaFeature
 import com.android.photopicker.features.navigationbar.NavigationBarFeature
 import com.android.photopicker.features.overflowmenu.OverflowMenuFeature
 import com.android.photopicker.features.photogrid.PhotoGridFeature
+import com.android.photopicker.features.preparemedia.PrepareMediaFeature
 import com.android.photopicker.features.preview.PreviewFeature
 import com.android.photopicker.features.privacyexplainer.PrivacyExplainerFeature
 import com.android.photopicker.features.profileselector.ProfileSelectorFeature
 import com.android.photopicker.features.search.SearchFeature
 import com.android.photopicker.features.selectionbar.SelectionBarFeature
 import com.android.photopicker.features.snackbar.SnackbarFeature
+import com.android.photopicker.util.mapOfDeferredWithTimeout
+import kotlinx.coroutines.CoroutineDispatcher
 import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Deferred
+import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.flow.StateFlow
 import kotlinx.coroutines.flow.drop
 import kotlinx.coroutines.launch
+import kotlinx.coroutines.runBlocking
 
 /**
  * The core class in the feature framework, the FeatureManager manages the registration,
@@ -55,12 +62,14 @@ import kotlinx.coroutines.launch
 class FeatureManager(
     private val configuration: StateFlow<PhotopickerConfiguration>,
     private val scope: CoroutineScope,
+    private val prefetchDataService: PrefetchDataService,
     // This is in the constructor to allow tests to swap in test features.
     private val registeredFeatures: Set<FeatureRegistration> =
         FeatureManager.KNOWN_FEATURE_REGISTRATIONS,
     // These are in the constructor to allow tests to swap in core event overrides.
     private val coreEventsConsumed: Set<RegisteredEventClass> = FeatureManager.CORE_EVENTS_CONSUMED,
     private val coreEventsProduced: Set<RegisteredEventClass> = FeatureManager.CORE_EVENTS_PRODUCED,
+    private val dispatcher: CoroutineDispatcher = Dispatchers.IO,
 ) {
     companion object {
         val TAG: String = "PhotopickerFeatureManager"
@@ -84,6 +93,7 @@ class FeatureManager(
                 PrivacyExplainerFeature.Registration,
                 BrowseFeature.Registration,
                 SearchFeature.Registration,
+                PrepareMediaFeature.Registration,
             )
 
         /* The list of events that the core library consumes. */
@@ -107,7 +117,7 @@ class FeatureManager(
                 Event.ReportPhotopickerAlbumSyncInfo::class.java,
                 Event.ReportPhotopickerSearchInfo::class.java,
                 Event.ReportSearchDataExtractionDetails::class.java,
-                Event.ReportEmbeddedPhotopickerInfo::class.java
+                Event.ReportEmbeddedPhotopickerInfo::class.java,
             )
     }
 
@@ -117,6 +127,13 @@ class FeatureManager(
     // The internal map of claimed [FeatureToken] to the claiming [PhotopickerFeature]
     private val _tokenMap: HashMap<String, PhotopickerFeature> = HashMap()
 
+    // A map containing the deferred results of all prefetched data.
+    // Prefetched data is the data that features can request FeatureManager to fetch for them
+    // (typically from a different process), before the features have to decide if they are enabled
+    // or not.
+    private val _deferredPrefetchResults: Map<PrefetchResultKey, Deferred<Any?>> =
+        getDeferredPrefetchResults()
+
     /* Returns an immutable copy rather than the actual set. */
     val enabledFeatures: Set<PhotopickerFeature>
         get() = _enabledFeatures.toSet()
@@ -188,6 +205,43 @@ class FeatureManager(
         locationRegistry.clear()
     }
 
+    /**
+     * 1. Collects all prefetch data requests from features.
+     * 2. Tries to fetch all prefetched results asynchronously (in parallel on background threads).
+     *    Each prefetch result should be received within a timeout of 200ms, otherwise the task will
+     *    be cancelled and the result will be null. If an error occurs, it will be swallowed and the
+     *    result will be null.
+     *
+     * @return A Map of prefetch result key to a Deferred prefetch result value.
+     */
+    private fun getDeferredPrefetchResults(): Map<PrefetchResultKey, Deferred<Any?>> {
+        Log.d(TAG, "Beginning prefetching results in the background.")
+
+        val prefetchRequestMap:
+            MutableMap<PrefetchResultKey, suspend (PrefetchDataService) -> Any?> =
+            mutableMapOf()
+        registeredFeatures
+            .mapNotNull { it.getPrefetchRequest(configuration.value) }
+            .forEach { prefetchRequestMap.putAll(it) }
+
+        val prefetchDeferredResultsMap =
+            runBlocking(dispatcher) {
+                mapOfDeferredWithTimeout<PrefetchResultKey, PrefetchDataService>(
+                    inputMap = prefetchRequestMap,
+                    input = prefetchDataService,
+                    timeoutMillis = 200L,
+                )
+            }
+
+        Log.d(
+            TAG,
+            "Creation of deferred prefetch results map is complete for keys: " +
+                "${prefetchRequestMap.keys}",
+        )
+
+        return prefetchDeferredResultsMap
+    }
+
     /**
      * For the provided set of [FeatureRegistration]s, attempt to initialize the runtime Feature set
      * with the current [PhotopickerConfiguration].
@@ -201,7 +255,7 @@ class FeatureManager(
         Log.d(TAG, "Beginning feature initialization with config: ${configuration.value}")
 
         for (featureCompanion in registeredFeatures) {
-            if (featureCompanion.isEnabled(config)) {
+            if (featureCompanion.isEnabled(config, _deferredPrefetchResults)) {
                 val feature = featureCompanion.build(this)
                 _enabledFeatures.add(feature)
                 if (_tokenMap.contains(feature.token))
@@ -218,7 +272,7 @@ class FeatureManager(
 
         Log.d(
             TAG,
-            "Feature initialization complete. Features: ${_enabledFeatures.map { it.token }}"
+            "Feature initialization complete. Features: ${_enabledFeatures.map { it.token }}",
         )
     }
 
@@ -266,7 +320,7 @@ class FeatureManager(
                 Log.w(
                     TAG,
                     "Events are expected to be consumed that are not produced: " +
-                        "$consumedButNotProduced"
+                        "$consumedButNotProduced",
                 )
             }
         }
diff --git a/photopicker/src/com/android/photopicker/core/features/FeatureRegistration.kt b/photopicker/src/com/android/photopicker/core/features/FeatureRegistration.kt
index 9e9cab110..9fe3d7ce1 100644
--- a/photopicker/src/com/android/photopicker/core/features/FeatureRegistration.kt
+++ b/photopicker/src/com/android/photopicker/core/features/FeatureRegistration.kt
@@ -17,6 +17,8 @@
 package com.android.photopicker.core.features
 
 import com.android.photopicker.core.configuration.PhotopickerConfiguration
+import com.android.photopicker.data.PrefetchDataService
+import kotlinx.coroutines.Deferred
 
 /**
  * This registration interface represents the registration contract between [FeatureManager] and
@@ -37,6 +39,27 @@ interface FeatureRegistration {
     /** Enforces that all features define a logging tag. This does not need to be unique. */
     val TAG: String
 
+    /**
+     * Called once when [FeatureManager] is initialized for a Photopicker session.
+     *
+     * If a feature needs to run relatively expensive operation before determining whether the
+     * feature should be enabled in the current session or not, they should override this method and
+     * return a map of prefetch data requests. A prefetch data request contains a key and a lambda
+     * that fetches the required result.
+     *
+     * Please note that all prefetch requests will be timed out after a few hundred milliseconds so
+     * please ensure that the prefetch operation does not take a long time to execute.
+     *
+     * Typically a prefetch request would fetch some information required from a different process.
+     *
+     * @param config An instance of [PhotopickerConfiguration].
+     * @return A map of prefetch requests with a key from [PrefetchResultKey] and prefetch lambda as
+     *   the value.
+     */
+    fun getPrefetchRequest(
+        config: PhotopickerConfiguration
+    ): Map<PrefetchResultKey, suspend (PrefetchDataService) -> Any?>? = null
+
     /**
      * Called everytime the [PhotopickerConfiguration] of the activity is changed. This will be
      * called infrequently, (usually just once) as is used by the [FeatureManager] to determine if
@@ -46,10 +69,15 @@ interface FeatureRegistration {
      * In the event of a configuration change, this will be called again with the new configuration,
      * and will help determine if the feature should be kept in activity scope, or dereferenced.
      *
+     * @param config An instance of [PhotopickerConfiguration].
+     * @param deferredPrefetchResultsMap A map with the deferred results of prefetch results.
      * @return Whether the Feature that this FeatureRegistration represents should be enabled with
      *   the given configuration.
      */
-    fun isEnabled(config: PhotopickerConfiguration): Boolean = false
+    fun isEnabled(
+        config: PhotopickerConfiguration,
+        deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>> = mapOf(),
+    ): Boolean = false
 
     /**
      * An exposed factory method for instantiating the registered feature. This is eventually called
diff --git a/photopicker/src/com/android/photopicker/core/features/FeatureToken.kt b/photopicker/src/com/android/photopicker/core/features/FeatureToken.kt
index 53141d6ed..dc9287f0a 100644
--- a/photopicker/src/com/android/photopicker/core/features/FeatureToken.kt
+++ b/photopicker/src/com/android/photopicker/core/features/FeatureToken.kt
@@ -26,6 +26,7 @@ enum class FeatureToken(val token: String) {
     BROWSE("BROWSE"),
     CLOUD_MEDIA("CLOUD_MEDIA"),
     CORE("CORE"),
+    MEDIA_PREPARE("MEDIA_PREPARE"),
     NAVIGATION_BAR("NAVIGATION_BAR"),
     OVERFLOW_MENU("OVERFLOW_MENU"),
     PHOTO_GRID("PHOTO_GRID"),
diff --git a/photopicker/src/com/android/photopicker/core/features/Location.kt b/photopicker/src/com/android/photopicker/core/features/Location.kt
index 5582b742b..77fea8b31 100644
--- a/photopicker/src/com/android/photopicker/core/features/Location.kt
+++ b/photopicker/src/com/android/photopicker/core/features/Location.kt
@@ -32,7 +32,7 @@ enum class Location {
 
     // keep-sorted start
     COMPOSE_TOP, // UI feature entrypoint at the top of the compose UI tree.
-    MEDIA_PRELOADER, // Where the MEDIA_PRELOADER is attached to the compose tree.
+    MEDIA_PREPARER, // Where the MEDIA_PREPARER is attached to the compose tree.
     NAVIGATION_BAR, // Where the navigation bar should be drawn (when it is active).
     NAVIGATION_BAR_NAV_BUTTON, // Where the navigation bar draws navigation buttons.
     OVERFLOW_MENU, // The overflow menu anchor
diff --git a/photopicker/src/com/android/photopicker/core/features/LocationParams.kt b/photopicker/src/com/android/photopicker/core/features/LocationParams.kt
index 320648fdd..339fa5286 100644
--- a/photopicker/src/com/android/photopicker/core/features/LocationParams.kt
+++ b/photopicker/src/com/android/photopicker/core/features/LocationParams.kt
@@ -17,6 +17,7 @@
 package com.android.photopicker.core.features
 
 import com.android.photopicker.data.model.Media
+import com.android.photopicker.features.preparemedia.PrepareMediaResult
 import kotlinx.coroutines.CompletableDeferred
 import kotlinx.coroutines.flow.Flow
 
@@ -48,14 +49,14 @@ sealed interface LocationParams {
         fun onClick()
     }
 
-    /** Requirements for attaching a [MediaPreloader] to the compose UI. */
-    interface WithMediaPreloader : LocationParams {
+    /** Requirements for attaching a [MediaPreparer] to the compose UI. */
+    interface WithMediaPreparer : LocationParams {
 
-        // Method which can be called to obtain a deferred for the currently requested preload
+        // Method which can be called to obtain a deferred for the currently requested prepare
         // operation.
-        fun obtainDeferred(): CompletableDeferred<Boolean>
+        fun obtainDeferred(): CompletableDeferred<PrepareMediaResult>
 
-        // Flow to trigger the start of media preloads.
-        val preloadMedia: Flow<Set<Media>>
+        // Flow to trigger the start of media prepares.
+        val prepareMedia: Flow<Set<Media>>
     }
 }
diff --git a/photopicker/src/com/android/photopicker/core/features/PrefetchResultKey.kt b/photopicker/src/com/android/photopicker/core/features/PrefetchResultKey.kt
new file mode 100644
index 000000000..359053944
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/core/features/PrefetchResultKey.kt
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.core.features
+
+/** Holds all prefetch result keys here. See [FeatureRegistration] */
+enum class PrefetchResultKey {
+    SEARCH_STATE
+}
diff --git a/photopicker/src/com/android/photopicker/core/glide/LoadMedia.kt b/photopicker/src/com/android/photopicker/core/glide/LoadMedia.kt
index e789f6ee0..4bd37ccf6 100644
--- a/photopicker/src/com/android/photopicker/core/glide/LoadMedia.kt
+++ b/photopicker/src/com/android/photopicker/core/glide/LoadMedia.kt
@@ -23,9 +23,7 @@ import androidx.compose.runtime.Composable
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.graphics.Color
 import androidx.compose.ui.graphics.painter.ColorPainter
-import androidx.compose.ui.res.stringResource
 import androidx.compose.ui.unit.dp
-import com.android.photopicker.R
 import com.bumptech.glide.RequestBuilder
 import com.bumptech.glide.integration.compose.ExperimentalGlideComposeApi
 import com.bumptech.glide.integration.compose.GlideImage
@@ -50,15 +48,16 @@ fun loadMedia(
     media: GlideLoadable,
     resolution: Resolution,
     modifier: Modifier = Modifier,
+    contentDescription: String? = null,
     requestBuilderTransformation:
         ((
-            media: GlideLoadable, resolution: Resolution, builder: RequestBuilder<Drawable>
+            media: GlideLoadable, resolution: Resolution, builder: RequestBuilder<Drawable>,
         ) -> RequestBuilder<Drawable>)? =
-        null
+        null,
 ) {
     GlideImage(
         model = media,
-        contentDescription = stringResource(R.string.photopicker_media_item),
+        contentDescription = contentDescription,
         // Always explicitly provide a default width and height to avoid cannot measure errors in
         // headless tests. These default minimums are only overridden when the incoming
         // corresponding constraint is 0, if a smaller size is specified, that will be used.
@@ -68,9 +67,10 @@ fun loadMedia(
         failure = placeholder(ColorPainter(Color.Black)),
     ) {
         requestBuilderTransformation?.invoke(media, resolution, it)
-        // If no RequestBuilder function was provided, then apply the loadables signature to ensure
-        // the cache is populated.
-        ?: it.set(RESOLUTION_REQUESTED, resolution)
+            // If no RequestBuilder function was provided, then apply the loadables signature to
+            // ensure
+            // the cache is populated.
+            ?: it.set(RESOLUTION_REQUESTED, resolution)
                 .centerCrop()
                 .signature(media.getSignature(resolution))
     }
diff --git a/photopicker/src/com/android/photopicker/data/DataService.kt b/photopicker/src/com/android/photopicker/data/DataService.kt
index d8c7d8713..8dea92f7c 100644
--- a/photopicker/src/com/android/photopicker/data/DataService.kt
+++ b/photopicker/src/com/android/photopicker/data/DataService.kt
@@ -16,6 +16,7 @@
 
 package com.android.photopicker.data
 
+import android.content.ContentResolver
 import android.net.Uri
 import androidx.paging.PagingSource
 import com.android.photopicker.data.model.CloudMediaProviderDetails
@@ -39,6 +40,9 @@ interface DataService {
         val TAG: String = "PhotopickerDataService"
     }
 
+    /** A [StateFlow] with the active content resolver. */
+    val activeContentResolver: StateFlow<ContentResolver>
+
     /** A [StateFlow] with a list of available [Provider]-s. */
     val availableProviders: StateFlow<List<Provider>>
 
@@ -83,7 +87,7 @@ interface DataService {
      */
     fun previewMediaPagingSource(
         currentSelection: Set<Media>,
-        currentDeselection: Set<Media>
+        currentDeselection: Set<Media>,
     ): PagingSource<MediaPageKey, Media>
 
     /**
diff --git a/photopicker/src/com/android/photopicker/data/DataServiceImpl.kt b/photopicker/src/com/android/photopicker/data/DataServiceImpl.kt
index bbde6dc68..c413b7f73 100644
--- a/photopicker/src/com/android/photopicker/data/DataServiceImpl.kt
+++ b/photopicker/src/com/android/photopicker/data/DataServiceImpl.kt
@@ -89,11 +89,8 @@ class DataServiceImpl(
     private val featureManager: FeatureManager,
     private val appContext: Context,
     private val events: Events,
-    private val processOwnerHandle: UserHandle
+    private val processOwnerHandle: UserHandle,
 ) : DataService {
-    private val _activeContentResolver =
-        MutableStateFlow<ContentResolver>(userStatus.value.activeContentResolver)
-
     // Here default value being null signifies that the look up for the grants has not happened yet.
     // Use [refreshPreGrantedItemsCount] to populate this with the latest value.
     private var _preGrantedMediaCount: MutableStateFlow<Int?> = MutableStateFlow(null)
@@ -143,19 +140,19 @@ class DataServiceImpl(
 
     /**
      * Saves the current job that collects the [availableProviderCallbackFlow]. Cancel this job when
-     * there is a change in the [_activeContentResolver]
+     * there is a change in the [activeContentResolver]
      */
     private var availableProviderCollectJob: Job? = null
 
     /**
      * Saves the current job that collects the [mediaUpdateCallbackFlow]. Cancel this job when there
-     * is a change in the [_activeContentResolver]
+     * is a change in the [activeContentResolver]
      */
     private var mediaUpdateCollectJob: Job? = null
 
     /**
      * Saves the current job that collects the [albumMediaUpdateCallbackFlow]. Cancel this job when
-     * there is a change in the [_activeContentResolver]
+     * there is a change in the [activeContentResolver]
      */
     private var albumMediaUpdateCollectJob: Job? = null
 
@@ -172,6 +169,9 @@ class DataServiceImpl(
         MutableStateFlow(fetchAvailableProviders())
     }
 
+    override val activeContentResolver =
+        MutableStateFlow<ContentResolver>(userStatus.value.activeContentResolver)
+
     /**
      * Create an immutable state flow from the callback flow [_availableProviders]. The state flow
      * helps retain and provide immediate access to the last emitted value.
@@ -186,12 +186,12 @@ class DataServiceImpl(
         _availableProviders.stateIn(
             scope,
             SharingStarted.WhileSubscribed(FLOW_TIMEOUT_MILLI_SECONDS),
-            _availableProviders.value
+            _availableProviders.value,
         )
 
     // Contains collection info cache
     private val collectionInfoState =
-        CollectionInfoState(mediaProviderClient, _activeContentResolver, availableProviders)
+        CollectionInfoState(mediaProviderClient, activeContentResolver, availableProviders)
 
     override val disruptiveDataUpdateChannel = Channel<Unit>(CONFLATED)
 
@@ -241,7 +241,7 @@ class DataServiceImpl(
 
         scope.launch(dispatcher) {
             // Only observe the changes in the active content resolver
-            _activeContentResolver.collect { activeContentResolver: ContentResolver ->
+            activeContentResolver.collect { activeContentResolver: ContentResolver ->
                 Log.d(DataService.TAG, "Active content resolver has changed.")
 
                 // Stop collecting available providers from previously initialized callback flow.
@@ -253,7 +253,7 @@ class DataServiceImpl(
                         availableProviderCallbackFlow?.collect { providers: List<Provider> ->
                             Log.d(
                                 DataService.TAG,
-                                "Available providers update notification received $providers"
+                                "Available providers update notification received $providers",
                             )
 
                             updateAvailableProviders(providers)
@@ -288,7 +288,7 @@ class DataServiceImpl(
                                 DataService.TAG,
                                 "Album media update notification " +
                                     "received for album authority $albumAuthority " +
-                                    "and album id $albumId"
+                                    "and album id $albumId",
                             )
                             albumMediaPagingSourceMutex.withLock {
                                 albumMediaPagingSources
@@ -303,7 +303,7 @@ class DataServiceImpl(
 
         scope.launch(dispatcher) {
             userStatus.collect { userStatusValue: UserStatus ->
-                _activeContentResolver.update { userStatusValue.activeContentResolver }
+                activeContentResolver.update { userStatusValue.activeContentResolver }
             }
         }
     }
@@ -327,7 +327,7 @@ class DataServiceImpl(
                     resolver,
                     AVAILABLE_PROVIDERS_CHANGE_NOTIFICATION_URI,
                     /* notifyForDescendants */ true,
-                    observer
+                    observer,
                 )
 
                 // Trigger the first fetch of available providers.
@@ -361,7 +361,7 @@ class DataServiceImpl(
                 resolver,
                 MEDIA_CHANGE_NOTIFICATION_URI,
                 /* notifyForDescendants */ true,
-                observer
+                observer,
             )
 
             // Unregister when the flow is closed.
@@ -394,7 +394,7 @@ class DataServiceImpl(
                 resolver,
                 ALBUM_CHANGE_NOTIFICATION_URI,
                 /* notifyForDescendants */ true,
-                observer
+                observer,
             )
 
             // Unregister when the flow is closed.
@@ -411,7 +411,7 @@ class DataServiceImpl(
 
                 if (!albumMap.containsKey(album.id) || albumMap[album.id]!!.invalid) {
                     val availableProviders: List<Provider> = availableProviders.value
-                    val contentResolver: ContentResolver = _activeContentResolver.value
+                    val contentResolver: ContentResolver = activeContentResolver.value
                     val albumMediaPagingSource =
                         AlbumMediaPagingSource(
                             album.id,
@@ -426,7 +426,7 @@ class DataServiceImpl(
 
                     Log.v(
                         DataService.TAG,
-                        "Created an album media paging source that queries " + "$availableProviders"
+                        "Created an album media paging source that queries " + "$availableProviders",
                     )
 
                     albumMap[album.id] = albumMediaPagingSource
@@ -441,7 +441,7 @@ class DataServiceImpl(
     override fun albumPagingSource(): PagingSource<MediaPageKey, Album> = runBlocking {
         mediaPagingSourceMutex.withLock {
             val availableProviders: List<Provider> = availableProviders.value
-            val contentResolver: ContentResolver = _activeContentResolver.value
+            val contentResolver: ContentResolver = activeContentResolver.value
             val albumPagingSource =
                 AlbumPagingSource(
                     contentResolver,
@@ -454,7 +454,7 @@ class DataServiceImpl(
 
             Log.v(
                 DataService.TAG,
-                "Created an album paging source that queries " + "$availableProviders"
+                "Created an album paging source that queries " + "$availableProviders",
             )
 
             albumPagingSources.add(albumPagingSource)
@@ -471,7 +471,7 @@ class DataServiceImpl(
     override fun mediaPagingSource(): PagingSource<MediaPageKey, Media> = runBlocking {
         mediaPagingSourceMutex.withLock {
             val availableProviders: List<Provider> = availableProviders.value
-            val contentResolver: ContentResolver = _activeContentResolver.value
+            val contentResolver: ContentResolver = activeContentResolver.value
             val mediaPagingSource =
                 MediaPagingSource(
                     contentResolver,
@@ -492,11 +492,11 @@ class DataServiceImpl(
     @GuardedBy("mediaPagingSourceMutex")
     override fun previewMediaPagingSource(
         currentSelection: Set<Media>,
-        currentDeselection: Set<Media>
+        currentDeselection: Set<Media>,
     ): PagingSource<MediaPageKey, Media> = runBlocking {
         mediaPagingSourceMutex.withLock {
             val availableProviders: List<Provider> = availableProviders.value
-            val contentResolver: ContentResolver = _activeContentResolver.value
+            val contentResolver: ContentResolver = activeContentResolver.value
             val mediaPagingSource =
                 MediaPagingSource(
                     contentResolver,
@@ -507,16 +507,12 @@ class DataServiceImpl(
                     events,
                     /* is_preview_request */ true,
                     currentSelection.mapNotNull { it.mediaId }.toCollection(ArrayList()),
-                    currentDeselection
-                        .mapNotNull { it.mediaId }
-                        .toCollection(
-                            ArrayList(),
-                        ),
+                    currentDeselection.mapNotNull { it.mediaId }.toCollection(ArrayList()),
                 )
 
             Log.v(
                 DataService.TAG,
-                "Created a media paging source that queries database for" + "preview items."
+                "Created a media paging source that queries database for" + "preview items.",
             )
             mediaPagingSources.add(mediaPagingSource)
             mediaPagingSource
@@ -540,7 +536,7 @@ class DataServiceImpl(
                 Log.i(
                     DataService.TAG,
                     "A media paging source is available for " +
-                        "album ${album.id}. Not sending a refresh album media request."
+                        "album ${album.id}. Not sending a refresh album media request.",
                 )
                 return
             }
@@ -555,15 +551,15 @@ class DataServiceImpl(
                 album.id,
                 album.authority,
                 providers,
-                _activeContentResolver.value,
-                config.value
+                activeContentResolver.value,
+                config.value,
             )
         } else {
             Log.e(
                 DataService.TAG,
                 "Available providers $providers " +
                     "does not contain album authority ${album.authority}. " +
-                    "Skip sending refresh album media request."
+                    "Skip sending refresh album media request.",
             )
         }
     }
@@ -573,7 +569,7 @@ class DataServiceImpl(
     }
 
     override suspend fun ensureProviders() {
-        mediaProviderClient.ensureProviders(_activeContentResolver.value)
+        mediaProviderClient.ensureProviders(activeContentResolver.value)
         updateAvailableProviders(fetchAvailableProviders())
     }
 
@@ -603,9 +599,9 @@ class DataServiceImpl(
                         uid =
                             packageManager.getPackageUid(
                                 it.providerInfo.packageName,
-                                /* flags */ 0
+                                /* flags */ 0,
                             ),
-                        displayName = it.loadLabel(packageManager) as? String ?: ""
+                        displayName = it.loadLabel(packageManager) as? String ?: "",
                     )
                 }
 
@@ -662,8 +658,8 @@ class DataServiceImpl(
         ) {
             _preGrantedMediaCount.update {
                 mediaProviderClient.fetchMediaGrantsCount(
-                    _activeContentResolver.value,
-                    config.value.callingPackageUid ?: -1
+                    activeContentResolver.value,
+                    config.value.callingPackageUid ?: -1,
                 )
             }
         }
@@ -684,10 +680,10 @@ class DataServiceImpl(
                     mediaProviderClient.fetchFilteredMedia(
                         MediaPageKey(),
                         MediaStore.getPickImagesMaxLimit(),
-                        _activeContentResolver.value,
+                        activeContentResolver.value,
                         _availableProviders.value,
                         config.value,
-                        uris
+                        uris,
                     )
                 }
             }
@@ -704,7 +700,7 @@ class DataServiceImpl(
         if (availableProviders.isNotEmpty()) {
             mediaProviderClient.refreshMedia(
                 availableProviders,
-                _activeContentResolver.value,
+                activeContentResolver.value,
                 config.value,
             )
         } else {
@@ -719,13 +715,13 @@ class DataServiceImpl(
      */
     private fun fetchAvailableProviders(): List<Provider> {
         var availableProviders =
-            mediaProviderClient.fetchAvailableProviders(_activeContentResolver.value)
+            mediaProviderClient.fetchAvailableProviders(activeContentResolver.value)
         if (!featureManager.isFeatureEnabled(CloudMediaFeature::class.java)) {
             availableProviders = availableProviders.filter { it.mediaSource != MediaSource.REMOTE }
             Log.i(
                 DataService.TAG,
                 "Cloud media feature is not enabled, available providers are " +
-                    "updated to  $availableProviders"
+                    "updated to  $availableProviders",
             )
         }
         return availableProviders
diff --git a/photopicker/src/com/android/photopicker/data/MediaProviderClient.kt b/photopicker/src/com/android/photopicker/data/MediaProviderClient.kt
index 8da6733e9..e24ad579f 100644
--- a/photopicker/src/com/android/photopicker/data/MediaProviderClient.kt
+++ b/photopicker/src/com/android/photopicker/data/MediaProviderClient.kt
@@ -21,8 +21,10 @@ import android.content.Intent
 import android.database.Cursor
 import android.net.Uri
 import android.os.Bundle
+import android.os.CancellationSignal
 import android.util.Log
 import androidx.core.os.bundleOf
+import androidx.core.util.Preconditions.checkNotNull
 import androidx.paging.PagingSource.LoadResult
 import com.android.modules.utils.build.SdkLevel
 import com.android.photopicker.core.configuration.PhotopickerConfiguration
@@ -32,7 +34,7 @@ import com.android.photopicker.data.model.Media
 import com.android.photopicker.data.model.MediaPageKey
 import com.android.photopicker.data.model.MediaSource
 import com.android.photopicker.data.model.Provider
-import java.lang.IllegalArgumentException
+import com.android.photopicker.features.search.model.SearchRequest
 
 /**
  * A client class that is reponsible for holding logic required to interact with [MediaProvider].
@@ -43,13 +45,16 @@ open class MediaProviderClient {
     companion object {
         private const val TAG = "MediaProviderClient"
         private const val MEDIA_INIT_CALL_METHOD: String = "picker_media_init"
+        private const val SEARCH_REQUEST_INIT_CALL_METHOD = "picker_internal_search_media_init"
         private const val EXTRA_MIME_TYPES = "mime_types"
         private const val EXTRA_INTENT_ACTION = "intent_action"
+        private const val EXTRA_PROVIDERS = "providers"
         private const val EXTRA_LOCAL_ONLY = "is_local_only"
         private const val EXTRA_ALBUM_ID = "album_id"
         private const val EXTRA_ALBUM_AUTHORITY = "album_authority"
         private const val COLUMN_GRANTS_COUNT = "grants_count"
         private const val PRE_SELECTION_URIS = "pre_selection_uris"
+        const val SEARCH_REQUEST_ID = "search_request_id"
     }
 
     /** Contains all optional and mandatory keys required to make a Media query */
@@ -65,7 +70,14 @@ open class MediaProviderClient {
      * [MediaQuery] already.
      */
     private enum class AlbumMediaQuery(val key: String) {
-        ALBUM_AUTHORITY("album_authority"),
+        ALBUM_AUTHORITY("album_authority")
+    }
+
+    private enum class SearchRequestInitRequest(val key: String) {
+        SEARCH_TEXT("search_text"),
+        MEDIA_SET_ID("media_set_id"),
+        AUTHORITY("authority"),
+        TYPE("search_suggestion_type"),
     }
 
     /**
@@ -75,7 +87,7 @@ open class MediaProviderClient {
         AUTHORITY("authority"),
         MEDIA_SOURCE("media_source"),
         UID("uid"),
-        DISPLAY_NAME("display_name")
+        DISPLAY_NAME("display_name"),
     }
 
     enum class CollectionInfoResponse(val key: String) {
@@ -117,27 +129,25 @@ open class MediaProviderClient {
         DATE_TAKEN("date_taken_millis"),
         ALBUM_NAME("display_name"),
         UNWRAPPED_COVER_URI("unwrapped_cover_uri"),
-        COVER_MEDIA_SOURCE("media_source")
+        COVER_MEDIA_SOURCE("media_source"),
     }
 
     /** Contains all optional and mandatory keys for the Preview Media Query. */
     enum class PreviewMediaQuery(val key: String) {
         CURRENT_SELECTION("current_selection"),
         CURRENT_DE_SELECTION("current_de_selection"),
-        IS_FIRST_PAGE("is_first_page")
+        IS_FIRST_PAGE("is_first_page"),
     }
 
     /** Fetch available [Provider]-s from the Media Provider process. */
-    fun fetchAvailableProviders(
-        contentResolver: ContentResolver,
-    ): List<Provider> {
+    fun fetchAvailableProviders(contentResolver: ContentResolver): List<Provider> {
         try {
             contentResolver
                 .query(
                     AVAILABLE_PROVIDERS_URI,
                     /* projection */ null,
                     /* queryArgs */ null,
-                    /* cancellationSignal */ null // TODO
+                    /* cancellationSignal */ null, // TODO
                 )
                 .use { cursor ->
                     return getListOfProviders(cursor!!)
@@ -192,7 +202,7 @@ open class MediaProviderClient {
                     MEDIA_URI,
                     /* projection */ null,
                     input,
-                    /* cancellationSignal */ null // TODO
+                    /* cancellationSignal */ null, // TODO
                 )
                 .use { cursor ->
                     cursor?.let {
@@ -213,6 +223,57 @@ open class MediaProviderClient {
         }
     }
 
+    /** Fetch search results as a list of [Media] from MediaProvider for the given page key. */
+    fun fetchSearchResults(
+        searchRequestId: Int,
+        pageKey: MediaPageKey,
+        pageSize: Int,
+        contentResolver: ContentResolver,
+        availableProviders: List<Provider>,
+        config: PhotopickerConfiguration,
+        cancellationSignal: CancellationSignal?,
+    ): LoadResult<MediaPageKey, Media> {
+        val input: Bundle =
+            bundleOf(
+                MediaQuery.PICKER_ID.key to pageKey.pickerId,
+                MediaQuery.DATE_TAKEN.key to pageKey.dateTakenMillis,
+                MediaQuery.PAGE_SIZE.key to pageSize,
+                MediaQuery.PROVIDERS.key to
+                    ArrayList<String>().apply {
+                        availableProviders.forEach { provider -> add(provider.authority) }
+                    },
+                EXTRA_MIME_TYPES to config.mimeTypes,
+                EXTRA_INTENT_ACTION to config.action,
+                Intent.EXTRA_UID to config.callingPackageUid,
+            )
+
+        try {
+            return contentResolver
+                .query(
+                    getSearchResultsMediaUri(searchRequestId),
+                    /* projection */ null,
+                    input,
+                    cancellationSignal,
+                )
+                .use { cursor ->
+                    cursor?.let {
+                        LoadResult.Page(
+                            data = cursor.getListOfMedia(),
+                            prevKey = cursor.getPrevPageKey(),
+                            nextKey = cursor.getNextPageKey(),
+                            itemsBefore =
+                                cursor.getItemsBeforeCount() ?: LoadResult.Page.COUNT_UNDEFINED,
+                        )
+                    }
+                        ?: throw IllegalStateException(
+                            "Received a null response from Media Provider for search results"
+                        )
+                }
+        } catch (e: RuntimeException) {
+            throw RuntimeException("Could not fetch search results media", e)
+        }
+    }
+
     /** Fetch a list of [Media] from MediaProvider for the given page key. */
     fun fetchPreviewMedia(
         pageKey: MediaPageKey,
@@ -247,14 +308,14 @@ open class MediaProviderClient {
                     MEDIA_PREVIEW_URI,
                     /* projection */ null,
                     input,
-                    /* cancellationSignal */ null // TODO
+                    /* cancellationSignal */ null, // TODO
                 )
                 .use { cursor ->
                     cursor?.let {
                         LoadResult.Page(
                             data = cursor.getListOfMedia(),
                             prevKey = cursor.getPrevPageKey(),
-                            nextKey = cursor.getNextPageKey()
+                            nextKey = cursor.getNextPageKey(),
                         )
                     }
                         ?: throw IllegalStateException(
@@ -272,7 +333,7 @@ open class MediaProviderClient {
         pageSize: Int,
         contentResolver: ContentResolver,
         availableProviders: List<Provider>,
-        config: PhotopickerConfiguration
+        config: PhotopickerConfiguration,
     ): LoadResult<MediaPageKey, Group.Album> {
         val input: Bundle =
             bundleOf(
@@ -293,14 +354,14 @@ open class MediaProviderClient {
                     ALBUM_URI,
                     /* projection */ null,
                     input,
-                    /* cancellationSignal */ null // TODO
+                    /* cancellationSignal */ null, // TODO
                 )
                 .use { cursor ->
                     cursor?.let {
                         LoadResult.Page(
                             data = cursor.getListOfAlbums(),
                             prevKey = cursor.getPrevPageKey(),
-                            nextKey = cursor.getNextPageKey()
+                            nextKey = cursor.getNextPageKey(),
                         )
                     }
                         ?: throw IllegalStateException(
@@ -320,7 +381,7 @@ open class MediaProviderClient {
         pageSize: Int,
         contentResolver: ContentResolver,
         availableProviders: List<Provider>,
-        config: PhotopickerConfiguration
+        config: PhotopickerConfiguration,
     ): LoadResult<MediaPageKey, Media> {
         val input: Bundle =
             bundleOf(
@@ -343,14 +404,14 @@ open class MediaProviderClient {
                     getAlbumMediaUri(albumId),
                     /* projection */ null,
                     input,
-                    /* cancellationSignal */ null // TODO
+                    /* cancellationSignal */ null, // TODO
                 )
                 .use { cursor ->
                     cursor?.let {
                         LoadResult.Page(
                             data = cursor.getListOfMedia(),
                             prevKey = cursor.getPrevPageKey(),
-                            nextKey = cursor.getNextPageKey()
+                            nextKey = cursor.getNextPageKey(),
                         )
                     }
                         ?: throw IllegalStateException(
@@ -376,7 +437,7 @@ open class MediaProviderClient {
                     COLLECTION_INFO_URI,
                     /* projection */ null,
                     /* queryArgs */ null,
-                    /* cancellationSignal */ null
+                    /* cancellationSignal */ null,
                 )
                 .use { cursor ->
                     return getListOfCollectionInfo(cursor!!)
@@ -432,7 +493,7 @@ open class MediaProviderClient {
         contentResolver: ContentResolver,
         availableProviders: List<Provider>,
         config: PhotopickerConfiguration,
-        uris: List<Uri>
+        uris: List<Uri>,
     ): List<Media> {
         val input: Bundle =
             bundleOf(
@@ -456,7 +517,7 @@ open class MediaProviderClient {
                     MEDIA_PRE_SELECTION_URI,
                     /* projection */ null,
                     input,
-                    /* cancellationSignal */ null // TODO
+                    /* cancellationSignal */ null, // TODO
                 )
                 ?.getListOfMedia() ?: ArrayList()
         } catch (e: RuntimeException) {
@@ -471,7 +532,7 @@ open class MediaProviderClient {
     fun refreshMedia(
         @Suppress("UNUSED_PARAMETER") providers: List<Provider>,
         resolver: ContentResolver,
-        config: PhotopickerConfiguration
+        config: PhotopickerConfiguration,
     ) {
         val extras = Bundle()
 
@@ -497,7 +558,7 @@ open class MediaProviderClient {
         albumAuthority: String,
         providers: List<Provider>,
         resolver: ContentResolver,
-        config: PhotopickerConfiguration
+        config: PhotopickerConfiguration,
     ) {
         val extras = Bundle()
         val initLocalOnlyMedia: Boolean =
@@ -510,6 +571,66 @@ open class MediaProviderClient {
         refreshMedia(extras, resolver)
     }
 
+    /**
+     * Creates a search request with the data source.
+     *
+     * The data source is expected to return a search request id associated with the request.
+     * [MediaProviderClient] can use this search request id to query search results throughout the
+     * photopicker session.
+     *
+     * This call lets [MediaProvider] know that the Photopicker session has made a new search
+     * request and the backend should prepare to handle search results queries for the given search
+     * request.
+     */
+    fun createSearchRequest(
+        searchRequest: SearchRequest,
+        providers: List<Provider>,
+        resolver: ContentResolver,
+        config: PhotopickerConfiguration,
+    ): Int {
+        val extras =
+            bundleOf(
+                EXTRA_MIME_TYPES to config.mimeTypes,
+                EXTRA_INTENT_ACTION to config.action,
+                EXTRA_PROVIDERS to
+                    ArrayList<String>().apply {
+                        providers.forEach { provider -> add(provider.authority) }
+                    },
+            )
+
+        when (searchRequest) {
+            is SearchRequest.SearchTextRequest ->
+                extras.putString(SearchRequestInitRequest.SEARCH_TEXT.key, searchRequest.searchText)
+            is SearchRequest.SearchSuggestionRequest -> {
+                extras.putString(
+                    SearchRequestInitRequest.SEARCH_TEXT.key,
+                    searchRequest.suggestion.displayText,
+                )
+                extras.putString(
+                    SearchRequestInitRequest.AUTHORITY.key,
+                    searchRequest.suggestion.authority,
+                )
+                extras.putString(
+                    SearchRequestInitRequest.MEDIA_SET_ID.key,
+                    searchRequest.suggestion.mediaSetId,
+                )
+                extras.putString(
+                    SearchRequestInitRequest.TYPE.key,
+                    searchRequest.suggestion.type.name,
+                )
+            }
+        }
+
+        val result: Bundle? =
+            resolver.call(
+                MEDIA_PROVIDER_AUTHORITY,
+                SEARCH_REQUEST_INIT_CALL_METHOD,
+                /* arg */ null,
+                extras,
+            )
+        return checkNotNull(result?.getInt(SEARCH_REQUEST_ID), "Search request ID cannot be null")
+    }
+
     /** Creates a list of [Provider] from the given [Cursor]. */
     private fun getListOfProviders(cursor: Cursor): List<Provider> {
         val result: MutableList<Provider> = mutableListOf<Provider>()
@@ -540,7 +661,7 @@ open class MediaProviderClient {
                                 cursor.getColumnIndexOrThrow(
                                     AvailableProviderResponse.DISPLAY_NAME.key
                                 )
-                            )
+                            ),
                     )
                 )
             } while (cursor.moveToNext())
@@ -581,7 +702,7 @@ open class MediaProviderClient {
                                     CollectionInfoResponse.ACCOUNT_NAME.key
                                 )
                             ),
-                        accountConfigurationIntent = accountConfigurationIntent
+                        accountConfigurationIntent = accountConfigurationIntent,
                     )
                 )
             } while (cursor.moveToNext())
@@ -636,7 +757,7 @@ open class MediaProviderClient {
                             sizeInBytes = sizeInBytes,
                             mimeType = mimeType,
                             standardMimeTypeExtension = standardMimeTypeExtension,
-                            isPreGranted = (isPregranted == 1) // here 1 denotes true else false
+                            isPreGranted = (isPregranted == 1), // here 1 denotes true else false
                         )
                     )
                 } else if (mimeType.startsWith("video/")) {
@@ -654,7 +775,7 @@ open class MediaProviderClient {
                             mimeType = mimeType,
                             standardMimeTypeExtension = standardMimeTypeExtension,
                             duration = getInt(getColumnIndexOrThrow(MediaResponse.DURATION.key)),
-                            isPreGranted = (isPregranted == 1) // here 1 denotes true else false
+                            isPreGranted = (isPregranted == 1), // here 1 denotes true else false
                         )
                     )
                 } else {
@@ -735,7 +856,7 @@ open class MediaProviderClient {
                                 getString(
                                     getColumnIndexOrThrow(AlbumResponse.COVER_MEDIA_SOURCE.key)
                                 )
-                            )
+                            ),
                     )
                 )
             } while (moveToNext())
@@ -754,7 +875,7 @@ open class MediaProviderClient {
                 MEDIA_PROVIDER_AUTHORITY,
                 MEDIA_INIT_CALL_METHOD,
                 /* arg */ null,
-                extras
+                extras,
             )
         } catch (e: RuntimeException) {
             Log.e(TAG, "Could not send refresh media call to Media Provider $extras", e)
diff --git a/photopicker/src/com/android/photopicker/data/PrefetchDataService.kt b/photopicker/src/com/android/photopicker/data/PrefetchDataService.kt
new file mode 100644
index 000000000..a23b139a2
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/data/PrefetchDataService.kt
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.data
+
+import com.android.photopicker.features.search.model.SearchEnabledState
+
+/** Class responsible to fetch all the required data before feature initialization */
+interface PrefetchDataService {
+    companion object {
+        val TAG: String = "PrefetchDataService"
+    }
+
+    suspend fun getSearchState(): SearchEnabledState
+}
diff --git a/photopicker/src/com/android/photopicker/data/PrefetchDataServiceImpl.kt b/photopicker/src/com/android/photopicker/data/PrefetchDataServiceImpl.kt
new file mode 100644
index 000000000..2d2044ba5
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/data/PrefetchDataServiceImpl.kt
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.data
+
+import com.android.photopicker.features.search.model.SearchEnabledState
+
+class PrefetchDataServiceImpl() : PrefetchDataService {
+
+    override suspend fun getSearchState(): SearchEnabledState {
+        return SearchEnabledState.DISABLED
+    }
+}
diff --git a/photopicker/src/com/android/photopicker/data/UriHelper.kt b/photopicker/src/com/android/photopicker/data/UriHelper.kt
index 170a6926b..b8312d7c0 100644
--- a/photopicker/src/com/android/photopicker/data/UriHelper.kt
+++ b/photopicker/src/com/android/photopicker/data/UriHelper.kt
@@ -30,6 +30,10 @@ private const val ALBUM_PATH_SEGMENT = "album"
 private const val MEDIA_GRANTS_COUNT_PATH_SEGMENT = "media_grants_count"
 private const val PREVIEW_PATH_SEGMENT = "preview"
 private const val PRE_SELECTION_URI_PATH_SEGMENT = "pre_selection"
+private const val SEARCH_MEDIA_PATH_SEGMENT = "search_media"
+
+const val PICKER_SEGMENT = "picker"
+const val PICKER_TRANSCODED_SEGMENT = "picker_transcoded"
 
 private val pickerUri: Uri =
     Uri.Builder()
@@ -100,3 +104,13 @@ val ALBUM_CHANGE_NOTIFICATION_URI: Uri =
 fun getAlbumMediaUri(albumId: String): Uri {
     return ALBUM_URI.buildUpon().apply { appendPath(albumId) }.build()
 }
+
+fun getSearchResultsMediaUri(searchRequestId: Int): Uri {
+    return pickerUri
+        .buildUpon()
+        .apply {
+            appendPath(SEARCH_MEDIA_PATH_SEGMENT)
+            appendPath(searchRequestId.toString())
+        }
+        .build()
+}
diff --git a/photopicker/src/com/android/photopicker/extensions/Intent.kt b/photopicker/src/com/android/photopicker/extensions/Intent.kt
index ef7d0a40b..111ed9814 100644
--- a/photopicker/src/com/android/photopicker/extensions/Intent.kt
+++ b/photopicker/src/com/android/photopicker/extensions/Intent.kt
@@ -17,8 +17,11 @@
 package com.android.photopicker.extensions
 
 import android.content.Intent
+import android.media.ApplicationMediaCapabilities
 import android.net.Uri
+import android.os.Build
 import android.provider.MediaStore
+import androidx.annotation.RequiresApi
 import com.android.modules.utils.build.SdkLevel
 import com.android.photopicker.core.configuration.IllegalIntentExtraException
 import com.android.photopicker.core.navigation.PhotopickerDestinations
@@ -120,7 +123,7 @@ fun Intent.getStartDestination(default: PhotopickerDestinations): PhotopickerDes
                     getIntExtra(
                         MediaStore.EXTRA_PICK_IMAGES_LAUNCH_TAB,
                         // The default does not match any destination
-                        /* default= */ 9999
+                        /* default= */ 9999,
                     )
                 ) {
                     MediaStore.PICK_IMAGES_TAB_ALBUMS -> PhotopickerDestinations.ALBUM_GRID
@@ -255,7 +258,7 @@ fun Intent.getPickImagesPreSelectedUris(): ArrayList<Uri>? {
                         (if (SdkLevel.isAtLeastT()) {
                                 it.getParcelableArrayList(
                                     MediaStore.EXTRA_PICKER_PRE_SELECTION_URIS,
-                                    Uri::class.java
+                                    Uri::class.java,
                                 ) as ArrayList<Uri>
                             } else {
                                 it.getParcelableArrayList<Uri>(
@@ -289,6 +292,38 @@ fun Intent.getPickImagesPreSelectedUris(): ArrayList<Uri>? {
     return preSelectedUris
 }
 
+/**
+ * Fetches the [MediaStore.EXTRA_MEDIA_CAPABILITIES] extra from the intent.
+ *
+ * @return The [ApplicationMediaCapabilities] if present, null otherwise.
+ */
+@Suppress("DEPRECATION")
+@RequiresApi(Build.VERSION_CODES.S)
+fun Intent.getApplicationMediaCapabilities(): ApplicationMediaCapabilities? {
+    extras?.apply {
+        if (containsKey(MediaStore.EXTRA_MEDIA_CAPABILITIES)) {
+            if (action != MediaStore.ACTION_PICK_IMAGES) {
+                // This intent extra is only supported for ACTION_PICK_IMAGES
+                throw IllegalIntentExtraException(
+                    "EXTRA_MEDIA_CAPABILITIES is not supported for $action, " +
+                        "use ACTION_PICK_IMAGES instead."
+                )
+            }
+
+            return if (SdkLevel.isAtLeastT()) {
+                getParcelable(
+                    MediaStore.EXTRA_MEDIA_CAPABILITIES,
+                    ApplicationMediaCapabilities::class.java,
+                )
+            } else {
+                getParcelable(MediaStore.EXTRA_MEDIA_CAPABILITIES)
+            }
+        }
+    }
+
+    return null
+}
+
 /**
  * Determines if the mimeType is a media mimetype that Photopicker can support.
  *
diff --git a/photopicker/src/com/android/photopicker/extensions/Modifier.kt b/photopicker/src/com/android/photopicker/extensions/Modifier.kt
index 4e75f4f99..a29b5e70e 100644
--- a/photopicker/src/com/android/photopicker/extensions/Modifier.kt
+++ b/photopicker/src/com/android/photopicker/extensions/Modifier.kt
@@ -19,21 +19,25 @@ package com.android.photopicker.extensions
 import android.os.Build
 import android.view.SurfaceControlViewHost
 import androidx.annotation.RequiresApi
+import androidx.compose.foundation.gestures.Orientation
+import androidx.compose.foundation.gestures.awaitEachGesture
+import androidx.compose.foundation.gestures.awaitFirstDown
 import androidx.compose.foundation.lazy.grid.LazyGridState
 import androidx.compose.runtime.State
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.draw.drawBehind
 import androidx.compose.ui.geometry.Offset
+import androidx.compose.ui.geometry.isSpecified
 import androidx.compose.ui.graphics.Color
 import androidx.compose.ui.graphics.drawscope.Stroke
 import androidx.compose.ui.graphics.isUnspecified
-import androidx.compose.ui.input.pointer.PointerEvent
-import androidx.compose.ui.input.pointer.PointerEventType
+import androidx.compose.ui.input.pointer.PointerEventPass
 import androidx.compose.ui.input.pointer.pointerInput
 import androidx.compose.ui.layout.layout
 import androidx.compose.ui.unit.Dp
 import androidx.compose.ui.unit.dp
 import androidx.compose.ui.unit.offset
+import com.android.photopicker.util.TouchSlopDetector
 
 /**
  * Draws circle with a solid [color] behind the content.
@@ -50,7 +54,7 @@ fun Modifier.circleBackground(
     color: Color,
     padding: Dp,
     borderColor: Color = Color.Unspecified,
-    borderWidth: Dp = 1.dp
+    borderWidth: Dp = 1.dp,
 ): Modifier {
     val backgroundModifier = drawBehind {
         drawCircle(color, size.width / 2f, center = Offset(size.width / 2f, size.height / 2f))
@@ -59,7 +63,7 @@ fun Modifier.circleBackground(
                 borderColor,
                 size.width / 2f,
                 center = Offset(size.width / 2f, size.height / 2f),
-                style = Stroke(width = borderWidth.roundToPx().toFloat())
+                style = Stroke(width = borderWidth.roundToPx().toFloat()),
             )
         }
     }
@@ -81,7 +85,7 @@ fun Modifier.circleBackground(
             // Place the composable at the calculated position
             placeable.placeRelative(
                 (newDiameter - currentWidth) / 2,
-                (newDiameter - currentHeight) / 2
+                (newDiameter - currentHeight) / 2,
             )
         }
     }
@@ -103,14 +107,10 @@ fun Modifier.circleBackground(
 fun Modifier.transferGridTouchesToHostInEmbedded(
     state: LazyGridState,
     isExpanded: State<Boolean>,
-    host: SurfaceControlViewHost
+    host: SurfaceControlViewHost,
 ): Modifier {
     return this then
-        transferTouchesToSurfaceControlViewHost(
-            state = state,
-            isExpanded = isExpanded,
-            host = host,
-        )
+        transferTouchesToSurfaceControlViewHost(state = state, isExpanded = isExpanded, host = host)
 }
 
 /**
@@ -127,7 +127,13 @@ fun Modifier.transferTouchesToHostInEmbedded(host: SurfaceControlViewHost): Modi
 }
 
 /**
- * Transfer necessary touch events to host on runtime in Embedded Photopicker
+ * Transfer necessary touch events to host on runtime in Embedded Photopicker.
+ *
+ * This custom modifier has been explicitly applied to four different components - the navigation
+ * bar, Album media grid's empty state, Photos grid's empty state and media grid.
+ *
+ * Todo(b/368021407): Touches should also be transferred into the empty spaces left within the
+ * embedded
  *
  * @param state the state of Photos/albums grid. If state is null means Photos/Albums grid has not
  *   requested the custom modifier
@@ -139,81 +145,87 @@ fun Modifier.transferTouchesToHostInEmbedded(host: SurfaceControlViewHost): Modi
 private fun Modifier.transferTouchesToSurfaceControlViewHost(
     state: LazyGridState?,
     isExpanded: State<Boolean>?,
-    host: SurfaceControlViewHost
+    host: SurfaceControlViewHost,
 ): Modifier {
 
-    /**
-     * Initial y position when user touches the screen or when [PointerEventType.Press] is received
-     */
-    var initialY = 0F
-
-    /**
-     * Difference in Y position with respect to initialY as user starts scrolling on the screen, to
-     * know the direction of the movement
-     */
-    var dy = 0F
-
     val pointerInputModifier =
         pointerInput(Unit) {
-            awaitPointerEventScope {
-                while (true) {
-                    // Suspend until next pointer event
-                    val event: PointerEvent = awaitPointerEvent()
-                    event.changes.forEach { change ->
-                        if (state != null) {
-                            when (event.type) {
-                                PointerEventType.Press -> {
-                                    // Set initial Y position when user touches the screen
-                                    initialY = change.position.y
-                                }
-                                PointerEventType.Move -> {
-                                    // Position difference with respect to initial position
-                                    dy = change.position.y - initialY
-                                }
-                                PointerEventType.Release -> {
-                                    // Resetting the position change for next touch event
-                                    dy = 0F
-                                }
+            awaitEachGesture {
+                val touchSlop = viewConfiguration.touchSlop
+                val touchSlopDetector = TouchSlopDetector(Orientation.Vertical)
+
+                // This needs to run in the [PointerEventPass.Initial] to ensure that the event
+                // can be handled in the parent, rather than the child.
+                //
+                // This touch handler is a parent of the touch handler the grid is using to monitor
+                // clicks & scroll, so these touches are processed in the first pass, and if they
+                // aren't transferred to the host they will be processed by the grid in the
+                // [PointerEventPass.Main]
+                val down =
+                    awaitFirstDown(requireUnconsumed = false, pass = PointerEventPass.Initial)
+                val pointerId = down.id
+
+                // Now that a down exists set up a loop which processes the touch input and
+                // evaluates if it should be sent to the host.
+                do {
+                    val event = awaitPointerEvent(pass = PointerEventPass.Initial)
+                    val dragEvent = event.changes.firstOrNull { it.id == pointerId }
+
+                    // If the dragEvent cannot be found for the pointer, or is consumed elsewhere
+                    // cancel this gesture.
+                    val canceled = dragEvent?.isConsumed ?: true
+
+                    val postSlopOffset =
+                        if (dragEvent != null)
+                            touchSlopDetector.addPointerInputChange(dragEvent, touchSlop)
+                        else Offset.Unspecified
+
+                    // Once pastTouchSlop check to see if the touch meets the conditions to be
+                    // transferred to the host.
+                    if (postSlopOffset.isSpecified) {
+
+                        val isGridCollapsed =
+                            state != null && isExpanded != null && !isExpanded.value
+                        val isGridExpanded = state != null && isExpanded != null && isExpanded.value
+
+                        val shouldTransferToHost =
+                            when {
+
+                                // When this isn't attached to a grid, all vertical gestures should
+                                // be transferred.
+                                state == null -> true
+
+                                // If the grid is collapsed and vertical touchSlop has been passed,
+                                // touches should be transferred.
+                                isGridCollapsed -> true
+
+                                // If the grid isExpanded, scrolled to the first item and the
+                                // gesture
+                                // direction was up (to collapse the Photopicker)
+                                isGridExpanded &&
+                                    (state.firstVisibleItemIndex == 0 &&
+                                        state.firstVisibleItemScrollOffset == 0 &&
+                                        postSlopOffset.y > 0F) -> true
+
+                                // Otherwise don't transfer
+                                else -> false
                             }
-                        }
-                    }
-
-                    // Todo(b/356790658) : Avoid recalculate these every time, just do it when
-                    // argument changes
-                    val isGridCollapsed = state != null && isExpanded != null && !isExpanded.value
-                    val isGridExpanded = state != null && isExpanded != null && isExpanded.value
 
-                    // Event is done being processed, make a decision about if this event should
-                    // be transferred
-                    val shouldTransferToHost =
-                        when {
-
-                            // Never transfer if the event type isn't move
-                            event.type != PointerEventType.Move -> false
-
-                            // Case for Not Grid attached modifiers
-                            state == null -> true
-
-                            // Case for grid attached when embedded is collapsed
-                            isGridCollapsed && dy != 0F -> true
-
-                            // Case for grid attached when embedded is expanded, and
-                            // the lazy grid is at the top of its scroll container
-                            isGridExpanded &&
-                                (state.firstVisibleItemIndex == 0 &&
-                                    state.firstVisibleItemScrollOffset == 0 &&
-                                    dy > 0) -> true
-
-                            // Otherwise don't transfer
-                            else -> false
+                        if (shouldTransferToHost) {
+                            // TODO(b/356671436): Use V API when available
+                            @Suppress("DEPRECATION") host.transferTouchGestureToHost()
                         }
-
-                    if (shouldTransferToHost) {
-                        // TODO(b/356671436): Use V API when available
-                        @Suppress("DEPRECATION") host.transferTouchGestureToHost()
                     }
-                }
+                } while (
+                    // Continue monitoring this event if it hasn't been consumed elsewhere.
+                    !canceled &&
+
+                        // Only monitor the event if it is a finger touching the screen or mouse
+                        // button is being pressed.
+                        event.changes.any { it.pressed }
+                )
             }
         }
+
     return this then pointerInputModifier
 }
diff --git a/photopicker/src/com/android/photopicker/features/albumgrid/AlbumGrid.kt b/photopicker/src/com/android/photopicker/features/albumgrid/AlbumGrid.kt
index 9863fa780..30bd76dab 100644
--- a/photopicker/src/com/android/photopicker/features/albumgrid/AlbumGrid.kt
+++ b/photopicker/src/com/android/photopicker/features/albumgrid/AlbumGrid.kt
@@ -38,6 +38,8 @@ import com.android.photopicker.R
 import com.android.photopicker.core.components.MediaGridItem
 import com.android.photopicker.core.components.mediaGrid
 import com.android.photopicker.core.configuration.LocalPhotopickerConfiguration
+import com.android.photopicker.core.configuration.PhotopickerRuntimeEnv
+import com.android.photopicker.core.embedded.LocalEmbeddedState
 import com.android.photopicker.core.events.Event
 import com.android.photopicker.core.events.LocalEvents
 import com.android.photopicker.core.events.Telemetry
@@ -79,6 +81,10 @@ fun AlbumGrid(viewModel: AlbumGridViewModel = obtainViewModel()) {
     val events = LocalEvents.current
     val scope = rememberCoroutineScope()
 
+    val isEmbedded =
+        LocalPhotopickerConfiguration.current.runtimeEnv == PhotopickerRuntimeEnv.EMBEDDED
+    val isExpanded = LocalEmbeddedState.current?.isExpanded ?: false
+
     // Use the expanded layout any time the Width is Medium or larger.
     val isExpandedScreen: Boolean =
         when (LocalWindowSizeClass.current.widthSizeClass) {
@@ -106,7 +112,7 @@ fun AlbumGrid(viewModel: AlbumGridViewModel = obtainViewModel()) {
                                             FeatureToken.ALBUM_GRID.token,
                                             configuration.sessionId,
                                             configuration.callingPackageUid ?: -1,
-                                            Telemetry.UiEvent.SWITCH_PICKER_TAB
+                                            Telemetry.UiEvent.SWITCH_PICKER_TAB,
                                         )
                                     )
                                 }
@@ -120,6 +126,11 @@ fun AlbumGrid(viewModel: AlbumGridViewModel = obtainViewModel()) {
         // the album content for the album that is selected by the user.
         mediaGrid(
             items = items,
+            userScrollEnabled =
+                when (isEmbedded) {
+                    true -> isExpanded
+                    false -> true
+                },
             onItemClick = { item ->
                 if (item is MediaGridItem.AlbumItem) {
                     // Dispatch events to log album related details
@@ -129,7 +140,7 @@ fun AlbumGrid(viewModel: AlbumGridViewModel = obtainViewModel()) {
                                 FeatureToken.ALBUM_GRID.token,
                                 configuration.sessionId,
                                 configuration.callingPackageUid ?: -1,
-                                item.album
+                                item.album,
                             )
                         )
                         events.dispatch(
@@ -137,7 +148,7 @@ fun AlbumGrid(viewModel: AlbumGridViewModel = obtainViewModel()) {
                                 FeatureToken.ALBUM_GRID.token,
                                 configuration.sessionId,
                                 configuration.callingPackageUid ?: -1,
-                                Telemetry.UiEvent.PICKER_ALBUMS_INTERACTION
+                                Telemetry.UiEvent.PICKER_ALBUMS_INTERACTION,
                             )
                         )
                     }
@@ -163,7 +174,7 @@ fun AlbumGrid(viewModel: AlbumGridViewModel = obtainViewModel()) {
                         FeatureToken.PHOTO_GRID.token,
                         configuration.sessionId,
                         configuration.callingPackageUid ?: -1,
-                        Telemetry.UiEvent.UI_LOADED_ALBUMS
+                        Telemetry.UiEvent.UI_LOADED_ALBUMS,
                     )
                 )
             }
@@ -193,7 +204,7 @@ fun AlbumGridNavButton(modifier: Modifier) {
                         FeatureToken.ALBUM_GRID.token,
                         sessionId,
                         packageUid,
-                        Telemetry.UiEvent.SWITCH_PICKER_TAB
+                        Telemetry.UiEvent.SWITCH_PICKER_TAB,
                     )
                 )
             }
diff --git a/photopicker/src/com/android/photopicker/features/albumgrid/AlbumGridFeature.kt b/photopicker/src/com/android/photopicker/features/albumgrid/AlbumGridFeature.kt
index f763737e6..8d213df44 100644
--- a/photopicker/src/com/android/photopicker/features/albumgrid/AlbumGridFeature.kt
+++ b/photopicker/src/com/android/photopicker/features/albumgrid/AlbumGridFeature.kt
@@ -26,6 +26,7 @@ import androidx.compose.ui.Modifier
 import androidx.navigation.NamedNavArgument
 import androidx.navigation.NavBackStackEntry
 import androidx.navigation.NavDeepLink
+import com.android.photopicker.core.animations.springDefaultEffectOffset
 import com.android.photopicker.core.configuration.PhotopickerConfiguration
 import com.android.photopicker.core.events.Event
 import com.android.photopicker.core.events.RegisteredEventClass
@@ -35,11 +36,13 @@ import com.android.photopicker.core.features.FeatureToken
 import com.android.photopicker.core.features.Location
 import com.android.photopicker.core.features.LocationParams
 import com.android.photopicker.core.features.PhotopickerUiFeature
+import com.android.photopicker.core.features.PrefetchResultKey
 import com.android.photopicker.core.features.Priority
 import com.android.photopicker.core.navigation.PhotopickerDestinations.ALBUM_GRID
 import com.android.photopicker.core.navigation.PhotopickerDestinations.ALBUM_MEDIA_GRID
 import com.android.photopicker.core.navigation.Route
 import com.android.photopicker.data.model.Group
+import kotlinx.coroutines.Deferred
 import kotlinx.coroutines.flow.StateFlow
 
 /**
@@ -51,7 +54,10 @@ class AlbumGridFeature : PhotopickerUiFeature {
     companion object Registration : FeatureRegistration {
         override val TAG: String = "PhotopickerAlbumGridFeature"
 
-        override fun isEnabled(config: PhotopickerConfiguration) = true
+        override fun isEnabled(
+            config: PhotopickerConfiguration,
+            deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>>,
+        ) = true
 
         override fun build(featureManager: FeatureManager) = AlbumGridFeature()
 
@@ -68,13 +74,11 @@ class AlbumGridFeature : PhotopickerUiFeature {
         setOf(
             Event.ShowSnackbarMessage::class.java,
             Event.LogPhotopickerUIEvent::class.java,
-            Event.LogPhotopickerAlbumOpenedUIEvent::class.java
+            Event.LogPhotopickerAlbumOpenedUIEvent::class.java,
         )
 
     override fun registerLocations(): List<Pair<Location, Int>> {
-        return listOf(
-            Pair(Location.NAVIGATION_BAR_NAV_BUTTON, Priority.HIGH.priority),
-        )
+        return listOf(Pair(Location.NAVIGATION_BAR_NAV_BUTTON, Priority.HIGH.priority))
     }
 
     override fun registerNavigationRoutes(): Set<Route> {
@@ -100,44 +104,48 @@ class AlbumGridFeature : PhotopickerUiFeature {
                     (AnimatedContentTransitionScope<NavBackStackEntry>.() -> EnterTransition)? =
                     {
                         if (initialState.destination.route == ALBUM_MEDIA_GRID.route) {
-                            // no animation required if previous route was from ALBUM_MEDIA_GRID.
-                            EnterTransition.None
+                            // Negative value to slide right-to-left
+                            // if previous route was from ALBUM_MEDIA_GRID.
+                            slideInHorizontally(animationSpec = springDefaultEffectOffset) { -it }
                         } else {
                             // Positive value to slide left-to-right
-                            slideInHorizontally { it }
+                            slideInHorizontally(animationSpec = springDefaultEffectOffset) { it }
                         }
                     }
                 override val exitTransition:
                     (AnimatedContentTransitionScope<NavBackStackEntry>.() -> ExitTransition)? =
                     {
                         if (targetState.destination.route == ALBUM_MEDIA_GRID.route) {
-                            // no animation required if previous route was from ALBUM_MEDIA_GRID.
-                            ExitTransition.None
+                            // Negative value to slide right-to-left
+                            // if target route is ALBUM_MEDIA_GRID
+                            slideOutHorizontally(animationSpec = springDefaultEffectOffset) { -it }
                         } else {
                             // Positive value to slide left-to-right
-                            slideOutHorizontally { it }
+                            slideOutHorizontally(animationSpec = springDefaultEffectOffset) { it }
                         }
                     }
                 override val popEnterTransition:
                     (AnimatedContentTransitionScope<NavBackStackEntry>.() -> EnterTransition)? =
                     {
                         if (initialState.destination.route == ALBUM_MEDIA_GRID.route) {
-                            // no animation required if previous route was from ALBUM_MEDIA_GRID.
-                            EnterTransition.None
+                            // Negative value to slide right-to-left
+                            // if previous route was from ALBUM_MEDIA_GRID.
+                            slideInHorizontally(animationSpec = springDefaultEffectOffset) { -it }
                         } else {
                             // Positive value to slide left-to-right
-                            slideInHorizontally { it }
+                            slideInHorizontally(animationSpec = springDefaultEffectOffset) { it }
                         }
                     }
                 override val popExitTransition:
                     (AnimatedContentTransitionScope<NavBackStackEntry>.() -> ExitTransition)? =
                     {
                         if (targetState.destination.route == ALBUM_MEDIA_GRID.route) {
-                            // no animation required if previous route was from ALBUM_MEDIA_GRID.
-                            ExitTransition.None
+                            // Negative value to slide right-to-left
+                            // if target route is ALBUM_MEDIA_GRID
+                            slideOutHorizontally(animationSpec = springDefaultEffectOffset) { -it }
                         } else {
                             // Positive value to slide left-to-right
-                            slideOutHorizontally { it }
+                            slideOutHorizontally(animationSpec = springDefaultEffectOffset) { it }
                         }
                     }
 
@@ -162,22 +170,23 @@ class AlbumGridFeature : PhotopickerUiFeature {
                 override val enterTransition:
                     (AnimatedContentTransitionScope<NavBackStackEntry>.() -> EnterTransition)? =
                     {
-                        EnterTransition.None
+                        // Positive value to slide left-to-right
+                        slideInHorizontally(animationSpec = springDefaultEffectOffset) { it }
                     }
                 override val exitTransition:
                     (AnimatedContentTransitionScope<NavBackStackEntry>.() -> ExitTransition)? =
                     {
-                        ExitTransition.None
+                        slideOutHorizontally(animationSpec = springDefaultEffectOffset) { it }
                     }
                 override val popEnterTransition:
                     (AnimatedContentTransitionScope<NavBackStackEntry>.() -> EnterTransition)? =
                     {
-                        EnterTransition.None
+                        slideInHorizontally(animationSpec = springDefaultEffectOffset) { it }
                     }
                 override val popExitTransition:
                     (AnimatedContentTransitionScope<NavBackStackEntry>.() -> ExitTransition)? =
                     {
-                        ExitTransition.None
+                        slideOutHorizontally(animationSpec = springDefaultEffectOffset) { it }
                     }
 
                 @Composable
@@ -186,7 +195,7 @@ class AlbumGridFeature : PhotopickerUiFeature {
                         checkNotNull(
                             navBackStackEntry
                                 ?.savedStateHandle
-                                ?.getStateFlow<Group.Album?>(ALBUM_KEY, null),
+                                ?.getStateFlow<Group.Album?>(ALBUM_KEY, null)
                         ) {
                             "Unable to get a savedStateHandle for album content grid"
                         }
@@ -197,11 +206,7 @@ class AlbumGridFeature : PhotopickerUiFeature {
     }
 
     @Composable
-    override fun compose(
-        location: Location,
-        modifier: Modifier,
-        params: LocationParams,
-    ) {
+    override fun compose(location: Location, modifier: Modifier, params: LocationParams) {
         when (location) {
             Location.NAVIGATION_BAR_NAV_BUTTON -> AlbumGridNavButton(modifier)
             else -> {}
diff --git a/photopicker/src/com/android/photopicker/features/albumgrid/AlbumMediaGrid.kt b/photopicker/src/com/android/photopicker/features/albumgrid/AlbumMediaGrid.kt
index 13b0109ab..ca112202a 100644
--- a/photopicker/src/com/android/photopicker/features/albumgrid/AlbumMediaGrid.kt
+++ b/photopicker/src/com/android/photopicker/features/albumgrid/AlbumMediaGrid.kt
@@ -44,11 +44,14 @@ import androidx.lifecycle.compose.collectAsStateWithLifecycle
 import androidx.paging.LoadState
 import androidx.paging.PagingData
 import androidx.paging.compose.collectAsLazyPagingItems
+import com.android.modules.utils.build.SdkLevel
 import com.android.photopicker.R
 import com.android.photopicker.core.components.EmptyState
 import com.android.photopicker.core.components.MediaGridItem
 import com.android.photopicker.core.components.mediaGrid
 import com.android.photopicker.core.configuration.LocalPhotopickerConfiguration
+import com.android.photopicker.core.configuration.PhotopickerRuntimeEnv
+import com.android.photopicker.core.embedded.LocalEmbeddedState
 import com.android.photopicker.core.events.Event
 import com.android.photopicker.core.events.LocalEvents
 import com.android.photopicker.core.events.Telemetry
@@ -61,7 +64,9 @@ import com.android.photopicker.core.selection.LocalSelection
 import com.android.photopicker.core.theme.LocalWindowSizeClass
 import com.android.photopicker.data.model.Group
 import com.android.photopicker.extensions.navigateToPreviewMedia
+import com.android.photopicker.extensions.transferTouchesToHostInEmbedded
 import com.android.photopicker.features.preview.PreviewFeature
+import com.android.photopicker.util.LocalLocalizationHelper
 import kotlinx.coroutines.flow.Flow
 import kotlinx.coroutines.flow.StateFlow
 import kotlinx.coroutines.launch
@@ -77,15 +82,18 @@ import kotlinx.coroutines.launch
 @Composable
 fun AlbumMediaGrid(
     flow: StateFlow<Group.Album?>,
-    viewModel: AlbumGridViewModel = obtainViewModel()
+    viewModel: AlbumGridViewModel = obtainViewModel(),
 ) {
     val albumState by flow.collectAsStateWithLifecycle(initialValue = null)
     val album = albumState
 
-    when (album) {
-        null -> {}
-        else -> {
-            AlbumMediaGrid(album = album, albumItems = viewModel.getAlbumMedia(album))
+    Column(modifier = Modifier.fillMaxSize()) {
+        when (album) {
+            null -> {}
+            else -> {
+                val albumItems = remember(album) { viewModel.getAlbumMedia(album) }
+                AlbumMediaGrid(album = album, albumItems = albumItems)
+            }
         }
     }
 }
@@ -108,8 +116,12 @@ private fun AlbumMediaGrid(
     val selection by LocalSelection.current.flow.collectAsStateWithLifecycle()
 
     val selectionLimit = LocalPhotopickerConfiguration.current.selectionLimit
+    val localizedSelectionLimit = LocalLocalizationHelper.current.getLocalizedCount(selectionLimit)
     val selectionLimitExceededMessage =
-        stringResource(R.string.photopicker_selection_limit_exceeded_snackbar, selectionLimit)
+        stringResource(
+            R.string.photopicker_selection_limit_exceeded_snackbar,
+            localizedSelectionLimit,
+        )
     val scope = rememberCoroutineScope()
     val events = LocalEvents.current
     val configuration = LocalPhotopickerConfiguration.current
@@ -123,6 +135,11 @@ private fun AlbumMediaGrid(
         }
 
     val state = rememberLazyGridState()
+    val isEmbedded =
+        LocalPhotopickerConfiguration.current.runtimeEnv == PhotopickerRuntimeEnv.EMBEDDED
+    val isExpanded = LocalEmbeddedState.current?.isExpanded ?: false
+
+    val host = LocalEmbeddedState.current?.host
     // Container encapsulating the album title followed by the album content in the form of a
     // grid, the content also includes date and month separators.
     Column(modifier = Modifier.fillMaxSize()) {
@@ -138,8 +155,15 @@ private fun AlbumMediaGrid(
                     remember(localConfig) { (localConfig.screenHeightDp * .20).dp }
                 val (title, body, icon) = getEmptyStateContentForAlbum(album)
                 EmptyState(
-                    // Provide 20% of screen height as empty space above
-                    modifier = Modifier.fillMaxWidth().padding(top = emptyStatePadding),
+                    modifier =
+                        if (SdkLevel.isAtLeastU() && isEmbedded && host != null) {
+                            // In embedded no need to give extra top padding to make empty
+                            // state title and body clearly visible in collapse mode (small view)
+                            Modifier.fillMaxWidth().transferTouchesToHostInEmbedded(host = host)
+                        } else {
+                            // Provide 20% of screen height as empty space above
+                            Modifier.fillMaxWidth().padding(top = emptyStatePadding)
+                        },
                     icon = icon,
                     title = title,
                     body = body,
@@ -150,6 +174,11 @@ private fun AlbumMediaGrid(
                 mediaGrid(
                     // Album content grid
                     items = items,
+                    userScrollEnabled =
+                        when (isEmbedded) {
+                            true -> isExpanded
+                            false -> true
+                        },
                     isExpandedScreen = isExpandedScreen,
                     selection = selection,
                     onItemClick = { item ->
@@ -157,24 +186,24 @@ private fun AlbumMediaGrid(
                             viewModel.handleAlbumMediaGridItemSelection(
                                 item.media,
                                 selectionLimitExceededMessage,
-                                album
+                                album,
                             )
                         }
                     },
                     onItemLongPress = { item ->
-                        // Dispatch UI event to log long pressing the media item
-                        scope.launch {
-                            events.dispatch(
-                                Event.LogPhotopickerUIEvent(
-                                    FeatureToken.PREVIEW.token,
-                                    configuration.sessionId,
-                                    configuration.callingPackageUid ?: -1,
-                                    Telemetry.UiEvent.PICKER_LONG_SELECT_MEDIA_ITEM
-                                )
-                            )
-                        }
                         // If the [PreviewFeature] is enabled, launch the preview route.
                         if (isPreviewEnabled && item is MediaGridItem.MediaItem) {
+                            // Dispatch UI event to log long pressing the media item
+                            scope.launch {
+                                events.dispatch(
+                                    Event.LogPhotopickerUIEvent(
+                                        FeatureToken.PREVIEW.token,
+                                        configuration.sessionId,
+                                        configuration.callingPackageUid ?: -1,
+                                        Telemetry.UiEvent.PICKER_LONG_SELECT_MEDIA_ITEM,
+                                    )
+                                )
+                            }
                             // Dispatch UI event to log entry into preview mode
                             scope.launch {
                                 events.dispatch(
@@ -182,7 +211,7 @@ private fun AlbumMediaGrid(
                                         FeatureToken.PREVIEW.token,
                                         configuration.sessionId,
                                         configuration.callingPackageUid ?: -1,
-                                        Telemetry.UiEvent.ENTER_PICKER_PREVIEW_MODE
+                                        Telemetry.UiEvent.ENTER_PICKER_PREVIEW_MODE,
                                     )
                                 )
                             }
@@ -198,7 +227,7 @@ private fun AlbumMediaGrid(
                             FeatureToken.PHOTO_GRID.token,
                             configuration.sessionId,
                             configuration.callingPackageUid ?: -1,
-                            Telemetry.UiEvent.UI_LOADED_ALBUM_CONTENTS
+                            Telemetry.UiEvent.UI_LOADED_ALBUM_CONTENTS,
                         )
                     )
                 }
diff --git a/photopicker/src/com/android/photopicker/features/browse/BrowseFeature.kt b/photopicker/src/com/android/photopicker/features/browse/BrowseFeature.kt
index 4a7a84323..82b0278bb 100644
--- a/photopicker/src/com/android/photopicker/features/browse/BrowseFeature.kt
+++ b/photopicker/src/com/android/photopicker/features/browse/BrowseFeature.kt
@@ -33,9 +33,11 @@ import com.android.photopicker.core.features.FeatureToken
 import com.android.photopicker.core.features.Location
 import com.android.photopicker.core.features.LocationParams
 import com.android.photopicker.core.features.PhotopickerUiFeature
+import com.android.photopicker.core.features.PrefetchResultKey
 import com.android.photopicker.core.features.Priority
 import com.android.photopicker.core.navigation.Route
 import com.android.photopicker.features.overflowmenu.OverflowMenuItem
+import kotlinx.coroutines.Deferred
 import kotlinx.coroutines.launch
 
 /**
@@ -48,7 +50,10 @@ class BrowseFeature : PhotopickerUiFeature {
     companion object Registration : FeatureRegistration {
         override val TAG: String = "PhotopickerBrowseFeature"
 
-        override fun isEnabled(config: PhotopickerConfiguration): Boolean {
+        override fun isEnabled(
+            config: PhotopickerConfiguration,
+            deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>>,
+        ): Boolean {
             // Browse is only available for ACTION_GET_CONTENT when in the activity runtime env
             return config.action == Intent.ACTION_GET_CONTENT && config.runtimeEnv == ACTIVITY
         }
@@ -63,9 +68,7 @@ class BrowseFeature : PhotopickerUiFeature {
     override val eventsProduced = setOf<RegisteredEventClass>(Event.BrowseToDocumentsUi::class.java)
 
     override fun registerLocations(): List<Pair<Location, Int>> {
-        return listOf(
-            Pair(Location.OVERFLOW_MENU_ITEMS, Priority.HIGH.priority),
-        )
+        return listOf(Pair(Location.OVERFLOW_MENU_ITEMS, Priority.HIGH.priority))
     }
 
     override fun registerNavigationRoutes(): Set<Route> {
@@ -73,11 +76,7 @@ class BrowseFeature : PhotopickerUiFeature {
     }
 
     @Composable
-    override fun compose(
-        location: Location,
-        modifier: Modifier,
-        params: LocationParams,
-    ) {
+    override fun compose(location: Location, modifier: Modifier, params: LocationParams) {
         when (location) {
             Location.OVERFLOW_MENU_ITEMS -> {
                 val clickAction = params as? LocationParams.WithClickAction
@@ -90,7 +89,7 @@ class BrowseFeature : PhotopickerUiFeature {
                             events.dispatch(Event.BrowseToDocumentsUi(dispatcherToken = token))
                         }
                         clickAction?.onClick()
-                    }
+                    },
                 )
             }
             else -> {}
diff --git a/photopicker/src/com/android/photopicker/features/cloudmedia/CloudMediaFeature.kt b/photopicker/src/com/android/photopicker/features/cloudmedia/CloudMediaFeature.kt
index 42ae219c6..f3a5deee0 100644
--- a/photopicker/src/com/android/photopicker/features/cloudmedia/CloudMediaFeature.kt
+++ b/photopicker/src/com/android/photopicker/features/cloudmedia/CloudMediaFeature.kt
@@ -29,6 +29,7 @@ import com.android.photopicker.core.banners.BannerDefinitions
 import com.android.photopicker.core.banners.BannerState
 import com.android.photopicker.core.configuration.LocalPhotopickerConfiguration
 import com.android.photopicker.core.configuration.PhotopickerConfiguration
+import com.android.photopicker.core.configuration.PhotopickerRuntimeEnv
 import com.android.photopicker.core.events.Event
 import com.android.photopicker.core.events.LocalEvents
 import com.android.photopicker.core.events.RegisteredEventClass
@@ -39,6 +40,7 @@ import com.android.photopicker.core.features.FeatureToken
 import com.android.photopicker.core.features.Location
 import com.android.photopicker.core.features.LocationParams
 import com.android.photopicker.core.features.PhotopickerUiFeature
+import com.android.photopicker.core.features.PrefetchResultKey
 import com.android.photopicker.core.features.Priority
 import com.android.photopicker.core.navigation.Route
 import com.android.photopicker.core.user.UserMonitor
@@ -47,6 +49,7 @@ import com.android.photopicker.data.model.CollectionInfo
 import com.android.photopicker.data.model.MediaSource
 import com.android.photopicker.data.model.Provider
 import com.android.photopicker.features.overflowmenu.OverflowMenuItem
+import kotlinx.coroutines.Deferred
 import kotlinx.coroutines.launch
 
 /**
@@ -59,7 +62,10 @@ class CloudMediaFeature : PhotopickerUiFeature {
     companion object Registration : FeatureRegistration {
         override val TAG: String = "PhotopickerCloudMediaFeature"
 
-        override fun isEnabled(config: PhotopickerConfiguration): Boolean {
+        override fun isEnabled(
+            config: PhotopickerConfiguration,
+            deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>>,
+        ): Boolean {
 
             // Cloud media is not available in permission mode.
             if (config.action == MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP) return false
@@ -88,6 +94,7 @@ class CloudMediaFeature : PhotopickerUiFeature {
         userMonitor: UserMonitor,
     ): Int {
 
+        val isEmbedded = config.runtimeEnv == PhotopickerRuntimeEnv.EMBEDDED
         // If any of the banners owned by [CloudMediaFeature] have been previously dismissed, then
         // return a disabled priority.
         if (bannerState?.dismissed == true) {
@@ -106,26 +113,36 @@ class CloudMediaFeature : PhotopickerUiFeature {
 
         return when (banner) {
             BannerDefinitions.CLOUD_CHOOSE_PROVIDER -> {
-                if (
+                return when {
+                    // Don't show in Embedded, as the banner starts an activity which can cause a
+                    // crash.
+                    isEmbedded -> Priority.DISABLED.priority
+
+                    // If there is no current provider, but a list of allowed providers exists
                     currentCloudProvider == null &&
-                        dataService.getAllAllowedProviders().isNotEmpty()
-                ) {
-                    return Priority.MEDIUM.priority
-                } else {
-                    return Priority.DISABLED.priority
+                        dataService.getAllAllowedProviders().isNotEmpty() ->
+                        Priority.MEDIUM.priority
+
+                    // There's a cloud provider set, so don't show
+                    else -> Priority.DISABLED.priority
                 }
             }
             BannerDefinitions.CLOUD_CHOOSE_ACCOUNT -> {
                 collectionInfo?.let {
-                    if (it.accountName == null) {
-                        Priority.MEDIUM.priority
-                    } else {
-                        Priority.DISABLED.priority
+                    when {
+                        // Don't show in Embedded, as the banner starts an activity which can cause
+                        // a crash.
+                        isEmbedded -> Priority.DISABLED.priority
+
+                        // If there is no current cloud provider account
+                        it.accountName == null -> Priority.MEDIUM.priority
+
+                        // There's a cloud provider account set, so don't show
+                        else -> Priority.DISABLED.priority
                     }
                 } ?: Priority.DISABLED.priority
             }
             BannerDefinitions.CLOUD_MEDIA_AVAILABLE -> {
-
                 collectionInfo?.let {
                     if (it.accountName != null && it.collectionId != null) {
                         Priority.MEDIUM.priority
@@ -162,7 +179,7 @@ class CloudMediaFeature : PhotopickerUiFeature {
                     collectionInfo =
                         checkNotNull(collectionInfo) {
                             "collectionInfo was null during buildBanner"
-                        }
+                        },
                 )
             BannerDefinitions.CLOUD_MEDIA_AVAILABLE ->
                 buildCloudMediaAvailableBanner(
@@ -185,15 +202,14 @@ class CloudMediaFeature : PhotopickerUiFeature {
     override val eventsProduced =
         setOf<RegisteredEventClass>(
             Event.LogPhotopickerMenuInteraction::class.java,
-            Event.LogPhotopickerUIEvent::class.java
+            Event.LogPhotopickerUIEvent::class.java,
         )
 
     override fun registerLocations(): List<Pair<Location, Int>> {
         return listOf(
-            Pair(Location.MEDIA_PRELOADER, Priority.HIGH.priority),
             // Medium priority for OVERFLOW_MENU_ITEMS so that [BrowseFeature] can
             // have the top spot if it's enabled.
-            Pair(Location.OVERFLOW_MENU_ITEMS, Priority.MEDIUM.priority),
+            Pair(Location.OVERFLOW_MENU_ITEMS, Priority.MEDIUM.priority)
         )
     }
 
@@ -202,16 +218,11 @@ class CloudMediaFeature : PhotopickerUiFeature {
     }
 
     @Composable
-    override fun compose(
-        location: Location,
-        modifier: Modifier,
-        params: LocationParams,
-    ) {
+    override fun compose(location: Location, modifier: Modifier, params: LocationParams) {
         val events = LocalEvents.current
         val scope = rememberCoroutineScope()
         val configuration = LocalPhotopickerConfiguration.current
         when (location) {
-            Location.MEDIA_PRELOADER -> MediaPreloader(modifier, params)
             Location.OVERFLOW_MENU_ITEMS -> {
                 val context = LocalContext.current
                 val clickAction = params as? LocationParams.WithClickAction
@@ -228,11 +239,11 @@ class CloudMediaFeature : PhotopickerUiFeature {
                                     token,
                                     configuration.sessionId,
                                     configuration.callingPackageUid ?: -1,
-                                    Telemetry.MenuItemSelected.CLOUD_SETTINGS
+                                    Telemetry.MenuItemSelected.CLOUD_SETTINGS,
                                 )
                             )
                         }
-                    }
+                    },
                 )
             }
             else -> {}
diff --git a/photopicker/src/com/android/photopicker/features/cloudmedia/MediaPreloaderViewModel.kt b/photopicker/src/com/android/photopicker/features/cloudmedia/MediaPreloaderViewModel.kt
deleted file mode 100644
index 7a3292eea..000000000
--- a/photopicker/src/com/android/photopicker/features/cloudmedia/MediaPreloaderViewModel.kt
+++ /dev/null
@@ -1,465 +0,0 @@
-/*
- * Copyright 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.photopicker.features.cloudmedia
-
-import android.util.Log
-import androidx.annotation.GuardedBy
-import androidx.lifecycle.ViewModel
-import androidx.lifecycle.viewModelScope
-import com.android.photopicker.core.Background
-import com.android.photopicker.core.configuration.ConfigurationManager
-import com.android.photopicker.core.events.Event
-import com.android.photopicker.core.events.Events
-import com.android.photopicker.core.events.Telemetry
-import com.android.photopicker.core.features.FeatureToken
-import com.android.photopicker.core.selection.Selection
-import com.android.photopicker.core.user.UserMonitor
-import com.android.photopicker.data.model.Media
-import com.android.photopicker.data.model.MediaSource
-import dagger.hilt.android.lifecycle.HiltViewModel
-import java.io.FileNotFoundException
-import javax.inject.Inject
-import kotlinx.coroutines.CompletableDeferred
-import kotlinx.coroutines.CoroutineDispatcher
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.Job
-import kotlinx.coroutines.channels.BufferOverflow
-import kotlinx.coroutines.flow.MutableSharedFlow
-import kotlinx.coroutines.flow.MutableStateFlow
-import kotlinx.coroutines.flow.SharingStarted
-import kotlinx.coroutines.flow.StateFlow
-import kotlinx.coroutines.flow.distinctUntilChanged
-import kotlinx.coroutines.flow.map
-import kotlinx.coroutines.flow.stateIn
-import kotlinx.coroutines.flow.update
-import kotlinx.coroutines.launch
-import kotlinx.coroutines.sync.Mutex
-import kotlinx.coroutines.sync.withLock
-
-/** Enumeration for the LoadState of a given preloaded item. */
-private enum class LoadResult {
-    COMPLETED,
-    FAILED,
-    QUEUED,
-}
-
-/** Data objects which contain all the UI data to render the various Preloader dialogs. */
-sealed interface PreloaderDialogData {
-
-    /**
-     * The loading dialog data
-     *
-     * @param total Total of items to be loaded
-     * @param completed Number of items currently completed
-     */
-    data class PreloaderLoadingDialogData(
-        val total: Int,
-        val completed: Int = 0,
-    ) : PreloaderDialogData
-
-    /** Empty object for telling the UI to show a generic error dialog */
-    object PreloaderLoadingErrorDialog : PreloaderDialogData
-}
-
-/**
- * The view model for the [MediaPreloader].
- *
- * This is the class responsible for the requests to remote providers to prepare remote media for
- * local apps. The main preloading operation should only be triggered by the main activity, by
- * emitting a set of media to preload into the flow provided to the MediaPreloader compose UI via
- * [LocationParams].
- *
- * Additionally, this method exposes the required state data for the UI to draw the correct dialog
- * overlays as preloading is initiated, is progressing, and resolves with either a failure or a
- * success.
- *
- * This class should not be injected anywhere other than the MediaPreloader's context to attempt to
- * monitor the state of the ongoing preload.
- *
- * When the preload is complete, the [CompletableDeferred] that is passed in the [LocationParams]
- * will be marked completed, A TRUE value indicates success, and a FALSE value indicates a failure.
- */
-@HiltViewModel
-class MediaPreloaderViewModel
-@Inject
-constructor(
-    private val scopeOverride: CoroutineScope?,
-    @Background private val backgroundDispatcher: CoroutineDispatcher,
-    private val selection: Selection<Media>,
-    private val userMonitor: UserMonitor,
-    private val configurationManager: ConfigurationManager,
-    private val events: Events,
-) : ViewModel() {
-
-    companion object {
-        // Ensure only 2 downloads are occurring in parallel.
-        val MAX_CONCURRENT_LOADS = 2
-    }
-
-    /* Parent job that owns the overall preloader operation & monitor */
-    private var job: Job? = null
-
-    /*
-     * A heartbeat flow to drive the preload monitor job.
-     * Replay = 1 and DROP_OLDEST due to the fact the heartbeat doesn't contain any useful
-     * data, so as long as something is in the buffer to be collected, there's no need
-     * for duplicate emissions.
-     */
-    private val heartbeat: MutableSharedFlow<Unit> =
-        MutableSharedFlow(replay = 1, onBufferOverflow = BufferOverflow.DROP_OLDEST)
-
-    // Protect [remoteItems] with a Mutex since multiple coroutines are reading/writing it.
-    private val mutex = Mutex()
-    // A list of remote items to be loaded, and their current [LoadResult].
-    // NOTE: This should always be accessed after acquiring the [Mutex] to ensure data
-    // accuracy during concurrency.
-    @GuardedBy("mutex") private val remoteItems = mutableMapOf<Media, LoadResult>()
-
-    // Check if a scope override was injected before using the default [viewModelScope]
-    private val scope: CoroutineScope =
-        if (scopeOverride == null) {
-            this.viewModelScope
-        } else {
-            scopeOverride
-        }
-
-    /* Flow for monitoring the activeContentResolver:
-     *   - map to get rid of other [UserStatus] fields this does not care about
-     *   - distinctUntilChanged to only emit when the resolver actually changes, since
-     *     UserStatus might be updated if other profiles turn on and off
-     */
-    private val _contentResolver =
-        userMonitor.userStatus.map { it.activeContentResolver }.distinctUntilChanged()
-
-    /** Flow that can push new data into the preloader's dialogs. */
-    private val _dialogData = MutableStateFlow<PreloaderDialogData?>(null)
-
-    /** Public flow for the compose ui to collect. */
-    val dialogData: StateFlow<PreloaderDialogData?> =
-        _dialogData.stateIn(
-            scope,
-            SharingStarted.WhileSubscribed(),
-            initialValue = _dialogData.value
-        )
-
-    val configuration = configurationManager.configuration.value
-
-    init {
-
-        // If the active user's resolver changes, cancel any pending preload work.
-        scope.launch {
-            _contentResolver.collect {
-                // Action is only required if there's currently a job running.
-                job?.let {
-                    Log.d(CloudMediaFeature.TAG, "User was changed, abandoning preloads")
-                    it.cancel()
-                    hideAllDialogs()
-                }
-            }
-        }
-    }
-
-    /**
-     * Entrypoint of the selected media preload operation.
-     *
-     * This is triggered when the preloadMedia flow from compose receives a new Set<Media> to
-     * preload.
-     *
-     * Once the new set of media is received from its source, the compose UI will call startPreload
-     * to begin the preload of the set.
-     *
-     * This operation will enqueue work to load any [DataSource.REMOTE] files that are present in
-     * the current selection to ensure they are downloaded / prepared by the remote provider. This
-     * has the benefit of ensuring that the files can be immediately opened by the App that started
-     * Photopicker without having to deal with awaiting any remote procedures to bring the remote
-     * file down to the device.
-     *
-     * This method will run a parent [CoroutineScope] (see [job] in this class), which will
-     * subsequently schedule child jobs for each remote item in the selection. The [Background]
-     * [CoroutineDispatcher] is used for this operation, however the parallel execution is limited
-     * to [MAX_CONCURRENT_LOADS] to avoid over-stressing the remote providers and saturating the
-     * available network bandwidth.
-     *
-     * @param selection The set of media to preload
-     * @param deferred A [CompletableDeferred] that can be used to signal when the preload operation
-     *   is complete. TRUE represents success, FALSE represents failure.
-     * @see [LocationParams.WithMediaPreloader] for the data that is passed to the UI to attach the
-     *   preloader.
-     */
-    suspend fun startPreload(selection: Set<Media>, deferred: CompletableDeferred<Boolean>) {
-
-        mutex.withLock {
-
-            // Begin by clearing any prior state.
-            remoteItems.clear()
-
-            for (item in selection.filter { it.mediaSource == MediaSource.REMOTE }) {
-                remoteItems.put(item, LoadResult.QUEUED)
-            }
-        }
-
-        // End early if there are not any [DataSource.REMOTE] items in the current selection.
-        if (remoteItems.isEmpty()) {
-            Log.i(CloudMediaFeature.TAG, "Preload not required, no remote items.")
-            deferred.complete(true)
-            return
-        }
-
-        Log.i(
-            CloudMediaFeature.TAG,
-            "SelectionMediaBeginPreload operation was requested. " +
-                "Total remote items: ${remoteItems.size}"
-        )
-        // Update the UI so the Loading dialog can be displayed with the initial loading data.
-        _dialogData.update {
-            PreloaderDialogData.PreloaderLoadingDialogData(
-                total = selection.size,
-                // Local items are automatically "completed" as there is nothing to preload.
-                completed = (selection.size - remoteItems.size),
-            )
-        }
-
-        // All preloading work must be a child of this job, a reference of the job is saved
-        // so that if the User requests cancellation the child jobs receive the cancellation as
-        // well.
-        job =
-            scope.launch(backgroundDispatcher) {
-                // Enqueue a job to monitor the ongoing operation. This job is crucially also a
-                // child of the main preloading job, so it will be canceled anytime loading is
-                // canceled.
-                launch { monitorPreloadOperation(deferred) }
-
-                // Start a parallelism constrained child job to actually handle the loads to
-                // enforce that the device bandwidth doesn't become over saturated by trying
-                // to load too many files at once.
-                launch(
-                    @OptIn(kotlinx.coroutines.ExperimentalCoroutinesApi::class)
-                    backgroundDispatcher.limitedParallelism(MAX_CONCURRENT_LOADS)
-                ) {
-                    // This is the main preloader job coroutine, enqueue other work here, but
-                    // don't run any heavy / blocking work, as it will prevent the loading
-                    // from starting.
-                    for (item in remoteItems.keys) {
-                        launch { preloadMediaItem(item, deferred) }
-                    }
-                }
-            }
-    }
-
-    /**
-     * Entrypoint for preloading a single [Media] item.
-     *
-     * This begins preparing the file by requesting the file from the current user's
-     * [ContentResolver], and updates the dialog data and remote items statuses when a load is
-     * successful.
-     *
-     * If a file cannot be opened or the ContentResolver throws a [FileNotFoundException], the item
-     * is marked as failed.
-     *
-     * @param item The item to load from the [ContentResolver].
-     * @param deferred The overall deferred for the preload operation which is used to see if the
-     *   preload has been canceled already)
-     */
-    private suspend fun preloadMediaItem(item: Media, deferred: CompletableDeferred<Boolean>) {
-        Log.v(CloudMediaFeature.TAG, "Beginning preload of: $item")
-        try {
-            if (!deferred.isCompleted) {
-                userMonitor.userStatus.value.activeContentResolver
-                    .openAssetFileDescriptor(item.mediaUri, "r")
-                    .use {
-
-                        // Mark the item as complete in the result status.
-                        mutex.withLock { remoteItems.set(item, LoadResult.COMPLETED) }
-
-                        // Update the [PreloaderDialogData] flow an increment the
-                        // completed operations by one so the UI updates.
-                        _dialogData.update {
-                            when (it) {
-                                is PreloaderDialogData.PreloaderLoadingDialogData ->
-                                    it.copy(completed = it.completed + 1)
-                                else -> it
-                            }
-                        }
-                        Log.v(CloudMediaFeature.TAG, "Preload successful: $item")
-                    }
-                // Emit a new monitor heartbeat so the preload can continue or finish.
-                heartbeat.emit(Unit)
-            }
-        } catch (e: FileNotFoundException) {
-            Log.e(CloudMediaFeature.TAG, "Error while preloading $item", e)
-
-            // Only need to take action if the deferred is already not marked as completed,
-            // another load job may have already failed.
-            if (!deferred.isCompleted) {
-                Log.d(
-                    CloudMediaFeature.TAG,
-                    "Failure detected, cancelling the rest of the preload operation."
-                )
-                // Log failure of media items preloading
-                scope.launch {
-                    events.dispatch(
-                        Event.LogPhotopickerUIEvent(
-                            FeatureToken.CORE.token,
-                            configuration.sessionId,
-                            configuration.callingPackageUid ?: -1,
-                            Telemetry.UiEvent.PICKER_PRELOADING_FAILED
-                        )
-                    )
-                }
-                // Mark the item as failed in the result status.
-                mutex.withLock { remoteItems.set(item, LoadResult.FAILED) }
-                // Emit a new heartbeat so the monitor will react to this failure.
-                heartbeat.emit(Unit)
-            }
-        }
-    }
-
-    /**
-     * Suspended function that monitors [remoteItems] preloading and takes an action when all items
-     * are [LoadResult.COMPLETED] or a [LoadResult.FAILURE] is found in [remoteItems].
-     *
-     * When all remoteItems are [LoadResult.COMPLETED] -> mark the [CompletableDeferred] that
-     * represents this preload operation as completed(TRUE) to signal the preload was successful.
-     *
-     * When one of the remoteItems returns [LoadResult.FAILED] any pending preloads are cancelled,
-     * and the parent job is also canceled. The failed item(s) will be removed from the current
-     * selection, and the deferred will be completed(FALSE) to signal the preload has failed.
-     *
-     * This method will run a new check for every heartbeat, and does not observe the [remoteItems]
-     * data structure directly. As such, it's important that any status changes in the state of
-     * loading trigger an update of heartbeat for the collector in this method to execute.
-     *
-     * @param deferred the status of the overall preload operation. TRUE signals a successful
-     *   preload, and FALSE a failure.
-     */
-    private suspend fun monitorPreloadOperation(deferred: CompletableDeferred<Boolean>) {
-
-        heartbeat.collect {
-
-            // Outcomes, another possibility is neither is met, and the load should continue until
-            // the next result.
-            var loadFailed = false
-            var loadCompleted = false
-
-            // Fetch the current results with the mutex, but don't hold the mutex longer than
-            // needed.
-            mutex.withLock {
-
-                // The load is failed if any single item fails to load.
-                loadFailed = remoteItems.any { (_, loadResult) -> loadResult == LoadResult.FAILED }
-
-                // The load is complete if all items are completed successfully.
-                loadCompleted =
-                    remoteItems.all { (_, loadResult) -> loadResult == LoadResult.COMPLETED }
-            }
-
-            // Outcomes, if none of these branches are yet met, the load will continue, and this
-            // block will run on the next known result.
-            when {
-                loadFailed -> {
-                    // Remove any failed items from the selection
-                    selection.removeAll(
-                        remoteItems
-                            .filter { (_, loadResult) -> loadResult == LoadResult.FAILED }
-                            .keys
-                    )
-                    // Now that a failure has been detected, update the [PreloaderDialogData]
-                    // so the UI will show the loading error dialog.
-                    _dialogData.update { PreloaderDialogData.PreloaderLoadingErrorDialog }
-
-                    // Since something has failed, mark the overall preload operation as failed.
-                    deferred.complete(false)
-                }
-                loadCompleted -> {
-                    // If all of the remote items have completed successfully, the preload operation
-                    // is complete, deferred can be marked as complete(true) to instruct the
-                    // application to send the selected Media to the caller.
-                    Log.d(CloudMediaFeature.TAG, "Preload operation was successful.")
-                    deferred.complete(true)
-                    // Dispatch UI event to mark the end of preloading of media items
-                    scope.launch {
-                        events.dispatch(
-                            Event.LogPhotopickerUIEvent(
-                                FeatureToken.CORE.token,
-                                configuration.sessionId,
-                                configuration.callingPackageUid ?: -1,
-                                Telemetry.UiEvent.PICKER_PRELOADING_FINISHED
-                            )
-                        )
-                    }
-                }
-            }
-
-            // If the load has a result, clean up the active running job.
-            if (loadFailed || loadCompleted) {
-                job?.cancel()
-                // Drop any pending heartbeats as the monitor job is being shutdown.
-                @OptIn(kotlinx.coroutines.ExperimentalCoroutinesApi::class)
-                heartbeat.resetReplayCache()
-            }
-        }
-    }
-
-    /**
-     * Cancels any pending preload operation by canceling the parent job.
-     *
-     * This method is safe to call if no preload is currently active, it will have no effect.
-     *
-     * NOTE: This does not cancel any file open calls that have already started, but will prevent
-     * any additional file open calls from being started.
-     *
-     * @param deferred The [CompletableDeferred] for the job to cancel, if one exists.
-     */
-    fun cancelPreload(deferred: CompletableDeferred<Boolean>? = null) {
-        job?.let {
-            it.cancel()
-            Log.i(CloudMediaFeature.TAG, "Preload operation was cancelled.")
-            // Dispatch an event to log cancellation of media items preloading
-            scope.launch {
-                events.dispatch(
-                    Event.LogPhotopickerUIEvent(
-                        FeatureToken.CORE.token,
-                        configuration.sessionId,
-                        configuration.callingPackageUid ?: -1,
-                        Telemetry.UiEvent.PICKER_PRELOADING_CANCELLED
-                    )
-                )
-            }
-        }
-
-        // In the event of single selection mode, the selection needs to be cleared.
-        if (configurationManager.configuration.value.selectionLimit == 1) {
-            scope.launch { selection.clear() }
-        }
-
-        // If a deferred was passed, mark it as failed.
-        deferred?.complete(false)
-
-        // Drop any pending heartbeats as the monitor job is being shutdown.
-        @OptIn(kotlinx.coroutines.ExperimentalCoroutinesApi::class) heartbeat.resetReplayCache()
-    }
-
-    /**
-     * Forces the [PreloaderDialogData] flows back to their initialization state so that any dialog
-     * currently being shown will be hidden.
-     *
-     * NOTE: This does not cancel a preload operation, so future progress may show a dialog.
-     */
-    fun hideAllDialogs() {
-        _dialogData.update { null }
-    }
-}
diff --git a/photopicker/src/com/android/photopicker/features/navigationbar/NavigationBar.kt b/photopicker/src/com/android/photopicker/features/navigationbar/NavigationBar.kt
index d66a062c9..7327e346a 100644
--- a/photopicker/src/com/android/photopicker/features/navigationbar/NavigationBar.kt
+++ b/photopicker/src/com/android/photopicker/features/navigationbar/NavigationBar.kt
@@ -16,16 +16,18 @@
 
 package com.android.photopicker.features.navigationbar
 
+import androidx.compose.animation.expandVertically
+import androidx.compose.animation.shrinkVertically
 import androidx.compose.foundation.layout.Arrangement
 import androidx.compose.foundation.layout.Column
 import androidx.compose.foundation.layout.Row
 import androidx.compose.foundation.layout.Spacer
 import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.heightIn
 import androidx.compose.foundation.layout.padding
 import androidx.compose.foundation.layout.width
 import androidx.compose.material.icons.Icons
 import androidx.compose.material.icons.automirrored.filled.ArrowBack
-import androidx.compose.material.icons.filled.ArrowBack
 import androidx.compose.material3.ButtonDefaults
 import androidx.compose.material3.FilledTonalButton
 import androidx.compose.material3.Icon
@@ -38,12 +40,19 @@ import androidx.compose.runtime.remember
 import androidx.compose.ui.Alignment
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.res.stringResource
+import androidx.compose.ui.semantics.semantics
+import androidx.compose.ui.semantics.traversalIndex
 import androidx.compose.ui.text.style.TextOverflow
 import androidx.compose.ui.unit.dp
 import androidx.navigation.compose.currentBackStackEntryAsState
 import com.android.photopicker.R
+import com.android.photopicker.core.StateSelector
+import com.android.photopicker.core.animations.standardDecelerate
+import com.android.photopicker.core.embedded.LocalEmbeddedState
 import com.android.photopicker.core.features.LocalFeatureManager
 import com.android.photopicker.core.features.Location
+import com.android.photopicker.core.features.LocationParams
+import com.android.photopicker.core.hideWhenState
 import com.android.photopicker.core.navigation.LocalNavController
 import com.android.photopicker.core.navigation.PhotopickerDestinations
 import com.android.photopicker.core.theme.CustomAccentColorScheme
@@ -66,6 +75,9 @@ private val MEASUREMENT_EDGE_PADDING = 4.dp
 private val MEASUREMENT_TOP_PADDING = 8.dp
 private val MEASUREMENT_BOT_PADDING = 24.dp
 
+/* Minimum height for the NavigationBar */
+private val MEASUREMENT_MIN_HEIGHT = 48.dp
+
 /**
  * Top of the NavigationBar feature.
  *
@@ -81,7 +93,7 @@ private val MEASUREMENT_BOT_PADDING = 24.dp
  * Additionally, the composable also calls for the [PROFILE_SELECTOR] and [OVERFLOW_MENU] locations.
  */
 @Composable
-fun NavigationBar(modifier: Modifier = Modifier) {
+fun NavigationBar(modifier: Modifier = Modifier, params: LocationParams) {
 
     val navController = LocalNavController.current
     val navBackStackEntry by navController.currentBackStackEntryAsState()
@@ -91,12 +103,14 @@ fun NavigationBar(modifier: Modifier = Modifier) {
 
     Row(
         modifier =
-            modifier.padding(
-                start = MEASUREMENT_EDGE_PADDING,
-                end = MEASUREMENT_EDGE_PADDING,
-                top = MEASUREMENT_TOP_PADDING,
-                bottom = MEASUREMENT_BOT_PADDING,
-            ),
+            modifier
+                .padding(
+                    start = MEASUREMENT_EDGE_PADDING,
+                    end = MEASUREMENT_EDGE_PADDING,
+                    top = MEASUREMENT_TOP_PADDING,
+                    bottom = MEASUREMENT_BOT_PADDING,
+                )
+                .heightIn(min = MEASUREMENT_MIN_HEIGHT),
         horizontalArrangement = Arrangement.SpaceBetween,
         verticalAlignment = Alignment.Top,
     ) {
@@ -109,7 +123,7 @@ fun NavigationBar(modifier: Modifier = Modifier) {
 
             // When search feature is enabled then display search bar along with profile selector,
             // overflow menu and the navigation buttons below it.
-            searchFeatureEnabled -> NavigationBarWithSearch(modifier)
+            searchFeatureEnabled -> NavigationBarWithSearch(modifier, params)
 
             // For all other routes, show the profile selector and the navigation buttons
             else -> BasicNavigationBar(modifier)
@@ -134,7 +148,7 @@ fun NavigationBarButton(
     onClick: () -> Unit,
     modifier: Modifier,
     isCurrentRoute: (String) -> Boolean,
-    buttonContent: @Composable () -> Unit
+    buttonContent: @Composable () -> Unit,
 ) {
     val navController = LocalNavController.current
     val navBackStackEntry by navController.currentBackStackEntryAsState()
@@ -177,15 +191,15 @@ private fun NavigationBarButtons(modifier: Modifier) {
     Row(
         // Consume the incoming modifier to get the correct positioning.
         modifier = modifier,
-        horizontalArrangement = Arrangement.Center
+        horizontalArrangement = Arrangement.Center,
     ) {
         Row(
             // Layout in individual buttons in a row, and space them evenly.
             horizontalArrangement =
                 Arrangement.spacedBy(
                     MEASUREMENT_SPACER_SIZE,
-                    alignment = Alignment.CenterHorizontally
-                ),
+                    alignment = Alignment.CenterHorizontally,
+                )
         ) {
             val featureManager = LocalFeatureManager.current
             val searchFeatureEnabled = featureManager.isFeatureEnabled(SearchFeature::class.java)
@@ -199,7 +213,7 @@ private fun NavigationBarButtons(modifier: Modifier) {
                         Modifier.weight(1f)
                     } else {
                         Modifier // No modifier needed when search not enabled
-                    }
+                    },
             )
         }
     }
@@ -224,15 +238,13 @@ private fun NavigationBarForAlbum(modifier: Modifier) {
         when (album) {
             null -> {}
             else -> {
-                Row(
-                    verticalAlignment = Alignment.CenterVertically,
-                ) {
+                Row(verticalAlignment = Alignment.CenterVertically) {
                     // back button
                     IconButton(
                         modifier =
                             Modifier.width(MEASUREMENT_ICON_BUTTON_WIDTH)
                                 .padding(horizontal = MEASUREMENT_ICON_BUTTON_OUTSIDE_PADDING),
-                        onClick = { navController.navigateToAlbumGrid() }
+                        onClick = { navController.navigateToAlbumGrid() },
                     ) {
                         Icon(
                             imageVector = Icons.AutoMirrored.Filled.ArrowBack,
@@ -247,6 +259,8 @@ private fun NavigationBarForAlbum(modifier: Modifier) {
                         overflow = TextOverflow.Ellipsis,
                         maxLines = 1,
                         style = MaterialTheme.typography.titleLarge,
+                        // Traversal index -1 forces TalkBack to focus on the album title first.
+                        modifier = Modifier.semantics { traversalIndex = -1f },
                     )
                 }
             }
@@ -256,14 +270,11 @@ private fun NavigationBarForAlbum(modifier: Modifier) {
             remember(featureManager) {
                 featureManager.isFeatureEnabled(OverflowMenuFeature::class.java)
             }
-        Row(
-            modifier = Modifier.weight(1f),
-            horizontalArrangement = Arrangement.End,
-        ) {
+        Row(modifier = Modifier.weight(1f), horizontalArrangement = Arrangement.End) {
             if (overFlowMenuEnabled) {
                 featureManager.composeLocation(
                     Location.OVERFLOW_MENU,
-                    modifier = Modifier.width(MEASUREMENT_ICON_BUTTON_WIDTH)
+                    modifier = Modifier.width(MEASUREMENT_ICON_BUTTON_WIDTH),
                 )
             } else {
                 Spacer(Modifier.width(MEASUREMENT_ICON_BUTTON_WIDTH))
@@ -281,43 +292,44 @@ private fun NavigationBarForAlbum(modifier: Modifier) {
  * Navigation buttons are positioned below the search bar.
  */
 @Composable
-private fun NavigationBarWithSearch(modifier: Modifier) {
+private fun NavigationBarWithSearch(modifier: Modifier, params: LocationParams) {
     val featureManager = LocalFeatureManager.current
     Column(
         modifier = modifier,
         verticalArrangement = Arrangement.Top,
-        horizontalAlignment = Alignment.Start
+        horizontalAlignment = Alignment.Start,
     ) {
         Row(verticalAlignment = Alignment.CenterVertically, modifier = modifier) {
             featureManager.composeLocation(
                 Location.SEARCH_BAR,
                 maxSlots = 1,
-                modifier = Modifier.weight(1f)
+                modifier = Modifier.weight(1f),
+                params,
             )
             featureManager.composeLocation(
                 Location.PROFILE_SELECTOR,
                 maxSlots = 1,
-                modifier = Modifier.padding(start = 8.dp)
+                modifier = Modifier.padding(start = 8.dp),
             )
-            Row(
-                modifier = Modifier,
-                horizontalArrangement = Arrangement.End,
+            val overFlowMenuEnabled =
+                remember(featureManager) {
+                    featureManager.isFeatureEnabled(OverflowMenuFeature::class.java)
+                }
+            if (
+                overFlowMenuEnabled &&
+                    LocalFeatureManager.current.getSizeOfLocationInRegistry(
+                        Location.OVERFLOW_MENU_ITEMS
+                    ) > 0
             ) {
-                val overFlowMenuEnabled =
-                    remember(featureManager) {
-                        featureManager.isFeatureEnabled(OverflowMenuFeature::class.java)
-                    }
-                if (overFlowMenuEnabled) {
+                Row(modifier = Modifier, horizontalArrangement = Arrangement.End) {
                     featureManager.composeLocation(
                         Location.OVERFLOW_MENU,
-                        modifier = Modifier.width(MEASUREMENT_ICON_BUTTON_WIDTH)
+                        modifier = Modifier.width(MEASUREMENT_ICON_BUTTON_WIDTH),
                     )
-                } else {
-                    Spacer(Modifier.width(MEASUREMENT_ICON_BUTTON_WIDTH))
                 }
             }
         }
-        NavigationBarButtons(Modifier)
+        NavigationBarButtons(Modifier.padding(start = 8.dp, end = 8.dp))
     }
 }
 
@@ -341,7 +353,7 @@ private fun BasicNavigationBar(modifier: Modifier) {
             featureManager.composeLocation(
                 Location.PROFILE_SELECTOR,
                 maxSlots = 1,
-                modifier = Modifier.padding(start = 8.dp).weight(1f)
+                modifier = Modifier.padding(start = 8.dp).weight(1f),
             )
         } else {
             Spacer(
@@ -350,15 +362,21 @@ private fun BasicNavigationBar(modifier: Modifier) {
                     .weight(1f)
             )
         }
-        NavigationBarButtons(Modifier)
-        Row(
-            modifier = Modifier.weight(1f),
-            horizontalArrangement = Arrangement.End,
+        hideWhenState(
+            selector =
+                object : StateSelector.AnimatedVisibilityInEmbedded {
+                    override val visible = LocalEmbeddedState.current?.isExpanded ?: false
+                    override val enter = expandVertically(animationSpec = standardDecelerate(150))
+                    override val exit = shrinkVertically(animationSpec = standardDecelerate(100))
+                }
         ) {
+            NavigationBarButtons(Modifier)
+        }
+        Row(modifier = Modifier.weight(1f), horizontalArrangement = Arrangement.End) {
             if (overFlowMenuEnabled) {
                 featureManager.composeLocation(
                     Location.OVERFLOW_MENU,
-                    modifier = Modifier.width(MEASUREMENT_ICON_BUTTON_WIDTH)
+                    modifier = Modifier.width(MEASUREMENT_ICON_BUTTON_WIDTH),
                 )
             } else {
                 Spacer(Modifier.width(MEASUREMENT_ICON_BUTTON_WIDTH))
diff --git a/photopicker/src/com/android/photopicker/features/navigationbar/NavigationBarFeature.kt b/photopicker/src/com/android/photopicker/features/navigationbar/NavigationBarFeature.kt
index 3239ebb55..9816f88e9 100644
--- a/photopicker/src/com/android/photopicker/features/navigationbar/NavigationBarFeature.kt
+++ b/photopicker/src/com/android/photopicker/features/navigationbar/NavigationBarFeature.kt
@@ -26,7 +26,9 @@ import com.android.photopicker.core.features.FeatureToken
 import com.android.photopicker.core.features.Location
 import com.android.photopicker.core.features.LocationParams
 import com.android.photopicker.core.features.PhotopickerUiFeature
+import com.android.photopicker.core.features.PrefetchResultKey
 import com.android.photopicker.core.features.Priority
+import kotlinx.coroutines.Deferred
 
 /** Feature class for the Photopicker's navigation bar. */
 class NavigationBarFeature : PhotopickerUiFeature {
@@ -34,7 +36,10 @@ class NavigationBarFeature : PhotopickerUiFeature {
     companion object Registration : FeatureRegistration {
         override val TAG: String = "PhotopickerNavigationBarFeature"
 
-        override fun isEnabled(config: PhotopickerConfiguration) = true
+        override fun isEnabled(
+            config: PhotopickerConfiguration,
+            deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>>,
+        ) = true
 
         override fun build(featureManager: FeatureManager) = NavigationBarFeature()
     }
@@ -54,7 +59,7 @@ class NavigationBarFeature : PhotopickerUiFeature {
     @Composable
     override fun compose(location: Location, modifier: Modifier, params: LocationParams) {
         when (location) {
-            Location.NAVIGATION_BAR -> NavigationBar(modifier)
+            Location.NAVIGATION_BAR -> NavigationBar(modifier, params)
             else -> {}
         }
     }
diff --git a/photopicker/src/com/android/photopicker/features/overflowmenu/OverflowMenuFeature.kt b/photopicker/src/com/android/photopicker/features/overflowmenu/OverflowMenuFeature.kt
index de7f0c135..324defabf 100644
--- a/photopicker/src/com/android/photopicker/features/overflowmenu/OverflowMenuFeature.kt
+++ b/photopicker/src/com/android/photopicker/features/overflowmenu/OverflowMenuFeature.kt
@@ -28,7 +28,9 @@ import com.android.photopicker.core.features.FeatureToken
 import com.android.photopicker.core.features.Location
 import com.android.photopicker.core.features.LocationParams
 import com.android.photopicker.core.features.PhotopickerUiFeature
+import com.android.photopicker.core.features.PrefetchResultKey
 import com.android.photopicker.core.features.Priority
+import kotlinx.coroutines.Deferred
 
 /** Feature class for the Photopicker's overflow menu. */
 class OverflowMenuFeature : PhotopickerUiFeature {
@@ -36,8 +38,10 @@ class OverflowMenuFeature : PhotopickerUiFeature {
     companion object Registration : FeatureRegistration {
         override val TAG: String = "PhotopickerOverflowMenuFeature"
 
-        override fun isEnabled(config: PhotopickerConfiguration) =
-            config.runtimeEnv != PhotopickerRuntimeEnv.EMBEDDED
+        override fun isEnabled(
+            config: PhotopickerConfiguration,
+            deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>>,
+        ) = config.runtimeEnv != PhotopickerRuntimeEnv.EMBEDDED
 
         override fun build(featureManager: FeatureManager) = OverflowMenuFeature()
     }
diff --git a/photopicker/src/com/android/photopicker/features/photogrid/PhotoGrid.kt b/photopicker/src/com/android/photopicker/features/photogrid/PhotoGrid.kt
index 7618bac5f..a84b71ac0 100644
--- a/photopicker/src/com/android/photopicker/features/photogrid/PhotoGrid.kt
+++ b/photopicker/src/com/android/photopicker/features/photogrid/PhotoGrid.kt
@@ -17,6 +17,8 @@
 package com.android.photopicker.features.photogrid
 
 import androidx.compose.animation.animateContentSize
+import androidx.compose.animation.expandVertically
+import androidx.compose.animation.shrinkVertically
 import androidx.compose.foundation.gestures.detectHorizontalDragGestures
 import androidx.compose.foundation.layout.Box
 import androidx.compose.foundation.layout.Column
@@ -45,7 +47,10 @@ import androidx.compose.ui.unit.dp
 import androidx.lifecycle.compose.collectAsStateWithLifecycle
 import androidx.paging.LoadState
 import androidx.paging.compose.collectAsLazyPagingItems
+import com.android.modules.utils.build.SdkLevel
 import com.android.photopicker.R
+import com.android.photopicker.core.StateSelector
+import com.android.photopicker.core.animations.standardDecelerate
 import com.android.photopicker.core.banners.Banner
 import com.android.photopicker.core.banners.BannerDefinitions
 import com.android.photopicker.core.components.EmptyState
@@ -61,6 +66,7 @@ import com.android.photopicker.core.events.Telemetry
 import com.android.photopicker.core.features.FeatureToken
 import com.android.photopicker.core.features.LocalFeatureManager
 import com.android.photopicker.core.features.Location
+import com.android.photopicker.core.hideWhenState
 import com.android.photopicker.core.navigation.LocalNavController
 import com.android.photopicker.core.navigation.PhotopickerDestinations
 import com.android.photopicker.core.navigation.PhotopickerDestinations.PHOTO_GRID
@@ -70,9 +76,11 @@ import com.android.photopicker.core.theme.LocalWindowSizeClass
 import com.android.photopicker.extensions.navigateToAlbumGrid
 import com.android.photopicker.extensions.navigateToPhotoGrid
 import com.android.photopicker.extensions.navigateToPreviewMedia
+import com.android.photopicker.extensions.transferTouchesToHostInEmbedded
 import com.android.photopicker.features.albumgrid.AlbumGridFeature
 import com.android.photopicker.features.navigationbar.NavigationBarButton
 import com.android.photopicker.features.preview.PreviewFeature
+import com.android.photopicker.util.LocalLocalizationHelper
 import kotlinx.coroutines.launch
 
 private val MEASUREMENT_BANNER_PADDING =
@@ -114,8 +122,14 @@ fun PhotoGrid(viewModel: PhotoGridViewModel = obtainViewModel()) {
             .collectAsLazyPagingItems()
 
     val selectionLimit = LocalPhotopickerConfiguration.current.selectionLimit
+    val localizedSelectionLimit = LocalLocalizationHelper.current.getLocalizedCount(selectionLimit)
+
     val selectionLimitExceededMessage =
-        stringResource(R.string.photopicker_selection_limit_exceeded_snackbar, selectionLimit)
+        stringResource(
+            R.string.photopicker_selection_limit_exceeded_snackbar,
+            localizedSelectionLimit,
+        )
+
     val events = LocalEvents.current
     val scope = rememberCoroutineScope()
     val configuration = LocalPhotopickerConfiguration.current
@@ -155,6 +169,7 @@ fun PhotoGrid(viewModel: PhotoGridViewModel = obtainViewModel()) {
         LocalPhotopickerConfiguration.current.runtimeEnv == PhotopickerRuntimeEnv.EMBEDDED
     val isExpanded = LocalEmbeddedState.current?.isExpanded ?: false
     val isEmbeddedAndCollapsed = isEmbedded && !isExpanded
+    val host = LocalEmbeddedState.current?.host
 
     Column(
         modifier =
@@ -174,8 +189,15 @@ fun PhotoGrid(viewModel: PhotoGridViewModel = obtainViewModel()) {
                 val emptyStatePadding =
                     remember(localConfig) { (localConfig.screenHeightDp * .20).dp }
                 EmptyState(
-                    // Provide 20% of screen height as empty space above
-                    modifier = Modifier.fillMaxWidth().padding(top = emptyStatePadding),
+                    modifier =
+                        if (SdkLevel.isAtLeastU() && isEmbedded && host != null) {
+                            // In embedded no need to give extra top padding to make empty
+                            // state title and body clearly visible in collapse mode (small view)
+                            Modifier.fillMaxWidth().transferTouchesToHostInEmbedded(host = host)
+                        } else {
+                            // Provide 20% of screen height as empty space above
+                            Modifier.fillMaxWidth().padding(top = emptyStatePadding)
+                        },
                     icon = Icons.Outlined.Image,
                     title = stringResource(R.string.photopicker_photos_empty_state_title),
                     body = stringResource(R.string.photopicker_photos_empty_state_body),
@@ -191,8 +213,27 @@ fun PhotoGrid(viewModel: PhotoGridViewModel = obtainViewModel()) {
                 mediaGrid(
                     items = items,
                     isExpandedScreen = isExpandedScreen,
+                    userScrollEnabled =
+                        when (isEmbedded) {
+                            true -> isExpanded
+                            false -> true
+                        },
                     selection = selection,
-                    bannerContent = { AnimatedBannerWrapper(currentBanner) },
+                    bannerContent = {
+                        hideWhenState(
+                            selector =
+                                object : StateSelector.AnimatedVisibilityInEmbedded {
+                                    override val visible =
+                                        LocalEmbeddedState.current?.isExpanded ?: false
+                                    override val enter =
+                                        expandVertically(animationSpec = standardDecelerate(300))
+                                    override val exit =
+                                        shrinkVertically(animationSpec = standardDecelerate(150))
+                                }
+                        ) {
+                            AnimatedBannerWrapper(currentBanner)
+                        }
+                    },
                     onItemClick = { item ->
                         if (item is MediaGridItem.MediaItem) {
                             viewModel.handleGridItemSelection(
diff --git a/photopicker/src/com/android/photopicker/features/photogrid/PhotoGridFeature.kt b/photopicker/src/com/android/photopicker/features/photogrid/PhotoGridFeature.kt
index 7e0b7ea9b..75edcba66 100644
--- a/photopicker/src/com/android/photopicker/features/photogrid/PhotoGridFeature.kt
+++ b/photopicker/src/com/android/photopicker/features/photogrid/PhotoGridFeature.kt
@@ -26,6 +26,7 @@ import androidx.compose.ui.Modifier
 import androidx.navigation.NamedNavArgument
 import androidx.navigation.NavBackStackEntry
 import androidx.navigation.NavDeepLink
+import com.android.photopicker.core.animations.springDefaultEffectOffset
 import com.android.photopicker.core.configuration.PhotopickerConfiguration
 import com.android.photopicker.core.events.Event
 import com.android.photopicker.core.events.RegisteredEventClass
@@ -35,9 +36,11 @@ import com.android.photopicker.core.features.FeatureToken
 import com.android.photopicker.core.features.Location
 import com.android.photopicker.core.features.LocationParams
 import com.android.photopicker.core.features.PhotopickerUiFeature
+import com.android.photopicker.core.features.PrefetchResultKey
 import com.android.photopicker.core.features.Priority
 import com.android.photopicker.core.navigation.PhotopickerDestinations
 import com.android.photopicker.core.navigation.Route
+import kotlinx.coroutines.Deferred
 
 /**
  * Feature class for the Photopicker's primary photo grid.
@@ -48,7 +51,10 @@ class PhotoGridFeature : PhotopickerUiFeature {
     companion object Registration : FeatureRegistration {
         override val TAG: String = "PhotopickerPhotoGridFeature"
 
-        override fun isEnabled(config: PhotopickerConfiguration) = true
+        override fun isEnabled(
+            config: PhotopickerConfiguration,
+            deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>>,
+        ) = true
 
         override fun build(featureManager: FeatureManager) = PhotoGridFeature()
     }
@@ -63,9 +69,7 @@ class PhotoGridFeature : PhotopickerUiFeature {
         setOf(Event.ShowSnackbarMessage::class.java, Event.LogPhotopickerUIEvent::class.java)
 
     override fun registerLocations(): List<Pair<Location, Int>> {
-        return listOf(
-            Pair(Location.NAVIGATION_BAR_NAV_BUTTON, Priority.HIGH.priority),
-        )
+        return listOf(Pair(Location.NAVIGATION_BAR_NAV_BUTTON, Priority.HIGH.priority))
     }
 
     override fun registerNavigationRoutes(): Set<Route> {
@@ -91,41 +95,37 @@ class PhotoGridFeature : PhotopickerUiFeature {
                     (AnimatedContentTransitionScope<NavBackStackEntry>.() -> EnterTransition)? =
                     {
                         // Positive value to slide left-to-right
-                        slideInHorizontally { -it }
+                        slideInHorizontally(animationSpec = springDefaultEffectOffset) { it }
                     }
                 override val exitTransition:
                     (AnimatedContentTransitionScope<NavBackStackEntry>.() -> ExitTransition)? =
                     {
                         // Negative value to slide right-to-left
-                        slideOutHorizontally { -it }
+                        slideOutHorizontally(animationSpec = springDefaultEffectOffset) { -it }
                     }
                 override val popEnterTransition:
                     (AnimatedContentTransitionScope<NavBackStackEntry>.() -> EnterTransition)? =
                     {
                         // When returning from the backstack slide right-to-left
-                        slideInHorizontally { -it }
+                        slideInHorizontally(animationSpec = springDefaultEffectOffset) { -it }
                     }
                 override val popExitTransition:
                     (AnimatedContentTransitionScope<NavBackStackEntry>.() -> ExitTransition)? =
                     {
                         // When navigating to the backstack slide left-to-right
-                        slideOutHorizontally { -it }
+                        slideOutHorizontally(animationSpec = springDefaultEffectOffset) { -it }
                     }
 
                 @Composable
                 override fun composable(navBackStackEntry: NavBackStackEntry?) {
                     PhotoGrid()
                 }
-            },
+            }
         )
     }
 
     @Composable
-    override fun compose(
-        location: Location,
-        modifier: Modifier,
-        params: LocationParams,
-    ) {
+    override fun compose(location: Location, modifier: Modifier, params: LocationParams) {
         when (location) {
             Location.NAVIGATION_BAR_NAV_BUTTON -> PhotoGridNavButton(modifier)
             else -> {}
diff --git a/photopicker/src/com/android/photopicker/features/cloudmedia/MediaPreloader.kt b/photopicker/src/com/android/photopicker/features/preparemedia/MediaPreparer.kt
similarity index 67%
rename from photopicker/src/com/android/photopicker/features/cloudmedia/MediaPreloader.kt
rename to photopicker/src/com/android/photopicker/features/preparemedia/MediaPreparer.kt
index ffa864de5..5159cd417 100644
--- a/photopicker/src/com/android/photopicker/features/cloudmedia/MediaPreloader.kt
+++ b/photopicker/src/com/android/photopicker/features/preparemedia/MediaPreparer.kt
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.android.photopicker.features.cloudmedia
+package com.android.photopicker.features.preparemedia
 
 import android.util.Log
 import androidx.compose.foundation.layout.Column
@@ -37,9 +37,9 @@ import androidx.compose.runtime.Composable
 import androidx.compose.runtime.LaunchedEffect
 import androidx.compose.runtime.getValue
 import androidx.compose.runtime.rememberCoroutineScope
-import androidx.compose.runtime.setValue
 import androidx.compose.ui.Alignment
 import androidx.compose.ui.Modifier
+import androidx.compose.ui.platform.LocalContext
 import androidx.compose.ui.res.stringResource
 import androidx.compose.ui.unit.dp
 import androidx.lifecycle.compose.collectAsStateWithLifecycle
@@ -62,110 +62,110 @@ private val MEASUREMENT_DIALOG_PADDING = 24.dp
 @Composable
 @OptIn(ExperimentalMaterial3Api::class)
 /**
- * Attaches a [MediaPreloader] so that it can handle emissions in the
- * [LocationParams.WithMediaPreloader.preloadMedia] and display preloading dialogs to the user.
+ * Attaches a [MediaPreparer] so that it can handle emissions in the
+ * [LocationParams.WithMediaPreparer.prepareMedia] and display preparing dialogs to the user.
  *
  * This composable has three states:
- * - Empty (No preload activity, no error state)
- * - Loading (A preload operation is currently running)
- * - Error (A preloading operation has failed)
+ * - Empty (No prepare activity, no error state)
+ * - Preparing (A prepare operation is currently running)
+ * - Error (A preparing operation has failed)
  *
  * For the non empty states, the appropriate dialog is shown to the user. For an empty state, this
- * composable exists to attach the [MediaPreloaderViewModel] so that it can monitor the event bus.
+ * composable exists to attach the [MediaPreparerViewModel] so that it can monitor the event bus.
  */
-fun MediaPreloader(
+fun MediaPreparer(
     // The incoming modifier is ignored, since no elements are actually added to
-    // [Location.MEDIA_PRELOADER], only floating dialogs that sit above the app.
+    // [Location.MEDIA_PREPARER], only floating dialogs that sit above the app.
     @Suppress("UNUSED_PARAMETER") modifier: Modifier,
     params: LocationParams,
-    viewModel: MediaPreloaderViewModel = obtainViewModel(),
+    viewModel: MediaPreparerViewModel = obtainViewModel(),
 ) {
 
     // Data flow from the view model for which Dialog to display.
     val dialogData by viewModel.dialogData.collectAsStateWithLifecycle()
 
-    // These must be set by the parent composable for the preloader to have any effect.
-    val preloaderParameters = params as? LocationParams.WithMediaPreloader
+    // These must be set by the parent composable for the preparer to have any effect.
+    val preparerParameters = params as? LocationParams.WithMediaPreparer
 
     val configuration = LocalPhotopickerConfiguration.current
     val scope = rememberCoroutineScope()
     val events = LocalEvents.current
+    val context = LocalContext.current
 
-    preloaderParameters?.let {
+    preparerParameters?.let {
         LaunchedEffect(params) {
-            // Listen for emissions of media to preload, and begin the preload when requested.
-            it.preloadMedia.collect { media ->
-                // Dispatch UI event to log the beginning of media items preloading
+            // Listen for emissions of media to prepare, and begin the prepare when requested.
+            it.prepareMedia.collect { media ->
+                // Dispatch UI event to log the beginning of media items preparing
                 scope.launch {
                     events.dispatch(
                         Event.LogPhotopickerUIEvent(
                             FeatureToken.CORE.token,
                             configuration.sessionId,
                             configuration.callingPackageUid ?: -1,
-                            Telemetry.UiEvent.PICKER_PRELOADING_START
+                            Telemetry.UiEvent.PICKER_PRELOADING_START,
                         )
                     )
                 }
-                viewModel.startPreload(media, it.obtainDeferred())
+
+                viewModel.startPrepare(media, it.obtainDeferred(), context)
             }
         }
     }
-        // If no preloaderParameters were passed to this location, there is no way to trigger
-        // the preloader.
+        // If no preparerParameters were passed to this location, there is no way to trigger
+        // the preparer.
         ?: Log.w(
-            CloudMediaFeature.TAG,
-            "MediaPreloader did not receive parameters from parent location," +
-                "  the preloader will not be active."
+            PrepareMediaFeature.TAG,
+            "MediaPreparer did not receive parameters from parent location," +
+                "  the preparer will not be active.",
         )
 
-    // Show a dialog or empty state based on which [PreloaderDialogData] is present.
+    // Show a dialog or empty state based on which [PreparerDialogData] is present.
     when (val data = dialogData) {
         null -> Unit // Empty state, no dialog
-        is PreloaderDialogData.PreloaderLoadingDialogData ->
-            MediaPreloaderLoadingDialog(
+        is PreparerDialogData.PreparingDialogData ->
+            MediaPreparerPreparingDialog(
                 dialogData = data,
                 onDismissRequest = {
-                    viewModel.cancelPreload(preloaderParameters?.obtainDeferred())
+                    viewModel.cancelPrepare(preparerParameters?.obtainDeferred())
                     viewModel.hideAllDialogs()
                 },
             )
-        is PreloaderDialogData.PreloaderLoadingErrorDialog ->
-            MediaPreloaderErrorDialog(
+        is PreparerDialogData.PreparingErrorDialog ->
+            MediaPreparerErrorDialog(
                 onDismissRequest = {
-                    viewModel.cancelPreload(preloaderParameters?.obtainDeferred())
+                    viewModel.cancelPrepare(preparerParameters?.obtainDeferred())
                     viewModel.hideAllDialogs()
-                },
+                }
             )
     }
 }
 
 /**
- * This is the Loading state dialog of the Preloader.
+ * This is the Preparing state dialog of the Preparer.
  *
- * This dialog shows a Loading message and progress indicator to the user which updates as the
- * [MediaPreloaderViewModel] emits updated [PreloaderDialogData].
+ * This dialog shows a Preparing message and progress indicator to the user which updates as the
+ * [MediaPreparerViewModel] emits updated [PreparerDialogData].
  *
- * The user can cancel the preload operation to return to the previous screen. (This will also
+ * The user can cancel the prepare operation to return to the previous screen. (This will also
  * prevent the Photopicker from being closed when the Media is ready.)
  */
 @OptIn(ExperimentalMaterial3Api::class)
 @Composable
-private fun MediaPreloaderLoadingDialog(
+private fun MediaPreparerPreparingDialog(
     onDismissRequest: () -> Unit,
-    dialogData: PreloaderDialogData.PreloaderLoadingDialogData,
+    dialogData: PreparerDialogData.PreparingDialogData,
 ) {
-    BasicAlertDialog(
-        onDismissRequest = {},
-    ) {
+    BasicAlertDialog(onDismissRequest = {}) {
         Surface(
             modifier = Modifier.wrapContentWidth().wrapContentHeight(),
             shape = MaterialTheme.shapes.large,
-            tonalElevation = AlertDialogDefaults.TonalElevation
+            tonalElevation = AlertDialogDefaults.TonalElevation,
         ) {
             Column(modifier = Modifier.padding(MEASUREMENT_DIALOG_PADDING)) {
                 Text(
                     stringResource(R.string.photopicker_preloading_dialog_title),
-                    style = MaterialTheme.typography.titleLarge
+                    style = MaterialTheme.typography.titleLarge,
                 )
                 Spacer(modifier = Modifier.height(MEASUREMENT_DIALOG_SPACER_SIZE))
                 Row(verticalAlignment = Alignment.CenterVertically) {
@@ -175,16 +175,14 @@ private fun MediaPreloaderLoadingDialog(
                         stringResource(
                             R.string.photopicker_preloading_progress_message,
                             dialogData.completed,
-                            dialogData.total
+                            dialogData.total,
                         ),
-                        style = MaterialTheme.typography.bodyMedium
+                        style = MaterialTheme.typography.bodyMedium,
                     )
                 }
                 Spacer(modifier = Modifier.height(MEASUREMENT_DIALOG_SPACER_SIZE))
                 Row(Modifier.align(Alignment.End)) {
-                    TextButton(
-                        onClick = onDismissRequest,
-                    ) {
+                    TextButton(onClick = onDismissRequest) {
                         Text(stringResource(android.R.string.cancel))
                     }
                 }
@@ -196,40 +194,34 @@ private fun MediaPreloaderLoadingDialog(
 @OptIn(ExperimentalMaterial3Api::class)
 @Composable
 /**
- * This is the Error state dialog of the Preloader.
+ * This is the Error state dialog of the Preparer.
  *
  * This dialog shows a generic Error message to the user which updates as the
- * [MediaPreloaderViewModel] emits updated [PreloaderDialogData].
+ * [MediaPreparerViewModel] emits updated [PreparerDialogData].
  *
  * The user can dismiss the dialog to return to the previous screen.
  */
-private fun MediaPreloaderErrorDialog(
-    onDismissRequest: () -> Unit,
-) {
+private fun MediaPreparerErrorDialog(onDismissRequest: () -> Unit) {
 
-    BasicAlertDialog(
-        onDismissRequest = onDismissRequest,
-    ) {
+    BasicAlertDialog(onDismissRequest = onDismissRequest) {
         Surface(
             modifier = Modifier.wrapContentWidth().wrapContentHeight(),
             shape = MaterialTheme.shapes.large,
-            tonalElevation = AlertDialogDefaults.TonalElevation
+            tonalElevation = AlertDialogDefaults.TonalElevation,
         ) {
             Column(modifier = Modifier.padding(MEASUREMENT_DIALOG_PADDING)) {
                 Text(
                     stringResource(R.string.photopicker_preloading_dialog_error_title),
-                    style = MaterialTheme.typography.titleLarge
+                    style = MaterialTheme.typography.titleLarge,
                 )
                 Spacer(modifier = Modifier.height(MEASUREMENT_DIALOG_SPACER_SIZE))
                 Text(
                     stringResource(R.string.photopicker_preloading_dialog_error_message),
-                    style = MaterialTheme.typography.bodyMedium
+                    style = MaterialTheme.typography.bodyMedium,
                 )
                 Spacer(modifier = Modifier.height(MEASUREMENT_DIALOG_SPACER_SIZE))
                 Row(Modifier.align(Alignment.End)) {
-                    TextButton(
-                        onClick = onDismissRequest,
-                    ) {
+                    TextButton(onClick = onDismissRequest) {
                         Text(stringResource(android.R.string.ok))
                     }
                 }
diff --git a/photopicker/src/com/android/photopicker/features/preparemedia/MediaPreparerViewModel.kt b/photopicker/src/com/android/photopicker/features/preparemedia/MediaPreparerViewModel.kt
new file mode 100644
index 000000000..41753b265
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/preparemedia/MediaPreparerViewModel.kt
@@ -0,0 +1,730 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.preparemedia
+
+import android.content.Context
+import android.os.Bundle
+import android.util.Log
+import androidx.annotation.GuardedBy
+import androidx.annotation.VisibleForTesting
+import androidx.lifecycle.ViewModel
+import androidx.lifecycle.viewModelScope
+import com.android.photopicker.core.Background
+import com.android.photopicker.core.configuration.ConfigurationManager
+import com.android.photopicker.core.events.Event
+import com.android.photopicker.core.events.Events
+import com.android.photopicker.core.events.Telemetry
+import com.android.photopicker.core.features.FeatureToken
+import com.android.photopicker.core.selection.Selection
+import com.android.photopicker.core.user.UserMonitor
+import com.android.photopicker.data.model.Media
+import com.android.photopicker.data.model.MediaSource
+import com.android.photopicker.features.preparemedia.PrepareMediaResult.PrepareMediaFailed
+import com.android.photopicker.features.preparemedia.PrepareMediaResult.PreparedMedia
+import com.android.photopicker.features.preparemedia.Transcoder.Companion.toTranscodedUri
+import dagger.hilt.android.lifecycle.HiltViewModel
+import java.io.FileNotFoundException
+import javax.inject.Inject
+import kotlinx.coroutines.CompletableDeferred
+import kotlinx.coroutines.CoroutineDispatcher
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.Job
+import kotlinx.coroutines.channels.BufferOverflow
+import kotlinx.coroutines.flow.MutableSharedFlow
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.SharingStarted
+import kotlinx.coroutines.flow.StateFlow
+import kotlinx.coroutines.flow.distinctUntilChanged
+import kotlinx.coroutines.flow.map
+import kotlinx.coroutines.flow.stateIn
+import kotlinx.coroutines.flow.update
+import kotlinx.coroutines.launch
+import kotlinx.coroutines.sync.Mutex
+import kotlinx.coroutines.sync.withLock
+
+/** Enumeration for the LoadStatus of a given preloaded item. */
+private enum class LoadStatus {
+    COMPLETED,
+    FAILED,
+    QUEUED,
+}
+
+/** Enumeration for the TranscodeStatus of a given media item. */
+private enum class TranscodeStatus {
+    NOT_APPLIED,
+    SUCCEED,
+    FAILED,
+    QUEUED,
+}
+
+/** Data class for the prepare status of a given media item. */
+private data class PrepareStatus(val loadStatus: LoadStatus, val transcodeStatus: TranscodeStatus) {
+    val isPreloadCompleted = loadStatus == LoadStatus.COMPLETED
+    val isTranscodeCompleted =
+        transcodeStatus == TranscodeStatus.SUCCEED || transcodeStatus == TranscodeStatus.NOT_APPLIED
+
+    val isCompleted = isPreloadCompleted && isTranscodeCompleted
+    val isFailed = loadStatus == LoadStatus.FAILED || transcodeStatus == TranscodeStatus.FAILED
+}
+
+/** Data objects which contain all the UI data to render the various Preparer dialogs. */
+sealed interface PreparerDialogData {
+
+    /**
+     * The preparing dialog data.
+     *
+     * @param total Total of items to be prepared
+     * @param completed Number of items currently completed
+     */
+    data class PreparingDialogData(val total: Int, val completed: Int = 0) : PreparerDialogData
+
+    /** Empty object for telling the UI to show a generic error dialog */
+    object PreparingErrorDialog : PreparerDialogData
+}
+
+/**
+ * The view model for the [MediaPreparer].
+ *
+ * This is the class responsible for preparing files before providing URI, e.g. request remote
+ * providers to prepare remote media for local apps or pre-transcode video for incompatible apps.
+ * The main preparing operation should only be triggered by the main activity, by emitting a set of
+ * media to prepare into the flow provided to the MediaPreparer compose UI via [LocationParams].
+ *
+ * Additionally, this method exposes the required state data for the UI to draw the correct dialog
+ * overlays as preparing is initiated, is progressing, and resolves with either a failure or a
+ * success.
+ *
+ * This class should not be injected anywhere other than the MediaPreparer's context to attempt to
+ * monitor the state of the ongoing prepare.
+ *
+ * When the prepare is complete, the [CompletableDeferred] that is passed in the [LocationParams]
+ * will be marked completed, A TRUE value indicates success, and a FALSE value indicates a failure.
+ */
+@HiltViewModel
+class MediaPreparerViewModel
+@Inject
+constructor(
+    private val scopeOverride: CoroutineScope?,
+    @Background private val backgroundDispatcher: CoroutineDispatcher,
+    private val selection: Selection<Media>,
+    private val userMonitor: UserMonitor,
+    private val configurationManager: ConfigurationManager,
+    private val events: Events,
+) : ViewModel() {
+
+    companion object {
+        private const val EXTRA_URI = "uri"
+        private const val PICKER_TRANSCODE_CALL = "picker_transcode"
+        @VisibleForTesting const val PICKER_TRANSCODE_RESULT = "picker_transcode_result"
+
+        // Ensure only 2 downloads are occurring in parallel.
+        val MAX_CONCURRENT_LOADS = 2
+    }
+
+    /* Parent job that owns the overall preparer operation & monitor */
+    private var job: Job? = null
+
+    /*
+     * A heartbeat flow to drive the prepare monitor job.
+     * Replay = 1 and DROP_OLDEST due to the fact the heartbeat doesn't contain any useful
+     * data, so as long as something is in the buffer to be collected, there's no need
+     * for duplicate emissions.
+     */
+    private val heartbeat: MutableSharedFlow<Unit> =
+        MutableSharedFlow(replay = 1, onBufferOverflow = BufferOverflow.DROP_OLDEST)
+
+    // Protect [preparingItems] with a Mutex since multiple coroutines are reading/writing it.
+    private val mutex = Mutex()
+
+    // A map that tracks the p [PrepareStatus] of media items.
+    // NOTE: This should always be accessed after acquiring the [Mutex] to ensure data
+    // accuracy during concurrency.
+    @GuardedBy("mutex") private val preparingItems = mutableMapOf<Media, PrepareStatus>()
+
+    /*
+     * A flow to drive the media transcoding job.
+     * Replay = selectionLimit so that any place that emits to this flow, won't suspend.
+     * (Each media is expected to be emitted only once, so each media should only be emitted when
+     *  it is ready for transcoding)
+     */
+    private val itemsToTranscode: MutableSharedFlow<Media> =
+        MutableSharedFlow(
+            replay = configurationManager.configuration.value.selectionLimit,
+            onBufferOverflow = BufferOverflow.SUSPEND,
+        )
+
+    // Transcoder that help media transcode process.
+    @VisibleForTesting var transcoder: Transcoder = TranscoderImpl()
+
+    // Check if a scope override was injected before using the default [viewModelScope]
+    private val scope: CoroutineScope =
+        if (scopeOverride == null) {
+            this.viewModelScope
+        } else {
+            scopeOverride
+        }
+
+    /* Flow for monitoring the activeContentResolver:
+     *   - map to get rid of other [UserStatus] fields this does not care about
+     *   - distinctUntilChanged to only emit when the resolver actually changes, since
+     *     UserStatus might be updated if other profiles turn on and off
+     */
+    private val _contentResolver =
+        userMonitor.userStatus.map { it.activeContentResolver }.distinctUntilChanged()
+
+    /** Flow that can push new data into the preparer's dialogs. */
+    private val _dialogData = MutableStateFlow<PreparerDialogData?>(null)
+
+    /** Public flow for the compose ui to collect. */
+    val dialogData: StateFlow<PreparerDialogData?> =
+        _dialogData.stateIn(
+            scope,
+            SharingStarted.WhileSubscribed(),
+            initialValue = _dialogData.value,
+        )
+
+    init {
+
+        // If the active user's resolver changes, cancel any pending prepare work.
+        scope.launch {
+            _contentResolver.collect {
+                // Action is only required if there's currently a job running.
+                job?.let {
+                    Log.d(PrepareMediaFeature.TAG, "User was changed, abandoning prepares")
+                    it.cancel()
+                    hideAllDialogs()
+                }
+            }
+        }
+    }
+
+    /**
+     * Entrypoint of the selected media prepare operation.
+     *
+     * This is triggered when the prepareMedia flow from compose receives a new Set<Media> to
+     * prepare.
+     *
+     * Once the new set of media is received from its source, the compose UI will call startPrepare
+     * to begin the prepare of the set.
+     *
+     * This operation will enqueue work to prepare any media files that are present in the current
+     * selection to ensure they are downloaded by the remote provider or transcoded to a compatible
+     * format. This has the benefit of ensuring that the files can be immediately opened by the App
+     * that started Photopicker without having to deal with awaiting any remote procedures to bring
+     * the remote file down to the device.
+     *
+     * This method will run a parent [CoroutineScope] (see [job] in this class), which will
+     * subsequently schedule child jobs for each media item in the selection. For remote media
+     * preloading, the [Background] [CoroutineDispatcher] is used for this operation, however the
+     * parallel execution is limited to [MAX_CONCURRENT_LOADS] to avoid over-stressing the remote
+     * providers and saturating the available network bandwidth. For media transcoding, the
+     * execution is running sequentially, and if a media item requires remote preloading before
+     * transcoding, subsequent items are processed first to maximize efficiency.
+     *
+     * @param selection The set of media to prepare.
+     * @param deferred A [CompletableDeferred] that can be used to signal when the prepare operation
+     *   is complete. TRUE represents success, FALSE represents failure.
+     * @param context The current context.
+     * @see [LocationParams.WithMediaPreparer] for the data that is passed to the UI to attach the
+     *   preparer.
+     */
+    suspend fun startPrepare(
+        selection: Set<Media>,
+        deferred: CompletableDeferred<PrepareMediaResult>,
+        context: Context,
+    ) {
+        initialMediaPreparation(selection)
+
+        val countPrepareRequired: Int =
+            mutex.withLock { preparingItems.filter { (_, status) -> !status.isCompleted }.size }
+
+        // End early if there are not any items need to be prepared.
+        if (countPrepareRequired == 0) {
+            Log.i(PrepareMediaFeature.TAG, "Prepare not required, no remote or incompatible items.")
+            deferred.complete(PreparedMedia(preparedMedia = getPreparedMedia()))
+            return
+        }
+
+        Log.i(
+            PrepareMediaFeature.TAG,
+            "SelectionMediaBeginPrepare operation was requested. " +
+                "Total items to prepare: $countPrepareRequired",
+        )
+
+        // Update the UI so the Preparing dialog can be displayed with the initial preparing data.
+        _dialogData.update {
+            PreparerDialogData.PreparingDialogData(
+                total = selection.size,
+                completed = (selection.size - countPrepareRequired),
+            )
+        }
+
+        // All preparing work must be a child of this job, a reference of the job is saved
+        // so that if the User requests cancellation the child jobs receive the cancellation as
+        // well.
+        job =
+            scope.launch(backgroundDispatcher) {
+                // Enqueue a job to monitor the ongoing operation. This job is crucially also a
+                // child of the main preloading job, so it will be canceled anytime loading is
+                // canceled.
+                launch { monitorPrepareOperation(deferred) }
+
+                // Start a parallelism constrained child job to actually handle the loads to
+                // enforce that the device bandwidth doesn't become over saturated by trying
+                // to load too many files at once.
+                launch(
+                    @OptIn(kotlinx.coroutines.ExperimentalCoroutinesApi::class)
+                    backgroundDispatcher.limitedParallelism(MAX_CONCURRENT_LOADS)
+                ) {
+                    // This is the main preloading job coroutine, enqueue other work here, but
+                    // don't run any heavy / blocking work, as it will prevent the loading
+                    // from starting.
+                    val remoteItems =
+                        mutex.withLock {
+                            preparingItems.entries
+                                .toList()
+                                .filter { it.value.loadStatus == LoadStatus.QUEUED }
+                                .map { it.key }
+                        }
+                    for (item in remoteItems) {
+                        launch { preloadMediaItem(item, deferred) }
+                    }
+                }
+
+                // Start a child job to wait and send the readied media items to transcode.
+                launch {
+                    itemsToTranscode.collect { item ->
+                        try {
+                            // The transcoding process is only started when an item's transcoding
+                            // is not completed (currently only video can be transcoded) and
+                            // does not require loading.
+                            val prepareStatus = mutex.withLock { preparingItems.getValue(item) }
+                            if (
+                                !prepareStatus.isTranscodeCompleted &&
+                                    prepareStatus.isPreloadCompleted
+                            ) {
+                                transcodeMediaItem(item, deferred, context)
+                            }
+                        } catch (e: NoSuchElementException) {
+                            // Should not go here.
+                            Log.e(
+                                PrepareMediaFeature.TAG,
+                                "Expected media object was not in the status map",
+                                e,
+                            )
+                        }
+                    }
+                }
+            }
+    }
+
+    /**
+     * Initializes required objects for media prepare processing.
+     *
+     * @param selection The set of media to be prepared.
+     */
+    private suspend fun initialMediaPreparation(selection: Set<Media>) {
+        val config = configurationManager.configuration.value
+        val mediaCapabilities = config.callingPackageMediaCapabilities
+        val isTranscodingEnabled = config.flags.PICKER_TRANSCODING_ENABLED
+
+        // Initial preparation states.
+        mutex.withLock {
+            // Begin by clearing any prior state.
+            preparingItems.clear()
+
+            for (item in selection) {
+                // Check if media need to be preloaded.
+                val loadStatus =
+                    if (item.mediaSource == MediaSource.REMOTE) {
+                        LoadStatus.QUEUED
+                    } else {
+                        LoadStatus.COMPLETED
+                    }
+
+                // Check if media need to be transcoded.
+                val transcodeStatus =
+                    if (isTranscodingEnabled && mediaCapabilities != null && item is Media.Video) {
+                        TranscodeStatus.QUEUED
+                    } else {
+                        TranscodeStatus.NOT_APPLIED
+                    }
+
+                val prepareStatus = PrepareStatus(loadStatus, transcodeStatus)
+                preparingItems.put(item, prepareStatus)
+
+                // Queue readied media items for transcoding. Items that have not been preloaded
+                // will be queued after loading.
+                if (!prepareStatus.isTranscodeCompleted && prepareStatus.isPreloadCompleted) {
+                    itemsToTranscode.emit(item)
+                }
+            }
+        }
+    }
+
+    /**
+     * Entrypoint for preloading a single [Media] item.
+     *
+     * This begins preparing the file by requesting the file from the current user's
+     * [ContentResolver], and updates the dialog data and remote items statuses when a load is
+     * successful.
+     *
+     * If a file cannot be opened or the ContentResolver throws a [FileNotFoundException], the item
+     * is marked as failed.
+     *
+     * @param item The item to load from the [ContentResolver].
+     * @param deferred The overall deferred for the preload operation which is used to see if the
+     *   preload has been canceled already)
+     */
+    private suspend fun preloadMediaItem(
+        item: Media,
+        deferred: CompletableDeferred<PrepareMediaResult>,
+    ) {
+        Log.v(PrepareMediaFeature.TAG, "Beginning preload of: $item")
+        try {
+            if (!deferred.isCompleted) {
+                userMonitor.userStatus.value.activeContentResolver
+                    .openAssetFileDescriptor(item.mediaUri, "r")
+                    ?.close()
+
+                // Mark the item as complete in the result status.
+                updatePrepareStatus(item, loadStatus = LoadStatus.COMPLETED)
+                Log.v(PrepareMediaFeature.TAG, "Preload successful: $item")
+
+                // Pass the loaded item for transcoding. The transcoding status does not to check
+                // here, since it will be examined before passing to "transcodeMediaItem" to start
+                // the transcoding process.
+                itemsToTranscode.emit(item)
+
+                // Emit a new monitor heartbeat so the prepare can continue or finish.
+                heartbeat.emit(Unit)
+            }
+        } catch (e: FileNotFoundException) {
+            Log.e(PrepareMediaFeature.TAG, "Error while preloading $item", e)
+
+            // Only need to take action if the deferred is already not marked as completed,
+            // another prepare job may have already failed.
+            if (!deferred.isCompleted) {
+                Log.d(
+                    PrepareMediaFeature.TAG,
+                    "Failure detected, cancelling the rest of the preload operation.",
+                )
+                // Log failure of media items preloading
+                scope.launch {
+                    val configuration = configurationManager.configuration.value
+                    events.dispatch(
+                        Event.LogPhotopickerUIEvent(
+                            FeatureToken.CORE.token,
+                            configuration.sessionId,
+                            configuration.callingPackageUid ?: -1,
+                            Telemetry.UiEvent.PICKER_PRELOADING_FAILED,
+                        )
+                    )
+                }
+                // Mark the item as failed in the result status.
+                updatePrepareStatus(item, loadStatus = LoadStatus.FAILED)
+                // Emit a new heartbeat so the monitor will react to this failure.
+                heartbeat.emit(Unit)
+            }
+        }
+    }
+
+    /**
+     * Entrypoint for transcoding a single [Media.Video] item.
+     *
+     * This begins transcoding the file by triggering the call method of the current user's
+     * [ContentResolver], and updates the dialog data and incompatible items statuses when a
+     * transcode is successful.
+     *
+     * If a file cannot be opened or the ContentResolver throws a [FileNotFoundException], the item
+     * is marked as failed.
+     *
+     * @param item The item to transcode from the [ContentResolver].
+     * @param deferred The overall deferred for the transcode operation which is used to see if the
+     *   transcode has been canceled already).
+     * @param context The current context.
+     */
+    private suspend fun transcodeMediaItem(
+        item: Media,
+        deferred: CompletableDeferred<PrepareMediaResult>,
+        context: Context,
+    ) {
+        Log.v(PrepareMediaFeature.TAG, "Beginning transcode of: $item")
+        if (!deferred.isCompleted) {
+            if (item is Media.Video) {
+                val contentResolver = userMonitor.userStatus.value.activeContentResolver
+                val mediaCapabilities =
+                    configurationManager.configuration.value.callingPackageMediaCapabilities
+
+                // Trigger transcoding.
+                val transcodeStatus =
+                    if (transcoder.isTranscodeRequired(context, mediaCapabilities, item)) {
+                        val uri = item.mediaUri
+                        val resultBundle =
+                            contentResolver.call(
+                                uri,
+                                PICKER_TRANSCODE_CALL,
+                                null,
+                                Bundle().apply { putParcelable(EXTRA_URI, uri) },
+                            )
+
+                        if (resultBundle?.getBoolean(PICKER_TRANSCODE_RESULT, false) == true) {
+                            Log.v(PrepareMediaFeature.TAG, "Transcode successful: $item")
+                            TranscodeStatus.SUCCEED
+                        } else {
+                            Log.w(PrepareMediaFeature.TAG, "Not able to transcode: $item")
+                            TranscodeStatus.NOT_APPLIED
+                        }
+                    } else {
+                        Log.v(PrepareMediaFeature.TAG, "No need to transcode: $item")
+                        TranscodeStatus.NOT_APPLIED
+                    }
+
+                // Mark the item as complete in the result status.
+                updatePrepareStatus(item, transcodeStatus = transcodeStatus)
+            } else {
+                // Should not go here. Currently, only video can be transcoded.
+                Log.e(PrepareMediaFeature.TAG, "Expected media object was not a video")
+
+                // Mark the item as failed in the result status.
+                updatePrepareStatus(item, transcodeStatus = TranscodeStatus.FAILED)
+            }
+
+            // Emit a new monitor heartbeat so the prepare can continue or finish.
+            heartbeat.emit(Unit)
+        }
+    }
+
+    /**
+     * Updates the preparation status for the given media.
+     *
+     * @param item The media whose status to update.
+     * @param loadStatus The new load status. If null, the existing status is preserved.
+     * @param transcodeStatus The new transcode status. If null, the existing status is preserved.
+     */
+    private suspend fun updatePrepareStatus(
+        item: Media,
+        loadStatus: LoadStatus? = null,
+        transcodeStatus: TranscodeStatus? = null,
+    ) {
+        val oldStatus: PrepareStatus
+        val newStatus: PrepareStatus
+
+        mutex.withLock {
+            oldStatus =
+                try {
+                    preparingItems.getValue(item)
+                } catch (e: NoSuchElementException) {
+                    Log.e(
+                        PrepareMediaFeature.TAG,
+                        "Failed to update preparing status, item not in the map",
+                        e,
+                    )
+                    return
+                }
+            newStatus =
+                oldStatus.copy(
+                    loadStatus = loadStatus ?: oldStatus.loadStatus,
+                    transcodeStatus = transcodeStatus ?: oldStatus.transcodeStatus,
+                )
+            preparingItems.put(item, newStatus)
+        }
+
+        if (!oldStatus.isCompleted && newStatus.isCompleted) {
+            increaseCompletionOnUI()
+        }
+    }
+
+    /** Update the [PreparerDialogData] flow an increment the completed operations by one on UI. */
+    private fun increaseCompletionOnUI() {
+        _dialogData.update {
+            when (it) {
+                is PreparerDialogData.PreparingDialogData -> it.copy(completed = it.completed + 1)
+                else -> it
+            }
+        }
+    }
+
+    /**
+     * Suspended function that monitors media preparing and takes an action when [PrepareStatus] of
+     * all items are completed or a failure is found in [preparingItems].
+     *
+     * When all preparingItems are completed -> mark the [CompletableDeferred] that represents this
+     * prepare operation as completed(TRUE) to signal the prepare was successful.
+     *
+     * When one of the preparingItems is failed any pending prepares are cancelled, and the parent
+     * job is also canceled. The failed item(s) will be removed from the current selection, and the
+     * deferred will be completed(FALSE) to signal the prepare has failed.
+     *
+     * This method will run a new check for every heartbeat, and does not observe the
+     * [preparingItems] data structure directly. As such, it's important that any status changes in
+     * the state of preparing trigger an update of heartbeat for the collector in this method to
+     * execute.
+     *
+     * @param deferred the status of the overall prepare operation. TRUE signals a successful
+     *   prepare, and FALSE a failure.
+     */
+    @OptIn(ExperimentalCoroutinesApi::class)
+    private suspend fun monitorPrepareOperation(deferred: CompletableDeferred<PrepareMediaResult>) {
+
+        heartbeat.collect {
+
+            // Outcomes, another possibility is neither is met, and the prepare should continue
+            // until the next result.
+            var prepareFailed = false
+            var prepareCompleted = false
+
+            // Fetch the current results with the mutex, but don't hold the mutex longer than
+            // needed.
+            mutex.withLock {
+
+                // The prepare is failed if any single item fails to prepare.
+                prepareFailed = preparingItems.any { (_, status) -> status.isFailed }
+
+                // The prepare is complete if all items are completed successfully.
+                prepareCompleted = preparingItems.all { (_, status) -> status.isCompleted }
+            }
+
+            // Outcomes, if none of these branches are yet met, the prepare will continue, and this
+            // block will run on the next known result.
+            when {
+                prepareFailed -> {
+                    // Remove any failed items from the selection
+                    selection.removeAll(
+                        preparingItems.filter { (_, status) -> status.isFailed }.keys
+                    )
+                    // Now that a failure has been detected, update the [PreparerDialogData]
+                    // so the UI will show the preparing error dialog.
+                    _dialogData.update { PreparerDialogData.PreparingErrorDialog }
+
+                    // Since something has failed, mark the overall prepare operation as failed.
+                    deferred.complete(PrepareMediaFailed)
+                }
+                prepareCompleted -> {
+                    // If all of the remote items have completed successfully and the videos have
+                    // been transcoded to the compatible formats, the prepare operation is
+                    // complete, deferred can be marked as complete(true) to instruct the
+                    // application to send the selected Media to the caller.
+                    Log.d(PrepareMediaFeature.TAG, "Prepare operation was successful.")
+                    deferred.complete(PreparedMedia(preparedMedia = getPreparedMedia()))
+
+                    // Dispatch UI event to mark the end of preparing of media items
+                    scope.launch {
+                        val configuration = configurationManager.configuration.value
+                        events.dispatch(
+                            Event.LogPhotopickerUIEvent(
+                                FeatureToken.CORE.token,
+                                configuration.sessionId,
+                                configuration.callingPackageUid ?: -1,
+                                Telemetry.UiEvent.PICKER_PRELOADING_FINISHED,
+                            )
+                        )
+                    }
+                }
+            }
+
+            // If the prepare has a result, clean up the active running job.
+            if (prepareFailed || prepareCompleted) {
+                job?.cancel()
+                // Drop any pending heartbeats or transcoding items as the preparer job is being
+                // shutdown.
+                heartbeat.resetReplayCache()
+                itemsToTranscode.resetReplayCache()
+            }
+        }
+    }
+
+    /**
+     * Gets the set of media that have been prepared.
+     *
+     * Note that if the media is transcoded, its media URI will be updated to the transcoded URI .
+     *
+     * @return The set of media.
+     */
+    private suspend fun getPreparedMedia(): Set<Media> {
+        return mutex.withLock {
+            preparingItems
+                .asSequence()
+                .map { (media, status) ->
+                    if (status.transcodeStatus == TranscodeStatus.SUCCEED) {
+                        if (media is Media.Video) {
+                            // Replace media uri with transcoded uri if the media is transcoded.
+                            return@map media.copy(mediaUri = toTranscodedUri(media.mediaUri))
+                        } else {
+                            // Should not go here. Currently, only video can be transcoded.
+                            Log.e(PrepareMediaFeature.TAG, "Expected media object was not a video")
+                        }
+                    }
+                    media
+                }
+                .toSet()
+        }
+    }
+
+    /**
+     * Cancels any pending prepare operation by canceling the parent job.
+     *
+     * This method is safe to call if no prepare is currently active, it will have no effect.
+     *
+     * NOTE: This does not cancel any file open calls that have already started, but will prevent
+     * any additional file open calls from being started.
+     *
+     * @param deferred The [CompletableDeferred] for the job to cancel, if one exists.
+     */
+    @OptIn(ExperimentalCoroutinesApi::class)
+    fun cancelPrepare(deferred: CompletableDeferred<PrepareMediaResult>? = null) {
+        job?.let {
+            it.cancel()
+            Log.i(PrepareMediaFeature.TAG, "Prepare operation was cancelled.")
+            // Dispatch an event to log cancellation of media items preparing
+            scope.launch {
+                val configuration = configurationManager.configuration.value
+                events.dispatch(
+                    Event.LogPhotopickerUIEvent(
+                        FeatureToken.CORE.token,
+                        configuration.sessionId,
+                        configuration.callingPackageUid ?: -1,
+                        Telemetry.UiEvent.PICKER_PRELOADING_CANCELLED,
+                    )
+                )
+            }
+        }
+
+        // In the event of single selection mode, the selection needs to be cleared.
+        if (configurationManager.configuration.value.selectionLimit == 1) {
+            scope.launch { selection.clear() }
+        }
+
+        // If a deferred was passed, mark it as failed.
+        deferred?.complete(PrepareMediaFailed)
+
+        // Drop any pending heartbeats or transcoding items as the preparer job is being shutdown.
+        heartbeat.resetReplayCache()
+        itemsToTranscode.resetReplayCache()
+    }
+
+    /**
+     * Forces the [PreparerDialogData] flows back to their initialization state so that any dialog
+     * currently being shown will be hidden.
+     *
+     * NOTE: This does not cancel a prepare operation, so future progress may show a dialog.
+     */
+    fun hideAllDialogs() {
+        _dialogData.update { null }
+    }
+}
diff --git a/photopicker/src/com/android/photopicker/features/preparemedia/PrepareMediaFeature.kt b/photopicker/src/com/android/photopicker/features/preparemedia/PrepareMediaFeature.kt
new file mode 100644
index 000000000..3edde6c80
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/preparemedia/PrepareMediaFeature.kt
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.preparemedia
+
+import android.provider.MediaStore
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.Modifier
+import com.android.photopicker.core.configuration.PhotopickerConfiguration
+import com.android.photopicker.core.configuration.PhotopickerRuntimeEnv
+import com.android.photopicker.core.events.Event
+import com.android.photopicker.core.events.RegisteredEventClass
+import com.android.photopicker.core.features.FeatureManager
+import com.android.photopicker.core.features.FeatureRegistration
+import com.android.photopicker.core.features.FeatureToken
+import com.android.photopicker.core.features.Location
+import com.android.photopicker.core.features.LocationParams
+import com.android.photopicker.core.features.PhotopickerUiFeature
+import com.android.photopicker.core.features.PrefetchResultKey
+import com.android.photopicker.core.features.Priority
+import com.android.photopicker.core.navigation.Route
+import com.android.photopicker.features.cloudmedia.CloudMediaFeature
+import kotlinx.coroutines.Deferred
+
+/**
+ * Feature class for the Photopicker's media preparation implementation.
+ *
+ * This feature adds the preparer for preparing media content before the Photopicker session ends.
+ */
+class PrepareMediaFeature : PhotopickerUiFeature {
+    companion object Registration : FeatureRegistration {
+        override val TAG: String = "PrepareMediaFeature"
+
+        override fun isEnabled(
+            config: PhotopickerConfiguration,
+            deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>>,
+        ): Boolean {
+            with(config) {
+                if (runtimeEnv != PhotopickerRuntimeEnv.ACTIVITY) {
+                    return false
+                }
+
+                // Media Prepare is not available in permission mode.
+                if (action == MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP) {
+                    return false
+                }
+
+                val pickerTranscodingEnabled =
+                    flags.PICKER_TRANSCODING_ENABLED && callingPackageMediaCapabilities != null
+                return pickerTranscodingEnabled || CloudMediaFeature.isEnabled(this)
+            }
+        }
+
+        override fun build(featureManager: FeatureManager) = PrepareMediaFeature()
+    }
+
+    override val token = FeatureToken.MEDIA_PREPARE.token
+
+    override val eventsConsumed = setOf<RegisteredEventClass>()
+
+    override val eventsProduced = setOf(Event.LogPhotopickerUIEvent::class.java)
+
+    override fun registerLocations(): List<Pair<Location, Int>> {
+        return listOf(Pair(Location.MEDIA_PREPARER, Priority.HIGH.priority))
+    }
+
+    override fun registerNavigationRoutes(): Set<Route> {
+        return setOf()
+    }
+
+    @Composable
+    override fun compose(location: Location, modifier: Modifier, params: LocationParams) {
+        when (location) {
+            Location.MEDIA_PREPARER -> MediaPreparer(modifier, params)
+            else -> {}
+        }
+    }
+}
diff --git a/photopicker/src/com/android/photopicker/features/preparemedia/PrepareMediaResult.kt b/photopicker/src/com/android/photopicker/features/preparemedia/PrepareMediaResult.kt
new file mode 100644
index 000000000..9e53579d7
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/preparemedia/PrepareMediaResult.kt
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.preparemedia
+
+import com.android.photopicker.data.model.Media
+
+/** Interface that represents the result of media preparation. */
+sealed interface PrepareMediaResult {
+
+    /** Indicates that media preparation failed. */
+    data object PrepareMediaFailed : PrepareMediaResult
+
+    /**
+     * Represents a successful media preparation result, containing a set of prepared media objects.
+     *
+     * @property preparedMedia The set of prepared media objects.
+     */
+    data class PreparedMedia(val preparedMedia: Set<Media>) : PrepareMediaResult
+}
diff --git a/photopicker/src/com/android/photopicker/features/preparemedia/Transcoder.kt b/photopicker/src/com/android/photopicker/features/preparemedia/Transcoder.kt
new file mode 100644
index 000000000..f2f82e89e
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/preparemedia/Transcoder.kt
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.preparemedia
+
+import android.content.Context
+import android.media.ApplicationMediaCapabilities
+import android.net.Uri
+import com.android.photopicker.data.PICKER_SEGMENT
+import com.android.photopicker.data.PICKER_TRANSCODED_SEGMENT
+import com.android.photopicker.data.model.Media
+
+/** Provides methods to help video transcode. */
+interface Transcoder {
+
+    /**
+     * Checks if a transcode is required for the given video.
+     *
+     * @param context The context.
+     * @param mediaCapabilities The application media capabilities.
+     * @param video The video to check.
+     */
+    fun isTranscodeRequired(
+        context: Context,
+        mediaCapabilities: ApplicationMediaCapabilities?,
+        video: Media.Video,
+    ): Boolean
+
+    companion object {
+
+        /**
+         * Converts a picker provider URI to a transcoded URI.
+         *
+         * @param pickerUri The picker provider URI.
+         * @return The transcoded URI.
+         * @throws IllegalArgumentException If the picker provider URI is not valid.
+         */
+        fun toTranscodedUri(pickerUri: Uri): Uri {
+            val segments = pickerUri.pathSegments
+
+            require(segments.size == 5) { "Unexpected picker provider URI: $pickerUri" }
+
+            val builder = Uri.Builder().scheme(pickerUri.scheme).authority(pickerUri.authority)
+
+            for (i in segments.indices) {
+                if (PICKER_SEGMENT == segments[i]) {
+                    // Replace picker segment with picker transcoded segment.
+                    builder.appendPath(PICKER_TRANSCODED_SEGMENT)
+                } else {
+                    builder.appendPath(segments[i])
+                }
+            }
+
+            return builder.build()
+        }
+    }
+}
diff --git a/photopicker/src/com/android/photopicker/features/preparemedia/TranscoderImpl.kt b/photopicker/src/com/android/photopicker/features/preparemedia/TranscoderImpl.kt
new file mode 100644
index 000000000..547440037
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/preparemedia/TranscoderImpl.kt
@@ -0,0 +1,192 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.preparemedia
+
+import android.content.Context
+import android.media.ApplicationMediaCapabilities
+import android.media.MediaFeature.HdrType
+import android.media.MediaFormat
+import android.media.MediaFormat.COLOR_STANDARD_BT2020
+import android.media.MediaFormat.COLOR_STANDARD_BT709
+import android.media.MediaFormat.COLOR_TRANSFER_HLG
+import android.media.MediaFormat.COLOR_TRANSFER_ST2084
+import android.media.MediaFormat.MIMETYPE_VIDEO_DOLBY_VISION
+import android.media.MediaFormat.MIMETYPE_VIDEO_HEVC
+import android.util.Log
+import androidx.annotation.VisibleForTesting
+import androidx.media3.common.util.MediaFormatUtil.createFormatFromMediaFormat
+import androidx.media3.common.util.MediaFormatUtil.isVideoFormat
+import androidx.media3.exoplayer.MediaExtractorCompat
+import com.android.photopicker.data.model.Media
+
+/** A class that help video transcode. */
+class TranscoderImpl : Transcoder {
+
+    override fun isTranscodeRequired(
+        context: Context,
+        mediaCapabilities: ApplicationMediaCapabilities?,
+        video: Media.Video,
+    ): Boolean {
+        if (mediaCapabilities == null) {
+            return false
+        }
+
+        if (video.duration > DURATION_LIMIT_MS) {
+            Log.w(TAG, "Duration (${video.duration} ms) is over limit ($DURATION_LIMIT_MS).")
+            return false
+        }
+
+        // Check if any video tracks need to be transcoded.
+        val videoTrackMediaFormats = getVideoTrackMediaFormats(context, video)
+        for (mediaFormat in videoTrackMediaFormats) {
+            if (isTranscodeRequired(mediaFormat, mediaCapabilities)) {
+                return true
+            }
+        }
+
+        return false
+    }
+
+    /**
+     * Gets the [MediaFormat]s of the video tracks in the given video.
+     *
+     * @param context The context.
+     * @param video The video to check.
+     * @return The [MediaFormat]s of the video tracks in the given video.
+     */
+    private fun getVideoTrackMediaFormats(context: Context, video: Media.Video): List<MediaFormat> {
+        val mediaFormats = mutableListOf<MediaFormat>()
+
+        try {
+            val extractor = MediaExtractorCompat(context)
+            extractor.setDataSource(video.mediaUri, 0)
+
+            for (index in 0..<extractor.trackCount) {
+                val mediaFormat = extractor.getTrackFormat(index)
+                if (isVideoFormat(mediaFormat)) {
+                    mediaFormats.add(mediaFormat)
+                }
+            }
+        } catch (e: Exception) {
+            Log.e(TAG, "Failed to get MediaFormat of URI (${video.mediaUri}).", e)
+        }
+
+        return mediaFormats
+    }
+
+    /**
+     * Checks if a transcode is required for the given [MediaFormat].
+     *
+     * @param mediaFormat The [MediaFormat] to check.
+     * @return True if a transcode is required for the given [MediaFormat], false otherwise.
+     */
+    @VisibleForTesting
+    fun isTranscodeRequired(
+        mediaFormat: MediaFormat,
+        mediaCapabilities: ApplicationMediaCapabilities,
+    ): Boolean {
+        val format = createFormatFromMediaFormat(mediaFormat)
+        val mimeType = format.sampleMimeType
+        val colorStandard = format.colorInfo?.colorSpace
+        val colorTransfer = format.colorInfo?.colorTransfer
+
+        with(mediaCapabilities) {
+            if (isHevc(mimeType)) {
+                // Not to transcode when App does not support HEVC, as it is indistinguishable
+                // from the 'unset' case. Transcode for "HEVC -> AVC for SDR content" might not be
+                // what the caller intended.
+
+                if (isHlg10(colorStandard, colorTransfer) && !isHdrTypeSupported(HdrType.HLG)) {
+                    return true
+                }
+
+                if (
+                    isHdr10OrHdr10Plus(colorStandard, colorTransfer) &&
+                        (!isHdrTypeSupported(HdrType.HDR10) ||
+                            !isHdrTypeSupported(HdrType.HDR10_PLUS))
+                ) {
+                    return true
+                }
+            }
+
+            if (
+                isHdrDolbyVision(mimeType, colorStandard, colorTransfer) &&
+                    !isHdrTypeSupported(HdrType.DOLBY_VISION)
+            ) {
+                return true
+            }
+        }
+
+        return false
+    }
+
+    companion object {
+        private const val TAG = "Transcoder"
+        @VisibleForTesting const val DURATION_LIMIT_MS = 60_000L // 1 min
+
+        /**
+         * Checks if the mime type is HEVC.
+         *
+         * @param mimeType The mime type.
+         * @return True if the mime type is HEVC, false otherwise.
+         */
+        private fun isHevc(mimeType: String?): Boolean {
+            return MIMETYPE_VIDEO_HEVC.equals(mimeType, ignoreCase = true)
+        }
+
+        /**
+         * Checks if the given parameters represent HLG.
+         *
+         * @param colorStandard The color standard.
+         * @param colorTransfer The color transfer.
+         * @return True if the parameters represent HLG, false otherwise.
+         */
+        private fun isHlg10(colorStandard: Int?, colorTransfer: Int?): Boolean {
+            return (colorStandard == COLOR_STANDARD_BT709 ||
+                colorStandard == COLOR_STANDARD_BT2020) && colorTransfer == COLOR_TRANSFER_HLG
+        }
+
+        /**
+         * Checks if the given parameters represent HDR10 or HDR10+.
+         *
+         * @param colorStandard The color standard.
+         * @param colorTransfer The color transfer.
+         * @return True if the parameters represent HDR10 or HDR10+, false otherwise.
+         */
+        private fun isHdr10OrHdr10Plus(colorStandard: Int?, colorTransfer: Int?): Boolean {
+            return colorStandard == COLOR_STANDARD_BT2020 && colorTransfer == COLOR_TRANSFER_ST2084
+        }
+
+        /**
+         * Checks if the given parameters represent HDR Dolby Vision.
+         *
+         * @param mimeType The mime type.
+         * @param colorStandard The color standard.
+         * @param colorTransfer The color transfer.
+         * @return True if the parameters represent HDR Dolby Vision, false otherwise.
+         */
+        private fun isHdrDolbyVision(
+            mimeType: String?,
+            colorStandard: Int?,
+            colorTransfer: Int?,
+        ): Boolean {
+            return (MIMETYPE_VIDEO_DOLBY_VISION.equals(mimeType, ignoreCase = true)) &&
+                COLOR_STANDARD_BT2020 == colorStandard &&
+                (colorTransfer == COLOR_TRANSFER_ST2084 || colorTransfer == COLOR_TRANSFER_HLG)
+        }
+    }
+}
diff --git a/photopicker/src/com/android/photopicker/features/preview/Preview.kt b/photopicker/src/com/android/photopicker/features/preview/Preview.kt
index 083d9acf6..90b1b3e9b 100644
--- a/photopicker/src/com/android/photopicker/features/preview/Preview.kt
+++ b/photopicker/src/com/android/photopicker/features/preview/Preview.kt
@@ -62,6 +62,9 @@ import androidx.compose.ui.graphics.Color
 import androidx.compose.ui.graphics.vector.ImageVector
 import androidx.compose.ui.res.stringResource
 import androidx.compose.ui.res.vectorResource
+import androidx.compose.ui.semantics.contentDescription
+import androidx.compose.ui.semantics.onClick
+import androidx.compose.ui.semantics.semantics
 import androidx.compose.ui.unit.dp
 import androidx.lifecycle.compose.collectAsStateWithLifecycle
 import androidx.paging.compose.LazyPagingItems
@@ -88,6 +91,7 @@ import com.android.photopicker.core.theme.CustomAccentColorScheme
 import com.android.photopicker.core.theme.LocalFixedAccentColors
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.extensions.navigateToPreviewSelection
+import com.android.photopicker.util.LocalLocalizationHelper
 import kotlinx.coroutines.flow.StateFlow
 import kotlinx.coroutines.launch
 
@@ -101,7 +105,7 @@ import kotlinx.coroutines.launch
 @Composable
 fun PreviewSelection(
     viewModel: PreviewViewModel = obtainViewModel(),
-    previewItemFlow: StateFlow<Media?>? = null
+    previewItemFlow: StateFlow<Media?>? = null,
 ) {
     val currentSelection by LocalSelection.current.flow.collectAsStateWithLifecycle()
 
@@ -122,7 +126,7 @@ fun PreviewSelection(
                         .getPreviewMediaIncludingPreGrantedItems(
                             setOf(localMedia),
                             LocalPhotopickerConfiguration.current,
-                            /* isSingleItemPreview */ true
+                            /* isSingleItemPreview */ true,
                         )
                         .collectAsLazyPagingItems()
                 } else {
@@ -135,7 +139,7 @@ fun PreviewSelection(
                     .getPreviewMediaIncludingPreGrantedItems(
                         selectionSnapshot,
                         LocalPhotopickerConfiguration.current,
-                        /* isSingleItemPreview */ false
+                        /* isSingleItemPreview */ false,
                     )
                     .collectAsLazyPagingItems()
             }
@@ -157,7 +161,7 @@ fun PreviewSelection(
             ) {
                 Row(
                     modifier =
-                        Modifier.fillMaxWidth().padding(top = 16.dp, bottom = 4.dp, start = 8.dp),
+                        Modifier.fillMaxWidth().padding(top = 16.dp, bottom = 4.dp, start = 8.dp)
                 ) {
                     // back button
                     IconButton(onClick = { navController.popBackStack() }) {
@@ -184,7 +188,7 @@ fun PreviewSelection(
                             selection,
                             state,
                             snackbarHostState,
-                            /* singleItemPreview */ previewSingleItem
+                            /* singleItemPreview */ previewSingleItem,
                         )
 
                         // Only show the selection button if not in single select.
@@ -194,9 +198,13 @@ fun PreviewSelection(
                                 onClick = {
                                     val media = selection.get(state.currentPage)
                                     media?.let { viewModel.toggleInSelection(it, {}) }
-                                }
+                                },
                             ) {
                                 if (currentSelection.contains(selection.get(state.currentPage))) {
+                                    val deselectActionLabel =
+                                        stringResource(
+                                            R.string.photopicker_deselect_action_description
+                                        )
                                     Icon(
                                         ImageVector.vectorResource(
                                             R.drawable.photopicker_selected_media
@@ -208,10 +216,16 @@ fun PreviewSelection(
                                                 // space.
                                                 .background(
                                                     MaterialTheme.colorScheme.onPrimary,
-                                                    CircleShape
-                                                ),
+                                                    CircleShape,
+                                                )
+                                                .semantics {
+                                                    onClick(
+                                                        label = deselectActionLabel,
+                                                        action = null,
+                                                    )
+                                                },
                                         contentDescription =
-                                            stringResource(R.string.photopicker_media_item),
+                                            stringResource(R.string.photopicker_item_selected),
                                         tint =
                                             CustomAccentColorScheme.current
                                                 .getAccentColorIfDefinedOrElse(
@@ -219,11 +233,19 @@ fun PreviewSelection(
                                                 ),
                                     )
                                 } else {
+                                    val selectActionLabel =
+                                        stringResource(
+                                            R.string.photopicker_select_action_description
+                                        )
                                     Icon(
                                         Icons.Outlined.Circle,
                                         contentDescription =
-                                            stringResource(R.string.photopicker_item_selected),
-                                        tint = Color.White
+                                            stringResource(R.string.photopicker_item_not_selected),
+                                        tint = Color.White,
+                                        modifier =
+                                            Modifier.semantics {
+                                                onClick(label = selectActionLabel, action = null)
+                                            },
                                     )
                                 }
                             }
@@ -235,7 +257,7 @@ fun PreviewSelection(
                     // never an option.
                     SnackbarHost(
                         snackbarHostState,
-                        modifier = Modifier.align(Alignment.BottomCenter)
+                        modifier = Modifier.align(Alignment.BottomCenter),
                     )
                 }
 
@@ -244,7 +266,7 @@ fun PreviewSelection(
                     modifier =
                         Modifier.fillMaxWidth()
                             .padding(bottom = 48.dp, start = 4.dp, end = 16.dp, top = 12.dp),
-                    horizontalArrangement = Arrangement.SpaceBetween
+                    horizontalArrangement = Arrangement.SpaceBetween,
                 ) {
                     val config = LocalPhotopickerConfiguration.current
                     val strategy = remember(config) { determineSelectionStrategy(config) }
@@ -274,7 +296,7 @@ fun PreviewSelection(
                                         .getTextColorForAccentComponentsIfDefinedOrElse(
                                             /* fallback */ MaterialTheme.colorScheme.onPrimary
                                         ),
-                            )
+                            ),
                     ) {
                         Text(
                             text =
@@ -296,9 +318,8 @@ fun PreviewSelection(
 @Composable
 private fun SelectionButton(
     currentSelection: Set<Media>,
-    viewModel: PreviewViewModel = obtainViewModel()
+    viewModel: PreviewViewModel = obtainViewModel(),
 ) {
-
     TextButton(
         onClick = {
             if (currentSelection.size > 0 && viewModel.selectionSnapshot.value.size > 0) {
@@ -317,19 +338,25 @@ private fun SelectionButton(
                     // so it doesn't clash with the custom color.
                     if (CustomAccentColorScheme.current.isAccentColorDefined()) Color.White
                     else LocalFixedAccentColors.current.primaryFixedDim
-            )
+            ),
     ) {
+        val localizationHelper = LocalLocalizationHelper.current
         if (currentSelection.size > 0) {
             Icon(ImageVector.vectorResource(R.drawable.tab_close), contentDescription = null)
             Spacer(Modifier.size(8.dp))
-            Text(stringResource(R.string.photopicker_deselect_button_label, currentSelection.size))
+            Text(
+                stringResource(
+                    R.string.photopicker_deselect_button_label,
+                    localizationHelper.getLocalizedCount(currentSelection.size),
+                )
+            )
         } else {
             Icon(Icons.Filled.PhotoLibrary, contentDescription = null)
             Spacer(Modifier.size(8.dp))
             Text(
                 stringResource(
                     R.string.photopicker_select_button_label,
-                    viewModel.selectionSnapshot.value.size
+                    localizationHelper.getLocalizedCount(viewModel.selectionSnapshot.value.size),
                 )
             )
         }
@@ -355,10 +382,7 @@ private fun PreviewPager(
     // Preview session state to keep track if the video player's audio is muted.
     var audioIsMuted by remember { mutableStateOf(true) }
 
-    HorizontalPager(
-        state = state,
-        modifier = modifier,
-    ) { page ->
+    HorizontalPager(state = state, modifier = modifier) { page ->
         val media = selection.get(page)
         if (media != null) {
             when (media) {
@@ -369,7 +393,7 @@ private fun PreviewPager(
                         audioIsMuted,
                         { audioIsMuted = it },
                         snackbarHostState,
-                        singleItemPreview
+                        singleItemPreview,
                     )
             }
         }
@@ -403,7 +427,7 @@ private fun ImageUi(image: Media.Image, singleItemPreview: Boolean) {
                     Telemetry.PreviewModeEntry.LONG_PRESS,
                     previewItemCount = 1,
                     mediaType,
-                    Telemetry.VideoPlayBackInteractions.UNSET_VIDEO_PLAYBACK_INTERACTION
+                    Telemetry.VideoPlayBackInteractions.UNSET_VIDEO_PLAYBACK_INTERACTION,
                 )
             )
         }
@@ -447,7 +471,7 @@ fun PreviewSelectionButton(modifier: Modifier) {
                 color =
                     CustomAccentColorScheme.current.getAccentColorIfDefinedOrElse(
                         /* fallback */ MaterialTheme.colorScheme.primary
-                    )
+                    ),
             )
         }
     }
@@ -470,7 +494,7 @@ private suspend fun logPreviewSelectionButtonClicked(
             Telemetry.PreviewModeEntry.VIEW_SELECTED,
             previewItemCount,
             Telemetry.MediaType.UNSET_MEDIA_TYPE,
-            Telemetry.VideoPlayBackInteractions.UNSET_VIDEO_PLAYBACK_INTERACTION
+            Telemetry.VideoPlayBackInteractions.UNSET_VIDEO_PLAYBACK_INTERACTION,
         )
     )
 
@@ -480,7 +504,7 @@ private suspend fun logPreviewSelectionButtonClicked(
             FeatureToken.PREVIEW.token,
             configuration.sessionId,
             configuration.callingPackageUid ?: -1,
-            Telemetry.UiEvent.ENTER_PICKER_PREVIEW_MODE
+            Telemetry.UiEvent.ENTER_PICKER_PREVIEW_MODE,
         )
     )
 
@@ -489,7 +513,7 @@ private suspend fun logPreviewSelectionButtonClicked(
             FeatureToken.PREVIEW.token,
             configuration.sessionId,
             configuration.callingPackageUid ?: -1,
-            Telemetry.UiEvent.PICKER_CLICK_VIEW_SELECTED
+            Telemetry.UiEvent.PICKER_CLICK_VIEW_SELECTED,
         )
     )
 }
diff --git a/photopicker/src/com/android/photopicker/features/preview/PreviewFeature.kt b/photopicker/src/com/android/photopicker/features/preview/PreviewFeature.kt
index 14f331481..08c79d508 100644
--- a/photopicker/src/com/android/photopicker/features/preview/PreviewFeature.kt
+++ b/photopicker/src/com/android/photopicker/features/preview/PreviewFeature.kt
@@ -32,10 +32,12 @@ import com.android.photopicker.core.features.FeatureToken
 import com.android.photopicker.core.features.Location
 import com.android.photopicker.core.features.LocationParams
 import com.android.photopicker.core.features.PhotopickerUiFeature
+import com.android.photopicker.core.features.PrefetchResultKey
 import com.android.photopicker.core.features.Priority
 import com.android.photopicker.core.navigation.PhotopickerDestinations
 import com.android.photopicker.core.navigation.Route
 import com.android.photopicker.data.model.Media
+import kotlinx.coroutines.Deferred
 
 /**
  * Feature class for the Photopicker's media preview.
@@ -47,8 +49,10 @@ class PreviewFeature : PhotopickerUiFeature {
     companion object Registration : FeatureRegistration {
         override val TAG: String = "PhotopickerPreviewFeature"
 
-        override fun isEnabled(config: PhotopickerConfiguration) =
-            config.runtimeEnv != PhotopickerRuntimeEnv.EMBEDDED
+        override fun isEnabled(
+            config: PhotopickerConfiguration,
+            deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>>,
+        ) = config.runtimeEnv != PhotopickerRuntimeEnv.EMBEDDED
 
         override fun build(featureManager: FeatureManager) = PreviewFeature()
 
diff --git a/photopicker/src/com/android/photopicker/features/preview/video/VideoUi.kt b/photopicker/src/com/android/photopicker/features/preview/video/VideoUi.kt
index 547808dd8..6dd71d25a 100644
--- a/photopicker/src/com/android/photopicker/features/preview/video/VideoUi.kt
+++ b/photopicker/src/com/android/photopicker/features/preview/video/VideoUi.kt
@@ -101,7 +101,7 @@ private val MEASUREMENT_PLAYER_CONTROLS_PADDING_HORIZONTAL = 8.dp
 private val MEASUREMENT_PLAYER_CONTROLS_PADDING_VERTICAL = 12.dp
 
 /** Delay in milliseconds before the player controls are faded. */
-private val TIME_MS_PLAYER_CONTROLS_FADE_DELAY = 3000L
+private val TIME_MS_PLAYER_CONTROLS_FADE_DELAY = 5000L
 
 /**
  * Builds a remote video player surface and handles the interactions with the
@@ -167,7 +167,7 @@ fun VideoUi(
                     Telemetry.PreviewModeEntry.LONG_PRESS,
                     previewItemCount = 1,
                     Telemetry.MediaType.VIDEO,
-                    Telemetry.VideoPlayBackInteractions.MUTE
+                    Telemetry.VideoPlayBackInteractions.MUTE,
                 )
             )
         }
@@ -238,7 +238,7 @@ fun VideoUi(
                                         Telemetry.PreviewModeEntry.LONG_PRESS,
                                         previewItemCount = 1,
                                         Telemetry.MediaType.VIDEO,
-                                        Telemetry.VideoPlayBackInteractions.PLAY
+                                        Telemetry.VideoPlayBackInteractions.PLAY,
                                     )
                                 )
                             }
@@ -255,7 +255,7 @@ fun VideoUi(
                                         Telemetry.PreviewModeEntry.LONG_PRESS,
                                         previewItemCount = 1,
                                         Telemetry.MediaType.VIDEO,
-                                        Telemetry.VideoPlayBackInteractions.PAUSE
+                                        Telemetry.VideoPlayBackInteractions.PAUSE,
                                     )
                                 )
                             }
@@ -431,7 +431,7 @@ private fun VideoSurfaceView(
                                     holder: SurfaceHolder,
                                     format: Int,
                                     width: Int,
-                                    height: Int
+                                    height: Int,
                                 ) {
                                     onSurfaceChanged(format, width, height)
                                 }
@@ -491,7 +491,7 @@ private fun VideoPlayerControls(
         Box(
             Modifier.padding(
                 vertical = MEASUREMENT_PLAYER_CONTROLS_PADDING_VERTICAL,
-                horizontal = MEASUREMENT_PLAYER_CONTROLS_PADDING_HORIZONTAL
+                horizontal = MEASUREMENT_PLAYER_CONTROLS_PADDING_HORIZONTAL,
             )
         ) {
             // Play / Pause button (center of the screen)
@@ -687,18 +687,14 @@ private fun rememberAudioFocus(
 private fun producePlaybackInfo(
     surfaceId: Int,
     video: Media.Video,
-    viewModel: PreviewViewModel = obtainViewModel()
+    viewModel: PreviewViewModel = obtainViewModel(),
 ): State<PlaybackInfo> {
 
     return produceState<PlaybackInfo>(
         initialValue =
-            PlaybackInfo(
-                state = PlaybackState.UNKNOWN,
-                surfaceId,
-                authority = video.authority,
-            ),
+            PlaybackInfo(state = PlaybackState.UNKNOWN, surfaceId, authority = video.authority),
         surfaceId,
-        video
+        video,
     ) {
         viewModel.getPlaybackInfoForPlayer(surfaceId, video).collect { playbackInfo ->
             Log.d(PreviewFeature.TAG, "PlaybackState change received: $playbackInfo")
@@ -723,14 +719,10 @@ private fun producePlaybackInfo(
 private fun produceAspectRatio(
     surfaceId: Int,
     video: Media.Video,
-    viewModel: PreviewViewModel = obtainViewModel()
+    viewModel: PreviewViewModel = obtainViewModel(),
 ): State<Float?> {
 
-    return produceState<Float?>(
-        initialValue = null,
-        surfaceId,
-        video,
-    ) {
+    return produceState<Float?>(initialValue = null, surfaceId, video) {
         viewModel
             .getPlaybackInfoForPlayer(surfaceId, video)
             .filter { it.state == PlaybackState.MEDIA_SIZE_CHANGED }
diff --git a/photopicker/src/com/android/photopicker/features/privacyexplainer/PrivacyExplainerFeature.kt b/photopicker/src/com/android/photopicker/features/privacyexplainer/PrivacyExplainerFeature.kt
index d1bf5b0d5..cca305490 100644
--- a/photopicker/src/com/android/photopicker/features/privacyexplainer/PrivacyExplainerFeature.kt
+++ b/photopicker/src/com/android/photopicker/features/privacyexplainer/PrivacyExplainerFeature.kt
@@ -35,9 +35,11 @@ import com.android.photopicker.core.features.FeatureToken
 import com.android.photopicker.core.features.Location
 import com.android.photopicker.core.features.LocationParams
 import com.android.photopicker.core.features.PhotopickerUiFeature
+import com.android.photopicker.core.features.PrefetchResultKey
 import com.android.photopicker.core.features.Priority
 import com.android.photopicker.core.user.UserMonitor
 import com.android.photopicker.data.DataService
+import kotlinx.coroutines.Deferred
 
 /** Feature class for the Photopicker's Privacy explainer. */
 class PrivacyExplainerFeature : PhotopickerUiFeature {
@@ -45,7 +47,10 @@ class PrivacyExplainerFeature : PhotopickerUiFeature {
     companion object Registration : FeatureRegistration {
         override val TAG: String = "PhotopickerPrivacyExplainerFeature"
 
-        override fun isEnabled(config: PhotopickerConfiguration) = true
+        override fun isEnabled(
+            config: PhotopickerConfiguration,
+            deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>>,
+        ) = true
 
         override fun build(featureManager: FeatureManager) = PrivacyExplainerFeature()
     }
@@ -91,19 +96,19 @@ class PrivacyExplainerFeature : PhotopickerUiFeature {
                     @Composable
                     override fun buildMessage(): String {
                         val config = LocalPhotopickerConfiguration.current
+                        val genericAppName =
+                            stringResource(R.string.photopicker_privacy_explainer_generic_app_name)
 
                         return when (config.action) {
                             MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP ->
                                 stringResource(
                                     R.string.photopicker_privacy_explainer_permission_mode,
-                                    config.callingPackageLabel
-                                        ?: R.string.photopicker_privacy_explainer_generic_app_name
+                                    config.callingPackageLabel ?: genericAppName,
                                 )
                             else ->
                                 stringResource(
                                     R.string.photopicker_privacy_explainer,
-                                    config.callingPackageLabel
-                                        ?: R.string.photopicker_privacy_explainer_generic_app_name
+                                    config.callingPackageLabel ?: genericAppName,
                                 )
                         }
                     }
diff --git a/photopicker/src/com/android/photopicker/features/profileselector/ProfileSelector.kt b/photopicker/src/com/android/photopicker/features/profileselector/ProfileSelector.kt
index 736118ea9..2e6374fe4 100644
--- a/photopicker/src/com/android/photopicker/features/profileselector/ProfileSelector.kt
+++ b/photopicker/src/com/android/photopicker/features/profileselector/ProfileSelector.kt
@@ -36,6 +36,7 @@ import androidx.compose.material3.MaterialTheme
 import androidx.compose.material3.MenuDefaults
 import androidx.compose.material3.Surface
 import androidx.compose.material3.Text
+import androidx.compose.material3.contentColorFor
 import androidx.compose.runtime.Composable
 import androidx.compose.runtime.getValue
 import androidx.compose.runtime.mutableStateOf
@@ -46,6 +47,9 @@ import androidx.compose.ui.Modifier
 import androidx.compose.ui.graphics.vector.ImageVector
 import androidx.compose.ui.platform.LocalContext
 import androidx.compose.ui.res.stringResource
+import androidx.compose.ui.semantics.contentDescription
+import androidx.compose.ui.semantics.onClick
+import androidx.compose.ui.semantics.semantics
 import androidx.compose.ui.unit.dp
 import androidx.lifecycle.compose.collectAsStateWithLifecycle
 import com.android.photopicker.R
@@ -53,6 +57,7 @@ import com.android.photopicker.core.components.ElevationTokens
 import com.android.photopicker.core.configuration.LocalPhotopickerConfiguration
 import com.android.photopicker.core.configuration.PhotopickerRuntimeEnv
 import com.android.photopicker.core.obtainViewModel
+import com.android.photopicker.core.theme.CustomAccentColorScheme
 import com.android.photopicker.core.user.UserProfile
 
 /* The size of the current profile's icon in the selector button */
@@ -82,6 +87,20 @@ fun ProfileSelector(
         val context = LocalContext.current
         val currentProfile by viewModel.selectedProfile.collectAsStateWithLifecycle()
         var expanded by remember { mutableStateOf(false) }
+
+        // The button color should be neutral if and the calling app has provided a valid custom
+        // color. This will avoid unpleasant clashes with the custom color and what is in the
+        // default material theme. If no custom color is set, then the button should be
+        // primaryContainer to align with the theme's accents.
+        val customAccentColorScheme = CustomAccentColorScheme.current
+        val buttonContainerColor =
+            if (customAccentColorScheme.isAccentColorDefined())
+                MaterialTheme.colorScheme.surfaceContainerHigh
+            else MaterialTheme.colorScheme.primaryContainer
+        val currentProfileLabel = currentProfile.label ?: getLabelForProfile(currentProfile)
+        val profileSelectorDescription =
+            stringResource(R.string.photopicker_profile_switch_button_description)
+
         Box(modifier = modifier) {
             FilledTonalButton(
                 modifier = Modifier.align(Alignment.CenterStart),
@@ -89,25 +108,32 @@ fun ProfileSelector(
                 contentPadding = PaddingValues(start = 16.dp, end = 8.dp),
                 colors =
                     ButtonDefaults.filledTonalButtonColors(
-                        containerColor = MaterialTheme.colorScheme.primaryContainer,
-                        contentColor = MaterialTheme.colorScheme.primary,
+                        containerColor = buttonContainerColor,
+                        contentColor =
+                            if (customAccentColorScheme.isAccentColorDefined())
+                                MaterialTheme.colorScheme.primary
+                            else contentColorFor(buttonContainerColor),
                     ),
             ) {
                 currentProfile.icon?.let {
                     Icon(
                         it,
-                        contentDescription =
-                            stringResource(R.string.photopicker_profile_switch_button_description),
-                        modifier = Modifier.size(MEASUREMENT_PROFILE_ICON_SIZE),
+                        contentDescription = currentProfileLabel,
+                        modifier =
+                            Modifier.size(MEASUREMENT_PROFILE_ICON_SIZE).semantics {
+                                onClick(label = profileSelectorDescription, action = null)
+                            },
                     )
                 }
                     // If the profile doesn't have an icon drawable set, then
                     // generate one.
                     ?: Icon(
                         getIconForProfile(currentProfile),
-                        contentDescription =
-                            stringResource(R.string.photopicker_profile_switch_button_description),
-                        modifier = Modifier.size(MEASUREMENT_PROFILE_ICON_SIZE),
+                        contentDescription = currentProfileLabel,
+                        modifier =
+                            Modifier.size(MEASUREMENT_PROFILE_ICON_SIZE).semantics {
+                                onClick(label = profileSelectorDescription, action = null)
+                            },
                     )
 
                 Icon(
@@ -127,13 +153,32 @@ fun ProfileSelector(
             ) {
                 for (profile in allProfiles) {
 
+                    // The surface color should be neutral if the profile is selected
+                    // and the calling app has provided a valid custom color. This will
+                    // avoid unpleasant clashes with the custom color and what is in the
+                    // default material theme. If no custom color is set, then the surfaceColor
+                    // should be primaryContainer to align with the theme's accents.
+                    val surfaceColor =
+                        when {
+                            currentProfile == profile ->
+                                if (customAccentColorScheme.isAccentColorDefined())
+                                    MaterialTheme.colorScheme.surfaceContainerHighest
+                                else MaterialTheme.colorScheme.primaryContainer
+                            else -> MaterialTheme.colorScheme.surfaceContainerHigh
+                        }
+                    val surfaceContentColor = contentColorFor(surfaceColor)
+                    val selectedProfileDescription =
+                        stringResource(
+                            R.string.photopicker_selected_profile_description,
+                            currentProfileLabel,
+                        )
+                    val profileLabel = profile.label ?: getLabelForProfile(profile)
+
                     // The background color behind the text
                     Surface(
                         modifier = Modifier.widthIn(min = 200.dp),
-                        color =
-                            if (currentProfile == profile)
-                                MaterialTheme.colorScheme.primaryContainer
-                            else MaterialTheme.colorScheme.surfaceContainerHigh,
+                        color = surfaceColor,
+                        contentColor = surfaceContentColor,
                     ) {
                         DropdownMenuItem(
                             modifier = Modifier.fillMaxWidth(),
@@ -170,8 +215,16 @@ fun ProfileSelector(
                             },
                             text = {
                                 Text(
-                                    text = profile.label ?: getLabelForProfile(profile),
+                                    text = profileLabel,
                                     style = MaterialTheme.typography.bodyLarge,
+                                    modifier =
+                                        Modifier.semantics {
+                                            contentDescription =
+                                                when (currentProfile == profile) {
+                                                    true -> selectedProfileDescription
+                                                    false -> profileLabel
+                                                }
+                                        },
                                 )
                             },
                             leadingIcon = {
@@ -181,7 +234,7 @@ fun ProfileSelector(
                                         contentDescription = null,
                                         tint =
                                             when (profile.enabled) {
-                                                true -> MaterialTheme.colorScheme.primary
+                                                true -> surfaceContentColor
                                                 false ->
                                                     MenuDefaults.itemColors()
                                                         .disabledLeadingIconColor
@@ -195,7 +248,7 @@ fun ProfileSelector(
                                         contentDescription = null,
                                         tint =
                                             when (profile.enabled) {
-                                                true -> MaterialTheme.colorScheme.primary
+                                                true -> surfaceContentColor
                                                 false ->
                                                     MenuDefaults.itemColors()
                                                         .disabledLeadingIconColor
diff --git a/photopicker/src/com/android/photopicker/features/profileselector/ProfileSelectorFeature.kt b/photopicker/src/com/android/photopicker/features/profileselector/ProfileSelectorFeature.kt
index 30e6ca001..7e28c1065 100644
--- a/photopicker/src/com/android/photopicker/features/profileselector/ProfileSelectorFeature.kt
+++ b/photopicker/src/com/android/photopicker/features/profileselector/ProfileSelectorFeature.kt
@@ -35,10 +35,12 @@ import com.android.photopicker.core.features.FeatureToken
 import com.android.photopicker.core.features.Location
 import com.android.photopicker.core.features.LocationParams
 import com.android.photopicker.core.features.PhotopickerUiFeature
+import com.android.photopicker.core.features.PrefetchResultKey
 import com.android.photopicker.core.features.Priority
 import com.android.photopicker.core.user.UserMonitor
 import com.android.photopicker.core.user.UserProfile
 import com.android.photopicker.data.DataService
+import kotlinx.coroutines.Deferred
 import kotlinx.coroutines.runBlocking
 
 /** Feature class for the Photopicker's Profile Selector button. */
@@ -47,7 +49,10 @@ class ProfileSelectorFeature : PhotopickerUiFeature {
     companion object Registration : FeatureRegistration {
         override val TAG: String = "PhotopickerProfileSelectorFeature"
 
-        override fun isEnabled(config: PhotopickerConfiguration): Boolean {
+        override fun isEnabled(
+            config: PhotopickerConfiguration,
+            deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>>,
+        ): Boolean {
 
             // Profile switching is not permitted in permission mode.
             if (MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP.equals(config.action)) {
@@ -66,10 +71,7 @@ class ProfileSelectorFeature : PhotopickerUiFeature {
 
     override val token = FeatureToken.PROFILE_SELECTOR.token
 
-    override val ownedBanners: Set<BannerDefinitions> =
-        setOf(
-            BannerDefinitions.SWITCH_PROFILE,
-        )
+    override val ownedBanners: Set<BannerDefinitions> = setOf(BannerDefinitions.SWITCH_PROFILE)
 
     override suspend fun getBannerPriority(
         banner: BannerDefinitions,
@@ -162,11 +164,7 @@ class ProfileSelectorFeature : PhotopickerUiFeature {
         setOf<RegisteredEventClass>(Event.LogPhotopickerUIEvent::class.java)
 
     @Composable
-    override fun compose(
-        location: Location,
-        modifier: Modifier,
-        params: LocationParams,
-    ) {
+    override fun compose(location: Location, modifier: Modifier, params: LocationParams) {
         when (location) {
             Location.PROFILE_SELECTOR -> ProfileSelector(modifier)
             else -> {}
diff --git a/photopicker/src/com/android/photopicker/features/search/Search.kt b/photopicker/src/com/android/photopicker/features/search/Search.kt
index 621af02b3..400d13c83 100644
--- a/photopicker/src/com/android/photopicker/features/search/Search.kt
+++ b/photopicker/src/com/android/photopicker/features/search/Search.kt
@@ -16,50 +16,208 @@
 
 package com.android.photopicker.features.search
 
+import android.util.Log
+import androidx.compose.foundation.background
+import androidx.compose.foundation.clickable
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Box
 import androidx.compose.foundation.layout.PaddingValues
+import androidx.compose.foundation.layout.Row
+import androidx.compose.foundation.layout.Spacer
+import androidx.compose.foundation.layout.fillMaxSize
 import androidx.compose.foundation.layout.fillMaxWidth
 import androidx.compose.foundation.layout.height
 import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.size
+import androidx.compose.foundation.lazy.LazyColumn
+import androidx.compose.foundation.lazy.grid.rememberLazyGridState
+import androidx.compose.foundation.lazy.items
+import androidx.compose.foundation.shape.CircleShape
+import androidx.compose.foundation.shape.RoundedCornerShape
 import androidx.compose.material.icons.Icons
 import androidx.compose.material.icons.automirrored.filled.ArrowBack
-import androidx.compose.material.icons.filled.Search
+import androidx.compose.material.icons.filled.Today
+import androidx.compose.material.icons.outlined.HideImage
+import androidx.compose.material.icons.outlined.History
+import androidx.compose.material.icons.outlined.LocationOn
+import androidx.compose.material.icons.outlined.PhotoAlbum
+import androidx.compose.material.icons.outlined.PlayCircle
+import androidx.compose.material.icons.outlined.Search
+import androidx.compose.material.icons.outlined.Smartphone
+import androidx.compose.material.icons.outlined.StarBorder
+import androidx.compose.material3.Card
+import androidx.compose.material3.CardDefaults
+import androidx.compose.material3.CircularProgressIndicator
 import androidx.compose.material3.ExperimentalMaterial3Api
 import androidx.compose.material3.Icon
 import androidx.compose.material3.IconButton
 import androidx.compose.material3.MaterialTheme
+import androidx.compose.material3.PlainTooltip
 import androidx.compose.material3.SearchBar
 import androidx.compose.material3.SearchBarDefaults
 import androidx.compose.material3.Text
 import androidx.compose.material3.TextFieldDefaults
+import androidx.compose.material3.TooltipBox
+import androidx.compose.material3.rememberTooltipState
+import androidx.compose.material3.windowsizeclass.WindowWidthSizeClass
 import androidx.compose.runtime.Composable
+import androidx.compose.runtime.LaunchedEffect
 import androidx.compose.runtime.getValue
 import androidx.compose.runtime.mutableStateOf
 import androidx.compose.runtime.remember
+import androidx.compose.runtime.rememberCoroutineScope
+import androidx.compose.runtime.saveable.rememberSaveable
 import androidx.compose.runtime.setValue
+import androidx.compose.ui.Alignment
 import androidx.compose.ui.Modifier
+import androidx.compose.ui.draw.clip
+import androidx.compose.ui.graphics.ImageBitmap
+import androidx.compose.ui.graphics.Shape
+import androidx.compose.ui.graphics.vector.ImageVector
+import androidx.compose.ui.platform.LocalConfiguration
+import androidx.compose.ui.platform.LocalFocusManager
 import androidx.compose.ui.res.stringResource
+import androidx.compose.ui.unit.IntOffset
+import androidx.compose.ui.unit.IntRect
+import androidx.compose.ui.unit.IntSize
+import androidx.compose.ui.unit.LayoutDirection
 import androidx.compose.ui.unit.dp
+import androidx.compose.ui.window.PopupPositionProvider
+import androidx.lifecycle.compose.collectAsStateWithLifecycle
+import androidx.paging.LoadState
+import androidx.paging.PagingData
+import androidx.paging.compose.collectAsLazyPagingItems
 import com.android.photopicker.R
+import com.android.photopicker.core.components.EmptyState
+import com.android.photopicker.core.components.MediaGridItem
+import com.android.photopicker.core.components.mediaGrid
+import com.android.photopicker.core.configuration.LocalPhotopickerConfiguration
+import com.android.photopicker.core.events.Event
+import com.android.photopicker.core.events.LocalEvents
+import com.android.photopicker.core.events.Telemetry
+import com.android.photopicker.core.features.FeatureToken
+import com.android.photopicker.core.features.LocalFeatureManager
+import com.android.photopicker.core.features.LocationParams
+import com.android.photopicker.core.navigation.LocalNavController
+import com.android.photopicker.core.obtainViewModel
+import com.android.photopicker.core.selection.LocalSelection
+import com.android.photopicker.core.theme.LocalWindowSizeClass
+import com.android.photopicker.extensions.navigateToPreviewMedia
+import com.android.photopicker.features.preview.PreviewFeature
+import com.android.photopicker.features.search.model.SearchEnabledState
+import com.android.photopicker.features.search.model.SearchSuggestion
+import com.android.photopicker.features.search.model.SearchSuggestionType
+import com.android.photopicker.util.rememberBitmapFromUri
+import kotlinx.coroutines.delay
+import kotlinx.coroutines.flow.Flow
+import kotlinx.coroutines.flow.flow
+import kotlinx.coroutines.launch
+import kotlinx.coroutines.withContext
 
 private val MEASUREMENT_SEARCH_BAR_HEIGHT = 56.dp
 private val MEASUREMENT_SEARCH_BAR_PADDING =
     PaddingValues(start = 8.dp, end = 8.dp, top = 8.dp, bottom = 16.dp)
 
+private val FETCH_SUGGESTION_DEBOUNCE_DELAY = 300L // in milliseconds
+
+private val SUGGESTION_TITLE_PADDING =
+    PaddingValues(start = 32.dp, end = 32.dp, top = 12.dp, bottom = 12.dp)
+private val MEASUREMENT_LARGE_PADDING = 16.dp
+private val MEASUREMENT_ITEM_GAP_PADDING = 12.dp
+private val MEASUREMENT_MEDIUM_PADDING = 8.dp
+private val MEASUREMENT_SMALL_PADDING = 4.dp
+private val MEASUREMENT_EXTRA_SMALL_PADDING = 2.dp
+
+private val MEASUREMENT_SUGGESTION_ITEM_PADDING =
+    PaddingValues(start = 16.dp, end = 16.dp, top = 12.dp, bottom = 12.dp)
+
+private val CARD_CORNER_RADIUS_LARGE = 28.dp
+private val CARD_CORNER_RADIUS_SMALL = 4.dp
+private val TOP_SUGGESTION_CARD_SHAPE =
+    RoundedCornerShape(
+        topStart = CARD_CORNER_RADIUS_LARGE,
+        topEnd = CARD_CORNER_RADIUS_LARGE,
+        bottomStart = CARD_CORNER_RADIUS_SMALL,
+        bottomEnd = CARD_CORNER_RADIUS_SMALL,
+    )
+private val BOTTOM_SUGGESTION_CARD_SHAPE =
+    RoundedCornerShape(
+        topStart = CARD_CORNER_RADIUS_SMALL,
+        topEnd = CARD_CORNER_RADIUS_SMALL,
+        bottomStart = CARD_CORNER_RADIUS_LARGE,
+        bottomEnd = CARD_CORNER_RADIUS_LARGE,
+    )
+private val MIDDLE_SUGGESTION_CARD_SHAPE = RoundedCornerShape(CARD_CORNER_RADIUS_SMALL)
+private val SINGLE_SUGGESTION_CARD_SHAPE = RoundedCornerShape(CARD_CORNER_RADIUS_LARGE)
+
+private val MEASUREMENT_FACE_SUGGESTION_ICON = 48.dp
+private val MEASUREMENT_FACE_RESULT_ICON = 32.dp
+private val MEASUREMENT_OTHER_ICON = 40.dp
+
 /** A composable function that displays a SearchBar. */
 @Composable
-@OptIn(ExperimentalMaterial3Api::class)
-fun Search(modifier: Modifier = Modifier) {
-    val searchTerm = remember { mutableStateOf("") }
-    val focused = remember { mutableStateOf(false) }
+fun Search(
+    modifier: Modifier = Modifier,
+    params: LocationParams,
+    viewModel: SearchViewModel = obtainViewModel(),
+) {
+    val searchEnabled by viewModel.searchEnabled.collectAsStateWithLifecycle()
+    when {
+        searchEnabled == SearchEnabledState.ENABLED -> {
+            SearchBarEnabled(params, viewModel, modifier)
+        }
+        else -> {
+            SearchBarWithTooltip(modifier)
+        }
+    }
+}
 
+/**
+ * This composable displays an enabled search bar that allows users to enter search queries.
+ *
+ * @param params A [LocationParams] relevant to the search functionality.
+ * @param viewModel The `SearchViewModel` providing the search logic and state.
+ * @param modifier The modifier to be applied to the composable.
+ */
+@Composable
+@OptIn(ExperimentalMaterial3Api::class)
+fun SearchBarEnabled(params: LocationParams, viewModel: SearchViewModel, modifier: Modifier) {
+    val focused = rememberSaveable { mutableStateOf(false) }
+    val searchTerm = rememberSaveable { mutableStateOf("") }
+    val searchState by viewModel.searchState.collectAsStateWithLifecycle()
+    val suggestionLists by viewModel.suggestionLists.collectAsStateWithLifecycle()
+    val scope = rememberCoroutineScope()
+    val events = LocalEvents.current
+    val configuration = LocalPhotopickerConfiguration.current
     SearchBar(
         inputField = {
-            SearchInput(
-                searchQuery = searchTerm.value,
+            SearchInputContent(
+                viewModel = viewModel,
                 focused = focused.value,
-                onSearchQueryChanged = { searchTerm.value = it },
-                onFocused = { focused.value = it },
-                modifier
+                searchTerm = searchTerm.value,
+                onFocused = {
+                    if (it) {
+                        val clickAction = params as? LocationParams.WithClickAction
+                        clickAction?.onClick()
+                        scope.launch {
+                            events.dispatch(
+                                Event.LogPhotopickerUIEvent(
+                                    FeatureToken.SEARCH.token,
+                                    configuration.sessionId,
+                                    configuration.callingPackageUid ?: -1,
+                                    Telemetry.UiEvent.ENTER_PICKER_SEARCH,
+                                )
+                            )
+                        }
+                    }
+                    focused.value = it
+                },
+                onSearchQueryChanged = {
+                    searchTerm.value = it
+                    viewModel.clearSearch()
+                },
+                searchState = searchState,
+                modifier,
             )
         },
         expanded = focused.value,
@@ -75,8 +233,172 @@ fun Search(modifier: Modifier = Modifier) {
             } else {
                 modifier.padding(MEASUREMENT_SEARCH_BAR_PADDING)
             },
-        content = {},
+        content = {
+            when (searchState) {
+                is SearchState.Active -> {
+                    val searchResults =
+                        remember(searchState) {
+                            try {
+                                viewModel.getSearchResults()
+                            } catch (e: IllegalStateException) {
+                                // If search state is inactive fetching search results would throw
+                                // an IllegalStateException but this is not expected to ever happen
+                                // as search results will be called only for active search states.
+                                Log.e(
+                                    SearchFeature.TAG,
+                                    " Cannot show search results in inactive search state",
+                                    e,
+                                )
+                                flow { PagingData.from(emptyList()) }
+                            }
+                        }
+                    ResultMediaGrid(searchResults)
+                }
+
+                SearchState.Inactive -> {
+                    if (suggestionLists.totalSuggestions > 0) {
+                        val focusManager = LocalFocusManager.current
+                        ShowSuggestions(
+                            suggestionLists = suggestionLists,
+                            isZeroSearchState = searchTerm.value.isEmpty(),
+                            onSuggestionClick = { suggestion ->
+                                focusManager.clearFocus()
+                                searchTerm.value = suggestion.displayText ?: ""
+                                viewModel.performSearch(suggestion = suggestion)
+                            },
+                            modifier = modifier,
+                        )
+                    }
+                }
+            }
+        },
     )
+    LaunchedEffect(key1 = searchTerm.value) { // Trigger when searchTerm changes
+        delay(FETCH_SUGGESTION_DEBOUNCE_DELAY)
+        viewModel.fetchSuggestions(searchTerm.value)
+    }
+}
+
+/**
+ * This composable displays a disabled search bar with a tooltip that appears when the user clicks
+ * over it.
+ *
+ * @param modifier The modifier to be applied to the composable.
+ */
+@Composable
+@OptIn(ExperimentalMaterial3Api::class)
+fun SearchBarWithTooltip(modifier: Modifier) {
+    val tooltipState = rememberTooltipState()
+    val scope = rememberCoroutineScope()
+    TooltipBox(
+        positionProvider =
+            remember {
+                object : PopupPositionProvider {
+                    override fun calculatePosition(
+                        anchorBounds: IntRect,
+                        windowSize: IntSize,
+                        layoutDirection: LayoutDirection,
+                        popupContentSize: IntSize,
+                    ): IntOffset {
+                        return IntOffset(
+                            x =
+                                anchorBounds.left +
+                                    (anchorBounds.width - popupContentSize.width) / 2,
+                            y = anchorBounds.bottom - popupContentSize.height,
+                        )
+                    }
+                }
+            },
+        tooltip = {
+            PlainTooltip { Text(text = stringResource(R.string.photopicker_search_disabled_hint)) }
+        },
+        state = tooltipState,
+    ) {
+        SearchBar(
+            inputField = {
+                SearchBarDefaults.InputField(
+                    query = "",
+                    enabled = false,
+                    placeholder = { SearchBarPlaceHolder(false) },
+                    colors = TextFieldDefaults.colors(MaterialTheme.colorScheme.surface),
+                    onQueryChange = {},
+                    onSearch = {},
+                    expanded = false,
+                    onExpandedChange = {},
+                    leadingIcon = { SearchBarIcon(false, {}, {}, searchDisabled = true) },
+                    modifier =
+                        modifier.height(MEASUREMENT_SEARCH_BAR_HEIGHT).clickable {
+                            scope.launch { tooltipState.show() }
+                        },
+                )
+            },
+            expanded = false,
+            onExpandedChange = {},
+            colors =
+                SearchBarDefaults.colors(
+                    containerColor = MaterialTheme.colorScheme.surfaceContainer,
+                    dividerColor = MaterialTheme.colorScheme.outlineVariant,
+                ),
+            modifier = modifier.padding(MEASUREMENT_SEARCH_BAR_PADDING),
+            content = {},
+        )
+    }
+}
+
+/**
+ * Renders the appropriate search input field based on the current search state.
+ *
+ * This composable function determines which type of search input to display depending on whether
+ * the user has selected a "FACE" type suggestion or is performing a regular text search.
+ *
+ * @param viewModel The `SearchViewModel` providing the search logic and state.
+ * @param focused A boolean value indicating if the search input field is currently focused.
+ * @param searchTerm Current text entered in search input field.
+ * @param onFocused A callback function to be invoked when the focus state of the search field
+ *   changes.
+ * @param onSearchQueryChanged A callback function to be invoked when the search query text changes.
+ * @param searchState The current state of the search, determining the input field type.
+ * @param modifier A Modifier that can be applied to the SearchInputContent composable.
+ */
+@Composable
+@OptIn(ExperimentalMaterial3Api::class)
+fun SearchInputContent(
+    viewModel: SearchViewModel,
+    focused: Boolean,
+    searchTerm: String,
+    onFocused: (Boolean) -> Unit,
+    onSearchQueryChanged: (String) -> Unit,
+    searchState: SearchState,
+    modifier: Modifier,
+) {
+    when (
+        searchState is SearchState.Active.SuggestionSearch &&
+            searchState.suggestion.type == SearchSuggestionType.FACE
+    ) {
+        true -> {
+            ShowSearchInputWithCustomIcon(
+                searchState.suggestion,
+                onFocused,
+                onSearchQueryChanged,
+                viewModel,
+            )
+        }
+        else -> {
+            SearchInput(
+                searchQuery = searchTerm,
+                focused = focused,
+                onSearchQueryChanged = { onSearchQueryChanged(it) },
+                onFocused = {
+                    onFocused(it)
+                    if (it) {
+                        viewModel.clearSearch()
+                    }
+                },
+                onSearch = { viewModel.performSearch(query = searchTerm) },
+                modifier = modifier,
+            )
+        }
+    }
 }
 
 /**
@@ -95,6 +417,7 @@ fun Search(modifier: Modifier = Modifier) {
  *   changes.
  *     * This function receives a boolean value indicating the new focus state.
  *
+ * @param onSearch A callback function to be invoked when a text is searched.
  * @param modifier A Modifier that can be applied to the SearchInput composable to customize its
  *     * appearance and behavior.
  */
@@ -105,25 +428,29 @@ private fun SearchInput(
     focused: Boolean,
     onSearchQueryChanged: (String) -> Unit,
     onFocused: (Boolean) -> Unit,
-    modifier: Modifier
+    onSearch: () -> Unit,
+    modifier: Modifier,
 ) {
+    val focusManager = LocalFocusManager.current
     SearchBarDefaults.InputField(
         query = searchQuery,
-        placeholder = {
-            val placeholderText =
-                when (focused) {
-                    true -> stringResource(R.string.photopicker_searchView_placeholder_text)
-                    false -> stringResource(R.string.photopicker_search_placeholder_text)
-                }
-            Text(text = placeholderText, style = MaterialTheme.typography.bodyLarge)
-        },
+        placeholder = { SearchBarPlaceHolder(focused) },
         colors =
             TextFieldDefaults.colors(
-                unfocusedContainerColor = MaterialTheme.colorScheme.surface,
+                unfocusedContainerColor =
+                    if (focused) {
+                        MaterialTheme.colorScheme.surfaceContainer
+                    } else {
+                        MaterialTheme.colorScheme.surface
+                    },
                 focusedContainerColor = MaterialTheme.colorScheme.surfaceContainer,
             ),
         onQueryChange = onSearchQueryChanged,
-        onSearch = { onFocused(true) },
+        onSearch = {
+            onFocused(true)
+            focusManager.clearFocus()
+            onSearch()
+        },
         expanded = focused,
         onExpandedChange = onFocused,
         leadingIcon = { SearchBarIcon(focused, onFocused, onSearchQueryChanged) },
@@ -131,6 +458,55 @@ private fun SearchInput(
     )
 }
 
+/**
+ * Composable that shows an Icon and Title if present in Search Results page on selecting Face type
+ * from suggestions list.
+ */
+
+/**
+ * Composable that displays a search input field with a custom icon and text.
+ *
+ * This composable function renders a search input field in a row that includes:
+ * - A leading icon
+ * - A custom icon representing a search suggestion.
+ * - Text displaying the suggestion's display text.
+ *
+ * @param suggestion The `SearchSuggestion` object to be displayed.
+ * @param onFocused A callback function to be invoked when the focus state of the search field
+ *   changes.
+ * @param onSearchQueryChanged A callback function to be invoked when the search query text changes.
+ * @param viewModel The `SearchViewModel` providing the search logic and state.
+ */
+@Composable
+fun ShowSearchInputWithCustomIcon(
+    suggestion: SearchSuggestion,
+    onFocused: (Boolean) -> Unit,
+    onSearchQueryChanged: (String) -> Unit,
+    viewModel: SearchViewModel = obtainViewModel(),
+) {
+    Row(
+        modifier = Modifier.padding(MEASUREMENT_SMALL_PADDING).fillMaxWidth(),
+        verticalAlignment = Alignment.CenterVertically,
+    ) {
+        SearchBarIcon(
+            true,
+            onFocused = onFocused,
+            onSearchQueryChanged = { onSearchQueryChanged("") },
+        )
+        val imageBitmap =
+            suggestion.iconUri?.let { rememberBitmapFromUri(it, viewModel.backgroundDispatcher) }
+        ShowSuggestionIcon(
+            suggestion,
+            imageBitmap,
+            modifier = Modifier.clip(CircleShape).size(MEASUREMENT_FACE_RESULT_ICON),
+        )
+        Text(
+            text = suggestion.displayText ?: "",
+            modifier = Modifier.padding(start = MEASUREMENT_MEDIUM_PADDING),
+        )
+    }
+}
+
 /**
  * A composable function that displays the leading icon in a SearchBar. The icon changes based on
  * the focused state of the SearchBar.
@@ -144,12 +520,15 @@ private fun SearchInput(
  * @param onSearchQueryChanged A callback function that is invoked when the search query text
  *   changes.
  *     * This function receives the updated search query as a parameter.
+ *
+ * @param searchDisabled A boolean value indicating whether the search bar is disabled.
  */
 @Composable
 private fun SearchBarIcon(
     focused: Boolean,
     onFocused: (Boolean) -> Unit,
-    onSearchQueryChanged: (String) -> Unit
+    onSearchQueryChanged: (String) -> Unit,
+    searchDisabled: Boolean = false,
 ) {
     if (focused) {
         IconButton(
@@ -160,13 +539,511 @@ private fun SearchBarIcon(
         ) {
             Icon(
                 imageVector = Icons.AutoMirrored.Filled.ArrowBack,
-                contentDescription = stringResource(R.string.photopicker_back_option)
+                contentDescription = stringResource(R.string.photopicker_back_option),
             )
         }
     } else {
-        Icon(
-            imageVector = Icons.Default.Search,
-            contentDescription = stringResource(R.string.photopicker_search_placeholder_text)
-        )
+        val description =
+            when (searchDisabled) {
+                true -> {
+                    stringResource(R.string.photopicker_search_disabled_hint)
+                }
+                else -> {
+                    stringResource(R.string.photopicker_search_placeholder_text)
+                }
+            }
+        Icon(imageVector = Icons.Outlined.Search, contentDescription = description)
+    }
+}
+
+/**
+ * Composable function that displays a placeholder text in search bar.
+ *
+ * The placeholder text changes depending on whether the search bar is focused or not. When focused,
+ * it also considers the allowed MIME types from the `LocalPhotopickerConfiguration` to display a
+ * more specific placeholder.
+ *
+ * @param focused Boolean value indicating whether the search bar is currently focused.
+ */
+@Composable
+private fun SearchBarPlaceHolder(focused: Boolean) {
+    val placeholderText =
+        when (focused) {
+            true -> {
+                if (LocalPhotopickerConfiguration.current.hasOnlyVideoMimeTypes()) {
+                    stringResource(R.string.photopicker_search_videos_placeholder_text)
+                } else {
+                    stringResource(R.string.photopicker_search_photos_placeholder_text)
+                }
+            }
+            false -> stringResource(R.string.photopicker_search_placeholder_text)
+        }
+    Text(text = placeholderText, style = MaterialTheme.typography.bodyLarge)
+}
+
+/**
+ * This composable displays an empty state screen when there are no results.
+ *
+ * @param modifier Modifier used to adjust the layout or styling of the composable.
+ */
+@Composable
+fun EmptySearchResult(modifier: Modifier = Modifier) {
+    val localConfig = LocalConfiguration.current
+    val emptyStatePadding = remember(localConfig) { (localConfig.screenHeightDp * .20).dp }
+
+    EmptyState(
+        modifier = modifier.fillMaxWidth().padding(top = emptyStatePadding),
+        icon = Icons.Outlined.HideImage,
+        title = stringResource(R.string.photopicker_search_result_empty_state_title),
+        body = stringResource(R.string.photopicker_search_result_empty_state_body),
+    )
+}
+
+/**
+ * Composable function that shows suggestion in the search view.
+ *
+ * @param suggestionLists A `SuggestionLists` object containing the search suggestions to display.
+ * @param isZeroSearchState A boolean value indicating if the search query is empty.
+ * @param modifier A Modifier that can be applied to the suggestions list.
+ * @param onSuggestionClick A callback function to be invoked when a suggestion is clicked.
+ */
+@Composable
+private fun ShowSuggestions(
+    suggestionLists: SuggestionLists,
+    isZeroSearchState: Boolean,
+    modifier: Modifier,
+    onSuggestionClick: (SearchSuggestion) -> Unit,
+) {
+    val historySuggestions = suggestionLists.history
+    val faceSuggestions = suggestionLists.face
+    val otherSuggestions = suggestionLists.other
+    Box(modifier = modifier.padding(MEASUREMENT_LARGE_PADDING)) {
+        LazyColumn {
+            item { Spacer(modifier = Modifier.height(MEASUREMENT_MEDIUM_PADDING)) }
+            items(historySuggestions.take(SearchViewModel.HISTORY_SUGGESTION_MAX_LIMIT)) {
+                suggestion ->
+                val size =
+                    minOf(historySuggestions.size, SearchViewModel.HISTORY_SUGGESTION_MAX_LIMIT)
+                ShowSuggestionCard(
+                    suggestion,
+                    historySuggestions.indexOf(suggestion),
+                    size,
+                    faceSuggestions.size,
+                    otherSuggestions.size,
+                    onSuggestionClick,
+                )
+            }
+            item {
+                Text(
+                    text = stringResource(R.string.photopicker_search_suggestions_text),
+                    modifier = Modifier.padding(SUGGESTION_TITLE_PADDING),
+                )
+            }
+            if (faceSuggestions.size > 0) {
+                item {
+                    ShowFaceSuggestions(faceSuggestions, onSuggestionClick, otherSuggestions.size)
+                }
+            }
+            items(otherSuggestions.take(SearchViewModel.ALL_SUGGESTION_MAX_LIMIT)) { suggestion ->
+                val size = minOf(otherSuggestions.size, SearchViewModel.ALL_SUGGESTION_MAX_LIMIT)
+                ShowSuggestionCard(
+                    suggestion,
+                    otherSuggestions.indexOf(suggestion),
+                    size,
+                    faceSuggestions.size,
+                    otherSuggestions.size,
+                    onSuggestionClick,
+                    isZeroSearchState,
+                )
+            }
+        }
+    }
+}
+
+/**
+ * Composable that displays a suggestion card within a search suggestion list.
+ *
+ * @param suggestion The search suggestion data to display in the card.
+ * @param index The index of this suggestion within the list of suggestions.
+ * @param size The total number of suggestions in the list.
+ * @param faceTypeCount The number of suggestions of type FACE in the list.
+ * @param otherTypeCount The number of suggestions of other type in the list.
+ * @param onSuggestionClick Callback function to be invoked when the suggestion card is clicked. It
+ *   receives the clicked [SearchSuggestion] as a parameter.
+ * @param isZeroSearchState A boolean flag indicating whether the search is in a "zero state" (e.g.,
+ *   no search term entered yet). Defaults to `false`.
+ */
+@Composable
+private fun ShowSuggestionCard(
+    suggestion: SearchSuggestion,
+    index: Int,
+    size: Int,
+    faceTypeCount: Int,
+    otherTypeCount: Int,
+    onSuggestionClick: (SearchSuggestion) -> Unit,
+    isZeroSearchState: Boolean = false,
+) {
+    Card(
+        modifier =
+            Modifier.fillMaxWidth()
+                .padding(MEASUREMENT_EXTRA_SMALL_PADDING)
+                .clickable(onClick = { onSuggestionClick(suggestion) }),
+        shape =
+            getCardShape(
+                index,
+                size,
+                suggestion.type,
+                faceTypeCount,
+                otherTypeCount,
+                isZeroSearchState,
+            ),
+        elevation = CardDefaults.cardElevation(defaultElevation = 0.dp),
+    ) {
+        SuggestionItem(suggestion)
+    }
+}
+
+/**
+ * Composable that displays the actual suggestion item within a suggestion card
+ *
+ * @param suggestion The search suggestion item to display.
+ * @param viewModel The `SearchViewModel` providing the search logic and state.
+ */
+@Composable
+fun SuggestionItem(suggestion: SearchSuggestion, viewModel: SearchViewModel = obtainViewModel()) {
+    Row(
+        verticalAlignment = Alignment.CenterVertically,
+        modifier = Modifier.fillMaxWidth().padding(MEASUREMENT_SUGGESTION_ITEM_PADDING),
+    ) {
+        Box(
+            modifier =
+                Modifier.background(MaterialTheme.colorScheme.surface, CircleShape).padding(6.dp)
+        ) {
+            Icon(
+                imageVector = getImageVector(suggestion.type),
+                contentDescription = suggestion.displayText ?: "",
+            )
+        }
+        val text = suggestion.displayText ?: ""
+        Text(text = text, modifier = Modifier.padding(start = MEASUREMENT_LARGE_PADDING).weight(1f))
+        if (suggestion.type != SearchSuggestionType.FACE && suggestion.iconUri != null) {
+            rememberBitmapFromUri(suggestion.iconUri, viewModel.backgroundDispatcher)?.let {
+                imageBitmap ->
+                ShowSuggestionIcon(
+                    suggestion,
+                    imageBitmap,
+                    modifier = Modifier.size(MEASUREMENT_OTHER_ICON),
+                )
+            }
+        }
+    }
+}
+
+/**
+ * Composable for showing Face suggestion type in the list of search suggestions.
+ *
+ * @param list The list of `SearchSuggestion` objects of type FACE to be displayed.
+ * @param onSuggestionClick A callback function to be invoked when a suggestion is clicked.
+ * @param otherTypeCount The number of suggestions of other type in search suggestions list.
+ * @param viewModel The `SearchViewModel` providing the search logic and state.
+ */
+@Composable
+fun ShowFaceSuggestions(
+    list: List<SearchSuggestion>,
+    onSuggestionClick: (SearchSuggestion) -> Unit,
+    otherTypeCount: Int,
+    viewModel: SearchViewModel = obtainViewModel(),
+) {
+    Card(
+        modifier = Modifier.fillMaxWidth().padding(MEASUREMENT_EXTRA_SMALL_PADDING),
+        shape =
+            getCardShape(
+                0,
+                list.size,
+                SearchSuggestionType.FACE,
+                faceTypeCount = list.size,
+                otherTypeCount = otherTypeCount,
+            ),
+        elevation = CardDefaults.cardElevation(defaultElevation = 0.dp),
+    ) {
+        Row(
+            modifier = Modifier.padding(MEASUREMENT_LARGE_PADDING).fillMaxWidth(),
+            horizontalArrangement = Arrangement.spacedBy(MEASUREMENT_ITEM_GAP_PADDING),
+        ) {
+            list.take(SearchViewModel.FACE_SUGGESTION_MAX_LIMIT).forEach { suggestion ->
+                val imageBitmap =
+                    suggestion.iconUri?.let {
+                        rememberBitmapFromUri(it, viewModel.backgroundDispatcher)
+                    }
+                ShowSuggestionIcon(
+                    suggestion,
+                    imageBitmap,
+                    modifier =
+                        Modifier.size(MEASUREMENT_FACE_SUGGESTION_ICON)
+                            .clip(CircleShape)
+                            .clickable { onSuggestionClick(suggestion) },
+                )
+            }
+        }
+    }
+}
+
+/**
+ * Composable that displays an icon for a search suggestion
+ *
+ * Tries to load an image from the `iconUri` provided in the SearchSuggestion` object. If the image
+ * loading is successful displays the image as a bitmap else falls back to displaying default vector
+ * icon.
+ *
+ * @param suggestion The `SearchSuggestion` object containing the icon URI and suggestion type.
+ * @param imageBitmap Bitmap for the suggestion icon to be shown.
+ * @param modifier Modifiers to be applied to the Icon composable.
+ */
+@Composable
+fun ShowSuggestionIcon(
+    suggestion: SearchSuggestion,
+    imageBitmap: ImageBitmap?,
+    modifier: Modifier,
+) {
+    val imageDescription = suggestion.displayText ?: ""
+    when {
+        imageBitmap != null -> {
+            Icon(bitmap = imageBitmap, contentDescription = imageDescription, modifier = modifier)
+        }
+        else -> {
+            Icon(
+                imageVector = getImageVector(suggestion.type),
+                contentDescription = imageDescription,
+                modifier = modifier,
+            )
+        }
+    }
+}
+
+/** Composable for drawing the search results Grid */
+@Composable
+private fun ResultMediaGrid(
+    resultItems: Flow<PagingData<MediaGridItem>>,
+    viewModel: SearchViewModel = obtainViewModel(),
+) {
+    val navController = LocalNavController.current
+    val selectionLimit = LocalPhotopickerConfiguration.current.selectionLimit
+    val featureManager = LocalFeatureManager.current
+    val isPreviewEnabled = remember { featureManager.isFeatureEnabled(PreviewFeature::class.java) }
+    val selectionLimitExceededMessage =
+        stringResource(R.string.photopicker_selection_limit_exceeded_snackbar, selectionLimit)
+    val items = resultItems.collectAsLazyPagingItems()
+    val scope = rememberCoroutineScope()
+    val events = LocalEvents.current
+    val configuration = LocalPhotopickerConfiguration.current
+
+    // Collect the selection to notify the mediaGrid of selection changes.
+    val selection by LocalSelection.current.flow.collectAsStateWithLifecycle()
+
+    // Use the expanded layout any time the Width is Medium or larger.
+    val isExpandedScreen: Boolean =
+        when (LocalWindowSizeClass.current.widthSizeClass) {
+            WindowWidthSizeClass.Medium,
+            WindowWidthSizeClass.Expanded -> true
+            else -> false
+        }
+
+    val state = rememberLazyGridState()
+    val isEmptyAndNoMorePages =
+        items.itemCount == 0 &&
+            items.loadState.source.append is LoadState.NotLoading &&
+            items.loadState.source.append.endOfPaginationReached
+
+    // State to track the loading and empty states
+    var resultsState by remember { mutableStateOf(ResultsState.LOADING_WITHOUT_INDICATOR) }
+    if (isEmptyAndNoMorePages) {
+        resultsState = ResultsState.EMPTY
+    }
+
+    LaunchedEffect(items.loadState.refresh) {
+        if (
+            items.itemCount == 0 &&
+                items.loadState.refresh is LoadState.Loading &&
+                resultsState == ResultsState.LOADING_WITHOUT_INDICATOR
+        ) {
+            withContext(viewModel.backgroundDispatcher) {
+                delay(1000)
+                if (items.itemCount == 0) {
+                    resultsState = ResultsState.LOADING_WITH_INDICATOR
+                    delay(4000)
+                    if (resultsState == ResultsState.LOADING_WITH_INDICATOR)
+                        resultsState = ResultsState.EMPTY
+                }
+            }
+        } else if (resultsState != ResultsState.EMPTY) {
+            resultsState = ResultsState.RESULTS_GRID
+        }
+    }
+    when (resultsState) {
+        ResultsState.EMPTY -> {
+            EmptySearchResult()
+        }
+        ResultsState.LOADING_WITH_INDICATOR -> {
+            Box(modifier = Modifier.fillMaxSize()) {
+                CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))
+            }
+        }
+        ResultsState.RESULTS_GRID -> {
+            Box(modifier = Modifier.fillMaxSize()) {
+                mediaGrid(
+                    items = items,
+                    isExpandedScreen = isExpandedScreen,
+                    selection = selection,
+                    onItemClick = { item ->
+                        if (item is MediaGridItem.MediaItem) {
+                            viewModel.handleGridItemSelection(
+                                item = item.media,
+                                selectionLimitExceededMessage = selectionLimitExceededMessage,
+                            )
+                            // TODO: (b/381876944) Log Ui Event after adding search enum
+                        }
+                    },
+                    onItemLongPress = { item ->
+                        // If the [PreviewFeature] is enabled, launch the preview route.
+                        if (isPreviewEnabled) {
+                            scope.launch {
+                                events.dispatch(
+                                    Event.LogPhotopickerUIEvent(
+                                        FeatureToken.SEARCH.token,
+                                        configuration.sessionId,
+                                        configuration.callingPackageUid ?: -1,
+                                        Telemetry.UiEvent.PICKER_LONG_SELECT_MEDIA_ITEM,
+                                    )
+                                )
+                            }
+                            if (item is MediaGridItem.MediaItem) {
+                                scope.launch {
+                                    events.dispatch(
+                                        Event.LogPhotopickerUIEvent(
+                                            FeatureToken.SEARCH.token,
+                                            configuration.sessionId,
+                                            configuration.callingPackageUid ?: -1,
+                                            Telemetry.UiEvent.ENTER_PICKER_PREVIEW_MODE,
+                                        )
+                                    )
+                                }
+                                navController.navigateToPreviewMedia(item.media)
+                            }
+                        }
+                    },
+                    state = state,
+                )
+            }
+        }
+        else -> {}
+    }
+}
+
+/**
+ * Returns Icon based on the suggestion type.
+ *
+ * @param suggestionType The type of search suggestion
+ */
+private fun getImageVector(suggestionType: SearchSuggestionType): ImageVector {
+    return when (suggestionType) {
+        SearchSuggestionType.HISTORY -> {
+            Icons.Outlined.History
+        }
+        SearchSuggestionType.FAVORITES_ALBUM -> {
+            Icons.Outlined.StarBorder
+        }
+        SearchSuggestionType.LOCATION -> {
+            Icons.Outlined.LocationOn
+        }
+        SearchSuggestionType.DATE -> {
+            Icons.Filled.Today
+        }
+        SearchSuggestionType.VIDEOS_ALBUM -> {
+            Icons.Outlined.PlayCircle
+        }
+        SearchSuggestionType.ALBUM -> {
+            Icons.Outlined.PhotoAlbum
+        }
+        SearchSuggestionType.TEXT -> {
+            Icons.Outlined.Search
+        }
+        SearchSuggestionType.SCREENSHOTS_ALBUM -> {
+            Icons.Outlined.Smartphone
+        }
+        else -> {
+            Icons.Outlined.Search
+        }
+    }
+}
+
+/**
+ * Determines the shape of a card based on its index, size, and suggestion type.
+ *
+ * This function calculates the appropriate `Shape` for a card in a list, considering:
+ * - **index:** The position of the card in the list.
+ * - **size:** The total number of cards in the list.
+ * - **type:** The type of suggestion the card represents.
+ * - **isZeroState:** Indicates whether the search is in a "zero state"
+ *
+ * @param index The index of the card in the list.
+ * @param size The total number of cards in the list.
+ * @param type The type of suggestion.
+ * @param faceTypeCount The number of suggestions of type FACE in the list.
+ * @param otherTypeCount The number of suggestions of other type in the suggestions list.
+ * @param isZeroState A boolean flag to indicate whether the search is in a "zero state"
+ * @return The calculated `Shape` for the card.
+ */
+@Composable
+private fun getCardShape(
+    index: Int,
+    size: Int,
+    type: SearchSuggestionType,
+    faceTypeCount: Int,
+    otherTypeCount: Int,
+    isZeroState: Boolean = true,
+): Shape {
+    return when {
+        type == SearchSuggestionType.FACE && isZeroState -> {
+            if (otherTypeCount > 0) {
+                TOP_SUGGESTION_CARD_SHAPE
+            } else {
+                SINGLE_SUGGESTION_CARD_SHAPE
+            }
+        }
+        type == SearchSuggestionType.HISTORY -> getRoundedCornerShape(index, size)
+        else -> {
+            if (faceTypeCount == 0) {
+                getRoundedCornerShape(index, size)
+            } else {
+                when (index) {
+                    size - 1 -> BOTTOM_SUGGESTION_CARD_SHAPE
+                    else -> MIDDLE_SUGGESTION_CARD_SHAPE
+                }
+            }
+        }
+    }
+}
+
+/**
+ * Helper function to calculate the rounded corner shape based on index and size.
+ *
+ * @param index The position of the item in the list.
+ * @param size The total number of items in the list.
+ * @return A `Shape` object with the appropriate rounded corners.
+ */
+private fun getRoundedCornerShape(index: Int, size: Int): Shape {
+    return when {
+        index == 0 && size == 1 -> SINGLE_SUGGESTION_CARD_SHAPE
+        index == 0 -> TOP_SUGGESTION_CARD_SHAPE
+        index == size - 1 -> BOTTOM_SUGGESTION_CARD_SHAPE
+        else -> MIDDLE_SUGGESTION_CARD_SHAPE
     }
 }
+
+/** Represents the different UI states for the search results data. */
+enum class ResultsState {
+    LOADING_WITHOUT_INDICATOR,
+    LOADING_WITH_INDICATOR,
+    EMPTY,
+    RESULTS_GRID,
+}
diff --git a/photopicker/src/com/android/photopicker/features/search/SearchFeature.kt b/photopicker/src/com/android/photopicker/features/search/SearchFeature.kt
index 1af76f569..26ed22801 100644
--- a/photopicker/src/com/android/photopicker/features/search/SearchFeature.kt
+++ b/photopicker/src/com/android/photopicker/features/search/SearchFeature.kt
@@ -16,9 +16,11 @@
 
 package com.android.photopicker.features.search
 
+import android.provider.MediaStore
 import androidx.compose.runtime.Composable
 import androidx.compose.ui.Modifier
 import com.android.photopicker.core.configuration.PhotopickerConfiguration
+import com.android.photopicker.core.events.Event
 import com.android.photopicker.core.events.RegisteredEventClass
 import com.android.photopicker.core.features.FeatureManager
 import com.android.photopicker.core.features.FeatureRegistration
@@ -26,7 +28,12 @@ import com.android.photopicker.core.features.FeatureToken
 import com.android.photopicker.core.features.Location
 import com.android.photopicker.core.features.LocationParams
 import com.android.photopicker.core.features.PhotopickerUiFeature
+import com.android.photopicker.core.features.PrefetchResultKey
 import com.android.photopicker.core.features.Priority
+import com.android.photopicker.data.PrefetchDataService
+import com.android.photopicker.features.search.model.SearchEnabledState
+import kotlinx.coroutines.Deferred
+import kotlinx.coroutines.runBlocking
 
 /** Feature class for the Photopicker's search functionality. */
 class SearchFeature : PhotopickerUiFeature {
@@ -34,8 +41,42 @@ class SearchFeature : PhotopickerUiFeature {
     companion object Registration : FeatureRegistration {
         override val TAG: String = "SearchFeature"
 
-        override fun isEnabled(config: PhotopickerConfiguration) =
-            config.flags.PICKER_SEARCH_ENABLED
+        override fun getPrefetchRequest(
+            config: PhotopickerConfiguration
+        ): Map<PrefetchResultKey, suspend (PrefetchDataService) -> Any?>? {
+            return if (
+                config.flags.PICKER_SEARCH_ENABLED &&
+                    config.action != MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP
+            ) {
+                mapOf(
+                    PrefetchResultKey.SEARCH_STATE to
+                        { prefetchDataService ->
+                            prefetchDataService.getSearchState()
+                        }
+                )
+            } else {
+                null
+            }
+        }
+
+        override fun isEnabled(
+            config: PhotopickerConfiguration,
+            deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>>,
+        ): Boolean {
+            // Search feature is not enabled in permission mode.
+            if (config.action == MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP) return false
+
+            if (!config.flags.PICKER_SEARCH_ENABLED) return false
+
+            return runBlocking {
+                val searchStatus: Any? =
+                    deferredPrefetchResultsMap[PrefetchResultKey.SEARCH_STATE]?.await()
+                when (searchStatus) {
+                    is SearchEnabledState -> searchStatus == SearchEnabledState.ENABLED
+                    else -> false // prefetch may have timed out
+                }
+            }
+        }
 
         override fun build(featureManager: FeatureManager) = SearchFeature()
     }
@@ -47,7 +88,7 @@ class SearchFeature : PhotopickerUiFeature {
     @Composable
     override fun compose(location: Location, modifier: Modifier, params: LocationParams) {
         when (location) {
-            Location.SEARCH_BAR -> Search(modifier)
+            Location.SEARCH_BAR -> Search(modifier, params)
             else -> {}
         }
     }
@@ -56,5 +97,11 @@ class SearchFeature : PhotopickerUiFeature {
 
     override val eventsConsumed = setOf<RegisteredEventClass>()
 
-    override val eventsProduced = setOf<RegisteredEventClass>()
+    /** Events produced by the search feature */
+    override val eventsProduced =
+        setOf(
+            Event.ShowSnackbarMessage::class.java,
+            Event.LogPhotopickerUIEvent::class.java,
+            Event.ReportPhotopickerSearchInfo::class.java,
+        )
 }
diff --git a/photopicker/src/com/android/photopicker/features/search/SearchJob.kt b/photopicker/src/com/android/photopicker/features/search/SearchJob.kt
new file mode 100644
index 000000000..1aaa87bc3
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/search/SearchJob.kt
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.search
+
+import android.os.CancellationSignal
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Job
+import kotlinx.coroutines.launch
+
+/**
+ * A wrapper class responsible for managing search jobs and their cancellation.
+ *
+ * This class encapsulates the logic for starting a new search operation, canceling any ongoing
+ * search.
+ *
+ * @param scope The CoroutineScope in which to launch the search job. This is typically a ViewModel
+ *   scope or a scope that is tied to the lifecycle of the component that uses this class.
+ */
+class SearchJob(private val scope: CoroutineScope) {
+    private var searchJob: Job? = null
+    val cancellationSignal: CancellationSignal = CancellationSignal()
+
+    /** Cancels the current search job. */
+    fun cancel() {
+        searchJob?.cancel()
+        cancellationSignal.cancel()
+    }
+
+    /**
+     * Launches a coroutine to execute a provided search action.
+     *
+     * This function starts a new coroutine within the defined scope to perform the provided
+     * `searchAction`.
+     *
+     * @param searchAction A suspend function that represents the search operation to be executed.
+     */
+    fun startSearch(searchAction: suspend () -> Unit) {
+        searchJob = scope.launch { searchAction() }
+    }
+}
diff --git a/photopicker/src/com/android/photopicker/features/search/SearchSuggestionCache.kt b/photopicker/src/com/android/photopicker/features/search/SearchSuggestionCache.kt
new file mode 100644
index 000000000..9d31c0f25
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/search/SearchSuggestionCache.kt
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.search
+
+import com.android.photopicker.features.search.model.SearchSuggestion
+
+/**
+ * Class that implements cache for SearchSuggestions that stores a list of suggestions for a given
+ * prefix
+ */
+class SearchSuggestionCache {
+    private var cacheSuggestion: HashMap<String, List<SearchSuggestion>> = java.util.HashMap()
+
+    /**
+     * Retrieves suggestions for a given prefix from the cache.
+     *
+     * @param query The prefix to search for.
+     * @return A list of suggestions for the prefix, or null if no suggestions are found.
+     */
+    fun getSuggestions(query: String): List<SearchSuggestion>? {
+        return cacheSuggestion.get(query)
+    }
+
+    /**
+     * Adds suggestions for a given prefix to the cache.
+     *
+     * @param query The prefix to add suggestions for.
+     * @param suggestions The list of suggestions to add.
+     */
+    fun addSuggestions(query: String, suggestions: List<SearchSuggestion>) {
+        cacheSuggestion.put(query, suggestions)
+    }
+}
diff --git a/photopicker/src/com/android/photopicker/features/search/SearchViewModel.kt b/photopicker/src/com/android/photopicker/features/search/SearchViewModel.kt
new file mode 100644
index 000000000..e55bd7cd0
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/search/SearchViewModel.kt
@@ -0,0 +1,325 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.search
+
+import androidx.lifecycle.ViewModel
+import androidx.lifecycle.viewModelScope
+import androidx.paging.Pager
+import androidx.paging.PagingConfig
+import androidx.paging.PagingData
+import androidx.paging.cachedIn
+import com.android.photopicker.core.Background
+import com.android.photopicker.core.components.MediaGridItem
+import com.android.photopicker.core.configuration.ConfigurationManager
+import com.android.photopicker.core.events.Event
+import com.android.photopicker.core.events.Events
+import com.android.photopicker.core.events.Telemetry
+import com.android.photopicker.core.features.FeatureToken
+import com.android.photopicker.core.selection.Selection
+import com.android.photopicker.core.selection.SelectionModifiedResult
+import com.android.photopicker.data.model.Media
+import com.android.photopicker.extensions.insertMonthSeparators
+import com.android.photopicker.extensions.toMediaGridItemFromMedia
+import com.android.photopicker.features.search.data.SearchDataService
+import com.android.photopicker.features.search.model.SearchEnabledState
+import com.android.photopicker.features.search.model.SearchSuggestion
+import com.android.photopicker.features.search.model.SearchSuggestionType
+import dagger.hilt.android.lifecycle.HiltViewModel
+import javax.inject.Inject
+import kotlinx.coroutines.CoroutineDispatcher
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.flow.Flow
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.StateFlow
+import kotlinx.coroutines.launch
+import kotlinx.coroutines.withContext
+
+/**
+ * ViewModel for handling search functionality.
+ *
+ * This ViewModel manages the search state, including the search term, suggestions, and whether a
+ * search was triggered by a query or a suggestion.
+ *
+ * @param scopeOverride An optional CoroutineScope to be used instead of the default viewModelScope.
+ * @param backgroundDispatcher A CoroutineDispatcher for running background tasks. This dispatcher
+ *   is marked as `internal` and can be accessed by other classes within the same module.
+ * @param searchDataService The service for fetching search suggestions.
+ */
+@HiltViewModel
+class SearchViewModel
+@Inject
+constructor(
+    private val scopeOverride: CoroutineScope?,
+    @Background val backgroundDispatcher: CoroutineDispatcher,
+    private val searchDataService: SearchDataService,
+    private val selection: Selection<Media>,
+    private val events: Events,
+    private val configurationManager: ConfigurationManager,
+) : ViewModel() {
+
+    companion object {
+        const val HISTORY_SUGGESTION_MAX_LIMIT = 3
+        const val FACE_SUGGESTION_MAX_LIMIT = 6
+        const val ALL_SUGGESTION_MAX_LIMIT = 6
+        const val SEARCH_RESULT_GRID_PAGE_SIZE = 50
+        const val SEARCH_RESULT_GRID_MAX_ITEMS_IN_MEMORY = SEARCH_RESULT_GRID_PAGE_SIZE * 10
+    }
+
+    // Check if a scope override was injected before using the default [viewModelScope]
+    private val scope: CoroutineScope = scopeOverride ?: this.viewModelScope
+
+    private var searchJob: SearchJob? = null
+
+    /**
+     * Represents the current state of the search.
+     *
+     * It can be one of the following:
+     * - **Inactive:** The initial state where no search is active.
+     * - **Active.QuerySearch:** A search is active with a user-entered query.
+     * - **Active.SuggestionSearch:** A search is active using a selected suggestion.
+     */
+    private val _searchState = MutableStateFlow<SearchState>(SearchState.Inactive)
+    val searchState: StateFlow<SearchState> = _searchState
+
+    /**
+     * Holds the current state of search suggestions list.
+     *
+     * This `StateFlow` emits updates whenever the list of search suggestions changes. It provides
+     * various types of suggestions (e.g., history, face, others).
+     */
+    private val _suggestionLists = MutableStateFlow(SuggestionLists())
+    val suggestionLists: StateFlow<SuggestionLists> = _suggestionLists
+
+    /**
+     * Holds the value of the current profile's search enabled state
+     *
+     * This `StateFlow` emits updates whenever the search enabled state of a profile changes.
+     */
+    val searchEnabled: StateFlow<SearchEnabledState> = searchDataService.isSearchEnabled
+
+    private val suggestionCache = SearchSuggestionCache()
+
+    init {
+        fetchSuggestions("")
+    }
+
+    /**
+     * Updates the search term and fetches new suggestions.
+     *
+     * This function cancels any current search job and starts search as a new job.
+     *
+     * @param query The new search term.
+     */
+    fun fetchSuggestions(query: String) {
+        searchJob?.cancel()
+
+        val cachedSuggestion: List<SearchSuggestion>? = suggestionCache.getSuggestions(query)
+        when (cachedSuggestion != null) {
+            true -> {
+                getSuggestionTypeLists(cachedSuggestion, query.isEmpty())
+            }
+
+            else -> {
+                searchJob = SearchJob(scope)
+                searchJob?.let { job ->
+                    job.startSearch() {
+                        withContext(backgroundDispatcher) {
+                            val newSuggestions =
+                                searchDataService.getSearchSuggestions(
+                                    query,
+                                    cancellationSignal = job.cancellationSignal,
+                                )
+                            val refactoredSuggestionList: List<SearchSuggestion> =
+                                getSuggestionTypeLists(newSuggestions, query.isEmpty())
+                            suggestionCache.addSuggestions(query, refactoredSuggestionList)
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Returns [PagingData] of type [MediaGridItem] as a [Flow] containing search result for a
+     * search suggestion or query based on search state.
+     */
+    fun getSearchResults(): Flow<PagingData<MediaGridItem>> {
+        val currentSearchState = _searchState.value
+        val pagerForSearchResult =
+            Pager(
+                PagingConfig(
+                    pageSize = SEARCH_RESULT_GRID_PAGE_SIZE,
+                    maxSize = SEARCH_RESULT_GRID_MAX_ITEMS_IN_MEMORY,
+                )
+            ) {
+                when (currentSearchState) {
+                    is SearchState.Active.SuggestionSearch -> {
+                        scope.launch {
+                            events.dispatch(
+                                Event.ReportPhotopickerSearchInfo(
+                                    FeatureToken.SEARCH.token,
+                                    configurationManager.configuration.value.sessionId,
+                                    Telemetry.SearchMethod.SUGGESTED_SEARCHES,
+                                )
+                            )
+                        }
+                        searchDataService.getSearchResults(
+                            suggestion = currentSearchState.suggestion
+                        )
+                    }
+                    is SearchState.Active.QuerySearch -> {
+                        scope.launch {
+                            events.dispatch(
+                                Event.ReportPhotopickerSearchInfo(
+                                    FeatureToken.SEARCH.token,
+                                    configurationManager.configuration.value.sessionId,
+                                    Telemetry.SearchMethod.SEARCH_QUERY,
+                                )
+                            )
+                        }
+                        searchDataService.getSearchResults(searchText = currentSearchState.query)
+                    }
+                    is SearchState.Inactive -> {
+                        throw IllegalStateException("Cannot create Pager in inactive search state.")
+                    }
+                }
+            }
+
+        /** Export the data from the pager and prepare it for use in the [MediaGridItem] */
+        return pagerForSearchResult.flow
+            .toMediaGridItemFromMedia()
+            .insertMonthSeparators()
+            // After the load and transformations, cache the data in the viewModelScope.
+            // This ensures that the list position and state will be remembered by the
+            // MediaGrid when navigating back to the SearchResult route.
+            .cachedIn(scope)
+    }
+
+    /** Sets Inactive search state where no search result is active */
+    fun clearSearch() {
+        _searchState.value = SearchState.Inactive
+    }
+
+    /**
+     * Initiates a search based on a selected search suggestion.
+     *
+     * @param suggestion The `SearchSuggestion` selected by the user.
+     */
+    fun performSearch(suggestion: SearchSuggestion) {
+        _searchState.value = SearchState.Active.SuggestionSearch(suggestion)
+    }
+
+    /**
+     * Initiates a search based on a user-provided query string.
+     *
+     * @param query The search query entered by the user.
+     */
+    fun performSearch(query: String) {
+        _searchState.value = SearchState.Active.QuerySearch(query)
+    }
+
+    /**
+     * Click handler that is called when items in the grid are clicked. Selection updates are made
+     * in the viewModelScope to ensure they aren't canceled if the user navigates away from the
+     * PhotoGrid composable.
+     */
+    fun handleGridItemSelection(item: Media, selectionLimitExceededMessage: String) {
+        val updatedMediaItem =
+            Media.withSelectable(
+                item,
+                /* selectionSource */ Telemetry.MediaLocation.SEARCH_GRID,
+                /* album */ null,
+            )
+        scope.launch {
+            val result = selection.toggle(updatedMediaItem)
+            if (result == SelectionModifiedResult.FAILURE_SELECTION_LIMIT_EXCEEDED) {
+                scope.launch {
+                    events.dispatch(
+                        Event.ShowSnackbarMessage(
+                            FeatureToken.SEARCH.token,
+                            selectionLimitExceededMessage,
+                        )
+                    )
+                }
+            }
+        }
+    }
+
+    /**
+     * Method that updates the list for each type of suggestion from the suggestions result and
+     * returns a trimmed list of search suggestions to show on UI
+     *
+     * @param suggestions The original list of `SearchSuggestion` objects.
+     * @param isZeroSearchState A boolean value indicating if the search query is empty.
+     */
+    private fun getSuggestionTypeLists(
+        suggestions: List<SearchSuggestion>,
+        isZeroSearchState: Boolean,
+    ): List<SearchSuggestion> {
+        val history = mutableListOf<SearchSuggestion>()
+        val face = mutableListOf<SearchSuggestion>()
+        val other = mutableListOf<SearchSuggestion>()
+        val result = mutableListOf<SearchSuggestion>()
+        var (historyCount, faceCount, otherCount) = listOf(0, 0, 0)
+
+        for (suggestion in suggestions) {
+            when (suggestion.type) {
+                SearchSuggestionType.HISTORY ->
+                    if (historyCount++ < HISTORY_SUGGESTION_MAX_LIMIT) {
+                        history.add(suggestion)
+                        result.add(suggestion)
+                    }
+                SearchSuggestionType.FACE ->
+                    if (isZeroSearchState) {
+                        if (faceCount++ < FACE_SUGGESTION_MAX_LIMIT) {
+                            face.add(suggestion)
+                            result.add(suggestion)
+                        }
+                    } else {
+                        if (otherCount++ < ALL_SUGGESTION_MAX_LIMIT) {
+                            other.add(suggestion)
+                            result.add(suggestion)
+                        }
+                    }
+                else ->
+                    if (otherCount++ < ALL_SUGGESTION_MAX_LIMIT) {
+                        other.add(suggestion)
+                        result.add(suggestion)
+                    }
+            }
+            if (
+                historyCount >= HISTORY_SUGGESTION_MAX_LIMIT &&
+                    faceCount >= FACE_SUGGESTION_MAX_LIMIT &&
+                    otherCount >= ALL_SUGGESTION_MAX_LIMIT
+            )
+                break // Early exit
+        }
+        _suggestionLists.value = SuggestionLists(history, face, other)
+        return result
+    }
+}
+
+/** Represents the different states of the search functionality. */
+sealed class SearchState {
+    object Inactive : SearchState()
+
+    sealed class Active : SearchState() {
+        data class QuerySearch(val query: String) : Active()
+
+        data class SuggestionSearch(val suggestion: SearchSuggestion) : Active()
+    }
+}
diff --git a/photopicker/src/com/android/photopicker/features/search/SuggestionLists.kt b/photopicker/src/com/android/photopicker/features/search/SuggestionLists.kt
new file mode 100644
index 000000000..237674b3c
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/search/SuggestionLists.kt
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.search
+
+import com.android.photopicker.features.search.model.SearchSuggestion
+
+/**
+ * Data class that holds different types of search suggestions.
+ *
+ * This class encapsulates lists for history suggestions, face suggestions, and other suggestions.
+ * It also provides a calculated property to get the total number of suggestions.
+ *
+ * @property history List of history they search suggestions.
+ * @property face List of face type search suggestions.
+ * @property other List of other types of search suggestions.
+ */
+data class SuggestionLists(
+    val history: List<SearchSuggestion> = emptyList(),
+    val face: List<SearchSuggestion> = emptyList(),
+    val other: List<SearchSuggestion> = emptyList(),
+) {
+    val totalSuggestions: Int = history.size + face.size + other.size
+}
diff --git a/photopicker/src/com/android/photopicker/features/search/data/FakeSearchDataServiceImpl.kt b/photopicker/src/com/android/photopicker/features/search/data/FakeSearchDataServiceImpl.kt
new file mode 100644
index 000000000..3e6adbeea
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/search/data/FakeSearchDataServiceImpl.kt
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.search.data
+
+import android.net.Uri
+import android.os.CancellationSignal
+import androidx.paging.PagingSource
+import com.android.photopicker.data.DataService
+import com.android.photopicker.data.model.Media
+import com.android.photopicker.data.model.MediaPageKey
+import com.android.photopicker.features.search.model.SearchEnabledState
+import com.android.photopicker.features.search.model.SearchSuggestion
+import com.android.photopicker.features.search.model.SearchSuggestionType
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.StateFlow
+
+/**
+ * Placeholder for the actual [SearchDataService] implementation class. This class can be used to
+ * unblock and test UI development till we have the actual implementation in ready.
+ */
+// TODO(b/361043596) Clean up once we have the implementation for [SearchDataService] class.
+class FakeSearchDataServiceImpl(private val dataService: DataService) : SearchDataService {
+    // Use the internal flow of type StateFlow<Map<UserProfile, Boolean>> which would cache
+    // the result for all profiles, to populate this flow for the current profile.
+    override val isSearchEnabled: StateFlow<SearchEnabledState> =
+        MutableStateFlow(SearchEnabledState.ENABLED)
+
+    /** Returns a few static suggestions to unblock UI development. */
+    override suspend fun getSearchSuggestions(
+        prefix: String,
+        limit: Int,
+        cancellationSignal: CancellationSignal?,
+    ): List<SearchSuggestion> {
+        if (prefix == "testempty") {
+            return emptyList()
+        }
+        return listOf(
+            SearchSuggestion("1", "authority", "France", SearchSuggestionType.LOCATION, null),
+            SearchSuggestion(
+                "2",
+                "authority",
+                "Favorites",
+                SearchSuggestionType.FAVORITES_ALBUM,
+                Uri.parse("xyz"),
+            ),
+            SearchSuggestion(
+                "8",
+                "authority",
+                "Album",
+                SearchSuggestionType.ALBUM,
+                Uri.parse("xyz"),
+            ),
+            SearchSuggestion("2", "authority", "Videos", SearchSuggestionType.VIDEOS_ALBUM, null),
+            SearchSuggestion(null, "authority", "france", SearchSuggestionType.HISTORY, null),
+            SearchSuggestion(null, "authority", "paris", SearchSuggestionType.HISTORY, null),
+            SearchSuggestion("3", "authority", "March", SearchSuggestionType.DATE, null),
+            SearchSuggestion(
+                "3",
+                "authority",
+                "Screenshot",
+                SearchSuggestionType.SCREENSHOTS_ALBUM,
+                null,
+            ),
+            SearchSuggestion("4", "authority", "Emma", SearchSuggestionType.FACE, Uri.parse("xyz")),
+            SearchSuggestion("5", "authority", "Bob", SearchSuggestionType.FACE, Uri.parse("xyz")),
+            SearchSuggestion("6", "authority", "April", SearchSuggestionType.DATE, null),
+            SearchSuggestion("7", "authority", null, SearchSuggestionType.FACE, Uri.parse("xyz")),
+        )
+    }
+
+    /** Returns all media to unblock UI development. */
+    override fun getSearchResults(
+        suggestion: SearchSuggestion,
+        cancellationSignal: CancellationSignal?,
+    ): PagingSource<MediaPageKey, Media> = dataService.mediaPagingSource()
+
+    /** Returns all media to unblock UI development. */
+    override fun getSearchResults(
+        searchText: String,
+        cancellationSignal: CancellationSignal?,
+    ): PagingSource<MediaPageKey, Media> = dataService.mediaPagingSource()
+}
diff --git a/photopicker/src/com/android/photopicker/features/search/data/SearchDataService.kt b/photopicker/src/com/android/photopicker/features/search/data/SearchDataService.kt
new file mode 100644
index 000000000..d04aac74b
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/search/data/SearchDataService.kt
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.search.data
+
+import android.os.CancellationSignal
+import androidx.paging.PagingSource
+import com.android.photopicker.data.model.Media
+import com.android.photopicker.data.model.MediaPageKey
+import com.android.photopicker.features.search.model.SearchEnabledState
+import com.android.photopicker.features.search.model.SearchSuggestion
+import kotlinx.coroutines.flow.StateFlow
+
+/**
+ * Powers UI with data for the search feature. This class owns the responsibility to:
+ * - fetch data on demand
+ * - cache data if required
+ * - keep track of data updates in the data source
+ * - detect and refresh stale data
+ */
+interface SearchDataService {
+    companion object {
+        const val TAG: String = "PhotopickerSearchDataService"
+    }
+
+    /**
+     * A [StateFlow] that emits a value when current profile changes or search config in the data
+     * source changes. It hold that value of the current profile's search enabled state
+     * [SearchEnabledState].
+     */
+    val isSearchEnabled: StateFlow<SearchEnabledState>
+
+    /**
+     * Get search suggestions for the user in zero state and as the user is typing.
+     *
+     * @param prefix The search text typed so far by the user. If the user is in zero-state (has not
+     *   typed anything), the prefix will be null.
+     * @param limit Maximum number of search suggestions.
+     * @param cancellationSignal used to indicate that the fetch suggestions operation should be
+     *   cancelled. If the user has cleared the search text or the prefix has changed, UI layer can
+     *   choose to stop the get suggestions operation to save resources.
+     * @return A list of [SearchSuggestion]-s.
+     */
+    suspend fun getSearchSuggestions(
+        prefix: String,
+        limit: Int = 200,
+        cancellationSignal: CancellationSignal? = null,
+    ): List<SearchSuggestion>
+
+    /**
+     * Get search results for a search suggestion. This method should be used when the user searches
+     * for an item by selecting a search suggestion.
+     *
+     * @param suggestion The search suggestion the user selected.
+     * @return The [PagingSource] that fetches a page using [MediaPageKey]. A page in the paging
+     *   source contains a [List] of [Media] items.
+     */
+    fun getSearchResults(
+        suggestion: SearchSuggestion,
+        cancellationSignal: CancellationSignal? = null,
+    ): PagingSource<MediaPageKey, Media>
+
+    /**
+     * Get search results for a search text query. This method should be used when the user searches
+     * for an item by entering something in the search bar.
+     *
+     * @param searchText The search text that the user entered.
+     * @return The [PagingSource] that fetches a page using [MediaPageKey]. A page in the paging
+     *   source contains a [List] of [Media] items.
+     */
+    fun getSearchResults(
+        searchText: String,
+        cancellationSignal: CancellationSignal? = null,
+    ): PagingSource<MediaPageKey, Media>
+}
diff --git a/photopicker/src/com/android/photopicker/features/search/data/SearchDataServiceImpl.kt b/photopicker/src/com/android/photopicker/features/search/data/SearchDataServiceImpl.kt
new file mode 100644
index 000000000..78ebc1e9e
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/search/data/SearchDataServiceImpl.kt
@@ -0,0 +1,248 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.search.data
+
+import android.content.ContentResolver
+import android.os.CancellationSignal
+import android.util.Log
+import androidx.paging.PagingSource
+import com.android.photopicker.core.configuration.PhotopickerConfiguration
+import com.android.photopicker.core.events.Events
+import com.android.photopicker.core.user.UserStatus
+import com.android.photopicker.data.DataService
+import com.android.photopicker.data.MediaProviderClient
+import com.android.photopicker.data.NotificationService
+import com.android.photopicker.data.model.Media
+import com.android.photopicker.data.model.MediaPageKey
+import com.android.photopicker.data.model.Provider
+import com.android.photopicker.features.search.model.SearchEnabledState
+import com.android.photopicker.features.search.model.SearchRequest
+import com.android.photopicker.features.search.model.SearchSuggestion
+import kotlinx.coroutines.CoroutineDispatcher
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.StateFlow
+import kotlinx.coroutines.launch
+import kotlinx.coroutines.runBlocking
+import kotlinx.coroutines.sync.Mutex
+import kotlinx.coroutines.sync.withLock
+
+/**
+ * Provides search feature data to the Photo Picker UI. The data comes from a [ContentProvider]
+ * called [MediaProvider].
+ *
+ * Underlying data changes in [MediaProvider] are observed using [ContentObservers]. When a change
+ * in data is observed, the data is re-fetched from the [MediaProvider] process and the new data is
+ * emitted to the [StateFlows]-s.
+ *
+ * @param dataService Core Picker's data service that provides data related to core functionality.
+ * @param userStatus A [StateFlow] with the current active user's details.
+ * @param photopickerConfiguration A [StateFlow] that emits [PhotopickerConfiguration] changes.
+ * @param scope The [CoroutineScope] the data flows will be shared in.
+ * @param dispatcher A [CoroutineDispatcher] to run the coroutines in.
+ * @param notificationService An instance of [NotificationService] responsible to listen to data
+ *   change notifications.
+ * @param mediaProviderClient An instance of [MediaProviderClient] responsible to get data from
+ *   MediaProvider.
+ * @param events Event bus for the current session.
+ */
+class SearchDataServiceImpl(
+    private val dataService: DataService,
+    private val userStatus: StateFlow<UserStatus>,
+    private val photopickerConfiguration: StateFlow<PhotopickerConfiguration>,
+    private val scope: CoroutineScope,
+    private val dispatcher: CoroutineDispatcher,
+    private val notificationService: NotificationService,
+    private val mediaProviderClient: MediaProviderClient,
+    private val events: Events,
+) : SearchDataService {
+    // An internal lock to allow thread-safe updates to the search request and results cache.
+    private val searchResultsPagingSourceMutex = Mutex()
+
+    // Cache that contains a search request to search request id map.
+    private val searchRequestIdMap: MutableMap<SearchRequest, Int> = mutableMapOf()
+
+    // Cache that contains a search request id to [SearchResultsPagingSource] map.
+    private val searchResultsPagingSources: MutableMap<Int, PagingSource<MediaPageKey, Media>> =
+        mutableMapOf()
+
+    init {
+        // Listen to available provider changes and clear search cache when required.
+        scope.launch(dispatcher) {
+            dataService.availableProviders.collect { providers: List<Provider> ->
+                Log.d(
+                    SearchDataService.TAG,
+                    "Available providers have changed to $providers. " +
+                        "Clearing search results cache.",
+                )
+
+                searchResultsPagingSourceMutex.withLock {
+                    searchResultsPagingSources.values.forEach { pagingSource ->
+                        pagingSource.invalidate()
+                    }
+
+                    searchResultsPagingSources.clear()
+                    searchRequestIdMap.clear()
+                }
+            }
+        }
+    }
+
+    // TODO(b/381819838)
+    override val isSearchEnabled: StateFlow<SearchEnabledState> =
+        MutableStateFlow(SearchEnabledState.ENABLED)
+
+    // TODO(b/381820020)
+    override suspend fun getSearchSuggestions(
+        prefix: String,
+        limit: Int,
+        cancellationSignal: CancellationSignal?,
+    ): List<SearchSuggestion> = emptyList()
+
+    /**
+     * Returns an instance of [SearchResultsPagingSource] that can source search results for the
+     * given search suggestions query.
+     */
+    override fun getSearchResults(
+        suggestion: SearchSuggestion,
+        cancellationSignal: CancellationSignal?,
+    ): PagingSource<MediaPageKey, Media> {
+        return getSearchResults(
+            SearchRequest.SearchSuggestionRequest(suggestion),
+            cancellationSignal,
+        )
+    }
+
+    /**
+     * Returns an instance of [SearchResultsPagingSource] that can source search results for the
+     * given search text query.
+     */
+    override fun getSearchResults(
+        searchText: String,
+        cancellationSignal: CancellationSignal?,
+    ): PagingSource<MediaPageKey, Media> {
+        return getSearchResults(SearchRequest.SearchTextRequest(searchText), cancellationSignal)
+    }
+
+    /**
+     * Returns an instance of [SearchResultsPagingSource] that can source search results for the
+     * given search request.
+     *
+     * @param searchRequest Input search request.
+     * @param inputCancellationSignal [CancellationSignal] received from the UI layer.
+     */
+    private fun getSearchResults(
+        searchRequest: SearchRequest,
+        inputCancellationSignal: CancellationSignal?,
+    ): PagingSource<MediaPageKey, Media> = runBlocking {
+        val availableProviders: List<Provider> = dataService.availableProviders.value
+        val contentResolver: ContentResolver = dataService.activeContentResolver.value
+        val config: PhotopickerConfiguration = photopickerConfiguration.value
+
+        return@runBlocking try {
+            val searchRequestId: Int =
+                getSearchRequestId(searchRequest, availableProviders, contentResolver, config)
+
+            searchResultsPagingSourceMutex.withLock {
+                if (
+                    searchResultsPagingSources.containsKey(searchRequestId) &&
+                        searchResultsPagingSources[searchRequestId]!!.invalid
+                ) {
+                    Log.d(
+                        SearchDataService.TAG,
+                        "A valid paging source is available for search request id " +
+                            "$searchRequestId. Not creating a new paging source.",
+                    )
+
+                    searchResultsPagingSources[searchRequestId]!!
+                } else {
+                    val cancellationSignal = inputCancellationSignal ?: CancellationSignal()
+
+                    val searchResultsPagingSource =
+                        SearchResultsPagingSource(
+                            searchRequestId = searchRequestId,
+                            contentResolver = contentResolver,
+                            availableProviders = availableProviders,
+                            mediaProviderClient = mediaProviderClient,
+                            dispatcher = dispatcher,
+                            configuration = config,
+                            cancellationSignal = cancellationSignal,
+                        )
+
+                    // Ensure that sync is cancelled when the paging source gets invalidated.
+                    searchResultsPagingSource.registerInvalidatedCallback {
+                        cancellationSignal.cancel()
+                    }
+
+                    Log.d(
+                        DataService.TAG,
+                        "Created a search results paging source that queries $availableProviders",
+                    )
+
+                    searchResultsPagingSources[searchRequestId] = searchResultsPagingSource
+                    searchResultsPagingSource
+                }
+            }
+        } catch (e: RuntimeException) {
+            Log.e(SearchDataService.TAG, "Could not create search results paging source", e)
+
+            // Create a [SearchResultsPagingSource] object so that the load method can handle the
+            // error in loading media items for null searchRequestId elegantly without crashing
+            // the app.
+            SearchResultsPagingSource(
+                searchRequestId = null,
+                contentResolver = contentResolver,
+                availableProviders = availableProviders,
+                mediaProviderClient = mediaProviderClient,
+                dispatcher = dispatcher,
+                configuration = config,
+                cancellationSignal = null,
+            )
+        }
+    }
+
+    /**
+     * Checks if this is a new search request in the current session.
+     * 1. If this is a new search requests, [MediaProvider] is notified with the new search request
+     *    and it creates and returns a search request id.
+     * 2. If this is not a new search request, previously caches search request id is returned.
+     */
+    private fun getSearchRequestId(
+        searchRequest: SearchRequest,
+        availableProviders: List<Provider>,
+        contentResolver: ContentResolver,
+        config: PhotopickerConfiguration,
+    ): Int = runBlocking {
+        searchResultsPagingSourceMutex.withLock {
+            if (searchRequestIdMap.containsKey(searchRequest)) {
+                Log.d(
+                    SearchDataService.TAG,
+                    "Search request id is available for search request $searchRequest. " +
+                        "Not creating a new search request id.",
+                )
+                searchRequestIdMap[searchRequest]!!
+            } else {
+                mediaProviderClient.createSearchRequest(
+                    searchRequest,
+                    availableProviders,
+                    contentResolver,
+                    config,
+                )
+            }
+        }
+    }
+}
diff --git a/photopicker/src/com/android/photopicker/features/search/data/SearchResultsPagingSource.kt b/photopicker/src/com/android/photopicker/features/search/data/SearchResultsPagingSource.kt
new file mode 100644
index 000000000..12938b520
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/search/data/SearchResultsPagingSource.kt
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.search.data
+
+import android.content.ContentResolver
+import android.os.CancellationSignal
+import android.util.Log
+import androidx.paging.PagingSource
+import androidx.paging.PagingState
+import com.android.photopicker.core.configuration.PhotopickerConfiguration
+import com.android.photopicker.data.MediaProviderClient
+import com.android.photopicker.data.model.Media
+import com.android.photopicker.data.model.MediaPageKey
+import com.android.photopicker.data.model.Provider
+import kotlinx.coroutines.CoroutineDispatcher
+import kotlinx.coroutines.withContext
+
+/**
+ * This [PagingSource] class is responsible to providing paginated search results from Picker
+ * Database by serving requests from Paging library.
+ *
+ * It sources data from a [ContentProvider] called [MediaProvider].
+ */
+class SearchResultsPagingSource(
+    private val searchRequestId: Int?,
+    private val contentResolver: ContentResolver,
+    private val availableProviders: List<Provider>,
+    private val mediaProviderClient: MediaProviderClient,
+    private val dispatcher: CoroutineDispatcher,
+    private val configuration: PhotopickerConfiguration,
+    private val cancellationSignal: CancellationSignal?,
+) : PagingSource<MediaPageKey, Media>() {
+    companion object {
+        val TAG: String = "PickerSearchPagingSource"
+    }
+
+    override suspend fun load(params: LoadParams<MediaPageKey>): LoadResult<MediaPageKey, Media> {
+        val pageKey = params.key ?: MediaPageKey()
+        val pageSize = params.loadSize
+        // Switch to the background thread from the main thread using [withContext].
+        val searchResultsPage =
+            withContext(dispatcher) {
+                try {
+                    if (availableProviders.isEmpty()) {
+                        throw IllegalArgumentException("No available providers found.")
+                    }
+
+                    checkNotNull(searchRequestId) { "Search request id is invalid" }
+
+                    mediaProviderClient.fetchSearchResults(
+                        searchRequestId,
+                        pageKey,
+                        pageSize,
+                        contentResolver,
+                        availableProviders,
+                        configuration,
+                        cancellationSignal,
+                    )
+                } catch (e: Exception) {
+                    Log.e(TAG, "Could not fetch search results page from Media provider", e)
+                    LoadResult.Error(e)
+                }
+            }
+
+        return searchResultsPage
+    }
+
+    override fun getRefreshKey(state: PagingState<MediaPageKey, Media>): MediaPageKey? = null
+}
diff --git a/photopicker/src/com/android/photopicker/features/search/inject/SearchActivityRetainedModule.kt b/photopicker/src/com/android/photopicker/features/search/inject/SearchActivityRetainedModule.kt
new file mode 100644
index 000000000..eff645ebd
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/search/inject/SearchActivityRetainedModule.kt
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.search.inject
+
+import android.util.Log
+import com.android.photopicker.core.Background
+import com.android.photopicker.core.configuration.ConfigurationManager
+import com.android.photopicker.core.events.Events
+import com.android.photopicker.core.user.UserMonitor
+import com.android.photopicker.data.DataService
+import com.android.photopicker.data.MediaProviderClient
+import com.android.photopicker.data.NotificationService
+import com.android.photopicker.features.search.data.SearchDataService
+import com.android.photopicker.features.search.data.SearchDataServiceImpl
+import dagger.Module
+import dagger.Provides
+import dagger.hilt.InstallIn
+import dagger.hilt.android.components.ActivityRetainedComponent
+import dagger.hilt.android.scopes.ActivityRetainedScoped
+import kotlinx.coroutines.CoroutineDispatcher
+import kotlinx.coroutines.CoroutineScope
+
+/**
+ * Injection Module for search feature specific dependencies, that provides access to objects bound
+ * to the ActivityRetainedScope.
+ *
+ * These can be injected by requesting the type with the [@ActivityRetainedScoped] qualifier.
+ *
+ * The module outlives the individual activities (and survives configuration changes), but is bound
+ * to a single Photopicker session.
+ *
+ * Note: Jobs that are launched in the [CoroutineScope] provided by this module will be
+ * automatically cancelled when the ActivityRetainedScope is ended.
+ */
+@Module
+@InstallIn(ActivityRetainedComponent::class)
+class SearchActivityRetainedModule {
+    companion object {
+        val TAG: String = "SearchActivityModule"
+    }
+
+    // Avoid initialization until it's actually needed.
+    private lateinit var searchDataService: SearchDataService
+
+    /** Provider for an implementation of [SearchDataService]. */
+    @Provides
+    @ActivityRetainedScoped
+    fun provideSearchDataService(
+        dataService: DataService,
+        userMonitor: UserMonitor,
+        configurationManager: ConfigurationManager,
+        @Background scope: CoroutineScope,
+        @Background dispatcher: CoroutineDispatcher,
+        notificationService: NotificationService,
+        events: Events,
+    ): SearchDataService {
+        if (::searchDataService.isInitialized) {
+            return searchDataService
+        } else {
+            Log.d(
+                SearchDataService.TAG,
+                "SearchDataService requested but not yet initialized." +
+                    " Initializing SearchDataService.",
+            )
+
+            searchDataService =
+                SearchDataServiceImpl(
+                    dataService,
+                    userMonitor.userStatus,
+                    configurationManager.configuration,
+                    scope,
+                    dispatcher,
+                    notificationService,
+                    MediaProviderClient(),
+                    events,
+                )
+            return searchDataService
+        }
+    }
+}
diff --git a/photopicker/src/com/android/photopicker/features/search/inject/SearchEmbeddedServiceModule.kt b/photopicker/src/com/android/photopicker/features/search/inject/SearchEmbeddedServiceModule.kt
new file mode 100644
index 000000000..409a40c23
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/search/inject/SearchEmbeddedServiceModule.kt
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.search.inject
+
+import android.util.Log
+import com.android.photopicker.core.Background
+import com.android.photopicker.core.EmbeddedServiceComponent
+import com.android.photopicker.core.SessionScoped
+import com.android.photopicker.core.configuration.ConfigurationManager
+import com.android.photopicker.core.events.Events
+import com.android.photopicker.core.user.UserMonitor
+import com.android.photopicker.data.DataService
+import com.android.photopicker.data.MediaProviderClient
+import com.android.photopicker.data.NotificationService
+import com.android.photopicker.features.search.data.SearchDataService
+import com.android.photopicker.features.search.data.SearchDataServiceImpl
+import dagger.Module
+import dagger.Provides
+import dagger.hilt.InstallIn
+import kotlinx.coroutines.CoroutineDispatcher
+import kotlinx.coroutines.CoroutineScope
+
+/**
+ * Injection Module for search feature specific dependencies, that provides access to objects bound
+ * to a single [EmbeddedServiceComponent].
+ *
+ * The module is bound to a single instance of the embedded Photopicker, and first obtained in the
+ * [Session].
+ *
+ * Note: Jobs that are launched in the [CoroutineScope] provided by this module will be
+ * automatically cancelled when the [EmbeddedLifecycle] provided by this module ends.
+ */
+@Module
+@InstallIn(EmbeddedServiceComponent::class)
+class SearchEmbeddedServiceModule {
+    companion object {
+        val TAG: String = "SearchEmbeddedModule"
+    }
+
+    // Avoid initialization until it's actually needed.
+    private lateinit var searchDataService: SearchDataService
+
+    /** Provider for an implementation of [SearchDataService]. */
+    @Provides
+    @SessionScoped
+    fun provideSearchDataService(
+        dataService: DataService,
+        userMonitor: UserMonitor,
+        configurationManager: ConfigurationManager,
+        @Background scope: CoroutineScope,
+        @Background dispatcher: CoroutineDispatcher,
+        notificationService: NotificationService,
+        events: Events,
+    ): SearchDataService {
+        if (::searchDataService.isInitialized) {
+            return searchDataService
+        } else {
+            Log.d(
+                SearchDataService.TAG,
+                "SearchDataService requested but not yet initialized." +
+                    " Initializing SearchDataService.",
+            )
+
+            searchDataService =
+                SearchDataServiceImpl(
+                    dataService,
+                    userMonitor.userStatus,
+                    configurationManager.configuration,
+                    scope,
+                    dispatcher,
+                    notificationService,
+                    MediaProviderClient(),
+                    events,
+                )
+            return searchDataService
+        }
+    }
+}
diff --git a/photopicker/src/com/android/photopicker/features/search/model/SearchEnabledState.kt b/photopicker/src/com/android/photopicker/features/search/model/SearchEnabledState.kt
new file mode 100644
index 000000000..f969e62d3
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/search/model/SearchEnabledState.kt
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.search.model
+
+/** This represents the search enabled states the current profile could have. */
+enum class SearchEnabledState {
+    /* Search is enabled for the current profile */
+    ENABLED,
+    /* Search is disabled in the current profile but enabled in other profiles */
+    ENABLED_IN_OTHER_PROFILES_ONLY,
+    /* Search is disabled in all profiles */
+    DISABLED,
+    /* Either the state of the current profile is unknown, or the current profile has search
+     * disabled and the state of other profile(s) is unknown. */
+    UNKNOWN,
+}
diff --git a/photopicker/src/com/android/photopicker/features/search/model/SearchRequest.kt b/photopicker/src/com/android/photopicker/features/search/model/SearchRequest.kt
new file mode 100644
index 000000000..3a1669546
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/search/model/SearchRequest.kt
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.search.model
+
+sealed interface SearchRequest {
+    data class SearchTextRequest(val searchText: String) : SearchRequest
+
+    data class SearchSuggestionRequest(val suggestion: SearchSuggestion) : SearchRequest
+}
diff --git a/photopicker/src/com/android/photopicker/features/search/model/SearchSuggestion.kt b/photopicker/src/com/android/photopicker/features/search/model/SearchSuggestion.kt
new file mode 100644
index 000000000..6ec8deb0b
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/search/model/SearchSuggestion.kt
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.search.model
+
+import android.net.Uri
+
+/**
+ * A data class that holds a Search Suggestion. Search suggestions could be suggestions shown to the
+ * user in zero state (when the user has not typed anything) or the suggestions shown to the user as
+ * they type a search text.
+ */
+data class SearchSuggestion(
+    /* Unique identifier for the search suggestions in cloud media providers. Not all suggestions
+     * have a unique media set id, for instance, history suggestions might be search text
+     * suggestions that don't have a media set ID. */
+    val mediaSetId: String?,
+    /* The authority of the source ContentProvider that provided this Search Suggestion. */
+    val authority: String,
+    /* Display text could be null sometimes for instance, if the suggestion type is a face */
+    val displayText: String?,
+    val type: SearchSuggestionType,
+    /* Unwrapped URI of the icon shown to the user along with the suggestion. If this is null,
+    please fallback to default icons based on the [SearchSuggestionType] of the suggestion. */
+    val iconUri: Uri?,
+) {
+    init {
+        require(type != SearchSuggestionType.FACE || iconUri != null) {
+            "Icon cannot be null for FACE type search suggestion"
+        }
+        require(type == SearchSuggestionType.FACE || displayText != null) {
+            "Display text cannot be null except for FACE type search suggestion"
+        }
+    }
+}
diff --git a/photopicker/src/com/android/photopicker/features/search/model/SearchSuggestionType.kt b/photopicker/src/com/android/photopicker/features/search/model/SearchSuggestionType.kt
new file mode 100644
index 000000000..7e5d06396
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/features/search/model/SearchSuggestionType.kt
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.search.model
+
+/**
+ * This enum holds all valid values of a search suggestion type. Search suggestion types could be
+ * decided by the cloud media provider or by the photo picker backend.
+ */
+enum class SearchSuggestionType {
+    TEXT,
+    FACE,
+    LOCATION,
+    DATE,
+    /* Suggestion saved in history. History suggestions could be based on searches that are
+     * triggered by selecting a CMP suggestion or by entering search text. */
+    HISTORY,
+    /* Suggestion for the Screenshots album */
+    SCREENSHOTS_ALBUM,
+    /* Suggestion for the Favorites album */
+    FAVORITES_ALBUM,
+    /* Suggestion for the Videos album */
+    VIDEOS_ALBUM,
+    /* All other albums */
+    ALBUM,
+}
diff --git a/photopicker/src/com/android/photopicker/features/selectionbar/SelectionBar.kt b/photopicker/src/com/android/photopicker/features/selectionbar/SelectionBar.kt
index a9153020a..37c552fd9 100644
--- a/photopicker/src/com/android/photopicker/features/selectionbar/SelectionBar.kt
+++ b/photopicker/src/com/android/photopicker/features/selectionbar/SelectionBar.kt
@@ -44,6 +44,8 @@ import androidx.compose.runtime.rememberCoroutineScope
 import androidx.compose.ui.Alignment
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.res.stringResource
+import androidx.compose.ui.semantics.contentDescription
+import androidx.compose.ui.semantics.semantics
 import androidx.compose.ui.unit.dp
 import androidx.lifecycle.compose.collectAsStateWithLifecycle
 import com.android.photopicker.R
@@ -60,6 +62,7 @@ import com.android.photopicker.core.features.Location
 import com.android.photopicker.core.features.LocationParams
 import com.android.photopicker.core.selection.LocalSelection
 import com.android.photopicker.core.theme.CustomAccentColorScheme
+import com.android.photopicker.util.LocalLocalizationHelper
 import kotlinx.coroutines.launch
 
 /* The size of spacers between elements on the bar */
@@ -83,6 +86,7 @@ fun SelectionBar(modifier: Modifier = Modifier, params: LocationParams) {
     // Collect selection to ensure this is recomposed when the selection is updated.
     val selection = LocalSelection.current
     val currentSelection by LocalSelection.current.flow.collectAsStateWithLifecycle()
+
     // For ACTION_USER_SELECT_IMAGES_FOR_APP selection bar should always be visible to allow users
     // the option to exit with zero selection i.e. revoking all grants.
     val visible =
@@ -93,7 +97,8 @@ fun SelectionBar(modifier: Modifier = Modifier, params: LocationParams) {
     val configuration = LocalPhotopickerConfiguration.current
     val events = LocalEvents.current
     val scope = rememberCoroutineScope()
-
+    val localizedCurrentSelectionSize =
+        LocalLocalizationHelper.current.getLocalizedCount(currentSelection.size)
     // The entire selection bar is hidden if the selection is empty, and
     // animates between visible states.
     AnimatedVisibility(
@@ -101,15 +106,8 @@ fun SelectionBar(modifier: Modifier = Modifier, params: LocationParams) {
         modifier = modifier,
         visible = visible,
         enter =
-            slideInVertically(
-                animationSpec = emphasizedDecelerate,
-                initialOffsetY = { it * 2 },
-            ),
-        exit =
-            slideOutVertically(
-                animationSpec = emphasizedAccelerate,
-                targetOffsetY = { it * 2 },
-            ),
+            slideInVertically(animationSpec = emphasizedDecelerate, initialOffsetY = { it * 2 }),
+        exit = slideOutVertically(animationSpec = emphasizedAccelerate, targetOffsetY = { it * 2 }),
     ) {
         Surface(
             modifier = Modifier.fillMaxWidth(),
@@ -124,9 +122,7 @@ fun SelectionBar(modifier: Modifier = Modifier, params: LocationParams) {
             ) {
 
                 // Deselect all button [Left side]
-                Row(
-                    verticalAlignment = Alignment.CenterVertically,
-                ) {
+                Row(verticalAlignment = Alignment.CenterVertically) {
                     IconButton(onClick = { scope.launch { selection.clear() } }) {
                         Icon(
                             Icons.Filled.Close,
@@ -138,17 +134,25 @@ fun SelectionBar(modifier: Modifier = Modifier, params: LocationParams) {
                         )
                     }
                     Spacer(Modifier.size(MEASUREMENT_DESELECT_SPACER_SIZE))
-                    Text("${currentSelection.size}", style = MaterialTheme.typography.headlineSmall)
+                    val selectionSizeDescription =
+                        stringResource(
+                            R.string.photopicker_selection_size_description,
+                            localizedCurrentSelectionSize,
+                        )
+                    Text(
+                        "$localizedCurrentSelectionSize",
+                        style = MaterialTheme.typography.headlineSmall,
+                        modifier =
+                            Modifier.semantics { contentDescription = selectionSizeDescription },
+                    )
                 }
 
                 // Primary and Secondary actions [Right side]
-                Row(
-                    verticalAlignment = Alignment.CenterVertically,
-                ) {
+                Row(verticalAlignment = Alignment.CenterVertically) {
                     LocalFeatureManager.current.composeLocation(
                         Location.SELECTION_BAR_SECONDARY_ACTION,
                         maxSlots = 1, // Only accept one additional action.
-                        modifier = Modifier
+                        modifier = Modifier,
                     )
                     Spacer(Modifier.size(MEASUREMENT_BUTTONS_SPACER_SIZE))
                     FilledTonalButton(
@@ -160,7 +164,7 @@ fun SelectionBar(modifier: Modifier = Modifier, params: LocationParams) {
                                         FeatureToken.SELECTION_BAR.token,
                                         configuration.sessionId,
                                         configuration.callingPackageUid ?: -1,
-                                        Telemetry.UiEvent.PICKER_CLICK_ADD_BUTTON
+                                        Telemetry.UiEvent.PICKER_CLICK_ADD_BUTTON,
                                     )
                                 )
                             }
@@ -180,7 +184,7 @@ fun SelectionBar(modifier: Modifier = Modifier, params: LocationParams) {
                                         .getTextColorForAccentComponentsIfDefinedOrElse(
                                             /* fallback */ MaterialTheme.colorScheme.onPrimary
                                         ),
-                            )
+                            ),
                     ) {
                         Text(stringResource(R.string.photopicker_done_button_label))
                     }
diff --git a/photopicker/src/com/android/photopicker/features/selectionbar/SelectionBarFeature.kt b/photopicker/src/com/android/photopicker/features/selectionbar/SelectionBarFeature.kt
index 9434b8e3a..cbc63aaa7 100644
--- a/photopicker/src/com/android/photopicker/features/selectionbar/SelectionBarFeature.kt
+++ b/photopicker/src/com/android/photopicker/features/selectionbar/SelectionBarFeature.kt
@@ -28,8 +28,10 @@ import com.android.photopicker.core.features.FeatureToken
 import com.android.photopicker.core.features.Location
 import com.android.photopicker.core.features.LocationParams
 import com.android.photopicker.core.features.PhotopickerUiFeature
+import com.android.photopicker.core.features.PrefetchResultKey
 import com.android.photopicker.core.features.Priority
 import com.android.photopicker.core.navigation.Route
+import kotlinx.coroutines.Deferred
 
 /** Feature class for the Photopicker's selection bar. */
 class SelectionBarFeature : PhotopickerUiFeature {
@@ -40,7 +42,10 @@ class SelectionBarFeature : PhotopickerUiFeature {
         // The selection bar is only shown when in multi-select mode. For single select,
         // the activity ends as soon as the first Media is selected, so this feature is
         // disabled to prevent it's animation for playing when the selection changes.
-        override fun isEnabled(config: PhotopickerConfiguration): Boolean {
+        override fun isEnabled(
+            config: PhotopickerConfiguration,
+            deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>>,
+        ): Boolean {
             if (config.runtimeEnv == PhotopickerRuntimeEnv.ACTIVITY) {
                 return config.selectionLimit > 1
             }
diff --git a/photopicker/src/com/android/photopicker/features/snackbar/SnackbarFeature.kt b/photopicker/src/com/android/photopicker/features/snackbar/SnackbarFeature.kt
index 9b99577dd..dc365f8ec 100644
--- a/photopicker/src/com/android/photopicker/features/snackbar/SnackbarFeature.kt
+++ b/photopicker/src/com/android/photopicker/features/snackbar/SnackbarFeature.kt
@@ -27,8 +27,10 @@ import com.android.photopicker.core.features.FeatureToken
 import com.android.photopicker.core.features.Location
 import com.android.photopicker.core.features.LocationParams
 import com.android.photopicker.core.features.PhotopickerUiFeature
+import com.android.photopicker.core.features.PrefetchResultKey
 import com.android.photopicker.core.features.Priority
 import com.android.photopicker.core.navigation.Route
+import kotlinx.coroutines.Deferred
 
 /** Feature class for the Photopicker's snackbar. */
 class SnackbarFeature : PhotopickerUiFeature {
@@ -36,7 +38,10 @@ class SnackbarFeature : PhotopickerUiFeature {
     companion object Registration : FeatureRegistration {
         override val TAG: String = "PhotopickerSnackbarFeature"
 
-        override fun isEnabled(config: PhotopickerConfiguration) = true
+        override fun isEnabled(
+            config: PhotopickerConfiguration,
+            deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>>,
+        ) = true
 
         override fun build(featureManager: FeatureManager) = SnackbarFeature()
     }
diff --git a/photopicker/src/com/android/photopicker/inject/ActivityModule.kt b/photopicker/src/com/android/photopicker/inject/ActivityModule.kt
index 77a8a9454..dc69be86a 100644
--- a/photopicker/src/com/android/photopicker/inject/ActivityModule.kt
+++ b/photopicker/src/com/android/photopicker/inject/ActivityModule.kt
@@ -41,6 +41,8 @@ import com.android.photopicker.data.DataServiceImpl
 import com.android.photopicker.data.MediaProviderClient
 import com.android.photopicker.data.NotificationService
 import com.android.photopicker.data.NotificationServiceImpl
+import com.android.photopicker.data.PrefetchDataService
+import com.android.photopicker.data.PrefetchDataServiceImpl
 import com.android.photopicker.data.model.Media
 import dagger.Module
 import dagger.Provides
@@ -83,6 +85,7 @@ class ActivityModule {
     private lateinit var featureManager: FeatureManager
     private lateinit var mainScope: CoroutineScope
     private lateinit var notificationService: NotificationService
+    private lateinit var prefetchDataService: PrefetchDataService
     private lateinit var selection: Selection<Media>
     private lateinit var userMonitor: UserMonitor
 
@@ -245,6 +248,8 @@ class ActivityModule {
     fun provideFeatureManager(
         @Background scope: CoroutineScope,
         configurationManager: ConfigurationManager,
+        prefetchDataService: PrefetchDataService,
+        @Background backgroundDispatcher: CoroutineDispatcher,
     ): FeatureManager {
 
         if (::featureManager.isInitialized) {
@@ -257,7 +262,12 @@ class ActivityModule {
             featureManager =
                 // Do not pass a set of FeatureRegistrations here to use the standard set of
                 // enabled features.
-                FeatureManager(configurationManager.configuration, scope)
+                FeatureManager(
+                    configuration = configurationManager.configuration,
+                    scope = scope,
+                    prefetchDataService = prefetchDataService,
+                    dispatcher = backgroundDispatcher,
+                )
             return featureManager
         }
     }
@@ -299,6 +309,21 @@ class ActivityModule {
         return notificationService
     }
 
+    @Provides
+    @ActivityRetainedScoped
+    fun providePrefetchDataService(): PrefetchDataService {
+
+        if (!::prefetchDataService.isInitialized) {
+            Log.d(
+                PrefetchDataService.TAG,
+                "PrefetchDataService requested but not yet initialized. " +
+                    "Initializing PrefetchDataService.",
+            )
+            prefetchDataService = PrefetchDataServiceImpl()
+        }
+        return prefetchDataService
+    }
+
     @Provides
     @ActivityRetainedScoped
     fun provideSelection(
diff --git a/photopicker/src/com/android/photopicker/inject/EmbeddedServiceModule.kt b/photopicker/src/com/android/photopicker/inject/EmbeddedServiceModule.kt
index a8fcd5f99..fd87f4a86 100644
--- a/photopicker/src/com/android/photopicker/inject/EmbeddedServiceModule.kt
+++ b/photopicker/src/com/android/photopicker/inject/EmbeddedServiceModule.kt
@@ -44,7 +44,10 @@ import com.android.photopicker.data.DataServiceImpl
 import com.android.photopicker.data.MediaProviderClient
 import com.android.photopicker.data.NotificationService
 import com.android.photopicker.data.NotificationServiceImpl
+import com.android.photopicker.data.PrefetchDataService
+import com.android.photopicker.data.PrefetchDataServiceImpl
 import com.android.photopicker.data.model.Media
+import com.android.photopicker.features.search.data.SearchDataService
 import dagger.Lazy
 import dagger.Module
 import dagger.Provides
@@ -85,6 +88,7 @@ class EmbeddedServiceModule {
     private lateinit var featureManager: FeatureManager
     private lateinit var mainScope: CoroutineScope
     private lateinit var notificationService: NotificationService
+    private lateinit var prefetchDataService: PrefetchDataService
     private lateinit var selection: Selection<Media>
     private lateinit var userMonitor: UserMonitor
 
@@ -115,6 +119,7 @@ class EmbeddedServiceModule {
         selection: Lazy<Selection<Media>>,
         userMonitor: Lazy<UserMonitor>,
         dataService: Lazy<DataService>,
+        searchDataService: Lazy<SearchDataService>,
         events: Lazy<Events>,
     ): EmbeddedViewModelFactory {
         if (::embeddedViewModelFactory.isInitialized) {
@@ -127,6 +132,7 @@ class EmbeddedServiceModule {
                     configurationManager,
                     bannerManager,
                     dataService,
+                    searchDataService,
                     events,
                     featureManager,
                     selection,
@@ -309,6 +315,8 @@ class EmbeddedServiceModule {
     fun provideFeatureManager(
         @SessionScoped @Background scope: CoroutineScope,
         @SessionScoped configurationManager: ConfigurationManager,
+        prefetchDataService: PrefetchDataService,
+        @Background backgroundDispatcher: CoroutineDispatcher,
     ): FeatureManager {
 
         if (::featureManager.isInitialized) {
@@ -321,7 +329,12 @@ class EmbeddedServiceModule {
             featureManager =
                 // Do not pass a set of FeatureRegistrations here to use the standard set of
                 // enabled features.
-                FeatureManager(configurationManager.configuration, scope)
+                FeatureManager(
+                    configuration = configurationManager.configuration,
+                    scope = scope,
+                    prefetchDataService = prefetchDataService,
+                    dispatcher = backgroundDispatcher,
+                )
             return featureManager
         }
     }
@@ -374,6 +387,21 @@ class EmbeddedServiceModule {
         return notificationService
     }
 
+    @Provides
+    @SessionScoped
+    fun providePrefetchDataService(): PrefetchDataService {
+
+        if (!::prefetchDataService.isInitialized) {
+            Log.d(
+                PrefetchDataService.TAG,
+                "PrefetchDataService requested but not yet initialized. " +
+                    "Initializing PrefetchDataService.",
+            )
+            prefetchDataService = PrefetchDataServiceImpl()
+        }
+        return prefetchDataService
+    }
+
     @Provides
     @SessionScoped
     fun provideSelection(
diff --git a/photopicker/src/com/android/photopicker/util/LocalLocalizationHelper.kt b/photopicker/src/com/android/photopicker/util/LocalLocalizationHelper.kt
new file mode 100644
index 000000000..cb9a837a5
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/util/LocalLocalizationHelper.kt
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.util
+
+import androidx.compose.runtime.compositionLocalOf
+
+/** Provider for fetching the [LocalizationHelper] inside of composables. */
+val LocalLocalizationHelper = compositionLocalOf { LocalizationHelper() }
diff --git a/photopicker/src/com/android/photopicker/util/LocalizationHelper.kt b/photopicker/src/com/android/photopicker/util/LocalizationHelper.kt
new file mode 100644
index 000000000..65c9a4f2f
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/util/LocalizationHelper.kt
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.util
+
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.remember
+import androidx.compose.ui.platform.LocalConfiguration
+import java.text.DateFormat
+import java.text.NumberFormat
+import java.text.SimpleDateFormat
+import java.util.Locale
+
+/**
+ * A helper class for localization tasks
+ *
+ * @property locale The locale to use for localization. Defaults to the device's default locale.
+ */
+data class LocalizationHelper(private val locale: Locale = Locale.getDefault()) {
+
+    private val numberFormat = NumberFormat.getInstance(locale)
+
+    /**
+     * Returns a localized string representation of the given count.
+     *
+     * @param count The count to format.
+     * @return The localized string representation of the count.
+     */
+    fun getLocalizedCount(count: Int): String {
+        return numberFormat.format(count)
+    }
+
+    /**
+     * Returns a localized date and time formatter.
+     *
+     * @param dateStyle The style of the date format (e.g., DateFormat.MEDIUM).
+     * @param timeStyle The style of the time format (e.g., DateFormat.SHORT).
+     * @return A DateFormat instance with the specified styles and locale.
+     */
+    fun getLocalizedDateTimeFormatter(dateStyle: Int, timeStyle: Int): DateFormat {
+        return SimpleDateFormat.getDateTimeInstance(dateStyle, timeStyle, locale)
+    }
+}
+
+/**
+ * Provides a [LocalizationHelper] instance that is remembered and updated when the locale changes.
+ */
+@Composable
+fun rememberLocalizationHelper(): LocalizationHelper {
+    val currentLocale = LocalConfiguration.current.locales.get(0) ?: Locale.getDefault()
+    return remember(currentLocale) { LocalizationHelper(locale = currentLocale) }
+}
diff --git a/photopicker/src/com/android/photopicker/util/MapOfDeferredWithTimeout.kt b/photopicker/src/com/android/photopicker/util/MapOfDeferredWithTimeout.kt
new file mode 100644
index 000000000..776e59f60
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/util/MapOfDeferredWithTimeout.kt
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.util
+
+import android.util.Log
+import kotlinx.coroutines.Deferred
+import kotlinx.coroutines.async
+import kotlinx.coroutines.coroutineScope
+import kotlinx.coroutines.withTimeout
+
+private const val TAG = "MapOfDeferredWithTimeout"
+
+/**
+ * A Suspend function that accepts a (key -> lambda) map and a timeout.
+ *
+ * Each lambda runs in parallel using [async] and a (key -> [Deferred] result) map is returned by
+ * this method.
+ *
+ * If any [async] task runs for longer than the provided timeout, it will automatically be cancelled
+ * and the result will be set to null.
+ *
+ * If any async task throws an error, it will be swallowed and the result will be set to null.
+ */
+suspend fun <A, B> mapOfDeferredWithTimeout(
+    inputMap: Map<A, suspend (B) -> Any?>,
+    input: B,
+    timeoutMillis: Long,
+): Map<A, Deferred<Any?>> = coroutineScope {
+    inputMap
+        .map<A, suspend (B) -> Any?, Pair<A, Deferred<Any?>>> { (key, block) ->
+            key to
+                async {
+                    try {
+                        withTimeout(timeoutMillis) {
+                            Log.d(TAG, "Fetching result for : $key")
+                            val result = block(input)
+                            Log.d(TAG, "Finished fetching result for : $key val: $result")
+                            result
+                        }
+                    } catch (e: RuntimeException) {
+                        Log.e(TAG, "An error occurred in fetching result for key: $key")
+                        null
+                    }
+                }
+        }
+        .toMap()
+}
diff --git a/photopicker/src/com/android/photopicker/util/TouchSlopDetector.kt b/photopicker/src/com/android/photopicker/util/TouchSlopDetector.kt
new file mode 100644
index 000000000..1105390f7
--- /dev/null
+++ b/photopicker/src/com/android/photopicker/util/TouchSlopDetector.kt
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.util
+
+import androidx.compose.foundation.gestures.Orientation
+import androidx.compose.ui.geometry.Offset
+import androidx.compose.ui.input.pointer.PointerInputChange
+import kotlin.math.absoluteValue
+import kotlin.math.sign
+
+/** A utility class to handle calculating pointer touchSlop for the provided [Orientation]. */
+class TouchSlopDetector(val orientation: Orientation? = null) {
+
+    fun Offset.mainAxis() = if (orientation == Orientation.Horizontal) x else y
+
+    fun Offset.crossAxis() = if (orientation == Orientation.Horizontal) y else x
+
+    /** The accumulation of drag deltas in this detector. */
+    private var totalPositionChange: Offset = Offset.Zero
+
+    /**
+     * Adds [dragEvent] to this detector. If the accumulated position changes crosses the touch slop
+     * provided by [touchSlop], this method will return the post slop offset, that is the total
+     * accumulated delta change minus the touch slop value, otherwise this will return
+     * [Offset.Unspecified].
+     */
+    fun addPointerInputChange(dragEvent: PointerInputChange, touchSlop: Float): Offset {
+        val currentPosition = dragEvent.position
+        val previousPosition = dragEvent.previousPosition
+        val positionChange = currentPosition - previousPosition
+        totalPositionChange += positionChange
+
+        val inDirection =
+            if (orientation == null) {
+                totalPositionChange.getDistance()
+            } else {
+                totalPositionChange.mainAxis().absoluteValue
+            }
+
+        val hasCrossedSlop = inDirection >= touchSlop
+
+        return if (hasCrossedSlop) {
+            calculatePostSlopOffset(touchSlop)
+        } else {
+            Offset.Unspecified
+        }
+    }
+
+    /** Resets the accumulator associated with this detector. */
+    fun reset() {
+        totalPositionChange = Offset.Zero
+    }
+
+    /**
+     * Calculates the offset beyond the [touchSlop] for events passed to this detector.
+     *
+     * NOTE: Before calling this there should be a check if the slop has been crossed, if the slop
+     * has not been crossed this value will be inaccurate.
+     */
+    private fun calculatePostSlopOffset(touchSlop: Float): Offset {
+        return if (orientation == null) {
+            val touchSlopOffset =
+                totalPositionChange / totalPositionChange.getDistance() * touchSlop
+            // update postSlopOffset
+            totalPositionChange - touchSlopOffset
+        } else {
+            val finalMainAxisChange =
+                totalPositionChange.mainAxis() - (sign(totalPositionChange.mainAxis()) * touchSlop)
+            val finalCrossAxisChange = totalPositionChange.crossAxis()
+            if (orientation == Orientation.Horizontal) {
+                Offset(finalMainAxisChange, finalCrossAxisChange)
+            } else {
+                Offset(finalCrossAxisChange, finalMainAxisChange)
+            }
+        }
+    }
+}
diff --git a/photopicker/src/com/android/photopicker/util/UtilityMethods.kt b/photopicker/src/com/android/photopicker/util/UtilityMethods.kt
index ac3f39e21..873a1789d 100644
--- a/photopicker/src/com/android/photopicker/util/UtilityMethods.kt
+++ b/photopicker/src/com/android/photopicker/util/UtilityMethods.kt
@@ -16,6 +16,31 @@
 
 package com.android.photopicker.util
 
+import android.content.Context
+import android.graphics.BitmapFactory
+import android.net.Uri
+import android.provider.MediaStore.Files.FileColumns._SPECIAL_FORMAT_ANIMATED_WEBP
+import android.provider.MediaStore.Files.FileColumns._SPECIAL_FORMAT_GIF
+import android.provider.MediaStore.Files.FileColumns._SPECIAL_FORMAT_MOTION_PHOTO
+import android.text.format.DateUtils
+import android.util.Log
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.LaunchedEffect
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.runtime.remember
+import androidx.compose.runtime.setValue
+import androidx.compose.ui.graphics.ImageBitmap
+import androidx.compose.ui.graphics.asImageBitmap
+import androidx.compose.ui.platform.LocalContext
+import androidx.compose.ui.res.stringResource
+import com.android.photopicker.R
+import com.android.photopicker.data.model.Media
+import java.text.DateFormat
+import java.util.Date
+import kotlinx.coroutines.CoroutineDispatcher
+import kotlinx.coroutines.withContext
+
 /**
  * Custom hashing function to generate a stable hash code value for any object given the input
  * values.
@@ -35,3 +60,75 @@ fun hashCodeOf(vararg values: Any?) =
             if (value != null && value is Array<*>) value.contentHashCode() else value.hashCode()
         (acc * 31) + hashCode
     }
+
+/**
+ * Retrieves an ImageBitmap from a given URI.
+ *
+ * This function attempts to open an input stream from the provided URI and decode it into an
+ * ImageBitmap using BitmapFactory. If successful, the resulting ImageBitmap is returned. If any
+ * exception occurs during the process (e.g., the URI is invalid, the file doesn't exist, or there
+ * are permission issues), null is returned.
+ *
+ * @param context A context required to get the content resolver
+ * @param uri The URI of the icon to load.
+ * @return The ImageBitmap if successfully loaded, otherwise null.
+ */
+fun getBitmapFromUri(context: Context, uri: Uri): ImageBitmap? {
+    return try {
+        context.contentResolver.openInputStream(uri).use { inputStream ->
+            BitmapFactory.decodeStream(inputStream)?.asImageBitmap()
+        }
+    } catch (exception: Exception) {
+        // Handle exceptions
+        Log.e("getBitmapFromUri", "Unable to get Image as bitmap ", exception)
+        null
+    }
+}
+
+/**
+ * Composable function that loads image bitmap from the provided URI asynchronously using
+ * [LaunchedEffect] and [withContext] to avoid blocking the main thread.
+ *
+ * @param uri The URI of the image to load.
+ * @param dispatcher - A CoroutineDispatcher for running this task
+ * @return The loaded [ImageBitmap], or null if an error occurred while loading.
+ */
+@Composable
+fun rememberBitmapFromUri(uri: Uri, dispatcher: CoroutineDispatcher): ImageBitmap? {
+    var bitmap: ImageBitmap? by remember { mutableStateOf(null) }
+    val context = LocalContext.current
+    LaunchedEffect(uri) { withContext(dispatcher) { bitmap = getBitmapFromUri(context, uri) } }
+    return bitmap
+}
+
+/**
+ * Generates a content description for a given media item (photo, video, GIF, etc.). This
+ * description is intended to be used for accessibility purposes, providing information about the
+ * media to users with visual impairments.
+ *
+ * @param media The media item for which to generate a content description.
+ * @param dateFormat The `DateFormat` object to use for formatting the date the media was taken.
+ * @return A string containing the content description for the media.
+ */
+@Composable
+fun getMediaContentDescription(media: Media, dateFormat: DateFormat): String {
+    val dateTaken = dateFormat.format(Date(media.dateTakenMillisLong))
+    if (media is Media.Video) {
+        val duration = DateUtils.formatElapsedTime(media.duration / 1000L)
+        return stringResource(R.string.photopicker_video_item_content_desc, dateTaken, duration)
+    }
+    val itemType: String =
+        when (media.standardMimeTypeExtension) {
+            _SPECIAL_FORMAT_GIF,
+            _SPECIAL_FORMAT_ANIMATED_WEBP -> {
+                stringResource(R.string.photopicker_gif)
+            }
+            _SPECIAL_FORMAT_MOTION_PHOTO -> {
+                stringResource(R.string.photopicker_motion_photo)
+            }
+            else -> {
+                stringResource(R.string.photopicker_photo)
+            }
+        }
+    return stringResource(R.string.photopicker_item_content_desc, itemType, dateTaken)
+}
diff --git a/photopicker/tests/AndroidManifest.xml b/photopicker/tests/AndroidManifest.xml
index 5a6d1d266..379d6c204 100644
--- a/photopicker/tests/AndroidManifest.xml
+++ b/photopicker/tests/AndroidManifest.xml
@@ -48,7 +48,7 @@
 
     <!-- A test provider to allow the test application to issue uri grants for selected media-->
     <provider
-      android:name="com.android.photopicker.tests.utils.StubProvider"
+      android:name="com.android.photopicker.util.test.StubProvider"
       android:authorities="photopickertest"
       android:exported="false"
       android:grantUriPermissions="true"
diff --git a/photopicker/tests/src/com/android/photopicker/MainActivityTest.kt b/photopicker/tests/src/com/android/photopicker/MainActivityTest.kt
index 6296a42d3..277af9a9a 100644
--- a/photopicker/tests/src/com/android/photopicker/MainActivityTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/MainActivityTest.kt
@@ -45,9 +45,9 @@ import com.android.photopicker.core.events.Events
 import com.android.photopicker.core.selection.Selection
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.inject.PhotopickerTestModule
-import com.android.photopicker.tests.utils.StubProvider
-import com.android.photopicker.tests.utils.mockito.mockSystemService
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.StubProvider
+import com.android.photopicker.util.test.mockSystemService
+import com.android.photopicker.util.test.whenever
 import com.google.common.truth.Truth.assertWithMessage
 import dagger.Lazy
 import dagger.Module
@@ -76,11 +76,7 @@ import org.mockito.Mockito.anyString
 import org.mockito.MockitoAnnotations
 
 /** This test class will run Photopicker's actual MainActivity. */
-@UninstallModules(
-    ApplicationModule::class,
-    ActivityModule::class,
-    EmbeddedServiceModule::class,
-)
+@UninstallModules(ApplicationModule::class, ActivityModule::class, EmbeddedServiceModule::class)
 @HiltAndroidTest
 @OptIn(ExperimentalCoroutinesApi::class)
 class MainActivityTest {
@@ -134,7 +130,7 @@ class MainActivityTest {
             mockContext.createPackageContextAsUser(
                 anyString(),
                 anyInt(),
-                any(UserHandle::class.java)
+                any(UserHandle::class.java),
             )
         ) {
             mockContext
@@ -150,7 +146,7 @@ class MainActivityTest {
                     .setComponent(
                         ComponentName(
                             InstrumentationRegistry.getInstrumentation().targetContext,
-                            MainActivity::class.java
+                            MainActivity::class.java,
                         )
                     )
             with(ActivityScenario.launch<MainActivity>(intent)) {
@@ -170,7 +166,7 @@ class MainActivityTest {
                 .setComponent(
                     ComponentName(
                         InstrumentationRegistry.getInstrumentation().targetContext,
-                        MainActivity::class.java
+                        MainActivity::class.java,
                     )
                 )
         with(launchActivityForResult<MainActivity>(intent)) {
@@ -200,7 +196,7 @@ class MainActivityTest {
                 .setComponent(
                     ComponentName(
                         InstrumentationRegistry.getInstrumentation().targetContext,
-                        MainActivity::class.java
+                        MainActivity::class.java,
                     )
                 )
                 .putExtra(Intent.EXTRA_UID, Process.myUid())
@@ -239,7 +235,7 @@ class MainActivityTest {
                 .setComponent(
                     ComponentName(
                         InstrumentationRegistry.getInstrumentation().targetContext,
-                        MainActivity::class.java
+                        MainActivity::class.java,
                     )
                 )
 
@@ -283,7 +279,7 @@ class MainActivityTest {
                 .setComponent(
                     ComponentName(
                         InstrumentationRegistry.getInstrumentation().targetContext,
-                        MainActivity::class.java
+                        MainActivity::class.java,
                     )
                 )
 
@@ -327,7 +323,7 @@ class MainActivityTest {
                 .setComponent(
                     ComponentName(
                         InstrumentationRegistry.getInstrumentation().targetContext,
-                        MainActivity::class.java
+                        MainActivity::class.java,
                     )
                 )
 
@@ -372,7 +368,7 @@ class MainActivityTest {
                 .setComponent(
                     ComponentName(
                         InstrumentationRegistry.getInstrumentation().targetContext,
-                        MainActivity::class.java
+                        MainActivity::class.java,
                     )
                 )
 
diff --git a/photopicker/tests/src/com/android/photopicker/PhotopickerDeviceConfigReceiverTest.kt b/photopicker/tests/src/com/android/photopicker/PhotopickerDeviceConfigReceiverTest.kt
index 22e824e4e..85ce9ea5f 100644
--- a/photopicker/tests/src/com/android/photopicker/PhotopickerDeviceConfigReceiverTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/PhotopickerDeviceConfigReceiverTest.kt
@@ -28,8 +28,8 @@ import androidx.test.filters.SmallTest
 import androidx.test.platform.app.InstrumentationRegistry
 import com.android.photopicker.core.configuration.NAMESPACE_MEDIAPROVIDER
 import com.android.photopicker.core.configuration.TestDeviceConfigProxyImpl
-import com.android.photopicker.tests.utils.mockito.nonNullableEq
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.nonNullableEq
+import com.android.photopicker.util.test.whenever
 import org.junit.Before
 import org.junit.Test
 import org.junit.runner.RunWith
diff --git a/photopicker/tests/src/com/android/photopicker/PhotopickerFeatureBaseTest.kt b/photopicker/tests/src/com/android/photopicker/PhotopickerFeatureBaseTest.kt
index c03825cef..81237c46a 100644
--- a/photopicker/tests/src/com/android/photopicker/PhotopickerFeatureBaseTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/PhotopickerFeatureBaseTest.kt
@@ -44,8 +44,8 @@ import com.android.photopicker.core.selection.LocalSelection
 import com.android.photopicker.core.selection.Selection
 import com.android.photopicker.core.theme.PhotopickerTheme
 import com.android.photopicker.data.model.Media
-import com.android.photopicker.tests.utils.mockito.mockSystemService
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.mockSystemService
+import com.android.photopicker.util.test.whenever
 import dagger.Lazy
 import kotlinx.coroutines.flow.Flow
 import kotlinx.coroutines.flow.flow
@@ -86,7 +86,7 @@ abstract class PhotopickerFeatureBaseTest {
         mockContext: Context,
         mockUserManager: UserManager,
         contentResolver: ContentResolver,
-        mockPackageManager: PackageManager
+        mockPackageManager: PackageManager,
     ) {
         // Stub out UserManager with the mock
         mockSystemService(mockContext, UserManager::class.java) { mockUserManager }
@@ -123,7 +123,7 @@ abstract class PhotopickerFeatureBaseTest {
             mockContext.createPackageContextAsUser(
                 anyString(),
                 anyInt(),
-                any(UserHandle::class.java)
+                any(UserHandle::class.java),
             )
         ) {
             mockContext
@@ -140,7 +140,7 @@ abstract class PhotopickerFeatureBaseTest {
         selection: Selection<Media>,
         events: Events,
         navController: TestNavHostController = createNavController(),
-        disruptiveDataFlow: Flow<Int> = flow { emit(0) }
+        disruptiveDataFlow: Flow<Int> = flow { emit(0) },
     ) {
         val photopickerConfiguration by
             configurationManager.get().configuration.collectAsStateWithLifecycle()
@@ -150,7 +150,7 @@ abstract class PhotopickerFeatureBaseTest {
             LocalSelection provides selection,
             LocalPhotopickerConfiguration provides photopickerConfiguration,
             LocalNavController provides navController,
-            LocalEvents provides events
+            LocalEvents provides events,
         ) {
             PhotopickerTheme(config = photopickerConfiguration) {
                 PhotopickerMain(disruptiveDataNotification = disruptiveDataFlow)
diff --git a/photopicker/tests/src/com/android/photopicker/core/PhotopickerAppTest.kt b/photopicker/tests/src/com/android/photopicker/core/PhotopickerAppTest.kt
index 139dac74c..5ce7a6936 100644
--- a/photopicker/tests/src/com/android/photopicker/core/PhotopickerAppTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/core/PhotopickerAppTest.kt
@@ -38,10 +38,10 @@ import com.android.photopicker.data.model.Media
 import com.android.photopicker.extensions.navigateToAlbumGrid
 import com.android.photopicker.features.PhotopickerFeatureBaseTest
 import com.android.photopicker.inject.PhotopickerTestModule
-import com.android.photopicker.test.utils.MockContentProviderWrapper
 import com.android.photopicker.tests.HiltTestActivity
-import com.android.photopicker.tests.utils.StubProvider
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.MockContentProviderWrapper
+import com.android.photopicker.util.test.StubProvider
+import com.android.photopicker.util.test.whenever
 import com.google.common.truth.Truth.assertWithMessage
 import dagger.Lazy
 import dagger.Module
@@ -68,11 +68,7 @@ import org.mockito.Mockito.any
 import org.mockito.MockitoAnnotations
 
 /** This test class will run Photopicker's actual MainActivity. */
-@UninstallModules(
-    ApplicationModule::class,
-    ActivityModule::class,
-    EmbeddedServiceModule::class,
-)
+@UninstallModules(ApplicationModule::class, ActivityModule::class, EmbeddedServiceModule::class)
 @HiltAndroidTest
 @OptIn(ExperimentalCoroutinesApi::class)
 class PhotopickerAppTest : PhotopickerFeatureBaseTest() {
@@ -146,7 +142,7 @@ class PhotopickerAppTest : PhotopickerFeatureBaseTest() {
                             initial = 0
                         ) { prev, _ ->
                             prev + 1
-                        }
+                        },
                 )
             }
 
diff --git a/photopicker/tests/src/com/android/photopicker/core/banners/BannerManagerImplTest.kt b/photopicker/tests/src/com/android/photopicker/core/banners/BannerManagerImplTest.kt
index 05415e26f..08de0b7a2 100644
--- a/photopicker/tests/src/com/android/photopicker/core/banners/BannerManagerImplTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/core/banners/BannerManagerImplTest.kt
@@ -41,15 +41,18 @@ import com.android.photopicker.core.database.DatabaseManagerTestImpl
 import com.android.photopicker.core.events.generatePickerSessionId
 import com.android.photopicker.core.features.FeatureManager
 import com.android.photopicker.core.features.FeatureRegistration
+import com.android.photopicker.core.features.PrefetchResultKey
 import com.android.photopicker.core.user.UserMonitor
 import com.android.photopicker.core.user.UserProfile
 import com.android.photopicker.data.TestDataServiceImpl
+import com.android.photopicker.data.TestPrefetchDataService
 import com.android.photopicker.features.highpriorityuifeature.HighPriorityUiFeature
 import com.android.photopicker.features.simpleuifeature.SimpleUiFeature
-import com.android.photopicker.tests.utils.mockito.mockSystemService
-import com.android.photopicker.tests.utils.mockito.nonNullableEq
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.mockSystemService
+import com.android.photopicker.util.test.nonNullableEq
+import com.android.photopicker.util.test.whenever
 import com.google.common.truth.Truth.assertWithMessage
+import kotlinx.coroutines.Deferred
 import kotlinx.coroutines.ExperimentalCoroutinesApi
 import kotlinx.coroutines.test.StandardTestDispatcher
 import kotlinx.coroutines.test.advanceTimeBy
@@ -191,6 +194,7 @@ class BannerManagerImplTest {
                 FeatureManager(
                     configurationManager.configuration,
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     emptySet<FeatureRegistration>(),
                 )
 
@@ -245,6 +249,7 @@ class BannerManagerImplTest {
                 FeatureManager(
                     configurationManager.configuration,
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     setOf(SimpleUiFeature.Registration),
                 )
             val databaseManager = DatabaseManagerTestImpl()
@@ -303,6 +308,7 @@ class BannerManagerImplTest {
                 FeatureManager(
                     configurationManager.configuration,
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     setOf(SimpleUiFeature.Registration),
                 )
             val databaseManager = DatabaseManagerTestImpl()
@@ -386,6 +392,7 @@ class BannerManagerImplTest {
                 FeatureManager(
                     configurationManager.configuration,
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     setOf(SimpleUiFeature.Registration, HighPriorityUiFeature.Registration),
                 )
             val databaseManager = DatabaseManagerTestImpl()
@@ -459,6 +466,7 @@ class BannerManagerImplTest {
                 FeatureManager(
                     configurationManager.configuration,
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     setOf(SimpleUiFeature.Registration, HighPriorityUiFeature.Registration),
                 )
             val databaseManager = DatabaseManagerTestImpl()
@@ -520,6 +528,7 @@ class BannerManagerImplTest {
                 FeatureManager(
                     configurationManager.configuration,
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     setOf(SimpleUiFeature.Registration, HighPriorityUiFeature.Registration),
                 )
             val databaseManager = DatabaseManagerTestImpl()
@@ -589,6 +598,7 @@ class BannerManagerImplTest {
                 FeatureManager(
                     configurationManager.configuration,
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     setOf(SimpleUiFeature.Registration, HighPriorityUiFeature.Registration),
                 )
             val databaseManager = DatabaseManagerTestImpl()
@@ -653,6 +663,7 @@ class BannerManagerImplTest {
                 FeatureManager(
                     configurationManager.configuration,
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     setOf(SimpleUiFeature.Registration, HighPriorityUiFeature.Registration),
                 )
             val databaseManager = DatabaseManagerTestImpl()
@@ -723,6 +734,7 @@ class BannerManagerImplTest {
                 FeatureManager(
                     configurationManager.configuration,
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     setOf(SimpleUiFeature.Registration, HighPriorityUiFeature.Registration),
                 )
             val databaseManager = DatabaseManagerTestImpl()
@@ -790,7 +802,10 @@ class BannerManagerImplTest {
                 object : FeatureRegistration {
                     override val TAG = "MockedFeature"
 
-                    override fun isEnabled(config: PhotopickerConfiguration) = true
+                    override fun isEnabled(
+                        config: PhotopickerConfiguration,
+                        deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>>,
+                    ) = true
 
                     override fun build(featureManager: FeatureManager) = mockSimpleUiFeature
                 }
@@ -808,6 +823,7 @@ class BannerManagerImplTest {
                 FeatureManager(
                     configurationManager.configuration,
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     setOf(mockRegistration),
                 )
             val databaseManager = DatabaseManagerTestImpl()
@@ -888,6 +904,7 @@ class BannerManagerImplTest {
                 FeatureManager(
                     configurationManager.configuration,
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     setOf(SimpleUiFeature.Registration),
                 )
             val databaseManager = DatabaseManagerTestImpl()
diff --git a/photopicker/tests/src/com/android/photopicker/core/banners/BannerTest.kt b/photopicker/tests/src/com/android/photopicker/core/banners/BannerTest.kt
index b09f19362..46b5d6bde 100644
--- a/photopicker/tests/src/com/android/photopicker/core/banners/BannerTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/core/banners/BannerTest.kt
@@ -46,6 +46,7 @@ import com.android.photopicker.core.events.LocalEvents
 import com.android.photopicker.core.events.Telemetry.BannerType
 import com.android.photopicker.core.events.Telemetry.UserBannerInteraction
 import com.android.photopicker.core.features.FeatureManager
+import com.android.photopicker.data.TestPrefetchDataService
 import com.google.common.truth.Truth.assertWithMessage
 import kotlinx.coroutines.ExperimentalCoroutinesApi
 import kotlinx.coroutines.flow.toList
@@ -129,6 +130,7 @@ class BannerTest {
             FeatureManager(
                 configuration = provideTestConfigurationFlow(scope = this.backgroundScope),
                 scope = this.backgroundScope,
+                TestPrefetchDataService(),
             )
 
         val events =
@@ -177,6 +179,7 @@ class BannerTest {
             FeatureManager(
                 configuration = provideTestConfigurationFlow(scope = this.backgroundScope),
                 scope = this.backgroundScope,
+                TestPrefetchDataService(),
             )
 
         val events =
@@ -227,6 +230,7 @@ class BannerTest {
             FeatureManager(
                 configuration = provideTestConfigurationFlow(scope = this.backgroundScope),
                 scope = this.backgroundScope,
+                TestPrefetchDataService(),
             )
 
         val events =
@@ -257,6 +261,7 @@ class BannerTest {
             FeatureManager(
                 configuration = provideTestConfigurationFlow(scope = this.backgroundScope),
                 scope = this.backgroundScope,
+                TestPrefetchDataService(),
             )
 
         val events =
@@ -310,6 +315,7 @@ class BannerTest {
             FeatureManager(
                 configuration = provideTestConfigurationFlow(scope = this.backgroundScope),
                 scope = this.backgroundScope,
+                TestPrefetchDataService(),
             )
 
         val events =
diff --git a/photopicker/tests/src/com/android/photopicker/core/components/mediagrid/MediaGridTest.kt b/photopicker/tests/src/com/android/photopicker/core/components/mediagrid/MediaGridTest.kt
index 147994c62..1d89cc1ad 100644
--- a/photopicker/tests/src/com/android/photopicker/core/components/mediagrid/MediaGridTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/core/components/mediagrid/MediaGridTest.kt
@@ -86,8 +86,8 @@ import com.android.photopicker.extensions.insertMonthSeparators
 import com.android.photopicker.extensions.toMediaGridItemFromAlbum
 import com.android.photopicker.extensions.toMediaGridItemFromMedia
 import com.android.photopicker.inject.PhotopickerTestModule
-import com.android.photopicker.test.utils.MockContentProviderWrapper
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.MockContentProviderWrapper
+import com.android.photopicker.util.test.whenever
 import com.google.common.truth.Truth.assertWithMessage
 import dagger.Module
 import dagger.hilt.InstallIn
@@ -193,6 +193,8 @@ class MediaGridTest {
     private val FIRST_SEPARATOR_LABEL = "First"
     private val SECOND_SEPARATOR_LABEL = "Second"
 
+    private val MEDIA_ITEM_CONTENT_DESCRIPTION_SUBSTRING = "taken on"
+
     /* A small MediaGridItem list that includes two Separators with three MediaItems in between */
     private val dataWithSeparators =
         buildList<MediaGridItem>() {
@@ -270,7 +272,7 @@ class MediaGridTest {
     private fun initEmbeddedStates() {
         if (SdkLevel.isAtLeastU()) {
             @Suppress("DEPRECATION")
-            whenever(mockSurfaceControlViewHost.transferTouchGestureToHost()) { true }
+            (whenever(mockSurfaceControlViewHost.transferTouchGestureToHost()) { true })
             testEmbeddedStateWithHostInCollapsedState =
                 EmbeddedState(isExpanded = false, host = mockSurfaceControlViewHost)
             testEmbeddedStateWithHostInExpandedState =
@@ -511,9 +513,6 @@ class MediaGridTest {
     /** Ensures that items have the correct semantic information before and after selection */
     @Test
     fun testMediaGridClickItemSingleSelect() {
-        val resources = InstrumentationRegistry.getInstrumentation().getContext().getResources()
-        val mediaItemString = resources.getString(R.string.photopicker_media_item)
-
         runTest {
             val selection =
                 SelectionImpl<Media>(
@@ -563,7 +562,12 @@ class MediaGridTest {
                 .onNode(hasTestTag(MEDIA_GRID_TEST_TAG))
                 .onChildren()
                 // Remove the separators
-                .filter(hasContentDescription(mediaItemString))
+                .filter(
+                    hasContentDescription(
+                        MEDIA_ITEM_CONTENT_DESCRIPTION_SUBSTRING,
+                        substring = true,
+                    )
+                )
                 .onFirst()
                 .performClick()
 
@@ -581,7 +585,6 @@ class MediaGridTest {
     @Test
     fun testMediaGridClickItemMultiSelect() {
         val resources = InstrumentationRegistry.getInstrumentation().getContext().getResources()
-        val mediaItemString = resources.getString(R.string.photopicker_media_item)
         val selectedString = resources.getString(R.string.photopicker_item_selected)
 
         runTest {
@@ -633,7 +636,12 @@ class MediaGridTest {
                 .onNode(hasTestTag(MEDIA_GRID_TEST_TAG))
                 .onChildren()
                 // Remove the separators
-                .filter(hasContentDescription(mediaItemString))
+                .filter(
+                    hasContentDescription(
+                        MEDIA_ITEM_CONTENT_DESCRIPTION_SUBSTRING,
+                        substring = true,
+                    )
+                )
                 .onFirst()
                 .performClick()
 
@@ -653,8 +661,6 @@ class MediaGridTest {
     /** Ensures that items have the correct semantic information before and after selection */
     @Test
     fun testMediaGridClickItemOrderedSelection() {
-        val resources = InstrumentationRegistry.getInstrumentation().getContext().getResources()
-        val mediaItemString = resources.getString(R.string.photopicker_media_item)
         val photopickerConfiguration: PhotopickerConfiguration =
             TestPhotopickerConfiguration.build {
                 action(MediaStore.ACTION_PICK_IMAGES)
@@ -697,7 +703,12 @@ class MediaGridTest {
                 .onNode(hasTestTag(MEDIA_GRID_TEST_TAG))
                 .onChildren()
                 // Remove the separators
-                .filter(hasContentDescription(mediaItemString))
+                .filter(
+                    hasContentDescription(
+                        MEDIA_ITEM_CONTENT_DESCRIPTION_SUBSTRING,
+                        substring = true,
+                    )
+                )
                 .onFirst()
                 .performClick()
 
@@ -717,9 +728,6 @@ class MediaGridTest {
     /** Ensures that items have the correct semantic information before and after selection */
     @Test
     fun testMediaGridLongPressItem() {
-        val resources = InstrumentationRegistry.getInstrumentation().getContext().getResources()
-        val mediaItemString = resources.getString(R.string.photopicker_media_item)
-
         runTest {
             val selection =
                 SelectionImpl<Media>(
@@ -762,7 +770,12 @@ class MediaGridTest {
                 .onNode(hasTestTag(MEDIA_GRID_TEST_TAG))
                 .onChildren()
                 // Remove the separators
-                .filter(hasContentDescription(mediaItemString))
+                .filter(
+                    hasContentDescription(
+                        MEDIA_ITEM_CONTENT_DESCRIPTION_SUBSTRING,
+                        substring = true,
+                    )
+                )
                 .onFirst()
                 .performTouchInput { longClick() }
 
@@ -779,9 +792,6 @@ class MediaGridTest {
     /** Ensures that Separators are correctly inserted into the MediaGrid. */
     @Test
     fun testMediaGridSeparator() {
-        val resources = InstrumentationRegistry.getInstrumentation().getContext().getResources()
-        val mediaItemString = resources.getString(R.string.photopicker_media_item)
-
         // Provide a custom PagingData that puts Separators in specific positions to reduce
         // test flakiness of having to scroll to find a separator.
         val customData = PagingData.from(dataWithSeparators)
@@ -818,7 +828,14 @@ class MediaGridTest {
                 }
             }
 
-            composeTestRule.onAllNodes(hasContentDescription(mediaItemString)).assertCountEquals(3)
+            composeTestRule
+                .onAllNodes(
+                    hasContentDescription(
+                        value = MEDIA_ITEM_CONTENT_DESCRIPTION_SUBSTRING,
+                        substring = true,
+                    )
+                )
+                .assertCountEquals(3)
             composeTestRule.onNode(hasText(FIRST_SEPARATOR_LABEL)).assertIsDisplayed()
             composeTestRule.onNode(hasText(SECOND_SEPARATOR_LABEL)).assertIsDisplayed()
         }
@@ -850,7 +867,7 @@ class MediaGridTest {
                         selection = selected,
                         onItemClick = {},
                         onItemLongPress = {},
-                        contentItemFactory = { item, _, onClick, _ ->
+                        contentItemFactory = { item, _, onClick, _, _ ->
                             customContentItemFactory(item, onClick)
                         },
                     )
diff --git a/photopicker/tests/src/com/android/photopicker/core/configuration/ConfigurationManagerTest.kt b/photopicker/tests/src/com/android/photopicker/core/configuration/ConfigurationManagerTest.kt
index 964097fc9..1c116206c 100644
--- a/photopicker/tests/src/com/android/photopicker/core/configuration/ConfigurationManagerTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/core/configuration/ConfigurationManagerTest.kt
@@ -19,6 +19,9 @@ package com.android.photopicker.core.configuration
 import android.content.Intent
 import android.net.Uri
 import android.os.Build
+import android.platform.test.annotations.RequiresFlagsEnabled
+import android.platform.test.flag.junit.CheckFlagsRule
+import android.platform.test.flag.junit.DeviceFlagsValueProvider
 import android.provider.MediaStore
 import android.widget.photopicker.EmbeddedPhotoPickerFeatureInfo
 import androidx.core.os.bundleOf
@@ -27,6 +30,7 @@ import androidx.test.filters.SdkSuppress
 import androidx.test.filters.SmallTest
 import com.android.photopicker.core.events.generatePickerSessionId
 import com.android.photopicker.core.navigation.PhotopickerDestinations
+import com.android.providers.media.flags.Flags
 import com.google.common.truth.Truth.assertThat
 import kotlinx.coroutines.ExperimentalCoroutinesApi
 import kotlinx.coroutines.flow.first
@@ -37,6 +41,7 @@ import kotlinx.coroutines.test.advanceTimeBy
 import kotlinx.coroutines.test.runTest
 import org.junit.Assert.assertThrows
 import org.junit.Before
+import org.junit.Rule
 import org.junit.Test
 import org.junit.runner.RunWith
 import org.mockito.MockitoAnnotations
@@ -47,6 +52,8 @@ import org.mockito.MockitoAnnotations
 @OptIn(ExperimentalCoroutinesApi::class)
 class ConfigurationManagerTest {
 
+    @get:Rule val checkFlagsRule: CheckFlagsRule = DeviceFlagsValueProvider.createCheckFlagsRule()
+
     // Isolate the test device by providing a test wrapper around device config so that the
     // tests can control the flag values that are returned.
     val deviceConfigProxy = TestDeviceConfigProxyImpl()
@@ -69,7 +76,7 @@ class ConfigurationManagerTest {
                     scope = this.backgroundScope,
                     dispatcher = StandardTestDispatcher(this.testScheduler),
                     deviceConfigProxy,
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
 
             // Expect the default configuration with an action matching the test action.
@@ -95,7 +102,7 @@ class ConfigurationManagerTest {
                     scope = this.backgroundScope,
                     dispatcher = StandardTestDispatcher(this.testScheduler),
                     deviceConfigProxy,
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
             // Expect the default configuration with an action matching the test action.
             val expectedConfiguration = PhotopickerConfiguration(action = "", sessionId = sessionId)
@@ -109,7 +116,7 @@ class ConfigurationManagerTest {
             deviceConfigProxy.setFlag(
                 NAMESPACE_MEDIAPROVIDER,
                 FEATURE_CLOUD_MEDIA_FEATURE_ENABLED.first,
-                false
+                false,
             )
 
             // wait for debounce
@@ -140,7 +147,7 @@ class ConfigurationManagerTest {
                     scope = this.backgroundScope,
                     dispatcher = StandardTestDispatcher(this.testScheduler),
                     deviceConfigProxy,
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
             // Expect the default configuration with an action matching the test action.
             val expectedConfiguration = PhotopickerConfiguration(action = "", sessionId = sessionId)
@@ -160,7 +167,7 @@ class ConfigurationManagerTest {
             deviceConfigProxy.setFlag(
                 NAMESPACE_MEDIAPROVIDER,
                 FEATURE_CLOUD_MEDIA_PROVIDER_ALLOWLIST.first,
-                "testallowlist"
+                "testallowlist",
             )
             deviceConfigProxy.setFlag(
                 NAMESPACE_MEDIAPROVIDER,
@@ -199,7 +206,7 @@ class ConfigurationManagerTest {
                 scope = this.backgroundScope,
                 dispatcher = StandardTestDispatcher(this.testScheduler),
                 deviceConfigProxy,
-                sessionId = sessionId
+                sessionId = sessionId,
             )
         // Expect the default configuration with an action matching the test action.
         val expectedConfiguration = PhotopickerConfiguration(action = "", sessionId = sessionId)
@@ -213,7 +220,7 @@ class ConfigurationManagerTest {
         deviceConfigProxy.setFlag(
             NAMESPACE_MEDIAPROVIDER,
             FEATURE_CLOUD_MEDIA_PROVIDER_ALLOWLIST.first,
-            "test.cmp1,test.cmp2.cloudprovider,test.cmp3.cloudpicker"
+            "test.cmp1,test.cmp2.cloudprovider,test.cmp3.cloudpicker",
         )
 
         // wait for debounce
@@ -226,8 +233,7 @@ class ConfigurationManagerTest {
                 expectedConfiguration.copy(
                     flags =
                         PhotopickerFlags(
-                            CLOUD_ALLOWED_PROVIDERS =
-                                arrayOf("test.cmp1", "test.cmp2", "test.cmp3"),
+                            CLOUD_ALLOWED_PROVIDERS = arrayOf("test.cmp1", "test.cmp2", "test.cmp3")
                         )
                 )
             )
@@ -247,7 +253,7 @@ class ConfigurationManagerTest {
                     scope = this.backgroundScope,
                     dispatcher = StandardTestDispatcher(this.testScheduler),
                     deviceConfigProxy,
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
             // Expect the default configuration
             val expectedConfiguration = PhotopickerConfiguration(action = "", sessionId = sessionId)
@@ -275,7 +281,7 @@ class ConfigurationManagerTest {
                     scope = this.backgroundScope,
                     dispatcher = StandardTestDispatcher(this.testScheduler),
                     deviceConfigProxy,
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
             // Expect the default configuration
             val expectedConfiguration = PhotopickerConfiguration(action = "", sessionId = sessionId)
@@ -287,7 +293,7 @@ class ConfigurationManagerTest {
             configurationManager.setCaller(
                 callingPackage = "com.caller.package",
                 callingPackageUid = 99999,
-                callingPackageLabel = "Caller"
+                callingPackageLabel = "Caller",
             )
             advanceTimeBy(100)
 
@@ -323,7 +329,7 @@ class ConfigurationManagerTest {
                     scope = this.backgroundScope,
                     dispatcher = StandardTestDispatcher(this.testScheduler),
                     deviceConfigProxy,
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
             // Expect the default configuration
             val expectedConfiguration = PhotopickerConfiguration(action = "", sessionId = sessionId)
@@ -359,7 +365,7 @@ class ConfigurationManagerTest {
                     scope = this.backgroundScope,
                     dispatcher = StandardTestDispatcher(this.testScheduler),
                     deviceConfigProxy,
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
             // Expect the default configuration
             val expectedConfiguration = PhotopickerConfiguration(action = "", sessionId = sessionId)
@@ -396,7 +402,7 @@ class ConfigurationManagerTest {
                     scope = this.backgroundScope,
                     dispatcher = StandardTestDispatcher(this.testScheduler),
                     deviceConfigProxy,
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
             // Expect the default configuration
             val expectedConfiguration = PhotopickerConfiguration(action = "", sessionId = sessionId)
@@ -427,7 +433,7 @@ class ConfigurationManagerTest {
                 .setAction(MediaStore.ACTION_PICK_IMAGES)
                 .putStringArrayListExtra(
                     Intent.EXTRA_MIME_TYPES,
-                    arrayListOf("image/png", "video/mp4")
+                    arrayListOf("image/png", "video/mp4"),
                 )
 
         runTest {
@@ -437,7 +443,7 @@ class ConfigurationManagerTest {
                     scope = this.backgroundScope,
                     dispatcher = StandardTestDispatcher(this.testScheduler),
                     deviceConfigProxy,
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
             // Expect the default configuration
             val expectedConfiguration = PhotopickerConfiguration(action = "", sessionId = sessionId)
@@ -474,7 +480,7 @@ class ConfigurationManagerTest {
                     scope = this.backgroundScope,
                     dispatcher = StandardTestDispatcher(this.testScheduler),
                     deviceConfigProxy,
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
             assertThrows(IllegalIntentExtraException::class.java) {
                 configurationManager.setIntent(intent)
@@ -502,7 +508,7 @@ class ConfigurationManagerTest {
                     scope = this.backgroundScope,
                     dispatcher = StandardTestDispatcher(this.testScheduler),
                     deviceConfigProxy,
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
             // Expect the default configuration
             val expectedConfiguration = PhotopickerConfiguration(action = "", sessionId = sessionId)
@@ -534,7 +540,7 @@ class ConfigurationManagerTest {
         val inputUris =
             arrayListOf(
                 Uri.parse(String.format(testUriPlaceHolder, "1")),
-                Uri.parse(String.format(testUriPlaceHolder, "2"))
+                Uri.parse(String.format(testUriPlaceHolder, "2")),
             )
         val intent =
             Intent()
@@ -548,7 +554,7 @@ class ConfigurationManagerTest {
                     scope = this.backgroundScope,
                     dispatcher = StandardTestDispatcher(this.testScheduler),
                     deviceConfigProxy,
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
             // Expect the default configuration
             val expectedConfiguration = PhotopickerConfiguration(action = "", sessionId = sessionId)
@@ -581,7 +587,7 @@ class ConfigurationManagerTest {
                 .setAction(MediaStore.ACTION_PICK_IMAGES)
                 .putExtra(
                     MediaStore.EXTRA_PICK_IMAGES_LAUNCH_TAB,
-                    MediaStore.PICK_IMAGES_TAB_ALBUMS
+                    MediaStore.PICK_IMAGES_TAB_ALBUMS,
                 )
 
         runTest {
@@ -591,7 +597,7 @@ class ConfigurationManagerTest {
                     scope = this.backgroundScope,
                     dispatcher = StandardTestDispatcher(this.testScheduler),
                     deviceConfigProxy,
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
             // Expect the default configuration
             val expectedConfiguration = PhotopickerConfiguration(action = "", sessionId = sessionId)
@@ -623,7 +629,7 @@ class ConfigurationManagerTest {
                 .setAction(MediaStore.ACTION_PICK_IMAGES)
                 .putExtra(
                     MediaStore.EXTRA_PICK_IMAGES_LAUNCH_TAB,
-                    MediaStore.PICK_IMAGES_TAB_IMAGES
+                    MediaStore.PICK_IMAGES_TAB_IMAGES,
                 )
 
         runTest {
@@ -633,7 +639,7 @@ class ConfigurationManagerTest {
                     scope = this.backgroundScope,
                     dispatcher = StandardTestDispatcher(this.testScheduler),
                     deviceConfigProxy,
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
             // Expect the default configuration
             val expectedConfiguration = PhotopickerConfiguration(action = "", sessionId = sessionId)
@@ -666,7 +672,7 @@ class ConfigurationManagerTest {
                 .putExtra(
                     MediaStore.EXTRA_PICK_IMAGES_LAUNCH_TAB,
                     // This value isn't valid, and should result in a default start.
-                    1000
+                    1000,
                 )
 
         runTest {
@@ -676,7 +682,7 @@ class ConfigurationManagerTest {
                     scope = this.backgroundScope,
                     dispatcher = StandardTestDispatcher(this.testScheduler),
                     deviceConfigProxy,
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
             // Expect the default configuration
             val expectedConfiguration = PhotopickerConfiguration(action = "", sessionId = sessionId)
@@ -714,7 +720,7 @@ class ConfigurationManagerTest {
                     scope = this.backgroundScope,
                     dispatcher = StandardTestDispatcher(this.testScheduler),
                     deviceConfigProxy,
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
             // Expect the default configuration
             val expectedConfiguration = PhotopickerConfiguration(action = "", sessionId = sessionId)
@@ -752,7 +758,7 @@ class ConfigurationManagerTest {
                     scope = this.backgroundScope,
                     dispatcher = StandardTestDispatcher(this.testScheduler),
                     deviceConfigProxy,
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
             // Expect the default configuration
             val expectedConfiguration = PhotopickerConfiguration(action = "", sessionId = sessionId)
@@ -783,7 +789,7 @@ class ConfigurationManagerTest {
                 .setAction(Intent.ACTION_GET_CONTENT)
                 .putExtra(
                     MediaStore.EXTRA_PICK_IMAGES_LAUNCH_TAB,
-                    MediaStore.PICK_IMAGES_TAB_ALBUMS
+                    MediaStore.PICK_IMAGES_TAB_ALBUMS,
                 )
 
         runTest {
@@ -793,7 +799,7 @@ class ConfigurationManagerTest {
                     scope = this.backgroundScope,
                     dispatcher = StandardTestDispatcher(this.testScheduler),
                     deviceConfigProxy,
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
             // Expect the default configuration
             val expectedConfiguration = PhotopickerConfiguration(action = "", sessionId = sessionId)
@@ -838,7 +844,7 @@ class ConfigurationManagerTest {
                     scope = this.backgroundScope,
                     dispatcher = StandardTestDispatcher(this.testScheduler),
                     deviceConfigProxy,
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
             // Expect the default configuration
             val expectedConfiguration = PhotopickerConfiguration(action = "", sessionId = sessionId)
@@ -868,6 +874,7 @@ class ConfigurationManagerTest {
      */
     @Test
     @SdkSuppress(minSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_EMBEDDED_PHOTOPICKER)
     fun testSetEmbeddedPhotopickerFeatureInfoSetsSelectionLimit() {
         val featureInfo = EmbeddedPhotoPickerFeatureInfo.Builder().build()
 
@@ -878,14 +885,14 @@ class ConfigurationManagerTest {
                     scope = this.backgroundScope,
                     dispatcher = StandardTestDispatcher(this.testScheduler),
                     deviceConfigProxy,
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
             // Expect the default configuration
             val expectedConfiguration =
                 PhotopickerConfiguration(
                     runtimeEnv = PhotopickerRuntimeEnv.EMBEDDED,
                     action = "",
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
 
             val emissions = mutableListOf<PhotopickerConfiguration>()
@@ -908,6 +915,7 @@ class ConfigurationManagerTest {
      */
     @Test
     @SdkSuppress(minSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_EMBEDDED_PHOTOPICKER)
     fun testSetEmbeddedPhotopickerFeatureInfoSetsMimeTypes() {
         val featureInfo =
             EmbeddedPhotoPickerFeatureInfo.Builder()
@@ -921,14 +929,14 @@ class ConfigurationManagerTest {
                     scope = this.backgroundScope,
                     dispatcher = StandardTestDispatcher(this.testScheduler),
                     deviceConfigProxy,
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
             // Expect the default configuration
             val expectedConfiguration =
                 PhotopickerConfiguration(
                     runtimeEnv = PhotopickerRuntimeEnv.EMBEDDED,
                     action = "",
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
 
             val emissions = mutableListOf<PhotopickerConfiguration>()
@@ -950,6 +958,7 @@ class ConfigurationManagerTest {
      */
     @Test
     @SdkSuppress(minSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_EMBEDDED_PHOTOPICKER)
     fun testSetEmbeddedPhotopickerFeatureInfoSetsPickImagesInOrder() {
         val featureInfo = EmbeddedPhotoPickerFeatureInfo.Builder().setOrderedSelection(true).build()
 
@@ -960,14 +969,14 @@ class ConfigurationManagerTest {
                     scope = this.backgroundScope,
                     dispatcher = StandardTestDispatcher(this.testScheduler),
                     deviceConfigProxy,
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
             // Expect the default configuration
             val expectedConfiguration =
                 PhotopickerConfiguration(
                     runtimeEnv = PhotopickerRuntimeEnv.EMBEDDED,
                     action = "",
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
 
             val emissions = mutableListOf<PhotopickerConfiguration>()
@@ -989,6 +998,7 @@ class ConfigurationManagerTest {
      */
     @Test
     @SdkSuppress(minSdkVersion = Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_EMBEDDED_PHOTOPICKER)
     fun testSetEmbeddedPhotopickerFeatureInfoSetsPreSelectedUris() {
         val featureInfo =
             EmbeddedPhotoPickerFeatureInfo.Builder()
@@ -1002,14 +1012,14 @@ class ConfigurationManagerTest {
                     scope = this.backgroundScope,
                     dispatcher = StandardTestDispatcher(this.testScheduler),
                     deviceConfigProxy,
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
             // Expect the default configuration
             val expectedConfiguration =
                 PhotopickerConfiguration(
                     runtimeEnv = PhotopickerRuntimeEnv.EMBEDDED,
                     action = "",
-                    sessionId = sessionId
+                    sessionId = sessionId,
                 )
 
             val emissions = mutableListOf<PhotopickerConfiguration>()
diff --git a/photopicker/tests/src/com/android/photopicker/core/configuration/PhotopickerConfigurationTest.kt b/photopicker/tests/src/com/android/photopicker/core/configuration/PhotopickerConfigurationTest.kt
new file mode 100644
index 000000000..cc6cbbf40
--- /dev/null
+++ b/photopicker/tests/src/com/android/photopicker/core/configuration/PhotopickerConfigurationTest.kt
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.core.configuration
+
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import com.android.photopicker.core.events.generatePickerSessionId
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertTrue
+import org.junit.Test
+import org.junit.runner.RunWith
+
+/** Unit tests for the [PhotopickerConfiguration] */
+@RunWith(AndroidJUnit4::class)
+class PhotopickerConfigurationTest {
+
+    val sessionId = generatePickerSessionId()
+
+    @Test
+    fun hasOnlyVideoMimeTypes_onlyVideoMimeTypes_returnsTrue() {
+        val config =
+            PhotopickerConfiguration(
+                action = "test",
+                mimeTypes = arrayListOf("video/*"),
+                sessionId = sessionId,
+            )
+        assertTrue(config.hasOnlyVideoMimeTypes())
+    }
+
+    @Test
+    fun hasOnlyVideoMimeTypes_mixedMimeTypes_returnsFalse() {
+        val config =
+            PhotopickerConfiguration(
+                action = "test",
+                mimeTypes = arrayListOf("video/*", "image/*"),
+                sessionId = sessionId,
+            )
+        assertFalse(config.hasOnlyVideoMimeTypes())
+    }
+
+    @Test
+    fun hasOnlyVideoMimeTypes_onlyImageMimeTypes_returnsFalse() {
+        val config =
+            PhotopickerConfiguration(
+                action = "test",
+                mimeTypes = arrayListOf("image/*", "image/png"),
+                sessionId = sessionId,
+            )
+
+        assertFalse(config.hasOnlyVideoMimeTypes())
+    }
+
+    @Test
+    fun hasOnlyVideoMimeTypes_allMimeTypes_returnsFalse() {
+        val config =
+            PhotopickerConfiguration(
+                action = "test",
+                mimeTypes = arrayListOf("*/*"),
+                sessionId = sessionId,
+            )
+        assertFalse(config.hasOnlyVideoMimeTypes())
+    }
+}
diff --git a/photopicker/tests/src/com/android/photopicker/core/configuration/TestPhotopickerConfiguration.kt b/photopicker/tests/src/com/android/photopicker/core/configuration/TestPhotopickerConfiguration.kt
index faa5b4740..e444adabb 100644
--- a/photopicker/tests/src/com/android/photopicker/core/configuration/TestPhotopickerConfiguration.kt
+++ b/photopicker/tests/src/com/android/photopicker/core/configuration/TestPhotopickerConfiguration.kt
@@ -68,6 +68,7 @@ class TestPhotopickerConfiguration {
         private var runtimeEnv: PhotopickerRuntimeEnv = PhotopickerRuntimeEnv.ACTIVITY
         private var sessionId: Int = generatePickerSessionId()
         private var flags: PhotopickerFlags = PhotopickerFlags()
+        private var mimeTypes: ArrayList<String> = arrayListOf("image/*", "video/*")
 
         fun action(value: String) = apply { this.action = value }
 
@@ -89,6 +90,8 @@ class TestPhotopickerConfiguration {
 
         fun flags(value: PhotopickerFlags) = apply { this.flags = value }
 
+        fun mimeTypes(value: ArrayList<String>) = apply { this.mimeTypes = value }
+
         fun build(): PhotopickerConfiguration {
             return PhotopickerConfiguration(
                 action = action,
@@ -101,6 +104,7 @@ class TestPhotopickerConfiguration {
                 runtimeEnv = runtimeEnv,
                 sessionId = sessionId,
                 flags = flags,
+                mimeTypes = mimeTypes,
             )
         }
     }
diff --git a/photopicker/tests/src/com/android/photopicker/core/embedded/EmbeddedFeaturesTest.kt b/photopicker/tests/src/com/android/photopicker/core/embedded/EmbeddedFeaturesTest.kt
index b320c7200..36210781b 100644
--- a/photopicker/tests/src/com/android/photopicker/core/embedded/EmbeddedFeaturesTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/core/embedded/EmbeddedFeaturesTest.kt
@@ -13,12 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package com.android.photopicker.core.embedded
 
 import android.content.ContentProvider
 import android.content.ContentResolver
 import android.content.Context
+import android.content.Intent
 import android.content.pm.PackageManager
 import android.net.Uri
 import android.os.Build
@@ -26,6 +26,7 @@ import android.os.Parcel
 import android.os.UserHandle
 import android.os.UserManager
 import android.test.mock.MockContentResolver
+import android.view.SurfaceControlViewHost
 import androidx.activity.compose.LocalOnBackPressedDispatcherOwner
 import androidx.compose.runtime.CompositionLocalProvider
 import androidx.compose.ui.test.ExperimentalTestApi
@@ -37,12 +38,17 @@ import androidx.compose.ui.test.hasClickAction
 import androidx.compose.ui.test.hasContentDescription
 import androidx.compose.ui.test.hasText
 import androidx.compose.ui.test.junit4.createAndroidComposeRule
-import androidx.compose.ui.test.onAllNodesWithContentDescription
+import androidx.compose.ui.test.longClick
 import androidx.compose.ui.test.onFirst
+import androidx.compose.ui.test.onNodeWithText
 import androidx.compose.ui.test.performTouchInput
+import androidx.compose.ui.test.swipeDown
 import androidx.compose.ui.test.swipeLeft
+import androidx.compose.ui.test.swipeRight
+import androidx.compose.ui.test.swipeUp
 import androidx.lifecycle.viewmodel.compose.LocalViewModelStoreOwner
 import androidx.test.filters.SdkSuppress
+import com.android.modules.utils.build.SdkLevel
 import com.android.photopicker.R
 import com.android.photopicker.core.ActivityModule
 import com.android.photopicker.core.ApplicationModule
@@ -52,10 +58,19 @@ import com.android.photopicker.core.EmbeddedServiceModule
 import com.android.photopicker.core.Main
 import com.android.photopicker.core.PhotopickerApp
 import com.android.photopicker.core.ViewModelModule
+import com.android.photopicker.core.banners.BannerDefinitions
 import com.android.photopicker.core.banners.BannerManager
+import com.android.photopicker.core.banners.BannerState
+import com.android.photopicker.core.banners.BannerStateDao
 import com.android.photopicker.core.configuration.ConfigurationManager
+import com.android.photopicker.core.configuration.DeviceConfigProxy
+import com.android.photopicker.core.configuration.FEATURE_CLOUD_ENFORCE_PROVIDER_ALLOWLIST
+import com.android.photopicker.core.configuration.FEATURE_CLOUD_MEDIA_FEATURE_ENABLED
+import com.android.photopicker.core.configuration.FEATURE_CLOUD_MEDIA_PROVIDER_ALLOWLIST
 import com.android.photopicker.core.configuration.LocalPhotopickerConfiguration
+import com.android.photopicker.core.configuration.NAMESPACE_MEDIAPROVIDER
 import com.android.photopicker.core.configuration.PhotopickerRuntimeEnv
+import com.android.photopicker.core.configuration.TestDeviceConfigProxyImpl
 import com.android.photopicker.core.configuration.TestPhotopickerConfiguration
 import com.android.photopicker.core.database.DatabaseManager
 import com.android.photopicker.core.events.Event
@@ -69,16 +84,21 @@ import com.android.photopicker.core.navigation.PhotopickerDestinations
 import com.android.photopicker.core.selection.LocalSelection
 import com.android.photopicker.core.selection.Selection
 import com.android.photopicker.core.theme.PhotopickerTheme
+import com.android.photopicker.data.DataService
+import com.android.photopicker.data.TestDataServiceImpl
+import com.android.photopicker.data.model.CollectionInfo
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.data.model.MediaSource
+import com.android.photopicker.data.model.Provider
 import com.android.photopicker.features.overflowmenu.OverflowMenuFeature
 import com.android.photopicker.features.preview.PreviewFeature
 import com.android.photopicker.features.snackbar.SnackbarFeature
 import com.android.photopicker.inject.PhotopickerTestModule
 import com.android.photopicker.inject.TestOptions
-import com.android.photopicker.test.utils.MockContentProviderWrapper
 import com.android.photopicker.tests.HiltTestActivity
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.MockContentProviderWrapper
+import com.android.photopicker.util.test.nonNullableEq
+import com.android.photopicker.util.test.whenever
 import com.google.common.truth.Truth.assertWithMessage
 import dagger.Lazy
 import dagger.Module
@@ -99,11 +119,16 @@ import kotlinx.coroutines.test.TestScope
 import kotlinx.coroutines.test.advanceTimeBy
 import kotlinx.coroutines.test.runTest
 import kotlinx.coroutines.withContext
+import org.junit.Assume.assumeTrue
 import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
 import org.mockito.Mock
 import org.mockito.Mockito.any
+import org.mockito.Mockito.anyInt
+import org.mockito.Mockito.atLeast
+import org.mockito.Mockito.never
+import org.mockito.Mockito.verify
 import org.mockito.MockitoAnnotations
 
 @UninstallModules(
@@ -118,10 +143,8 @@ import org.mockito.MockitoAnnotations
 class EmbeddedFeaturesTest : EmbeddedPhotopickerFeatureBaseTest() {
     /** Hilt's rule needs to come first to ensure the DI container is setup for the test. */
     @get:Rule(order = 0) var hiltRule = HiltAndroidRule(this)
-
     @get:Rule(order = 1)
     val composeTestRule = createAndroidComposeRule(activityClass = HiltTestActivity::class.java)
-
     @get:Rule(order = 2) val glideRule = GlideTestRule()
 
     /** Setup dependencies for the UninstallModules for the test class. */
@@ -131,19 +154,13 @@ class EmbeddedFeaturesTest : EmbeddedPhotopickerFeatureBaseTest() {
         PhotopickerTestModule(TestOptions.build { runtimeEnv(PhotopickerRuntimeEnv.EMBEDDED) })
 
     val testDispatcher = StandardTestDispatcher()
-
     /* Overrides for EmbeddedServiceModule */
     val testScope: TestScope = TestScope(testDispatcher)
-
     @BindValue @Main val mainScope: CoroutineScope = testScope
-
     @BindValue @Background var testBackgroundScope: CoroutineScope = testScope.backgroundScope
-
     @Inject @Main lateinit var mainDispatcher: CoroutineDispatcher
-
     /* Overrides for ViewModelModule */
     @BindValue val viewModelScopeOverride: CoroutineScope? = testScope.backgroundScope
-
     /**
      * Preview uses Glide for loading images, so we have to mock out the dependencies for Glide
      * Replace the injected ContentResolver binding in [ApplicationModule] with this test value.
@@ -151,26 +168,37 @@ class EmbeddedFeaturesTest : EmbeddedPhotopickerFeatureBaseTest() {
     @BindValue @ApplicationOwned lateinit var contentResolver: ContentResolver
     private lateinit var provider: MockContentProviderWrapper
     @Mock lateinit var mockContentProvider: ContentProvider
+    @Mock lateinit var mockSurfaceControlViewHost: SurfaceControlViewHost
+    /**
+     * A [EmbeddedState] having a mocked [SurfaceControlViewHost] instance that can be used for
+     * testing in collapsed mode
+     */
+    private lateinit var testEmbeddedStateWithHostInCollapsedState: EmbeddedState
+    /**
+     * A [EmbeddedState] having a mocked [SurfaceControlViewHost] instance that can be used for
+     * testing in Expanded state
+     */
+    private lateinit var testEmbeddedStateWithHostInExpandedState: EmbeddedState
 
-    @Inject lateinit var events: Events
-    @Inject lateinit var selection: Selection<Media>
-    @Inject lateinit var featureManager: FeatureManager
+    @Inject lateinit var events: Lazy<Events>
+    @Inject lateinit var selection: Lazy<Selection<Media>>
+    @Inject lateinit var featureManager: Lazy<FeatureManager>
     @Inject lateinit var userHandle: UserHandle
     @Inject lateinit var bannerManager: Lazy<BannerManager>
-    @Inject lateinit var embeddedLifecycle: EmbeddedLifecycle
+    @Inject lateinit var embeddedLifecycle: Lazy<EmbeddedLifecycle>
     @Inject lateinit var databaseManager: DatabaseManager
+    @Inject lateinit var dataService: Lazy<DataService>
     @Inject override lateinit var configurationManager: Lazy<ConfigurationManager>
-
     // Needed for UserMonitor
     @Inject lateinit var mockContext: Context
     @Mock lateinit var mockUserManager: UserManager
     @Mock lateinit var mockPackageManager: PackageManager
-
+    @Inject lateinit var deviceConfig: DeviceConfigProxy
     private val USER_HANDLE_MANAGED: UserHandle
     private val USER_ID_MANAGED: Int = 10
+    private val MEDIA_ITEM_CONTENT_DESCRIPTION_SUBSTRING = "taken on"
 
     init {
-
         // Create a UserHandle for a managed profile.
         val parcel = Parcel.obtain()
         parcel.writeInt(USER_ID_MANAGED)
@@ -209,16 +237,27 @@ class EmbeddedFeaturesTest : EmbeddedPhotopickerFeatureBaseTest() {
             mimeType = "image/png",
             standardMimeTypeExtension = 1,
         )
+    private val localProvider =
+        Provider(
+            authority = "local_authority",
+            mediaSource = MediaSource.LOCAL,
+            uid = 1,
+            displayName = "Local Provider",
+        )
+    private val cloudProvider =
+        Provider(
+            authority = "clout_authority",
+            mediaSource = MediaSource.REMOTE,
+            uid = 2,
+            displayName = "Cloud Provider",
+        )
 
     @Before
     fun setup() {
         MockitoAnnotations.initMocks(this)
-
         hiltRule.inject()
-
         // Stub for MockContentResolver constructor
         whenever(mockContext.getApplicationInfo()) { getTestableContext().getApplicationInfo() }
-
         // Stub out the content resolver for Glide
         val mockContentResolver = MockContentResolver(mockContext)
         provider = MockContentProviderWrapper(mockContentProvider)
@@ -240,28 +279,19 @@ class EmbeddedFeaturesTest : EmbeddedPhotopickerFeatureBaseTest() {
                 resources.getString(R.string.photopicker_photos_nav_button_label)
             val albumsGridNavButtonLabel =
                 resources.getString(R.string.photopicker_albums_nav_button_label)
-
             composeTestRule.setContent {
-                CompositionLocalProvider(
-                    LocalPhotopickerConfiguration provides
-                        TestPhotopickerConfiguration.build {
-                            runtimeEnv(PhotopickerRuntimeEnv.EMBEDDED)
-                        },
-                    LocalEmbeddedState provides testEmbeddedStateCollapsed,
-                ) {
+                CompositionLocalProvider(LocalEmbeddedState provides testEmbeddedStateCollapsed) {
                     callEmbeddedPhotopickerMain(
-                        embeddedLifecycle = embeddedLifecycle,
-                        featureManager = featureManager,
-                        selection = selection,
-                        events = events,
+                        embeddedLifecycle = embeddedLifecycle.get(),
+                        featureManager = featureManager.get(),
+                        selection = selection.get(),
+                        events = events.get(),
                     )
                 }
             }
-
             // Wait for the PhotoGridViewModel to load data and for the UI to update.
             advanceTimeBy(100)
             composeTestRule.waitForIdle()
-
             composeTestRule
                 .onNode(
                     hasAnyChild(hasText(photosGridNavButtonLabel)) and
@@ -278,34 +308,24 @@ class EmbeddedFeaturesTest : EmbeddedPhotopickerFeatureBaseTest() {
                 resources.getString(R.string.photopicker_photos_nav_button_label)
             val albumsGridNavButtonLabel =
                 resources.getString(R.string.photopicker_albums_nav_button_label)
-
             composeTestRule.setContent {
-                CompositionLocalProvider(
-                    LocalPhotopickerConfiguration provides
-                        TestPhotopickerConfiguration.build {
-                            runtimeEnv(PhotopickerRuntimeEnv.EMBEDDED)
-                        },
-                    LocalEmbeddedState provides testEmbeddedStateExpanded,
-                ) {
+                CompositionLocalProvider(LocalEmbeddedState provides testEmbeddedStateExpanded) {
                     callEmbeddedPhotopickerMain(
-                        embeddedLifecycle = embeddedLifecycle,
-                        featureManager = featureManager,
-                        selection = selection,
-                        events = events,
+                        embeddedLifecycle = embeddedLifecycle.get(),
+                        featureManager = featureManager.get(),
+                        selection = selection.get(),
+                        events = events.get(),
                     )
                 }
             }
-
             // Wait for the PhotoGridViewModel to load data and for the UI to update.
             advanceTimeBy(100)
             composeTestRule.waitForIdle()
-
             // Photos Grid Nav Button and Albums Grid Nav Button
             composeTestRule
                 .onNode(hasText(photosGridNavButtonLabel))
                 .assertIsDisplayed()
                 .assert(hasClickAction())
-
             composeTestRule
                 .onNode(hasText(albumsGridNavButtonLabel))
                 .assertIsDisplayed()
@@ -315,32 +335,26 @@ class EmbeddedFeaturesTest : EmbeddedPhotopickerFeatureBaseTest() {
     @Test
     fun testSwipeLeftToNavigateDisabledInEmbeddedWhenCollapsed() =
         testScope.runTest {
-            val resources = getTestableContext().getResources()
-            val mediaItemString = resources.getString(R.string.photopicker_media_item)
-
             composeTestRule.setContent {
-                CompositionLocalProvider(
-                    LocalPhotopickerConfiguration provides
-                        TestPhotopickerConfiguration.build {
-                            runtimeEnv(PhotopickerRuntimeEnv.EMBEDDED)
-                        },
-                    LocalEmbeddedState provides testEmbeddedStateCollapsed,
-                ) {
+                CompositionLocalProvider(LocalEmbeddedState provides testEmbeddedStateCollapsed) {
                     callEmbeddedPhotopickerMain(
-                        embeddedLifecycle = embeddedLifecycle,
-                        featureManager = featureManager,
-                        selection = selection,
-                        events = events,
+                        embeddedLifecycle = embeddedLifecycle.get(),
+                        featureManager = featureManager.get(),
+                        selection = selection.get(),
+                        events = events.get(),
                     )
                 }
             }
-
             // Wait for the PhotoGridViewModel to load data and for the UI to update.
             advanceTimeBy(100)
             composeTestRule.waitForIdle()
-
             composeTestRule
-                .onAllNodesWithContentDescription(mediaItemString)
+                .onAllNodes(
+                    hasContentDescription(
+                        value = MEDIA_ITEM_CONTENT_DESCRIPTION_SUBSTRING,
+                        substring = true,
+                    )
+                )
                 .onFirst()
                 .performTouchInput { swipeLeft() }
             composeTestRule.waitForIdle()
@@ -353,32 +367,26 @@ class EmbeddedFeaturesTest : EmbeddedPhotopickerFeatureBaseTest() {
     @Test
     fun testSwipeLeftToAlbumWorksInEmbeddedWhenExpanded() =
         testScope.runTest {
-            val resources = getTestableContext().getResources()
-            val mediaItemString = resources.getString(R.string.photopicker_media_item)
-
             composeTestRule.setContent {
-                CompositionLocalProvider(
-                    LocalPhotopickerConfiguration provides
-                        TestPhotopickerConfiguration.build {
-                            runtimeEnv(PhotopickerRuntimeEnv.EMBEDDED)
-                        },
-                    LocalEmbeddedState provides testEmbeddedStateExpanded,
-                ) {
+                CompositionLocalProvider(LocalEmbeddedState provides testEmbeddedStateExpanded) {
                     callEmbeddedPhotopickerMain(
-                        embeddedLifecycle = embeddedLifecycle,
-                        featureManager = featureManager,
-                        selection = selection,
-                        events = events,
+                        embeddedLifecycle = embeddedLifecycle.get(),
+                        featureManager = featureManager.get(),
+                        selection = selection.get(),
+                        events = events.get(),
                     )
                 }
             }
-
             // Wait for the PhotoGridViewModel to load data and for the UI to update.
             advanceTimeBy(100)
             composeTestRule.waitForIdle()
-
             composeTestRule
-                .onAllNodesWithContentDescription(mediaItemString)
+                .onAllNodes(
+                    hasContentDescription(
+                        value = MEDIA_ITEM_CONTENT_DESCRIPTION_SUBSTRING,
+                        substring = true,
+                    )
+                )
                 .onFirst()
                 .performTouchInput { swipeLeft() }
             composeTestRule.waitForIdle()
@@ -392,32 +400,24 @@ class EmbeddedFeaturesTest : EmbeddedPhotopickerFeatureBaseTest() {
     fun testProfileSelectorIsNotDisplayedInEmbeddedWhenCollapsed() =
         testScope.runTest {
             composeTestRule.setContent {
-                CompositionLocalProvider(
-                    LocalPhotopickerConfiguration provides
-                        TestPhotopickerConfiguration.build {
-                            runtimeEnv(PhotopickerRuntimeEnv.EMBEDDED)
-                        },
-                    LocalEmbeddedState provides testEmbeddedStateCollapsed,
-                ) {
+                CompositionLocalProvider(LocalEmbeddedState provides testEmbeddedStateCollapsed) {
                     callEmbeddedPhotopickerMain(
-                        embeddedLifecycle = embeddedLifecycle,
-                        featureManager = featureManager,
-                        selection = selection,
-                        events = events,
+                        embeddedLifecycle = embeddedLifecycle.get(),
+                        featureManager = featureManager.get(),
+                        selection = selection.get(),
+                        events = events.get(),
                     )
                 }
             }
-
             // Wait for the PhotoGridViewModel to load data and for the UI to update.
             advanceTimeBy(100)
             composeTestRule.waitForIdle()
-
             composeTestRule
                 .onNode(
                     hasContentDescription(
                         getTestableContext()
                             .getResources()
-                            .getString(R.string.photopicker_profile_switch_button_description)
+                            .getString(R.string.photopicker_profile_primary_label)
                     )
                 )
                 .assertIsNotDisplayed()
@@ -426,42 +426,34 @@ class EmbeddedFeaturesTest : EmbeddedPhotopickerFeatureBaseTest() {
     @Test
     fun testProfileSelectorIsDisplayedInEmbeddedWhenExpanded() =
         testScope.runTest {
-
             // Initial setup state: Two profiles (Personal/Work), both enabled
             whenever(mockUserManager.userProfiles) { listOf(userHandle, USER_HANDLE_MANAGED) }
             whenever(mockUserManager.isManagedProfile(USER_ID_MANAGED)) { true }
             whenever(mockUserManager.isQuietModeEnabled(USER_HANDLE_MANAGED)) { false }
             whenever(mockUserManager.getProfileParent(USER_HANDLE_MANAGED)) { userHandle }
-
             withContext(Dispatchers.Main) {
                 composeTestRule.setContent {
                     CompositionLocalProvider(
-                        LocalPhotopickerConfiguration provides
-                            TestPhotopickerConfiguration.build {
-                                runtimeEnv(PhotopickerRuntimeEnv.EMBEDDED)
-                            },
-                        LocalEmbeddedState provides testEmbeddedStateExpanded,
+                        LocalEmbeddedState provides testEmbeddedStateExpanded
                     ) {
                         callEmbeddedPhotopickerMain(
-                            embeddedLifecycle = embeddedLifecycle,
-                            featureManager = featureManager,
-                            selection = selection,
-                            events = events,
+                            embeddedLifecycle = embeddedLifecycle.get(),
+                            featureManager = featureManager.get(),
+                            selection = selection.get(),
+                            events = events.get(),
                         )
                     }
                 }
             }
-
             // Wait for the PhotoGridViewModel to load data and for the UI to update.
             advanceTimeBy(100)
             composeTestRule.waitForIdle()
-
             composeTestRule
                 .onNode(
                     hasContentDescription(
                         getTestableContext()
                             .getResources()
-                            .getString(R.string.photopicker_profile_switch_button_description)
+                            .getString(R.string.photopicker_profile_primary_label)
                     )
                 )
                 .assertIsDisplayed()
@@ -469,7 +461,6 @@ class EmbeddedFeaturesTest : EmbeddedPhotopickerFeatureBaseTest() {
 
     @Test
     fun testSnackbarIsAlwaysEnabledInEmbedded() {
-
         assertWithMessage("SnackbarFeature is not always enabled for action pick image")
             .that(
                 SnackbarFeature.Registration.isEnabled(
@@ -491,12 +482,12 @@ class EmbeddedFeaturesTest : EmbeddedPhotopickerFeatureBaseTest() {
                             runtimeEnv(PhotopickerRuntimeEnv.EMBEDDED)
                         },
                     LocalEmbeddedState provides testEmbeddedStateCollapsed,
-                    LocalFeatureManager provides featureManager,
-                    LocalSelection provides selection,
-                    LocalEvents provides events,
-                    LocalEmbeddedLifecycle provides embeddedLifecycle,
-                    LocalViewModelStoreOwner provides embeddedLifecycle,
-                    LocalOnBackPressedDispatcherOwner provides embeddedLifecycle,
+                    LocalFeatureManager provides featureManager.get(),
+                    LocalSelection provides selection.get(),
+                    LocalEvents provides events.get(),
+                    LocalEmbeddedLifecycle provides embeddedLifecycle.get(),
+                    LocalViewModelStoreOwner provides embeddedLifecycle.get(),
+                    LocalOnBackPressedDispatcherOwner provides embeddedLifecycle.get(),
                 ) {
                     PhotopickerTheme(
                         isDarkTheme = false,
@@ -512,18 +503,14 @@ class EmbeddedFeaturesTest : EmbeddedPhotopickerFeatureBaseTest() {
                     }
                 }
             }
-
             // Advance the UI clock manually to control for the fade animations on the snackbar.
             composeTestRule.mainClock.autoAdvance = false
-
             val TEST_MESSAGE = "This is a test message"
-            events.dispatch(Event.ShowSnackbarMessage(FeatureToken.CORE.token, TEST_MESSAGE))
+            events.get().dispatch(Event.ShowSnackbarMessage(FeatureToken.CORE.token, TEST_MESSAGE))
             advanceTimeBy(500)
-
             // Advance ui clock to allow fade in
             composeTestRule.mainClock.advanceTimeBy(2000L)
             composeTestRule.onNode(hasText(TEST_MESSAGE)).assertIsDisplayed()
-
             // Advance ui clock to allow fade out
             composeTestRule.mainClock.advanceTimeBy(10_000L)
             composeTestRule.onNode(hasText(TEST_MESSAGE)).assertIsNotDisplayed()
@@ -531,7 +518,6 @@ class EmbeddedFeaturesTest : EmbeddedPhotopickerFeatureBaseTest() {
 
     @Test
     fun testOverflowMenuDisabledInEmbedded() {
-
         assertWithMessage("Expected OverflowMenuFeature to be disabled in embedded runtime")
             .that(
                 OverflowMenuFeature.Registration.isEnabled(
@@ -545,7 +531,6 @@ class EmbeddedFeaturesTest : EmbeddedPhotopickerFeatureBaseTest() {
 
     @Test
     fun testPreviewDisabledInEmbedded() {
-
         assertWithMessage("Expected PreviewFeature to be disabled in embedded runtime")
             .that(
                 PreviewFeature.Registration.isEnabled(
@@ -556,4 +541,436 @@ class EmbeddedFeaturesTest : EmbeddedPhotopickerFeatureBaseTest() {
             )
             .isEqualTo(false)
     }
+
+    @Test
+    fun testBannerHidden_embeddedMode_collapsedState() = runTest {
+        configurationManager
+            .get()
+            .setCaller(
+                callingPackage = "com.android.test.package",
+                callingPackageUid = 12345,
+                callingPackageLabel = "Test Package",
+            )
+        advanceTimeBy(1000)
+        val resources = getTestableContext().getResources()
+        val expectedPrivacyMessage =
+            resources.getString(R.string.photopicker_privacy_explainer, "Test Package")
+        composeTestRule.setContent {
+            CompositionLocalProvider(LocalEmbeddedState provides testEmbeddedStateCollapsed) {
+                callEmbeddedPhotopickerMain(
+                    embeddedLifecycle = embeddedLifecycle.get(),
+                    featureManager = featureManager.get(),
+                    selection = selection.get(),
+                    events = events.get(),
+                )
+            }
+        }
+        composeTestRule.waitForIdle()
+        bannerManager.get().showBanner(BannerDefinitions.PRIVACY_EXPLAINER)
+        advanceTimeBy(100)
+        composeTestRule.onNodeWithText(expectedPrivacyMessage).assertIsNotDisplayed()
+    }
+
+    @Test
+    fun testBannerShown_embeddedMode_expandedState() = runTest {
+        configurationManager
+            .get()
+            .setCaller(
+                callingPackage = "com.android.test.package",
+                callingPackageUid = 12345,
+                callingPackageLabel = "Test Package",
+            )
+        val resources = getTestableContext().getResources()
+        val expectedPrivacyMessage =
+            resources.getString(R.string.photopicker_privacy_explainer, "Test Package")
+        composeTestRule.setContent {
+            CompositionLocalProvider(LocalEmbeddedState provides testEmbeddedStateExpanded) {
+                callEmbeddedPhotopickerMain(
+                    embeddedLifecycle = embeddedLifecycle.get(),
+                    featureManager = featureManager.get(),
+                    selection = selection.get(),
+                    events = events.get(),
+                )
+            }
+        }
+        composeTestRule.waitForIdle()
+        bannerManager.get().showBanner(BannerDefinitions.PRIVACY_EXPLAINER)
+        advanceTimeBy(100)
+        composeTestRule.onNodeWithText(expectedPrivacyMessage).assertIsDisplayed()
+    }
+
+    @Test
+    fun testSwipeUpInCollapseMode_emptyPhotosGrid_transferTouchToHost() {
+        // This test is only allowed to run on sdk level U+
+        assumeTrue(SdkLevel.isAtLeastU())
+
+        // Initialize [EmbeddedState] instances
+        @Suppress("DEPRECATION")
+        (whenever(mockSurfaceControlViewHost.transferTouchGestureToHost()) { true })
+        testEmbeddedStateWithHostInCollapsedState =
+            EmbeddedState(isExpanded = false, host = mockSurfaceControlViewHost)
+
+        val testDataService = dataService.get() as? TestDataServiceImpl
+        checkNotNull(testDataService) { "Expected a TestDataServiceImpl" }
+        // Force the data service to return no data for all test sources during this test.
+        testDataService.mediaSetSize = 0
+        testScope.runTest {
+            val resources = getTestableContext().getResources()
+            composeTestRule.setContent {
+                CompositionLocalProvider(
+                    LocalEmbeddedState provides testEmbeddedStateWithHostInCollapsedState
+                ) {
+                    callEmbeddedPhotopickerMain(
+                        embeddedLifecycle = embeddedLifecycle.get(),
+                        featureManager = featureManager.get(),
+                        selection = selection.get(),
+                        events = events.get(),
+                    )
+                }
+            }
+            // Wait for the PhotoGridViewModel to load data and for the UI to update.
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+            composeTestRule
+                .onNode(hasText(resources.getString(R.string.photopicker_photos_empty_state_body)))
+                .assertIsDisplayed()
+            composeTestRule
+                .onNode(hasText(resources.getString(R.string.photopicker_photos_empty_state_title)))
+                .assertIsDisplayed()
+                .performTouchInput { swipeUp() }
+            // Verify whether the method to transfer touch events is invoked during testing
+            @Suppress("DEPRECATION")
+            verify(mockSurfaceControlViewHost, atLeast(1)).transferTouchGestureToHost()
+        }
+    }
+
+    @Test
+    fun testSwipeUpInExpandedMode_emptyPhotosGrid_transferTouchToHost() {
+        // This test is only allowed to run on sdk level U+
+        assumeTrue(SdkLevel.isAtLeastU())
+
+        // Initialize [EmbeddedState] instances
+        @Suppress("DEPRECATION")
+        (whenever(mockSurfaceControlViewHost.transferTouchGestureToHost()) { true })
+        testEmbeddedStateWithHostInExpandedState =
+            EmbeddedState(isExpanded = true, host = mockSurfaceControlViewHost)
+
+        val testDataService = dataService.get() as? TestDataServiceImpl
+        checkNotNull(testDataService) { "Expected a TestDataServiceImpl" }
+        // Force the data service to return no data for all test sources during this test.
+        testDataService.mediaSetSize = 0
+        testScope.runTest {
+            val resources = getTestableContext().getResources()
+            composeTestRule.setContent {
+                CompositionLocalProvider(
+                    LocalEmbeddedState provides testEmbeddedStateWithHostInExpandedState
+                ) {
+                    callEmbeddedPhotopickerMain(
+                        embeddedLifecycle = embeddedLifecycle.get(),
+                        featureManager = featureManager.get(),
+                        selection = selection.get(),
+                        events = events.get(),
+                    )
+                }
+            }
+            // Wait for the PhotoGridViewModel to load data and for the UI to update.
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+            composeTestRule
+                .onNode(hasText(resources.getString(R.string.photopicker_photos_empty_state_body)))
+                .assertIsDisplayed()
+            composeTestRule
+                .onNode(hasText(resources.getString(R.string.photopicker_photos_empty_state_title)))
+                .assertIsDisplayed()
+                .performTouchInput { swipeUp() }
+            // Verify whether the method to transfer touch events is invoked during testing
+            @Suppress("DEPRECATION")
+            verify(mockSurfaceControlViewHost, atLeast(1)).transferTouchGestureToHost()
+        }
+    }
+
+    @Test
+    fun testSwipeDownInExpandedMode_emptyPhotosGrid_transferTouchToHost() {
+        // This test is only allowed to run on sdk level U+
+        assumeTrue(SdkLevel.isAtLeastU())
+
+        // Initialize [EmbeddedState] instances
+        @Suppress("DEPRECATION")
+        (whenever(mockSurfaceControlViewHost.transferTouchGestureToHost()) { true })
+        testEmbeddedStateWithHostInExpandedState =
+            EmbeddedState(isExpanded = true, host = mockSurfaceControlViewHost)
+
+        val testDataService = dataService.get() as? TestDataServiceImpl
+        checkNotNull(testDataService) { "Expected a TestDataServiceImpl" }
+        // Force the data service to return no data for all test sources during this test.
+        testDataService.mediaSetSize = 0
+        testScope.runTest {
+            val resources = getTestableContext().getResources()
+            composeTestRule.setContent {
+                CompositionLocalProvider(
+                    LocalEmbeddedState provides testEmbeddedStateWithHostInExpandedState
+                ) {
+                    callEmbeddedPhotopickerMain(
+                        embeddedLifecycle = embeddedLifecycle.get(),
+                        featureManager = featureManager.get(),
+                        selection = selection.get(),
+                        events = events.get(),
+                    )
+                }
+            }
+            // Wait for the PhotoGridViewModel to load data and for the UI to update.
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+            composeTestRule
+                .onNode(hasText(resources.getString(R.string.photopicker_photos_empty_state_body)))
+                .assertIsDisplayed()
+            composeTestRule
+                .onNode(hasText(resources.getString(R.string.photopicker_photos_empty_state_title)))
+                .assertIsDisplayed()
+                .performTouchInput { swipeDown() }
+            // Verify whether the method to transfer touch events is invoked during testing
+            @Suppress("DEPRECATION")
+            verify(mockSurfaceControlViewHost, atLeast(1)).transferTouchGestureToHost()
+        }
+    }
+
+    @Test
+    fun testSwipeRightInExpandedMode_emptyPhotosGrid_notTransferTouchToHost() {
+        // This test is only allowed to run on sdk level U+
+        assumeTrue(SdkLevel.isAtLeastU())
+
+        // Initialize [EmbeddedState] instances
+        @Suppress("DEPRECATION")
+        (whenever(mockSurfaceControlViewHost.transferTouchGestureToHost()) { true })
+        testEmbeddedStateWithHostInExpandedState =
+            EmbeddedState(isExpanded = true, host = mockSurfaceControlViewHost)
+
+        val testDataService = dataService.get() as? TestDataServiceImpl
+        checkNotNull(testDataService) { "Expected a TestDataServiceImpl" }
+        // Force the data service to return no data for all test sources during this test.
+        testDataService.mediaSetSize = 0
+        testScope.runTest {
+            val resources = getTestableContext().getResources()
+            composeTestRule.setContent {
+                CompositionLocalProvider(
+                    LocalEmbeddedState provides testEmbeddedStateWithHostInExpandedState
+                ) {
+                    callEmbeddedPhotopickerMain(
+                        embeddedLifecycle = embeddedLifecycle.get(),
+                        featureManager = featureManager.get(),
+                        selection = selection.get(),
+                        events = events.get(),
+                    )
+                }
+            }
+            // Wait for the PhotoGridViewModel to load data and for the UI to update.
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+            composeTestRule
+                .onNode(hasText(resources.getString(R.string.photopicker_photos_empty_state_body)))
+                .assertIsDisplayed()
+            composeTestRule
+                .onNode(hasText(resources.getString(R.string.photopicker_photos_empty_state_title)))
+                .assertIsDisplayed()
+                .performTouchInput { swipeRight() }
+            // Verify whether the method to transfer touch events is invoked during testing
+            @Suppress("DEPRECATION")
+            verify(mockSurfaceControlViewHost, never()).transferTouchGestureToHost()
+        }
+    }
+
+    @Test
+    fun testPreviewDisabled_onLongPressMediaItem_photosGrid() = runTest {
+        composeTestRule.setContent {
+            CompositionLocalProvider(LocalEmbeddedState provides testEmbeddedStateExpanded) {
+                callEmbeddedPhotopickerMain(
+                    embeddedLifecycle = embeddedLifecycle.get(),
+                    featureManager = featureManager.get(),
+                    selection = selection.get(),
+                    events = events.get(),
+                )
+            }
+        }
+
+        advanceTimeBy(100)
+        composeTestRule.waitForIdle()
+
+        composeTestRule
+            .onAllNodes(
+                hasContentDescription(
+                    value = MEDIA_ITEM_CONTENT_DESCRIPTION_SUBSTRING,
+                    substring = true,
+                )
+            )
+            .onFirst()
+            .performTouchInput { longClick() }
+
+        advanceTimeBy(100)
+        composeTestRule.waitForIdle()
+
+        val route = navController.currentBackStackEntry?.destination?.route
+        assertWithMessage("Expected preview to be disabled and the current route to be Photo grid.")
+            .that(route)
+            .isEqualTo(PhotopickerDestinations.PHOTO_GRID.route)
+    }
+
+    @Test
+    fun testCloudChooseProviderBannerIsNotVisibleInEmbedded() =
+        testScope.runTest {
+            val testDeviceConfigProxy =
+                checkNotNull(deviceConfig as? TestDeviceConfigProxyImpl) {
+                    "Expected a TestDeviceConfigProxy"
+                }
+
+            testDeviceConfigProxy.setFlag(
+                NAMESPACE_MEDIAPROVIDER,
+                FEATURE_CLOUD_MEDIA_FEATURE_ENABLED.first,
+                true,
+            )
+            testDeviceConfigProxy.setFlag(
+                NAMESPACE_MEDIAPROVIDER,
+                FEATURE_CLOUD_ENFORCE_PROVIDER_ALLOWLIST.first,
+                true,
+            )
+            testDeviceConfigProxy.setFlag(
+                NAMESPACE_MEDIAPROVIDER,
+                FEATURE_CLOUD_MEDIA_PROVIDER_ALLOWLIST.first,
+                "com.android.test.cloudpicker",
+            )
+
+            configurationManager
+                .get()
+                .setCaller(
+                    callingPackage = "com.android.test.package",
+                    callingPackageUid = 12345,
+                    callingPackageLabel = "Test Package",
+                )
+            val bannerStateDao = databaseManager.acquireDao(BannerStateDao::class.java)
+
+            // Treat privacy explainer as already dismissed since it's a higher priority.
+            whenever(
+                bannerStateDao.getBannerState(
+                    nonNullableEq(BannerDefinitions.PRIVACY_EXPLAINER.id),
+                    anyInt(),
+                )
+            ) {
+                BannerState(
+                    bannerId = BannerDefinitions.PRIVACY_EXPLAINER.id,
+                    dismissed = true,
+                    uid = 12345,
+                )
+            }
+
+            val testDataService = dataService.get() as? TestDataServiceImpl
+            checkNotNull(testDataService) { "Expected a TestDataServiceImpl" }
+            testDataService.allowedProviders = listOf(cloudProvider)
+            testDataService.setAvailableProviders(listOf(localProvider))
+
+            val resources = getTestableContext().getResources()
+            val expectedTitle =
+                resources.getString(R.string.photopicker_banner_cloud_choose_provider_title)
+            val expectedMessage =
+                resources.getString(R.string.photopicker_banner_cloud_choose_provider_message)
+            bannerManager.get().refreshBanners()
+            advanceTimeBy(100)
+            composeTestRule.setContent {
+                CompositionLocalProvider(LocalEmbeddedState provides testEmbeddedStateExpanded) {
+                    callEmbeddedPhotopickerMain(
+                        embeddedLifecycle = embeddedLifecycle.get(),
+                        featureManager = featureManager.get(),
+                        selection = selection.get(),
+                        events = events.get(),
+                    )
+                }
+            }
+            composeTestRule.waitForIdle()
+            composeTestRule.onNode(hasText(expectedTitle)).assertIsNotDisplayed()
+            composeTestRule.onNode(hasText(expectedMessage)).assertIsNotDisplayed()
+        }
+
+    @Test
+    fun testCloudChooseAccountBannerIsNotVisibleInEmbedded() =
+        testScope.runTest {
+            val testDeviceConfigProxy =
+                checkNotNull(deviceConfig as? TestDeviceConfigProxyImpl) {
+                    "Expected a TestDeviceConfigProxy"
+                }
+
+            testDeviceConfigProxy.setFlag(
+                NAMESPACE_MEDIAPROVIDER,
+                FEATURE_CLOUD_MEDIA_FEATURE_ENABLED.first,
+                true,
+            )
+            testDeviceConfigProxy.setFlag(
+                NAMESPACE_MEDIAPROVIDER,
+                FEATURE_CLOUD_ENFORCE_PROVIDER_ALLOWLIST.first,
+                true,
+            )
+            testDeviceConfigProxy.setFlag(
+                NAMESPACE_MEDIAPROVIDER,
+                FEATURE_CLOUD_MEDIA_PROVIDER_ALLOWLIST.first,
+                "com.android.test.cloudpicker",
+            )
+
+            configurationManager
+                .get()
+                .setCaller(
+                    callingPackage = "com.android.test.package",
+                    callingPackageUid = 12345,
+                    callingPackageLabel = "Test Package",
+                )
+            val bannerStateDao = databaseManager.acquireDao(BannerStateDao::class.java)
+
+            // Treat privacy explainer as already dismissed since it's a higher priority.
+            whenever(
+                bannerStateDao.getBannerState(
+                    nonNullableEq(BannerDefinitions.PRIVACY_EXPLAINER.id),
+                    anyInt(),
+                )
+            ) {
+                BannerState(
+                    bannerId = BannerDefinitions.PRIVACY_EXPLAINER.id,
+                    dismissed = true,
+                    uid = 12345,
+                )
+            }
+
+            val testDataService = dataService.get() as? TestDataServiceImpl
+            checkNotNull(testDataService) { "Expected a TestDataServiceImpl" }
+            testDataService.setAvailableProviders(listOf(localProvider, cloudProvider))
+            testDataService.collectionInfo.put(
+                cloudProvider,
+                CollectionInfo(
+                    authority = cloudProvider.authority,
+                    collectionId = null,
+                    accountName = null,
+                    accountConfigurationIntent = Intent(),
+                ),
+            )
+
+            val resources = getTestableContext().getResources()
+            val expectedTitle =
+                resources.getString(R.string.photopicker_banner_cloud_choose_account_title)
+            val expectedMessage =
+                resources.getString(
+                    R.string.photopicker_banner_cloud_choose_account_message,
+                    cloudProvider.displayName,
+                )
+
+            bannerManager.get().refreshBanners()
+            advanceTimeBy(100)
+            composeTestRule.setContent {
+                CompositionLocalProvider(LocalEmbeddedState provides testEmbeddedStateExpanded) {
+                    callEmbeddedPhotopickerMain(
+                        embeddedLifecycle = embeddedLifecycle.get(),
+                        featureManager = featureManager.get(),
+                        selection = selection.get(),
+                        events = events.get(),
+                    )
+                }
+            }
+            composeTestRule.waitForIdle()
+            composeTestRule.onNode(hasText(expectedTitle)).assertIsNotDisplayed()
+            composeTestRule.onNode(hasText(expectedMessage)).assertIsNotDisplayed()
+        }
 }
diff --git a/photopicker/tests/src/com/android/photopicker/core/embedded/EmbeddedPhotopickerImplTest.kt b/photopicker/tests/src/com/android/photopicker/core/embedded/EmbeddedPhotopickerImplTest.kt
index a162d224f..b1492099b 100644
--- a/photopicker/tests/src/com/android/photopicker/core/embedded/EmbeddedPhotopickerImplTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/core/embedded/EmbeddedPhotopickerImplTest.kt
@@ -30,7 +30,7 @@ import androidx.test.ext.junit.runners.AndroidJUnit4
 import androidx.test.filters.SdkSuppress
 import androidx.test.platform.app.InstrumentationRegistry
 import com.android.photopicker.extensions.requireSystemService
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.whenever
 import com.android.providers.media.flags.Flags
 import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.ExperimentalCoroutinesApi
diff --git a/photopicker/tests/src/com/android/photopicker/core/embedded/SessionTest.kt b/photopicker/tests/src/com/android/photopicker/core/embedded/SessionTest.kt
index 02c78e166..15ee6cc89 100644
--- a/photopicker/tests/src/com/android/photopicker/core/embedded/SessionTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/core/embedded/SessionTest.kt
@@ -44,8 +44,8 @@ import androidx.compose.ui.test.SemanticsNodeInteractionCollection
 import androidx.compose.ui.test.assert
 import androidx.compose.ui.test.assertIsDisplayed
 import androidx.compose.ui.test.hasClickAction
+import androidx.compose.ui.test.hasContentDescription
 import androidx.compose.ui.test.junit4.createAndroidComposeRule
-import androidx.compose.ui.test.onAllNodesWithContentDescription
 import androidx.compose.ui.test.onFirst
 import androidx.compose.ui.test.onNodeWithText
 import androidx.compose.ui.test.performClick
@@ -78,11 +78,11 @@ import com.android.photopicker.data.model.Provider
 import com.android.photopicker.extensions.requireSystemService
 import com.android.photopicker.inject.PhotopickerTestModule
 import com.android.photopicker.inject.TestOptions
-import com.android.photopicker.test.utils.MockContentProviderWrapper
 import com.android.photopicker.tests.HiltTestActivity
-import com.android.photopicker.tests.utils.StubProvider
-import com.android.photopicker.tests.utils.mockito.capture
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.MockContentProviderWrapper
+import com.android.photopicker.util.test.StubProvider
+import com.android.photopicker.util.test.capture
+import com.android.photopicker.util.test.whenever
 import com.android.providers.media.flags.Flags
 import com.google.common.truth.Truth.assertThat
 import com.google.common.truth.Truth.assertWithMessage
@@ -192,6 +192,8 @@ class SessionTest : EmbeddedPhotopickerFeatureBaseTest() {
 
     val featureInfo = EmbeddedPhotoPickerFeatureInfo.Builder().build()
 
+    private val MEDIA_ITEM_CONTENT_DESCRIPTION_SUBSTRING: String = "taken on"
+
     // Session has a surfacePackage which outlives the test if not closed, so it always needs to be
     // closed at the end of each test to prevent any existing UI activity from leaking into the next
     // test. Hold a reference to it in the test class and try to call close in the @After block.
@@ -311,14 +313,14 @@ class SessionTest : EmbeddedPhotopickerFeatureBaseTest() {
             advanceTimeBy(100)
             composeTestRule.waitForIdle()
 
-            val resources = getTestableContext().getResources()
-
-            // This is the accessibility label for a Photo in the grid.
-            val mediaItemString = resources.getString(R.string.photopicker_media_item)
-
             // Verify that data in PhotoGrid is displayed
             composeTestRule
-                .onAllNodesWithContentDescription(mediaItemString)
+                .onAllNodes(
+                    hasContentDescription(
+                        value = MEDIA_ITEM_CONTENT_DESCRIPTION_SUBSTRING,
+                        substring = true,
+                    )
+                )
                 .onFirst()
                 .assert(hasClickAction())
                 .assertIsDisplayed()
@@ -485,13 +487,14 @@ class SessionTest : EmbeddedPhotopickerFeatureBaseTest() {
 
             clearInvocations(mockTextContextWrapper, mockClient)
 
-            val resources = getTestableContext().getResources()
-
-            // This is the accessibility label for a Photo in the grid.
-            val mediaItemString = resources.getString(R.string.photopicker_media_item)
-
             // Get all image nodes
-            val allImageNodes = composeTestRule.onAllNodesWithContentDescription(mediaItemString)
+            val allImageNodes =
+                composeTestRule.onAllNodes(
+                    hasContentDescription(
+                        value = MEDIA_ITEM_CONTENT_DESCRIPTION_SUBSTRING,
+                        substring = true,
+                    )
+                )
 
             // Make list of indices to select
             var indicesToSelect = setOf(2, 0, 4) // Select images at indices 2, 0, and 4
@@ -605,15 +608,14 @@ class SessionTest : EmbeddedPhotopickerFeatureBaseTest() {
 
             composeTestRule.waitForIdle()
 
-            clearInvocations(mockTextContextWrapper, mockClient)
-
-            val resources = getTestableContext().getResources()
-
-            // This is the accessibility label for a Photo in the grid.
-            val mediaItemString = resources.getString(R.string.photopicker_media_item)
-
             // Get all image nodes
-            val allImageNodes = composeTestRule.onAllNodesWithContentDescription(mediaItemString)
+            val allImageNodes =
+                composeTestRule.onAllNodes(
+                    hasContentDescription(
+                        value = MEDIA_ITEM_CONTENT_DESCRIPTION_SUBSTRING,
+                        substring = true,
+                    )
+                )
 
             // Make list of indices to select
             var indicesToSelect = setOf(2, 0, 4) // Select images at indices 2, 0, and 4
@@ -732,12 +734,14 @@ class SessionTest : EmbeddedPhotopickerFeatureBaseTest() {
 
             composeTestRule.waitForIdle()
 
-            val resources = getTestableContext().getResources()
-            // This is the accessibility label for a Photo in the grid.
-            val mediaItemString = resources.getString(R.string.photopicker_media_item)
-
             // Get all image nodes
-            val allImageNodes = composeTestRule.onAllNodesWithContentDescription(mediaItemString)
+            val allImageNodes =
+                composeTestRule.onAllNodes(
+                    hasContentDescription(
+                        value = MEDIA_ITEM_CONTENT_DESCRIPTION_SUBSTRING,
+                        substring = true,
+                    )
+                )
 
             // Make list of indices to select
             var indicesToSelect = setOf(2, 0, 4) // Select images at indices 2, 0, and 4
diff --git a/photopicker/tests/src/com/android/photopicker/core/events/DispatchersTest.kt b/photopicker/tests/src/com/android/photopicker/core/events/DispatchersTest.kt
new file mode 100644
index 000000000..fbc4d502e
--- /dev/null
+++ b/photopicker/tests/src/com/android/photopicker/core/events/DispatchersTest.kt
@@ -0,0 +1,392 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.tests.core.events
+
+import android.content.ContentResolver
+import android.content.Context
+import android.content.pm.PackageManager
+import android.content.pm.UserProperties
+import android.net.Uri
+import android.os.Parcel
+import android.os.UserHandle
+import android.os.UserManager
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import androidx.test.filters.SmallTest
+import androidx.test.platform.app.InstrumentationRegistry
+import com.android.modules.utils.build.SdkLevel
+import com.android.photopicker.R
+import com.android.photopicker.core.configuration.PhotopickerRuntimeEnv
+import com.android.photopicker.core.configuration.TestPhotopickerConfiguration
+import com.android.photopicker.core.configuration.provideTestConfigurationFlow
+import com.android.photopicker.core.events.Event
+import com.android.photopicker.core.events.Events
+import com.android.photopicker.core.events.Telemetry
+import com.android.photopicker.core.events.dispatchPhotopickerExpansionStateChangedEvent
+import com.android.photopicker.core.events.dispatchReportPhotopickerApiInfoEvent
+import com.android.photopicker.core.events.dispatchReportPhotopickerMediaItemStatusEvent
+import com.android.photopicker.core.events.dispatchReportPhotopickerSessionInfoEvent
+import com.android.photopicker.core.events.generatePickerSessionId
+import com.android.photopicker.core.features.FeatureManager
+import com.android.photopicker.core.features.FeatureToken
+import com.android.photopicker.core.selection.Selection
+import com.android.photopicker.core.selection.SelectionImpl
+import com.android.photopicker.core.user.UserMonitor
+import com.android.photopicker.data.DataService
+import com.android.photopicker.data.TestDataServiceImpl
+import com.android.photopicker.data.TestPrefetchDataService
+import com.android.photopicker.data.model.Group
+import com.android.photopicker.data.model.Media
+import com.android.photopicker.data.model.MediaSource
+import com.android.photopicker.util.test.mockSystemService
+import com.android.photopicker.util.test.whenever
+import com.google.common.truth.Truth.assertThat
+import dagger.Lazy
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.flow.toList
+import kotlinx.coroutines.launch
+import kotlinx.coroutines.test.StandardTestDispatcher
+import kotlinx.coroutines.test.TestScope
+import kotlinx.coroutines.test.advanceTimeBy
+import kotlinx.coroutines.test.runTest
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.ArgumentMatchers.any
+import org.mockito.Mockito.anyInt
+import org.mockito.Mockito.mock
+
+/** Unit tests for the telemetry event dispatchers */
+@SmallTest
+@RunWith(AndroidJUnit4::class)
+@OptIn(ExperimentalCoroutinesApi::class)
+class DispatchersTest {
+    private val sessionId = generatePickerSessionId()
+    private val packageUid = 12345
+
+    private val photopickerConfiguration =
+        TestPhotopickerConfiguration.build {
+            action(value = "")
+            sessionId(value = sessionId)
+            callingPackageUid(value = packageUid)
+            runtimeEnv(value = PhotopickerRuntimeEnv.EMBEDDED)
+            mimeTypes(arrayListOf("image/jpeg"))
+        }
+    private val mediaItemAlbum =
+        Group.Album(
+            id = "",
+            pickerId = 0L,
+            authority = "",
+            dateTakenMillisLong = 0L,
+            displayName = "",
+            coverUri = Uri.EMPTY,
+            coverMediaSource = MediaSource.LOCAL,
+        )
+    private val mediaItem =
+        Media.Image(
+            mediaId = "",
+            pickerId = 0L,
+            index = 9999,
+            authority = "",
+            mediaSource = MediaSource.LOCAL,
+            mediaUri = Uri.EMPTY,
+            glideLoadableUri = Uri.EMPTY,
+            dateTakenMillisLong = 0L,
+            sizeInBytes = 0,
+            mimeType = "image/jpeg",
+            standardMimeTypeExtension = 0,
+            selectionSource = Telemetry.MediaLocation.MAIN_GRID,
+            mediaItemAlbum = mediaItemAlbum,
+        )
+
+    private val lazyDataService: Lazy<DataService> = Lazy { TestDataServiceImpl() }
+
+    private lateinit var lazyEvents: Lazy<Events>
+    private lateinit var eventsDispatched: MutableList<Event>
+    private lateinit var lazyUserMonitor: Lazy<UserMonitor>
+    private lateinit var lazyMediaSelection: Lazy<Selection<Media>>
+
+    private fun setup(testScope: TestScope) {
+        val backgroundScope = testScope.backgroundScope
+        val testScheduler = testScope.testScheduler
+
+        val photopickerConfigurationStateFlow =
+            provideTestConfigurationFlow(
+                scope = backgroundScope,
+                defaultConfiguration = photopickerConfiguration,
+            )
+        val featureManager =
+            FeatureManager(
+                configuration = photopickerConfigurationStateFlow,
+                scope = backgroundScope,
+                prefetchDataService = TestPrefetchDataService(),
+            )
+
+        val events =
+            Events(
+                scope = backgroundScope,
+                configuration = photopickerConfigurationStateFlow,
+                featureManager = featureManager,
+            )
+        lazyEvents = Lazy { events }
+
+        eventsDispatched = mutableListOf()
+        backgroundScope.launch { events.flow.toList(eventsDispatched) }
+
+        val mockContext = mock(Context::class.java)
+
+        val mockUserManager = mock(UserManager::class.java)
+        mockSystemService(mockContext, UserManager::class.java) { mockUserManager }
+
+        if (SdkLevel.isAtLeastV()) {
+            whenever(mockUserManager.getUserProperties(any(UserHandle::class.java))) {
+                UserProperties.Builder().build()
+            }
+            whenever(mockUserManager.getUserBadge()) {
+                InstrumentationRegistry.getInstrumentation()
+                    .context
+                    .resources
+                    .getDrawable(R.drawable.android, /* theme= */ null)
+            }
+            whenever(mockUserManager.getProfileLabel()) { "label" }
+        }
+
+        whenever(mockContext.packageManager) { mock(PackageManager::class.java) }
+        whenever(mockContext.contentResolver) { mock(ContentResolver::class.java) }
+        whenever(mockContext.createPackageContextAsUser(any(), anyInt(), any())) { mockContext }
+        whenever(mockContext.createContextAsUser(any(UserHandle::class.java), anyInt())) {
+            mockContext
+        }
+
+        // Get primaryUserHandle: UserHandle
+        val parcel1 = Parcel.obtain()
+        parcel1.writeInt(/* primary user id */ 0)
+        parcel1.setDataPosition(0)
+        val primaryUserHandle = UserHandle(parcel1)
+        parcel1.recycle()
+
+        val userMonitor =
+            UserMonitor(
+                context = mockContext,
+                configuration = photopickerConfigurationStateFlow,
+                scope = backgroundScope,
+                dispatcher = StandardTestDispatcher(testScheduler),
+                processOwnerUserHandle = primaryUserHandle,
+            )
+        lazyUserMonitor = Lazy { userMonitor }
+
+        val selection =
+            SelectionImpl(
+                scope = backgroundScope,
+                configuration = photopickerConfigurationStateFlow,
+                preSelectedMedia = lazyDataService.get().preSelectionMediaData,
+            )
+        lazyMediaSelection = Lazy { selection }
+    }
+
+    @Test
+    fun testDispatchPhotopickerExpansionStateChangedEvent_isExpanded() = runTest {
+        // Setup
+        setup(testScope = this)
+
+        val expectedEvent =
+            Event.LogPhotopickerUIEvent(
+                dispatcherToken = FeatureToken.CORE.token,
+                sessionId = sessionId,
+                packageUid = packageUid,
+                uiEvent = Telemetry.UiEvent.EXPAND_PICKER,
+            )
+
+        // Action
+        dispatchPhotopickerExpansionStateChangedEvent(
+            coroutineScope = backgroundScope,
+            lazyEvents = lazyEvents,
+            photopickerConfiguration = photopickerConfiguration,
+            isExpanded = true,
+        )
+        advanceTimeBy(delayTimeMillis = 50)
+
+        // Assert
+        assertThat(eventsDispatched).contains(expectedEvent)
+    }
+
+    @Test
+    fun testDispatchPhotopickerExpansionStateChangedEvent_isCollapsed() = runTest {
+        // Setup
+        setup(testScope = this)
+
+        val expectedEvent =
+            Event.LogPhotopickerUIEvent(
+                dispatcherToken = FeatureToken.CORE.token,
+                sessionId = sessionId,
+                packageUid = packageUid,
+                uiEvent = Telemetry.UiEvent.COLLAPSE_PICKER,
+            )
+
+        // Action
+        dispatchPhotopickerExpansionStateChangedEvent(
+            coroutineScope = backgroundScope,
+            lazyEvents = lazyEvents,
+            photopickerConfiguration = photopickerConfiguration,
+            isExpanded = false,
+        )
+        advanceTimeBy(delayTimeMillis = 50)
+
+        // Assert
+        assertThat(eventsDispatched).contains(expectedEvent)
+    }
+
+    @Test
+    fun testDispatchReportPhotopickerMediaItemStatusEvent_selected() = runTest {
+        // Setup
+        setup(testScope = this)
+
+        val expectedEvent =
+            Event.ReportPhotopickerMediaItemStatus(
+                dispatcherToken = FeatureToken.CORE.token,
+                sessionId = sessionId,
+                mediaStatus = Telemetry.MediaStatus.SELECTED,
+                selectionSource = Telemetry.MediaLocation.MAIN_GRID,
+                itemPosition = 9999,
+                selectedAlbum = mediaItemAlbum,
+                mediaType = Telemetry.MediaType.PHOTO,
+                cloudOnly = false,
+                pickerSize = Telemetry.PickerSize.UNSET_PICKER_SIZE,
+            )
+
+        // Action
+        dispatchReportPhotopickerMediaItemStatusEvent(
+            coroutineScope = backgroundScope,
+            lazyEvents = lazyEvents,
+            photopickerConfiguration = photopickerConfiguration,
+            mediaItem = mediaItem,
+            mediaStatus = Telemetry.MediaStatus.SELECTED,
+        )
+        advanceTimeBy(delayTimeMillis = 50)
+
+        // Assert
+        assertThat(eventsDispatched).contains(expectedEvent)
+    }
+
+    @Test
+    fun testDispatchReportPhotopickerMediaItemStatusEvent_unselected() = runTest {
+        // Setup
+        setup(testScope = this)
+
+        val expectedEvent =
+            Event.ReportPhotopickerMediaItemStatus(
+                dispatcherToken = FeatureToken.CORE.token,
+                sessionId = sessionId,
+                mediaStatus = Telemetry.MediaStatus.UNSELECTED,
+                selectionSource = Telemetry.MediaLocation.MAIN_GRID,
+                itemPosition = 9999,
+                selectedAlbum = mediaItemAlbum,
+                mediaType = Telemetry.MediaType.PHOTO,
+                cloudOnly = false,
+                pickerSize = Telemetry.PickerSize.UNSET_PICKER_SIZE,
+            )
+
+        // Action
+        dispatchReportPhotopickerMediaItemStatusEvent(
+            coroutineScope = backgroundScope,
+            lazyEvents = lazyEvents,
+            photopickerConfiguration = photopickerConfiguration,
+            mediaItem = mediaItem,
+            mediaStatus = Telemetry.MediaStatus.UNSELECTED,
+        )
+        advanceTimeBy(delayTimeMillis = 50)
+
+        // Assert
+        assertThat(eventsDispatched).contains(expectedEvent)
+    }
+
+    @Test
+    fun testDispatchReportPhotopickerSessionInfoEvent() = runTest {
+        // Setup
+        setup(testScope = this)
+
+        val pickerStatus = Telemetry.PickerStatus.OPENED
+        val pickerCloseMethod = Telemetry.PickerCloseMethod.SWIPE_DOWN
+
+        val expectedEvent =
+            Event.ReportPhotopickerSessionInfo(
+                dispatcherToken = FeatureToken.CORE.token,
+                sessionId = sessionId,
+                packageUid = packageUid,
+                pickerSelection = Telemetry.PickerSelection.SINGLE,
+                cloudProviderUid = -1,
+                userProfile = Telemetry.UserProfile.PERSONAL,
+                pickerStatus = pickerStatus,
+                pickedItemsCount = 0,
+                pickedItemsSize = 0,
+                profileSwitchButtonVisible = false,
+                pickerMode = Telemetry.PickerMode.EMBEDDED_PICKER,
+                pickerCloseMethod = pickerCloseMethod,
+            )
+
+        // Action
+        dispatchReportPhotopickerSessionInfoEvent(
+            coroutineScope = backgroundScope,
+            lazyEvents = lazyEvents,
+            photopickerConfiguration = photopickerConfiguration,
+            lazyDataService = lazyDataService,
+            lazyUserMonitor = lazyUserMonitor,
+            lazyMediaSelection = lazyMediaSelection,
+            pickerStatus = pickerStatus,
+            pickerCloseMethod = pickerCloseMethod,
+        )
+        advanceTimeBy(delayTimeMillis = 50)
+
+        // Assert
+        assertThat(eventsDispatched).contains(expectedEvent)
+    }
+
+    @Test
+    fun testDispatchReportPhotopickerApiInfoEvent() = runTest {
+        // Setup
+        setup(testScope = this)
+
+        val pickerIntentAction = Telemetry.PickerIntentAction.ACTION_PICK_IMAGES
+
+        val expectedEvent =
+            Event.ReportPhotopickerApiInfo(
+                dispatcherToken = FeatureToken.CORE.token,
+                sessionId = sessionId,
+                pickerIntentAction = pickerIntentAction,
+                pickerSize = Telemetry.PickerSize.COLLAPSED,
+                mediaFilter = Telemetry.MediaType.PHOTO,
+                maxPickedItemsCount = 1,
+                selectedTab = Telemetry.SelectedTab.UNSET_SELECTED_TAB,
+                selectedAlbum = Telemetry.SelectedAlbum.UNSET_SELECTED_ALBUM,
+                isOrderedSelectionSet = false,
+                isAccentColorSet = false,
+                isDefaultTabSet = false,
+                isCloudSearchEnabled = false,
+                isLocalSearchEnabled = false,
+            )
+
+        // Action
+        dispatchReportPhotopickerApiInfoEvent(
+            coroutineScope = backgroundScope,
+            lazyEvents = lazyEvents,
+            photopickerConfiguration = photopickerConfiguration,
+            pickerIntentAction = pickerIntentAction,
+        )
+        advanceTimeBy(delayTimeMillis = 50)
+
+        // Assert
+        assertThat(eventsDispatched).contains(expectedEvent)
+    }
+}
diff --git a/photopicker/tests/src/com/android/photopicker/core/events/EventsTest.kt b/photopicker/tests/src/com/android/photopicker/core/events/EventsTest.kt
index 9142a509d..d68573bfc 100644
--- a/photopicker/tests/src/com/android/photopicker/core/events/EventsTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/core/events/EventsTest.kt
@@ -24,10 +24,13 @@ import com.android.photopicker.core.configuration.TestPhotopickerConfiguration
 import com.android.photopicker.core.configuration.provideTestConfigurationFlow
 import com.android.photopicker.core.features.FeatureManager
 import com.android.photopicker.core.features.FeatureRegistration
+import com.android.photopicker.core.features.PrefetchResultKey
+import com.android.photopicker.data.TestPrefetchDataService
 import com.android.photopicker.features.simpleuifeature.SimpleUiFeature
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.whenever
 import com.google.common.truth.Truth.assertWithMessage
 import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Deferred
 import kotlinx.coroutines.ExperimentalCoroutinesApi
 import kotlinx.coroutines.flow.toList
 import kotlinx.coroutines.launch
@@ -51,7 +54,10 @@ class EventsTest {
         object : FeatureRegistration {
             override val TAG = "MockedFeature"
 
-            override fun isEnabled(config: PhotopickerConfiguration) = true
+            override fun isEnabled(
+                config: PhotopickerConfiguration,
+                deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>>,
+            ) = true
 
             override fun build(featureManager: FeatureManager) = mockSimpleUiFeature
 
@@ -290,6 +296,7 @@ class EventsTest {
             configuration =
                 provideTestConfigurationFlow(scope = scope, defaultConfiguration = config),
             scope = scope,
+            prefetchDataService = TestPrefetchDataService(),
             registeredFeatures = features,
             /*coreEventsConsumed=*/ setOf<RegisteredEventClass>(),
             /*coreEventsProduced=*/ setOf<RegisteredEventClass>(),
diff --git a/photopicker/tests/src/com/android/photopicker/core/features/FeatureManagerTest.kt b/photopicker/tests/src/com/android/photopicker/core/features/FeatureManagerTest.kt
index 13d6c05bd..b36955452 100644
--- a/photopicker/tests/src/com/android/photopicker/core/features/FeatureManagerTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/core/features/FeatureManagerTest.kt
@@ -38,17 +38,18 @@ import com.android.photopicker.core.configuration.provideTestConfigurationFlow
 import com.android.photopicker.core.events.Event
 import com.android.photopicker.core.events.RegisteredEventClass
 import com.android.photopicker.core.events.generatePickerSessionId
+import com.android.photopicker.data.TestPrefetchDataService
 import com.android.photopicker.features.alwaysdisabledfeature.AlwaysDisabledFeature
 import com.android.photopicker.features.highpriorityuifeature.HighPriorityUiFeature
 import com.android.photopicker.features.simpleuifeature.SimpleUiFeature
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.whenever
 import com.google.common.truth.Truth.assertThat
 import com.google.common.truth.Truth.assertWithMessage
 import kotlinx.coroutines.CompletableDeferred
+import kotlinx.coroutines.Deferred
 import kotlinx.coroutines.ExperimentalCoroutinesApi
 import kotlinx.coroutines.flow.MutableStateFlow
 import kotlinx.coroutines.flow.SharingStarted
-import kotlinx.coroutines.flow.first
 import kotlinx.coroutines.flow.stateIn
 import kotlinx.coroutines.flow.update
 import kotlinx.coroutines.test.advanceTimeBy
@@ -60,6 +61,7 @@ import org.junit.Test
 import org.junit.runner.RunWith
 import org.mockito.Mockito.mock
 import org.mockito.Mockito.verify
+import src.com.android.photopicker.features.test.prefetchfeature.PrefetchFeature
 
 /** Unit tests for the [FeatureManager] */
 @SmallTest
@@ -77,6 +79,7 @@ class FeatureManagerTest {
             SimpleUiFeature.Registration,
             HighPriorityUiFeature.Registration,
             AlwaysDisabledFeature.Registration,
+            PrefetchFeature.Registration,
         )
 
     val sessionId = generatePickerSessionId()
@@ -101,15 +104,18 @@ class FeatureManagerTest {
                 FeatureManager(
                     provideTestConfigurationFlow(scope = this.backgroundScope),
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     testRegistrations,
                     /*coreEventsConsumed=*/ setOf<RegisteredEventClass>(),
                     /*coreEventsProduced=*/ setOf<RegisteredEventClass>(),
                 )
 
-            // Expect only the [SimpleUiFeature] and [HighPriorityUiFeature] to be enabled.
-            assertThat(featureManager.enabledFeatures.size).isEqualTo(2)
-            assertThat(featureManager.enabledFeatures.first() is SimpleUiFeature).isTrue()
-            assertThat(featureManager.enabledFeatures.last() is HighPriorityUiFeature).isTrue()
+            // Expect only the [SimpleUiFeature], [HighPriorityUiFeature] and [PrefetchFeature]
+            // to be enabled.
+            assertThat(featureManager.enabledFeatures.size).isEqualTo(3)
+            assertThat(featureManager.enabledFeatures.any { it is SimpleUiFeature }).isTrue()
+            assertThat(featureManager.enabledFeatures.any { it is HighPriorityUiFeature }).isTrue()
+            assertThat(featureManager.enabledFeatures.any { it is PrefetchFeature }).isTrue()
         }
     }
 
@@ -120,6 +126,7 @@ class FeatureManagerTest {
             FeatureManager(
                 provideTestConfigurationFlow(scope = this.backgroundScope),
                 this.backgroundScope,
+                TestPrefetchDataService(),
                 testRegistrations,
                 /*coreEventsConsumed=*/ setOf<RegisteredEventClass>(),
                 /*coreEventsProduced=*/ setOf<RegisteredEventClass>(),
@@ -133,6 +140,7 @@ class FeatureManagerTest {
             FeatureManager(
                 provideTestConfigurationFlow(scope = this.backgroundScope),
                 this.backgroundScope,
+                TestPrefetchDataService(),
                 /*registeredFeatures=*/ emptySet(),
                 /*coreEventsConsumed=*/ setOf<RegisteredEventClass>(),
                 /*coreEventsProduced=*/ setOf<RegisteredEventClass>(),
@@ -149,6 +157,7 @@ class FeatureManagerTest {
                 FeatureManager(
                     provideTestConfigurationFlow(scope = this.backgroundScope),
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     testRegistrations,
                     /*coreEventsConsumed=*/ setOf<RegisteredEventClass>(),
                     /*coreEventsProduced=*/ setOf<RegisteredEventClass>(),
@@ -186,6 +195,7 @@ class FeatureManagerTest {
                 FeatureManager(
                     provideTestConfigurationFlow(scope = this.backgroundScope),
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     testRegistrations,
                     /*coreEventsConsumed=*/ setOf<RegisteredEventClass>(),
                     /*coreEventsProduced=*/ setOf<RegisteredEventClass>(),
@@ -219,7 +229,10 @@ class FeatureManagerTest {
             object : FeatureRegistration {
                 override val TAG = "MockedFeature"
 
-                override fun isEnabled(config: PhotopickerConfiguration) = true
+                override fun isEnabled(
+                    config: PhotopickerConfiguration,
+                    deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>>,
+                ) = true
 
                 override fun build(featureManager: FeatureManager) = mockSimpleUiFeature
             }
@@ -237,6 +250,7 @@ class FeatureManagerTest {
             FeatureManager(
                 configFlow.stateIn(backgroundScope, SharingStarted.Eagerly, configFlow.value),
                 backgroundScope,
+                TestPrefetchDataService(),
                 setOf(mockRegistration),
                 /*coreEventsConsumed=*/ setOf<RegisteredEventClass>(),
                 /*coreEventsProduced=*/ setOf<RegisteredEventClass>(),
@@ -267,7 +281,10 @@ class FeatureManagerTest {
             object : FeatureRegistration {
                 override val TAG = "MockedFeature"
 
-                override fun isEnabled(config: PhotopickerConfiguration) = true
+                override fun isEnabled(
+                    config: PhotopickerConfiguration,
+                    deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>>,
+                ) = true
 
                 override fun build(featureManager: FeatureManager) = mockSimpleUiFeature
             }
@@ -289,6 +306,7 @@ class FeatureManagerTest {
                 FeatureManager(
                     configFlow.stateIn(backgroundScope, SharingStarted.Eagerly, configFlow.value),
                     backgroundScope,
+                    TestPrefetchDataService(),
                     setOf(mockRegistration),
                 )
             }
@@ -305,7 +323,10 @@ class FeatureManagerTest {
             object : FeatureRegistration {
                 override val TAG = "MockedFeature"
 
-                override fun isEnabled(config: PhotopickerConfiguration) = true
+                override fun isEnabled(
+                    config: PhotopickerConfiguration,
+                    deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>>,
+                ) = true
 
                 override fun build(featureManager: FeatureManager) = mockSimpleUiFeature
             }
@@ -327,6 +348,7 @@ class FeatureManagerTest {
                 FeatureManager(
                     configFlow.stateIn(backgroundScope, SharingStarted.Eagerly, configFlow.value),
                     backgroundScope,
+                    TestPrefetchDataService(),
                     setOf(mockRegistration),
                 )
             } catch (e: IllegalStateException) {
@@ -342,6 +364,7 @@ class FeatureManagerTest {
                 FeatureManager(
                     provideTestConfigurationFlow(scope = this.backgroundScope),
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     testRegistrations,
                     /*coreEventsConsumed=*/ setOf<RegisteredEventClass>(),
                     /*coreEventsProduced=*/ setOf<RegisteredEventClass>(),
@@ -378,6 +401,7 @@ class FeatureManagerTest {
                 FeatureManager(
                     provideTestConfigurationFlow(scope = this.backgroundScope),
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     testRegistrations,
                     /*coreEventsConsumed=*/ setOf<RegisteredEventClass>(),
                     /*coreEventsProduced=*/ setOf<RegisteredEventClass>(),
diff --git a/photopicker/tests/src/com/android/photopicker/core/glide/LoadMediaTest.kt b/photopicker/tests/src/com/android/photopicker/core/glide/LoadMediaTest.kt
index d9b83f6ea..6844c8898 100644
--- a/photopicker/tests/src/com/android/photopicker/core/glide/LoadMediaTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/core/glide/LoadMediaTest.kt
@@ -37,10 +37,10 @@ import com.android.photopicker.core.ConcurrencyModule
 import com.android.photopicker.core.EmbeddedServiceModule
 import com.android.photopicker.core.Main
 import com.android.photopicker.inject.PhotopickerTestModule
-import com.android.photopicker.test.utils.GlideLoadableIdlingResource
-import com.android.photopicker.test.utils.MockContentProviderWrapper
-import com.android.photopicker.tests.utils.mockito.capture
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.GlideLoadableIdlingResource
+import com.android.photopicker.util.test.MockContentProviderWrapper
+import com.android.photopicker.util.test.capture
+import com.android.photopicker.util.test.whenever
 import com.bumptech.glide.RequestBuilder
 import com.bumptech.glide.load.DataSource
 import com.bumptech.glide.load.engine.DiskCacheStrategy
@@ -70,7 +70,6 @@ import org.mockito.ArgumentCaptor
 import org.mockito.Captor
 import org.mockito.Mock
 import org.mockito.Mockito.any
-import org.mockito.Mockito.reset
 import org.mockito.Mockito.verify
 import org.mockito.MockitoAnnotations
 
@@ -200,7 +199,7 @@ class LoadMediaTest {
                 capture(uri),
                 capture(mimeType),
                 capture(options),
-                any(CancellationSignal::class.java)
+                any(CancellationSignal::class.java),
             )
 
         assertThat(uri.getValue()).isEqualTo(loadable.getLoadableUri())
@@ -256,7 +255,7 @@ class LoadMediaTest {
                 capture(uri),
                 capture(mimeType),
                 capture(options),
-                any(CancellationSignal::class.java)
+                any(CancellationSignal::class.java),
             )
 
         assertThat(uri.getValue()).isEqualTo(loadable.getLoadableUri())
@@ -311,7 +310,7 @@ class LoadMediaTest {
                 capture(uri),
                 capture(mimeType),
                 capture(options),
-                any(CancellationSignal::class.java)
+                any(CancellationSignal::class.java),
             )
 
         assertThat(uri.getValue()).isEqualTo(loadable.getLoadableUri())
@@ -370,7 +369,7 @@ class LoadMediaTest {
                 capture(uri),
                 capture(mimeType),
                 capture(options),
-                any(CancellationSignal::class.java)
+                any(CancellationSignal::class.java),
             )
 
         assertThat(uri.getValue()).isEqualTo(loadable.getLoadableUri())
@@ -410,7 +409,7 @@ class LoadMediaTest {
     private fun setupRequestListener(
         media: GlideLoadable,
         resolution: Resolution,
-        builder: RequestBuilder<Drawable>
+        builder: RequestBuilder<Drawable>,
     ): RequestBuilder<Drawable> {
 
         glideIdlingResource.loadStarted()
@@ -422,7 +421,7 @@ class LoadMediaTest {
                     ex: GlideException?,
                     model: Any?,
                     target: Target<Drawable>,
-                    isFirstResource: Boolean
+                    isFirstResource: Boolean,
                 ): Boolean {
                     glideIdlingResource.loadFinished()
                     // Return false to indicate the target hasn't been modified by the listener.
@@ -434,7 +433,7 @@ class LoadMediaTest {
                     model: Any,
                     target: Target<Drawable>,
                     datasource: DataSource,
-                    isFirstResource: Boolean
+                    isFirstResource: Boolean,
                 ): Boolean {
                     glideIdlingResource.loadFinished()
                     // Return false to indicate the target hasn't been modified by the listener.
diff --git a/photopicker/tests/src/com/android/photopicker/core/navigation/PhotopickerNavGraphTest.kt b/photopicker/tests/src/com/android/photopicker/core/navigation/PhotopickerNavGraphTest.kt
index 91258ac40..e8cad3c8e 100644
--- a/photopicker/tests/src/com/android/photopicker/core/navigation/PhotopickerNavGraphTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/core/navigation/PhotopickerNavGraphTest.kt
@@ -36,6 +36,7 @@ import com.android.photopicker.core.events.generatePickerSessionId
 import com.android.photopicker.core.features.FeatureManager
 import com.android.photopicker.core.features.FeatureRegistration
 import com.android.photopicker.core.features.LocalFeatureManager
+import com.android.photopicker.data.TestPrefetchDataService
 import com.android.photopicker.features.alwaysdisabledfeature.AlwaysDisabledFeature
 import com.android.photopicker.features.highpriorityuifeature.HighPriorityUiFeature
 import com.android.photopicker.features.simpleuifeature.SimpleUiFeature
@@ -75,6 +76,7 @@ class PhotopickerNavGraphTest {
             FeatureManager(
                 provideTestConfigurationFlow(scope = scope.backgroundScope),
                 scope,
+                TestPrefetchDataService(),
                 testRegistrations,
                 /*coreEventsConsumed=*/ setOf<RegisteredEventClass>(),
                 /*coreEventsProduced=*/ setOf<RegisteredEventClass>(),
@@ -89,7 +91,7 @@ class PhotopickerNavGraphTest {
     private fun testNavGraph(
         featureManager: FeatureManager,
         configuration: PhotopickerConfiguration =
-            PhotopickerConfiguration(action = "", sessionId = sessionId)
+            PhotopickerConfiguration(action = "", sessionId = sessionId),
     ) {
         navController = TestNavHostController(LocalContext.current)
         navController.navigatorProvider.addNavigator(ComposeNavigator())
@@ -97,7 +99,7 @@ class PhotopickerNavGraphTest {
         // Provide the feature manager to the compose stack.
         CompositionLocalProvider(
             LocalPhotopickerConfiguration provides configuration,
-            LocalFeatureManager provides featureManager
+            LocalFeatureManager provides featureManager,
         ) {
 
             // Provide the nav controller via [CompositionLocalProvider] to
@@ -120,6 +122,7 @@ class PhotopickerNavGraphTest {
             FeatureManager(
                 provideTestConfigurationFlow(scope = scope.backgroundScope),
                 scope,
+                TestPrefetchDataService(),
                 emptySet<FeatureRegistration>(),
                 /*coreEventsConsumed=*/ setOf<RegisteredEventClass>(),
                 /*coreEventsProduced=*/ setOf<RegisteredEventClass>(),
@@ -154,7 +157,7 @@ class PhotopickerNavGraphTest {
             PhotopickerConfiguration(
                 action = "",
                 startDestination = PhotopickerDestinations.ALBUM_GRID,
-                sessionId = sessionId
+                sessionId = sessionId,
             )
         composeTestRule.setContent { testNavGraph(featureManager, config) }
 
@@ -170,7 +173,7 @@ class PhotopickerNavGraphTest {
             PhotopickerConfiguration(
                 action = "",
                 startDestination = PhotopickerDestinations.PHOTO_GRID,
-                sessionId = sessionId
+                sessionId = sessionId,
             )
         composeTestRule.setContent { testNavGraph(featureManager, config) }
 
diff --git a/photopicker/tests/src/com/android/photopicker/core/network/NetworkMonitorTest.kt b/photopicker/tests/src/com/android/photopicker/core/network/NetworkMonitorTest.kt
index 10b20e69e..115025817 100644
--- a/photopicker/tests/src/com/android/photopicker/core/network/NetworkMonitorTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/core/network/NetworkMonitorTest.kt
@@ -23,9 +23,9 @@ import android.net.NetworkCapabilities
 import android.net.NetworkRequest
 import androidx.test.ext.junit.runners.AndroidJUnit4
 import androidx.test.filters.SmallTest
-import com.android.photopicker.tests.utils.mockito.capture
-import com.android.photopicker.tests.utils.mockito.mockSystemService
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.capture
+import com.android.photopicker.util.test.mockSystemService
+import com.android.photopicker.util.test.whenever
 import com.google.common.truth.Truth.assertThat
 import kotlinx.coroutines.ExperimentalCoroutinesApi
 import kotlinx.coroutines.flow.first
diff --git a/photopicker/tests/src/com/android/photopicker/core/user/UserMonitorTest.kt b/photopicker/tests/src/com/android/photopicker/core/user/UserMonitorTest.kt
index 6393ec53c..ec613a5a2 100644
--- a/photopicker/tests/src/com/android/photopicker/core/user/UserMonitorTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/core/user/UserMonitorTest.kt
@@ -36,9 +36,9 @@ import com.android.modules.utils.build.SdkLevel
 import com.android.photopicker.R
 import com.android.photopicker.core.configuration.TestPhotopickerConfiguration
 import com.android.photopicker.core.configuration.provideTestConfigurationFlow
-import com.android.photopicker.tests.utils.mockito.capture
-import com.android.photopicker.tests.utils.mockito.mockSystemService
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.capture
+import com.android.photopicker.util.test.mockSystemService
+import com.android.photopicker.util.test.whenever
 import com.google.common.truth.Truth.assertThat
 import kotlinx.coroutines.ExperimentalCoroutinesApi
 import kotlinx.coroutines.flow.first
diff --git a/photopicker/tests/src/com/android/photopicker/data/DataServiceImplTest.kt b/photopicker/tests/src/com/android/photopicker/data/DataServiceImplTest.kt
index 3a92ee588..d74cc8f7e 100644
--- a/photopicker/tests/src/com/android/photopicker/data/DataServiceImplTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/data/DataServiceImplTest.kt
@@ -46,9 +46,9 @@ import com.android.photopicker.data.model.MediaPageKey
 import com.android.photopicker.data.model.MediaSource
 import com.android.photopicker.data.model.Provider
 import com.android.photopicker.features.cloudmedia.CloudMediaFeature
-import com.android.photopicker.tests.utils.mockito.nonNullableAny
-import com.android.photopicker.tests.utils.mockito.nonNullableEq
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.nonNullableAny
+import com.android.photopicker.util.test.nonNullableEq
+import com.android.photopicker.util.test.whenever
 import com.google.common.truth.Truth.assertThat
 import kotlinx.coroutines.ExperimentalCoroutinesApi
 import kotlinx.coroutines.flow.MutableStateFlow
@@ -133,6 +133,7 @@ class DataServiceImplTest {
             FeatureManager(
                 provideTestConfigurationFlow(scope = scope.backgroundScope),
                 scope,
+                TestPrefetchDataService(),
                 setOf(CloudMediaFeature.Registration),
                 setOf<RegisteredEventClass>(),
                 setOf<RegisteredEventClass>(),
@@ -199,6 +200,7 @@ class DataServiceImplTest {
                         ),
                 ),
                 this.backgroundScope,
+                TestPrefetchDataService(),
                 setOf(CloudMediaFeature.Registration),
                 setOf<RegisteredEventClass>(),
                 setOf<RegisteredEventClass>(),
@@ -295,6 +297,7 @@ class DataServiceImplTest {
             FeatureManager(
                 provideTestConfigurationFlow(scope = scope.backgroundScope),
                 scope,
+                TestPrefetchDataService(),
                 setOf(), // Don't register CloudMediaFeature
                 setOf<RegisteredEventClass>(),
                 setOf<RegisteredEventClass>(),
@@ -364,6 +367,7 @@ class DataServiceImplTest {
                         ),
                 ),
                 this.backgroundScope,
+                TestPrefetchDataService(),
                 setOf(CloudMediaFeature.Registration),
                 setOf<RegisteredEventClass>(),
                 setOf<RegisteredEventClass>(),
@@ -1057,6 +1061,7 @@ class DataServiceImplTest {
                         ),
                 ),
                 this.backgroundScope,
+                TestPrefetchDataService(),
                 setOf(CloudMediaFeature.Registration),
                 setOf<RegisteredEventClass>(),
                 setOf<RegisteredEventClass>(),
diff --git a/photopicker/tests/src/com/android/photopicker/data/TestDataServiceImpl.kt b/photopicker/tests/src/com/android/photopicker/data/TestDataServiceImpl.kt
index aca60eb7e..3d7a08810 100644
--- a/photopicker/tests/src/com/android/photopicker/data/TestDataServiceImpl.kt
+++ b/photopicker/tests/src/com/android/photopicker/data/TestDataServiceImpl.kt
@@ -16,6 +16,7 @@
 
 package com.android.photopicker.data
 
+import android.content.ContentResolver
 import android.net.Uri
 import androidx.paging.PagingSource
 import com.android.photopicker.data.model.CloudMediaProviderDetails
@@ -66,6 +67,9 @@ class TestDataServiceImpl() : DataService {
         _availableProviders.update { newProviders }
     }
 
+    override val activeContentResolver: StateFlow<ContentResolver>
+        get() = TODO("Not yet implemented")
+
     override val preGrantedMediaCount: StateFlow<Int> = _preGrantsCount
     override val preSelectionMediaData: StateFlow<List<Media>?> =
         MutableStateFlow(ArrayList<Media>())
@@ -96,7 +100,7 @@ class TestDataServiceImpl() : DataService {
 
     override fun previewMediaPagingSource(
         currentSelection: Set<Media>,
-        currentDeselection: Set<Media>
+        currentDeselection: Set<Media>,
     ): PagingSource<MediaPageKey, Media> {
         // re-using the media source, modify as per future test usage.
         return mediaList?.let { FakeInMemoryMediaPagingSource(it) }
diff --git a/photopicker/tests/src/com/android/photopicker/data/TestMediaProvider.kt b/photopicker/tests/src/com/android/photopicker/data/TestMediaProvider.kt
index 6f0245d40..9c5d5fe01 100644
--- a/photopicker/tests/src/com/android/photopicker/data/TestMediaProvider.kt
+++ b/photopicker/tests/src/com/android/photopicker/data/TestMediaProvider.kt
@@ -22,6 +22,7 @@ import android.net.Uri
 import android.os.Bundle
 import android.os.CancellationSignal
 import android.test.mock.MockContentProvider
+import androidx.core.os.bundleOf
 import com.android.photopicker.data.model.CollectionInfo
 import com.android.photopicker.data.model.Group
 import com.android.photopicker.data.model.Media
@@ -44,7 +45,7 @@ val DEFAULT_PROVIDERS: List<Provider> =
             authority = "test_authority",
             mediaSource = MediaSource.LOCAL,
             uid = 0,
-            displayName = "Test app"
+            displayName = "Test app",
         )
     )
 
@@ -53,7 +54,7 @@ val DEFAULT_COLLECTION_INFO: List<CollectionInfo> =
         CollectionInfo(
             authority = "test_authority",
             collectionId = "1",
-            accountName = "default@test.com"
+            accountName = "default@test.com",
         )
     )
 
@@ -67,16 +68,14 @@ val DEFAULT_MEDIA: List<Media> =
     )
 
 val DEFAULT_ALBUMS: List<Group.Album> =
-    listOf(
-        createAlbum("Favorites"),
-        createAlbum("Downloads"),
-        createAlbum("CloudAlbum"),
-    )
+    listOf(createAlbum("Favorites"), createAlbum("Downloads"), createAlbum("CloudAlbum"))
 
 val DEFAULT_ALBUM_NAME = "album_id"
 
 val DEFAULT_ALBUM_MEDIA: Map<String, List<Media>> = mapOf(DEFAULT_ALBUM_NAME to DEFAULT_MEDIA)
 
+val DEFAULT_SEARCH_REQUEST_ID: Int = 100
+
 fun createMediaImage(pickerId: Long): Media {
     return Media.Image(
         mediaId = UUID.randomUUID().toString(),
@@ -88,7 +87,7 @@ fun createMediaImage(pickerId: Long): Media {
         dateTakenMillisLong = Long.MAX_VALUE,
         sizeInBytes = 10,
         mimeType = "image/*",
-        standardMimeTypeExtension = 0
+        standardMimeTypeExtension = 0,
     )
 }
 
@@ -100,7 +99,7 @@ fun createAlbum(albumId: String): Group.Album {
         dateTakenMillisLong = Long.MAX_VALUE,
         displayName = albumId,
         coverUri = Uri.parse("content://media/picker/authority/media/$albumId"),
-        coverMediaSource = MediaSource.LOCAL
+        coverMediaSource = MediaSource.LOCAL,
     )
 }
 
@@ -109,7 +108,8 @@ class TestMediaProvider(
     var collectionInfos: List<CollectionInfo> = DEFAULT_COLLECTION_INFO,
     var media: List<Media> = DEFAULT_MEDIA,
     var albums: List<Group.Album> = DEFAULT_ALBUMS,
-    var albumMedia: Map<String, List<Media>> = DEFAULT_ALBUM_MEDIA
+    var albumMedia: Map<String, List<Media>> = DEFAULT_ALBUM_MEDIA,
+    var searchRequestId: Int = DEFAULT_SEARCH_REQUEST_ID,
 ) : MockContentProvider() {
     var lastRefreshMediaRequest: Bundle? = null
     var TEST_GRANTS_COUNT = 2
@@ -118,7 +118,7 @@ class TestMediaProvider(
         uri: Uri,
         projection: Array<String>?,
         queryArgs: Bundle?,
-        cancellationSignal: CancellationSignal?
+        cancellationSignal: CancellationSignal?,
     ): Cursor? {
         return when (uri.lastPathSegment) {
             "available_providers" -> getAvailableProviders()
@@ -132,6 +132,9 @@ class TestMediaProvider(
                 if (pathSegments.size == 4 && pathSegments[2].equals("album")) {
                     // Album media query
                     return getAlbumMedia(pathSegments[3])
+                } else if (pathSegments.size == 4 && pathSegments[2].equals("search_media")) {
+                    // Search results media query
+                    return getMedia()
                 } else {
                     throw UnsupportedOperationException("Could not recognize uri $uri")
                 }
@@ -145,6 +148,9 @@ class TestMediaProvider(
                 initMedia(extras)
                 null
             }
+            "picker_internal_search_media_init" -> {
+                bundleOf(MediaProviderClient.SEARCH_REQUEST_ID to searchRequestId)
+            }
             else -> throw UnsupportedOperationException("Could not recognize method $method")
         }
     }
@@ -157,7 +163,7 @@ class TestMediaProvider(
                     MediaProviderClient.AvailableProviderResponse.AUTHORITY.key,
                     MediaProviderClient.AvailableProviderResponse.MEDIA_SOURCE.key,
                     MediaProviderClient.AvailableProviderResponse.UID.key,
-                    MediaProviderClient.AvailableProviderResponse.DISPLAY_NAME.key
+                    MediaProviderClient.AvailableProviderResponse.DISPLAY_NAME.key,
                 )
             )
         providers.forEach { provider ->
@@ -166,7 +172,7 @@ class TestMediaProvider(
                     provider.authority,
                     provider.mediaSource.name,
                     provider.uid.toString(),
-                    provider.displayName
+                    provider.displayName,
                 )
             )
         }
@@ -179,7 +185,7 @@ class TestMediaProvider(
                 arrayOf(
                     MediaProviderClient.CollectionInfoResponse.AUTHORITY.key,
                     MediaProviderClient.CollectionInfoResponse.COLLECTION_ID.key,
-                    MediaProviderClient.CollectionInfoResponse.ACCOUNT_NAME.key
+                    MediaProviderClient.CollectionInfoResponse.ACCOUNT_NAME.key,
                 )
             )
         cursor.setExtras(Bundle())
@@ -188,7 +194,7 @@ class TestMediaProvider(
                 arrayOf(
                     collectionInfo.authority,
                     collectionInfo.collectionId,
-                    collectionInfo.accountName
+                    collectionInfo.accountName,
                 )
             )
             cursor
diff --git a/photopicker/tests/src/com/android/photopicker/data/TestPrefetchDataService.kt b/photopicker/tests/src/com/android/photopicker/data/TestPrefetchDataService.kt
new file mode 100644
index 000000000..c66d25635
--- /dev/null
+++ b/photopicker/tests/src/com/android/photopicker/data/TestPrefetchDataService.kt
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.data
+
+import com.android.photopicker.features.search.model.SearchEnabledState
+
+class TestPrefetchDataService() : PrefetchDataService {
+    var searchEnabledState = SearchEnabledState.ENABLED
+
+    override suspend fun getSearchState(): SearchEnabledState {
+        return searchEnabledState
+    }
+}
diff --git a/photopicker/tests/src/com/android/photopicker/data/paging/AlbumMediaPagingSourceTest.kt b/photopicker/tests/src/com/android/photopicker/data/paging/AlbumMediaPagingSourceTest.kt
index d3f97a2eb..920b83913 100644
--- a/photopicker/tests/src/com/android/photopicker/data/paging/AlbumMediaPagingSourceTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/data/paging/AlbumMediaPagingSourceTest.kt
@@ -30,6 +30,7 @@ import com.android.photopicker.core.features.FeatureManager
 import com.android.photopicker.core.features.FeatureRegistration
 import com.android.photopicker.data.MediaProviderClient
 import com.android.photopicker.data.TestMediaProvider
+import com.android.photopicker.data.TestPrefetchDataService
 import com.android.photopicker.data.model.MediaPageKey
 import com.android.photopicker.data.model.MediaSource
 import com.android.photopicker.data.model.Provider
@@ -78,6 +79,7 @@ class AlbumMediaPagingSourceTest {
             FeatureManager(
                 provideTestConfigurationFlow(this.backgroundScope, testPhotopickerConfiguration),
                 this.backgroundScope,
+                TestPrefetchDataService(),
                 emptySet<FeatureRegistration>(),
             )
         val events =
diff --git a/photopicker/tests/src/com/android/photopicker/data/paging/AlbumPagingSourceTest.kt b/photopicker/tests/src/com/android/photopicker/data/paging/AlbumPagingSourceTest.kt
index 6f9d5bdf9..888555d20 100644
--- a/photopicker/tests/src/com/android/photopicker/data/paging/AlbumPagingSourceTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/data/paging/AlbumPagingSourceTest.kt
@@ -30,6 +30,7 @@ import com.android.photopicker.core.features.FeatureManager
 import com.android.photopicker.core.features.FeatureRegistration
 import com.android.photopicker.data.MediaProviderClient
 import com.android.photopicker.data.TestMediaProvider
+import com.android.photopicker.data.TestPrefetchDataService
 import com.android.photopicker.data.model.MediaPageKey
 import com.android.photopicker.data.model.Provider
 import com.android.photopicker.data.paging.AlbumPagingSource
@@ -74,6 +75,7 @@ class AlbumPagingSourceTest {
             FeatureManager(
                 provideTestConfigurationFlow(this.backgroundScope, testPhotopickerConfiguration),
                 this.backgroundScope,
+                TestPrefetchDataService(),
                 emptySet<FeatureRegistration>(),
             )
         val events =
diff --git a/photopicker/tests/src/com/android/photopicker/data/paging/FakeInMemoryAlbumPagingSource.kt b/photopicker/tests/src/com/android/photopicker/data/paging/FakeInMemoryAlbumPagingSource.kt
index 5589f3e35..d25e49a12 100644
--- a/photopicker/tests/src/com/android/photopicker/data/paging/FakeInMemoryAlbumPagingSource.kt
+++ b/photopicker/tests/src/com/android/photopicker/data/paging/FakeInMemoryAlbumPagingSource.kt
@@ -29,7 +29,7 @@ import java.time.ZoneOffset
 import java.time.temporal.ChronoUnit
 
 /**
- * This [FakeInMemoryMediaPagingSource] class is responsible to providing paginated media data from
+ * This [FakeInMemoryAlbumPagingSource] class is responsible to providing paginated album data from
  * Picker Database by serving requests from Paging library.
  *
  * It generates and returns its own fake data.
@@ -37,15 +37,15 @@ import java.time.temporal.ChronoUnit
 class FakeInMemoryAlbumPagingSource
 private constructor(
     val DATA_SIZE: Int = DEFAULT_SIZE,
-    private val DATA_LIST: List<Group.Album>? = null
+    private val DATA_LIST: List<Group.Album>? = null,
 ) : PagingSource<MediaPageKey, Group.Album>() {
 
     companion object {
         const val TEST_ALBUM_NAME_PREFIX = "AlbumNumber_"
-        const val DEFAULT_SIZE = 10_000
+        const val DEFAULT_SIZE = 1_000
     }
 
-    constructor(dataSize: Int = 10_000) : this(dataSize, null)
+    constructor(dataSize: Int = DEFAULT_SIZE) : this(dataSize, null)
 
     constructor(dataList: List<Group.Album>) : this(DEFAULT_SIZE, dataList)
 
@@ -75,7 +75,7 @@ private constructor(
                                     .minus(i.toLong(), ChronoUnit.DAYS)
                                     .toEpochSecond(ZoneOffset.UTC) * 1000,
                             coverMediaSource = MediaSource.LOCAL,
-                        ),
+                        )
                     )
                 }
             }
@@ -87,11 +87,7 @@ private constructor(
         // Handle a data size of 0 for the first page, and return an empty page with no further
         // keys.
         if (DATA.size == 0 && params.key == null) {
-            return LoadResult.Page(
-                data = emptyList(),
-                nextKey = null,
-                prevKey = null,
-            )
+            return LoadResult.Page(data = emptyList(), nextKey = null, prevKey = null)
         }
 
         // This is inefficient, but a reliable way to locate the record being requested by the
@@ -137,11 +133,7 @@ private constructor(
                 )
             }
 
-        return LoadResult.Page(
-            data = pageData,
-            nextKey = nextKey,
-            prevKey = prevKey,
-        )
+        return LoadResult.Page(data = pageData, nextKey = nextKey, prevKey = prevKey)
     }
 
     override fun getRefreshKey(state: PagingState<MediaPageKey, Group.Album>): MediaPageKey? {
diff --git a/photopicker/tests/src/com/android/photopicker/data/paging/FakeInMemoryMediaPagingSource.kt b/photopicker/tests/src/com/android/photopicker/data/paging/FakeInMemoryMediaPagingSource.kt
index c26967942..9b51dd857 100644
--- a/photopicker/tests/src/com/android/photopicker/data/paging/FakeInMemoryMediaPagingSource.kt
+++ b/photopicker/tests/src/com/android/photopicker/data/paging/FakeInMemoryMediaPagingSource.kt
@@ -39,10 +39,10 @@ private constructor(val DATA_SIZE: Int = DEFAULT_SIZE, private val DATA_LIST: Li
     PagingSource<MediaPageKey, Media>() {
 
     companion object {
-        const val DEFAULT_SIZE = 10_000
+        const val DEFAULT_SIZE = 1_000
     }
 
-    constructor(dataSize: Int = 10_000) : this(dataSize, null)
+    constructor(dataSize: Int = DEFAULT_SIZE) : this(dataSize, null)
 
     constructor(dataList: List<Media>) : this(DEFAULT_SIZE, dataList)
 
@@ -94,11 +94,7 @@ private constructor(val DATA_SIZE: Int = DEFAULT_SIZE, private val DATA_LIST: Li
         // Handle a data size of 0 for the first page, and return an empty page with no further
         // keys.
         if (DATA_SIZE == 0 && params.key == null) {
-            return LoadResult.Page(
-                data = emptyList(),
-                nextKey = null,
-                prevKey = null,
-            )
+            return LoadResult.Page(data = emptyList(), nextKey = null, prevKey = null)
         }
 
         // This is inefficient, but a reliable way to locate the record being requested by the
@@ -124,7 +120,7 @@ private constructor(val DATA_SIZE: Int = DEFAULT_SIZE, private val DATA_LIST: Li
             else
                 MediaPageKey(
                     pickerId = nextRow.pickerId,
-                    dateTakenMillis = nextRow.dateTakenMillisLong
+                    dateTakenMillis = nextRow.dateTakenMillisLong,
                 )
 
         // Find the start of the previous page and generate a Page key.
@@ -134,14 +130,10 @@ private constructor(val DATA_SIZE: Int = DEFAULT_SIZE, private val DATA_LIST: Li
             else
                 MediaPageKey(
                     pickerId = prevPageRow.pickerId,
-                    dateTakenMillis = prevPageRow.dateTakenMillisLong
+                    dateTakenMillis = prevPageRow.dateTakenMillisLong,
                 )
 
-        return LoadResult.Page(
-            data = pageData,
-            nextKey = nextKey,
-            prevKey = prevKey,
-        )
+        return LoadResult.Page(data = pageData, nextKey = nextKey, prevKey = prevKey)
     }
 
     override fun getRefreshKey(state: PagingState<MediaPageKey, Media>): MediaPageKey? {
diff --git a/photopicker/tests/src/com/android/photopicker/data/paging/MediaPagingSourceTest.kt b/photopicker/tests/src/com/android/photopicker/data/paging/MediaPagingSourceTest.kt
index 7e8c53a9d..ba42eb58a 100644
--- a/photopicker/tests/src/com/android/photopicker/data/paging/MediaPagingSourceTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/data/paging/MediaPagingSourceTest.kt
@@ -30,6 +30,7 @@ import com.android.photopicker.core.features.FeatureManager
 import com.android.photopicker.core.features.FeatureRegistration
 import com.android.photopicker.data.MediaProviderClient
 import com.android.photopicker.data.TestMediaProvider
+import com.android.photopicker.data.TestPrefetchDataService
 import com.android.photopicker.data.model.MediaPageKey
 import com.android.photopicker.data.model.Provider
 import com.android.photopicker.data.paging.MediaPagingSource
@@ -74,6 +75,7 @@ class MediaPagingSourceTest {
             FeatureManager(
                 provideTestConfigurationFlow(this.backgroundScope, testPhotopickerConfiguration),
                 this.backgroundScope,
+                TestPrefetchDataService(),
                 emptySet<FeatureRegistration>(),
             )
         val events =
diff --git a/photopicker/tests/src/com/android/photopicker/data/paging/MediaProviderClientTest.kt b/photopicker/tests/src/com/android/photopicker/data/paging/MediaProviderClientTest.kt
index f36e28eb2..ae04b290b 100644
--- a/photopicker/tests/src/com/android/photopicker/data/paging/MediaProviderClientTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/data/paging/MediaProviderClientTest.kt
@@ -26,6 +26,7 @@ import androidx.test.filters.SmallTest
 import com.android.photopicker.core.configuration.PhotopickerConfiguration
 import com.android.photopicker.core.configuration.TestPhotopickerConfiguration
 import com.android.photopicker.core.events.generatePickerSessionId
+import com.android.photopicker.data.DEFAULT_SEARCH_REQUEST_ID
 import com.android.photopicker.data.MediaProviderClient
 import com.android.photopicker.data.TestMediaProvider
 import com.android.photopicker.data.model.Group
@@ -33,6 +34,7 @@ import com.android.photopicker.data.model.Media
 import com.android.photopicker.data.model.MediaPageKey
 import com.android.photopicker.data.model.MediaSource
 import com.android.photopicker.data.model.Provider
+import com.android.photopicker.features.search.model.SearchRequest
 import com.google.common.truth.Truth.assertThat
 import kotlinx.coroutines.test.runTest
 import org.junit.Test
@@ -404,4 +406,60 @@ class MediaProviderClientTest {
             assertThat(albumMedia[index]).isEqualTo(expectedAlbumMedia[index])
         }
     }
+
+    @Test
+    fun testFetchSearchResultsPage() = runTest {
+        val mediaProviderClient = MediaProviderClient()
+
+        val mediaLoadResult: LoadResult<MediaPageKey, Media> =
+            mediaProviderClient.fetchSearchResults(
+                searchRequestId = 1,
+                pageKey = MediaPageKey(),
+                pageSize = 5,
+                contentResolver = testContentResolver,
+                availableProviders = listOf(Provider("provider", MediaSource.LOCAL, 0, "")),
+                config =
+                    PhotopickerConfiguration(
+                        action = MediaStore.ACTION_PICK_IMAGES,
+                        sessionId = sessionId,
+                    ),
+                cancellationSignal = null,
+            )
+
+        assertThat(mediaLoadResult is LoadResult.Page).isTrue()
+
+        val media: List<Media> = (mediaLoadResult as LoadResult.Page).data
+
+        assertThat(media.count()).isEqualTo(testContentProvider.media.count())
+        for (index in media.indices) {
+            assertThat(media[index]).isEqualTo(testContentProvider.media[index])
+        }
+    }
+
+    @Test
+    fun testCreateSearchRequest() = runTest {
+        val mediaProviderClient = MediaProviderClient()
+        val providers: List<Provider> =
+            mutableListOf(
+                Provider(
+                    authority = "local_authority",
+                    mediaSource = MediaSource.LOCAL,
+                    uid = 0,
+                    displayName = "",
+                )
+            )
+        val config =
+            PhotopickerConfiguration(action = MediaStore.ACTION_PICK_IMAGES, sessionId = sessionId)
+        val searchRequest = SearchRequest.SearchTextRequest("search_text")
+
+        val searchRequestId =
+            mediaProviderClient.createSearchRequest(
+                searchRequest = searchRequest,
+                providers = providers,
+                resolver = testContentResolver,
+                config = config,
+            )
+
+        assertThat(searchRequestId).isEqualTo(DEFAULT_SEARCH_REQUEST_ID)
+    }
 }
diff --git a/photopicker/tests/src/com/android/photopicker/features/albumgrid/AlbumGridFeatureTest.kt b/photopicker/tests/src/com/android/photopicker/features/albumgrid/AlbumGridFeatureTest.kt
index b5f75ffa7..4305be5bf 100644
--- a/photopicker/tests/src/com/android/photopicker/features/albumgrid/AlbumGridFeatureTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/albumgrid/AlbumGridFeatureTest.kt
@@ -28,7 +28,6 @@ import android.provider.CloudMediaProviderContract.AlbumColumns.ALBUM_ID_FAVORIT
 import android.provider.CloudMediaProviderContract.AlbumColumns.ALBUM_ID_VIDEOS
 import android.provider.MediaStore
 import android.test.mock.MockContentResolver
-import androidx.compose.runtime.getValue
 import androidx.compose.ui.test.ExperimentalTestApi
 import androidx.compose.ui.test.assert
 import androidx.compose.ui.test.assertIsDisplayed
@@ -63,9 +62,9 @@ import com.android.photopicker.data.paging.FakeInMemoryAlbumPagingSource.Compani
 import com.android.photopicker.extensions.navigateToAlbumGrid
 import com.android.photopicker.features.PhotopickerFeatureBaseTest
 import com.android.photopicker.inject.PhotopickerTestModule
-import com.android.photopicker.test.utils.MockContentProviderWrapper
 import com.android.photopicker.tests.HiltTestActivity
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.MockContentProviderWrapper
+import com.android.photopicker.util.test.whenever
 import com.google.common.truth.Truth.assertWithMessage
 import dagger.Lazy
 import dagger.Module
diff --git a/photopicker/tests/src/com/android/photopicker/features/albumgrid/AlbumGridViewModelTest.kt b/photopicker/tests/src/com/android/photopicker/features/albumgrid/AlbumGridViewModelTest.kt
index fc43125a9..4674a641b 100644
--- a/photopicker/tests/src/com/android/photopicker/features/albumgrid/AlbumGridViewModelTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/albumgrid/AlbumGridViewModelTest.kt
@@ -31,6 +31,7 @@ import com.android.photopicker.core.features.FeatureManager
 import com.android.photopicker.core.features.FeatureToken.ALBUM_GRID
 import com.android.photopicker.core.selection.SelectionImpl
 import com.android.photopicker.data.TestDataServiceImpl
+import com.android.photopicker.data.TestPrefetchDataService
 import com.android.photopicker.data.model.Group
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.data.model.MediaSource
@@ -107,13 +108,14 @@ class AlbumGridViewModelTest {
                 SelectionImpl<Media>(
                     scope = this.backgroundScope,
                     configuration = provideTestConfigurationFlow(scope = this.backgroundScope),
-                    preSelectedMedia = TestDataServiceImpl().preSelectionMediaData
+                    preSelectedMedia = TestDataServiceImpl().preSelectionMediaData,
                 )
 
             val featureManager =
                 FeatureManager(
                     configuration = provideTestConfigurationFlow(scope = this.backgroundScope),
                     scope = this.backgroundScope,
+                    prefetchDataService = TestPrefetchDataService(),
                     coreEventsConsumed = setOf<RegisteredEventClass>(),
                     coreEventsProduced = setOf<RegisteredEventClass>(),
                 )
@@ -126,12 +128,7 @@ class AlbumGridViewModelTest {
                 )
 
             val viewModel =
-                AlbumGridViewModel(
-                    this.backgroundScope,
-                    selection,
-                    TestDataServiceImpl(),
-                    events,
-                )
+                AlbumGridViewModel(this.backgroundScope, selection, TestDataServiceImpl(), events)
 
             assertWithMessage("Unexpected selection start size")
                 .that(selection.snapshot().size)
@@ -174,16 +171,17 @@ class AlbumGridViewModelTest {
                                     action = "TEST_ACTION",
                                     intent = null,
                                     selectionLimit = 0,
-                                    sessionId = generatePickerSessionId()
-                                )
+                                    sessionId = generatePickerSessionId(),
+                                ),
                         ),
-                    preSelectedMedia = TestDataServiceImpl().preSelectionMediaData
+                    preSelectedMedia = TestDataServiceImpl().preSelectionMediaData,
                 )
 
             val featureManager =
                 FeatureManager(
                     configuration = provideTestConfigurationFlow(scope = this.backgroundScope),
                     scope = this.backgroundScope,
+                    prefetchDataService = TestPrefetchDataService(),
                     coreEventsConsumed = setOf<RegisteredEventClass>(),
                     coreEventsProduced = setOf<RegisteredEventClass>(),
                 )
@@ -199,12 +197,7 @@ class AlbumGridViewModelTest {
             backgroundScope.launch { events.flow.toList(eventsDispatched) }
 
             val viewModel =
-                AlbumGridViewModel(
-                    this.backgroundScope,
-                    selection,
-                    TestDataServiceImpl(),
-                    events,
-                )
+                AlbumGridViewModel(this.backgroundScope, selection, TestDataServiceImpl(), events)
 
             assertWithMessage("Unexpected selection start size")
                 .that(selection.snapshot().size)
diff --git a/photopicker/tests/src/com/android/photopicker/features/cloudmedia/CloudMediaFeatureTest.kt b/photopicker/tests/src/com/android/photopicker/features/cloudmedia/CloudMediaFeatureTest.kt
index 46b3ebe1a..90c39982b 100644
--- a/photopicker/tests/src/com/android/photopicker/features/cloudmedia/CloudMediaFeatureTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/cloudmedia/CloudMediaFeatureTest.kt
@@ -69,8 +69,8 @@ import com.android.photopicker.features.PhotopickerFeatureBaseTest
 import com.android.photopicker.features.overflowmenu.OverflowMenuFeature
 import com.android.photopicker.inject.PhotopickerTestModule
 import com.android.photopicker.tests.HiltTestActivity
-import com.android.photopicker.tests.utils.mockito.nonNullableEq
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.nonNullableEq
+import com.android.photopicker.util.test.whenever
 import com.google.common.truth.Truth.assertWithMessage
 import dagger.Lazy
 import dagger.Module
diff --git a/photopicker/tests/src/com/android/photopicker/features/cloudmedia/MediaPreloaderTest.kt b/photopicker/tests/src/com/android/photopicker/features/cloudmedia/MediaPreloaderTest.kt
deleted file mode 100644
index 403de7cd1..000000000
--- a/photopicker/tests/src/com/android/photopicker/features/cloudmedia/MediaPreloaderTest.kt
+++ /dev/null
@@ -1,492 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.photopicker.features.cloudmedia
-
-import android.content.ContentProvider
-import android.content.ContentResolver
-import android.content.Context
-import android.content.Intent
-import android.content.pm.PackageManager
-import android.net.Uri
-import android.os.UserManager
-import android.provider.MediaStore
-import android.test.mock.MockContentResolver
-import androidx.compose.runtime.CompositionLocalProvider
-import androidx.compose.ui.Modifier
-import androidx.compose.ui.test.ExperimentalTestApi
-import androidx.compose.ui.test.assert
-import androidx.compose.ui.test.assertIsDisplayed
-import androidx.compose.ui.test.assertIsNotDisplayed
-import androidx.compose.ui.test.hasClickAction
-import androidx.compose.ui.test.hasText
-import androidx.compose.ui.test.junit4.createAndroidComposeRule
-import androidx.compose.ui.test.performClick
-import androidx.compose.ui.test.waitUntilExactlyOneExists
-import com.android.photopicker.R
-import com.android.photopicker.core.ActivityModule
-import com.android.photopicker.core.ApplicationModule
-import com.android.photopicker.core.ApplicationOwned
-import com.android.photopicker.core.Background
-import com.android.photopicker.core.ConcurrencyModule
-import com.android.photopicker.core.EmbeddedServiceModule
-import com.android.photopicker.core.Main
-import com.android.photopicker.core.ViewModelModule
-import com.android.photopicker.core.configuration.ConfigurationManager
-import com.android.photopicker.core.configuration.DeviceConfigProxy
-import com.android.photopicker.core.configuration.FEATURE_CLOUD_ENFORCE_PROVIDER_ALLOWLIST
-import com.android.photopicker.core.configuration.FEATURE_CLOUD_MEDIA_FEATURE_ENABLED
-import com.android.photopicker.core.configuration.FEATURE_CLOUD_MEDIA_PROVIDER_ALLOWLIST
-import com.android.photopicker.core.configuration.LocalPhotopickerConfiguration
-import com.android.photopicker.core.configuration.NAMESPACE_MEDIAPROVIDER
-import com.android.photopicker.core.configuration.TestDeviceConfigProxyImpl
-import com.android.photopicker.core.configuration.TestPhotopickerConfiguration
-import com.android.photopicker.core.events.Events
-import com.android.photopicker.core.events.LocalEvents
-import com.android.photopicker.core.features.FeatureManager
-import com.android.photopicker.core.features.Location
-import com.android.photopicker.core.features.LocationParams
-import com.android.photopicker.core.glide.GlideTestRule
-import com.android.photopicker.core.selection.Selection
-import com.android.photopicker.data.model.Media
-import com.android.photopicker.data.model.MediaSource
-import com.android.photopicker.features.PhotopickerFeatureBaseTest
-import com.android.photopicker.inject.PhotopickerTestModule
-import com.android.photopicker.test.utils.MockContentProviderWrapper
-import com.android.photopicker.tests.HiltTestActivity
-import com.android.photopicker.tests.utils.mockito.whenever
-import com.google.common.truth.Truth.assertWithMessage
-import dagger.Lazy
-import dagger.Module
-import dagger.hilt.InstallIn
-import dagger.hilt.android.testing.BindValue
-import dagger.hilt.android.testing.HiltAndroidRule
-import dagger.hilt.android.testing.HiltAndroidTest
-import dagger.hilt.android.testing.UninstallModules
-import dagger.hilt.components.SingletonComponent
-import java.io.FileNotFoundException
-import javax.inject.Inject
-import kotlinx.coroutines.CompletableDeferred
-import kotlinx.coroutines.CoroutineDispatcher
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.ExperimentalCoroutinesApi
-import kotlinx.coroutines.flow.MutableSharedFlow
-import kotlinx.coroutines.test.StandardTestDispatcher
-import kotlinx.coroutines.test.TestScope
-import kotlinx.coroutines.test.advanceTimeBy
-import kotlinx.coroutines.test.runTest
-import org.junit.Before
-import org.junit.Rule
-import org.junit.Test
-import org.mockito.Mock
-import org.mockito.Mockito.any
-import org.mockito.Mockito.times
-import org.mockito.Mockito.verify
-import org.mockito.MockitoAnnotations
-
-@UninstallModules(
-    ActivityModule::class,
-    ApplicationModule::class,
-    ConcurrencyModule::class,
-    EmbeddedServiceModule::class,
-    ViewModelModule::class,
-)
-@HiltAndroidTest
-@OptIn(ExperimentalCoroutinesApi::class, ExperimentalTestApi::class)
-class MediaPreloaderTest : PhotopickerFeatureBaseTest() {
-
-    /* Hilt's rule needs to come first to ensure the DI container is setup for the test. */
-    @get:Rule(order = 0) val hiltRule = HiltAndroidRule(this)
-    @get:Rule(order = 1)
-    val composeTestRule = createAndroidComposeRule(activityClass = HiltTestActivity::class.java)
-    @get:Rule(order = 2) val glideRule = GlideTestRule()
-
-    /* Setup dependencies for the UninstallModules for the test class. */
-    @Module @InstallIn(SingletonComponent::class) class TestModule : PhotopickerTestModule()
-
-    val testDispatcher = StandardTestDispatcher()
-
-    /* Overrides for ActivityModule */
-    val testScope: TestScope = TestScope(testDispatcher)
-    @BindValue @Main val mainScope: CoroutineScope = testScope
-    @BindValue @Background var testBackgroundScope: CoroutineScope = testScope.backgroundScope
-
-    /* Overrides for ViewModelModule */
-    @BindValue val viewModelScopeOverride: CoroutineScope? = testScope.backgroundScope
-
-    /* Overrides for the ConcurrencyModule */
-    @BindValue @Main val mainDispatcher: CoroutineDispatcher = testDispatcher
-    @BindValue @Background val backgroundDispatcher: CoroutineDispatcher = testDispatcher
-
-    /**
-     * Preview uses Glide for loading images, so we have to mock out the dependencies for Glide
-     * Replace the injected ContentResolver binding in [ApplicationModule] with this test value.
-     */
-    @BindValue @ApplicationOwned lateinit var contentResolver: ContentResolver
-    private lateinit var provider: MockContentProviderWrapper
-    @Mock lateinit var mockContentProvider: ContentProvider
-
-    // Needed for UserMonitor
-    @Mock lateinit var mockUserManager: UserManager
-    @Mock lateinit var mockPackageManager: PackageManager
-
-    @Inject lateinit var mockContext: Context
-    @Inject lateinit var selection: Lazy<Selection<Media>>
-    @Inject lateinit var featureManager: Lazy<FeatureManager>
-    @Inject override lateinit var configurationManager: Lazy<ConfigurationManager>
-    @Inject lateinit var deviceConfig: DeviceConfigProxy
-    @Inject lateinit var events: Lazy<Events>
-
-    val mediaToPreload = MutableSharedFlow<Set<Media>>()
-
-    val DATA =
-        buildList<Media>() {
-            for (i in 1..20) {
-                add(
-                    Media.Image(
-                        mediaId = "$i",
-                        pickerId = i.toLong(),
-                        authority = "a",
-                        // 50% of items should be remote items
-                        mediaSource =
-                            when (i % 2 == 0) {
-                                true -> MediaSource.LOCAL
-                                false -> MediaSource.REMOTE
-                            },
-                        mediaUri =
-                            Uri.EMPTY.buildUpon()
-                                .apply {
-                                    scheme(ContentResolver.SCHEME_CONTENT)
-                                    authority(MockContentProviderWrapper.AUTHORITY)
-                                    path("$i")
-                                }
-                                .build(),
-                        glideLoadableUri =
-                            Uri.EMPTY.buildUpon()
-                                .apply {
-                                    scheme(ContentResolver.SCHEME_CONTENT)
-                                    authority(MockContentProviderWrapper.AUTHORITY)
-                                    path("$i")
-                                }
-                                .build(),
-                        dateTakenMillisLong = 123456789L,
-                        sizeInBytes = 1000L,
-                        mimeType = "image/png",
-                        standardMimeTypeExtension = 1,
-                    )
-                )
-            }
-        }
-
-    @Before
-    fun setup() {
-        MockitoAnnotations.initMocks(this)
-
-        hiltRule.inject()
-
-        val testDeviceConfigProxy =
-            checkNotNull(deviceConfig as? TestDeviceConfigProxyImpl) {
-                "Expected a TestDeviceConfigProxy"
-            }
-
-        testDeviceConfigProxy.setFlag(
-            NAMESPACE_MEDIAPROVIDER,
-            FEATURE_CLOUD_MEDIA_FEATURE_ENABLED.first,
-            true,
-        )
-        testDeviceConfigProxy.setFlag(
-            NAMESPACE_MEDIAPROVIDER,
-            FEATURE_CLOUD_ENFORCE_PROVIDER_ALLOWLIST.first,
-            true,
-        )
-        testDeviceConfigProxy.setFlag(
-            NAMESPACE_MEDIAPROVIDER,
-            FEATURE_CLOUD_MEDIA_PROVIDER_ALLOWLIST.first,
-            "com.android.test.cloudpicker",
-        )
-
-        val testIntent =
-            Intent(MediaStore.ACTION_PICK_IMAGES).apply {
-                putExtra(MediaStore.EXTRA_PICK_IMAGES_MAX, 50)
-            }
-        configurationManager.get().setIntent(testIntent)
-
-        // Stub for MockContentResolver constructor
-        whenever(mockContext.getApplicationInfo()) { getTestableContext().getApplicationInfo() }
-
-        // Stub out the content resolver for Glide
-        val mockContentResolver = MockContentResolver(mockContext)
-        provider = MockContentProviderWrapper(mockContentProvider)
-        mockContentResolver.addProvider(MockContentProviderWrapper.AUTHORITY, provider)
-        contentResolver = mockContentResolver
-
-        // Return a resource png so that glide actually has something to load
-        whenever(mockContentProvider.openTypedAssetFile(any(), any(), any(), any())) {
-            getTestableContext().getResources().openRawResourceFd(R.drawable.android)
-        }
-        whenever(mockContentProvider.openTypedAssetFile(any(), any(), any())) {
-            getTestableContext().getResources().openRawResourceFd(R.drawable.android)
-        }
-        setupTestForUserMonitor(mockContext, mockUserManager, contentResolver, mockPackageManager)
-    }
-
-    @Test
-    fun testMediaPreloaderCompletesDeferredWhenSuccessful() =
-        testScope.runTest {
-            var preloadDeferred = CompletableDeferred<Boolean>()
-
-            composeTestRule.setContent {
-                CompositionLocalProvider(
-                    LocalPhotopickerConfiguration provides
-                        TestPhotopickerConfiguration.build {
-                            action("TEST_ACTION")
-                            intent(Intent("TEST_ACTION"))
-                        },
-                    LocalEvents provides events.get(),
-                ) {
-                    featureManager
-                        .get()
-                        .composeLocation(
-                            location = Location.MEDIA_PRELOADER,
-                            modifier = Modifier,
-                            params =
-                                object : LocationParams.WithMediaPreloader {
-                                    override fun obtainDeferred(): CompletableDeferred<Boolean> {
-                                        return preloadDeferred
-                                    }
-
-                                    override val preloadMedia = mediaToPreload
-                                },
-                        )
-                }
-            }
-            composeTestRule.waitForIdle()
-
-            selection.get().addAll(DATA)
-            advanceTimeBy(100)
-
-            mediaToPreload.emit(selection.get().snapshot())
-
-            val preloadResult = preloadDeferred.await()
-
-            assertWithMessage("Expected preload result to be true, the preload must have failed.")
-                .that(preloadResult)
-                .isTrue()
-        }
-
-    @Test
-    fun testMediaPreloaderShowsLoadingDialog() =
-        testScope.runTest {
-            val resources = getTestableContext().getResources()
-            val loadingDialogTitle =
-                resources.getString(R.string.photopicker_preloading_dialog_title)
-
-            var preloadDeferred = CompletableDeferred<Boolean>()
-            composeTestRule.setContent {
-                CompositionLocalProvider(
-                    LocalPhotopickerConfiguration provides
-                        TestPhotopickerConfiguration.build {
-                            action("TEST_ACTION")
-                            intent(Intent("TEST_ACTION"))
-                        },
-                    LocalEvents provides events.get(),
-                ) {
-                    featureManager
-                        .get()
-                        .composeLocation(
-                            location = Location.MEDIA_PRELOADER,
-                            modifier = Modifier,
-                            params =
-                                object : LocationParams.WithMediaPreloader {
-                                    override fun obtainDeferred(): CompletableDeferred<Boolean> {
-                                        return preloadDeferred
-                                    }
-
-                                    override val preloadMedia = mediaToPreload
-                                },
-                        )
-                }
-            }
-            composeTestRule.waitForIdle()
-
-            selection.get().addAll(DATA)
-            advanceTimeBy(100)
-            composeTestRule.waitForIdle()
-
-            mediaToPreload.emit(selection.get().snapshot())
-            composeTestRule.waitForIdle()
-            advanceTimeBy(100)
-
-            composeTestRule.waitUntilExactlyOneExists(hasText(loadingDialogTitle))
-            composeTestRule.onNode(hasText(loadingDialogTitle)).assertIsDisplayed()
-            composeTestRule
-                .onNode(hasText(resources.getString(android.R.string.cancel)))
-                .assert(hasClickAction())
-                .assertIsDisplayed()
-        }
-
-    @Test
-    fun testMediaPreloaderCancelPreloadFromLoadingDialog() =
-        testScope.runTest {
-            val resources = getTestableContext().getResources()
-            val loadingDialogTitle =
-                resources.getString(R.string.photopicker_preloading_dialog_title)
-
-            var preloadDeferred = CompletableDeferred<Boolean>()
-            composeTestRule.setContent {
-                CompositionLocalProvider(
-                    LocalPhotopickerConfiguration provides
-                        TestPhotopickerConfiguration.build {
-                            action("TEST_ACTION")
-                            intent(Intent("TEST_ACTION"))
-                        },
-                    LocalEvents provides events.get(),
-                ) {
-                    featureManager
-                        .get()
-                        .composeLocation(
-                            location = Location.MEDIA_PRELOADER,
-                            modifier = Modifier,
-                            params =
-                                object : LocationParams.WithMediaPreloader {
-                                    override fun obtainDeferred(): CompletableDeferred<Boolean> {
-                                        return preloadDeferred
-                                    }
-
-                                    override val preloadMedia = mediaToPreload
-                                },
-                        )
-                }
-            }
-            composeTestRule.waitForIdle()
-
-            selection.get().addAll(DATA)
-            advanceTimeBy(100)
-            composeTestRule.waitForIdle()
-
-            mediaToPreload.emit(selection.get().snapshot())
-            composeTestRule.waitForIdle()
-            advanceTimeBy(100)
-
-            composeTestRule.waitUntilExactlyOneExists(hasText(loadingDialogTitle))
-            composeTestRule.onNode(hasText(loadingDialogTitle)).assertIsDisplayed()
-            composeTestRule
-                .onNode(hasText(resources.getString(android.R.string.cancel)))
-                .assert(hasClickAction())
-                .assertIsDisplayed()
-                .performClick()
-
-            advanceTimeBy(100)
-            composeTestRule.waitForIdle()
-
-            composeTestRule.onNode(hasText(loadingDialogTitle)).assertIsNotDisplayed()
-        }
-
-    @Test
-    fun testMediaPreloaderLoadsRemoteMedia() =
-        testScope.runTest {
-            var preloadDeferred = CompletableDeferred<Boolean>()
-            composeTestRule.setContent {
-                CompositionLocalProvider(
-                    LocalPhotopickerConfiguration provides
-                        TestPhotopickerConfiguration.build {
-                            action("TEST_ACTION")
-                            intent(Intent("TEST_ACTION"))
-                        },
-                    LocalEvents provides events.get(),
-                ) {
-                    featureManager
-                        .get()
-                        .composeLocation(
-                            location = Location.MEDIA_PRELOADER,
-                            modifier = Modifier,
-                            params =
-                                object : LocationParams.WithMediaPreloader {
-                                    override fun obtainDeferred(): CompletableDeferred<Boolean> {
-                                        return preloadDeferred
-                                    }
-
-                                    override val preloadMedia = mediaToPreload
-                                },
-                        )
-                }
-            }
-            composeTestRule.waitForIdle()
-
-            selection.get().addAll(DATA)
-            advanceTimeBy(100)
-
-            mediaToPreload.emit(selection.get().snapshot())
-            advanceTimeBy(100)
-
-            advanceTimeBy(100)
-
-            // Should receive a total of 5 calls. (20 Media items and 50% are MediaSource.REMOTE)
-            verify(mockContentProvider, times(10)).openTypedAssetFile(any(), any(), any())
-        }
-
-    @Test
-    fun testMediaPreloaderFailureShowsErrorDialog() =
-        testScope.runTest {
-            var preloadDeferred = CompletableDeferred<Boolean>()
-            val resources = getTestableContext().getResources()
-            val errorDialogTitle =
-                resources.getString(R.string.photopicker_preloading_dialog_error_title)
-            val errorDialogMessage =
-                resources.getString(R.string.photopicker_preloading_dialog_error_message)
-
-            whenever(mockContentProvider.openTypedAssetFile(any(), any(), any()))
-                .thenThrow(FileNotFoundException())
-
-            composeTestRule.setContent {
-                CompositionLocalProvider(
-                    LocalPhotopickerConfiguration provides
-                        TestPhotopickerConfiguration.build {
-                            action("TEST_ACTION")
-                            intent(Intent("TEST_ACTION"))
-                        },
-                    LocalEvents provides events.get(),
-                ) {
-                    featureManager
-                        .get()
-                        .composeLocation(
-                            location = Location.MEDIA_PRELOADER,
-                            modifier = Modifier,
-                            params =
-                                object : LocationParams.WithMediaPreloader {
-                                    override fun obtainDeferred(): CompletableDeferred<Boolean> {
-                                        return preloadDeferred
-                                    }
-
-                                    override val preloadMedia = mediaToPreload
-                                },
-                        )
-                }
-            }
-            composeTestRule.waitForIdle()
-
-            selection.get().addAll(DATA)
-            advanceTimeBy(100)
-
-            mediaToPreload.emit(selection.get().snapshot())
-            advanceTimeBy(500)
-            composeTestRule.waitForIdle()
-
-            composeTestRule.waitUntilExactlyOneExists(hasText(errorDialogTitle))
-            composeTestRule.onNode(hasText(errorDialogTitle)).assertIsDisplayed()
-            composeTestRule.onNode(hasText(errorDialogMessage)).assertIsDisplayed()
-        }
-}
diff --git a/photopicker/tests/src/com/android/photopicker/features/mediaprepare/MediaPreparerTest.kt b/photopicker/tests/src/com/android/photopicker/features/mediaprepare/MediaPreparerTest.kt
new file mode 100644
index 000000000..9f25b35d0
--- /dev/null
+++ b/photopicker/tests/src/com/android/photopicker/features/mediaprepare/MediaPreparerTest.kt
@@ -0,0 +1,624 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.preparemedia
+
+import android.content.ContentProvider
+import android.content.ContentResolver
+import android.content.Context
+import android.content.Intent
+import android.content.pm.PackageManager
+import android.media.ApplicationMediaCapabilities
+import android.net.Uri
+import android.os.Build
+import android.os.Bundle
+import android.os.UserManager
+import android.platform.test.annotations.RequiresFlagsEnabled
+import android.platform.test.flag.junit.CheckFlagsRule
+import android.platform.test.flag.junit.DeviceFlagsValueProvider
+import android.provider.MediaStore
+import android.test.mock.MockContentResolver
+import androidx.activity.viewModels
+import androidx.compose.runtime.CompositionLocalProvider
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.test.ExperimentalTestApi
+import androidx.compose.ui.test.assert
+import androidx.compose.ui.test.assertIsDisplayed
+import androidx.compose.ui.test.assertIsNotDisplayed
+import androidx.compose.ui.test.hasClickAction
+import androidx.compose.ui.test.hasText
+import androidx.compose.ui.test.junit4.createAndroidComposeRule
+import androidx.compose.ui.test.performClick
+import androidx.test.filters.SdkSuppress
+import com.android.photopicker.R
+import com.android.photopicker.core.ActivityModule
+import com.android.photopicker.core.ApplicationModule
+import com.android.photopicker.core.ApplicationOwned
+import com.android.photopicker.core.Background
+import com.android.photopicker.core.ConcurrencyModule
+import com.android.photopicker.core.EmbeddedServiceModule
+import com.android.photopicker.core.Main
+import com.android.photopicker.core.ViewModelModule
+import com.android.photopicker.core.configuration.ConfigurationManager
+import com.android.photopicker.core.configuration.DeviceConfigProxy
+import com.android.photopicker.core.configuration.FEATURE_CLOUD_ENFORCE_PROVIDER_ALLOWLIST
+import com.android.photopicker.core.configuration.FEATURE_CLOUD_MEDIA_FEATURE_ENABLED
+import com.android.photopicker.core.configuration.FEATURE_CLOUD_MEDIA_PROVIDER_ALLOWLIST
+import com.android.photopicker.core.configuration.LocalPhotopickerConfiguration
+import com.android.photopicker.core.configuration.NAMESPACE_MEDIAPROVIDER
+import com.android.photopicker.core.configuration.TestDeviceConfigProxyImpl
+import com.android.photopicker.core.events.Events
+import com.android.photopicker.core.events.LocalEvents
+import com.android.photopicker.core.features.FeatureManager
+import com.android.photopicker.core.features.Location
+import com.android.photopicker.core.features.LocationParams
+import com.android.photopicker.core.glide.GlideTestRule
+import com.android.photopicker.core.selection.Selection
+import com.android.photopicker.data.PICKER_SEGMENT
+import com.android.photopicker.data.model.Media
+import com.android.photopicker.data.model.MediaSource
+import com.android.photopicker.features.PhotopickerFeatureBaseTest
+import com.android.photopicker.features.preparemedia.MediaPreparerViewModel.Companion.PICKER_TRANSCODE_RESULT
+import com.android.photopicker.features.preparemedia.TranscoderImpl.Companion.DURATION_LIMIT_MS
+import com.android.photopicker.inject.PhotopickerTestModule
+import com.android.photopicker.tests.HiltTestActivity
+import com.android.photopicker.util.test.MockContentProviderWrapper
+import com.android.photopicker.util.test.nonNullableAny
+import com.android.photopicker.util.test.whenever
+import com.android.providers.media.flags.Flags
+import com.google.common.truth.Truth.assertWithMessage
+import dagger.Lazy
+import dagger.Module
+import dagger.hilt.InstallIn
+import dagger.hilt.android.testing.BindValue
+import dagger.hilt.android.testing.HiltAndroidRule
+import dagger.hilt.android.testing.HiltAndroidTest
+import dagger.hilt.android.testing.UninstallModules
+import dagger.hilt.components.SingletonComponent
+import java.io.FileNotFoundException
+import javax.inject.Inject
+import kotlinx.coroutines.CompletableDeferred
+import kotlinx.coroutines.CoroutineDispatcher
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.flow.MutableSharedFlow
+import kotlinx.coroutines.test.StandardTestDispatcher
+import kotlinx.coroutines.test.TestScope
+import kotlinx.coroutines.test.advanceTimeBy
+import kotlinx.coroutines.test.runTest
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.mockito.Mock
+import org.mockito.Mockito.any
+import org.mockito.Mockito.mock
+import org.mockito.Mockito.times
+import org.mockito.Mockito.verify
+import org.mockito.MockitoAnnotations
+
+@UninstallModules(
+    ActivityModule::class,
+    ApplicationModule::class,
+    ConcurrencyModule::class,
+    EmbeddedServiceModule::class,
+    ViewModelModule::class,
+)
+@HiltAndroidTest
+@OptIn(ExperimentalCoroutinesApi::class, ExperimentalTestApi::class)
+class MediaPreparerTest : PhotopickerFeatureBaseTest() {
+
+    /* Hilt's rule needs to come first to ensure the DI container is setup for the test. */
+    @get:Rule(order = 0) val hiltRule = HiltAndroidRule(this)
+    @get:Rule(order = 1)
+    val composeTestRule = createAndroidComposeRule(activityClass = HiltTestActivity::class.java)
+    @get:Rule(order = 2) val glideRule = GlideTestRule()
+    @get:Rule(order = 3)
+    val checkFlagsRule: CheckFlagsRule = DeviceFlagsValueProvider.createCheckFlagsRule()
+
+    /* Setup dependencies for the UninstallModules for the test class. */
+    @Module @InstallIn(SingletonComponent::class) class TestModule : PhotopickerTestModule()
+
+    val testDispatcher = StandardTestDispatcher()
+
+    /* Overrides for ActivityModule */
+    val testScope: TestScope = TestScope(testDispatcher)
+    @BindValue @Main val mainScope: CoroutineScope = testScope
+    @BindValue @Background var testBackgroundScope: CoroutineScope = testScope.backgroundScope
+
+    /* Overrides for ViewModelModule */
+    @BindValue val viewModelScopeOverride: CoroutineScope? = testScope.backgroundScope
+
+    /* Overrides for the ConcurrencyModule */
+    @BindValue @Main val mainDispatcher: CoroutineDispatcher = testDispatcher
+    @BindValue @Background val backgroundDispatcher: CoroutineDispatcher = testDispatcher
+
+    /**
+     * Preview uses Glide for loading images, so we have to mock out the dependencies for Glide
+     * Replace the injected ContentResolver binding in [ApplicationModule] with this test value.
+     */
+    @BindValue @ApplicationOwned lateinit var contentResolver: ContentResolver
+    private lateinit var provider: MockContentProviderWrapper
+    @Mock lateinit var mockContentProvider: ContentProvider
+
+    // Needed for UserMonitor
+    @Mock lateinit var mockUserManager: UserManager
+    @Mock lateinit var mockPackageManager: PackageManager
+
+    @Inject lateinit var mockContext: Context
+    @Inject lateinit var selection: Lazy<Selection<Media>>
+    @Inject lateinit var featureManager: Lazy<FeatureManager>
+    @Inject override lateinit var configurationManager: Lazy<ConfigurationManager>
+    @Inject lateinit var deviceConfig: DeviceConfigProxy
+    @Inject lateinit var events: Lazy<Events>
+
+    val mediaToPrepare = MutableSharedFlow<Set<Media>>()
+
+    val VIDEO =
+        Media.Video(
+            mediaId = "0",
+            pickerId = 0L,
+            authority = "a",
+            mediaSource = MediaSource.LOCAL,
+            mediaUri = Uri.EMPTY,
+            glideLoadableUri = Uri.EMPTY,
+            dateTakenMillisLong = 123456789L,
+            sizeInBytes = 1000L,
+            mimeType = "video/mp4",
+            standardMimeTypeExtension = 1,
+            duration = 45_000,
+        )
+    val DATA =
+        buildList<Media>() {
+            for (i in 1..20) {
+                val uri =
+                    Uri.EMPTY.buildUpon()
+                        .apply {
+                            scheme(ContentResolver.SCHEME_CONTENT)
+                            authority(MockContentProviderWrapper.AUTHORITY)
+                            path("$i")
+                        }
+                        .build()
+                add(
+                    Media.Image(
+                        mediaId = "$i",
+                        pickerId = i.toLong(),
+                        authority = "a",
+                        // 50% of items should be remote items
+                        mediaSource =
+                            when (i % 2 == 0) {
+                                true -> MediaSource.LOCAL
+                                false -> MediaSource.REMOTE
+                            },
+                        mediaUri = uri,
+                        glideLoadableUri = uri,
+                        dateTakenMillisLong = 123456789L,
+                        sizeInBytes = 1000L,
+                        mimeType = "image/png",
+                        standardMimeTypeExtension = 1,
+                    )
+                )
+            }
+        }
+    val LOCAL_IMAGE_DATA =
+        buildList<Media>() {
+            for (i in 1..20) {
+                val uri =
+                    Uri.EMPTY.buildUpon()
+                        .apply {
+                            scheme(ContentResolver.SCHEME_CONTENT)
+                            authority(MockContentProviderWrapper.AUTHORITY)
+                            path("$i")
+                        }
+                        .build()
+                add(
+                    Media.Image(
+                        mediaId = "$i",
+                        pickerId = i.toLong(),
+                        authority = "a",
+                        mediaSource = MediaSource.LOCAL,
+                        mediaUri = uri,
+                        glideLoadableUri = uri,
+                        dateTakenMillisLong = 123456789L,
+                        sizeInBytes = 1000L,
+                        mimeType = "image/png",
+                        standardMimeTypeExtension = 1,
+                    )
+                )
+            }
+        }
+    val VIDEO_DATA =
+        buildList<Media> {
+            for (i in 1..10) {
+                val uri =
+                    Uri.EMPTY.buildUpon()
+                        .apply {
+                            scheme(ContentResolver.SCHEME_CONTENT)
+                            authority(MockContentProviderWrapper.AUTHORITY)
+                            appendPath(PICKER_SEGMENT)
+                            appendPath("user_id")
+                            appendPath("a")
+                            appendPath("media")
+                            appendPath("$i")
+                        }
+                        .build()
+                add(
+                    Media.Video(
+                        mediaId = "$i",
+                        pickerId = i.toLong(),
+                        authority = "a",
+                        // 50% of items should be remote items
+                        mediaSource =
+                            when (i % 2 == 0) {
+                                true -> MediaSource.LOCAL
+                                false -> MediaSource.REMOTE
+                            },
+                        mediaUri = uri,
+                        glideLoadableUri = uri,
+                        dateTakenMillisLong = 123456789L,
+                        sizeInBytes = 1000L,
+                        mimeType = "video/mp4",
+                        standardMimeTypeExtension = 1,
+                        duration = 45_000,
+                    )
+                )
+            }
+        }
+    val LOCAL_VIDEO_DATA_WITH_HALF_OUT_OF_DURATION_LIMITATION =
+        buildList<Media> {
+            for (i in 1..10) {
+                val uri =
+                    Uri.EMPTY.buildUpon()
+                        .apply {
+                            scheme(ContentResolver.SCHEME_CONTENT)
+                            authority(MockContentProviderWrapper.AUTHORITY)
+                            appendPath(PICKER_SEGMENT)
+                            appendPath("user_id")
+                            appendPath("a")
+                            appendPath("media")
+                            appendPath("$i")
+                        }
+                        .build()
+                add(
+                    Media.Video(
+                        mediaId = "$i",
+                        pickerId = i.toLong(),
+                        authority = "a",
+                        mediaSource = MediaSource.LOCAL,
+                        mediaUri = uri,
+                        glideLoadableUri = uri,
+                        dateTakenMillisLong = 123456789L,
+                        sizeInBytes = 1000L,
+                        mimeType = "video/mp4",
+                        standardMimeTypeExtension = 1,
+                        // 50% of items should be out of duration limit
+                        duration =
+                            when (i % 2 == 0) {
+                                true -> 90_000
+                                false -> 45_000
+                            },
+                    )
+                )
+            }
+        }
+
+    @Before
+    fun setup() {
+        MockitoAnnotations.initMocks(this)
+
+        hiltRule.inject()
+
+        val testDeviceConfigProxy =
+            checkNotNull(deviceConfig as? TestDeviceConfigProxyImpl) {
+                "Expected a TestDeviceConfigProxy"
+            }
+
+        testDeviceConfigProxy.setFlag(
+            NAMESPACE_MEDIAPROVIDER,
+            FEATURE_CLOUD_MEDIA_FEATURE_ENABLED.first,
+            true,
+        )
+        testDeviceConfigProxy.setFlag(
+            NAMESPACE_MEDIAPROVIDER,
+            FEATURE_CLOUD_ENFORCE_PROVIDER_ALLOWLIST.first,
+            true,
+        )
+        testDeviceConfigProxy.setFlag(
+            NAMESPACE_MEDIAPROVIDER,
+            FEATURE_CLOUD_MEDIA_PROVIDER_ALLOWLIST.first,
+            "com.android.test.cloudpicker",
+        )
+
+        val testIntent =
+            Intent(MediaStore.ACTION_PICK_IMAGES).apply {
+                putExtra(MediaStore.EXTRA_PICK_IMAGES_MAX, 50)
+                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
+                    val testMediaCapabilities = ApplicationMediaCapabilities.Builder().build()
+                    putExtra(MediaStore.EXTRA_MEDIA_CAPABILITIES, testMediaCapabilities)
+                }
+            }
+        configurationManager.get().setIntent(testIntent)
+
+        // Stub for MockContentResolver constructor
+        whenever(mockContext.getApplicationInfo()) { getTestableContext().getApplicationInfo() }
+
+        // Stub out the content resolver for Glide
+        val mockContentResolver = MockContentResolver(mockContext)
+        provider = MockContentProviderWrapper(mockContentProvider)
+        mockContentResolver.addProvider(MockContentProviderWrapper.AUTHORITY, provider)
+        contentResolver = mockContentResolver
+
+        // Return a resource png so that glide actually has something to load
+        whenever(mockContentProvider.openTypedAssetFile(any(), any(), any(), any())) {
+            getTestableContext().getResources().openRawResourceFd(R.drawable.android)
+        }
+        whenever(mockContentProvider.openTypedAssetFile(any(), any(), any())) {
+            getTestableContext().getResources().openRawResourceFd(R.drawable.android)
+        }
+        // Return success flag when transcoding is requested.
+        whenever(mockContentProvider.call(any(), any(), any(), any())) {
+            Bundle().apply { putBoolean(PICKER_TRANSCODE_RESULT, true) }
+        }
+        setupTestForUserMonitor(mockContext, mockUserManager, contentResolver, mockPackageManager)
+    }
+
+    @Test
+    fun testMediaPreparerCompletesDeferredWhenSuccessful() =
+        testScope.runTest {
+            val prepareDeferred = CompletableDeferred<PrepareMediaResult>()
+            initialMediaPreparer(prepareDeferred)
+
+            selection.get().addAll(DATA)
+            advanceTimeBy(100)
+
+            val snapshot = selection.get().snapshot()
+            mediaToPrepare.emit(snapshot)
+
+            val prepareResult = prepareDeferred.await()
+
+            assertWithMessage("Expected prepare result to be true, the prepare must have failed.")
+                .that(prepareResult is PrepareMediaResult.PreparedMedia)
+                .isTrue()
+
+            val preparedMedia = (prepareResult as? PrepareMediaResult.PreparedMedia)?.preparedMedia
+            assertWithMessage("Expected prepared media size was not same as selected")
+                .that(snapshot.size == preparedMedia?.size)
+                .isTrue()
+        }
+
+    @Test
+    fun testMediaPreparerCompletesDeferredWhenPreparationNotRequired() =
+        testScope.runTest {
+            val prepareDeferred = CompletableDeferred<PrepareMediaResult>()
+            initialMediaPreparer(prepareDeferred)
+
+            // Local images do not need to be preloaded and transcoded.
+            selection.get().addAll(LOCAL_IMAGE_DATA)
+            advanceTimeBy(100)
+
+            val snapshot = selection.get().snapshot()
+            mediaToPrepare.emit(snapshot)
+
+            val prepareResult = prepareDeferred.await()
+
+            assertWithMessage("Expected prepare result to be true, the prepare must have failed.")
+                .that(prepareResult is PrepareMediaResult.PreparedMedia)
+                .isTrue()
+
+            val preparedMedia = (prepareResult as? PrepareMediaResult.PreparedMedia)?.preparedMedia
+            assertWithMessage("Expected prepared media size was not same as selected")
+                .that(snapshot.size == preparedMedia?.size)
+                .isTrue()
+        }
+
+    @Test
+    fun testMediaPreparerShowsPreparingDialog() =
+        testScope.runTest {
+            val resources = getTestableContext().getResources()
+            val loadingDialogTitle =
+                resources.getString(R.string.photopicker_preloading_dialog_title)
+
+            initialMediaPreparer(CompletableDeferred())
+
+            selection.get().addAll(DATA)
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+
+            mediaToPrepare.emit(selection.get().snapshot())
+            composeTestRule.waitForIdle()
+            advanceTimeBy(100)
+
+            composeTestRule.waitUntilExactlyOneExists(hasText(loadingDialogTitle))
+            composeTestRule.onNode(hasText(loadingDialogTitle)).assertIsDisplayed()
+            composeTestRule
+                .onNode(hasText(resources.getString(android.R.string.cancel)))
+                .assert(hasClickAction())
+                .assertIsDisplayed()
+        }
+
+    @Test
+    fun testMediaPreparerCancelPrepareFromPreparingDialog() =
+        testScope.runTest {
+            val resources = getTestableContext().getResources()
+            val loadingDialogTitle =
+                resources.getString(R.string.photopicker_preloading_dialog_title)
+
+            initialMediaPreparer(CompletableDeferred())
+
+            selection.get().addAll(DATA)
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+
+            mediaToPrepare.emit(selection.get().snapshot())
+            composeTestRule.waitForIdle()
+            advanceTimeBy(100)
+
+            composeTestRule.waitUntilExactlyOneExists(hasText(loadingDialogTitle))
+            composeTestRule.onNode(hasText(loadingDialogTitle)).assertIsDisplayed()
+            composeTestRule
+                .onNode(hasText(resources.getString(android.R.string.cancel)))
+                .assert(hasClickAction())
+                .assertIsDisplayed()
+                .performClick()
+
+            advanceTimeBy(100)
+            composeTestRule.waitForIdle()
+
+            composeTestRule.onNode(hasText(loadingDialogTitle)).assertIsNotDisplayed()
+        }
+
+    @Test
+    fun testMediaPreparerLoadsRemoteMedia() =
+        testScope.runTest {
+            initialMediaPreparer(CompletableDeferred())
+
+            selection.get().addAll(DATA)
+            advanceTimeBy(100)
+
+            mediaToPrepare.emit(selection.get().snapshot())
+            advanceTimeBy(100)
+
+            advanceTimeBy(100)
+
+            // Should receive a total of 5 calls. (20 Media items and 50% are MediaSource.REMOTE)
+            verify(mockContentProvider, times(10)).openTypedAssetFile(any(), any(), any())
+        }
+
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.TIRAMISU)
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_PHOTOPICKER_TRANSCODING)
+    @Test
+    fun testMediaPreparerTranscodeMedia() =
+        testScope.runTest {
+            initialMediaPreparer(CompletableDeferred())
+
+            // Use mock Transcoder to bypass checks require extracting info from videos.
+            val viewModel = composeTestRule.activity.viewModels<MediaPreparerViewModel>().value
+            val mockTranscoder = mock(Transcoder::class.java)
+            whenever(
+                mockTranscoder.isTranscodeRequired(
+                    nonNullableAny(Context::class.java, mockContext),
+                    any(),
+                    nonNullableAny(Media.Video::class.java, VIDEO),
+                )
+            ) {
+                true
+            }
+            viewModel.transcoder = mockTranscoder
+            composeTestRule.waitForIdle()
+
+            selection.get().addAll(VIDEO_DATA)
+            advanceTimeBy(100)
+
+            mediaToPrepare.emit(selection.get().snapshot())
+            advanceTimeBy(100)
+
+            // Buffer time for the busy checking delay. (10 videos)
+            advanceTimeBy(1000)
+
+            // Should receive a total of 5 calls. (10 videos and 50% are MediaSource.REMOTE)
+            verify(mockContentProvider, times(5)).openTypedAssetFile(any(), any(), any())
+            // Should receive a total of 10 calls. (10 videos and all their durations are in limit)
+            verify(mockContentProvider, times(10)).call(any(), any(), any(), any())
+        }
+
+    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.TIRAMISU)
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_PHOTOPICKER_TRANSCODING)
+    @Test
+    fun testMediaPreparerTranscodeMedia_notTranscodeOverDurationLimitVideos() =
+        testScope.runTest {
+            initialMediaPreparer(CompletableDeferred())
+
+            // Use mock Transcoder to bypass checks require extracting info from videos.
+            val viewModel = composeTestRule.activity.viewModels<MediaPreparerViewModel>().value
+            val mockTranscoder = mock(Transcoder::class.java)
+            whenever(
+                mockTranscoder.isTranscodeRequired(
+                    nonNullableAny(Context::class.java, mockContext),
+                    any(),
+                    nonNullableAny(Media.Video::class.java, VIDEO),
+                )
+            ) {
+                val video = this.arguments[2] as Media.Video
+                video.duration <= DURATION_LIMIT_MS
+            }
+            viewModel.transcoder = mockTranscoder
+            composeTestRule.waitForIdle()
+
+            selection.get().addAll(LOCAL_VIDEO_DATA_WITH_HALF_OUT_OF_DURATION_LIMITATION)
+            advanceTimeBy(100)
+
+            mediaToPrepare.emit(selection.get().snapshot())
+            advanceTimeBy(100)
+
+            // Buffer time for the busy checking delay. (10 videos)
+            advanceTimeBy(1000)
+
+            // Should receive a total of 5 calls. (10 videos and 50% are out of duration limit)
+            verify(mockContentProvider, times(5)).call(any(), any(), any(), any())
+        }
+
+    @Test
+    fun testMediaPreparerFailureShowsErrorDialog() =
+        testScope.runTest {
+            val resources = getTestableContext().getResources()
+            val errorDialogTitle =
+                resources.getString(R.string.photopicker_preloading_dialog_error_title)
+            val errorDialogMessage =
+                resources.getString(R.string.photopicker_preloading_dialog_error_message)
+
+            whenever(mockContentProvider.openTypedAssetFile(any(), any(), any()))
+                .thenThrow(FileNotFoundException())
+
+            initialMediaPreparer(CompletableDeferred())
+
+            selection.get().addAll(DATA)
+            advanceTimeBy(100)
+
+            mediaToPrepare.emit(selection.get().snapshot())
+            advanceTimeBy(500)
+            composeTestRule.waitForIdle()
+
+            composeTestRule.waitUntilExactlyOneExists(hasText(errorDialogTitle))
+            composeTestRule.onNode(hasText(errorDialogTitle)).assertIsDisplayed()
+            composeTestRule.onNode(hasText(errorDialogMessage)).assertIsDisplayed()
+        }
+
+    private fun initialMediaPreparer(prepareDeferred: CompletableDeferred<PrepareMediaResult>) {
+        composeTestRule.setContent {
+            CompositionLocalProvider(
+                LocalPhotopickerConfiguration provides
+                    configurationManager.get().configuration.value,
+                LocalEvents provides events.get(),
+            ) {
+                val params =
+                    object : LocationParams.WithMediaPreparer {
+                        override fun obtainDeferred(): CompletableDeferred<PrepareMediaResult> {
+                            return prepareDeferred
+                        }
+
+                        override val prepareMedia = mediaToPrepare
+                    }
+                featureManager
+                    .get()
+                    .composeLocation(
+                        location = Location.MEDIA_PREPARER,
+                        modifier = Modifier,
+                        params = params,
+                    )
+            }
+        }
+        composeTestRule.waitForIdle()
+    }
+}
diff --git a/photopicker/tests/src/com/android/photopicker/features/mediaprepare/TranscoderTest.kt b/photopicker/tests/src/com/android/photopicker/features/mediaprepare/TranscoderTest.kt
new file mode 100644
index 000000000..f8265ea4c
--- /dev/null
+++ b/photopicker/tests/src/com/android/photopicker/features/mediaprepare/TranscoderTest.kt
@@ -0,0 +1,289 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.preparemedia
+
+import android.media.ApplicationMediaCapabilities
+import android.media.MediaFeature.HdrType
+import android.media.MediaFormat
+import android.net.Uri
+import android.os.Build
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import androidx.test.filters.SdkSuppress
+import androidx.test.filters.SmallTest
+import com.android.photopicker.data.PICKER_SEGMENT
+import com.android.photopicker.data.PICKER_TRANSCODED_SEGMENT
+import com.google.common.truth.Truth.assertWithMessage
+import org.junit.Test
+import org.junit.runner.RunWith
+
+/** Unit tests for the [Transcoder] */
+@SmallTest
+@SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
+@RunWith(AndroidJUnit4::class)
+class TranscoderTest {
+
+    private val testTranscoder = TranscoderImpl()
+
+    @Test
+    fun testToPickerTranscodedUri() {
+        val testUri =
+            Uri.EMPTY.buildUpon()
+                .apply {
+                    scheme("content")
+                    authority("media")
+                    appendPath(PICKER_SEGMENT)
+                    appendPath("user_id")
+                    appendPath("a")
+                    appendPath("media")
+                    appendPath("video_id")
+                }
+                .build()
+        val expectedUri =
+            Uri.EMPTY.buildUpon()
+                .apply {
+                    scheme("content")
+                    authority("media")
+                    appendPath(PICKER_TRANSCODED_SEGMENT)
+                    appendPath("user_id")
+                    appendPath("a")
+                    appendPath("media")
+                    appendPath("video_id")
+                }
+                .build()
+
+        assertWithMessage("Expected media URI to be converted to picker transcoded URI")
+            .that(Transcoder.toTranscodedUri(testUri))
+            .isEqualTo(expectedUri)
+    }
+
+    @Test
+    fun testIsTranscodeRequired_returnFalse_whenDurationOverLimit() {
+        val testMediaCapabilities = ApplicationMediaCapabilities.Builder().build()
+        val testMediaFormat = MediaFormat().apply { setLong(MediaFormat.KEY_DURATION, 90_000_000L) }
+
+        assertWithMessage("Duration is over transcode limit")
+            .that(testTranscoder.isTranscodeRequired(testMediaFormat, testMediaCapabilities))
+            .isFalse()
+    }
+
+    @Test
+    fun testIsTranscodeRequired_returnFalse_whenMediaFormatIsAudio() {
+        val testMediaCapabilities = ApplicationMediaCapabilities.Builder().build()
+        val testMediaFormat =
+            MediaFormat().apply { setString(MediaFormat.KEY_MIME, MediaFormat.MIMETYPE_AUDIO_AAC) }
+
+        assertWithMessage("Audio do not need to be transcoded")
+            .that(testTranscoder.isTranscodeRequired(testMediaFormat, testMediaCapabilities))
+            .isFalse()
+    }
+
+    @Test
+    fun testIsTranscodeRequired_returnFalse_whenHevcAndAppNotSpecifySupport() {
+        val testMediaCapabilities =
+            ApplicationMediaCapabilities.Builder()
+                .addUnsupportedVideoMimeType(MediaFormat.MIMETYPE_VIDEO_HEVC)
+                .build()
+        val testMediaFormat =
+            MediaFormat().apply {
+                setLong(MediaFormat.KEY_DURATION, 10_000_000L)
+                setString(MediaFormat.KEY_MIME, MediaFormat.MIMETYPE_VIDEO_HEVC)
+            }
+
+        assertWithMessage("Not to transcode when App does not specify HEVC as supported")
+            .that(testTranscoder.isTranscodeRequired(testMediaFormat, testMediaCapabilities))
+            .isFalse()
+    }
+
+    @Test
+    fun testIsTranscodeRequired_returnFalse_whenHevcAndAppSpecifySupport() {
+        val testMediaCapabilities =
+            ApplicationMediaCapabilities.Builder()
+                .addSupportedVideoMimeType(MediaFormat.MIMETYPE_VIDEO_HEVC)
+                .build()
+        val testMediaFormat =
+            MediaFormat().apply {
+                setLong(MediaFormat.KEY_DURATION, 10_000_000L)
+                setString(MediaFormat.KEY_MIME, MediaFormat.MIMETYPE_VIDEO_HEVC)
+            }
+
+        assertWithMessage("Do not need to transcode when App support HEVC")
+            .that(testTranscoder.isTranscodeRequired(testMediaFormat, testMediaCapabilities))
+            .isFalse()
+    }
+
+    @Test
+    fun testIsTranscodeRequired_returnTrue_whenDolbyVisionAndAppCanNotHandle() {
+        val testMediaCapabilities =
+            ApplicationMediaCapabilities.Builder()
+                .addSupportedVideoMimeType(MediaFormat.MIMETYPE_VIDEO_HEVC)
+                .addUnsupportedHdrType(HdrType.DOLBY_VISION)
+                .build()
+        val testMediaFormat =
+            MediaFormat().apply {
+                setLong(MediaFormat.KEY_DURATION, 10_000_000L)
+                setString(MediaFormat.KEY_MIME, MediaFormat.MIMETYPE_VIDEO_DOLBY_VISION)
+                setInteger(MediaFormat.KEY_COLOR_STANDARD, MediaFormat.COLOR_STANDARD_BT2020)
+                setInteger(MediaFormat.KEY_COLOR_TRANSFER, MediaFormat.COLOR_TRANSFER_ST2084)
+            }
+
+        assertWithMessage("Need to transcode when App cannot handle Dolby Vision")
+            .that(testTranscoder.isTranscodeRequired(testMediaFormat, testMediaCapabilities))
+            .isTrue()
+    }
+
+    @Test
+    fun testIsTranscodeRequired_returnFalse_whenDolbyVisionAndAppCanHandle() {
+        val testMediaCapabilities =
+            ApplicationMediaCapabilities.Builder()
+                .addSupportedVideoMimeType(MediaFormat.MIMETYPE_VIDEO_HEVC)
+                .addSupportedHdrType(HdrType.DOLBY_VISION)
+                .build()
+        val testMediaFormat =
+            MediaFormat().apply {
+                setLong(MediaFormat.KEY_DURATION, 10_000_000L)
+                setString(MediaFormat.KEY_MIME, MediaFormat.MIMETYPE_VIDEO_DOLBY_VISION)
+                setInteger(MediaFormat.KEY_COLOR_STANDARD, MediaFormat.COLOR_STANDARD_BT2020)
+                setInteger(MediaFormat.KEY_COLOR_TRANSFER, MediaFormat.COLOR_TRANSFER_ST2084)
+            }
+
+        assertWithMessage("Do not need to transcode when App can handle Dolby Vision")
+            .that(testTranscoder.isTranscodeRequired(testMediaFormat, testMediaCapabilities))
+            .isFalse()
+    }
+
+    @Test
+    fun testIsTranscodeRequired_returnTrue_wheHlgAndAppCanNotHandle() {
+        val testMediaCapabilities =
+            ApplicationMediaCapabilities.Builder()
+                .addSupportedVideoMimeType(MediaFormat.MIMETYPE_VIDEO_HEVC)
+                .addUnsupportedHdrType(HdrType.HLG)
+                .build()
+        val testMediaFormat =
+            MediaFormat().apply {
+                setLong(MediaFormat.KEY_DURATION, 10_000_000L)
+                setString(MediaFormat.KEY_MIME, MediaFormat.MIMETYPE_VIDEO_HEVC)
+                setInteger(MediaFormat.KEY_COLOR_STANDARD, MediaFormat.COLOR_STANDARD_BT709)
+                setInteger(MediaFormat.KEY_COLOR_TRANSFER, MediaFormat.COLOR_TRANSFER_HLG)
+            }
+
+        assertWithMessage("Need to transcode when App cannot handle HLG")
+            .that(testTranscoder.isTranscodeRequired(testMediaFormat, testMediaCapabilities))
+            .isTrue()
+    }
+
+    @Test
+    fun testIsTranscodeRequired_returnFalse_whenHlgAndAppCanHandle() {
+        val testMediaCapabilities =
+            ApplicationMediaCapabilities.Builder()
+                .addSupportedVideoMimeType(MediaFormat.MIMETYPE_VIDEO_HEVC)
+                .addSupportedHdrType(HdrType.HLG)
+                .build()
+        val testMediaFormat =
+            MediaFormat().apply {
+                setLong(MediaFormat.KEY_DURATION, 10_000_000L)
+                setString(MediaFormat.KEY_MIME, MediaFormat.MIMETYPE_VIDEO_HEVC)
+                setInteger(MediaFormat.KEY_COLOR_STANDARD, MediaFormat.COLOR_STANDARD_BT709)
+                setInteger(MediaFormat.KEY_COLOR_TRANSFER, MediaFormat.COLOR_TRANSFER_HLG)
+            }
+
+        assertWithMessage("Do not need to transcode when App can handle HLG")
+            .that(testTranscoder.isTranscodeRequired(testMediaFormat, testMediaCapabilities))
+            .isFalse()
+    }
+
+    @Test
+    fun testIsTranscodeRequired_returnTrue_wheHdr10AndAppCanNotHandle() {
+        val testMediaCapabilities =
+            ApplicationMediaCapabilities.Builder()
+                .addSupportedVideoMimeType(MediaFormat.MIMETYPE_VIDEO_HEVC)
+                .addUnsupportedHdrType(HdrType.HDR10)
+                .build()
+        val testMediaFormat =
+            MediaFormat().apply {
+                setLong(MediaFormat.KEY_DURATION, 10_000_000L)
+                setString(MediaFormat.KEY_MIME, MediaFormat.MIMETYPE_VIDEO_HEVC)
+                setInteger(MediaFormat.KEY_COLOR_STANDARD, MediaFormat.COLOR_STANDARD_BT2020)
+                setInteger(MediaFormat.KEY_COLOR_TRANSFER, MediaFormat.COLOR_TRANSFER_ST2084)
+            }
+
+        assertWithMessage("Need to transcode when App cannot handle HDR10")
+            .that(testTranscoder.isTranscodeRequired(testMediaFormat, testMediaCapabilities))
+            .isTrue()
+    }
+
+    @Test
+    fun testIsTranscodeRequired_returnFalse_whenHdr10AndAppCanHandle() {
+        val testMediaCapabilities =
+            ApplicationMediaCapabilities.Builder()
+                .addSupportedVideoMimeType(MediaFormat.MIMETYPE_VIDEO_HEVC)
+                .addSupportedHdrType(HdrType.HDR10)
+                .addSupportedHdrType(HdrType.HDR10_PLUS)
+                .build()
+        val testMediaFormat =
+            MediaFormat().apply {
+                setLong(MediaFormat.KEY_DURATION, 10_000_000L)
+                setString(MediaFormat.KEY_MIME, MediaFormat.MIMETYPE_VIDEO_HEVC)
+                setInteger(MediaFormat.KEY_COLOR_STANDARD, MediaFormat.COLOR_STANDARD_BT2020)
+                setInteger(MediaFormat.KEY_COLOR_TRANSFER, MediaFormat.COLOR_TRANSFER_ST2084)
+            }
+
+        assertWithMessage("Do not need to transcode when App can handle HDR10")
+            .that(testTranscoder.isTranscodeRequired(testMediaFormat, testMediaCapabilities))
+            .isFalse()
+    }
+
+    @Test
+    fun testIsTranscodeRequired_returnTrue_wheHdr10PlusAndAppCanNotHandle() {
+        val testMediaCapabilities =
+            ApplicationMediaCapabilities.Builder()
+                .addSupportedVideoMimeType(MediaFormat.MIMETYPE_VIDEO_HEVC)
+                .addUnsupportedHdrType(HdrType.HDR10_PLUS)
+                .build()
+        val testMediaFormat =
+            MediaFormat().apply {
+                setLong(MediaFormat.KEY_DURATION, 10_000_000L)
+                setString(MediaFormat.KEY_MIME, MediaFormat.MIMETYPE_VIDEO_HEVC)
+                setInteger(MediaFormat.KEY_COLOR_STANDARD, MediaFormat.COLOR_STANDARD_BT2020)
+                setInteger(MediaFormat.KEY_COLOR_TRANSFER, MediaFormat.COLOR_TRANSFER_ST2084)
+            }
+
+        assertWithMessage("Need to transcode when App cannot handle HDR10+")
+            .that(testTranscoder.isTranscodeRequired(testMediaFormat, testMediaCapabilities))
+            .isTrue()
+    }
+
+    @Test
+    fun testIsTranscodeRequired_returnFalse_whenHdr10PlusAndAppCanHandle() {
+        val testMediaCapabilities =
+            ApplicationMediaCapabilities.Builder()
+                .addSupportedVideoMimeType(MediaFormat.MIMETYPE_VIDEO_HEVC)
+                .addSupportedHdrType(HdrType.HDR10)
+                .addSupportedHdrType(HdrType.HDR10_PLUS)
+                .build()
+        val testMediaFormat =
+            MediaFormat().apply {
+                setLong(MediaFormat.KEY_DURATION, 10_000_000L)
+                setString(MediaFormat.KEY_MIME, MediaFormat.MIMETYPE_VIDEO_HEVC)
+                setInteger(MediaFormat.KEY_COLOR_STANDARD, MediaFormat.COLOR_STANDARD_BT2020)
+                setInteger(MediaFormat.KEY_COLOR_TRANSFER, MediaFormat.COLOR_TRANSFER_ST2084)
+            }
+
+        assertWithMessage("Do not need to transcode when App can handle HDR10+")
+            .that(testTranscoder.isTranscodeRequired(testMediaFormat, testMediaCapabilities))
+            .isFalse()
+    }
+}
diff --git a/photopicker/tests/src/com/android/photopicker/features/navigationbar/NavigationBarFeatureTest.kt b/photopicker/tests/src/com/android/photopicker/features/navigationbar/NavigationBarFeatureTest.kt
index 3f61ff37e..759f16d98 100644
--- a/photopicker/tests/src/com/android/photopicker/features/navigationbar/NavigationBarFeatureTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/navigationbar/NavigationBarFeatureTest.kt
@@ -51,12 +51,13 @@ import com.android.photopicker.core.events.Events
 import com.android.photopicker.core.features.FeatureManager
 import com.android.photopicker.core.glide.GlideTestRule
 import com.android.photopicker.core.selection.Selection
+import com.android.photopicker.data.TestPrefetchDataService
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.features.PhotopickerFeatureBaseTest
 import com.android.photopicker.inject.PhotopickerTestModule
-import com.android.photopicker.test.utils.MockContentProviderWrapper
 import com.android.photopicker.tests.HiltTestActivity
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.MockContentProviderWrapper
+import com.android.photopicker.util.test.whenever
 import com.android.providers.media.flags.Flags
 import com.google.common.truth.Truth.assertWithMessage
 import dagger.Lazy
@@ -215,6 +216,7 @@ class NavigationBarFeatureTest : PhotopickerFeatureBaseTest() {
             FeatureManager(
                 registeredFeatures = FeatureManager.KNOWN_FEATURE_REGISTRATIONS,
                 scope = testBackgroundScope,
+                prefetchDataService = TestPrefetchDataService(),
                 configuration = provideTestConfigurationFlow(scope = testBackgroundScope),
             )
 
diff --git a/photopicker/tests/src/com/android/photopicker/features/overflowmenu/OverflowMenuFeatureTest.kt b/photopicker/tests/src/com/android/photopicker/features/overflowmenu/OverflowMenuFeatureTest.kt
index 84045340f..222cb7521 100644
--- a/photopicker/tests/src/com/android/photopicker/features/overflowmenu/OverflowMenuFeatureTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/overflowmenu/OverflowMenuFeatureTest.kt
@@ -53,6 +53,7 @@ import com.android.photopicker.core.features.FeatureToken.OVERFLOW_MENU
 import com.android.photopicker.core.features.LocalFeatureManager
 import com.android.photopicker.core.features.Location
 import com.android.photopicker.core.glide.GlideTestRule
+import com.android.photopicker.data.TestPrefetchDataService
 import com.android.photopicker.features.PhotopickerFeatureBaseTest
 import com.android.photopicker.features.simpleuifeature.SimpleUiFeature
 import com.android.photopicker.inject.PhotopickerTestModule
@@ -172,6 +173,7 @@ class OverflowMenuFeatureTest : PhotopickerFeatureBaseTest() {
                 FeatureManager(
                     provideTestConfigurationFlow(scope = this.backgroundScope),
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     setOf(SimpleUiFeature.Registration, OverflowMenuFeature.Registration),
                     /*coreEventsConsumed=*/ setOf<RegisteredEventClass>(),
                     /*coreEventsProduced=*/ setOf<RegisteredEventClass>(),
@@ -216,6 +218,7 @@ class OverflowMenuFeatureTest : PhotopickerFeatureBaseTest() {
                 FeatureManager(
                     provideTestConfigurationFlow(scope = this.backgroundScope),
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     setOf(OverflowMenuFeature.Registration),
                     /*coreEventsConsumed=*/ setOf<RegisteredEventClass>(),
                     /*coreEventsProduced=*/ setOf<RegisteredEventClass>(),
@@ -254,6 +257,7 @@ class OverflowMenuFeatureTest : PhotopickerFeatureBaseTest() {
                 FeatureManager(
                     provideTestConfigurationFlow(scope = this.backgroundScope),
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     setOf(SimpleUiFeature.Registration, OverflowMenuFeature.Registration),
                     /*coreEventsConsumed=*/ setOf<RegisteredEventClass>(),
                     /*coreEventsProduced=*/ setOf<RegisteredEventClass>(),
diff --git a/photopicker/tests/src/com/android/photopicker/features/photogrid/PhotoGridFeatureTest.kt b/photopicker/tests/src/com/android/photopicker/features/photogrid/PhotoGridFeatureTest.kt
index af9d78dc2..673d5f5d3 100644
--- a/photopicker/tests/src/com/android/photopicker/features/photogrid/PhotoGridFeatureTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/photogrid/PhotoGridFeatureTest.kt
@@ -28,9 +28,9 @@ import androidx.compose.ui.test.ExperimentalTestApi
 import androidx.compose.ui.test.assert
 import androidx.compose.ui.test.assertIsDisplayed
 import androidx.compose.ui.test.hasClickAction
+import androidx.compose.ui.test.hasContentDescription
 import androidx.compose.ui.test.hasText
 import androidx.compose.ui.test.junit4.createAndroidComposeRule
-import androidx.compose.ui.test.onAllNodesWithContentDescription
 import androidx.compose.ui.test.onFirst
 import androidx.compose.ui.test.performClick
 import androidx.compose.ui.test.performTouchInput
@@ -58,12 +58,13 @@ import com.android.photopicker.core.navigation.PhotopickerDestinations
 import com.android.photopicker.core.selection.Selection
 import com.android.photopicker.data.DataService
 import com.android.photopicker.data.TestDataServiceImpl
+import com.android.photopicker.data.TestPrefetchDataService
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.features.PhotopickerFeatureBaseTest
 import com.android.photopicker.inject.PhotopickerTestModule
-import com.android.photopicker.test.utils.MockContentProviderWrapper
 import com.android.photopicker.tests.HiltTestActivity
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.MockContentProviderWrapper
+import com.android.photopicker.util.test.whenever
 import com.google.common.truth.Truth.assertWithMessage
 import dagger.Lazy
 import dagger.Module
@@ -146,6 +147,8 @@ class PhotoGridFeatureTest : PhotopickerFeatureBaseTest() {
     @Inject lateinit var dataService: DataService
     @Inject lateinit var databaseManager: DatabaseManager
 
+    private val MEDIA_ITEM_CONTENT_DESCRIPTION_SUBSTRING = "taken on"
+
     val sessionId = generatePickerSessionId()
 
     @Before
@@ -198,7 +201,8 @@ class PhotoGridFeatureTest : PhotopickerFeatureBaseTest() {
             FeatureManager(
                 registeredFeatures = FeatureManager.KNOWN_FEATURE_REGISTRATIONS,
                 scope = testBackgroundScope,
-                configuration = provideTestConfigurationFlow(scope = testBackgroundScope)
+                prefetchDataService = TestPrefetchDataService(),
+                configuration = provideTestConfigurationFlow(scope = testBackgroundScope),
             )
 
         testScope.runTest {
@@ -221,9 +225,6 @@ class PhotoGridFeatureTest : PhotopickerFeatureBaseTest() {
 
     @Test
     fun testPhotosCanBeSelected() {
-        val resources = getTestableContext().getResources()
-        val mediaItemString = resources.getString(R.string.photopicker_media_item)
-
         testScope.runTest {
             composeTestRule.setContent {
                 callPhotopickerMain(
@@ -242,7 +243,12 @@ class PhotoGridFeatureTest : PhotopickerFeatureBaseTest() {
             composeTestRule.waitForIdle()
 
             composeTestRule
-                .onAllNodesWithContentDescription(mediaItemString)
+                .onAllNodes(
+                    hasContentDescription(
+                        value = MEDIA_ITEM_CONTENT_DESCRIPTION_SUBSTRING,
+                        substring = true,
+                    )
+                )
                 .onFirst()
                 .performClick()
 
@@ -258,9 +264,6 @@ class PhotoGridFeatureTest : PhotopickerFeatureBaseTest() {
 
     @Test
     fun testPhotosAreDisplayed() {
-        val resources = getTestableContext().getResources()
-        val mediaItemString = resources.getString(R.string.photopicker_media_item)
-
         testScope.runTest {
             composeTestRule.setContent {
                 callPhotopickerMain(
@@ -275,7 +278,12 @@ class PhotoGridFeatureTest : PhotopickerFeatureBaseTest() {
             composeTestRule.waitForIdle()
 
             composeTestRule
-                .onAllNodesWithContentDescription(mediaItemString)
+                .onAllNodes(
+                    hasContentDescription(
+                        value = MEDIA_ITEM_CONTENT_DESCRIPTION_SUBSTRING,
+                        substring = true,
+                    )
+                )
                 .onFirst()
                 .assert(hasClickAction())
                 .assertIsDisplayed()
@@ -284,9 +292,6 @@ class PhotoGridFeatureTest : PhotopickerFeatureBaseTest() {
 
     @Test
     fun testSwipeLeftToNavigateToAlbumGrid() {
-        val resources = getTestableContext().getResources()
-        val mediaItemString = resources.getString(R.string.photopicker_media_item)
-
         testScope.runTest {
             composeTestRule.setContent {
                 callPhotopickerMain(
@@ -301,7 +306,12 @@ class PhotoGridFeatureTest : PhotopickerFeatureBaseTest() {
             composeTestRule.waitForIdle()
 
             composeTestRule
-                .onAllNodesWithContentDescription(mediaItemString)
+                .onAllNodes(
+                    hasContentDescription(
+                        value = MEDIA_ITEM_CONTENT_DESCRIPTION_SUBSTRING,
+                        substring = true,
+                    )
+                )
                 .onFirst()
                 .performTouchInput { swipeLeft() }
             composeTestRule.waitForIdle()
diff --git a/photopicker/tests/src/com/android/photopicker/features/photogrid/PhotoGridViewModelTest.kt b/photopicker/tests/src/com/android/photopicker/features/photogrid/PhotoGridViewModelTest.kt
index ccab5132e..bc9a2bd59 100644
--- a/photopicker/tests/src/com/android/photopicker/features/photogrid/PhotoGridViewModelTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/photogrid/PhotoGridViewModelTest.kt
@@ -51,10 +51,11 @@ import com.android.photopicker.core.features.FeatureToken.PHOTO_GRID
 import com.android.photopicker.core.selection.SelectionImpl
 import com.android.photopicker.core.user.UserMonitor
 import com.android.photopicker.data.TestDataServiceImpl
+import com.android.photopicker.data.TestPrefetchDataService
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.data.model.MediaSource
-import com.android.photopicker.tests.utils.mockito.mockSystemService
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.mockSystemService
+import com.android.photopicker.util.test.whenever
 import com.google.common.truth.Truth.assertWithMessage
 import kotlinx.coroutines.ExperimentalCoroutinesApi
 import kotlinx.coroutines.flow.toList
@@ -180,6 +181,7 @@ class PhotoGridViewModelTest {
                 FeatureManager(
                     configuration = provideTestConfigurationFlow(scope = this.backgroundScope),
                     scope = this.backgroundScope,
+                    prefetchDataService = TestPrefetchDataService(),
                 )
 
             val events =
@@ -285,6 +287,7 @@ class PhotoGridViewModelTest {
                 FeatureManager(
                     configuration = provideTestConfigurationFlow(scope = this.backgroundScope),
                     scope = this.backgroundScope,
+                    prefetchDataService = TestPrefetchDataService(),
                     coreEventsConsumed = setOf<RegisteredEventClass>(),
                     coreEventsProduced = setOf<RegisteredEventClass>(),
                 )
@@ -376,6 +379,7 @@ class PhotoGridViewModelTest {
                 FeatureManager(
                     configuration = provideTestConfigurationFlow(scope = this.backgroundScope),
                     scope = this.backgroundScope,
+                    prefetchDataService = TestPrefetchDataService(),
                 )
 
             val events =
diff --git a/photopicker/tests/src/com/android/photopicker/features/preview/PreviewFeatureTest.kt b/photopicker/tests/src/com/android/photopicker/features/preview/PreviewFeatureTest.kt
index c3b96371b..c19b7aadb 100644
--- a/photopicker/tests/src/com/android/photopicker/features/preview/PreviewFeatureTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/preview/PreviewFeatureTest.kt
@@ -87,11 +87,11 @@ import com.android.photopicker.extensions.navigateToPreviewMedia
 import com.android.photopicker.extensions.navigateToPreviewSelection
 import com.android.photopicker.features.PhotopickerFeatureBaseTest
 import com.android.photopicker.inject.PhotopickerTestModule
-import com.android.photopicker.test.utils.MockContentProviderWrapper
 import com.android.photopicker.tests.HiltTestActivity
-import com.android.photopicker.tests.utils.mockito.capture
-import com.android.photopicker.tests.utils.mockito.nonNullableEq
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.MockContentProviderWrapper
+import com.android.photopicker.util.test.capture
+import com.android.photopicker.util.test.nonNullableEq
+import com.android.photopicker.util.test.whenever
 import com.google.common.truth.Truth.assertWithMessage
 import dagger.Lazy
 import dagger.Module
diff --git a/photopicker/tests/src/com/android/photopicker/features/preview/PreviewViewModelTest.kt b/photopicker/tests/src/com/android/photopicker/features/preview/PreviewViewModelTest.kt
index a89e765e5..6377bec0e 100644
--- a/photopicker/tests/src/com/android/photopicker/features/preview/PreviewViewModelTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/preview/PreviewViewModelTest.kt
@@ -68,13 +68,14 @@ import com.android.photopicker.core.selection.GrantsAwareSelectionImpl
 import com.android.photopicker.core.selection.SelectionImpl
 import com.android.photopicker.core.user.UserMonitor
 import com.android.photopicker.data.TestDataServiceImpl
+import com.android.photopicker.data.TestPrefetchDataService
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.data.model.MediaSource
-import com.android.photopicker.test.utils.MockContentProviderWrapper
-import com.android.photopicker.tests.utils.mockito.capture
-import com.android.photopicker.tests.utils.mockito.mockSystemService
-import com.android.photopicker.tests.utils.mockito.nonNullableEq
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.MockContentProviderWrapper
+import com.android.photopicker.util.test.capture
+import com.android.photopicker.util.test.mockSystemService
+import com.android.photopicker.util.test.nonNullableEq
+import com.android.photopicker.util.test.whenever
 import com.google.common.truth.Truth.assertWithMessage
 import java.time.LocalDateTime
 import java.time.ZoneOffset
@@ -282,6 +283,7 @@ class PreviewViewModelTest {
                 FeatureManager(
                     configurationManager.configuration,
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     emptySet<FeatureRegistration>(),
                 )
             val events =
@@ -354,6 +356,7 @@ class PreviewViewModelTest {
                 FeatureManager(
                     configurationManager.configuration,
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     emptySet<FeatureRegistration>(),
                 )
             val events =
@@ -442,6 +445,7 @@ class PreviewViewModelTest {
                 FeatureManager(
                     configurationManager.configuration,
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     emptySet<FeatureRegistration>(),
                 )
             val events =
@@ -509,6 +513,7 @@ class PreviewViewModelTest {
                 FeatureManager(
                     configurationManager.configuration,
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     emptySet<FeatureRegistration>(),
                 )
             val events =
@@ -578,6 +583,7 @@ class PreviewViewModelTest {
                 FeatureManager(
                     configurationManager.configuration,
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     emptySet<FeatureRegistration>(),
                 )
             val events =
@@ -656,6 +662,7 @@ class PreviewViewModelTest {
                 FeatureManager(
                     configurationManager.configuration,
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     emptySet<FeatureRegistration>(),
                 )
             val events =
@@ -778,6 +785,7 @@ class PreviewViewModelTest {
                 FeatureManager(
                     configurationManager.configuration,
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     emptySet<FeatureRegistration>(),
                 )
             val events =
@@ -833,6 +841,7 @@ class PreviewViewModelTest {
                 FeatureManager(
                     configurationManager.configuration,
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     registeredFeatures = setOf(PreviewFeature.Registration),
                 )
             val events =
diff --git a/photopicker/tests/src/com/android/photopicker/features/privacyexplainer/PrivacyExplainerFeatureTest.kt b/photopicker/tests/src/com/android/photopicker/features/privacyexplainer/PrivacyExplainerFeatureTest.kt
index 5db6d0a4e..56b1d6e7b 100644
--- a/photopicker/tests/src/com/android/photopicker/features/privacyexplainer/PrivacyExplainerFeatureTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/privacyexplainer/PrivacyExplainerFeatureTest.kt
@@ -49,10 +49,10 @@ import com.android.photopicker.core.selection.Selection
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.features.PhotopickerFeatureBaseTest
 import com.android.photopicker.inject.PhotopickerTestModule
-import com.android.photopicker.test.utils.MockContentProviderWrapper
 import com.android.photopicker.tests.HiltTestActivity
-import com.android.photopicker.tests.utils.mockito.nonNullableEq
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.MockContentProviderWrapper
+import com.android.photopicker.util.test.nonNullableEq
+import com.android.photopicker.util.test.whenever
 import dagger.Lazy
 import dagger.Module
 import dagger.hilt.InstallIn
@@ -196,13 +196,13 @@ class PrivacyExplainerFeatureTest : PhotopickerFeatureBaseTest() {
             whenever(
                 bannerStateDao.getBannerState(
                     nonNullableEq(BannerDefinitions.PRIVACY_EXPLAINER.id),
-                    anyInt()
+                    anyInt(),
                 )
             ) {
                 BannerState(
                     bannerId = BannerDefinitions.PRIVACY_EXPLAINER.id,
                     dismissed = true,
-                    uid = 12345
+                    uid = 12345,
                 )
             }
             // Mock out database state with previously dismissed state.
diff --git a/photopicker/tests/src/com/android/photopicker/features/profileselector/ProfileSelectorFeatureTest.kt b/photopicker/tests/src/com/android/photopicker/features/profileselector/ProfileSelectorFeatureTest.kt
index cd25354e6..f86926090 100644
--- a/photopicker/tests/src/com/android/photopicker/features/profileselector/ProfileSelectorFeatureTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/profileselector/ProfileSelectorFeatureTest.kt
@@ -56,8 +56,8 @@ import com.android.photopicker.data.model.Media
 import com.android.photopicker.features.PhotopickerFeatureBaseTest
 import com.android.photopicker.inject.PhotopickerTestModule
 import com.android.photopicker.tests.HiltTestActivity
-import com.android.photopicker.tests.utils.mockito.mockSystemService
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.mockSystemService
+import com.android.photopicker.util.test.whenever
 import com.google.common.truth.Truth.assertWithMessage
 import dagger.Lazy
 import dagger.Module
@@ -211,7 +211,7 @@ class ProfileSelectorFeatureTest : PhotopickerFeatureBaseTest() {
                     hasContentDescription(
                         getTestableContext()
                             .getResources()
-                            .getString(R.string.photopicker_profile_switch_button_description)
+                            .getString(R.string.photopicker_profile_primary_label)
                     )
                 )
                 .assertIsDisplayed()
@@ -232,7 +232,7 @@ class ProfileSelectorFeatureTest : PhotopickerFeatureBaseTest() {
                     hasContentDescription(
                         getTestableContext()
                             .getResources()
-                            .getString(R.string.photopicker_profile_switch_button_description)
+                            .getString(R.string.photopicker_profile_primary_label)
                     )
                 )
                 .assertIsNotDisplayed()
@@ -317,7 +317,7 @@ class ProfileSelectorFeatureTest : PhotopickerFeatureBaseTest() {
             composeTestRule
                 .onNode(
                     hasContentDescription(
-                        resources.getString(R.string.photopicker_profile_switch_button_description)
+                        resources.getString(R.string.photopicker_profile_primary_label)
                     )
                 )
                 .assertIsDisplayed()
@@ -395,7 +395,7 @@ class ProfileSelectorFeatureTest : PhotopickerFeatureBaseTest() {
             composeTestRule
                 .onNode(
                     hasContentDescription(
-                        resources.getString(R.string.photopicker_profile_switch_button_description)
+                        resources.getString(R.string.photopicker_profile_primary_label)
                     )
                 )
                 .assertIsDisplayed()
@@ -437,7 +437,7 @@ class ProfileSelectorFeatureTest : PhotopickerFeatureBaseTest() {
             composeTestRule
                 .onNode(
                     hasContentDescription(
-                        resources.getString(R.string.photopicker_profile_switch_button_description)
+                        resources.getString(R.string.photopicker_profile_primary_label)
                     )
                 )
                 .assertIsDisplayed()
diff --git a/photopicker/tests/src/com/android/photopicker/features/profileselector/ProfileSelectorViewModelTest.kt b/photopicker/tests/src/com/android/photopicker/features/profileselector/ProfileSelectorViewModelTest.kt
index d87c97945..a615b363c 100644
--- a/photopicker/tests/src/com/android/photopicker/features/profileselector/ProfileSelectorViewModelTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/profileselector/ProfileSelectorViewModelTest.kt
@@ -45,11 +45,12 @@ import com.android.photopicker.core.selection.SelectionImpl
 import com.android.photopicker.core.user.UserMonitor
 import com.android.photopicker.core.user.UserProfile
 import com.android.photopicker.data.TestDataServiceImpl
+import com.android.photopicker.data.TestPrefetchDataService
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.data.model.MediaSource
-import com.android.photopicker.test.utils.MockContentProviderWrapper
-import com.android.photopicker.tests.utils.mockito.mockSystemService
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.MockContentProviderWrapper
+import com.android.photopicker.util.test.mockSystemService
+import com.android.photopicker.util.test.whenever
 import com.google.common.truth.Truth.assertWithMessage
 import kotlinx.coroutines.ExperimentalCoroutinesApi
 import kotlinx.coroutines.test.StandardTestDispatcher
@@ -193,6 +194,7 @@ class ProfileSelectorViewModelTest {
                 FeatureManager(
                     configurationManager.configuration,
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     emptySet<FeatureRegistration>(),
                 )
             val events =
@@ -265,7 +267,11 @@ class ProfileSelectorViewModelTest {
                     generatePickerSessionId(),
                 )
             val featureManager =
-                FeatureManager(configurationManager.configuration, this.backgroundScope)
+                FeatureManager(
+                    configurationManager.configuration,
+                    this.backgroundScope,
+                    TestPrefetchDataService(),
+                )
             val events =
                 Events(
                     scope = this.backgroundScope,
diff --git a/photopicker/tests/src/com/android/photopicker/features/profileselector/SwitchProfileBannerTest.kt b/photopicker/tests/src/com/android/photopicker/features/profileselector/SwitchProfileBannerTest.kt
index 5a480ca3a..e69173012 100644
--- a/photopicker/tests/src/com/android/photopicker/features/profileselector/SwitchProfileBannerTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/profileselector/SwitchProfileBannerTest.kt
@@ -52,7 +52,7 @@ import com.android.photopicker.features.PhotopickerFeatureBaseTest
 import com.android.photopicker.inject.PhotopickerTestModule
 import com.android.photopicker.inject.TestOptions
 import com.android.photopicker.tests.HiltTestActivity
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.whenever
 import com.google.common.truth.Truth.assertWithMessage
 import dagger.Lazy
 import dagger.Module
diff --git a/photopicker/tests/src/com/android/photopicker/features/search/SearchDataServiceImplTest.kt b/photopicker/tests/src/com/android/photopicker/features/search/SearchDataServiceImplTest.kt
new file mode 100644
index 000000000..92da23322
--- /dev/null
+++ b/photopicker/tests/src/com/android/photopicker/features/search/SearchDataServiceImplTest.kt
@@ -0,0 +1,205 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.search
+
+import android.content.ContentResolver
+import android.content.Context
+import android.content.pm.PackageManager
+import android.os.CancellationSignal
+import android.os.Parcel
+import android.os.UserHandle
+import androidx.paging.PagingSource
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import androidx.test.filters.SmallTest
+import com.android.photopicker.core.configuration.provideTestConfigurationFlow
+import com.android.photopicker.core.events.Events
+import com.android.photopicker.core.events.RegisteredEventClass
+import com.android.photopicker.core.features.FeatureManager
+import com.android.photopicker.core.user.UserProfile
+import com.android.photopicker.core.user.UserStatus
+import com.android.photopicker.data.DataService
+import com.android.photopicker.data.DataServiceImpl
+import com.android.photopicker.data.MediaProviderClient
+import com.android.photopicker.data.TestMediaProvider
+import com.android.photopicker.data.TestNotificationServiceImpl
+import com.android.photopicker.data.TestPrefetchDataService
+import com.android.photopicker.data.model.Media
+import com.android.photopicker.data.model.MediaPageKey
+import com.android.photopicker.data.model.MediaSource
+import com.android.photopicker.data.model.Provider
+import com.android.photopicker.features.cloudmedia.CloudMediaFeature
+import com.android.photopicker.features.search.data.SearchDataService
+import com.android.photopicker.features.search.data.SearchDataServiceImpl
+import com.google.common.truth.Truth.assertThat
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.toList
+import kotlinx.coroutines.flow.update
+import kotlinx.coroutines.launch
+import kotlinx.coroutines.test.StandardTestDispatcher
+import kotlinx.coroutines.test.TestScope
+import kotlinx.coroutines.test.advanceTimeBy
+import kotlinx.coroutines.test.runTest
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.Mockito.mock
+
+@SmallTest
+@RunWith(AndroidJUnit4::class)
+@OptIn(ExperimentalCoroutinesApi::class)
+class SearchDataServiceImplTest {
+
+    companion object {
+        private fun createUserHandle(userId: Int = 0): UserHandle {
+            val parcel = Parcel.obtain()
+            parcel.writeInt(userId)
+            parcel.setDataPosition(0)
+            val userHandle = UserHandle(parcel)
+            parcel.recycle()
+            return userHandle
+        }
+
+        private val userProfilePrimary: UserProfile =
+            UserProfile(handle = createUserHandle(0), profileType = UserProfile.ProfileType.PRIMARY)
+    }
+
+    private lateinit var testFeatureManager: FeatureManager
+    private lateinit var testContentProvider: TestMediaProvider
+    private lateinit var testContentResolver: ContentResolver
+    private lateinit var notificationService: TestNotificationServiceImpl
+    private lateinit var mediaProviderClient: MediaProviderClient
+    private lateinit var userStatus: UserStatus
+    private lateinit var mockContext: Context
+    private lateinit var mockPackageManager: PackageManager
+    private lateinit var events: Events
+
+    @Before
+    fun setup() {
+        val scope = TestScope()
+        testContentProvider = TestMediaProvider()
+        testContentResolver = ContentResolver.wrap(testContentProvider)
+        notificationService = TestNotificationServiceImpl()
+        mediaProviderClient = MediaProviderClient()
+        mockContext = mock(Context::class.java)
+        mockPackageManager = mock(PackageManager::class.java)
+        userStatus =
+            UserStatus(
+                activeUserProfile = userProfilePrimary,
+                allProfiles = listOf(userProfilePrimary),
+                activeContentResolver = testContentResolver,
+            )
+        testFeatureManager =
+            FeatureManager(
+                provideTestConfigurationFlow(scope = scope.backgroundScope),
+                scope,
+                TestPrefetchDataService(),
+                setOf(CloudMediaFeature.Registration),
+                setOf<RegisteredEventClass>(),
+                setOf<RegisteredEventClass>(),
+            )
+    }
+
+    @Test
+    fun testSearchPagingSourceInvalidation() = runTest {
+        val userStatusFlow: MutableStateFlow<UserStatus> = MutableStateFlow(userStatus)
+        events =
+            Events(
+                scope = this.backgroundScope,
+                provideTestConfigurationFlow(this.backgroundScope),
+                testFeatureManager,
+            )
+
+        val dataService: DataService =
+            DataServiceImpl(
+                userStatus = userStatusFlow,
+                scope = this.backgroundScope,
+                notificationService = notificationService,
+                mediaProviderClient = mediaProviderClient,
+                dispatcher = StandardTestDispatcher(this.testScheduler),
+                config = provideTestConfigurationFlow(this.backgroundScope),
+                featureManager = testFeatureManager,
+                appContext = mockContext,
+                events = events,
+                processOwnerHandle = userProfilePrimary.handle,
+            )
+
+        val searchDataService: SearchDataService =
+            SearchDataServiceImpl(
+                dataService = dataService,
+                userStatus = userStatusFlow,
+                photopickerConfiguration = provideTestConfigurationFlow(this.backgroundScope),
+                scope = this.backgroundScope,
+                notificationService = notificationService,
+                mediaProviderClient = mediaProviderClient,
+                dispatcher = StandardTestDispatcher(this.testScheduler),
+                events = events,
+            )
+
+        val searchText: String = "search_query"
+        val cancellationSignal = CancellationSignal()
+
+        val emissions = mutableListOf<List<Provider>>()
+        this.backgroundScope.launch { dataService.availableProviders.toList(emissions) }
+        advanceTimeBy(100)
+
+        assertThat(emissions.count()).isEqualTo(1)
+
+        val firstSearchResultsPagingSource: PagingSource<MediaPageKey, Media> =
+            searchDataService.getSearchResults(searchText = searchText, cancellationSignal)
+        assertThat(firstSearchResultsPagingSource.invalid).isFalse()
+        assertThat(cancellationSignal.isCanceled()).isFalse()
+
+        // The active user changes
+        val updatedContentProvider = TestMediaProvider()
+        val updatedContentResolver: ContentResolver = ContentResolver.wrap(updatedContentProvider)
+        updatedContentProvider.providers =
+            mutableListOf(
+                Provider(
+                    authority = "local_authority",
+                    mediaSource = MediaSource.LOCAL,
+                    uid = 0,
+                    displayName = "",
+                ),
+                Provider(
+                    authority = "cloud_authority",
+                    mediaSource = MediaSource.REMOTE,
+                    uid = 0,
+                    displayName = "",
+                ),
+            )
+
+        userStatusFlow.update { it.copy(activeContentResolver = updatedContentResolver) }
+
+        advanceTimeBy(1000)
+
+        // Since the active user has changed, this should trigger a re-fetch of the active
+        // providers.
+        assertThat(emissions.count()).isEqualTo(2)
+
+        // Check that the old PagingSource has been invalidated.
+        assertThat(firstSearchResultsPagingSource.invalid).isTrue()
+
+        // Check that the CancellationSignal has been marked as cancelled.
+        assertThat(cancellationSignal.isCanceled()).isTrue()
+
+        // Check that the new PagingSource instance is valid.
+        val secondSearchResultsPagingSource: PagingSource<MediaPageKey, Media> =
+            searchDataService.getSearchResults(searchText)
+        assertThat(secondSearchResultsPagingSource.invalid).isFalse()
+    }
+}
diff --git a/photopicker/tests/src/com/android/photopicker/features/search/SearchFeatureTest.kt b/photopicker/tests/src/com/android/photopicker/features/search/SearchFeatureTest.kt
index 6dcce9632..a0aa0fdba 100644
--- a/photopicker/tests/src/com/android/photopicker/features/search/SearchFeatureTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/search/SearchFeatureTest.kt
@@ -55,9 +55,11 @@ import com.android.photopicker.core.configuration.PhotopickerRuntimeEnv
 import com.android.photopicker.core.configuration.TestPhotopickerConfiguration
 import com.android.photopicker.core.events.Events
 import com.android.photopicker.core.features.FeatureManager
+import com.android.photopicker.core.features.PrefetchResultKey
 import com.android.photopicker.core.selection.Selection
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.features.PhotopickerFeatureBaseTest
+import com.android.photopicker.features.search.model.SearchEnabledState
 import com.android.photopicker.inject.PhotopickerTestModule
 import com.android.photopicker.tests.HiltTestActivity
 import com.android.providers.media.flags.Flags
@@ -73,7 +75,10 @@ import dagger.hilt.components.SingletonComponent
 import javax.inject.Inject
 import kotlinx.coroutines.CoroutineDispatcher
 import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Deferred
 import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.async
+import kotlinx.coroutines.runBlocking
 import kotlinx.coroutines.test.StandardTestDispatcher
 import kotlinx.coroutines.test.TestScope
 import kotlinx.coroutines.test.runTest
@@ -129,6 +134,16 @@ class SearchFeatureTest : PhotopickerFeatureBaseTest() {
     @Mock lateinit var mockUserManager: UserManager
     @Mock lateinit var mockPackageManager: PackageManager
 
+    val deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>> =
+        mapOf(
+            PrefetchResultKey.SEARCH_STATE to
+                runBlocking {
+                    async {
+                        return@async SearchEnabledState.ENABLED
+                    }
+                }
+        )
+
     @Before
     fun setup() {
 
@@ -147,7 +162,12 @@ class SearchFeatureTest : PhotopickerFeatureBaseTest() {
                 intent(Intent(MediaStore.ACTION_PICK_IMAGES))
             }
         assertWithMessage("SearchBar is always enabled when search flag is disabled")
-            .that(SearchFeature.Registration.isEnabled(testActionPickImagesConfiguration))
+            .that(
+                SearchFeature.Registration.isEnabled(
+                    testActionPickImagesConfiguration,
+                    deferredPrefetchResultsMap,
+                )
+            )
             .isEqualTo(false)
 
         val testGetContentConfiguration: PhotopickerConfiguration =
@@ -156,7 +176,12 @@ class SearchFeatureTest : PhotopickerFeatureBaseTest() {
                 intent(Intent(Intent.ACTION_GET_CONTENT))
             }
         assertWithMessage("Search Feature is always enabled when search flag is disabled")
-            .that(SearchFeature.Registration.isEnabled(testGetContentConfiguration))
+            .that(
+                SearchFeature.Registration.isEnabled(
+                    testGetContentConfiguration,
+                    deferredPrefetchResultsMap,
+                )
+            )
             .isEqualTo(false)
 
         val testUserSelectImagesForAppConfiguration: PhotopickerConfiguration =
@@ -168,7 +193,12 @@ class SearchFeatureTest : PhotopickerFeatureBaseTest() {
                 callingPackageLabel("test_app")
             }
         assertWithMessage("Search Feature is always enabled when search flag is disabled")
-            .that(SearchFeature.Registration.isEnabled(testUserSelectImagesForAppConfiguration))
+            .that(
+                SearchFeature.Registration.isEnabled(
+                    testUserSelectImagesForAppConfiguration,
+                    deferredPrefetchResultsMap,
+                )
+            )
             .isEqualTo(false)
     }
 
@@ -182,7 +212,12 @@ class SearchFeatureTest : PhotopickerFeatureBaseTest() {
                 intent(Intent(MediaStore.ACTION_PICK_IMAGES))
             }
         assertWithMessage("Search Feature is not always enabled when search flag enabled")
-            .that(SearchFeature.Registration.isEnabled(testActionPickImagesConfiguration))
+            .that(
+                SearchFeature.Registration.isEnabled(
+                    testActionPickImagesConfiguration,
+                    deferredPrefetchResultsMap,
+                )
+            )
             .isEqualTo(true)
 
         val testGetContentConfiguration: PhotopickerConfiguration =
@@ -191,19 +226,12 @@ class SearchFeatureTest : PhotopickerFeatureBaseTest() {
                 intent(Intent(Intent.ACTION_GET_CONTENT))
             }
         assertWithMessage("Search Feature is not always enabled when search flag enabled")
-            .that(SearchFeature.Registration.isEnabled(testGetContentConfiguration))
-            .isEqualTo(true)
-
-        val testUserSelectImagesForAppConfiguration: PhotopickerConfiguration =
-            TestPhotopickerConfiguration.build {
-                action(MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP)
-                intent(Intent(MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP))
-                callingPackage("com.example.test")
-                callingPackageUid(1234)
-                callingPackageLabel("test_app")
-            }
-        assertWithMessage("Search Feature is not always enabled when search flag enabled")
-            .that(SearchFeature.Registration.isEnabled(testUserSelectImagesForAppConfiguration))
+            .that(
+                SearchFeature.Registration.isEnabled(
+                    testGetContentConfiguration,
+                    deferredPrefetchResultsMap,
+                )
+            )
             .isEqualTo(true)
     }
 
@@ -218,7 +246,12 @@ class SearchFeatureTest : PhotopickerFeatureBaseTest() {
                 intent(Intent(MediaStore.ACTION_PICK_IMAGES))
             }
         assertWithMessage("Search Feature is not always enabled when search flag enabled")
-            .that(SearchFeature.Registration.isEnabled(testActionPickImagesConfiguration))
+            .that(
+                SearchFeature.Registration.isEnabled(
+                    testActionPickImagesConfiguration,
+                    deferredPrefetchResultsMap,
+                )
+            )
             .isEqualTo(true)
 
         val testGetContentConfiguration: PhotopickerConfiguration =
@@ -228,9 +261,39 @@ class SearchFeatureTest : PhotopickerFeatureBaseTest() {
                 intent(Intent(Intent.ACTION_GET_CONTENT))
             }
         assertWithMessage("Search Feature is not always enabled when search flag enabled")
-            .that(SearchFeature.Registration.isEnabled(testGetContentConfiguration))
+            .that(
+                SearchFeature.Registration.isEnabled(
+                    testGetContentConfiguration,
+                    deferredPrefetchResultsMap,
+                )
+            )
             .isEqualTo(true)
+    }
 
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testSearchFeature_inPermissionMode_isDisabled() {
+        val testUserSelectImagesForAppConfiguration: PhotopickerConfiguration =
+            TestPhotopickerConfiguration.build {
+                action(MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP)
+                intent(Intent(MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP))
+                callingPackage("com.example.test")
+                callingPackageUid(1234)
+                callingPackageLabel("test_app")
+            }
+        assertWithMessage("Search Feature is always enabled in Permission mode")
+            .that(
+                SearchFeature.Registration.isEnabled(
+                    testUserSelectImagesForAppConfiguration,
+                    deferredPrefetchResultsMap,
+                )
+            )
+            .isEqualTo(false)
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH, Flags.FLAG_ENABLE_EMBEDDED_PHOTOPICKER)
+    fun testSearchFeature_whenEmbeddedPickerEnabledInPermissionMode_isDisabled() {
         val testUserSelectImagesForAppConfiguration: PhotopickerConfiguration =
             TestPhotopickerConfiguration.build {
                 runtimeEnv(PhotopickerRuntimeEnv.EMBEDDED)
@@ -240,9 +303,14 @@ class SearchFeatureTest : PhotopickerFeatureBaseTest() {
                 callingPackageUid(1234)
                 callingPackageLabel("test_app")
             }
-        assertWithMessage("Search Feature is not always enabled when search flag enabled")
-            .that(SearchFeature.Registration.isEnabled(testUserSelectImagesForAppConfiguration))
-            .isEqualTo(true)
+        assertWithMessage("Search Feature in embedded picker is always enabled in Perission mode")
+            .that(
+                SearchFeature.Registration.isEnabled(
+                    testUserSelectImagesForAppConfiguration,
+                    deferredPrefetchResultsMap,
+                )
+            )
+            .isEqualTo(false)
     }
 
     @Test
@@ -296,7 +364,9 @@ class SearchFeatureTest : PhotopickerFeatureBaseTest() {
             // Asserts search view page with its placeholder text displayed
             composeTestRule
                 .onNode(
-                    hasText(resources.getString(R.string.photopicker_searchView_placeholder_text))
+                    hasText(
+                        resources.getString(R.string.photopicker_search_photos_placeholder_text)
+                    )
                 )
                 .assertIsDisplayed()
 
@@ -338,7 +408,9 @@ class SearchFeatureTest : PhotopickerFeatureBaseTest() {
             val testQuery = "testquery"
             composeTestRule
                 .onNode(
-                    hasText(resources.getString(R.string.photopicker_searchView_placeholder_text))
+                    hasText(
+                        resources.getString(R.string.photopicker_search_photos_placeholder_text)
+                    )
                 )
                 .performTextInput(testQuery)
 
@@ -358,4 +430,137 @@ class SearchFeatureTest : PhotopickerFeatureBaseTest() {
                 .onNode(hasText(resources.getString(R.string.photopicker_search_placeholder_text)))
                 .assertIsDisplayed()
         }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testSearchBar_mimetypeOnlyVideo_showsVideoPlaceHolderText() =
+        testScope.runTest {
+            val resources = getTestableContext().getResources()
+            val testIntent =
+                Intent(MediaStore.ACTION_PICK_IMAGES).apply {
+                    putExtra(Intent.EXTRA_MIME_TYPES, arrayListOf("video/*", "video/mpeg"))
+                }
+            configurationManager.get().setIntent(testIntent)
+
+            composeTestRule.setContent {
+                callPhotopickerMain(
+                    featureManager = featureManager,
+                    selection = selection,
+                    events = events,
+                )
+            }
+
+            // Perform click action on the Search bar
+            composeTestRule
+                .onNode(hasText(resources.getString(R.string.photopicker_search_placeholder_text)))
+                .performClick()
+            composeTestRule.waitForIdle()
+
+            composeTestRule
+                .onNode(
+                    hasText(
+                        resources.getString(R.string.photopicker_search_videos_placeholder_text)
+                    )
+                )
+                .assertIsDisplayed()
+        }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testSearchBar_mimetypeOnlyImage_showsPhotosPlaceHolderText() =
+        testScope.runTest {
+            val resources = getTestableContext().getResources()
+            val testIntent =
+                Intent(MediaStore.ACTION_PICK_IMAGES).apply {
+                    putExtra(Intent.EXTRA_MIME_TYPES, arrayListOf("image/*", "image/png"))
+                }
+            configurationManager.get().setIntent(testIntent)
+            composeTestRule.setContent {
+                callPhotopickerMain(
+                    featureManager = featureManager,
+                    selection = selection,
+                    events = events,
+                )
+            }
+
+            // Perform click action on the Search bar
+            composeTestRule
+                .onNode(hasText(resources.getString(R.string.photopicker_search_placeholder_text)))
+                .performClick()
+            composeTestRule.waitForIdle()
+
+            composeTestRule
+                .onNode(
+                    hasText(
+                        resources.getString(R.string.photopicker_search_photos_placeholder_text)
+                    )
+                )
+                .assertIsDisplayed()
+        }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testSearchBar_mimetypeImageAndVideo_showsPhotosPlaceHolderText() =
+        testScope.runTest {
+            val resources = getTestableContext().getResources()
+            val testIntent =
+                Intent(MediaStore.ACTION_PICK_IMAGES).apply {
+                    putExtra(Intent.EXTRA_MIME_TYPES, arrayListOf("image/*", "video/*"))
+                }
+            configurationManager.get().setIntent(testIntent)
+            composeTestRule.setContent {
+                callPhotopickerMain(
+                    featureManager = featureManager,
+                    selection = selection,
+                    events = events,
+                )
+            }
+
+            // Perform click action on the Search bar
+            composeTestRule
+                .onNode(hasText(resources.getString(R.string.photopicker_search_placeholder_text)))
+                .performClick()
+            composeTestRule.waitForIdle()
+
+            composeTestRule
+                .onNode(
+                    hasText(
+                        resources.getString(R.string.photopicker_search_photos_placeholder_text)
+                    )
+                )
+                .assertIsDisplayed()
+        }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testSearchBar_mimeTypeAll_showsPhotosPlaceHolderText() =
+        testScope.runTest {
+            val resources = getTestableContext().getResources()
+            val testIntent =
+                Intent(MediaStore.ACTION_PICK_IMAGES).apply {
+                    putExtra(Intent.EXTRA_MIME_TYPES, arrayListOf("*/*"))
+                }
+            configurationManager.get().setIntent(testIntent)
+            composeTestRule.setContent {
+                callPhotopickerMain(
+                    featureManager = featureManager,
+                    selection = selection,
+                    events = events,
+                )
+            }
+
+            // Perform click action on the Search bar
+            composeTestRule
+                .onNode(hasText(resources.getString(R.string.photopicker_search_placeholder_text)))
+                .performClick()
+            composeTestRule.waitForIdle()
+
+            composeTestRule
+                .onNode(
+                    hasText(
+                        resources.getString(R.string.photopicker_search_photos_placeholder_text)
+                    )
+                )
+                .assertIsDisplayed()
+        }
 }
diff --git a/photopicker/tests/src/com/android/photopicker/features/search/SearchViewModelTest.kt b/photopicker/tests/src/com/android/photopicker/features/search/SearchViewModelTest.kt
new file mode 100644
index 000000000..94e336848
--- /dev/null
+++ b/photopicker/tests/src/com/android/photopicker/features/search/SearchViewModelTest.kt
@@ -0,0 +1,249 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.search
+
+import android.platform.test.annotations.EnableFlags
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import androidx.test.filters.SmallTest
+import com.android.photopicker.core.configuration.ConfigurationManager
+import com.android.photopicker.core.configuration.PhotopickerRuntimeEnv
+import com.android.photopicker.core.configuration.TestDeviceConfigProxyImpl
+import com.android.photopicker.core.configuration.provideTestConfigurationFlow
+import com.android.photopicker.core.events.Events
+import com.android.photopicker.core.events.generatePickerSessionId
+import com.android.photopicker.core.features.FeatureManager
+import com.android.photopicker.core.selection.Selection
+import com.android.photopicker.core.selection.SelectionImpl
+import com.android.photopicker.data.TestDataServiceImpl
+import com.android.photopicker.data.TestPrefetchDataService
+import com.android.photopicker.data.TestSearchDataServiceImpl
+import com.android.photopicker.data.model.Media
+import com.android.photopicker.features.search.model.SearchSuggestion
+import com.android.photopicker.features.search.model.SearchSuggestionType
+import com.android.providers.media.flags.Flags
+import com.google.common.truth.Truth.assertWithMessage
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.test.StandardTestDispatcher
+import kotlinx.coroutines.test.advanceTimeBy
+import kotlinx.coroutines.test.runTest
+import org.junit.Test
+import org.junit.runner.RunWith
+
+@SmallTest
+@RunWith(AndroidJUnit4::class)
+@OptIn(ExperimentalCoroutinesApi::class)
+class SearchViewModelTest {
+
+    lateinit var selection: Selection<Media>
+    lateinit var events: Events
+    private val deviceConfigProxy = TestDeviceConfigProxyImpl()
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testfetchSuggestions_initialState_hasFaceSuggestionAsSeparateList() {
+        runTest {
+            provideSelectionEvents(this.backgroundScope)
+            val configurationManager =
+                ConfigurationManager(
+                    runtimeEnv = PhotopickerRuntimeEnv.ACTIVITY,
+                    scope = this.backgroundScope,
+                    dispatcher = StandardTestDispatcher(this.testScheduler),
+                    deviceConfigProxy,
+                    generatePickerSessionId(),
+                )
+            val viewModel =
+                SearchViewModel(
+                    this.backgroundScope,
+                    StandardTestDispatcher(this.testScheduler),
+                    TestSearchDataServiceImpl(),
+                    selection,
+                    events,
+                    configurationManager,
+                )
+            viewModel.fetchSuggestions("")
+            advanceTimeBy(1000)
+            val suggestionLists = viewModel.suggestionLists.value
+            assertWithMessage("Unexpected total suggestions list size not correct")
+                .that(viewModel.suggestionLists.value.totalSuggestions)
+                .isEqualTo(4)
+            assertWithMessage("Unexpected history suggestions list size")
+                .that(suggestionLists.history.size)
+                .isEqualTo(1)
+            assertWithMessage("Unexpected face suggestions list size")
+                .that(suggestionLists.face.size)
+                .isEqualTo(1)
+            assertWithMessage("Unexpected other suggestions list size")
+                .that(suggestionLists.other.size)
+                .isEqualTo(2)
+        }
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun testfetchSuggestions_textQueryState_hasFaceSuggestionIntegratedList() {
+        runTest {
+            provideSelectionEvents(this.backgroundScope)
+            val configurationManager =
+                ConfigurationManager(
+                    runtimeEnv = PhotopickerRuntimeEnv.ACTIVITY,
+                    scope = this.backgroundScope,
+                    dispatcher = StandardTestDispatcher(this.testScheduler),
+                    deviceConfigProxy,
+                    generatePickerSessionId(),
+                )
+            val viewModel =
+                SearchViewModel(
+                    this.backgroundScope,
+                    StandardTestDispatcher(this.testScheduler),
+                    TestSearchDataServiceImpl(),
+                    selection,
+                    events,
+                    configurationManager,
+                )
+            viewModel.fetchSuggestions("abc")
+            advanceTimeBy(1000)
+            val suggestionLists = viewModel.suggestionLists.value
+            assertWithMessage("Unexpected total suggestions list size not correct")
+                .that(suggestionLists.totalSuggestions)
+                .isEqualTo(4)
+            assertWithMessage("Unexpected history suggestions list size")
+                .that(suggestionLists.history.size)
+                .isEqualTo(1)
+            assertWithMessage("Unexpected face suggestions list size")
+                .that(suggestionLists.face.size)
+                .isEqualTo(0)
+            assertWithMessage("Unexpected other suggestions list size")
+                .that(suggestionLists.other.size)
+                .isEqualTo(3)
+        }
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun clearSearch_searchState_isInactive() = runTest {
+        provideSelectionEvents(this.backgroundScope)
+        val configurationManager =
+            ConfigurationManager(
+                runtimeEnv = PhotopickerRuntimeEnv.ACTIVITY,
+                scope = this.backgroundScope,
+                dispatcher = StandardTestDispatcher(this.testScheduler),
+                deviceConfigProxy,
+                generatePickerSessionId(),
+            )
+        val viewModel =
+            SearchViewModel(
+                this.backgroundScope,
+                StandardTestDispatcher(this.testScheduler),
+                TestSearchDataServiceImpl(),
+                selection,
+                events,
+                configurationManager,
+            )
+        viewModel.performSearch("test") // Set a search state
+        viewModel.clearSearch()
+        assertWithMessage("Search state is not Inactive")
+            .that(SearchState.Inactive)
+            .isEqualTo(viewModel.searchState.value)
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun performSearch_withSuggestion_searchStateIsActiveSuggestion() = runTest {
+        provideSelectionEvents(this.backgroundScope)
+        val configurationManager =
+            ConfigurationManager(
+                runtimeEnv = PhotopickerRuntimeEnv.ACTIVITY,
+                scope = this.backgroundScope,
+                dispatcher = StandardTestDispatcher(this.testScheduler),
+                deviceConfigProxy,
+                generatePickerSessionId(),
+            )
+        val viewModel =
+            SearchViewModel(
+                this.backgroundScope,
+                StandardTestDispatcher(this.testScheduler),
+                TestSearchDataServiceImpl(),
+                selection,
+                events,
+                configurationManager,
+            )
+        val suggestion =
+            SearchSuggestion(
+                "suggestion",
+                authority = "",
+                "text",
+                type = SearchSuggestionType.TEXT,
+                null,
+            )
+        viewModel.performSearch(suggestion)
+        assertWithMessage("Search state is not Active for suggestion search")
+            .that(SearchState.Active.SuggestionSearch(suggestion))
+            .isEqualTo(viewModel.searchState.value)
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    fun performSearch_withQuery_searchStateIsActiveQuery() = runTest {
+        provideSelectionEvents(this.backgroundScope)
+        val configurationManager =
+            ConfigurationManager(
+                runtimeEnv = PhotopickerRuntimeEnv.ACTIVITY,
+                scope = this.backgroundScope,
+                dispatcher = StandardTestDispatcher(this.testScheduler),
+                deviceConfigProxy,
+                generatePickerSessionId(),
+            )
+        val viewModel =
+            SearchViewModel(
+                this.backgroundScope,
+                StandardTestDispatcher(this.testScheduler),
+                TestSearchDataServiceImpl(),
+                selection,
+                events,
+                configurationManager,
+            )
+        val query = "test query"
+        viewModel.performSearch(query)
+        assertWithMessage("Search state is not Active for query search")
+            .that(SearchState.Active.QuerySearch(query))
+            .isEqualTo(viewModel.searchState.value)
+    }
+
+    private fun provideSelectionEvents(scope: CoroutineScope) {
+        selection =
+            SelectionImpl<Media>(
+                scope = scope,
+                configuration = provideTestConfigurationFlow(scope = scope),
+                preSelectedMedia = TestDataServiceImpl().preSelectionMediaData,
+            )
+
+        val featureManager =
+            FeatureManager(
+                configuration = provideTestConfigurationFlow(scope = scope),
+                scope = scope,
+                prefetchDataService = TestPrefetchDataService(),
+            )
+
+        events =
+            Events(
+                scope = scope,
+                provideTestConfigurationFlow(scope = scope),
+                featureManager = featureManager,
+            )
+    }
+}
diff --git a/photopicker/tests/src/com/android/photopicker/features/search/TestSearchDataServiceImpl.kt b/photopicker/tests/src/com/android/photopicker/features/search/TestSearchDataServiceImpl.kt
new file mode 100644
index 000000000..f89933d7f
--- /dev/null
+++ b/photopicker/tests/src/com/android/photopicker/features/search/TestSearchDataServiceImpl.kt
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.data
+
+import android.net.Uri
+import android.os.CancellationSignal
+import androidx.paging.PagingSource
+import com.android.photopicker.data.model.Media
+import com.android.photopicker.data.model.MediaPageKey
+import com.android.photopicker.data.paging.FakeInMemoryMediaPagingSource
+import com.android.photopicker.features.search.data.SearchDataService
+import com.android.photopicker.features.search.model.SearchEnabledState
+import com.android.photopicker.features.search.model.SearchSuggestion
+import com.android.photopicker.features.search.model.SearchSuggestionType
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.StateFlow
+
+/**
+ * A test implementation of [SearchDataService] that provides fake search suggestions and results.
+ */
+class TestSearchDataServiceImpl() : SearchDataService {
+
+    var mediaSetSize: Int = FakeInMemoryMediaPagingSource.DEFAULT_SIZE
+    var mediaList: List<Media>? = null
+
+    override val isSearchEnabled: StateFlow<SearchEnabledState> =
+        MutableStateFlow(SearchEnabledState.ENABLED)
+
+    override suspend fun getSearchSuggestions(
+        prefix: String,
+        limit: Int,
+        cancellationSignal: CancellationSignal?,
+    ): List<SearchSuggestion> {
+        return listOf(
+            SearchSuggestion("1", "authority", "France", SearchSuggestionType.LOCATION, null),
+            SearchSuggestion("2", "authority", "Favorites", SearchSuggestionType.ALBUM, null),
+            SearchSuggestion("3", "authority", "Emma", SearchSuggestionType.FACE, Uri.parse("xyz")),
+            SearchSuggestion(null, "authority", "paris", SearchSuggestionType.HISTORY, null),
+        )
+    }
+
+    override fun getSearchResults(
+        suggestion: SearchSuggestion,
+        cancellationSignal: CancellationSignal?,
+    ): PagingSource<MediaPageKey, Media> {
+        return mediaList?.let { FakeInMemoryMediaPagingSource(it) }
+            ?: FakeInMemoryMediaPagingSource(mediaSetSize)
+    }
+
+    override fun getSearchResults(
+        searchText: String,
+        cancellationSignal: CancellationSignal?,
+    ): PagingSource<MediaPageKey, Media> {
+        return mediaList?.let { FakeInMemoryMediaPagingSource(it) }
+            ?: FakeInMemoryMediaPagingSource(mediaSetSize)
+    }
+}
diff --git a/photopicker/tests/src/com/android/photopicker/features/search/inject/SearchTestModule.kt b/photopicker/tests/src/com/android/photopicker/features/search/inject/SearchTestModule.kt
new file mode 100644
index 000000000..ae4b0b094
--- /dev/null
+++ b/photopicker/tests/src/com/android/photopicker/features/search/inject/SearchTestModule.kt
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.features.search.inject
+
+import com.android.photopicker.data.TestSearchDataServiceImpl
+import com.android.photopicker.features.search.data.SearchDataService
+import dagger.Module
+import dagger.Provides
+import dagger.hilt.components.SingletonComponent
+import dagger.hilt.testing.TestInstallIn
+import javax.inject.Singleton
+
+@Module
+@TestInstallIn(
+    components = [SingletonComponent::class],
+    replaces = [SearchEmbeddedServiceModule::class, SearchActivityRetainedModule::class],
+)
+class SearchTestModule {
+
+    @Singleton
+    @Provides
+    fun provideSearchDataService(): SearchDataService {
+        return TestSearchDataServiceImpl()
+    }
+}
diff --git a/photopicker/tests/src/com/android/photopicker/features/selectionbar/SelectionBarFeatureTest.kt b/photopicker/tests/src/com/android/photopicker/features/selectionbar/SelectionBarFeatureTest.kt
index 8588e3bbc..79b31183e 100644
--- a/photopicker/tests/src/com/android/photopicker/features/selectionbar/SelectionBarFeatureTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/selectionbar/SelectionBarFeatureTest.kt
@@ -61,13 +61,14 @@ import com.android.photopicker.core.navigation.LocalNavController
 import com.android.photopicker.core.selection.LocalSelection
 import com.android.photopicker.core.selection.Selection
 import com.android.photopicker.core.theme.PhotopickerTheme
+import com.android.photopicker.data.TestPrefetchDataService
 import com.android.photopicker.data.model.Media
 import com.android.photopicker.data.model.MediaSource
 import com.android.photopicker.features.PhotopickerFeatureBaseTest
 import com.android.photopicker.features.simpleuifeature.SimpleUiFeature
 import com.android.photopicker.inject.PhotopickerTestModule
 import com.android.photopicker.tests.HiltTestActivity
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.whenever
 import com.google.common.truth.Truth.assertWithMessage
 import dagger.Lazy
 import dagger.Module
@@ -348,6 +349,7 @@ class SelectionBarFeatureTest : PhotopickerFeatureBaseTest() {
                 FeatureManager(
                     provideTestConfigurationFlow(scope = this.backgroundScope),
                     this.backgroundScope,
+                    TestPrefetchDataService(),
                     testFeatureRegistrations,
                 )
             val photopickerConfiguration: PhotopickerConfiguration =
diff --git a/photopicker/tests/src/com/android/photopicker/features/snackbar/SnackbarFeatureTest.kt b/photopicker/tests/src/com/android/photopicker/features/snackbar/SnackbarFeatureTest.kt
index c9b7a7320..e1079a88b 100644
--- a/photopicker/tests/src/com/android/photopicker/features/snackbar/SnackbarFeatureTest.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/snackbar/SnackbarFeatureTest.kt
@@ -53,7 +53,7 @@ import com.android.photopicker.data.model.Media
 import com.android.photopicker.features.PhotopickerFeatureBaseTest
 import com.android.photopicker.inject.PhotopickerTestModule
 import com.android.photopicker.tests.HiltTestActivity
-import com.android.photopicker.tests.utils.mockito.whenever
+import com.android.photopicker.util.test.whenever
 import com.google.common.truth.Truth.assertWithMessage
 import dagger.Lazy
 import dagger.Module
diff --git a/photopicker/tests/src/com/android/photopicker/features/test/alwaysdisabledfeature/AlwaysDisabledFeature.kt b/photopicker/tests/src/com/android/photopicker/features/test/alwaysdisabledfeature/AlwaysDisabledFeature.kt
index 3723f5b66..32543a418 100644
--- a/photopicker/tests/src/com/android/photopicker/features/test/alwaysdisabledfeature/AlwaysDisabledFeature.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/test/alwaysdisabledfeature/AlwaysDisabledFeature.kt
@@ -28,7 +28,9 @@ import com.android.photopicker.core.features.FeatureRegistration
 import com.android.photopicker.core.features.Location
 import com.android.photopicker.core.features.LocationParams
 import com.android.photopicker.core.features.PhotopickerUiFeature
+import com.android.photopicker.core.features.PrefetchResultKey
 import com.android.photopicker.core.features.Priority
+import kotlinx.coroutines.Deferred
 
 /**
  * Test [PhotopickerUiFeature] that is always disabled, no matter what it tries, but always tries to
@@ -39,7 +41,10 @@ class AlwaysDisabledFeature : PhotopickerUiFeature {
     companion object Registration : FeatureRegistration {
         override val TAG: String = "AlwaysDisabledFeature"
 
-        override fun isEnabled(config: PhotopickerConfiguration) = false
+        override fun isEnabled(
+            config: PhotopickerConfiguration,
+            deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>>,
+        ) = false
 
         override fun build(featureManager: FeatureManager) = AlwaysDisabledFeature()
 
@@ -59,11 +64,7 @@ class AlwaysDisabledFeature : PhotopickerUiFeature {
     }
 
     @Composable
-    override fun compose(
-        location: Location,
-        modifier: Modifier,
-        params: LocationParams,
-    ) {
+    override fun compose(location: Location, modifier: Modifier, params: LocationParams) {
         when (location) {
             Location.COMPOSE_TOP -> composeTop()
             else -> {}
diff --git a/photopicker/tests/src/com/android/photopicker/features/test/highpriorityuifeature/HighPriorityUiFeature.kt b/photopicker/tests/src/com/android/photopicker/features/test/highpriorityuifeature/HighPriorityUiFeature.kt
index da28fba5a..c5d4f8886 100644
--- a/photopicker/tests/src/com/android/photopicker/features/test/highpriorityuifeature/HighPriorityUiFeature.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/test/highpriorityuifeature/HighPriorityUiFeature.kt
@@ -40,6 +40,7 @@ import com.android.photopicker.core.features.LocalFeatureManager
 import com.android.photopicker.core.features.Location
 import com.android.photopicker.core.features.LocationParams
 import com.android.photopicker.core.features.PhotopickerUiFeature
+import com.android.photopicker.core.features.PrefetchResultKey
 import com.android.photopicker.core.features.Priority
 import com.android.photopicker.core.navigation.LocalNavController
 import com.android.photopicker.core.navigation.PhotopickerDestinations.ALBUM_GRID
@@ -48,6 +49,7 @@ import com.android.photopicker.core.navigation.Route
 import com.android.photopicker.core.user.UserMonitor
 import com.android.photopicker.data.DataService
 import com.android.photopicker.features.simpleuifeature.SimpleUiFeature
+import kotlinx.coroutines.Deferred
 
 /**
  * Test [PhotopickerUiFeature] that renders a simple string to [Location.COMPOSE_TOP] with the
@@ -58,7 +60,10 @@ class HighPriorityUiFeature : PhotopickerUiFeature {
     companion object Registration : FeatureRegistration {
         override val TAG: String = "HighPriorityUiFeature"
 
-        override fun isEnabled(config: PhotopickerConfiguration) = true
+        override fun isEnabled(
+            config: PhotopickerConfiguration,
+            deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>>,
+        ) = true
 
         override fun build(featureManager: FeatureManager) = HighPriorityUiFeature()
 
@@ -188,11 +193,7 @@ class HighPriorityUiFeature : PhotopickerUiFeature {
 
     /* Feature framework compose-at-location callback */
     @Composable
-    override fun compose(
-        location: Location,
-        modifier: Modifier,
-        params: LocationParams,
-    ) {
+    override fun compose(location: Location, modifier: Modifier, params: LocationParams) {
         when (location) {
             Location.COMPOSE_TOP -> composeTop()
             else -> {}
diff --git a/photopicker/tests/src/com/android/photopicker/features/test/prefetchfeature/PrefetchFeature.kt b/photopicker/tests/src/com/android/photopicker/features/test/prefetchfeature/PrefetchFeature.kt
new file mode 100644
index 000000000..300a8fdbe
--- /dev/null
+++ b/photopicker/tests/src/com/android/photopicker/features/test/prefetchfeature/PrefetchFeature.kt
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package src.com.android.photopicker.features.test.prefetchfeature
+
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.Modifier
+import com.android.photopicker.core.configuration.PhotopickerConfiguration
+import com.android.photopicker.core.events.RegisteredEventClass
+import com.android.photopicker.core.features.FeatureManager
+import com.android.photopicker.core.features.FeatureRegistration
+import com.android.photopicker.core.features.Location
+import com.android.photopicker.core.features.LocationParams
+import com.android.photopicker.core.features.PhotopickerUiFeature
+import com.android.photopicker.core.features.PrefetchResultKey
+import com.android.photopicker.data.PrefetchDataService
+import kotlinx.coroutines.Deferred
+import kotlinx.coroutines.runBlocking
+
+class PrefetchFeature : PhotopickerUiFeature {
+
+    companion object Registration : FeatureRegistration {
+        // Use any valid key
+        private val prefetchResultKey: PrefetchResultKey = PrefetchResultKey.SEARCH_STATE
+
+        override val TAG: String = "PrefetchFeature"
+
+        override fun getPrefetchRequest(
+            config: PhotopickerConfiguration
+        ): Map<PrefetchResultKey, suspend (PrefetchDataService) -> Any?>? =
+            mapOf(prefetchResultKey to { true })
+
+        override fun isEnabled(
+            config: PhotopickerConfiguration,
+            deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>>,
+        ): Boolean {
+            return runBlocking {
+                val featureStatus: Any? = deferredPrefetchResultsMap[prefetchResultKey]?.await()
+                when (featureStatus) {
+                    null -> false
+                    is Boolean -> featureStatus
+                    else -> false
+                }
+            }
+        }
+
+        override fun build(featureManager: FeatureManager) = PrefetchFeature()
+    }
+
+    override fun registerLocations(): List<Pair<Location, Int>> = listOf()
+
+    @Composable
+    override fun compose(location: Location, modifier: Modifier, params: LocationParams) {}
+
+    override val token: String = TAG
+
+    override val eventsConsumed: Set<RegisteredEventClass> = emptySet()
+
+    override val eventsProduced: Set<RegisteredEventClass> = emptySet()
+}
diff --git a/photopicker/tests/src/com/android/photopicker/features/test/simpleuifeature/SimpleUiFeature.kt b/photopicker/tests/src/com/android/photopicker/features/test/simpleuifeature/SimpleUiFeature.kt
index 72f630267..4ee8aa100 100644
--- a/photopicker/tests/src/com/android/photopicker/features/test/simpleuifeature/SimpleUiFeature.kt
+++ b/photopicker/tests/src/com/android/photopicker/features/test/simpleuifeature/SimpleUiFeature.kt
@@ -35,11 +35,13 @@ import com.android.photopicker.core.features.FeatureRegistration
 import com.android.photopicker.core.features.Location
 import com.android.photopicker.core.features.LocationParams
 import com.android.photopicker.core.features.PhotopickerUiFeature
+import com.android.photopicker.core.features.PrefetchResultKey
 import com.android.photopicker.core.features.Priority
 import com.android.photopicker.core.navigation.Route
 import com.android.photopicker.core.user.UserMonitor
 import com.android.photopicker.data.DataService
 import com.android.photopicker.features.overflowmenu.OverflowMenuItem
+import kotlinx.coroutines.Deferred
 
 /** Test [PhotopickerUiFeature] that renders a simple string to [Location.COMPOSE_TOP] */
 open class SimpleUiFeature : PhotopickerUiFeature {
@@ -47,7 +49,10 @@ open class SimpleUiFeature : PhotopickerUiFeature {
     companion object Registration : FeatureRegistration {
         override val TAG: String = "SimpleUiFeature"
 
-        override fun isEnabled(config: PhotopickerConfiguration) = true
+        override fun isEnabled(
+            config: PhotopickerConfiguration,
+            deferredPrefetchResultsMap: Map<PrefetchResultKey, Deferred<Any?>>,
+        ) = true
 
         override fun build(featureManager: FeatureManager) = SimpleUiFeature()
 
@@ -123,17 +128,13 @@ open class SimpleUiFeature : PhotopickerUiFeature {
                 override fun composable(navBackStackEntry: NavBackStackEntry?) {
                     simpleRoute()
                 }
-            },
+            }
         )
     }
 
     /* Feature framework compose-at-location callback */
     @Composable
-    override fun compose(
-        location: Location,
-        modifier: Modifier,
-        params: LocationParams,
-    ) {
+    override fun compose(location: Location, modifier: Modifier, params: LocationParams) {
         when (location) {
             Location.COMPOSE_TOP -> composeTop(params)
             Location.SELECTION_BAR_SECONDARY_ACTION -> selectionBarAction()
diff --git a/photopicker/tests/src/com/android/photopicker/inject/PhotopickerTestModule.kt b/photopicker/tests/src/com/android/photopicker/inject/PhotopickerTestModule.kt
index 5d5b82da7..264f09021 100644
--- a/photopicker/tests/src/com/android/photopicker/inject/PhotopickerTestModule.kt
+++ b/photopicker/tests/src/com/android/photopicker/inject/PhotopickerTestModule.kt
@@ -39,8 +39,11 @@ import com.android.photopicker.core.selection.SelectionStrategy
 import com.android.photopicker.core.selection.SelectionStrategy.Companion.determineSelectionStrategy
 import com.android.photopicker.core.user.UserMonitor
 import com.android.photopicker.data.DataService
+import com.android.photopicker.data.PrefetchDataService
 import com.android.photopicker.data.TestDataServiceImpl
+import com.android.photopicker.data.TestPrefetchDataService
 import com.android.photopicker.data.model.Media
+import com.android.photopicker.features.search.data.SearchDataService
 import dagger.Lazy
 import dagger.Module
 import dagger.Provides
@@ -48,6 +51,7 @@ import dagger.hilt.migration.DisableInstallInCheck
 import javax.inject.Singleton
 import kotlinx.coroutines.CoroutineDispatcher
 import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.runBlocking
 import org.mockito.Mockito.mock
 
@@ -82,7 +86,7 @@ abstract class PhotopickerTestModule(val options: TestOptions = TestOptions.Buil
     @Provides
     fun provideEmbeddedLifecycle(
         viewModelFactory: EmbeddedViewModelFactory,
-        @Main dispatcher: CoroutineDispatcher
+        @Main dispatcher: CoroutineDispatcher,
     ): EmbeddedLifecycle {
         // Force Lifecycle to be created on the MainDispatcher
         val embeddedLifecycle = runBlocking(dispatcher) { EmbeddedLifecycle(viewModelFactory) }
@@ -99,6 +103,7 @@ abstract class PhotopickerTestModule(val options: TestOptions = TestOptions.Buil
         selection: Lazy<Selection<Media>>,
         userMonitor: Lazy<UserMonitor>,
         dataService: Lazy<DataService>,
+        searchDataService: Lazy<SearchDataService>,
         events: Lazy<Events>,
     ): EmbeddedViewModelFactory {
         val embeddedViewModelFactory =
@@ -107,6 +112,7 @@ abstract class PhotopickerTestModule(val options: TestOptions = TestOptions.Buil
                 configurationManager,
                 bannerManager,
                 dataService,
+                searchDataService,
                 events,
                 featureManager,
                 selection,
@@ -144,7 +150,7 @@ abstract class PhotopickerTestModule(val options: TestOptions = TestOptions.Buil
     fun createConfigurationManager(
         @Background scope: CoroutineScope,
         @Background dispatcher: CoroutineDispatcher,
-        deviceConfigProxy: DeviceConfigProxy
+        deviceConfigProxy: DeviceConfigProxy,
     ): ConfigurationManager {
 
         return ConfigurationManager(
@@ -152,7 +158,7 @@ abstract class PhotopickerTestModule(val options: TestOptions = TestOptions.Buil
             scope,
             dispatcher,
             deviceConfigProxy,
-            generatePickerSessionId()
+            generatePickerSessionId(),
         )
     }
 
@@ -189,7 +195,7 @@ abstract class PhotopickerTestModule(val options: TestOptions = TestOptions.Buil
             configurationManager.configuration,
             scope,
             dispatcher,
-            userHandle
+            userHandle,
         )
     }
 
@@ -204,7 +210,7 @@ abstract class PhotopickerTestModule(val options: TestOptions = TestOptions.Buil
     fun createEvents(
         @Background scope: CoroutineScope,
         configurationManager: ConfigurationManager,
-        featureManager: FeatureManager
+        featureManager: FeatureManager,
     ): Events {
         return Events(scope = scope, configurationManager.configuration, featureManager)
     }
@@ -214,32 +220,41 @@ abstract class PhotopickerTestModule(val options: TestOptions = TestOptions.Buil
     fun createFeatureManager(
         @Background scope: CoroutineScope,
         configurationManager: ConfigurationManager,
+        prefetchDataService: PrefetchDataService,
     ): FeatureManager {
         return FeatureManager(
             configuration = configurationManager.configuration,
             scope = scope,
+            prefetchDataService = prefetchDataService,
             registeredFeatures = options.registeredFeatures,
+            dispatcher = Dispatchers.Main.immediate,
         )
     }
 
+    @Singleton
+    @Provides
+    fun createPrefetchDataService(): PrefetchDataService {
+        return TestPrefetchDataService()
+    }
+
     @Singleton
     @Provides
     fun createSelection(
         @Background scope: CoroutineScope,
-        configurationManager: ConfigurationManager
+        configurationManager: ConfigurationManager,
     ): Selection<Media> {
         return when (determineSelectionStrategy(configurationManager.configuration.value)) {
             SelectionStrategy.GRANTS_AWARE_SELECTION ->
                 GrantsAwareSelectionImpl(
                     scope = scope,
                     configuration = configurationManager.configuration,
-                    preGrantedItemsCount = TestDataServiceImpl().preGrantedMediaCount
+                    preGrantedItemsCount = TestDataServiceImpl().preGrantedMediaCount,
                 )
             SelectionStrategy.DEFAULT ->
                 SelectionImpl(
                     scope = scope,
                     configuration = configurationManager.configuration,
-                    preSelectedMedia = TestDataServiceImpl().preSelectionMediaData
+                    preSelectedMedia = TestDataServiceImpl().preSelectionMediaData,
                 )
         }
     }
diff --git a/photopicker/tests/src/com/android/photopicker/util/MapOfDeferredWithTimeoutTest.kt b/photopicker/tests/src/com/android/photopicker/util/MapOfDeferredWithTimeoutTest.kt
new file mode 100644
index 000000000..fcf8038b4
--- /dev/null
+++ b/photopicker/tests/src/com/android/photopicker/util/MapOfDeferredWithTimeoutTest.kt
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.photopicker.util
+
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import androidx.test.filters.SmallTest
+import com.google.common.truth.Truth.assertWithMessage
+import kotlin.time.measureTime
+import kotlinx.coroutines.Deferred
+import kotlinx.coroutines.delay
+import kotlinx.coroutines.runBlocking
+import org.junit.Test
+import org.junit.runner.RunWith
+
+@SmallTest
+@RunWith(AndroidJUnit4::class)
+class MapOfDeferredWithTimeoutTest {
+
+    @Test
+    fun testTasksRunsInParallel() {
+        val time = measureTime {
+            runBlocking {
+                val inputMap: MutableMap<Int, suspend (Unit) -> Any?> = mutableMapOf()
+                for (i in 1..10) {
+                    inputMap[i] = {
+                        delay(50)
+                        i
+                    }
+                }
+
+                val resultMap: Map<Int, Deferred<Any?>> =
+                    mapOfDeferredWithTimeout(inputMap, Unit, 100)
+
+                for (i in 1..10) {
+                    val result: Any? = resultMap[i]?.await()
+                    assertWithMessage("Expected result type is not Int")
+                        .that(result is Int)
+                        .isTrue()
+                }
+            }
+        }
+
+        // If the map operation was not run in parallel there would be a expected time of 50 * N
+        // where N is the number of elements in the loop (10 in this case).
+        assertWithMessage("Expected total time to be less that 500ms")
+            .that(time.inWholeMilliseconds)
+            .isLessThan(500)
+    }
+
+    @Test
+    fun testMapTimeout() {
+        val time = measureTime {
+            runBlocking {
+                val inputMap: Map<String, suspend (Unit) -> Any?> =
+                    mapOf(
+                        "key1" to
+                            {
+                                delay(5000)
+                                true
+                            },
+                        "key2" to
+                            {
+                                delay(10)
+                                true
+                            },
+                        "key3" to { throw RuntimeException() },
+                    )
+
+                val resultMap: Map<String, Deferred<Any?>> =
+                    mapOfDeferredWithTimeout(inputMap, Unit, 50)
+
+                assertWithMessage("Task should be timed out. Expected result is null.")
+                    .that(resultMap["key1"]?.await())
+                    .isNull()
+
+                assertWithMessage("Result type is not Boolean")
+                    .that(resultMap["key2"]?.await() is Boolean)
+                    .isTrue()
+
+                assertWithMessage(
+                        "Error thrown by task should be silently logged. " +
+                            "Expected result is null."
+                    )
+                    .that(resultMap["key3"]?.await())
+                    .isNull()
+            }
+        }
+
+        // If the timeout didn't take effect, this would take more than 5 seconds to run.
+        assertWithMessage("Expected total time to be less that 500ms")
+            .that(time.inWholeMilliseconds)
+            .isLessThan(500)
+    }
+}
diff --git a/photopicker/tests/src/com/android/photopicker/utils/GlideLoadableIdlingResource.kt b/photopicker/tests/src/com/android/photopicker/util/test/GlideLoadableIdlingResource.kt
similarity index 98%
rename from photopicker/tests/src/com/android/photopicker/utils/GlideLoadableIdlingResource.kt
rename to photopicker/tests/src/com/android/photopicker/util/test/GlideLoadableIdlingResource.kt
index 00b7b5926..f436b5571 100644
--- a/photopicker/tests/src/com/android/photopicker/utils/GlideLoadableIdlingResource.kt
+++ b/photopicker/tests/src/com/android/photopicker/util/test/GlideLoadableIdlingResource.kt
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.android.photopicker.test.utils
+package com.android.photopicker.util.test
 
 import androidx.compose.ui.test.IdlingResource
 import java.util.concurrent.atomic.AtomicInteger
diff --git a/photopicker/tests/src/com/android/photopicker/utils/MockContentProviderWrapper.kt b/photopicker/tests/src/com/android/photopicker/util/test/MockContentProviderWrapper.kt
similarity index 95%
rename from photopicker/tests/src/com/android/photopicker/utils/MockContentProviderWrapper.kt
rename to photopicker/tests/src/com/android/photopicker/util/test/MockContentProviderWrapper.kt
index e51f679df..6a2187335 100644
--- a/photopicker/tests/src/com/android/photopicker/utils/MockContentProviderWrapper.kt
+++ b/photopicker/tests/src/com/android/photopicker/util/test/MockContentProviderWrapper.kt
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.android.photopicker.test.utils
+package com.android.photopicker.util.test
 
 import android.content.ContentProvider
 import android.content.res.AssetFileDescriptor
@@ -43,7 +43,7 @@ class MockContentProviderWrapper(val provider: ContentProvider) : MockContentPro
         uri: Uri,
         mimetype: String,
         opts: Bundle?,
-        cancellationSignal: CancellationSignal?
+        cancellationSignal: CancellationSignal?,
     ): AssetFileDescriptor? {
         return provider.openTypedAssetFile(uri, mimetype, opts, cancellationSignal)
     }
diff --git a/photopicker/tests/src/com/android/photopicker/utils/MockitoUtils.kt b/photopicker/tests/src/com/android/photopicker/util/test/MockitoUtils.kt
similarity index 97%
rename from photopicker/tests/src/com/android/photopicker/utils/MockitoUtils.kt
rename to photopicker/tests/src/com/android/photopicker/util/test/MockitoUtils.kt
index 7e5ce21ea..fc4e94b34 100644
--- a/photopicker/tests/src/com/android/photopicker/utils/MockitoUtils.kt
+++ b/photopicker/tests/src/com/android/photopicker/util/test/MockitoUtils.kt
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.android.photopicker.tests.utils.mockito
+package com.android.photopicker.util.test
 
 import android.content.Context
 import org.mockito.ArgumentCaptor
@@ -55,7 +55,7 @@ fun <Type> capture(argumentCaptor: ArgumentCaptor<Type>): Type = argumentCaptor.
 fun <Type> mockSystemService(
     context: Context,
     classToMock: Class<Type>,
-    block: InvocationOnMock.() -> Type
+    block: InvocationOnMock.() -> Type,
 ) {
     whenever(context.getSystemServiceName(classToMock)) { classToMock.simpleName }
     whenever(context.getSystemService(classToMock.simpleName)) { block() }
diff --git a/photopicker/tests/src/com/android/photopicker/utils/StubProvider.kt b/photopicker/tests/src/com/android/photopicker/util/test/StubProvider.kt
similarity index 97%
rename from photopicker/tests/src/com/android/photopicker/utils/StubProvider.kt
rename to photopicker/tests/src/com/android/photopicker/util/test/StubProvider.kt
index e46db611a..f89430428 100644
--- a/photopicker/tests/src/com/android/photopicker/utils/StubProvider.kt
+++ b/photopicker/tests/src/com/android/photopicker/util/test/StubProvider.kt
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.android.photopicker.tests.utils
+package com.android.photopicker.util.test
 
 import android.content.ContentProvider
 import android.content.ContentValues
@@ -81,6 +81,7 @@ class StubProvider : ContentProvider() {
             }
         }
     }
+
     /*
      * Always return true, indicating that the
      * provider loaded correctly.
@@ -101,7 +102,7 @@ class StubProvider : ContentProvider() {
         projection: Array<String>?,
         selection: String?,
         selectionArgs: Array<String>?,
-        sortOrder: String?
+        sortOrder: String?,
     ): Cursor? = null
 
     /*
@@ -121,6 +122,6 @@ class StubProvider : ContentProvider() {
         uri: Uri,
         values: ContentValues?,
         selection: String?,
-        selectionArgs: Array<String>?
+        selectionArgs: Array<String>?,
     ): Int = 0
 }
diff --git a/res/layout/permission_body.xml b/res/layout/permission_body.xml
index 6d5fc884f..0956e7450 100644
--- a/res/layout/permission_body.xml
+++ b/res/layout/permission_body.xml
@@ -80,9 +80,9 @@
     <ImageView
         android:id="@+id/thumb_full"
         android:layout_width="match_parent"
-        android:layout_height="200dp"
+        android:layout_height="150dp"
         android:layout_gravity="center"
-        android:scaleType="centerCrop"
+        android:scaleType="centerInside"
         android:src="@color/thumb_gray_color"
         android:visibility="gone" />
 
diff --git a/res/values-af/strings.xml b/res/values-af/strings.xml
index e06082c38..d235faeca 100644
--- a/res/values-af/strings.xml
+++ b/res/values-af/strings.xml
@@ -68,7 +68,7 @@
     <string name="picker_personal_profile" msgid="639484258397758406">"Skakel oor na persoonlik"</string>
     <string name="picker_personal_profile_label" msgid="6189198163209597344">"Persoonlik"</string>
     <string name="picker_profile_admin_title" msgid="4172022376418293777">"Deur jou admin geblokkeer"</string>
-    <string name="picker_profile_admin_msg_from_personal" msgid="1941639895084555723">"Toegang tot werkdata van \'n persoonlike program af word nie toegelaat nie"</string>
+    <string name="picker_profile_admin_msg_from_personal" msgid="1941639895084555723">"Toegang tot werkdata van \'n persoonlike app af word nie toegelaat nie"</string>
     <string name="picker_profile_admin_msg_from_work" msgid="8048524337462790110">"Toegang tot persoonlike data van \'n werkprogram af word nie toegelaat nie"</string>
     <string name="picker_profile_admin_msg" msgid="4060112887923255178">"Toegang tot <xliff:g id="PROFILE1">%1$s</xliff:g>-data van n <xliff:g id="PROFILE2">%2$s</xliff:g>-app af word nie toegelaat nie"</string>
     <string name="picker_profile_switch_message" msgid="1133817927412489487">"Skakel oor na <xliff:g id="PROFILE">%s</xliff:g>"</string>
diff --git a/res/values-bs/strings.xml b/res/values-bs/strings.xml
index 1a8887edc..73fd8f851 100644
--- a/res/values-bs/strings.xml
+++ b/res/values-bs/strings.xml
@@ -32,7 +32,7 @@
     <string name="permission_more_thumb" msgid="1938863829470531577">"{count,plural, =1{i jo <xliff:g id="COUNT_0">^1</xliff:g>}one{i jo <xliff:g id="COUNT_1">^1</xliff:g>}few{i jo <xliff:g id="COUNT_1">^1</xliff:g>}other{i jo <xliff:g id="COUNT_1">^1</xliff:g>}}"</string>
     <string name="permission_more_text" msgid="2471785045095597753">"{count,plural, =1{Jo <xliff:g id="COUNT_0">^1</xliff:g> dodatna stavka}one{Jo <xliff:g id="COUNT_1">^1</xliff:g> dodatna stavka}few{Jo <xliff:g id="COUNT_1">^1</xliff:g> dodatne stavke}other{Jo <xliff:g id="COUNT_1">^1</xliff:g> dodatnih stavki}}"</string>
     <string name="cache_clearing_dialog_title" msgid="8907893815183913664">"Brisanje privremenih fajlova aplikacija"</string>
-    <string name="cache_clearing_dialog_text" msgid="7057784635111940957">"Aplikacija <xliff:g id="APP_SEEKING_PERMISSION">%s</xliff:g> eli obrisati neke privremene fajlove. Ovo moe dovesti do poveanog koritenja baterije ili prijenosa podataka na mobilnoj mrei."</string>
+    <string name="cache_clearing_dialog_text" msgid="7057784635111940957">"Aplikacija <xliff:g id="APP_SEEKING_PERMISSION">%s</xliff:g> eli obrisati neke privremene fajlove. Ovo moe dovesti do poveanog koritenja baterije ili prenosa podataka na mobilnoj mrei."</string>
     <string name="cache_clearing_in_progress_title" msgid="6902220064511664209">"Brisanje privremenih fajlova aplikacije"</string>
     <string name="clear" msgid="5524638938415865915">"Obrii"</string>
     <string name="allow" msgid="8885707816848569619">"Dozvoli"</string>
diff --git a/res/values-ca/strings.xml b/res/values-ca/strings.xml
index e1225fb3a..5c277c3a6 100644
--- a/res/values-ca/strings.xml
+++ b/res/values-ca/strings.xml
@@ -153,7 +153,7 @@
     <string name="permission_progress_delete_generic" msgid="6709118146245087898">"{count,plural, =1{S\'est suprimint l\'element}many{S\'estan suprimint <xliff:g id="COUNT">^1</xliff:g> elements}other{S\'estan suprimint <xliff:g id="COUNT">^1</xliff:g> elements}}"</string>
     <string name="transcode_denied" msgid="6760546817138288976">"<xliff:g id="APP_NAME">%s</xliff:g> no pot processar els fitxers multimdia"</string>
     <string name="transcode_processing_cancelled" msgid="5340383917746945590">"El processament del contingut multimdia s\'ha cancellat"</string>
-    <string name="transcode_processing_error" msgid="8921643164508407874">"S\'ha produt un error en processar el contingut multimdia"</string>
+    <string name="transcode_processing_error" msgid="8921643164508407874">"Hi ha hagut un error en processar el contingut multimdia"</string>
     <string name="transcode_processing_success" msgid="447288876429730122">"El contingut multimdia s\'ha processat correctament"</string>
     <string name="transcode_processing_started" msgid="7789086308155361523">"El processament del contingut multimdia s\'ha iniciat"</string>
     <string name="transcode_processing" msgid="6753136468864077258">"S\'est processant el contingut multimdia"</string>
diff --git a/res/values-es/strings.xml b/res/values-es/strings.xml
index 9d0482ce5..95dc9bc2a 100644
--- a/res/values-es/strings.xml
+++ b/res/values-es/strings.xml
@@ -39,8 +39,8 @@
     <string name="deny" msgid="6040983710442068936">"Denegar"</string>
     <string name="picker_browse" msgid="5554477454636075934">"Buscar"</string>
     <string name="picker_settings" msgid="6443463167344790260">"App multimedia en la nube"</string>
-    <string name="picker_settings_system_settings_menu_title" msgid="3055084757610063581">"Aplicacin multimedia en la nube"</string>
-    <string name="picker_settings_title" msgid="5647700706470673258">"Aplicacin multimedia en la nube"</string>
+    <string name="picker_settings_system_settings_menu_title" msgid="3055084757610063581">"Servicio de almacenamiento en la nube"</string>
+    <string name="picker_settings_title" msgid="5647700706470673258">"Aplicacin de fotos en la nube"</string>
     <string name="picker_settings_description" msgid="2916686824777214585">"Accede a tu contenido multimedia en la nube cuando una aplicacin o sitio web te pide que selecciones fotos o vdeos"</string>
     <string name="picker_settings_selection_message" msgid="245453573086488596">"Accede al contenido multimedia en la nube desde"</string>
     <string name="picker_settings_no_provider" msgid="2582311853680058223">"Ninguna"</string>
diff --git a/res/values-eu/strings.xml b/res/values-eu/strings.xml
index 084b4c21d..5f76881b7 100644
--- a/res/values-eu/strings.xml
+++ b/res/values-eu/strings.xml
@@ -99,7 +99,7 @@
     <string name="picker_play_video" msgid="7106025944628666250">"Erreproduzitu"</string>
     <string name="picker_pause_video" msgid="1092718225234326702">"Pausatu"</string>
     <string name="picker_error_snackbar" msgid="5970192792792369203">"Ezin da erreproduzitu bideoa"</string>
-    <string name="picker_error_dialog_title" msgid="4540095603788920965">"Arazoren bat izan da bideoa erreproduzitzean"</string>
+    <string name="picker_error_dialog_title" msgid="4540095603788920965">"Arazoak daude bideoa erreproduzitzeko"</string>
     <string name="picker_error_dialog_body" msgid="2515738446802971453">"Egiaztatu Internetera konektatuta zaudela eta saiatu berriro"</string>
     <string name="picker_error_dialog_positive_action" msgid="749544129082109232">"Saiatu berriro"</string>
     <string name="not_selected" msgid="2244008151669896758">"hautatu gabe"</string>
diff --git a/res/values-fa/strings.xml b/res/values-fa/strings.xml
index 48b8a8227..9eae3f9c2 100644
--- a/res/values-fa/strings.xml
+++ b/res/values-fa/strings.xml
@@ -164,7 +164,7 @@
     <string name="transcode_progress_channel" msgid="6122609645085712101">"  "</string>
     <string name="dialog_error_message" msgid="5120432204743681606">"   .       ."</string>
     <string name="dialog_error_title" msgid="636349284077820636">"     "</string>
-    <string name="dialog_button_text" msgid="351366485240852280">""</string>
+    <string name="dialog_button_text" msgid="351366485240852280">""</string>
     <string name="permlab_accessMediaOwnerPackageName" msgid="3849443148060165651">"     "</string>
     <string name="permdesc_accessMediaOwnerPackageName" msgid="7381563109363105371">"              ."</string>
 </resources>
diff --git a/res/values-it/strings.xml b/res/values-it/strings.xml
index 6e4a69bcd..3a8287fa8 100644
--- a/res/values-it/strings.xml
+++ b/res/values-it/strings.xml
@@ -43,7 +43,7 @@
     <string name="picker_settings_title" msgid="5647700706470673258">"App multimediale cloud"</string>
     <string name="picker_settings_description" msgid="2916686824777214585">"Accedi ai tuoi contenuti multimediali sul cloud quando un\'app o un sito web ti chiede di selezionare foto o video"</string>
     <string name="picker_settings_selection_message" msgid="245453573086488596">"Accedi ai contenuti multimediali sul cloud da"</string>
-    <string name="picker_settings_no_provider" msgid="2582311853680058223">"Nessuna"</string>
+    <string name="picker_settings_no_provider" msgid="2582311853680058223">"Nessuna app"</string>
     <string name="picker_settings_toast_error" msgid="697274445512467469">"Ora  impossibile cambiare app multimediale cloud."</string>
     <string name="picker_sync_notification_channel" msgid="1867105708912627993">"Selettore media"</string>
     <string name="picker_sync_notification_title" msgid="1122713382122055246">"Selettore media"</string>
@@ -164,7 +164,7 @@
     <string name="transcode_progress_channel" msgid="6122609645085712101">"Avanzamento transcodifica"</string>
     <string name="dialog_error_message" msgid="5120432204743681606">"Riprova pi tardi. Le tue foto saranno disponibili dopo aver risolto il problema."</string>
     <string name="dialog_error_title" msgid="636349284077820636">"Impossibile caricare alcune foto"</string>
-    <string name="dialog_button_text" msgid="351366485240852280">"OK"</string>
+    <string name="dialog_button_text" msgid="351366485240852280">"Ok"</string>
     <string name="permlab_accessMediaOwnerPackageName" msgid="3849443148060165651">"Accedi al nome del pacchetto del proprietario dei media"</string>
     <string name="permdesc_accessMediaOwnerPackageName" msgid="7381563109363105371">"Consente all\'app di accedere ai nomi di tutti i file multimediali accessibili dei pacchetti del proprietario."</string>
 </resources>
diff --git a/res/values-ja/strings.xml b/res/values-ja/strings.xml
index 418de25ca..ccf352d7a 100644
--- a/res/values-ja/strings.xml
+++ b/res/values-ja/strings.xml
@@ -42,7 +42,7 @@
     <string name="picker_settings_system_settings_menu_title" msgid="3055084757610063581">" "</string>
     <string name="picker_settings_title" msgid="5647700706470673258">"  "</string>
     <string name="picker_settings_description" msgid="2916686824777214585">" "</string>
-    <string name="picker_settings_selection_message" msgid="245453573086488596">" "</string>
+    <string name="picker_settings_selection_message" msgid="245453573086488596">" "</string>
     <string name="picker_settings_no_provider" msgid="2582311853680058223">""</string>
     <string name="picker_settings_toast_error" msgid="697274445512467469">" "</string>
     <string name="picker_sync_notification_channel" msgid="1867105708912627993">""</string>
diff --git a/res/values-mk/strings.xml b/res/values-mk/strings.xml
index 5acc1e99e..e2453f3c8 100644
--- a/res/values-mk/strings.xml
+++ b/res/values-mk/strings.xml
@@ -66,7 +66,7 @@
     <string name="picker_preview" msgid="6257414886055861039">""</string>
     <string name="picker_work_profile" msgid="2083221066869141576">"    "</string>
     <string name="picker_personal_profile" msgid="639484258397758406">"    "</string>
-    <string name="picker_personal_profile_label" msgid="6189198163209597344">""</string>
+    <string name="picker_personal_profile_label" msgid="6189198163209597344">""</string>
     <string name="picker_profile_admin_title" msgid="4172022376418293777">"  "</string>
     <string name="picker_profile_admin_msg_from_personal" msgid="1941639895084555723">"         "</string>
     <string name="picker_profile_admin_msg_from_work" msgid="8048524337462790110">"         "</string>
diff --git a/res/values-sk/strings.xml b/res/values-sk/strings.xml
index 3c45dbd10..b6c044328 100644
--- a/res/values-sk/strings.xml
+++ b/res/values-sk/strings.xml
@@ -41,8 +41,8 @@
     <string name="picker_settings" msgid="6443463167344790260">"Ap. na prstup kmd. vcloude"</string>
     <string name="picker_settings_system_settings_menu_title" msgid="3055084757610063581">"Aplikcia na prstup kmd. vcloude"</string>
     <string name="picker_settings_title" msgid="5647700706470673258">"Aplikcia na prstup kmdim vcloude"</string>
-    <string name="picker_settings_description" msgid="2916686824777214585">"Ke vs aplikcia alebo web poiada ovber fotiek alebo vide, prejdite do mdi vcloude."</string>
-    <string name="picker_settings_selection_message" msgid="245453573086488596">"Pristupova kmdim vcloude zaplikcie:"</string>
+    <string name="picker_settings_description" msgid="2916686824777214585">"Ke vs nejak aplikcia alebo web poiada ovber fotiek alebo vide, mete vybera zo svojich mdi vcloude."</string>
+    <string name="picker_settings_selection_message" msgid="245453573086488596">"Otvramdi vcloude pomocouaplikcie:"</string>
     <string name="picker_settings_no_provider" msgid="2582311853680058223">"iadna aplikcia"</string>
     <string name="picker_settings_toast_error" msgid="697274445512467469">"Momentlne sa nepodarilo zmeni cloudov prehrva"</string>
     <string name="picker_sync_notification_channel" msgid="1867105708912627993">"Nstroj na vber mdi"</string>
diff --git a/res/values-ta/strings.xml b/res/values-ta/strings.xml
index 52c18402b..00250f335 100644
--- a/res/values-ta/strings.xml
+++ b/res/values-ta/strings.xml
@@ -37,7 +37,7 @@
     <string name="clear" msgid="5524638938415865915">""</string>
     <string name="allow" msgid="8885707816848569619">""</string>
     <string name="deny" msgid="6040983710442068936">""</string>
-    <string name="picker_browse" msgid="5554477454636075934">""</string>
+    <string name="picker_browse" msgid="5554477454636075934">"..."</string>
     <string name="picker_settings" msgid="6443463167344790260">"  "</string>
     <string name="picker_settings_system_settings_menu_title" msgid="3055084757610063581">"  "</string>
     <string name="picker_settings_title" msgid="5647700706470673258">"  "</string>
diff --git a/src/com/android/providers/media/DatabaseBackupAndRecovery.java b/src/com/android/providers/media/DatabaseBackupAndRecovery.java
index afcf12404..03888a772 100644
--- a/src/com/android/providers/media/DatabaseBackupAndRecovery.java
+++ b/src/com/android/providers/media/DatabaseBackupAndRecovery.java
@@ -35,7 +35,6 @@ import static com.android.providers.media.flags.Flags.enableStableUrisForExterna
 import static com.android.providers.media.flags.Flags.enableStableUrisForPublicVolume;
 
 import android.content.ContentValues;
-import android.content.Context;
 import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
 import android.os.Build;
@@ -103,6 +102,8 @@ public class DatabaseBackupAndRecovery {
      */
     private static final String LEVEL_DB_PREFIX = "leveldb-";
 
+    private static final String OWNERSHIP_TABLE_NAME = LEVEL_DB_PREFIX + "ownership";
+
     /**
      * Frequency at which next value of owner id is backed up in the external storage.
      */
@@ -123,6 +124,12 @@ public class DatabaseBackupAndRecovery {
      */
     private static final String LAST_BACKEDUP_GENERATION_XATTR_KEY = "user.lastbackedgeneration";
 
+    /**
+     * Key name of xattr used to store a public volume recovery flag.
+     */
+    private static final String PUBLIC_VOLUME_RECOVERY_FLAG_XATTR_KEY
+            = "user.publicvolumerecoveryflag";
+
     /**
      * External primary storage root path for given user.
      */
@@ -216,7 +223,7 @@ public class DatabaseBackupAndRecovery {
             return true;
         }
 
-        // Check if flags are enabled for test for external primary volume
+        // Check if flags are enabled for test for public volume
         if (!MediaStore.VOLUME_INTERNAL.equalsIgnoreCase(volumeName)
                 && !MediaStore.VOLUME_EXTERNAL_PRIMARY.equalsIgnoreCase(volumeName)
                 && mIsStableUrisEnabledForPublic) {
@@ -519,7 +526,7 @@ public class DatabaseBackupAndRecovery {
     protected void deleteBackupForVolume(String volumeName) {
         File dbFilePath = new File(
                 String.format(Locale.ROOT, "%s/%s.db", LOWER_FS_RECOVERY_DIRECTORY_PATH,
-                        volumeName));
+                        LEVEL_DB_PREFIX + volumeName));
         if (dbFilePath.exists()) {
             dbFilePath.delete();
         }
@@ -959,8 +966,38 @@ public class DatabaseBackupAndRecovery {
         return null;
     }
 
-    protected void queuePublicVolumeRecovery(Context context) {
-        MediaService.queuePublicVolumeRecovery(context);
+    protected void markPublicVolumesRecovery() {
+        try {
+            File recoveryDir = new File(LOWER_FS_RECOVERY_DIRECTORY_PATH);
+            for (File levelDbFile : recoveryDir.listFiles()) {
+                if (!(LEVEL_DB_PREFIX + MediaStore.VOLUME_EXTERNAL_PRIMARY)
+                        .equalsIgnoreCase(levelDbFile.getName())
+                        && !(LEVEL_DB_PREFIX + MediaStore.VOLUME_INTERNAL)
+                        .equalsIgnoreCase(levelDbFile.getName())
+                        && !(OWNERSHIP_TABLE_NAME
+                        .equalsIgnoreCase(levelDbFile.getName()))) {
+                    setXattr(levelDbFile.getAbsolutePath(), PUBLIC_VOLUME_RECOVERY_FLAG_XATTR_KEY,
+                            String.valueOf(true));
+                }
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "Exception while marking public volumes for recovery", e);
+        }
+    }
+
+    protected boolean isPublicVolumeMarkedForRecovery(String volumeName) {
+        String filePath = LOWER_FS_RECOVERY_DIRECTORY_PATH + "/" + LEVEL_DB_PREFIX
+                + volumeName.toLowerCase(Locale.ROOT);
+        Optional<String> flag = getXattr(filePath, PUBLIC_VOLUME_RECOVERY_FLAG_XATTR_KEY);
+        Log.d(TAG, "Public volume is " + (flag.isPresent() ? "" : "not ")
+                + "marked for recovery, volume: " + volumeName);
+        return flag.isPresent();
+    }
+
+    protected void removePublicVolumeRecoveryFlag(String volumeName) {
+        String filePath = LOWER_FS_RECOVERY_DIRECTORY_PATH + "/" + LEVEL_DB_PREFIX
+                + volumeName.toLowerCase(Locale.ROOT);
+        removeXattr(filePath, PUBLIC_VOLUME_RECOVERY_FLAG_XATTR_KEY);
     }
 
     protected void recoverData(SQLiteDatabase db, String volumeName) throws Exception {
@@ -968,11 +1005,6 @@ public class DatabaseBackupAndRecovery {
                 totalLevelDbRows = 0;
         final long startTime = SystemClock.elapsedRealtime();
         try {
-            if (!MediaStore.VOLUME_EXTERNAL_PRIMARY.equalsIgnoreCase(volumeName)
-                    && !MediaStore.VOLUME_INTERNAL.equalsIgnoreCase(volumeName)) {
-                // todo: implement for public volume
-                return;
-            }
             final String fuseFilePath = getFuseFilePathFromVolumeName(volumeName);
             // Wait for external primary to be attached as we use same thread for internal volume.
             // Maximum wait for 20s
@@ -983,7 +1015,7 @@ public class DatabaseBackupAndRecovery {
 
             Log.d(TAG, "Backup is present for " + volumeName);
             try {
-                waitForVolumeToBeAttached(mSetupCompleteVolumes);
+                waitForVolumeToBeAttached(MediaStore.VOLUME_EXTERNAL_PRIMARY);
             } catch (Exception e) {
                 throw new IllegalStateException(
                         "Volume not attached in given time. Cannot recover data.", e);
@@ -1076,28 +1108,30 @@ public class DatabaseBackupAndRecovery {
             return new File(INTERNAL_VOLUME_LOWER_FS_BACKUP_PATH).exists();
         } else if (MediaStore.VOLUME_EXTERNAL_PRIMARY.equalsIgnoreCase(volumeName)) {
             return new File(EXTERNAL_PRIMARY_VOLUME_LOWER_FS_BACKUP_PATH).exists();
+        } else if (!Strings.isNullOrEmpty(volumeName)) {
+            return new File(LOWER_FS_RECOVERY_DIRECTORY_PATH + "/leveldb-" + volumeName)
+                    .exists();
         }
 
         return false;
     }
 
-    protected void waitForVolumeToBeAttached(Set<String> setupCompleteVolumes)
-            throws TimeoutException {
+    protected void waitForVolumeToBeAttached(String volumeName) throws TimeoutException {
         long time = 0;
         // Wait of 10 seconds
         long waitTimeInMilliseconds = 10000;
         // Poll every 100 milliseconds
         long pollTime = 100;
         while (time <= waitTimeInMilliseconds) {
-            if (setupCompleteVolumes.contains(MediaStore.VOLUME_EXTERNAL_PRIMARY)) {
-                Log.i(TAG, "Found external primary volume attached.");
+            if (mSetupCompleteVolumes.contains(volumeName)) {
+                Log.i(TAG, "Found " + volumeName + " volume attached.");
                 return;
             }
 
             SystemClock.sleep(pollTime);
             time += pollTime;
         }
-        throw new TimeoutException("Timed out waiting for external primary setup");
+        throw new TimeoutException("Timed out waiting for " + volumeName + " setup");
     }
 
     protected FuseDaemon getFuseDaemonForFileWithWait(File fuseFilePath)
@@ -1158,24 +1192,40 @@ public class DatabaseBackupAndRecovery {
             return;
         }
 
-        FuseDaemon fuseDaemon;
+        final FuseDaemon fuseDaemonExternalPrimary;
         try {
-            fuseDaemon = getFuseDaemonForPath(getFuseFilePathFromVolumeName(
-                    newRow.getVolumeName()));
-        } catch (FileNotFoundException e) {
+            fuseDaemonExternalPrimary = getFuseDaemonForFileWithWait(
+                    new File(EXTERNAL_PRIMARY_ROOT_PATH));
+        } catch (Exception e) {
             Log.e(TAG,
                     "Fuse Daemon not found for primary external storage, skipping update of "
-                            + "backup.",
-                    e);
+                            + newRow.getPath(), e);
             return;
         }
 
+        final FuseDaemon fuseDaemonPublicVolume;
+        if (!isInternalOrExternalPrimary(newRow.getVolumeName())) {
+            try {
+                fuseDaemonPublicVolume = getFuseDaemonForFileWithWait(new File(
+                        getFuseFilePathFromVolumeName(newRow.getVolumeName())));
+            } catch (Exception e) {
+                Log.e(TAG,
+                        "Error occurred while retrieving the Fuse Daemon for "
+                                + getFuseFilePathFromVolumeName(newRow.getVolumeName())
+                                + ", skipping update of " + newRow.getPath(),
+                        e);
+                return;
+            }
+        } else {
+            fuseDaemonPublicVolume = null;
+        }
+
         helper.runWithTransaction((db) -> {
             try (Cursor c = db.query(true, "files", QUERY_COLUMNS, "_id=?",
                     new String[]{String.valueOf(newRow.getId())}, null, null, null,
                     null, null)) {
                 if (c.moveToFirst()) {
-                    backupDataValues(fuseDaemon, c);
+                    backupDataValues(fuseDaemonExternalPrimary, fuseDaemonPublicVolume, c);
                     String newPath = c.getString(1);
                     if (oldRow.getPath() != null && !oldRow.getPath().equalsIgnoreCase(newPath)) {
                         // If file path has changed, update leveldb backup to delete old path.
diff --git a/src/com/android/providers/media/DatabaseHelper.java b/src/com/android/providers/media/DatabaseHelper.java
index 6a1e2cc1e..2f433ff8a 100644
--- a/src/com/android/providers/media/DatabaseHelper.java
+++ b/src/com/android/providers/media/DatabaseHelper.java
@@ -338,8 +338,8 @@ public class DatabaseHelper extends SQLiteOpenHelper implements AutoCloseable {
         // Recreate all views to apply this filter
         final SQLiteDatabase db = super.getWritableDatabase();
         mSchemaLock.writeLock().lock();
-        db.beginTransaction();
         try {
+            db.beginTransaction();
             createLatestViews(db);
             db.setTransactionSuccessful();
         } finally {
@@ -572,27 +572,40 @@ public class DatabaseHelper extends SQLiteOpenHelper implements AutoCloseable {
             tryRecoverDatabase(db, MediaStore.VOLUME_INTERNAL);
         } else {
             tryRecoverDatabase(db, MediaStore.VOLUME_EXTERNAL_PRIMARY);
-            mDatabaseBackupAndRecovery.queuePublicVolumeRecovery(mContext);
         }
         tryRecoverRowIdSequence(db);
         tryMigrateFromLegacy(db);
     }
 
     public void tryRecoverPublicVolume(String volumeName) {
-        if (MediaStore.VOLUME_INTERNAL.equalsIgnoreCase(volumeName)
-                || MediaStore.VOLUME_EXTERNAL_PRIMARY.equalsIgnoreCase(volumeName)) {
+        if (!mDatabaseBackupAndRecovery.isStableUrisEnabled(volumeName)
+                || !mDatabaseBackupAndRecovery.isPublicVolumeMarkedForRecovery(volumeName)) {
             return;
         }
-        tryRecoverDatabase(super.getWritableDatabase(), mVolumeName);
-    }
 
-    private void tryRecoverDatabase(SQLiteDatabase db, String volumeName) {
-        if (!MediaStore.VOLUME_INTERNAL.equalsIgnoreCase(volumeName)
-                && !MediaStore.VOLUME_EXTERNAL_PRIMARY.equalsIgnoreCase(volumeName)) {
-            // Implement for public volume
-            return;
+        try {
+            mDatabaseBackupAndRecovery.waitForVolumeToBeAttached(volumeName);
+        } catch (Exception e) {
+            throw new IllegalStateException(
+                    "Volume not attached in given time. Cannot recover data.", e);
         }
 
+        synchronized (sRecoveryLock) {
+            final SQLiteDatabase db = super.getWritableDatabase();
+            mIsRecovering.set(true);
+            try {
+                mDatabaseBackupAndRecovery.recoverData(db, volumeName);
+            } catch (Exception exception) {
+                Log.e(TAG, "Error in recovering data", exception);
+            } finally {
+                mDatabaseBackupAndRecovery.removePublicVolumeRecoveryFlag(volumeName);
+                mIsRecovering.set(false);
+                mDatabaseBackupAndRecovery.resetLastBackedUpGenerationNumber(volumeName);
+            }
+        }
+    }
+
+    private void tryRecoverDatabase(SQLiteDatabase db, String volumeName) {
         if (!mDatabaseBackupAndRecovery.isStableUrisEnabled(volumeName)) {
             return;
         }
@@ -620,7 +633,6 @@ public class DatabaseHelper extends SQLiteOpenHelper implements AutoCloseable {
                 return;
             }
 
-
             MediaProviderStatsLog.write(
                     MediaProviderStatsLog.MEDIA_PROVIDER_DATABASE_ROLLBACK_REPORTED, isInternal()
                             ?
@@ -640,6 +652,9 @@ public class DatabaseHelper extends SQLiteOpenHelper implements AutoCloseable {
                 mIsRecovering.set(false);
                 mDatabaseBackupAndRecovery.resetLastBackedUpGenerationNumber(volumeName);
                 updateSessionIdInDatabaseAndExternalStorage(db);
+                if (MediaStore.VOLUME_EXTERNAL_PRIMARY.equalsIgnoreCase(volumeName)) {
+                    mDatabaseBackupAndRecovery.markPublicVolumesRecovery();
+                }
             }
         }
     }
diff --git a/src/com/android/providers/media/LocalUriMatcher.java b/src/com/android/providers/media/LocalUriMatcher.java
index 0a68fe715..67eee6a9e 100644
--- a/src/com/android/providers/media/LocalUriMatcher.java
+++ b/src/com/android/providers/media/LocalUriMatcher.java
@@ -80,6 +80,7 @@ class LocalUriMatcher {
     static final int PICKER_INTERNAL_ALBUMS_ALL = 904;
     static final int PICKER_INTERNAL_ALBUMS_LOCAL = 905;
     public static final int PICKER_GET_CONTENT_ID = 906;
+    public static final int PICKER_TRANSCODED_ID = 907;
 
     /**
      * Picker V2 base URI. {@see PickerUriResolverV2}.
@@ -148,6 +149,9 @@ class LocalUriMatcher {
         // content://media/picker_get_content/<user-id>/<authority>/media/<media-id>
         mPublic.addURI(auth, "picker_get_content/#/*/media/*", PICKER_GET_CONTENT_ID);
 
+        // content://media/picker_transcoded/<user-id>/<authority>/media/<media-id>
+        mPublic.addURI(auth, "picker_transcoded/#/*/media/*", PICKER_TRANSCODED_ID);
+
         mPublic.addURI(auth, "cli", CLI);
 
         mPublic.addURI(auth, "*/images/media", IMAGES_MEDIA);
diff --git a/src/com/android/providers/media/MaliciousAppDetector.java b/src/com/android/providers/media/MaliciousAppDetector.java
new file mode 100644
index 000000000..b7f6d5726
--- /dev/null
+++ b/src/com/android/providers/media/MaliciousAppDetector.java
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.provider.MediaStore;
+import android.util.Log;
+
+import androidx.annotation.VisibleForTesting;
+
+import java.util.HashSet;
+import java.util.Set;
+
+public final class MaliciousAppDetector {
+
+    private static final String TAG = "MaliciousAppDetector";
+    private static final String MALICIOUS_APP_UID_LIST = "malicious_app_uid_list";
+    // default file creation threshold limit set to 1 million
+    private static final int FILE_CREATION_THRESHOLD_LIMIT = 1_000_000;
+    // default checking malicious behaviour on every 1000th insertion
+    private static final int FREQUENCY_OF_MALICIOUS_INSERTION_CHECK = 1000;
+
+    public static final String MALICIOUS_APP_DETECTOR_PREFS = "malicious_app_detector_prefs";
+
+    private Set<String> mMaliciousAppUidSet = new HashSet<>();
+    private final int mFileCreationThresholdLimit;
+    private final int mFrequencyOfMaliciousInsertionCheck;
+    private final SharedPreferences mMaliciousAppDetectorPrefs;
+
+    public MaliciousAppDetector(Context context) {
+        this(context, FILE_CREATION_THRESHOLD_LIMIT, FREQUENCY_OF_MALICIOUS_INSERTION_CHECK);
+    }
+
+    public MaliciousAppDetector(Context context, int fileCreationThresholdLimit,
+            int frequencyOfMaliciousInsertionCheck) {
+        mMaliciousAppDetectorPrefs = context.getSharedPreferences(MALICIOUS_APP_DETECTOR_PREFS,
+                Context.MODE_PRIVATE);
+        mMaliciousAppUidSet = mMaliciousAppDetectorPrefs.getStringSet(MALICIOUS_APP_UID_LIST,
+                new HashSet<>());
+        mFileCreationThresholdLimit = fileCreationThresholdLimit;
+        mFrequencyOfMaliciousInsertionCheck = frequencyOfMaliciousInsertionCheck;
+    }
+
+    /**
+     * Monitors file creation activity and flags potentially malicious applications
+     * The method retrieves the application's UID and queries the media provider database to count
+     * the number of files associated with the application. If the file count exceeds the limit,
+     * the application's UID is added to the shared preferences
+     *
+     * @param context the context used to access shared preferences and package manager
+     * @param helper database helper used to interact with the media provider database
+     * @param packageName package name of the application to monitor
+     */
+    public void detectFileCreationByMaliciousApp(Context context, DatabaseHelper helper,
+            String packageName) {
+        try {
+            int uid = context.getPackageManager().getPackageUid(packageName, 0);
+            helper.runWithoutTransaction((db) -> {
+                int filesCount = getFilesCountForApp(db, packageName);
+                if (isInsertionLimitExceeded(filesCount)) {
+                    addUidToSharedPreference(uid);
+                }
+                return null;
+            });
+        } catch (Exception e) {
+            Log.e(TAG,
+                    "Error while detecting malicious file creation for " + packageName, e);
+        }
+    }
+
+    /**
+     * Checks if an app with the given UID is allowed to create files
+     *
+     * @param uid the uid of the application to check
+     * @return {@code true} if the application is allowed to create files, {@code false} otherwise
+     */
+    public boolean isAppAllowedToCreateFiles(long uid) {
+        String uidString = String.valueOf(uid);
+        return !mMaliciousAppUidSet.contains(uidString);
+    }
+
+    /**
+     * Retrieves the number of files owned by a specific application in the media provider database
+     *
+     * @param db media provider database
+     * @param packageName application package name
+     * @return total number of files owned by the application
+     */
+    private int getFilesCountForApp(SQLiteDatabase db, String packageName) {
+        String selection = MediaStore.MediaColumns.OWNER_PACKAGE_NAME + " = ? AND "
+                + MediaStore.MediaColumns.VOLUME_NAME + " = ?";
+        String[] selectionArgs = new String[]{packageName, MediaStore.VOLUME_EXTERNAL_PRIMARY};
+
+        try (Cursor cursor = db.query("files",
+                new String[]{MediaStore.Files.FileColumns._ID},
+                selection,
+                selectionArgs,
+                null, null, null, null)) {
+            return cursor.getCount();
+        }
+    }
+
+    /**
+     * Checks if the number of files created by an application exceeds the defined threshold
+     *
+     * @param filesCount number of files to check against
+     * @return {@code true} if the file count exceeds the threshold limit, {@code false} otherwise
+     */
+    private boolean isInsertionLimitExceeded(int filesCount) {
+        return mFileCreationThresholdLimit <= filesCount;
+    }
+
+    /**
+     * Adds the UID of an application to the shared preferences
+     *
+     * @param uid the uid of the application to add to the set
+     */
+    private void addUidToSharedPreference(int uid) {
+        SharedPreferences.Editor editor = mMaliciousAppDetectorPrefs.edit();
+        Set<String> uidSet = mMaliciousAppDetectorPrefs.getStringSet(MALICIOUS_APP_UID_LIST,
+                new HashSet<>());
+        if (uidSet == null) {
+            mMaliciousAppUidSet = new HashSet<>();
+        } else {
+            mMaliciousAppUidSet = new HashSet<>(uidSet);
+        }
+        mMaliciousAppUidSet.add(String.valueOf(uid));
+        editor.putStringSet(MALICIOUS_APP_UID_LIST, mMaliciousAppUidSet);
+        editor.apply();
+    }
+
+    /**
+     * Clears the shared preferences containing the set of malicious app UIDs
+     */
+    @VisibleForTesting
+    public void clearSharedPref() {
+        SharedPreferences.Editor editor = mMaliciousAppDetectorPrefs.edit();
+        mMaliciousAppUidSet = new HashSet<>();
+        editor.putStringSet(MALICIOUS_APP_UID_LIST, new HashSet<>());
+        editor.apply();
+    }
+
+    public int getFrequencyOfMaliciousInsertionCheck() {
+        return mFrequencyOfMaliciousInsertionCheck;
+    }
+
+    public int getFileCreationThresholdLimit() {
+        return mFileCreationThresholdLimit;
+    }
+}
diff --git a/src/com/android/providers/media/MediaGrants.java b/src/com/android/providers/media/MediaGrants.java
index 6235fb501..6f30d88ec 100644
--- a/src/com/android/providers/media/MediaGrants.java
+++ b/src/com/android/providers/media/MediaGrants.java
@@ -181,11 +181,9 @@ public class MediaGrants {
                             PACKAGE_USER_ID_COLUMN + " = " + packageUserId);
                     int countOfGrantsDeleted = sqbForGrantsCleanUp.delete(db, null, null);
 
-                    Log.d(
-                            TAG,
-                            String.format(
-                                    "Successfully added %s media_grants for %s.",
-                                    uris.size(), packageName));
+                    Log.d(TAG, String.format("Successfully added %s media_grants for "
+                                    + "package %s and packageUserId %d.",
+                                    uris.size(), packageName, packageUserId));
                     Log.d(TAG, "Grants clean up : " + countOfGrantsDeleted + " deleted");
 
                     return null;
diff --git a/src/com/android/providers/media/MediaIndexingDatabaseOperations.java b/src/com/android/providers/media/MediaIndexingDatabaseOperations.java
new file mode 100644
index 000000000..576c5316e
--- /dev/null
+++ b/src/com/android/providers/media/MediaIndexingDatabaseOperations.java
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media;
+
+import android.content.ContentProviderClient;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteException;
+import android.provider.MediaStore;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.VisibleForTesting;
+
+import com.android.providers.media.search.SearchUtilConstants;
+import com.android.providers.media.search.exceptions.SqliteCheckedException;
+
+import java.util.List;
+import java.util.Objects;
+import java.util.Optional;
+
+/**
+ * Provides all the database functionality for indexing media metadata
+ */
+public class MediaIndexingDatabaseOperations {
+
+    private final SearchUtilConstants mSearchUtilConstants;
+
+    public MediaIndexingDatabaseOperations() {
+        mSearchUtilConstants = new SearchUtilConstants();
+    }
+
+    /**
+     * Queries the specified table in the external database for the given selection and
+     * selection arguments.
+     */
+    @VisibleForTesting
+    Cursor queryExternalDatabaseTable(
+            @NonNull DatabaseHelper databaseHelper,
+            String tableName,
+            String[] columns,
+            String selection,
+            String[] selectionArgs,
+            String limit,
+            String orderBy
+    ) throws SqliteCheckedException {
+        Objects.requireNonNull(databaseHelper, "DatabaseHelper object found to be null."
+                + "Cannot query for items from external database");
+        try {
+            return databaseHelper.runWithoutTransaction(database -> {
+                return database.query(tableName, columns, selection,
+                        selectionArgs, /* groupBy */ null, /* having */ null, /* orderBy */ orderBy,
+                        /* limit */ limit
+                );
+            });
+        } catch (SQLiteException exception) {
+            throw new SqliteCheckedException("Couldn't query " + tableName, exception);
+        }
+    }
+
+    /**
+     * Updates the status table columns with the given parameter values. The values to be updated
+     * can be the processing statuses or they can be the metadata about the media item itself that
+     * we hold in the status table.
+     */
+    public void updateStatusTableValues(
+            @NonNull DatabaseHelper databaseHelper, String[] mediaItemIds, ContentValues values)
+            throws SqliteCheckedException {
+        Objects.requireNonNull(databaseHelper, "DatabaseHelper object found to be null."
+                + "Cannot update status table values.");
+        try {
+            databaseHelper.runWithTransaction(database-> {
+                StringBuilder whereClauseBuilder = new StringBuilder(
+                        mSearchUtilConstants.MEDIA_ID_COLUMN + " in (");
+                for (int i = 0; i < mediaItemIds.length; i++) {
+                    whereClauseBuilder.append("?");
+                    if (i < mediaItemIds.length - 1) {
+                        whereClauseBuilder.append(", ");
+                    }
+                }
+                whereClauseBuilder.append(")");
+                return database.update(
+                        mSearchUtilConstants.MEDIA_STATUS_TABLE, values,
+                        whereClauseBuilder.toString(), mediaItemIds);
+            });
+        } catch (SQLiteException exception) {
+            throw new SqliteCheckedException(
+                    "Couldn't update status table values ", exception);
+        }
+    }
+
+    /**
+     * Inserts the provided values into the status table. The inserted values are the metadata
+     * values of the media items such as the name, mime_type and item size to name a few.
+     */
+    public void insertIntoMediaStatusTable(
+            @NonNull DatabaseHelper databaseHelper, List<ContentValues> insertValuesList)
+            throws SqliteCheckedException {
+        Objects.requireNonNull(databaseHelper, "DatabaseHelper object found to be null."
+                + "Cannot insert into media status table.");
+        Objects.requireNonNull(insertValuesList, "insertValuesList found to be null."
+                + "Cannot insert into media status table.");
+        try {
+            databaseHelper.runWithTransaction(database -> {
+                insertValuesList.forEach(insertValues ->
+                        database.insert(
+                                mSearchUtilConstants.MEDIA_STATUS_TABLE,
+                                /* nullColumnHack */ null,
+                                insertValues));
+                return true;
+            });
+        } catch (SQLiteException exception) {
+            throw new SqliteCheckedException(
+                    "Couldn't insert into the status table ", exception);
+        }
+    }
+
+    /**
+     * Deletes the row corresponding to the given media item id from the status table
+     */
+    public void deleteMediaItemFromMediaStatusTable(
+            @NonNull DatabaseHelper databaseHelper, String mediaItemId)
+            throws SqliteCheckedException {
+        Objects.requireNonNull(databaseHelper, "DatabaseHelper object found to be null."
+                + "Cannot delete media item from status table.");
+        try {
+            databaseHelper.runWithTransaction(database -> {
+                String deleteWhereClause = mSearchUtilConstants.MEDIA_ID_COLUMN + " = ?";
+                String[] deleteArguments = new String[] { mediaItemId };
+                return database.delete(
+                        mSearchUtilConstants.MEDIA_STATUS_TABLE,
+                        deleteWhereClause, deleteArguments);
+            });
+        } catch (SQLiteException exception) {
+            throw new SqliteCheckedException("Couldn't delete media item with id "
+                    + mediaItemId + " from the status table", exception);
+        }
+    }
+
+    /**
+     * Returns a DatabaseHelper object reference held by the MediaProvider. This will get called
+     * only once per search worker instance. Hence, there is no need to keep a reference of the
+     * same.
+     */
+    public DatabaseHelper getDatabaseHelper(Context context) {
+        ContentResolver contentResolver = context.getContentResolver();
+        try (ContentProviderClient client =
+                     contentResolver.acquireContentProviderClient(MediaStore.AUTHORITY)) {
+            MediaProvider mediaProvider = (MediaProvider) client.getLocalContentProvider();
+            Optional<DatabaseHelper> databaseHelper =
+                    mediaProvider.getDatabaseHelper(DatabaseHelper.EXTERNAL_DATABASE_NAME);
+            if (databaseHelper.isPresent()) {
+                return databaseHelper.get();
+            } else {
+                throw new RuntimeException("Unable to retrieve MediaProvider database helper");
+            }
+        } catch (Exception exception) {
+            throw new IllegalStateException("Unable to acquire reference to MediaProvider due to "
+                    + exception);
+        }
+    }
+}
diff --git a/src/com/android/providers/media/MediaProvider.java b/src/com/android/providers/media/MediaProvider.java
index 5f5a432b5..be59d3d1d 100644
--- a/src/com/android/providers/media/MediaProvider.java
+++ b/src/com/android/providers/media/MediaProvider.java
@@ -47,6 +47,8 @@ import static android.provider.MediaStore.MATCH_INCLUDE;
 import static android.provider.MediaStore.MATCH_ONLY;
 import static android.provider.MediaStore.MEDIA_IGNORE_FILENAME;
 import static android.provider.MediaStore.MY_UID;
+import static android.provider.MediaStore.Images.ImageColumns.LATITUDE;
+import static android.provider.MediaStore.Images.ImageColumns.LONGITUDE;
 import static android.provider.MediaStore.MediaColumns.OEM_METADATA;
 import static android.provider.MediaStore.MediaColumns.OWNER_PACKAGE_NAME;
 import static android.provider.MediaStore.PER_USER_RANGE;
@@ -122,6 +124,7 @@ import static com.android.providers.media.LocalUriMatcher.MEDIA_SCANNER;
 import static com.android.providers.media.LocalUriMatcher.PICKER_GET_CONTENT_ID;
 import static com.android.providers.media.LocalUriMatcher.PICKER_ID;
 import static com.android.providers.media.LocalUriMatcher.PICKER_INTERNAL_V2;
+import static com.android.providers.media.LocalUriMatcher.PICKER_TRANSCODED_ID;
 import static com.android.providers.media.LocalUriMatcher.VERSION;
 import static com.android.providers.media.LocalUriMatcher.VIDEO_MEDIA;
 import static com.android.providers.media.LocalUriMatcher.VIDEO_MEDIA_ID;
@@ -132,7 +135,9 @@ import static com.android.providers.media.LocalUriMatcher.VOLUMES;
 import static com.android.providers.media.LocalUriMatcher.VOLUMES_ID;
 import static com.android.providers.media.PickerUriResolver.PICKER_GET_CONTENT_SEGMENT;
 import static com.android.providers.media.PickerUriResolver.PICKER_SEGMENT;
+import static com.android.providers.media.PickerUriResolver.PICKER_TRANSCODED_SEGMENT;
 import static com.android.providers.media.PickerUriResolver.getMediaUri;
+import static com.android.providers.media.flags.Flags.indexMediaLatitudeLongitude;
 import static com.android.providers.media.flags.Flags.versionLockdown;
 import static com.android.providers.media.flags.Flags.enableBackupAndRestore;
 import static com.android.providers.media.photopicker.data.ItemsProvider.EXTRA_MIME_TYPE_SELECTION;
@@ -190,6 +195,7 @@ import android.app.RemoteAction;
 import android.app.compat.CompatChanges;
 import android.compat.annotation.ChangeId;
 import android.compat.annotation.EnabledAfter;
+import android.compat.annotation.EnabledSince;
 import android.content.BroadcastReceiver;
 import android.content.ClipData;
 import android.content.ClipDescription;
@@ -260,7 +266,6 @@ import android.provider.MediaStore.Downloads;
 import android.provider.MediaStore.Files;
 import android.provider.MediaStore.Files.FileColumns;
 import android.provider.MediaStore.Images;
-import android.provider.MediaStore.Images.ImageColumns;
 import android.provider.MediaStore.MediaColumns;
 import android.provider.MediaStore.Video;
 import android.provider.OpenAssetFileRequest;
@@ -530,6 +535,13 @@ public class MediaProvider extends ContentProvider {
      */
     private static final String META_DATA_PREFERENCE_SUMMARY = "com.android.settings.summary";
 
+    /**
+     * Updates the MediaStore versioning schema and format to reduce identifying properties.
+     */
+    @ChangeId
+    @EnabledSince(targetSdkVersion = Build.VERSION_CODES.BAKLAVA)
+    static final long LOCKDOWN_MEDIASTORE_VERSION = 343977174L;
+
     @GuardedBy("mPendingOpenInfo")
     private final Map<Integer, PendingOpenInfo> mPendingOpenInfo = new ArrayMap<>();
 
@@ -590,7 +602,10 @@ public class MediaProvider extends ContentProvider {
      * @param bytes number of bytes which need to be freed
      */
     public void freeCache(long bytes) {
-        mTranscodeHelper.freeCache(bytes);
+        bytes -= mPhotoPickerTranscodeHelper.freeCache(bytes);
+        if (bytes > 0) {
+            mTranscodeHelper.freeCache(bytes);
+        }
     }
 
     public void onAnrDelayStarted(@NonNull String packageName, int uid, int tid, int reason) {
@@ -611,6 +626,7 @@ public class MediaProvider extends ContentProvider {
     private int mExternalStorageAuthorityAppId;
     private int mDownloadsAuthorityAppId;
     private Size mThumbSize;
+    private MaliciousAppDetector mMaliciousAppDetector;
 
     /**
      * Map from UID to cached {@link LocalCallingIdentity}. Values are only
@@ -1053,6 +1069,20 @@ public class MediaProvider extends ContentProvider {
                 }
 
                 mDatabaseBackupAndRecovery.backupVolumeDbData(helper, insertedRow);
+
+
+                // check for potentially malicious file creation activity
+                // to prevent excessive file creation that could exhaust system inodes,
+                // this check periodically monitors the number of files created by an app.
+                // if an app exceeds a defined threshold, it is flagged as potentially malicious
+                if (shouldCheckForMaliciousActivity()
+                        && insertedRow.getVolumeName().equals(MediaStore.VOLUME_EXTERNAL_PRIMARY)
+                        && insertedRow.getId()
+                        % mMaliciousAppDetector.getFrequencyOfMaliciousInsertionCheck()
+                        == 0) {
+                    mMaliciousAppDetector.detectFileCreationByMaliciousApp(getContext(), helper,
+                            insertedRow.getOwnerPackageName());
+                }
             });
         }
 
@@ -1117,8 +1147,11 @@ public class MediaProvider extends ContentProvider {
                     deletedRow.getId());
             acceptWithExpansion(helper::notifyDelete, deletedRow.getVolumeName(),
                     deletedRow.getId(), deletedRow.getMediaType(), deletedRow.isDownload());
+
             // Remove cached transcoded file if any
             mTranscodeHelper.deleteCachedTranscodeFile(deletedRow.getId());
+            mPhotoPickerTranscodeHelper.deleteCachedTranscodedFile(
+                    PickerSyncController.LOCAL_PICKER_PROVIDER_AUTHORITY, deletedRow.getId());
 
             helper.postBackground(() -> {
                 // Item no longer exists, so revoke all access to it
@@ -1412,6 +1445,7 @@ public class MediaProvider extends ContentProvider {
                 mConfigStore, pickerSyncLockManager);
         mPickerDataLayer = PickerDataLayer.create(context, mPickerDbFacade, mPickerSyncController,
                 mConfigStore);
+        mPhotoPickerTranscodeHelper = new PhotoPickerTranscodeHelper();
         mPickerUriResolver = new PickerUriResolver(context, mPickerDbFacade, mProjectionHelper,
                 mUriMatcher);
         mAsyncPickerFileOpener = new AsyncPickerFileOpener(this, mPickerUriResolver);
@@ -1524,6 +1558,7 @@ public class MediaProvider extends ContentProvider {
                 BackgroundThread.getExecutor(), this::storageNativeBootPropertyChangeListener);
 
         PulledMetrics.initialize(context);
+        mMaliciousAppDetector = createMaliciousAppDetector();
         return true;
     }
 
@@ -1719,6 +1754,9 @@ public class MediaProvider extends ContentProvider {
 
         final long itemCount = mExternalDatabase.runWithTransaction(DatabaseHelper::getItemCount);
 
+        // Clean picker transcoded media cache.
+        mPhotoPickerTranscodeHelper.cleanAllTranscodedFiles(signal);
+
         // Cleaning media files for users that have been removed
         cleanMediaFilesForRemovedUser(signal);
 
@@ -1838,6 +1876,7 @@ public class MediaProvider extends ContentProvider {
                 final int num = db.delete("files", FileColumns.VOLUME_NAME + "=?",
                         new String[] { staleVolumeName });
                 Log.d(TAG, "Forgot " + num + " stale items from " + staleVolumeName);
+                mDatabaseBackupAndRecovery.deleteBackupForVolume(staleVolumeName);
             }
             return null;
         });
@@ -2491,14 +2530,16 @@ public class MediaProvider extends ContentProvider {
         boolean result = false;
         switch (segmentCount) {
             case 1:
-                // .../picker or .../picker_get_content
-                if (lastSegment.equals(PICKER_SEGMENT) || lastSegment.equals(
-                        PICKER_GET_CONTENT_SEGMENT)) {
+                // .../picker or .../picker_get_content or .../picker_transcoded
+                if (lastSegment.equals(PICKER_SEGMENT)
+                        || lastSegment.equals(PICKER_GET_CONTENT_SEGMENT)
+                        || lastSegment.equals(PICKER_TRANSCODED_SEGMENT)) {
                     result = file.exists() || file.mkdir();
                 }
                 break;
             case 2:
-                // .../picker/<user-id> or .../picker_get_content/<user-id>
+                // .../picker/<user-id> or .../picker_get_content/<user-id> or
+                // .../picker_transcoded/<user-id>
                 try {
                     Integer.parseInt(lastSegment);
                     result = file.exists() || file.mkdir();
@@ -2508,19 +2549,23 @@ public class MediaProvider extends ContentProvider {
                 }
                 break;
             case 3:
-                // .../picker/<user-id>/<authority> or .../picker_get_content/<user-id>/<authority>
+                // .../picker/<user-id>/<authority> or
+                // .../picker_get_content/<user-id>/<authority> or
+                // .../picker_transcoded/<user-id>/<authority>
                 result = preparePickerAuthorityPathSegment(file, lastSegment, uid);
                 break;
             case 4:
                 // .../picker/<user-id>/<authority>/media or
-                // .../picker_get_content/<user-id>/<authority>/media
+                // .../picker_get_content/<user-id>/<authority>/media or
+                // .../picker_transcoded/<user-id>/<authority>/media
                 if (lastSegment.equals("media")) {
                     result = file.exists() || file.mkdir();
                 }
                 break;
             case 5:
                 // .../picker/<user-id>/<authority>/media/<media-id.extension> or
-                // .../picker_get_content/<user-id>/<authority>/media/<media-id.extension>
+                // .../picker_get_content/<user-id>/<authority>/media/<media-id.extension> or
+                // .../picker_transcoded/<user-id>/<authority>/media/<media-id.extension>
                 final String pickerSegmentType = syntheticRelativePathSegments.get(0);
                 final String fileUserId = syntheticRelativePathSegments.get(1);
                 final String authority = syntheticRelativePathSegments.get(2);
@@ -2544,7 +2589,8 @@ public class MediaProvider extends ContentProvider {
         }
 
         // ['', 'storage', 'emulated', '0', 'transforms', 'synthetic',
-        // 'picker' or 'picker_get_content', '<user-id>', '<host>', 'media', '<fileName>']
+        // 'picker' or 'picker_get_content' or 'picker_transcoded',
+        // '<user-id>', '<host>', 'media', '<fileName>']
         final String pickerSegmentType = segments[6];
         final String userId = segments[7];
         final String fileName = segments[10];
@@ -2558,25 +2604,32 @@ public class MediaProvider extends ContentProvider {
         }
 
         final String mediaId = fileName.substring(0, lastDotIndex);
-        final Uri uri = getMediaUri(authority).buildUpon().appendPath(mediaId).build();
-
-        IBinder binder = getContext().getContentResolver()
-                .call(uri, METHOD_GET_ASYNC_CONTENT_PROVIDER, null, null)
-                .getBinder(EXTRA_ASYNC_CONTENT_PROVIDER);
-        if (binder == null) {
-            Log.e(TAG, "Picker file open failed. No cloud media provider found.");
-            return FileOpenResult.createError(OsConstants.ENOENT, uid);
-        }
-        IAsyncContentProvider iAsyncContentProvider = IAsyncContentProvider.Stub.asInterface(
-                binder);
-        AsyncContentProvider asyncContentProvider = new AsyncContentProvider(iAsyncContentProvider);
         final ParcelFileDescriptor pfd;
-        try {
-            pfd = asyncContentProvider.openMedia(uri, "r");
-        } catch (FileNotFoundException | ExecutionException | InterruptedException
-                | TimeoutException | RemoteException e) {
-            Log.e(TAG, "Picker file open failed. Failed to open URI: " + uri, e);
-            return FileOpenResult.createError(OsConstants.ENOENT, uid);
+        if (pickerSegmentType.equalsIgnoreCase(PICKER_TRANSCODED_SEGMENT)) {
+            try {
+                pfd = mPhotoPickerTranscodeHelper.openTranscodedFile(host, mediaId);
+            } catch (FileNotFoundException e) {
+                Log.e(TAG, "Picker transcoded file open failed. No cached transcoded file found.");
+                return FileOpenResult.createError(OsConstants.ENOENT, uid);
+            }
+        } else {
+            final Uri uri = getMediaUri(authority).buildUpon().appendPath(mediaId).build();
+            IBinder binder = getContext().getContentResolver()
+                    .call(uri, METHOD_GET_ASYNC_CONTENT_PROVIDER, null, null)
+                    .getBinder(EXTRA_ASYNC_CONTENT_PROVIDER);
+            if (binder == null) {
+                Log.e(TAG, "Picker file open failed. No cloud media provider found.");
+                return FileOpenResult.createError(OsConstants.ENOENT, uid);
+            }
+            IAsyncContentProvider iAsyncProvider = IAsyncContentProvider.Stub.asInterface(binder);
+            AsyncContentProvider asyncContentProvider = new AsyncContentProvider(iAsyncProvider);
+            try {
+                pfd = asyncContentProvider.openMedia(uri, "r");
+            } catch (FileNotFoundException | ExecutionException | InterruptedException
+                     | TimeoutException | RemoteException e) {
+                Log.e(TAG, "Picker file open failed. Failed to open URI: " + uri, e);
+                return FileOpenResult.createError(OsConstants.ENOENT, uid);
+            }
         }
 
         try (FileInputStream fis = new FileInputStream(pfd.getFileDescriptor())) {
@@ -2587,6 +2640,7 @@ public class MediaProvider extends ContentProvider {
             LocalCallingIdentity callingIdentityForOriginalUid = getCachedCallingIdentityForFuse(
                     uid);
             final boolean isRedactionNeeded = pickerSegmentType.equalsIgnoreCase(PICKER_SEGMENT)
+                    || pickerSegmentType.equalsIgnoreCase(PICKER_TRANSCODED_SEGMENT)
                     || callingIdentityForOriginalUid == null
                     || isRedactionNeededForPickerUri(callingIdentityForOriginalUid);
             Log.v(TAG, "Redaction needed for file open: " + isRedactionNeeded);
@@ -2622,9 +2676,21 @@ public class MediaProvider extends ContentProvider {
         try (Cursor cursor = mPickerUriResolver.query(uri, projection, /* callingPid */0, uid,
                 mCallingIdentity.get().getPackageName())) {
             if (cursor != null && cursor.moveToFirst()) {
-                final int sizeBytesIdx = cursor.getColumnIndex(MediaStore.PickerMediaColumns.SIZE);
+                // For picker transcoded files, get their actual size, as ths value may differ from
+                // the source file. The code is put after the query operation to make sure that
+                // the app accessing the file have required permissions.
+                if (pickerSegmentType.equalsIgnoreCase(PICKER_TRANSCODED_SEGMENT)) {
+                    long size = mPhotoPickerTranscodeHelper.getTranscodedFileSize(authority,
+                            mediaId);
+                    if (size > 0) {
+                        return createSparseFile(file, size);
+                    }
+                    return false;
+                }
 
+                final int sizeBytesIdx = cursor.getColumnIndex(MediaStore.PickerMediaColumns.SIZE);
                 if (sizeBytesIdx != -1) {
+
                     return createSparseFile(file, cursor.getLong(sizeBytesIdx));
                 }
             }
@@ -3661,6 +3727,15 @@ public class MediaProvider extends ContentProvider {
         }
     }
 
+    /**
+     * Check if enable_unicode_check flag is enabled
+     * Called from JNI in jni/MediaProviderWrapper.cpp
+     */
+    @Keep
+    public boolean isUnicodeCheckEnabledForFuse() {
+        return Flags.enableUnicodeCheck();
+    }
+
     @Override
     public int checkUriPermission(@NonNull Uri uri, int uid,
             /* @Intent.AccessUriMode */ int modeFlags) {
@@ -3936,10 +4011,21 @@ public class MediaProvider extends ContentProvider {
 
         Cursor c;
 
-        if (Flags.enableOemMetadata() && hasOemMetadataInProjection(qb, projection)
+        if (Flags.enableOemMetadata()
+                && hasColumnsToFilterInProjection(qb, projection, List.of(OEM_METADATA))
                 && !mCallingIdentity.get().checkCallingPermissionOemMetadata()) {
             // Filter oem_data column to return as NULL
-            projection = updateProjectionToFilterOemMetadata(qb, projection);
+            projection = updateProjectionToFilterColumns(qb, projection, List.of(OEM_METADATA));
+        }
+
+        // The prev deprecated latitude and longitude columns are being populated again for
+        // picker search. We prevent any read access to them if they are present in the
+        // query projection.
+        if (indexMediaLatitudeLongitude() && hasColumnsToFilterInProjection(
+                        qb, projection, List.of(LATITUDE, LONGITUDE)) && !isCallingPackageSelf()) {
+            // Filter latitude and longitude to return as NULL
+            projection = updateProjectionToFilterColumns(
+                    qb, projection,  List.of(LATITUDE, LONGITUDE));
         }
 
         if (shouldFilterOwnerPackageNameFlag()
@@ -3989,27 +4075,47 @@ public class MediaProvider extends ContentProvider {
         return c;
     }
 
-    private String[] updateProjectionToFilterOemMetadata(SQLiteQueryBuilder qb,
-            String[] projection) {
-        projection = maybeReplaceNullProjection(projection, qb);
-        if (qb.getProjectionAllowlist() == null) {
-            qb.setProjectionAllowlist(new ArrayList<>());
+    private boolean hasColumnsToFilterInProjection(
+            SQLiteQueryBuilder qb, String[] projection, List<String> columnsToFilter) {
+        boolean columnsFound = false;
+        List<String> projectionInLowerCase = new ArrayList<>();
+        if (projection != null) {
+            projectionInLowerCase = Arrays.asList(projection);
+            projectionInLowerCase.replaceAll(String::toLowerCase);
         }
-        final String[] updatedProjection = new String[projection.length];
-        for (int i = 0; i < projection.length; i++) {
-            if (!OEM_METADATA.equalsIgnoreCase(projection[i])) {
-                updatedProjection[i] = projection[i];
-            } else {
-                updatedProjection[i] = constructOemMetadataProjection();
+        for (String column: columnsToFilter) {
+            columnsFound =
+                    (!projectionInLowerCase.isEmpty() && projectionInLowerCase.contains(column))
+                    || (projection == null && qb.getProjectionMap() != null
+                    && qb.getProjectionMap().containsKey(column));
+            if (columnsFound) {
+                return columnsFound;
             }
         }
-        return updatedProjection;
+        return columnsFound;
     }
 
-    private boolean hasOemMetadataInProjection(SQLiteQueryBuilder qb, String[] projection) {
-        return (projection != null && Arrays.asList(projection).contains(OEM_METADATA))
-                || (projection == null && qb.getProjectionMap() != null
-                        && qb.getProjectionMap().containsKey(OEM_METADATA));
+    private String[] updateProjectionToFilterColumns(
+            SQLiteQueryBuilder qb, String[] projection, List<String> columnsToFilter) {
+        projection = maybeReplaceNullProjection(projection, qb);
+        List<String> projectionList = Arrays.asList(projection);
+        projectionList.replaceAll(String::toLowerCase);
+
+        for (String columnToFilter: columnsToFilter) {
+            if (projectionList.contains(columnToFilter)) {
+                int indexOfColumnToBeFiltered = projectionList.indexOf(columnToFilter);
+                projectionList.set(
+                        indexOfColumnToBeFiltered,
+                        constructNullProjectionForColumn(columnToFilter)
+                );
+            }
+        }
+        String[] updatedProjection = new String[projectionList.size()];
+        return projectionList.toArray(updatedProjection);
+    }
+
+    private String constructNullProjectionForColumn(String columnName) {
+        return "NULL AS " + columnName;
     }
 
     /**
@@ -4037,14 +4143,6 @@ public class MediaProvider extends ContentProvider {
         return newProjection.toString();
     }
 
-    private String constructOemMetadataProjection() {
-        final StringBuilder newProjection = new StringBuilder()
-                .append("NULL AS ")
-                .append(OEM_METADATA);
-
-        return newProjection.toString();
-    }
-
     private String[] getAllOwnerPackageNames(SQLiteQueryBuilder qb, DatabaseHelper helper,
             Bundle queryArgs, CancellationSignal signal) {
         final SQLiteQueryBuilder qbCopy = new SQLiteQueryBuilder(qb);
@@ -4267,6 +4365,10 @@ public class MediaProvider extends ContentProvider {
 
     @Override
     public String getType(Uri url) {
+        if (isRedactedUri(url)) {
+            return queryForTypeAsCaller(url);
+        }
+
         final int match = matchUri(url, true);
         switch (match) {
             case IMAGES_MEDIA_ID:
@@ -5455,6 +5557,13 @@ public class MediaProvider extends ContentProvider {
     @Nullable
     private Uri insertInternal(@NonNull Uri uri, @Nullable ContentValues initialValues,
             @Nullable Bundle extras) throws FallbackException {
+        if (shouldCheckForMaliciousActivity() && !mMaliciousAppDetector.isAppAllowedToCreateFiles(
+                mCallingIdentity.get().uid)) {
+            Log.w(TAG, "Cannot be created, app has created files more than threshold limit of "
+                    + mMaliciousAppDetector.getFileCreationThresholdLimit());
+            throw new UnsupportedOperationException(
+                    "Cannot be created, app has created files more than threshold limit");
+        }
         final String originalVolumeName = getVolumeName(uri);
         PulledMetrics.logVolumeAccessViaMediaProvider(getCallingUidOrSelf(), originalVolumeName);
 
@@ -5566,15 +5675,16 @@ public class MediaProvider extends ContentProvider {
 
             if (!isCallingPackageSelf()) {
                 initialValues.remove(FileColumns.IS_DOWNLOAD);
-            }
 
-            // We no longer track location metadata
-            if (initialValues.containsKey(ImageColumns.LATITUDE)) {
-                initialValues.putNull(ImageColumns.LATITUDE);
-            }
-            if (initialValues.containsKey(ImageColumns.LONGITUDE)) {
-                initialValues.putNull(ImageColumns.LONGITUDE);
+                // We no longer track location metadata
+                if (initialValues.containsKey(LATITUDE)) {
+                    initialValues.putNull(LATITUDE);
+                }
+                if (initialValues.containsKey(LONGITUDE)) {
+                    initialValues.putNull(LONGITUDE);
+                }
             }
+
             if (getCallingPackageTargetSdkVersion() <= Build.VERSION_CODES.Q) {
                 // These columns are removed in R.
                 if (initialValues.containsKey("primary_directory")) {
@@ -6362,9 +6472,63 @@ public class MediaProvider extends ContentProvider {
             appendWhereStandalone(qb, ownerPackageMatchClause);
         }
 
+        // Prevent a query from returning results if the selection clauses query on latitude and
+        // longitude. Only return results if these columns are present in the sort clause to avoid
+        // breaking any existing usage but return them in any arbitrary fashion instead of actually
+        // sorting them.
+        List<String> filterClauses = getClausesForFilteringGeolocationData(extras, type);
+        if (indexMediaLatitudeLongitude() && !isCallingPackageSelf() && !filterClauses.isEmpty()) {
+            if (filterClauses.contains(QUERY_ARG_SQL_SORT_ORDER)) {
+                String sortArgs = extras.getString(QUERY_ARG_SQL_SORT_ORDER);
+                if (sortArgs != null) {
+                    if (sortArgs.contains(LATITUDE)) {
+                        sortArgs = sortArgs.replace(LATITUDE, /* replacement */ "NULL");
+                    }
+                    if (sortArgs.contains(LONGITUDE)) {
+                        sortArgs = sortArgs.replace(LONGITUDE, /* replacement */ "NULL");
+                    }
+                    extras.putString(QUERY_ARG_SQL_SORT_ORDER, sortArgs);
+                }
+            } else {
+                final String geolocationClause = "FALSE";
+                appendWhereStandalone(qb, geolocationClause);
+            }
+        }
         return qb;
     }
 
+    private List<String> getClausesForFilteringGeolocationData(
+            Bundle queryArgs, int type) {
+        if (type == TYPE_QUERY) {
+            return getClausesForFilteringGeolocationData(queryArgs);
+        }
+        return List.of();
+    }
+
+    private List<String> getClausesForFilteringGeolocationData(Bundle queryArgs) {
+        final String selection = queryArgs.getString(QUERY_ARG_SQL_SELECTION, "")
+                .toLowerCase(Locale.ROOT);
+        final String groupBy = queryArgs.getString(QUERY_ARG_SQL_GROUP_BY, "")
+                .toLowerCase(Locale.ROOT);
+        final String sort = queryArgs.getString(QUERY_ARG_SQL_SORT_ORDER, "")
+                .toLowerCase(Locale.ROOT);
+        final String having = queryArgs.getString(QUERY_ARG_SQL_HAVING, "")
+                .toLowerCase(Locale.ROOT);
+
+        List<String> filteringClauses = new ArrayList<>();
+        if (sort.contains(LATITUDE) || sort.contains(LONGITUDE)) {
+            filteringClauses.add(QUERY_ARG_SQL_SORT_ORDER);
+        }
+        if (selection.contains(LATITUDE) || selection.contains(LONGITUDE)
+                || groupBy.contains(LATITUDE) || groupBy.contains(LONGITUDE)
+                || having.contains(LATITUDE) || having.contains(LONGITUDE)) {
+            filteringClauses.add(QUERY_ARG_SQL_SELECTION);
+            filteringClauses.add(QUERY_ARG_SQL_GROUP_BY);
+            filteringClauses.add(QUERY_ARG_SQL_HAVING);
+        }
+        return filteringClauses;
+    }
+
     private boolean shouldFilterOwnerPackageNameInSelection(Bundle queryArgs, int type) {
         return type == TYPE_QUERY && containsOwnerPackageName(queryArgs)
                 && isApplicableForOwnerPackageNameFiltering();
@@ -6916,6 +7080,9 @@ public class MediaProvider extends ContentProvider {
             case MediaStore.CREATE_DELETE_REQUEST_CALL: {
                 return getResultForCreateOperationsRequest(method, extras);
             }
+            case MediaStore.MARK_MEDIA_AS_FAVORITE: {
+                return markMediaAsFavorite(extras);
+            }
             case MediaStore.CREATE_CANCELLATION_SIGNAL_CALL: {
                 return getResultForCreateCancellationSignal();
             }
@@ -6930,6 +7097,16 @@ public class MediaProvider extends ContentProvider {
             case MediaStore.PICKER_MEDIA_INIT_CALL: {
                 return getResultForPickerMediaInit(extras);
             }
+            case MediaStore.PICKER_INTERNAL_SEARCH_MEDIA_INIT_CALL: {
+                return getResultForPickerSearchMediaInit(extras);
+            }
+            case MediaStore.PICKER_MEDIA_SETS_INIT_CALL: {
+                initMediaSets(extras);
+                return new Bundle();
+            }
+            case MediaStore.PICKER_TRANSCODE_CALL: {
+                return getResultForPickerTranscode(extras);
+            }
             case MediaStore.GET_CLOUD_PROVIDER_CALL: {
                 return getResultForGetCloudProvider();
             }
@@ -7185,7 +7362,7 @@ public class MediaProvider extends ContentProvider {
                             final HashCode uuidHashCode =
                                     Hashing.farmHashFingerprint64()
                                        .hashString(input, StandardCharsets.UTF_8);
-                            return db.getVersion() + ":" + uuidHashCode;
+                            return uuidHashCode.toString();
                         } else {
                             return db.getVersion() + ":" + dbUuid;
                         }
@@ -7195,11 +7372,10 @@ public class MediaProvider extends ContentProvider {
         return res;
     }
 
-    private boolean shouldLockdownMediaStoreVersion() {
-        return versionLockdown()
-                && mCallingIdentity.get().getTargetSdkVersion()
-                    > Build.VERSION_CODES.VANILLA_ICE_CREAM
-                && Build.VERSION.SDK_INT > Build.VERSION_CODES.VANILLA_ICE_CREAM;
+    @VisibleForTesting
+    boolean shouldLockdownMediaStoreVersion() {
+        return versionLockdown() && CompatChanges.isChangeEnabled(
+                LOCKDOWN_MEDIASTORE_VERSION, mCallingIdentity.get().uid);
     }
 
     @NotNull
@@ -7379,6 +7555,32 @@ public class MediaProvider extends ContentProvider {
         return res;
     }
 
+    private Bundle markMediaAsFavorite(Bundle extras) {
+        final ContentValues values = extras.getParcelable(MediaStore.EXTRA_CONTENT_VALUES);
+        final ClipData clipData = extras.getParcelable(MediaStore.EXTRA_CLIP_DATA);
+        final List<Uri> uris = collectUris(clipData);
+
+        if (!isCallingPackageManager()) {
+            for (Uri uri : uris) {
+                if (!AccessChecker.hasAccessToCollection(mCallingIdentity.get(),
+                        matchUri(uri, isCallingPackageAllowedHidden()), /* forWrite= */false)) {
+                    throw new UnsupportedOperationException("Uri " + uri
+                            + " does not have required permission to mark media as favorite");
+                }
+            }
+        }
+
+        final LocalCallingIdentity token = clearLocalCallingIdentity();
+        try {
+            for (Uri uri : uris) {
+                update(uri, values, null);
+            }
+        } finally {
+            restoreLocalCallingIdentity(token);
+        }
+        return null;
+    }
+
     @NotNull
     private Bundle getResultForCreateCancellationSignal() {
         final Bundle res = new Bundle();
@@ -7438,6 +7640,55 @@ public class MediaProvider extends ContentProvider {
         return null;
     }
 
+    /**
+     * Checks if the caller has the permission to handle picker search media init. If not,
+     * this method throws a security exception.
+     */
+    @NonNull
+    private Bundle getResultForPickerSearchMediaInit(@NonNull Bundle extras) {
+        Log.i(TAG, "Received search media init query for extras: " + extras);
+        if (!checkPermissionSelf(Binder.getCallingUid())
+                && !isCallerPhotoPicker()) {
+            throw new SecurityException(
+                    getSecurityExceptionMessage("Picker search media init"));
+        }
+        return PickerDataLayerV2.handleNewSearchRequest(getContext(), extras);
+    }
+
+    private void initMediaSets(@NonNull Bundle extras) {
+        Objects.requireNonNull(extras);
+        Log.i(TAG, "Extras received for media sets init: " + extras);
+        if (!checkPermissionSelf(Binder.getCallingUid()) && !isCallerPhotoPicker()) {
+            throw new SecurityException(
+                    getSecurityExceptionMessage("Picker media sets init"));
+        }
+        PickerDataLayerV2.triggerMediaSetsSync(extras, getContext());
+    }
+
+    @NotNull
+    private Bundle getResultForPickerTranscode(@NonNull Bundle extras) {
+        Log.i(TAG, "Received media transcode request for extras: " + extras);
+
+        // Check the caller.
+        if (!checkPermissionShell(Binder.getCallingUid())
+                && !checkPermissionSelf(Binder.getCallingUid())
+                && !isCallerPhotoPicker()) {
+            throw new SecurityException(getSecurityExceptionMessage("Picker media transcode"));
+        }
+
+        // Transcode the media.
+        final Uri uri = Objects.requireNonNull(extras).getParcelable(MediaStore.EXTRA_URI);
+        if (uri == null) {
+            throw new IllegalArgumentException("Extras does not contains a URI for transcoding.");
+        }
+        boolean transcodeResult = mPhotoPickerTranscodeHelper.transcode(getContext(), uri);
+
+        // Return the result.
+        final Bundle bundle = new Bundle();
+        bundle.putBoolean(MediaStore.PICKER_TRANSCODE_RESULT, transcodeResult);
+        return bundle;
+    }
+
     @NotNull
     private Bundle getResultForGetCloudProvider() {
         if (!checkPermissionShell(Binder.getCallingUid())
@@ -7665,15 +7916,22 @@ public class MediaProvider extends ContentProvider {
         mDatabaseBackupAndRecovery.backupDatabases(mInternalDatabase, mExternalDatabase, signal);
     }
 
-    public void recoverPublicVolumes() {
-        for (MediaVolume mediaVolume : mVolumeCache.getExternalVolumes()) {
-            if (mediaVolume.isPublicVolume()) {
-                try {
-                    mExternalDatabase.tryRecoverPublicVolume(mediaVolume.getName());
-                } catch (Exception e) {
-                    Log.e(TAG, "Exception while recovering public volume: "
-                            + mediaVolume.getName());
-                }
+    public void recoverPublicVolume(MediaVolume volume) {
+        if (volume.isPublicVolume()
+                && mDatabaseBackupAndRecovery.isStableUrisEnabled(volume.getName())) {
+            Log.d(TAG, "Querying external_primary to make sure it's available");
+            try (Cursor cursor = getContext().getContentResolver()
+                    .query(MediaStore.Images.Media.getContentUri(VOLUME_EXTERNAL_PRIMARY),
+                            new String[]{FileColumns._ID}, null, null)) {
+            } catch (Exception e) {
+                Log.e(TAG, "Can't restore public volume because EXTERNAL_PRIMARY is not available");
+                return;
+            }
+
+            try {
+                mExternalDatabase.tryRecoverPublicVolume(volume.getName());
+            } catch (Exception e) {
+                Log.e(TAG, "Exception in public volume recovery for " + volume.getName(), e);
             }
         }
     }
@@ -7973,8 +8231,8 @@ public class MediaProvider extends ContentProvider {
         }
 
         private File getThumbnailFile(Uri uri) throws IOException {
-            final String volumeName = resolveVolumeName(uri);
-            final File volumePath = getVolumePath(volumeName);
+            // Always save generated thumbnails to primary storage
+            final File volumePath = getVolumePath(MediaStore.VOLUME_EXTERNAL_PRIMARY);
             return FileUtils.buildPath(volumePath, directoryName,
                     DIRECTORY_THUMBNAILS, ContentUris.parseId(uri) + ".jpg");
         }
@@ -8358,12 +8616,15 @@ public class MediaProvider extends ContentProvider {
             }
 
             // We no longer track location metadata
-            if (initialValues.containsKey(ImageColumns.LATITUDE)) {
-                initialValues.putNull(ImageColumns.LATITUDE);
-            }
-            if (initialValues.containsKey(ImageColumns.LONGITUDE)) {
-                initialValues.putNull(ImageColumns.LONGITUDE);
+            if (!isCallingPackageSelf()) {
+                if (initialValues.containsKey(LATITUDE)) {
+                    initialValues.putNull(LATITUDE);
+                }
+                if (initialValues.containsKey(LONGITUDE)) {
+                    initialValues.putNull(LONGITUDE);
+                }
             }
+
             if (getCallingPackageTargetSdkVersion() <= Build.VERSION_CODES.Q) {
                 // These columns are removed in R.
                 if (initialValues.containsKey("primary_directory")) {
@@ -8459,6 +8720,11 @@ public class MediaProvider extends ContentProvider {
             final String beforeVolume = extractVolumeName(beforePath);
             final String beforeOwner = extractPathOwnerPackageName(beforePath);
 
+            if (beforeVolume != null && MediaStore.VOLUME_EXTERNAL.equals(volumeName)) {
+                // Replace "external" with the volumeName
+                uri = replaceExternalUriWithVolumeName(uri, beforeVolume);
+            }
+
             initialValues.remove(MediaColumns.DATA);
             ensureNonUniqueFileColumns(match, uri, extras, initialValues, beforePath);
 
@@ -9096,7 +9362,8 @@ public class MediaProvider extends ContentProvider {
 
     private boolean isPickerUri(Uri uri) {
         final int match = matchUri(uri, /* allowHidden */ isCallingPackageAllowedHidden());
-        return match == PICKER_ID || match == PICKER_GET_CONTENT_ID;
+        return match == PICKER_ID || match == PICKER_GET_CONTENT_ID
+                || match == PICKER_TRANSCODED_ID;
     }
 
     @Override
@@ -9609,7 +9876,10 @@ public class MediaProvider extends ContentProvider {
         }
     }
 
-    private void invalidateFuseDentry(@NonNull File file) {
+    /**
+     * Invalidate fuse dentry cache for filepath
+     */
+    public void invalidateFuseDentry(@NonNull File file) {
         invalidateFuseDentry(file.getAbsolutePath());
     }
 
@@ -9991,6 +10261,7 @@ public class MediaProvider extends ContentProvider {
                         mNonHiddenPaths.put(key, 0);
                     } else {
                         mMediaScanner.onDirectoryDirty(topNoMediaDir);
+                        invalidateFuseDentry(topNoMediaDir);
                     }
                 }
             }
@@ -11522,6 +11793,7 @@ public class MediaProvider extends ContentProvider {
     private ConfigStore mConfigStore;
     private PickerSyncController mPickerSyncController;
     private TranscodeHelper mTranscodeHelper;
+    private PhotoPickerTranscodeHelper mPhotoPickerTranscodeHelper;
     private MediaGrants mMediaGrants;
     private DatabaseBackupAndRecovery mDatabaseBackupAndRecovery;
 
@@ -11818,6 +12090,25 @@ public class MediaProvider extends ContentProvider {
         }
     }
 
+    /**
+     * Replaces "external" in the URI path with the specified volumeName.
+     * Example:
+     * Input: content://media/external/images/media/1232
+     * Output: content://media/{volumeName}/images/media/1232
+     */
+    private Uri replaceExternalUriWithVolumeName(Uri uri, String volumeName) {
+        List<String> pathSegments = uri.getPathSegments();
+        if (!pathSegments.isEmpty() && pathSegments.get(0).equalsIgnoreCase(
+                MediaStore.VOLUME_EXTERNAL)) {
+            List<String> updatedSegments = new ArrayList<>(pathSegments);
+            updatedSegments.set(0, volumeName);
+            return uri.buildUpon()
+                    .path(TextUtils.join("/", updatedSegments))
+                    .build();
+        }
+        return uri;
+    }
+
     /**
      * Called once - from {@link #onCreate()}.
      */
@@ -11851,4 +12142,18 @@ public class MediaProvider extends ContentProvider {
     protected DatabaseBackupAndRecovery createDatabaseBackupAndRecovery() {
         return new DatabaseBackupAndRecovery(mConfigStore, mVolumeCache);
     }
+
+    protected MaliciousAppDetector createMaliciousAppDetector() {
+        return new MaliciousAppDetector(getContext());
+    }
+
+    protected boolean shouldCheckForMaliciousActivity() {
+        // Check for malicious activity if not a system gallery app, not the media provider itself,
+        // and the malicious app detector flag is enabled
+        if (!SdkLevel.isAtLeastS()) {
+            return false;
+        }
+        return Flags.enableMaliciousAppDetector() && !isCallingPackageSystemGallery()
+                && !isCallingPackageSelf();
+    }
 }
diff --git a/src/com/android/providers/media/MediaService.java b/src/com/android/providers/media/MediaService.java
index 75a2016b9..1c3d8720f 100644
--- a/src/com/android/providers/media/MediaService.java
+++ b/src/com/android/providers/media/MediaService.java
@@ -46,9 +46,6 @@ public class MediaService extends JobIntentService {
     private static final String ACTION_SCAN_VOLUME
             = "com.android.providers.media.action.SCAN_VOLUME";
 
-    private static final String ACTION_RECOVER_PUBLIC_VOLUMES
-            = "com.android.providers.media.action.RECOVER_PUBLIC_VOLUMES";
-
     private static final String EXTRA_MEDIAVOLUME = "MediaVolume";
 
     private static final String EXTRA_SCAN_REASON = "scan_reason";
@@ -61,11 +58,6 @@ public class MediaService extends JobIntentService {
         enqueueWork(context, intent);
     }
 
-    public static void queuePublicVolumeRecovery(Context context) {
-        Intent intent = new Intent(ACTION_RECOVER_PUBLIC_VOLUMES);
-        enqueueWork(context, intent);
-    }
-
     public static void enqueueWork(Context context, Intent work) {
         enqueueWork(context, MediaService.class, JOB_ID, work);
     }
@@ -99,14 +91,13 @@ public class MediaService extends JobIntentService {
                 }
                 case ACTION_SCAN_VOLUME: {
                     final MediaVolume volume = intent.getParcelableExtra(EXTRA_MEDIAVOLUME);
+                    if (volume.isPublicVolume()) {
+                        recoverPublicVolumeIfNeeded(volume);
+                    }
                     int reason = intent.getIntExtra(EXTRA_SCAN_REASON, REASON_DEMAND);
                     onScanVolume(this, volume, reason);
                     break;
                 }
-                case ACTION_RECOVER_PUBLIC_VOLUMES: {
-                    onPublicVolumeRecovery();
-                    break;
-                }
                 default: {
                     Log.w(TAG, "Unknown intent " + intent);
                     break;
@@ -159,10 +150,10 @@ public class MediaService extends JobIntentService {
         }
     }
 
-    private void onPublicVolumeRecovery() {
+    private void recoverPublicVolumeIfNeeded(MediaVolume volume) {
         try (ContentProviderClient cpc = getContentResolver()
                 .acquireContentProviderClient(MediaStore.AUTHORITY)) {
-            ((MediaProvider) cpc.getLocalContentProvider()).recoverPublicVolumes();
+            ((MediaProvider) cpc.getLocalContentProvider()).recoverPublicVolume(volume);
         } catch (Exception e) {
             Log.e(TAG, "Exception while starting public volume recovery thread", e);
         }
diff --git a/src/com/android/providers/media/PhotoPickerTranscodeHelper.java b/src/com/android/providers/media/PhotoPickerTranscodeHelper.java
new file mode 100644
index 000000000..ec4b352e4
--- /dev/null
+++ b/src/com/android/providers/media/PhotoPickerTranscodeHelper.java
@@ -0,0 +1,373 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media;
+
+import static android.provider.MediaStore.MEDIA_IGNORE_FILENAME;
+
+import static androidx.media3.transformer.Composition.HDR_MODE_TONE_MAP_HDR_TO_SDR_USING_MEDIACODEC;
+import static androidx.media3.transformer.Composition.HDR_MODE_TONE_MAP_HDR_TO_SDR_USING_OPEN_GL;
+
+import static com.android.providers.media.PickerUriResolver.getUserId;
+import static com.android.providers.media.PickerUriResolver.unwrapProviderUri;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.net.Uri;
+import android.os.CancellationSignal;
+import android.os.Handler;
+import android.os.Looper;
+import android.os.ParcelFileDescriptor;
+import android.os.UserHandle;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import androidx.media3.common.MediaItem;
+import androidx.media3.common.MimeTypes;
+import androidx.media3.transformer.Composition;
+import androidx.media3.transformer.EditedMediaItem;
+import androidx.media3.transformer.EditedMediaItemSequence;
+import androidx.media3.transformer.ExportException;
+import androidx.media3.transformer.ExportResult;
+import androidx.media3.transformer.Transformer;
+
+import com.android.providers.media.util.FileUtils;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.util.Objects;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+
+/**
+ * Utility class to handle transcoding requests from PhotoPicker.
+ */
+public class PhotoPickerTranscodeHelper {
+
+    private static final String TAG = "PickerTranscodeHelper";
+
+    private static final String STORAGE_PREFIX = "/storage/emulated/";
+    private static final String DIRECTORY_TRANSCODE = ".picker_transcoded";
+    private static final int TRANSCODING_TIMEOUT_SECOND = 90;
+
+    @NonNull
+    private final File mTranscodeDirectory;
+    @NonNull
+    private final ExecutorService mExecutor = Executors.newSingleThreadExecutor();
+    @NonNull
+    private Media3Transcoder mTranscoder = new Media3Transcoder();
+
+    public PhotoPickerTranscodeHelper() {
+        this(new File(STORAGE_PREFIX + UserHandle.myUserId(), DIRECTORY_TRANSCODE));
+    }
+
+    @VisibleForTesting
+    PhotoPickerTranscodeHelper(@NonNull File transcodeDirectory) {
+        mTranscodeDirectory = transcodeDirectory;
+        if (!mTranscodeDirectory.exists()) {
+            mTranscodeDirectory.mkdir();
+        }
+    }
+
+    /**
+     * Opens the transcoded file for the given host and media ID.
+     *
+     * @param host The host of the transcoded file.
+     * @param mediaId The media ID of the transcoded file.
+     * @return The ParcelFileDescriptor of the transcoded file.
+     * @throws FileNotFoundException If the transcoded file does not exist.
+     */
+    public ParcelFileDescriptor openTranscodedFile(@NonNull String host, @NonNull String mediaId)
+            throws FileNotFoundException {
+        final String transcodedFilePath = toTranscodedFilePath(host, mediaId);
+        final File transcodedFile = new File(transcodedFilePath);
+
+        return FileUtils.openSafely(transcodedFile, ParcelFileDescriptor.MODE_READ_ONLY);
+    }
+
+    /**
+     * Gets the size of the transcoded file for the given host and media ID.
+     *
+     * @param host The host of the transcoded file.
+     * @param mediaId The media ID of the transcoded file.
+     * @return The size of the transcoded file in bytes, or -1 if the file does not exist.
+     */
+    public long getTranscodedFileSize(@NonNull String host, @NonNull String mediaId) {
+        final String transcodedFilePath = toTranscodedFilePath(host, mediaId);
+        final File transcodedFile = new File(transcodedFilePath);
+
+        if (transcodedFile.exists()) {
+            return transcodedFile.length();
+        }
+
+        return -1L;
+    }
+
+    /**
+     * Transcodes the given media URI and caches the result.
+     *
+     * @param context The current context.
+     * @param source The URI of the media to transcode.
+     * @return True if the transcoding was successful, false otherwise.
+     */
+    @SuppressLint("NewApi")
+    public boolean transcode(@NonNull Context context, @NonNull Uri source) {
+        // Check the user id.
+        if (getUserId(source) != context.getUser().getIdentifier()) {
+            throw new IllegalArgumentException(
+                    "User id is not matched, not able to handle the uri : " + source);
+        }
+
+        final String destination = toTranscodedFilePath(source);
+
+        // No need to transcode if transcoded video is already cached.
+        final File transcodedFile = new File(destination);
+        if (transcodedFile.exists()) {
+            return true;
+        }
+
+        try {
+            return mExecutor.submit(() -> {
+                int transcodingStatus = mTranscoder.transcode(context, source, destination,
+                        TRANSCODING_TIMEOUT_SECOND, true);
+                if (transcodingStatus == Media3Transcoder.TRANSCODING_EXPORT_EXCEPTION) {
+                    // Retry transcoding without using OpenGL.
+                    transcodingStatus = mTranscoder.transcode(context, source, destination,
+                            TRANSCODING_TIMEOUT_SECOND, false);
+                }
+                return transcodingStatus == Media3Transcoder.TRANSCODING_SUCCESS;
+            }).get();
+        } catch (InterruptedException e) {
+            Log.w(TAG, "Transcoding interrupted.", e);
+            mTranscoder.cancelRunningTask();
+            return false;
+        } catch (ExecutionException e) {
+            // Should not go here.
+            Log.e(TAG, "Unexpected error from Transcoder.", e);
+            return false;
+        }
+    }
+
+    /**
+     * Frees up cache space for the given number of bytes.
+     *
+     * @param bytes The number of bytes to free.
+     * @return The number of bytes freed.
+     */
+    public long freeCache(long bytes) {
+        final File[] files = mTranscodeDirectory.listFiles();
+
+        if (files == null) {
+            return 0;
+        }
+
+        long bytesFreed = 0;
+        for (File file : files) {
+            if (bytes - bytesFreed <= 0) {
+                break;
+            }
+
+            if (Objects.equals(file.getName(), MEDIA_IGNORE_FILENAME)) continue;
+
+            if (file.exists() && file.isFile()) {
+                final long size = file.length();
+                if (file.delete()) {
+                    bytesFreed += size;
+                }
+            }
+        }
+
+        return bytesFreed;
+    }
+
+    /**
+     * Cleans all transcoded files.
+     *
+     * @param signal the cancellation signal.
+     */
+    public void cleanAllTranscodedFiles(@Nullable CancellationSignal signal) {
+        final File[] files = mTranscodeDirectory.listFiles();
+
+        if (files == null) {
+            return;
+        }
+
+        for (File file : files) {
+            if (signal != null && signal.isCanceled()) {
+                Log.i(TAG, "Received a cancellation signal during cleaning cache.");
+                break;
+            }
+
+            if (Objects.equals(file.getName(), MEDIA_IGNORE_FILENAME)) continue;
+
+            if (file.exists() && file.isFile()) {
+                file.delete();
+            }
+        }
+    }
+
+    /**
+     * Deletes the cached transcoded file for the given host and media ID.
+     *
+     * @param host The host of the transcoded file to delete.
+     * @param mediaId The media ID of the transcoded file to delete.
+     * @return True if the file was deleted, false otherwise.
+     */
+    public boolean deleteCachedTranscodedFile(@NonNull String host, long mediaId) {
+        final String transcodedFilePath = toTranscodedFilePath(host, String.valueOf(mediaId));
+        return new File(transcodedFilePath).delete();
+    }
+
+    @NonNull
+    private String toTranscodedFilePath(@NonNull Uri pickerUri) {
+        // Unwrap picker uri to get host and id.
+        final Uri unwrappedSourceUri = unwrapProviderUri(pickerUri);
+        final String host = unwrappedSourceUri.getHost();
+        final String mediaId = unwrappedSourceUri.getLastPathSegment();
+
+        return toTranscodedFilePath(host, mediaId);
+    }
+
+    @NonNull
+    private String toTranscodedFilePath(@NonNull String host, @NonNull String mediaId) {
+        String transcodedId = host + "_" + mediaId;
+        return new File(mTranscodeDirectory, transcodedId).getAbsolutePath();
+    }
+
+    @VisibleForTesting
+    void setTranscoder(@NonNull Media3Transcoder transcoder) {
+        mTranscoder = transcoder;
+    }
+
+    @VisibleForTesting
+    static class Media3Transcoder {
+
+        static final int TRANSCODING_SUCCESS = 0;
+        static final int TRANSCODING_EXPORT_EXCEPTION = 1;
+        static final int TRANSCODING_TIMEOUT_EXCEPTION = 2;
+        static final int TRANSCODING_OTHER_EXCEPTION = 3;
+
+        @Nullable
+        private Transformer mTransformer = null;
+
+        int transcode(@NonNull Context context, @NonNull Uri sourceUri,
+                @NonNull String destinationPath, int timeoutSec, boolean useOpenGl) {
+            // Cancel previous unfinished task (if existed).
+            cancelRunningTask();
+
+            final CompletableFuture<Void> future = new CompletableFuture<>();
+
+            // Start transcoding.
+            final Transformer.Listener listener = createListener(destinationPath, future);
+            mTransformer = createTransformer(context, listener);
+            final Composition composition = createComposition(sourceUri, useOpenGl);
+            final Handler handler = new Handler(Looper.getMainLooper());
+            handler.post(() -> mTransformer.start(composition, destinationPath));
+            Log.d(TAG, "Transformer started, useOpenGl: " + useOpenGl);
+
+            // Wait for transcoding.
+            try {
+                future.get(timeoutSec, TimeUnit.SECONDS);
+                return TRANSCODING_SUCCESS;
+            } catch (ExecutionException e) {
+                Log.w(TAG, "Transformer execution failed.", e);
+                return TRANSCODING_EXPORT_EXCEPTION;
+            } catch (TimeoutException e) {
+                Log.w(TAG, "Transformer execution timeout.", e);
+                cancelRunningTask();
+                return TRANSCODING_TIMEOUT_EXCEPTION;
+            } catch (InterruptedException e) {
+                // Should not go here.
+                Log.e(TAG, "Unexpected error. Transformer execution interrupted.", e);
+                return TRANSCODING_OTHER_EXCEPTION;
+            } finally {
+                mTransformer = null;
+            }
+        }
+
+        void cancelRunningTask() {
+            if (mTransformer != null) {
+                final Transformer transformer = mTransformer;
+                mTransformer = null;
+
+                // Cancel transformer;
+                final Handler handler = new Handler(Looper.getMainLooper());
+                handler.post(transformer::cancel);
+                Log.d(TAG, "Transformer canceled.");
+            }
+        }
+
+        private Transformer.Listener createListener(@NonNull String destinationPath,
+                @NonNull CompletableFuture<Void> future) {
+            return new Transformer.Listener() {
+                @Override
+                public void onCompleted(@NonNull Composition composition,
+                        @NonNull ExportResult exportResult) {
+                    future.complete(null);
+
+                    Log.d(TAG, "Transformer exported file successfully.");
+                }
+
+                @Override
+                public void onError(@NonNull Composition composition,
+                        @NonNull ExportResult exportResult,
+                        @NonNull ExportException exportException) {
+                    future.completeExceptionally(exportException);
+
+                    Log.w(TAG, "Transformer failed to export file: ", exportException);
+
+                    // Cleanup.
+                    boolean isCacheDeleted = new File(destinationPath).delete();
+                    if (isCacheDeleted) {
+                        Log.d(TAG, "The destination file is deleted.");
+                    } else {
+                        Log.e(TAG, "Failed to delete the destination file.");
+                    }
+                }
+            };
+        }
+
+        private Transformer createTransformer(@NonNull Context context,
+                @NonNull Transformer.Listener transformerListener) {
+            return new Transformer.Builder(context)
+                    // Note that H.264/AVC is used here to make the logic simple and provide broad
+                    // compatibility, but at the cost of reduced quality or increased size (compared
+                    // to H.265/HEVC). If the purposes are no longer considerations, the video mime
+                    // type should not be fixed as AVC.
+                    .setVideoMimeType(MimeTypes.VIDEO_H264)
+                    .addListener(transformerListener)
+                    .build();
+        }
+
+        private Composition createComposition(@NonNull Uri sourceUri, boolean useOpenGl) {
+            final int hdrMode = useOpenGl ? HDR_MODE_TONE_MAP_HDR_TO_SDR_USING_OPEN_GL
+                    : HDR_MODE_TONE_MAP_HDR_TO_SDR_USING_MEDIACODEC;
+            final EditedMediaItem editedMediaItem = new EditedMediaItem.Builder(
+                    MediaItem.fromUri(sourceUri)).build();
+
+            return new Composition
+                    .Builder(new EditedMediaItemSequence(editedMediaItem))
+                    .setHdrMode(hdrMode)
+                    .build();
+        }
+    }
+}
diff --git a/src/com/android/providers/media/PickerUriResolver.java b/src/com/android/providers/media/PickerUriResolver.java
index aa1ebcd1b..b1fffce3f 100644
--- a/src/com/android/providers/media/PickerUriResolver.java
+++ b/src/com/android/providers/media/PickerUriResolver.java
@@ -27,6 +27,7 @@ import static com.android.providers.media.LocalUriMatcher.PICKER_INTERNAL_ALBUMS
 import static com.android.providers.media.LocalUriMatcher.PICKER_INTERNAL_ALBUMS_LOCAL;
 import static com.android.providers.media.LocalUriMatcher.PICKER_INTERNAL_MEDIA_ALL;
 import static com.android.providers.media.LocalUriMatcher.PICKER_INTERNAL_MEDIA_LOCAL;
+import static com.android.providers.media.LocalUriMatcher.PICKER_TRANSCODED_ID;
 import static com.android.providers.media.photopicker.PickerDataLayer.QUERY_CLOUD_ID_SELECTION;
 import static com.android.providers.media.photopicker.PickerDataLayer.QUERY_ID_SELECTION;
 import static com.android.providers.media.photopicker.PickerDataLayer.QUERY_LOCAL_ID_SELECTION;
@@ -82,6 +83,7 @@ public class PickerUriResolver {
 
     public static final String PICKER_GET_CONTENT_SEGMENT = "picker_get_content";
     private static final String PICKER_INTERNAL_SEGMENT = "picker_internal";
+    public static final String PICKER_TRANSCODED_SEGMENT = "picker_transcoded";
     /** A uri with prefix "content://media/picker" is considered as a picker uri */
     public static final Uri PICKER_URI = MediaStore.AUTHORITY_URI.buildUpon().
             appendPath(PICKER_SEGMENT).build();
@@ -322,6 +324,8 @@ public class PickerUriResolver {
                 return PICKER_SEGMENT;
             case PICKER_GET_CONTENT_ID:
                 return PICKER_GET_CONTENT_SEGMENT;
+            case PICKER_TRANSCODED_ID:
+                return PICKER_TRANSCODED_SEGMENT;
         }
 
         return null;
@@ -516,7 +520,11 @@ public class PickerUriResolver {
         return builder;
     }
 
-    @VisibleForTesting
+    /**
+     * Gets the user id of the picker uri.
+     *
+     * @param uri The picker URI.
+     */
     static int getUserId(Uri uri) {
         // content://media/picker/<user-id>/<media-id>/...
         return Integer.parseInt(uri.getPathSegments().get(1));
diff --git a/src/com/android/providers/media/fuse/ExternalStorageServiceImpl.java b/src/com/android/providers/media/fuse/ExternalStorageServiceImpl.java
index a28420c84..0ff6df47b 100644
--- a/src/com/android/providers/media/fuse/ExternalStorageServiceImpl.java
+++ b/src/com/android/providers/media/fuse/ExternalStorageServiceImpl.java
@@ -37,8 +37,6 @@ import com.android.providers.media.MediaProvider;
 import com.android.providers.media.MediaService;
 import com.android.providers.media.MediaVolume;
 
-import com.android.modules.utils.BackgroundThread;
-
 import java.io.File;
 import java.io.IOException;
 import java.util.HashMap;
diff --git a/src/com/android/providers/media/photopicker/CategoriesState.java b/src/com/android/providers/media/photopicker/CategoriesState.java
new file mode 100644
index 000000000..380247ee3
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/CategoriesState.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker;
+
+import android.content.Context;
+
+import com.android.modules.utils.build.SdkLevel;
+import com.android.providers.media.ConfigStore;
+import com.android.providers.media.flags.Flags;
+import com.android.providers.media.photopicker.sync.PickerSearchProviderClient;
+
+/*
+ Checks whether the CMP has implemented the categories feature or not. Exposes a function to check
+ the same.
+ */
+public class CategoriesState {
+    private final ConfigStore mConfigStore;
+
+    public CategoriesState(ConfigStore configStore) {
+        mConfigStore = configStore;
+    }
+
+    /**
+     * Checks whether or not the given provider has MediaCategories enabled
+     * @param context The app context
+     * @param authority The provider authority
+     * @return True if the provider has enabled media categories
+     */
+    public boolean areCategoriesEnabled(Context context, String authority) {
+        PickerSearchProviderClient client = PickerSearchProviderClient.create(
+                context, authority);
+
+        return SdkLevel.isAtLeastT()
+                && mConfigStore.isModernPickerEnabled()
+                && Flags.enablePhotopickerSearch()
+                && Flags.enableCloudMediaProviderCapabilities()
+                && client.fetchCapabilities().isMediaCategoriesEnabled();
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/PhotoPickerActivity.java b/src/com/android/providers/media/photopicker/PhotoPickerActivity.java
index b35393c3c..af6f30331 100644
--- a/src/com/android/providers/media/photopicker/PhotoPickerActivity.java
+++ b/src/com/android/providers/media/photopicker/PhotoPickerActivity.java
@@ -287,6 +287,11 @@ public class PhotoPickerActivity extends AppCompatActivity {
     @NonNull
     protected PickerViewModel getOrCreateViewModel() {
         PickerViewModel viewModel =  mViewModelProvider.get(PickerViewModel.class);
+
+        // init user managers.
+        final UserIdManager userIdManager = getUserIdManager();
+        viewModel.initUserManagers(userIdManager);
+
         // populate calling package UID in PickerViewModel instance.
         try {
             if (getCallingPackage() != null) {
@@ -299,6 +304,19 @@ public class PhotoPickerActivity extends AppCompatActivity {
         return viewModel;
     }
 
+    /**
+     * @return {@link UserIdManager} to be used for the {@link PickerViewModel} when calling
+     * {@link PickerViewModel#initUserManagers(UserIdManager)}.
+     *
+     * <p> This method is also needed for tests; Allowing ourselves to control UserIdManager
+     * creation helps us mock the UserIdManager for tests. </p>
+     */
+    @VisibleForTesting
+    @NonNull
+    protected UserIdManager getUserIdManager() {
+        return UserIdManager.create(getApplicationContext());
+    }
+
     @Override
     public boolean dispatchTouchEvent(MotionEvent event){
         if (event.getAction() == MotionEvent.ACTION_DOWN) {
diff --git a/src/com/android/providers/media/photopicker/PickerDataLayer.java b/src/com/android/providers/media/photopicker/PickerDataLayer.java
index 6b8f4a779..8057a34aa 100644
--- a/src/com/android/providers/media/photopicker/PickerDataLayer.java
+++ b/src/com/android/providers/media/photopicker/PickerDataLayer.java
@@ -124,8 +124,8 @@ public class PickerDataLayer {
      */
     public static PickerDataLayer create(@NonNull Context context, @NonNull PickerDbFacade dbFacade,
             @NonNull PickerSyncController syncController, @NonNull ConfigStore configStore) {
-        PickerSyncManager syncManager = new PickerSyncManager(
-                getWorkManager(context), context, configStore, /* schedulePeriodicSyncs */ true);
+        PickerSyncManager syncManager = new PickerSyncManager(getWorkManager(context), context);
+        syncManager.schedulePeriodicSync(configStore);
         return new PickerDataLayer(context, dbFacade, syncController, configStore, syncManager);
     }
 
@@ -436,7 +436,7 @@ public class PickerDataLayer {
                     + " Should sync with local provider only: "
                     + syncRequestExtras.shouldSyncLocalOnlyData());
 
-            mSyncManager.syncMediaImmediately(syncRequestExtras);
+            mSyncManager.syncMediaImmediately(syncRequestExtras, mConfigStore);
         } else {
             // Sync album media data
             Log.i(TAG, String.format("Init data request for album content of: %s"
diff --git a/src/com/android/providers/media/photopicker/PickerSyncController.java b/src/com/android/providers/media/photopicker/PickerSyncController.java
index 137a7d4cf..d90e1c1fa 100644
--- a/src/com/android/providers/media/photopicker/PickerSyncController.java
+++ b/src/com/android/providers/media/photopicker/PickerSyncController.java
@@ -164,6 +164,10 @@ public class PickerSyncController {
     private ProviderCollectionInfo mLatestLocalProviderCollectionInfo;
     @NonNull
     private ProviderCollectionInfo mLatestCloudProviderCollectionInfo;
+    @NonNull
+    private SearchState mSearchState;
+    @NonNull
+    private CategoriesState mCategoriesState;
     @Nullable
     private static PickerSyncController sInstance;
 
@@ -251,6 +255,8 @@ public class PickerSyncController {
         mDbFacade = dbFacade;
         mPickerSyncLockManager = pickerSyncLockManager;
         mLocalProvider = localProvider;
+        mSearchState = new SearchState(mConfigStore);
+        mCategoriesState = new CategoriesState(mConfigStore);
 
         // Listen to the device config, and try to enable cloud features when the config changes.
         mConfigStore.addOnChangeListener(BackgroundThread.getExecutor(), this::initCloudProvider);
@@ -839,6 +845,11 @@ public class PickerSyncController {
         }
     }
 
+    @NonNull
+    public SearchState getSearchState() {
+        return mSearchState;
+    }
+
     private void resetCloudProvider() {
         try (CloseableReentrantLock ignored = mPickerSyncLockManager
                 .lock(PickerSyncLockManager.CLOUD_PROVIDER_LOCK)) {
@@ -2072,6 +2083,93 @@ public class PickerSyncController {
         }
     }
 
+    /**
+     * Returns true when all the following conditions are true:
+     * 1. Input cloud provider is not null.
+     * 2. Input cloud provider is present in the given providers list.
+     * 3. Input cloud provider is also the current cloud provider.
+     * 4. Search feature is enabled for the given cloud provider.
+     * Otherwise returns false.
+     */
+    public boolean shouldQueryCloudMediaForSearch(
+            @NonNull Set<String> providers,
+            @Nullable String cloudProvider) {
+        try (CloseableReentrantLock ignored =
+                     mPickerSyncLockManager.tryLock(PickerSyncLockManager.CLOUD_PROVIDER_LOCK)) {
+            return cloudProvider != null
+                    && providers.contains(cloudProvider)
+                    && cloudProvider.equals(getCloudProviderWithTimeout())
+                    && getSearchState().isCloudSearchEnabled(mContext, cloudProvider);
+        } catch (UnableToAcquireLockException e) {
+            Log.e(TAG, "Could not check if cloud media should be queried", e);
+            return false;
+        }
+    }
+
+    /**
+     * Returns true when all the following conditions are true:
+     * 1. Current local provider is not null.
+     * 2. Current local provider is present in the given providers list.
+     * 3. Search feature is enabled for the current local provider.
+     * Otherwise returns false.
+     */
+    public boolean shouldQueryLocalMediaForSearch(
+            @NonNull Set<String> providers) {
+        final String localProvider = getLocalProvider();
+        return localProvider != null
+                && providers.contains(localProvider)
+                && getSearchState().isLocalSearchEnabled();
+    }
+
+    /**
+     * @param providers List of providers for the current request
+     * @return Returns whether the local sync is possible
+     * Returns true if all of the following are true:
+     *  -The retrieved local provider is not null
+     *  -The input list of providers contains the current provider
+     *  -The CMP implements categories API
+     *  Otherwise, we get false
+     */
+    public boolean shouldQueryLocalMediaSets(@NonNull Set<String> providers) {
+        Objects.requireNonNull(providers);
+        final String localProvider = getLocalProvider();
+        return localProvider != null
+                && providers.contains(localProvider)
+                && getCategoriesState().areCategoriesEnabled(mContext, localProvider);
+    }
+
+    /**
+     * @param providers Set of providers for the current request
+     * @param cloudProvider The cloudAuthority to query for
+     * @return Returns whether the local sync is possible
+     * Returns true if all of the following are true:
+     *  -The given cloud provider is not null
+     *  -The input list of providers contains the current cloud provider
+     *  -Input cloud provider is the same as the current cloud provider
+     *  -The CMP implements categories API
+     *  Otherwise, we get false
+     */
+    public boolean shouldQueryCloudMediaSets(
+            @NonNull Set<String> providers,
+            @Nullable String cloudProvider) {
+        Objects.requireNonNull(providers);
+        try (CloseableReentrantLock ignored =
+                     mPickerSyncLockManager.tryLock(PickerSyncLockManager.CLOUD_PROVIDER_LOCK)) {
+            return cloudProvider != null
+                    && providers.contains(cloudProvider)
+                    && cloudProvider.equals(getCloudProviderWithTimeout())
+                    && getCategoriesState().areCategoriesEnabled(mContext, cloudProvider);
+        } catch (UnableToAcquireLockException e) {
+            Log.e(TAG, "Could not check if cloud media sets are to be queried", e);
+            return false;
+        }
+    }
+
+    @NonNull
+    public CategoriesState getCategoriesState() {
+        return mCategoriesState;
+    }
+
     /**
      * Disable cloud queries if the new collection id received from the cloud provider in the media
      * event notification is different than the cached value.
diff --git a/src/com/android/providers/media/photopicker/SearchState.java b/src/com/android/providers/media/photopicker/SearchState.java
new file mode 100644
index 000000000..e6cbeabf3
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/SearchState.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker;
+
+import static java.util.Objects.requireNonNull;
+
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+
+import com.android.modules.utils.build.SdkLevel;
+import com.android.providers.media.ConfigStore;
+import com.android.providers.media.flags.Flags;
+import com.android.providers.media.photopicker.sync.PickerSearchProviderClient;
+
+/**
+ * Contains the logic to decide if search feature is enabled.
+ */
+public class SearchState {
+    private static final String TAG = "PickerSearchState";
+    private final ConfigStore mConfigStore;
+
+    public SearchState(@NonNull ConfigStore configStore) {
+        mConfigStore = requireNonNull(configStore);
+    }
+
+    /**
+     * Returns true if cloud search is enabled for the given cloud provider.
+     */
+    public boolean isCloudSearchEnabled(
+            @NonNull Context context,
+            @NonNull String cloudAuthority) {
+        requireNonNull(context);
+        requireNonNull(cloudAuthority);
+
+        if (!isSearchFeatureEnabled(context)) {
+            Log.d(TAG, "Search feature is disabled on the device.");
+            return false;
+        }
+
+        final PickerSearchProviderClient client =
+                PickerSearchProviderClient.create(context, cloudAuthority);
+        final boolean cloudPickerSearchState =  client.fetchCapabilities().isSearchEnabled();
+        Log.d(TAG, String.format(
+                "Current cloud media provider: %s, Is search capability available: %s",
+                cloudAuthority,
+                cloudPickerSearchState));
+
+        return cloudPickerSearchState;
+    }
+
+    /**
+     * Returns true if cloud search is enabled for the current cloud provider.
+     */
+    public boolean isCloudSearchEnabled(@NonNull Context context) {
+        final String currentCloudAuthority = PickerSyncController
+                .getInstanceOrThrow()
+                .getCloudProviderOrDefault(null);
+
+        return isCloudSearchEnabled(context, currentCloudAuthority);
+    }
+
+    public boolean isLocalSearchEnabled() {
+        // Local search is not implemented yet.
+        return false;
+    }
+
+    /**
+     * Checks if the search feature is enabled on the device.
+     */
+    private boolean isSearchFeatureEnabled(Context context) {
+        if (!SdkLevel.isAtLeastT()) {
+            Log.d(TAG, "SDK level is less than T.");
+            return false;
+        }
+
+        if (!isHardwareSupported(context)) {
+            Log.d(TAG, "Hardware is not supported.");
+            return false;
+        }
+
+        if (!mConfigStore.isModernPickerEnabled()) {
+            Log.d(TAG, "Modern picker is disabled.");
+            return false;
+        }
+
+        if (!Flags.cloudMediaProviderSearch()) {
+            Log.d(TAG, "Search APIs are disabled.");
+            return false;
+        }
+
+        if (!Flags.enableCloudMediaProviderCapabilities()) {
+            Log.d(TAG, "Capability API is disabled.");
+            return false;
+        }
+
+        if (!Flags.enablePhotopickerSearch()) {
+            Log.d(TAG, "Search feature is disabled.");
+            return false;
+        }
+
+        return true;
+    }
+
+    private boolean isHardwareSupported(@NonNull Context context) {
+        // The Search feature in Picker is disabled for Watches and IoT devices.
+        final PackageManager pm = context.getPackageManager();
+        return !pm.hasSystemFeature(PackageManager.FEATURE_EMBEDDED)
+                && !pm.hasSystemFeature(PackageManager.FEATURE_WATCH);
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/data/PickerDatabaseHelper.java b/src/com/android/providers/media/photopicker/data/PickerDatabaseHelper.java
index ddeb1de10..fb70e7135 100644
--- a/src/com/android/providers/media/photopicker/data/PickerDatabaseHelper.java
+++ b/src/com/android/providers/media/photopicker/data/PickerDatabaseHelper.java
@@ -26,6 +26,7 @@ import android.database.sqlite.SQLiteOpenHelper;
 import android.os.Trace;
 import android.util.Log;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.VisibleForTesting;
 
 import com.android.providers.media.photopicker.PickerSyncController;
@@ -46,7 +47,10 @@ public class PickerDatabaseHelper extends SQLiteOpenHelper {
     public static final int VERSION_INTRODUCING_MEDIA_GRANTS_TABLE = 12;
     @VisibleForTesting
     public static final int VERSION_INTRODUCING_DE_SELECTIONS_TABLE = 13;
-    public static final int VERSION_LATEST = VERSION_INTRODUCING_DE_SELECTIONS_TABLE;
+    public static final int VERSION_INTRODUCING_SEARCH_TABLES = 14;
+    public static final int VERSION_INTRODUCING_CATEGORY_TABLES = 15;
+    public static final int VERSION_INTRODUCING_SEARCH_SUGGESTION_TABLES = 16;
+    public static final int VERSION_LATEST = VERSION_INTRODUCING_SEARCH_SUGGESTION_TABLES;
 
     final Context mContext;
     final String mName;
@@ -94,6 +98,20 @@ public class PickerDatabaseHelper extends SQLiteOpenHelper {
             // de_selection table did not exist.
             createDeselectionTable(db);
         }
+        if (oldV < VERSION_INTRODUCING_SEARCH_TABLES) {
+            // Create picker search tables if the database does not already contain it.
+            createSearchRequestTable(db);
+            createSearchResultMediaTable(db);
+        }
+        if (oldV < VERSION_INTRODUCING_CATEGORY_TABLES) {
+            createMediaSetsTable(db);
+            createMediaInMediaSetsTable(db);
+        }
+        if (oldV < VERSION_INTRODUCING_SEARCH_SUGGESTION_TABLES) {
+            // Create picker search suggestion tables if the database does not already contain it.
+            createSearchSuggestionsTable(db);
+            createSearchHistoryTable(db);
+        }
     }
 
     @Override
@@ -173,6 +191,15 @@ public class PickerDatabaseHelper extends SQLiteOpenHelper {
                 + "UNIQUE(cloud_id, album_id))");
         createMediaGrantsTable(db);
         createDeselectionTable(db);
+
+        createSearchRequestTable(db);
+        createSearchResultMediaTable(db);
+
+        createMediaSetsTable(db);
+        createMediaInMediaSetsTable(db);
+
+        createSearchSuggestionsTable(db);
+        createSearchHistoryTable(db);
     }
 
     private static void createMediaGrantsTable(SQLiteDatabase db) {
@@ -197,6 +224,119 @@ public class PickerDatabaseHelper extends SQLiteOpenHelper {
                 + ")");
     }
 
+    /**
+     * Creates a table to cache for Search Request details and their corresponding
+     * Search Request ID.
+     * @param db Wrapper that holds SQLite database connections and exposes methods to manage it.
+     */
+    private static void createSearchRequestTable(@NonNull SQLiteDatabase db) {
+        db.execSQL("DROP TABLE IF EXISTS search_request");
+
+        // Note that SQLite treats all null values as different. So, if you apply a
+        // UNIQUE(...) constraint on some columns and if any of those columns holds a null value,
+        // the unique constraint will not be applied. This is why in the search request table,
+        // a placeholder value will be used instead of null so that the unique constraint gets
+        // applied to all search requests saved in the table.
+        db.execSQL("CREATE TABLE search_request"
+                + "(_id INTEGER PRIMARY KEY AUTOINCREMENT,"
+                + "sync_resume_key TEXT,"
+                + "mime_types TEXT NOT NULL,"
+                + "search_text TEXT NOT NULL,"
+                + "media_set_id TEXT NOT NULL,"
+                + "suggestion_type TEXT NOT NULL,"
+                + "authority TEXT NOT NULL,"
+                + "CHECK(search_text IS NOT NULL OR media_set_id IS NOT NULL),"
+                + "UNIQUE(mime_types, search_text, media_set_id, suggestion_type, authority))");
+    }
+
+    /**
+     * Creates a table to cache for Search Result media mapped with their corresponding
+     * Search Request IDs.
+     * @param db Wrapper that holds SQLite database connections and exposes methods to manage it.
+     */
+    private static void createSearchResultMediaTable(@NonNull SQLiteDatabase db) {
+        db.execSQL("DROP TABLE IF EXISTS search_result_media");
+        db.execSQL("CREATE TABLE search_result_media"
+                + "(_id INTEGER PRIMARY KEY AUTOINCREMENT,"
+                + "search_request_id INTEGER NOT NULL,"
+                + "local_id TEXT,"
+                + "cloud_id TEXT,"
+                + "CHECK(local_id IS NOT NULL OR cloud_id IS NOT NULL),"
+                + "UNIQUE(search_request_id,  local_id),"
+                + "UNIQUE(search_request_id,  cloud_id))");
+    }
+
+    /**
+     * Creates a table to cache the MediaSets and their corresponding metadata under the various
+     * categories provided by the CloudMediaProvider.
+     * @param db Database wrapper that holds SQLite database connections and exposes methods to
+     *           manage it.
+     */
+    private static void createMediaSetsTable(@NonNull SQLiteDatabase db) {
+        db.execSQL("DROP TABLE IF EXISTS media_sets");
+        db.execSQL("CREATE TABLE media_sets("
+                + "_id INTEGER PRIMARY KEY AUTOINCREMENT,"
+                + "category_id TEXT NOT NULL,"
+                + "media_set_id TEXT NOT NULL,"
+                + "display_name TEXT,"
+                + "cover_id TEXT,"
+                + "media_set_authority TEXT NOT NULL,"
+                + "mime_type_filter TEXT NOT NULL,"
+                + "media_in_media_set_sync_resume_key TEXT,"
+                + "UNIQUE(category_id, media_set_id, mime_type_filter))");
+    }
+
+
+    /**
+     * Creates a table to cache the media items in various MediaSets and their corresponding
+     * metadata.
+     * @param db Database wrapper that holds SQLite database connections and exposes methods to
+     *           manage it.
+     */
+    private static void createMediaInMediaSetsTable(@NonNull SQLiteDatabase db) {
+        db.execSQL("DROP TABLE IF EXISTS media_in_media_sets");
+        db.execSQL("CREATE TABLE media_in_media_sets("
+                + "_id INTEGER PRIMARY KEY AUTOINCREMENT,"
+                + "cloud_id TEXT,"
+                + "local_id TEXT,"
+                + "media_set_picker_id INTEGER,"
+                + "CHECK(local_id IS NOT NULL OR cloud_id IS NOT NULL))");
+    }
+
+    /**
+     * Creates a table to cache for Search Suggestions for zero-state.
+     * @param db Wrapper that holds SQLite database connections and exposes methods to manage it.
+     */
+    private static void createSearchSuggestionsTable(@NonNull SQLiteDatabase db) {
+        db.execSQL("DROP TABLE IF EXISTS search_suggestion");
+        db.execSQL("CREATE TABLE search_suggestion"
+                + "(_id INTEGER PRIMARY KEY AUTOINCREMENT,"
+                + "authority TEXT NOT NULL,"
+                + "search_text TEXT,"
+                + "media_set_id TEXT NOT NULL,"
+                + "suggestion_type TEXT NOT NULL,"
+                + "cover_media_id TEXT,"
+                + "creation_time_ms INTEGER NOT NULL,"
+                + "UNIQUE(search_text, media_set_id))");
+    }
+
+    /**
+     * Creates a table to save the Search History.
+     * @param db Wrapper that holds SQLite database connections and exposes methods to manage it.
+     */
+    private static void createSearchHistoryTable(@NonNull SQLiteDatabase db) {
+        db.execSQL("DROP TABLE IF EXISTS search_history");
+        db.execSQL("CREATE TABLE search_history"
+                + "(_id INTEGER PRIMARY KEY AUTOINCREMENT,"
+                + "authority TEXT,"
+                + "search_text TEXT,"
+                + "media_set_id TEXT,"
+                + "cover_media_id TEXT,"
+                + "creation_time_ms INTEGER NOT NULL,"
+                + "CHECK(search_text IS NOT NULL OR media_set_id IS NOT NULL),"
+                + "UNIQUE(search_text, media_set_id))");
+    }
+
     private static void createLatestIndexes(SQLiteDatabase db) {
 
         db.execSQL("CREATE INDEX local_id_index on media(local_id)");
diff --git a/src/com/android/providers/media/photopicker/sync/MediaInMediaSetsSyncWorker.java b/src/com/android/providers/media/photopicker/sync/MediaInMediaSetsSyncWorker.java
new file mode 100644
index 000000000..9cbeb7618
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/sync/MediaInMediaSetsSyncWorker.java
@@ -0,0 +1,278 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.sync;
+
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_CLOUD_ONLY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_LOCAL_ONLY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_AUTHORITY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_MEDIA_SET_PICKER_ID;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_SYNC_SOURCE;
+import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.markMediaInMediaSetSyncAsComplete;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.os.Bundle;
+import android.os.CancellationSignal;
+import android.provider.CloudMediaProviderContract;
+import android.util.Log;
+import android.util.Pair;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import androidx.work.ListenableWorker;
+import androidx.work.Worker;
+import androidx.work.WorkerParameters;
+
+import com.android.providers.media.photopicker.PickerSyncController;
+import com.android.providers.media.photopicker.util.exceptions.RequestObsoleteException;
+import com.android.providers.media.photopicker.v2.sqlite.MediaInMediaSetsDatabaseUtil;
+import com.android.providers.media.photopicker.v2.sqlite.MediaSetsDatabaseUtil;
+
+import java.util.List;
+import java.util.Objects;
+
+/**
+ * This is a {@link Worker} class responsible for syncing the media items of a media set with the
+ * correct sync source.
+ */
+public class MediaInMediaSetsSyncWorker extends Worker {
+
+    private static final String TAG = "SearchSyncWorker";
+    private static final int SYNC_PAGE_COUNT = Integer.MAX_VALUE;
+    private static final int PAGE_SIZE = 500;
+    private static final int INVALID_SYNC_SOURCE = -1;
+    @VisibleForTesting
+    public static final String SYNC_COMPLETE_RESUME_KEY = "SYNCED";
+    private final Context mContext;
+    private final CancellationSignal mCancellationSignal;
+    private final SQLiteDatabase mDatabase;
+
+    public MediaInMediaSetsSyncWorker(@NonNull Context context, @NonNull WorkerParameters params) {
+        super(context, params);
+        mContext = context;
+        mCancellationSignal = new CancellationSignal();
+        mDatabase = getDatabase();
+    }
+
+    @NonNull
+    @Override
+    public ListenableWorker.Result doWork() {
+        final int syncSource = getInputData().getInt(SYNC_WORKER_INPUT_SYNC_SOURCE,
+                /* defaultValue */ INVALID_SYNC_SOURCE);
+        String mediaSetAuthority = getInputData().getString(SYNC_WORKER_INPUT_AUTHORITY);
+        String mediaSetPickerId = getInputData().getString(SYNC_WORKER_INPUT_MEDIA_SET_PICKER_ID);
+        String mediaSetId = "";
+
+        try {
+
+            Pair<String, String[]> pair = MediaSetsDatabaseUtil
+                    .getMediaSetIdAndMimeType(mDatabase, mediaSetPickerId);
+            mediaSetId = pair.first;
+            String[] mimeTypes = pair.second;
+
+            if (getRunAttemptCount() > 0) {
+                Log.w(TAG, "MediaInMediaSets worker retry was detected, "
+                        + "ending this run in failure.");
+                return ListenableWorker.Result.failure();
+            }
+
+            Log.i(TAG, "Starting media in media sets sync from sync source " + syncSource
+                    + " with mediaSetId " + mediaSetId);
+
+            checkIfWorkerHasStopped();
+
+            checkValidityOfWorkerInputParams(
+                    mediaSetId, syncSource, mediaSetPickerId, mediaSetAuthority);
+
+            syncMediaInMediaSet(
+                    syncSource, mediaSetId, mediaSetPickerId, mediaSetAuthority, mimeTypes);
+
+            Log.i(TAG, "Completed media in media set sync for mediaSetId " + mediaSetId);
+
+            return ListenableWorker.Result.success();
+
+        } catch (RuntimeException | RequestObsoleteException e) {
+            Log.e(TAG, "Could not complete media in media set sync from sync source "
+                    + " for mediaSetId " + mediaSetId);
+            return ListenableWorker.Result.failure();
+        } finally {
+            // mark sync as complete
+            markMediaInMediaSetSyncAsComplete(syncSource, getId());
+        }
+    }
+
+    /**
+     * Fetches the media of a media set from the provider
+     * @param syncSource Indicates whether we need to sync with the local provider or cloud provider
+     * @param mediaSetId The identifying id of the media set
+     * @param mediaSetPickerId The pickerId of the media set
+     */
+    private void syncMediaInMediaSet(
+            int syncSource, @NonNull String mediaSetId,
+            @NonNull String mediaSetPickerId, @NonNull String mediaSetAuthority,
+            @Nullable String[] mimeTypes)
+            throws RequestObsoleteException, IllegalArgumentException {
+        final PickerSearchProviderClient searchClient =
+                PickerSearchProviderClient.create(mContext, mediaSetAuthority);
+
+        String resumePageToken = MediaSetsDatabaseUtil.getMediaResumeKey(
+                mDatabase, mediaSetPickerId
+        );
+
+        if (SYNC_COMPLETE_RESUME_KEY.equals(resumePageToken)) {
+            Log.i(TAG, "Sync has already been completed.");
+            return;
+        }
+
+        try {
+            for (int currentIteration = 0; currentIteration < SYNC_PAGE_COUNT; currentIteration++) {
+                checkIfWorkerHasStopped();
+                checkIfCurrentCloudProviderAuthorityHasChanged(mediaSetAuthority);
+
+                try (Cursor mediaInMediaSetsCursor = fetchMediaInMediaSetFromCmp(
+                        searchClient, mediaSetId, resumePageToken, mimeTypes)) {
+                    // Cache the media items in this media set
+                    List<ContentValues> mediaItemsToInsert =
+                            MediaInMediaSetsDatabaseUtil.getMediaContentValuesFromCursor(
+                                    mediaInMediaSetsCursor,
+                                    mediaSetPickerId,
+                                    isAuthorityLocal(mediaSetAuthority)
+                            );
+                    MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
+                            mDatabase, mediaItemsToInsert, mediaSetAuthority
+                    );
+                    resumePageToken = getResumePageToken(mediaInMediaSetsCursor.getExtras());
+
+                    if (resumePageToken.equals(SYNC_COMPLETE_RESUME_KEY)) {
+                        break;
+                    }
+                    // mark sync as complete
+                    markMediaInMediaSetSyncAsComplete(syncSource, getId());
+                }
+            }
+        } finally {
+            MediaSetsDatabaseUtil.updateMediaInMediaSetSyncResumeKey(
+                    mDatabase, mediaSetPickerId, resumePageToken
+            );
+        }
+    }
+
+    /**
+     * Makes a call to CMP to fetch the media of a media set
+     * @param pickerSearchProviderClient Helper client to fetch media
+     * @param mediaSetId Identifying id of the media set
+     * @param resumePageToken The page token to fetch media
+     * @return Cursor with the media of the corresponding mediaSetId
+     */
+    private Cursor fetchMediaInMediaSetFromCmp(
+            @NonNull PickerSearchProviderClient pickerSearchProviderClient,
+            @NonNull String mediaSetId, @Nullable String resumePageToken,
+            @Nullable String[] mimeTypes) {
+        final Cursor cursor = pickerSearchProviderClient.fetchMediasInMediaSetFromCmp(
+                mediaSetId,
+                resumePageToken,
+                PAGE_SIZE,
+                CloudMediaProviderContract.SORT_ORDER_DESC_DATE_TAKEN,
+                mimeTypes,
+                mCancellationSignal
+        );
+
+        if (cursor == null) {
+            throw new IllegalStateException("Cursor returned from provider is null.");
+        }
+
+        return cursor;
+    }
+
+    @NonNull
+    private String getResumePageToken(@Nullable Bundle extras) {
+        if (extras == null
+                || extras.getString(CloudMediaProviderContract.EXTRA_PAGE_TOKEN) == null) {
+            return SYNC_COMPLETE_RESUME_KEY;
+        }
+
+        return extras.getString(CloudMediaProviderContract.EXTRA_PAGE_TOKEN);
+    }
+
+    private void checkIfWorkerHasStopped() throws RequestObsoleteException {
+        if (isStopped()) {
+            throw new RequestObsoleteException("MediaInMediaSets worker has stopped" + getId());
+        }
+    }
+
+    private void checkIfCurrentCloudProviderAuthorityHasChanged(@NonNull String authority)
+            throws RequestObsoleteException {
+        if (isAuthorityLocal(authority)) {
+            return;
+        }
+        final String currentCloudAuthority = getCurrentCloudProviderAuthority();
+        if (!authority.equals(currentCloudAuthority)) {
+            throw new RequestObsoleteException("Cloud provider authority has changed."
+                    + " Sync will not be continued."
+                    + " Current cloud provider authority: " + currentCloudAuthority
+                    + " Cloud provider authority to sync with: " + authority);
+        }
+    }
+
+    private void checkValidityOfWorkerInputParams(
+            @NonNull String mediaSetId, int syncSource,
+            @NonNull String mediaSetPickerId, @NonNull String mediaSetAuthority) {
+        Objects.requireNonNull(mediaSetId);
+        if (mediaSetId.isEmpty()) {
+            Log.e(TAG, "Received empty mediaSetId id to fetch media set items");
+            throw new IllegalArgumentException("mediaSetId was an empty string");
+        }
+
+        Objects.requireNonNull(mediaSetPickerId);
+        if (mediaSetPickerId.isEmpty()) {
+            Log.e(TAG, "Received empty mediaSetPickerId id to fetch media set items");
+            throw new IllegalArgumentException("mediaSetPickerId was an empty string");
+        }
+
+        // SyncSource should either be cloud or local in order to fetch media set items
+        if (syncSource != SYNC_LOCAL_ONLY && syncSource != SYNC_CLOUD_ONLY) {
+            throw new IllegalArgumentException("Invalid media sets sync source " + syncSource);
+        }
+
+        Objects.requireNonNull(mediaSetAuthority);
+        if (mediaSetAuthority.isEmpty()) {
+            Log.e(TAG, "Received empty mediaSetAuthority id to fetch media set items");
+            throw new IllegalArgumentException("mediaSetPickerId was an empty string");
+        }
+    }
+
+    private boolean isAuthorityLocal(@NonNull String authority) {
+        return getLocalProviderAuthority().equals(authority);
+    }
+
+    @Nullable
+    private String getLocalProviderAuthority() {
+        return PickerSyncController.getInstanceOrThrow().getLocalProvider();
+    }
+
+    @Nullable
+    private String getCurrentCloudProviderAuthority() {
+        return PickerSyncController.getInstanceOrThrow().getCloudProvider();
+    }
+
+    private SQLiteDatabase getDatabase() {
+        return PickerSyncController.getInstanceOrThrow().getDbFacade().getDatabase();
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/sync/MediaSetsSyncWorker.java b/src/com/android/providers/media/photopicker/sync/MediaSetsSyncWorker.java
new file mode 100644
index 000000000..a662a685c
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/sync/MediaSetsSyncWorker.java
@@ -0,0 +1,213 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.sync;
+
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.EXTRA_MIME_TYPES;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_CLOUD_ONLY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_LOCAL_ONLY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_AUTHORITY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_CATEGORY_ID;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_SYNC_SOURCE;
+import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.markMediaSetsSyncAsComplete;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.os.Bundle;
+import android.os.CancellationSignal;
+import android.provider.CloudMediaProviderContract;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.work.ListenableWorker;
+import androidx.work.Worker;
+import androidx.work.WorkerParameters;
+
+import com.android.providers.media.photopicker.PickerSyncController;
+import com.android.providers.media.photopicker.util.exceptions.RequestObsoleteException;
+import com.android.providers.media.photopicker.v2.sqlite.MediaSetsDatabaseUtil;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Objects;
+
+public class MediaSetsSyncWorker extends Worker {
+
+    private final String TAG = "MediaSetsSyncWorker";
+    private final int INVALID_SYNC_SOURCE = -1;
+    private final int SYNC_PAGE_COUNT = Integer.MAX_VALUE;
+    private final String SYNC_COMPLETE_KEY = "SYNCED";
+    private final int PAGE_SIZE = 500;
+    private final Context mContext;
+    private final CancellationSignal mCancellationSignal;
+
+    public MediaSetsSyncWorker(@NonNull Context context, @NonNull WorkerParameters parameters) {
+        super(context, parameters);
+
+        mContext = context;
+        mCancellationSignal = new CancellationSignal();
+    }
+
+    @NonNull
+    @Override
+    public ListenableWorker.Result doWork() {
+        final int syncSource = getInputData().getInt(SYNC_WORKER_INPUT_SYNC_SOURCE,
+                /* defaultValue */ INVALID_SYNC_SOURCE);
+        final String categoryId = getInputData().getString(SYNC_WORKER_INPUT_CATEGORY_ID);
+        String categoryAuthority = getInputData().getString(SYNC_WORKER_INPUT_AUTHORITY);
+        final String[] mimeTypes = getInputData().getStringArray(EXTRA_MIME_TYPES);
+
+        try {
+            checkValidityOfWorkerInputParams(categoryId, syncSource, categoryAuthority);
+
+            Log.i(TAG, "Fetching media sets from sync source "
+                    + syncSource + " for " + categoryId);
+
+            // Fail if the worker has stopped
+            if (isStopped()) {
+                throw new RequestObsoleteException("Work is stopped" + getId());
+            }
+
+            syncMediaSets(syncSource, categoryId, categoryAuthority, mimeTypes);
+
+            Log.i(TAG, "Completed media sets sync from sync source" + syncSource
+                    + " for categoryId " + categoryId);
+
+            return ListenableWorker.Result.success();
+        } catch (RuntimeException | RequestObsoleteException e) {
+            Log.e(TAG, "Could not complete media sets sync from "
+                            + syncSource + " with categoryId " + categoryId + " due to " + e);
+            return ListenableWorker.Result.failure();
+        }
+    }
+
+    private void checkValidityOfWorkerInputParams(
+            String categoryId, int syncSource, String categoryAuth)
+            throws RequestObsoleteException {
+        Objects.requireNonNull(categoryId);
+        if (categoryId.isEmpty()) {
+            Log.e(TAG, "Received empty category id to fetch media set data");
+            throw new IllegalArgumentException("CategoryId was an empty string");
+        }
+
+        // SyncSource should either be cloud or local in order to fetch media sets
+        if (syncSource != SYNC_LOCAL_ONLY && syncSource != SYNC_CLOUD_ONLY) {
+            throw new IllegalArgumentException("Invalid media sets sync source " + syncSource);
+        }
+
+        Objects.requireNonNull(categoryAuth);
+        checkIfCurrentCloudProviderAuthorityHasChanged(categoryAuth);
+
+    }
+
+    private void syncMediaSets(
+            int syncSource, @NonNull String categoryId,
+            @NonNull String categoryAuthority, @Nullable String[] mimeTypes)
+            throws RequestObsoleteException, IllegalArgumentException {
+
+        List<String> mimeTypesList = mimeTypes == null || mimeTypes.length == 0 ? null
+                : Arrays.asList(mimeTypes);
+        final PickerSearchProviderClient searchClient =
+                PickerSearchProviderClient.create(mContext, categoryAuthority);
+        String nextPageToken = null;
+
+        try {
+            for (int currentIteration = 0; currentIteration < SYNC_PAGE_COUNT; currentIteration++) {
+                checkIfWorkerHasStopped();
+                checkIfCurrentCloudProviderAuthorityHasChanged(categoryAuthority);
+
+                try (Cursor mediaSetsCursor = fetchMediaSetsFromCmp(
+                        searchClient, categoryId, nextPageToken, mimeTypes, mCancellationSignal)) {
+                    // Cache the retrieved media sets
+                    int numberOfRowsInserted = MediaSetsDatabaseUtil.cacheMediaSets(
+                            getDatabase(), mediaSetsCursor, categoryId,
+                            categoryAuthority, mimeTypesList);
+                    Log.i(TAG, "Cached " + numberOfRowsInserted + " media sets");
+                    // Update the next page token
+                    nextPageToken = getNextPageToken(mediaSetsCursor.getExtras());
+                    if (nextPageToken.equals(SYNC_COMPLETE_KEY)) {
+                        break;
+                    }
+                }
+            }
+        } finally {
+            markMediaSetsSyncAsComplete(syncSource, getId());
+        }
+    }
+
+    private Cursor fetchMediaSetsFromCmp(
+            PickerSearchProviderClient client,
+            String categoryId,
+            String nextPageToken,
+            String[] mimeTypes,
+            CancellationSignal cancellationSignal) {
+        final Cursor cursor = client.fetchMediaSetsFromCmp(
+                categoryId, nextPageToken, PAGE_SIZE, mimeTypes, cancellationSignal);
+
+        if (cursor == null) {
+            throw new IllegalStateException("Cursor returned from provider is null.");
+        }
+        return cursor;
+    }
+
+    private String getNextPageToken(Bundle extras) {
+        if (extras == null
+                || extras.getString(CloudMediaProviderContract.EXTRA_PAGE_TOKEN) == null) {
+            return SYNC_COMPLETE_KEY;
+        }
+        return extras.getString(CloudMediaProviderContract.EXTRA_PAGE_TOKEN);
+    }
+
+    private void checkIfWorkerHasStopped() throws RequestObsoleteException {
+        if (isStopped()) {
+            throw new RequestObsoleteException("MediaInMediaSets worker has stopped" + getId());
+        }
+    }
+
+    private void checkIfCurrentCloudProviderAuthorityHasChanged(@NonNull String authority)
+            throws RequestObsoleteException {
+        if (isAuthorityLocal(authority)) {
+            return;
+        }
+        final String currentCloudAuthority = getCurrentCloudProviderAuthority();
+        if (!authority.equals(currentCloudAuthority)) {
+            throw new RequestObsoleteException("Cloud provider authority has changed."
+                    + " Sync will not be continued."
+                    + " Current cloud provider authority: " + currentCloudAuthority
+                    + " Cloud provider authority to sync with: " + authority);
+        }
+    }
+
+    private boolean isAuthorityLocal(@NonNull String authority) {
+        return getLocalProviderAuthority().equals(authority);
+    }
+
+    @Nullable
+    private String getLocalProviderAuthority() {
+        return PickerSyncController.getInstanceOrThrow().getLocalProvider();
+    }
+
+    @Nullable
+    private String getCurrentCloudProviderAuthority() {
+        return PickerSyncController.getInstanceOrThrow().getCloudProvider();
+    }
+
+    private SQLiteDatabase getDatabase() {
+        return PickerSyncController.getInstanceOrThrow().getDbFacade().getDatabase();
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/sync/PickerSearchProviderClient.java b/src/com/android/providers/media/photopicker/sync/PickerSearchProviderClient.java
new file mode 100644
index 000000000..a51501634
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/sync/PickerSearchProviderClient.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.sync;
+
+import static android.provider.CloudMediaProviderContract.EXTRA_PROVIDER_CAPABILITIES;
+import static android.provider.CloudMediaProviderContract.METHOD_GET_CAPABILITIES;
+
+import static java.util.Objects.requireNonNull;
+
+import android.content.Context;
+import android.content.Intent;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.CancellationSignal;
+import android.provider.CloudMediaProviderContract;
+import android.provider.CloudMediaProviderContract.SortOrder;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+/**
+ * A client class responsible for fetching search results from
+ * cloud media provider and local search provider.
+ */
+public class PickerSearchProviderClient {
+    private static final String TAG = "PickerSearchProviderClient";
+
+    @NonNull
+    private final Context mContext;
+
+    @NonNull
+    private final String mCloudProviderAuthority;
+
+    private PickerSearchProviderClient(@NonNull Context context,
+            @NonNull String cloudProviderAuthority) {
+        mContext = requireNonNull(context);
+        mCloudProviderAuthority = requireNonNull(cloudProviderAuthority);
+    }
+
+    /**
+     * Create instance of a picker search client.
+     */
+    public static PickerSearchProviderClient create(@NonNull Context context,
+            @NonNull String cloudProviderAuthority) {
+        return new PickerSearchProviderClient(context, cloudProviderAuthority);
+    }
+
+    /**
+     * Method for querying CloudMediaProvider for media search result.
+     * Note: This functions does not expect pagination args.
+     */
+    @Nullable
+    public Cursor fetchSearchResultsFromCmp(
+            @Nullable String suggestedMediaSetId,
+            @Nullable String searchText,
+            @SortOrder int sortOrder,
+            int pageSize,
+            @Nullable String resumePageToken,
+            @Nullable CancellationSignal cancellationSignal) {
+        if (suggestedMediaSetId == null && searchText == null) {
+            throw new IllegalArgumentException(
+                    "both suggestedMediaSet and searchText can not be null at once");
+        }
+        final Bundle queryArgs = new Bundle();
+        queryArgs.putString(CloudMediaProviderContract.KEY_SEARCH_TEXT, searchText);
+        queryArgs.putString(CloudMediaProviderContract.KEY_MEDIA_SET_ID, suggestedMediaSetId);
+        queryArgs.putInt(CloudMediaProviderContract.EXTRA_PAGE_SIZE, pageSize);
+        queryArgs.putString(CloudMediaProviderContract.EXTRA_PAGE_TOKEN, resumePageToken);
+        queryArgs.putInt(CloudMediaProviderContract.EXTRA_SORT_ORDER, sortOrder);
+
+        return mContext.getContentResolver().query(
+                getCloudUriFromPath(CloudMediaProviderContract.URI_PATH_SEARCH_MEDIA),
+                null, queryArgs,  cancellationSignal);
+    }
+
+    /**
+     * Method for querying CloudMediaProvider for search suggestions
+     */
+    @Nullable
+    public Cursor fetchSearchSuggestionsFromCmp(@NonNull String prefixText,
+            int limit,
+            @Nullable CancellationSignal cancellationSignal) {
+        final Bundle queryArgs = new Bundle();
+        queryArgs.putString(CloudMediaProviderContract.KEY_PREFIX_TEXT, requireNonNull(prefixText));
+        queryArgs.putInt(CloudMediaProviderContract.EXTRA_PAGE_SIZE, limit);
+        return mContext.getContentResolver().query(
+                getCloudUriFromPath(CloudMediaProviderContract.URI_PATH_SEARCH_SUGGESTION),
+                null, queryArgs,  cancellationSignal);
+    }
+
+    /**
+     * Method for querying CloudMediaProvider for MediaCategories
+     */
+    @Nullable
+    public Cursor fetchMediaCategoriesFromCmp(
+            @Nullable String parentCategoryId,
+            @Nullable Bundle queryArgs,
+            @Nullable CancellationSignal cancellationSignal) {
+        if (queryArgs == null) {
+            queryArgs = new Bundle();
+        }
+        queryArgs.putString(CloudMediaProviderContract.KEY_PARENT_CATEGORY_ID, parentCategoryId);
+        return mContext.getContentResolver().query(
+                getCloudUriFromPath(CloudMediaProviderContract.URI_PATH_MEDIA_CATEGORY),
+                null, queryArgs, cancellationSignal);
+    }
+
+    /**
+     * Method for querying CloudMediaProvider for MediaSets
+     */
+    @Nullable
+    public Cursor fetchMediaSetsFromCmp(
+            @NonNull String mediaCategoryId, @Nullable String nextPageToken, int pageSize,
+            @Nullable String[] mimeTypes, @Nullable CancellationSignal cancellationSignal) {
+        final Bundle queryArgs = new Bundle();
+        queryArgs.putString(CloudMediaProviderContract.KEY_MEDIA_CATEGORY_ID,
+                requireNonNull(mediaCategoryId));
+        queryArgs.putString(CloudMediaProviderContract.EXTRA_PAGE_TOKEN, nextPageToken);
+        queryArgs.putInt(CloudMediaProviderContract.EXTRA_PAGE_SIZE, pageSize);
+        queryArgs.putStringArray(Intent.EXTRA_MIME_TYPES, mimeTypes);
+        return mContext.getContentResolver().query(
+                getCloudUriFromPath(CloudMediaProviderContract.URI_PATH_MEDIA_SET),
+                null, queryArgs,  cancellationSignal);
+    }
+
+    /**
+     * Method for querying Medias inside a  MediaSet
+     */
+    @Nullable
+    public Cursor fetchMediasInMediaSetFromCmp(
+            @NonNull String mediaSetId,
+            @Nullable String pageToken,
+            int pageSize,
+            int sortOrder,
+            @Nullable String[] mimeTypes,
+            @Nullable CancellationSignal cancellationSignal) {
+        final Bundle queryArgs = new Bundle();
+        queryArgs.putString(CloudMediaProviderContract.KEY_MEDIA_SET_ID,
+                requireNonNull(mediaSetId));
+        queryArgs.putInt(CloudMediaProviderContract.EXTRA_PAGE_SIZE, pageSize);
+        queryArgs.putString(CloudMediaProviderContract.EXTRA_PAGE_TOKEN, pageToken);
+        queryArgs.putInt(CloudMediaProviderContract.EXTRA_SORT_ORDER, sortOrder);
+        queryArgs.putStringArray(Intent.EXTRA_MIME_TYPES, mimeTypes);
+
+        return mContext.getContentResolver().query(
+                getCloudUriFromPath(CloudMediaProviderContract.URI_PATH_MEDIA_IN_MEDIA_SET),
+                null, queryArgs,  cancellationSignal);
+    }
+
+    private Uri getCloudUriFromPath(String uriPath) {
+        return Uri.parse("content://" + mCloudProviderAuthority + "/" + uriPath);
+    }
+
+    /**
+     * Fetches the {@link android.provider.CloudMediaProviderContract.Capabilities} from the
+     * cloud media provider and returns them. In case there is an issue in fetching the
+     * capabilities, this method returns the default capabilities.
+     */
+    @NonNull
+    public CloudMediaProviderContract.Capabilities fetchCapabilities() {
+        try {
+            final Bundle response = mContext.getContentResolver().call(
+                    mCloudProviderAuthority,
+                    METHOD_GET_CAPABILITIES,
+                    /* arg */ null,
+                    /* extras */ null);
+            requireNonNull(response);
+
+            final CloudMediaProviderContract.Capabilities capabilities =
+                    response.getParcelable(EXTRA_PROVIDER_CAPABILITIES);
+            requireNonNull(capabilities);
+
+            return capabilities;
+        } catch (RuntimeException e) {
+            Log.e(TAG, "Could not fetch capabilities from " + mCloudProviderAuthority);
+
+            // Return default capabilities.
+            return new CloudMediaProviderContract.Capabilities.Builder().build();
+        }
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/sync/PickerSyncManager.java b/src/com/android/providers/media/photopicker/sync/PickerSyncManager.java
index 61d45d38b..a8f37ebb6 100644
--- a/src/com/android/providers/media/photopicker/sync/PickerSyncManager.java
+++ b/src/com/android/providers/media/photopicker/sync/PickerSyncManager.java
@@ -17,8 +17,12 @@
 package com.android.providers.media.photopicker.sync;
 
 import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.markAlbumMediaSyncAsComplete;
+import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.markMediaSetsSyncAsComplete;
+import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.markSearchResultsSyncAsComplete;
 import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.markSyncAsComplete;
 import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.trackNewAlbumMediaSyncRequests;
+import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.trackNewMediaSetsSyncRequest;
+import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.trackNewSearchResultsSyncRequests;
 import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.trackNewSyncRequests;
 
 import static java.util.Objects.requireNonNull;
@@ -43,6 +47,7 @@ import androidx.work.Worker;
 import com.android.modules.utils.BackgroundThread;
 import com.android.providers.media.ConfigStore;
 import com.android.providers.media.photopicker.data.PickerSyncRequestExtras;
+import com.android.providers.media.photopicker.v2.model.MediaSetsSyncRequestParams;
 
 import org.jetbrains.annotations.NotNull;
 
@@ -86,6 +91,10 @@ public class PickerSyncManager {
     static final String SYNC_WORKER_INPUT_SYNC_SOURCE = "INPUT_SYNC_TYPE";
     static final String SYNC_WORKER_INPUT_RESET_TYPE = "INPUT_RESET_TYPE";
     static final String SYNC_WORKER_INPUT_ALBUM_ID = "INPUT_ALBUM_ID";
+    static final String SYNC_WORKER_INPUT_SEARCH_REQUEST_ID = "INPUT_SEARCH_REQUEST_ID";
+    static final String SYNC_WORKER_INPUT_CATEGORY_ID = "INPUT_CATEGORY_ID";
+    static final String SYNC_WORKER_INPUT_MEDIA_SET_ID = "INPUT_MEDIA_SET_ID";
+    static final String SYNC_WORKER_INPUT_MEDIA_SET_PICKER_ID = "INPUT_MEDIA_SET_PICKER_ID";
     static final String SYNC_WORKER_TAG_IS_PERIODIC = "PERIODIC";
     static final long PROACTIVE_SYNC_DELAY_MS = 1500;
     private static final int SYNC_MEDIA_PERIODIC_WORK_INTERVAL = 4; // Time unit is hours.
@@ -97,6 +106,10 @@ public class PickerSyncManager {
     public static final String IMMEDIATE_LOCAL_SYNC_WORK_NAME;
     private static final String IMMEDIATE_CLOUD_SYNC_WORK_NAME;
     public static final String IMMEDIATE_ALBUM_SYNC_WORK_NAME;
+    public static final String IMMEDIATE_LOCAL_SEARCH_SYNC_WORK_NAME;
+    public static final String IMMEDIATE_CLOUD_SEARCH_SYNC_WORK_NAME;
+    public static final String IMMEDIATE_LOCAL_MEDIA_SETS_SYNC_WORK_NAME;
+    public static final String IMMEDIATE_CLOUD_MEDIA_SETS_SYNC_WORK_NAME;
     public static final String PERIODIC_ALBUM_RESET_WORK_NAME;
     private static final String ENDLESS_WORK_NAME;
     public static final String IMMEDIATE_GRANTS_SYNC_WORK_NAME;
@@ -107,6 +120,8 @@ public class PickerSyncManager {
         final String syncPeriodicPrefix = "SYNC_MEDIA_PERIODIC_";
         final String syncProactivePrefix = "SYNC_MEDIA_PROACTIVE_";
         final String syncImmediatePrefix = "SYNC_MEDIA_IMMEDIATE_";
+        final String syncSearchResultsImmediatePrefix = "SYNC_SEARCH_RESULTS_IMMEDIATE_";
+        final String syncMediaSetsImmediatePrefix = "SYNC_MEDIA_SETS_IMMEDIATE_";
         final String syncAllSuffix = "ALL";
         final String syncLocalSuffix = "LOCAL";
         final String syncCloudSuffix = "CLOUD";
@@ -120,41 +135,71 @@ public class PickerSyncManager {
         IMMEDIATE_LOCAL_SYNC_WORK_NAME = syncImmediatePrefix + syncLocalSuffix;
         IMMEDIATE_CLOUD_SYNC_WORK_NAME = syncImmediatePrefix + syncCloudSuffix;
         IMMEDIATE_ALBUM_SYNC_WORK_NAME = "SYNC_ALBUM_MEDIA_IMMEDIATE";
+        IMMEDIATE_LOCAL_SEARCH_SYNC_WORK_NAME = syncSearchResultsImmediatePrefix + syncLocalSuffix;
+        IMMEDIATE_CLOUD_SEARCH_SYNC_WORK_NAME = syncSearchResultsImmediatePrefix + syncCloudSuffix;
+        IMMEDIATE_LOCAL_MEDIA_SETS_SYNC_WORK_NAME = syncMediaSetsImmediatePrefix + syncLocalSuffix;
+        IMMEDIATE_CLOUD_MEDIA_SETS_SYNC_WORK_NAME = syncMediaSetsImmediatePrefix + syncCloudSuffix;
         ENDLESS_WORK_NAME = "ENDLESS_WORK";
         SHOULD_SYNC_GRANTS = "SHOULD_SYNC_GRANTS";
         EXTRA_MIME_TYPES = "mime_types";
     }
 
     private final WorkManager mWorkManager;
-    private final ConfigStore mConfigStore;
     private final Context mContext;
 
-    public PickerSyncManager(@NonNull WorkManager workManager,
-            @NonNull Context context,
-            @NonNull ConfigStore configStore,
-            boolean shouldSchedulePeriodicSyncs) {
+    public PickerSyncManager(@NonNull WorkManager workManager, @NonNull Context context) {
         mWorkManager = requireNonNull(workManager);
-        mConfigStore = requireNonNull(configStore);
         mContext = requireNonNull(context);
+    }
 
-        setUpEndlessWork();
+    /**
+     * Schedule proactive periodic media syncs.
+     *
+     * @param configStore And instance of {@link ConfigStore} that holds all config info.
+     */
+    public void schedulePeriodicSync(@NonNull ConfigStore configStore) {
+        schedulePeriodicSync(configStore, /* periodicSyncInitialDelay */10000L);
+    }
 
-        if (shouldSchedulePeriodicSyncs) {
-            setUpPeriodicWork();
-        }
+    /**
+     * Schedule proactive periodic media syncs.
+     *
+     * @param configStore And instance of {@link ConfigStore} that holds all the config info.
+     * @param periodicSyncInitialDelay Initial delay of periodic sync in milliseconds.
+     */
+    public void schedulePeriodicSync(
+            @NonNull ConfigStore configStore,
+            long periodicSyncInitialDelay) {
+        requireNonNull(configStore);
+
+        // Move to a background thread to remove from MediaProvider boot path.
+        BackgroundThread.getHandler().postDelayed(
+                () -> {
+                    try {
+                        setUpEndlessWork();
+                        setUpPeriodicWork(configStore);
+                    } catch (RuntimeException e) {
+                        Log.e(TAG, "Could not schedule workers", e);
+                    }
+                },
+                periodicSyncInitialDelay
+        );
 
         // Subscribe to device config changes so we can enable periodic workers if Cloud
         // Photopicker is enabled.
-        mConfigStore.addOnChangeListener(BackgroundThread.getExecutor(), this::setUpPeriodicWork);
+        configStore.addOnChangeListener(
+                BackgroundThread.getExecutor(),
+                () -> setUpPeriodicWork(configStore));
     }
 
     /**
      * Will register new unique {@link Worker} for periodic sync and picker database maintenance if
      * the cloud photopicker experiment is currently enabled.
      */
-    private void setUpPeriodicWork() {
+    private void setUpPeriodicWork(@NonNull ConfigStore configStore) {
+        requireNonNull(configStore);
 
-        if (mConfigStore.isCloudMediaInPhotoPickerEnabled()) {
+        if (configStore.isCloudMediaInPhotoPickerEnabled()) {
             PickerSyncNotificationHelper.createNotificationChannel(mContext);
 
             schedulePeriodicSyncs();
@@ -265,9 +310,13 @@ public class PickerSyncManager {
      *
      * @param pickerSyncRequestExtras extras used to figure out which all syncs to trigger.
      */
-    public void syncMediaImmediately(PickerSyncRequestExtras pickerSyncRequestExtras) {
+    public void syncMediaImmediately(
+            @NonNull PickerSyncRequestExtras pickerSyncRequestExtras,
+            @NonNull ConfigStore configStore) {
+        requireNonNull(pickerSyncRequestExtras);
+        requireNonNull(configStore);
 
-        if (mConfigStore.isModernPickerEnabled()) {
+        if (configStore.isModernPickerEnabled()) {
             // sync for grants is only required for the modern picker, the java picker uses
             // MediaStore to directly fetch the grants for all purposes of selection.
             syncGrantsImmediately(
@@ -397,6 +446,86 @@ public class PickerSyncManager {
         }
     }
 
+    /**
+     * Use this method for reactive search results sync which are user action triggered.
+     *
+     * @param searchRequestId Identifier for the search request.
+     * @param syncSource indicates if the sync is required with local provider or cloud provider.
+     *                   Sync source cannot be both in this case.
+     * @param authority Authority of the provider.
+     */
+    public void syncSearchResultsForProvider(
+            int searchRequestId, @SyncSource int syncSource, String authority) {
+        final Data inputData =
+                new Data(
+                        Map.of(
+                                SYNC_WORKER_INPUT_AUTHORITY, authority,
+                                SYNC_WORKER_INPUT_SYNC_SOURCE, syncSource,
+                                SYNC_WORKER_INPUT_SEARCH_REQUEST_ID, searchRequestId));
+        final OneTimeWorkRequest syncRequest =
+                buildOneTimeWorkerRequest(SearchResultsSyncWorker.class, inputData);
+
+        // Track the new sync request
+        trackNewSearchResultsSyncRequests(syncSource, syncRequest.getId());
+
+        final String workName = syncSource == SYNC_LOCAL_ONLY
+                ? IMMEDIATE_LOCAL_SEARCH_SYNC_WORK_NAME
+                : IMMEDIATE_CLOUD_SEARCH_SYNC_WORK_NAME;
+        // Enqueue local or cloud sync request
+        try {
+            final Operation enqueueOperation = mWorkManager.enqueueUniqueWork(
+                    workName,
+                    ExistingWorkPolicy.APPEND_OR_REPLACE,
+                    syncRequest);
+
+            // Check that the request has been successfully enqueued.
+            enqueueOperation.getResult().get();
+        } catch (Exception e) {
+            Log.e(TAG, "Could not enqueue expedited search results sync request", e);
+            markSearchResultsSyncAsComplete(syncSource, syncRequest.getId());
+        }
+    }
+
+    /**
+     * Creates OneTimeWork request for syncing media sets with the given provider
+     * @param requestParams The MediaSetsSyncRequestsParams object containing all input parameters
+     *                      for creating a sync request
+     * @param syncSource Indicates whether the sync is required with the local provider or
+     *                   the cloud provider.
+     */
+    public void syncMediaSetsForProvider(
+            MediaSetsSyncRequestParams requestParams, @SyncSource int syncSource) {
+        final Data inputData =
+                new Data(
+                        Map.of(
+                                SYNC_WORKER_INPUT_AUTHORITY, requestParams.getAuthority(),
+                                SYNC_WORKER_INPUT_SYNC_SOURCE, syncSource,
+                                SYNC_WORKER_INPUT_CATEGORY_ID, requestParams.getCategoryId(),
+                                EXTRA_MIME_TYPES, requestParams.getMimeTypes()));
+        final OneTimeWorkRequest syncRequest =
+                buildOneTimeWorkerRequest(MediaSetsSyncWorker.class, inputData);
+
+        // track the new request
+        trackNewMediaSetsSyncRequest(syncSource, syncRequest.getId());
+
+        final String workName = syncSource == SYNC_LOCAL_ONLY
+                ? IMMEDIATE_LOCAL_MEDIA_SETS_SYNC_WORK_NAME
+                : IMMEDIATE_CLOUD_MEDIA_SETS_SYNC_WORK_NAME;
+        // Enqueue local or cloud sync request
+        try {
+            final Operation enqueueOperation = mWorkManager.enqueueUniqueWork(
+                    workName,
+                    ExistingWorkPolicy.APPEND_OR_REPLACE,
+                    syncRequest);
+
+            // Check that the request has been successfully enqueued.
+            enqueueOperation.getResult().get();
+        } catch (Exception e) {
+            Log.e(TAG, "Could not enqueue expedited media sets sync request", e);
+            markMediaSetsSyncAsComplete(syncSource, syncRequest.getId());
+        }
+    }
+
     @NotNull
     private OneTimeWorkRequest buildOneTimeWorkerRequest(
             @NotNull Class<? extends Worker> workerClass, @NonNull Data inputData) {
diff --git a/src/com/android/providers/media/photopicker/sync/SearchResultsSyncWorker.java b/src/com/android/providers/media/photopicker/sync/SearchResultsSyncWorker.java
new file mode 100644
index 000000000..82fc29b9c
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/sync/SearchResultsSyncWorker.java
@@ -0,0 +1,350 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.sync;
+
+import static android.provider.CloudMediaProviderContract.SEARCH_SUGGESTION_ALBUM;
+
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_CLOUD_ONLY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_LOCAL_ONLY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_SEARCH_REQUEST_ID;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_SYNC_SOURCE;
+import static com.android.providers.media.photopicker.sync.SyncTrackerRegistry.markSearchResultsSyncAsComplete;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.os.Bundle;
+import android.os.CancellationSignal;
+import android.provider.CloudMediaProviderContract;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+import androidx.work.ListenableWorker;
+import androidx.work.Worker;
+import androidx.work.WorkerParameters;
+
+import com.android.providers.media.photopicker.PickerSyncController;
+import com.android.providers.media.photopicker.util.exceptions.RequestObsoleteException;
+import com.android.providers.media.photopicker.v2.model.SearchRequest;
+import com.android.providers.media.photopicker.v2.model.SearchSuggestionRequest;
+import com.android.providers.media.photopicker.v2.model.SearchTextRequest;
+import com.android.providers.media.photopicker.v2.sqlite.SearchRequestDatabaseUtil;
+import com.android.providers.media.photopicker.v2.sqlite.SearchResultsDatabaseUtil;
+
+import java.util.List;
+
+/**
+ * This is a {@link Worker} class responsible for syncing search results media with the
+ * correct sync source.
+ */
+public class SearchResultsSyncWorker extends Worker {
+    private static final String TAG = "SearchSyncWorker";
+    private static final int SYNC_PAGE_COUNT = Integer.MAX_VALUE;
+    private static final int PAGE_SIZE = 500;
+    private static final int INVALID_SYNC_SOURCE = -1;
+    private static final int INVALID_SEARCH_REQUEST_ID = -1;
+    @VisibleForTesting
+    public static final String SYNC_COMPLETE_RESUME_KEY = "SYNCED";
+    private final Context mContext;
+    private final CancellationSignal mCancellationSignal;
+
+    /**
+     * Creates an instance of the {@link Worker}.
+     *
+     * @param context the application {@link Context}
+     * @param workerParams the set of {@link WorkerParameters}
+     */
+    public SearchResultsSyncWorker(
+            @NonNull Context context,
+            @NonNull WorkerParameters workerParams) {
+        super(context, workerParams);
+
+        mContext = context;
+        mCancellationSignal = new CancellationSignal();
+    }
+
+    @NonNull
+    @Override
+    public ListenableWorker.Result doWork() {
+        final int syncSource = getInputData().getInt(SYNC_WORKER_INPUT_SYNC_SOURCE,
+                /* defaultValue */ INVALID_SYNC_SOURCE);
+        final int searchRequestId = getInputData().getInt(SYNC_WORKER_INPUT_SEARCH_REQUEST_ID,
+                /* defaultValue */ INVALID_SEARCH_REQUEST_ID);
+
+        try {
+            // Do not allow endless re-runs of this worker, if this isn't the original run,
+            // just succeed and wait until the next scheduled run.
+            if (getRunAttemptCount() > 0) {
+                Log.w(TAG, "Worker retry was detected, ending this run in failure.");
+                return ListenableWorker.Result.failure();
+            }
+
+            Log.i(TAG, String.format(
+                    "Starting search results sync from sync source: %s search request id: %s",
+                    syncSource, searchRequestId));
+
+            throwIfWorkerStopped();
+
+            final SearchRequest searchRequest = SearchRequestDatabaseUtil
+                    .getSearchRequestDetails(getDatabase(), searchRequestId);
+            validateWorkInput(syncSource, searchRequestId, searchRequest);
+
+            syncWithSource(syncSource, searchRequestId, searchRequest);
+
+            Log.i(TAG, String.format(
+                    "Completed search results sync from sync source: %s search request id: %s",
+                    syncSource, searchRequestId));
+            return ListenableWorker.Result.success();
+        } catch (RuntimeException | RequestObsoleteException e) {
+            Log.e(TAG, String.format("Could not complete search results sync sync from "
+                            + "sync source: %s search request id: %s",
+                    syncSource, searchRequestId), e);
+            return ListenableWorker.Result.failure();
+        } finally {
+            markSearchResultsSyncAsComplete(syncSource, getId());
+        }
+    }
+
+    /**
+     * Sync search results with the given sync source.
+     *
+     * @param syncSource Identifies if we need to sync with local provider or cloud provider.
+     * @param searchRequestId Identifier for the search request.
+     * @param searchRequest Details of the search request.
+     * @throws IllegalArgumentException If the search request could not be identified.
+     * @throws RequestObsoleteException If the search request has become obsolete.
+     */
+    private void syncWithSource(
+            int syncSource,
+            int searchRequestId,
+            @Nullable SearchRequest searchRequest)
+            throws IllegalArgumentException, RequestObsoleteException {
+        final String authority = getProviderAuthority(syncSource, searchRequest);
+        final PickerSearchProviderClient searchClient =
+                PickerSearchProviderClient.create(mContext, authority);
+
+        String resumePageToken = searchRequest.getResumeKey();
+
+        if (SYNC_COMPLETE_RESUME_KEY.equals(resumePageToken)) {
+            Log.i(TAG, "Sync has already been completed.");
+            return;
+        }
+
+        try {
+            for (int iteration = 0; iteration < SYNC_PAGE_COUNT; iteration++) {
+                throwIfWorkerStopped();
+                throwIfCloudProviderHasChanged(authority);
+
+                try (Cursor cursor = fetchSearchResultsFromCmp(
+                        searchClient, searchRequest, resumePageToken)) {
+
+                    List<ContentValues> contentValues =
+                            SearchResultsDatabaseUtil.extractContentValuesList(
+                                    searchRequestId, cursor, isLocal(authority));
+
+                    SearchResultsDatabaseUtil
+                            .cacheSearchResults(getDatabase(), authority, contentValues);
+
+                    resumePageToken = getResumePageToken(cursor.getExtras());
+                    if (SYNC_COMPLETE_RESUME_KEY.equals(resumePageToken)) {
+                        // Stop syncing if there are no more pages to sync.
+                        break;
+                    }
+
+                    // Mark sync as completed after getting the first page to start returning
+                    // search results to the UI.
+                    markSearchResultsSyncAsComplete(syncSource, getId());
+                }
+            }
+        } finally {
+            // Save sync resume key till the point it was performed successfully
+            searchRequest.setResumeKey(resumePageToken);
+            SearchRequestDatabaseUtil
+                    .updateResumeKey(getDatabase(), searchRequestId, resumePageToken);
+        }
+    }
+
+    /**
+     * @param extras Bundle received from the CloudMediaProvider with the search results cursor.
+     * @return Extracts the rsume page token from the extras and returns it. If it is not present
+     * in the extras, returns {@link SearchResultsSyncWorker#SYNC_COMPLETE_RESUME_KEY}
+     */
+    @NonNull
+    private String getResumePageToken(@Nullable Bundle extras) {
+        if (extras == null
+                || extras.getString(CloudMediaProviderContract.EXTRA_PAGE_TOKEN) == null) {
+            return SYNC_COMPLETE_RESUME_KEY;
+        }
+
+        return extras.getString(CloudMediaProviderContract.EXTRA_PAGE_TOKEN);
+    }
+
+    /**
+     * Get search results from the CloudMediaProvider.
+     */
+    @NonNull
+    private Cursor fetchSearchResultsFromCmp(
+            @NonNull PickerSearchProviderClient searchClient,
+            @NonNull SearchRequest searchRequest,
+            @Nullable String resumePageToken) {
+        final String suggestedMediaSetId;
+        final String searchText;
+        if (searchRequest instanceof SearchSuggestionRequest searchSuggestionRequest) {
+            suggestedMediaSetId = searchSuggestionRequest.getSearchSuggestion().getMediaSetId();
+            searchText = searchSuggestionRequest.getSearchSuggestion().getSearchText();
+        } else if (searchRequest instanceof SearchTextRequest searchTextRequest) {
+            suggestedMediaSetId = null;
+            searchText = searchTextRequest.getSearchText();
+        } else {
+            throw new IllegalArgumentException("Could not recognize the type of SearchRequest");
+        }
+
+        final Cursor cursor = searchClient.fetchSearchResultsFromCmp(
+                suggestedMediaSetId,
+                searchText,
+                CloudMediaProviderContract.SORT_ORDER_DESC_DATE_TAKEN,
+                PAGE_SIZE,
+                resumePageToken,
+                mCancellationSignal
+        );
+
+        if (cursor == null) {
+            throw new IllegalStateException("Cursor returned from provider is null.");
+        }
+
+        return cursor;
+    }
+
+
+    /**
+     * Validates input data received by the Worker for an immediate search results sync.
+     */
+    private void validateWorkInput(
+            int syncSource,
+            int searchRequestId,
+            @Nullable SearchRequest searchRequest) throws IllegalArgumentException {
+        // Search result sync can only happen with either local provider or cloud provider. This
+        // information needs to be provided in the {@code inputData}.
+        if (syncSource != SYNC_LOCAL_ONLY && syncSource != SYNC_CLOUD_ONLY) {
+            throw new IllegalArgumentException("Invalid search results sync source " + syncSource);
+        }
+        if (searchRequestId == INVALID_SEARCH_REQUEST_ID) {
+            throw new IllegalArgumentException("Invalid search request id " + searchRequestId);
+        }
+        if (searchRequest == null) {
+            throw new IllegalArgumentException(
+                    "Could not get search request details for search request id "
+                            + searchRequestId);
+        }
+        if (searchRequest instanceof SearchSuggestionRequest searchSuggestionRequest) {
+            if (searchSuggestionRequest.getSearchSuggestion().getSearchSuggestionType()
+                    == SEARCH_SUGGESTION_ALBUM) {
+                final boolean isLocal =
+                        isLocal(searchSuggestionRequest.getSearchSuggestion().getAuthority());
+
+                if (isLocal && syncSource == SYNC_CLOUD_ONLY) {
+                    throw new IllegalArgumentException(
+                            "Cannot sync with cloud provider for local album suggestion. "
+                                    + "Search request id: " + searchRequestId);
+                } else if (!isLocal && syncSource == SYNC_LOCAL_ONLY) {
+                    throw new IllegalArgumentException(
+                            "Cannot sync with local provider for cloud album suggestion. "
+                                    + "Search request id: " + searchRequestId);
+                }
+            }
+        }
+    }
+
+    private String getProviderAuthority(
+            int syncSource,
+            @NonNull SearchRequest searchRequest) {
+        final String authority;
+        if (syncSource == SYNC_LOCAL_ONLY) {
+            authority = getLocalProviderAuthority();
+        } else if (syncSource == SYNC_CLOUD_ONLY) {
+            authority = getCurrentCloudProviderAuthority();
+        } else {
+            throw new IllegalArgumentException("Invalid search results sync source " + syncSource);
+        }
+
+        if (authority == null) {
+            throw new IllegalArgumentException("Authority of the provider to sync search results "
+                    + "with cannot be null");
+        }
+
+        // Only in case of ALBUM type search suggestion, we want to explicitly query the source
+        // suggestion authority. For the rest of the suggestion types, we can query both
+        // available providers - local and cloud.
+        if (searchRequest instanceof SearchSuggestionRequest searchSuggestionRequest) {
+            if (searchSuggestionRequest.getSearchSuggestion().getSearchSuggestionType()
+                    == SEARCH_SUGGESTION_ALBUM) {
+                if (!authority.equals(
+                        searchSuggestionRequest.getSearchSuggestion().getAuthority())) {
+                    throw new IllegalArgumentException(String.format(
+                            "Mismatch in the suggestion source authority %s and the "
+                                    + "current sync authority %s for album search results sync",
+                            searchSuggestionRequest.getSearchSuggestion().getAuthority(),
+                            authority));
+                }
+            }
+        }
+
+        return authority;
+    }
+
+    private void throwIfCloudProviderHasChanged(@NonNull String authority)
+            throws RequestObsoleteException {
+        // Local provider's authority cannot change.
+        if (isLocal(authority)) {
+            return;
+        }
+
+        final String currentCloudAuthority = getCurrentCloudProviderAuthority();
+        if (!authority.equals(currentCloudAuthority)) {
+            throw new RequestObsoleteException("Cloud provider authority has changed. "
+                    + " Current cloud provider authority: " + currentCloudAuthority
+                    + " Cloud provider authority to sync with: " + authority);
+        }
+    }
+
+    private void throwIfWorkerStopped() throws RequestObsoleteException {
+        if (isStopped()) {
+            throw new RequestObsoleteException("Work is stopped " + getId());
+        }
+    }
+
+    private boolean isLocal(@NonNull String authority) {
+        return getLocalProviderAuthority().equals(authority);
+    }
+
+    @Nullable
+    private String getLocalProviderAuthority() {
+        return PickerSyncController.getInstanceOrThrow().getLocalProvider();
+    }
+
+    @Nullable
+    private String getCurrentCloudProviderAuthority() {
+        return PickerSyncController.getInstanceOrThrow().getCloudProvider();
+    }
+
+    private SQLiteDatabase getDatabase() {
+        return PickerSyncController.getInstanceOrThrow().getDbFacade().getDatabase();
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/sync/SyncTrackerRegistry.java b/src/com/android/providers/media/photopicker/sync/SyncTrackerRegistry.java
index 3eaa43504..b9f937ac1 100644
--- a/src/com/android/providers/media/photopicker/sync/SyncTrackerRegistry.java
+++ b/src/com/android/providers/media/photopicker/sync/SyncTrackerRegistry.java
@@ -35,6 +35,12 @@ public class SyncTrackerRegistry {
     private static SyncTracker sCloudSyncTracker = new SyncTracker();
     private static SyncTracker sCloudAlbumSyncTracker = new SyncTracker();
     private static SyncTracker sGrantsSyncTracker = new SyncTracker();
+    private static SyncTracker sLocalSearchTracker = new SyncTracker();
+    private static SyncTracker sCloudSearchTracker = new SyncTracker();
+    private static SyncTracker sCloudMediaSetsSyncTracker = new SyncTracker();
+    private static SyncTracker sLocalMediaSetsSyncTracker = new SyncTracker();
+    private static SyncTracker sCloudMediaInMediaSetTracker = new SyncTracker();
+    private static SyncTracker sLocalMediaInMediaSetTracker = new SyncTracker();
 
     public static SyncTracker getLocalSyncTracker() {
         return sLocalSyncTracker;
@@ -100,6 +106,84 @@ public class SyncTrackerRegistry {
         return sGrantsSyncTracker;
     }
 
+    public static SyncTracker getLocalSearchSyncTracker() {
+        return sLocalSearchTracker;
+    }
+
+    /**
+     * This setter is required to inject mock data for tests. Do not use this anywhere else.
+     */
+    @VisibleForTesting(otherwise = VisibleForTesting.NONE)
+    public static void setLocalSearchSyncTracker(
+            SyncTracker localSearchSyncTracker) {
+        sLocalSearchTracker = localSearchSyncTracker;
+    }
+
+    public static SyncTracker getCloudSearchSyncTracker() {
+        return sCloudSearchTracker;
+    }
+
+    /**
+     * This setter is required to inject mock data for tests. Do not use this anywhere else.
+     */
+    @VisibleForTesting(otherwise = VisibleForTesting.NONE)
+    public static void setCloudSearchSyncTracker(
+            SyncTracker cloudSearchSyncTracker) {
+        sCloudSearchTracker = cloudSearchSyncTracker;
+    }
+
+
+    public static SyncTracker getCloudMediaSetsSyncTracker() {
+        return sCloudMediaSetsSyncTracker;
+    }
+
+    public static SyncTracker getLocalMediaSetsSyncTracker() {
+        return sLocalMediaSetsSyncTracker;
+    }
+
+
+    /*
+    Required for testing. Not to be used anywhere else
+     */
+    @VisibleForTesting(otherwise = VisibleForTesting.NONE)
+    public static void setCloudMediaSetsSyncTracker(SyncTracker cloudMediaSetsSyncTracker) {
+        sCloudMediaSetsSyncTracker = cloudMediaSetsSyncTracker;
+    }
+
+    /*
+    Required for testing. Not to be used anywhere else
+     */
+    @VisibleForTesting(otherwise = VisibleForTesting.NONE)
+    public static void setLocalMediaSetsSyncTracker(SyncTracker localMediaSetsSyncTracker) {
+        sLocalMediaSetsSyncTracker = localMediaSetsSyncTracker;
+    }
+
+    public static SyncTracker getCloudMediaInMediaSetTracker() {
+        return sCloudMediaInMediaSetTracker;
+    }
+
+    public static SyncTracker getLocalMediaInMediaSetTracker() {
+        return sLocalMediaInMediaSetTracker;
+    }
+
+    /*
+     Only to be used for tests and nowhere else
+     */
+    @VisibleForTesting(otherwise = VisibleForTesting.NONE)
+    public static void setCloudMediaInMediaSetTracker(
+            SyncTracker cloudMediaInMediaSetTracker) {
+        sCloudMediaInMediaSetTracker = cloudMediaInMediaSetTracker;
+    }
+
+    /*
+    Only to be used for tests and nowhere else
+    */
+    @VisibleForTesting(otherwise = VisibleForTesting.NONE)
+    public static void setLocalMediaInMediaSetTracker(
+            SyncTracker localMediaInMediaSetTracker) {
+        sLocalMediaInMediaSetTracker = localMediaInMediaSetTracker;
+    }
+
     /**
      * Return the appropriate sync tracker.
      * @param isLocal is true when sync with local provider needs to be tracked. It is false for
@@ -160,6 +244,47 @@ public class SyncTrackerRegistry {
         }
     }
 
+    /**
+     * Create the required completable futures for new search result sync requests that need to be
+     * tracked.
+     */
+    public static void trackNewSearchResultsSyncRequests(
+            @PickerSyncManager.SyncSource int syncSource,
+            @NonNull UUID syncRequestId) {
+        switch (syncSource) {
+            case SYNC_LOCAL_ONLY:
+                getLocalSearchSyncTracker().createSyncFuture(syncRequestId);
+                break;
+            case SYNC_CLOUD_ONLY:
+                getCloudSearchSyncTracker().createSyncFuture(syncRequestId);
+                break;
+            default:
+                getLocalSearchSyncTracker().createSyncFuture(syncRequestId);
+                getCloudSearchSyncTracker().createSyncFuture(syncRequestId);
+                break;
+        }
+    }
+
+    /**
+     * Create the required completable futures to track a new media sets sync request
+     */
+    public static void trackNewMediaSetsSyncRequest(
+            @PickerSyncManager.SyncSource int syncSource,
+            @NonNull UUID syncRequestId) {
+        switch (syncSource) {
+            case SYNC_LOCAL_ONLY:
+                getLocalMediaSetsSyncTracker().createSyncFuture(syncRequestId);
+                break;
+            case SYNC_CLOUD_ONLY:
+                getCloudMediaSetsSyncTracker().createSyncFuture(syncRequestId);
+                break;
+            default:
+                getLocalMediaSetsSyncTracker().createSyncFuture(syncRequestId);
+                getCloudMediaSetsSyncTracker().createSyncFuture(syncRequestId);
+                break;
+        }
+    }
+
     /**
      * Mark the required futures as complete for existing media sync requests.
      */
@@ -190,4 +315,46 @@ public class SyncTrackerRegistry {
             getCloudAlbumSyncTracker().markSyncCompleted(syncRequestId);
         }
     }
+
+    /**
+     * Mark the required futures as complete for existing search result sync requests.
+     */
+    public static void markSearchResultsSyncAsComplete(
+            @PickerSyncManager.SyncSource int syncSource,
+            @NonNull UUID syncRequestId) {
+        if (syncSource == SYNC_LOCAL_ONLY || syncSource == SYNC_LOCAL_AND_CLOUD) {
+            getLocalSearchSyncTracker().markSyncCompleted(syncRequestId);
+        }
+        if (syncSource == SYNC_CLOUD_ONLY || syncSource == SYNC_LOCAL_AND_CLOUD) {
+            getCloudSearchSyncTracker().markSyncCompleted(syncRequestId);
+        }
+    }
+
+    /**
+     * Mark the required futures as complete for existing media set sync requests.
+     */
+    public static void markMediaSetsSyncAsComplete(
+            @PickerSyncManager.SyncSource int syncSource,
+            @NonNull UUID syncRequestId) {
+        if (syncSource == SYNC_LOCAL_ONLY || syncSource == SYNC_LOCAL_AND_CLOUD) {
+            getLocalMediaSetsSyncTracker().markSyncCompleted(syncRequestId);
+        }
+        if (syncSource == SYNC_CLOUD_ONLY || syncSource == SYNC_LOCAL_AND_CLOUD) {
+            getCloudMediaSetsSyncTracker().markSyncCompleted(syncRequestId);
+        }
+    }
+
+    /**
+     * Mark the required futures as complete for existing media in media set sync requests.
+     */
+    public static void markMediaInMediaSetSyncAsComplete(
+            @PickerSyncManager.SyncSource int syncSource,
+            @NonNull UUID syncRequestId) {
+        if (syncSource == SYNC_LOCAL_ONLY || syncSource == SYNC_LOCAL_AND_CLOUD) {
+            getLocalMediaInMediaSetTracker().markSyncCompleted(syncRequestId);
+        }
+        if (syncSource == SYNC_CLOUD_ONLY || syncSource == SYNC_LOCAL_AND_CLOUD) {
+            getCloudMediaInMediaSetTracker().markSyncCompleted(syncRequestId);
+        }
+    }
 }
diff --git a/src/com/android/providers/media/photopicker/sync/WorkManagerInitializer.java b/src/com/android/providers/media/photopicker/sync/WorkManagerInitializer.java
index b8309d210..c086d0863 100644
--- a/src/com/android/providers/media/photopicker/sync/WorkManagerInitializer.java
+++ b/src/com/android/providers/media/photopicker/sync/WorkManagerInitializer.java
@@ -33,7 +33,7 @@ public class WorkManagerInitializer {
     // {@link PickerSyncManager} to ensure that any request type is not blocked on other request
     // types. It is advisable to use unique work requests because in case the number of queued
     // requests grows, they should not block other work requests.
-    private static final int WORK_MANAGER_THREAD_POOL_SIZE = 7;
+    private static final int WORK_MANAGER_THREAD_POOL_SIZE = 11;
     @Nullable
     private static volatile Executor sWorkManagerExecutor;
 
diff --git a/src/com/android/providers/media/photopicker/v2/PickerDataLayerV2.java b/src/com/android/providers/media/photopicker/v2/PickerDataLayerV2.java
index 0ebc5e67d..11db2a58e 100644
--- a/src/com/android/providers/media/photopicker/v2/PickerDataLayerV2.java
+++ b/src/com/android/providers/media/photopicker/v2/PickerDataLayerV2.java
@@ -16,6 +16,8 @@
 
 package com.android.providers.media.photopicker.v2;
 
+import static android.provider.CloudMediaProviderContract.SEARCH_SUGGESTION_ALBUM;
+
 import static com.android.providers.media.MediaGrants.MEDIA_GRANTS_TABLE;
 import static com.android.providers.media.MediaGrants.OWNER_PACKAGE_NAME_COLUMN;
 import static com.android.providers.media.MediaGrants.PACKAGE_USER_ID_COLUMN;
@@ -24,8 +26,17 @@ import static com.android.providers.media.photopicker.PickerSyncController.getPa
 import static com.android.providers.media.photopicker.PickerSyncController.uidToUserId;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.IMMEDIATE_GRANTS_SYNC_WORK_NAME;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.IMMEDIATE_LOCAL_SYNC_WORK_NAME;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_CLOUD_ONLY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_LOCAL_ONLY;
 import static com.android.providers.media.photopicker.sync.WorkManagerInitializer.getWorkManager;
+import static com.android.providers.media.photopicker.v2.SearchSuggestionsProvider.getDefaultSuggestions;
+import static com.android.providers.media.photopicker.v2.SearchSuggestionsProvider.getSuggestionsFromCloudProvider;
+import static com.android.providers.media.photopicker.v2.SearchSuggestionsProvider.getSuggestionsFromLocalProvider;
+import static com.android.providers.media.photopicker.v2.SearchSuggestionsProvider.maybeCacheSearchSuggestions;
+import static com.android.providers.media.photopicker.v2.SearchSuggestionsProvider.suggestionsToCursor;
 import static com.android.providers.media.photopicker.v2.model.AlbumsCursorWrapper.EMPTY_MEDIA_ID;
+import static com.android.providers.media.photopicker.v2.model.MediaGroup.ALBUM;
+import static com.android.providers.media.photopicker.v2.model.MediaGroup.CATEGORY;
 
 import static java.util.Objects.requireNonNull;
 
@@ -41,37 +52,62 @@ import android.database.MergeCursor;
 import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteQueryBuilder;
 import android.os.Bundle;
+import android.os.CancellationSignal;
 import android.os.Process;
+import android.provider.CloudMediaProviderContract;
 import android.provider.CloudMediaProviderContract.AlbumColumns;
 import android.provider.MediaStore;
 import android.util.Log;
+import android.util.Pair;
 
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
+import androidx.work.WorkManager;
 
 import com.android.providers.media.photopicker.PickerSyncController;
+import com.android.providers.media.photopicker.SearchState;
+import com.android.providers.media.photopicker.sync.PickerSearchProviderClient;
+import com.android.providers.media.photopicker.sync.PickerSyncManager;
 import com.android.providers.media.photopicker.sync.SyncCompletionWaiter;
 import com.android.providers.media.photopicker.sync.SyncTrackerRegistry;
 import com.android.providers.media.photopicker.util.exceptions.RequestObsoleteException;
 import com.android.providers.media.photopicker.util.exceptions.UnableToAcquireLockException;
 import com.android.providers.media.photopicker.v2.model.AlbumMediaQuery;
 import com.android.providers.media.photopicker.v2.model.AlbumsCursorWrapper;
-import com.android.providers.media.photopicker.v2.model.FavoritesMediaQuery;
+import com.android.providers.media.photopicker.v2.model.MediaGroup;
 import com.android.providers.media.photopicker.v2.model.MediaQuery;
 import com.android.providers.media.photopicker.v2.model.MediaQueryForPreSelection;
+import com.android.providers.media.photopicker.v2.model.MediaSetsSyncRequestParams;
 import com.android.providers.media.photopicker.v2.model.MediaSource;
 import com.android.providers.media.photopicker.v2.model.PreviewMediaQuery;
 import com.android.providers.media.photopicker.v2.model.ProviderCollectionInfo;
-import com.android.providers.media.photopicker.v2.model.VideoMediaQuery;
+import com.android.providers.media.photopicker.v2.model.SearchRequest;
+import com.android.providers.media.photopicker.v2.model.SearchSuggestion;
+import com.android.providers.media.photopicker.v2.model.SearchSuggestionRequest;
+import com.android.providers.media.photopicker.v2.sqlite.MediaGroupCursorUtils;
+import com.android.providers.media.photopicker.v2.sqlite.PickerMediaDatabaseUtil;
+import com.android.providers.media.photopicker.v2.sqlite.PickerSQLConstants;
+import com.android.providers.media.photopicker.v2.sqlite.SearchMediaQuery;
+import com.android.providers.media.photopicker.v2.sqlite.SearchRequestDatabaseUtil;
+import com.android.providers.media.photopicker.v2.sqlite.SearchResultsDatabaseUtil;
+import com.android.providers.media.photopicker.v2.sqlite.SearchSuggestionsDatabaseUtils;
+import com.android.providers.media.photopicker.v2.sqlite.SearchSuggestionsQuery;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ForkJoinPool;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 
 /**
  * This class handles Photo Picker content queries.\
@@ -88,6 +124,17 @@ public class PickerDataLayerV2 {
             AlbumColumns.ALBUM_ID_SCREENSHOTS,
             AlbumColumns.ALBUM_ID_DOWNLOADS
     );
+
+    // Pinned albums and categories have a predefined order that they should be displayed in.
+    public static final List<Pair<MediaGroup, String>> PINNED_CATEGORIES_AND_ALBUMS_ORDER = List.of(
+            new Pair<>(ALBUM, AlbumColumns.ALBUM_ID_FAVORITES),
+            new Pair<>(ALBUM, AlbumColumns.ALBUM_ID_CAMERA),
+            new Pair<>(CATEGORY, CloudMediaProviderContract.MEDIA_CATEGORY_TYPE_PEOPLE_AND_PETS),
+            new Pair<>(ALBUM, AlbumColumns.ALBUM_ID_DOWNLOADS),
+            new Pair<>(ALBUM, AlbumColumns.ALBUM_ID_SCREENSHOTS),
+            new Pair<>(ALBUM, AlbumColumns.ALBUM_ID_VIDEOS)
+    );
+
     // Set of known merged albums.
     public static final Set<String> MERGED_ALBUMS = Set.of(
             AlbumColumns.ALBUM_ID_FAVORITES,
@@ -124,7 +171,8 @@ public class PickerDataLayerV2 {
 
     public static final String COLUMN_GRANTS_COUNT = "grants_count";
 
-    private static final String PROJECTION_GRANTS_COUNT = String.format("COUNT(*) AS %s",
+    private static final String PROJECTION_GRANTS_COUNT = String.format(
+            Locale.ROOT, "COUNT(*) AS %s",
             COLUMN_GRANTS_COUNT);
 
     /**
@@ -147,7 +195,7 @@ public class PickerDataLayerV2 {
      *                  results.
      */
     @NonNull
-    static Cursor queryMedia(@NonNull Context appContext, @NonNull Bundle queryArgs) {
+    public static Cursor queryMedia(@NonNull Context appContext, @NonNull Bundle queryArgs) {
         final MediaQuery query = new MediaQuery(queryArgs);
         final PickerSyncController syncController = PickerSyncController.getInstanceOrThrow();
         final String effectiveLocalAuthority =
@@ -161,7 +209,10 @@ public class PickerDataLayerV2 {
                         ? cloudAuthority
                         : null;
 
-        return queryMediaInternal(
+        waitForOngoingSync(appContext, effectiveLocalAuthority, effectiveCloudAuthority,
+                query.getIntentAction());
+
+        return PickerMediaDatabaseUtil.queryMedia(
                 appContext,
                 syncController,
                 query,
@@ -197,7 +248,10 @@ public class PickerDataLayerV2 {
                     query.getCallingPackageUid(), query.getCurrentDeSelection());
         }
 
-        return queryMediaInternal(
+        waitForOngoingSync(appContext, effectiveLocalAuthority, effectiveCloudAuthority,
+                query.getIntentAction());
+
+        return PickerMediaDatabaseUtil.queryMedia(
                 appContext,
                 syncController,
                 query,
@@ -239,7 +293,8 @@ public class PickerDataLayerV2 {
         for (String albumId: PINNED_ALBUMS_ORDER) {
             final AlbumsCursorWrapper albumCursor;
             if (MERGED_ALBUMS.contains(albumId)) {
-                albumCursor = getMergedAlbumsCursor(albumId, appContext, queryArgs, database,
+                albumCursor = PickerMediaDatabaseUtil.getMergedAlbumsCursor(
+                        albumId, appContext, queryArgs, database,
                         effectiveLocalAuthority, effectiveCloudAuthority);
             } else if (LOCAL_ALBUMS.contains(albumId)) {
                 albumCursor = localAlbums.getOrDefault(albumId, null);
@@ -273,6 +328,115 @@ public class PickerDataLayerV2 {
         }
     }
 
+    /**
+     * Returns a cursor with the Photo Picker albums and categories in response.
+     *
+     * @param appContext The application context.
+     * @param queryArgs The arguments help us filter on the media query to yield the desired
+     *                  results.
+     * @param cancellationSignal CancellationSignal object that notifies if the request has been
+     *                           cancelled.
+     */
+    @Nullable
+    public static Cursor queryCategoriesAndAlbums(
+            @NonNull Context appContext,
+            @NonNull Bundle queryArgs,
+            @Nullable CancellationSignal cancellationSignal) {
+        final MediaQuery query = new MediaQuery(queryArgs);
+        final PickerSyncController syncController = PickerSyncController.getInstanceOrThrow();
+        final String localAuthority = syncController.getLocalProvider();
+        final boolean shouldShowLocalAlbums = query.getProviders().contains(localAuthority);
+        final String cloudAuthority =
+                syncController.getCloudProviderOrDefault(/* defaultValue */ null);
+        final boolean shouldShowCloudAlbums = syncController.shouldQueryCloudMedia(
+                query.getProviders(), cloudAuthority);
+
+        final String effectiveLocalAuthority = shouldShowLocalAlbums ? localAuthority : null;
+        final String effectiveCloudAuthority = shouldShowCloudAlbums ? cloudAuthority : null;
+
+        final SQLiteDatabase database = PickerSyncController.getInstanceOrThrow()
+                .getDbFacade().getDatabase();
+        final List<Cursor> allMediaGroupCursors = new ArrayList<>();
+
+        // Get all local albums from the local provider in separate cursors to facilitate zipping
+        // them with merged albums.
+        final Map<String, AlbumsCursorWrapper> localAlbums = getLocalAlbumCursors(
+                appContext, query, effectiveLocalAuthority);
+
+        // Get cloud categories from cloud provider.
+        final Cursor categories = getCloudCategories(
+                appContext, query, effectiveCloudAuthority, syncController, cancellationSignal);
+
+        // Add Pinned album and categories to the list of cursors in the order in which they
+        // should be displayed. Note that pinned albums can only be local and merged albums.
+        for (Pair<MediaGroup, String> mediaGroup: PINNED_CATEGORIES_AND_ALBUMS_ORDER) {
+            final Cursor cursor;
+
+            switch (mediaGroup.first) {
+                case ALBUM:
+                    final String albumId = mediaGroup.second;
+                    if (MERGED_ALBUMS.contains(albumId)) {
+                        final Cursor albumsCursor = PickerMediaDatabaseUtil.getMergedAlbumsCursor(
+                                albumId, appContext, queryArgs, database, effectiveLocalAuthority,
+                                effectiveCloudAuthority);
+                        cursor = MediaGroupCursorUtils.getMediaGroupCursorForAlbums(albumsCursor);
+                    } else if (LOCAL_ALBUMS.contains(albumId)) {
+                        final Cursor albumCursor = localAlbums.getOrDefault(albumId, null);
+                        cursor = MediaGroupCursorUtils.getMediaGroupCursorForAlbums(albumCursor);
+                    } else {
+                        Log.e(TAG, "Could not recognize pinned album id, skipping it : " + albumId);
+                        cursor = null;
+                    }
+
+                    break;
+                case CATEGORY:
+                    switch (mediaGroup.second) {
+                        case CloudMediaProviderContract.MEDIA_CATEGORY_TYPE_PEOPLE_AND_PETS:
+                            cursor = MediaGroupCursorUtils.getMediaGroupCursorForCategories(
+                                    categories, effectiveCloudAuthority);
+                            break;
+                        default:
+                            Log.e(TAG, "Could not recognize pinned category type, skipping it : "
+                                    + mediaGroup.second);
+                            cursor = null;
+                    }
+
+                    break;
+                default:
+                    Log.e(TAG, "Could not recognize media group, skipping it : " + mediaGroup);
+                    cursor = null;
+            }
+
+            allMediaGroupCursors.add(cursor);
+        }
+
+        // Add cloud albums at the end.
+        // This is an external query into the CMP, so catch any exceptions that might get thrown
+        // so that at a minimum, the local results are sent back to the UI.
+        try {
+            final Cursor cloudAlbumsCursor = getCloudAlbumsCursor(appContext, query,
+                    effectiveLocalAuthority, effectiveCloudAuthority);
+            allMediaGroupCursors.add(
+                    MediaGroupCursorUtils.getMediaGroupCursorForAlbums(cloudAlbumsCursor));
+        } catch (RuntimeException ex) {
+            Log.w(TAG, "Cloud provider exception while fetching cloud albums cursor", ex);
+        }
+
+        // Remove empty cursors.
+        allMediaGroupCursors.removeIf(it -> it == null || !it.moveToFirst());
+
+        if (allMediaGroupCursors.isEmpty()) {
+            Log.e(TAG, "No categories or albums available");
+            return null;
+        } else {
+            Cursor mergeCursor = new MergeCursor(
+                    allMediaGroupCursors.toArray(
+                            new Cursor[allMediaGroupCursors.size()]));
+            Log.i(TAG, "Returning " + mergeCursor.getCount() + " categories and albums.");
+            return mergeCursor;
+        }
+    }
+
     /**
      * Returns a cursor with the Photo Picker album media in response.
      *
@@ -299,7 +463,10 @@ public class PickerDataLayerV2 {
                         : null;
 
         if (MERGED_ALBUMS.contains(albumId)) {
-            return queryMergedAlbumMedia(
+            waitForOngoingSync(appContext, effectiveLocalAuthority, effectiveCloudAuthority,
+                    query.getIntentAction());
+
+            return PickerMediaDatabaseUtil.queryMergedAlbumMedia(
                     albumId,
                     appContext,
                     syncController,
@@ -308,7 +475,9 @@ public class PickerDataLayerV2 {
                     effectiveCloudAuthority
             );
         } else {
-            return queryAlbumMediaInternal(
+            waitForOngoingAlbumSync(appContext, query, effectiveLocalAuthority);
+
+            return PickerMediaDatabaseUtil.queryAlbumMedia(
                     appContext,
                     syncController,
                     query,
@@ -318,6 +487,164 @@ public class PickerDataLayerV2 {
         }
     }
 
+    /**
+     * Returns a cursor with the Photo Picker search results media in response.
+     *
+     * @param queryArgs The arguments help us filter on the media query to yield the desired
+     *                  results.
+     * @param searchRequestID Identifier of the search request.
+     */
+    public static Cursor querySearchMedia(
+            @NonNull Context appContext,
+            @NonNull Bundle queryArgs,
+            int searchRequestID) {
+        final SearchMediaQuery query = new SearchMediaQuery(queryArgs, searchRequestID);
+
+        // Validate query input
+        if (MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP.equals(query.getIntentAction())) {
+            throw new RuntimeException("Search feature cannot be enabled with Picker Choice");
+        }
+
+        final PickerSyncController syncController = PickerSyncController.getInstanceOrThrow();
+        final String effectiveLocalAuthority =
+                query.getProviders().contains(syncController.getLocalProvider())
+                        ? syncController.getLocalProvider()
+                        : null;
+        final String cloudAuthority = syncController
+                .getCloudProviderOrDefault(/* defaultValue */ null);
+        final String effectiveCloudAuthority =
+                syncController.shouldQueryCloudMedia(query.getProviders(), cloudAuthority)
+                        ? cloudAuthority
+                        : null;
+
+        waitForOngoingSearchResultSync(effectiveLocalAuthority, effectiveCloudAuthority);
+        // TODO(b/361042632) resume sync if required
+
+        return SearchResultsDatabaseUtil.querySearchMedia(
+                syncController,
+                query,
+                effectiveLocalAuthority,
+                effectiveCloudAuthority
+        );
+    }
+
+    /**
+     * Get search suggestions for a given prefix from the cloud media provider and search history.
+     * In case cloud media provider is taking time in returning the suggestion results, we'll try to
+     * fallback on previously cached search results.
+     *
+     * @param appContext Application context.
+     * @param queryArgs The arguments help us filter on the media query to get the desired results.
+     * @param cancellationSignal CancellationSignal that indicates that the client has cancelled
+     *                           the suggestions request and the results are not needed anymore.
+     * @return A cursor with search suggestion data.
+     * See {@link PickerSQLConstants.SearchSuggestionsResponseColumns}.
+     */
+    static Cursor querySearchSuggestions(
+            @NonNull Context appContext,
+            @NonNull Bundle queryArgs,
+            @Nullable CancellationSignal cancellationSignal) {
+        // By default use ForkJoinPool.commonPool() to reduce resource usage instead of creating a
+        // custom pool. Its threads are slowly reclaimed during periods of non-use, and reinstated
+        // upon subsequent use.
+        return querySearchSuggestions(appContext, queryArgs, ForkJoinPool.commonPool(),
+                cancellationSignal);
+    }
+
+    /**
+     * Get search suggestions for a given prefix from the cloud media provider and search history.
+     * In case cloud media provider is taking time in returning the suggestion results, we'll try to
+     * fallback on previously cached search results.
+     *
+     * @param appContext Application context.
+     * @param queryArgs The arguments help us filter on the media query to get the desired results.
+     * @param executor The executor used to run async tasks.
+     * @param cancellationSignal CancellationSignal that indicates that the client has cancelled
+     *                           the suggestions request and the results are not needed anymore.
+     * @return A cursor with search suggestion data.
+     * See {@link PickerSQLConstants.SearchSuggestionsResponseColumns}.
+     */
+    static Cursor querySearchSuggestions(
+            @NonNull Context appContext,
+            @NonNull Bundle queryArgs,
+            @NonNull Executor executor,
+            @Nullable CancellationSignal cancellationSignal) {
+        final SearchSuggestionsQuery query = new SearchSuggestionsQuery(queryArgs);
+
+        // Attempt to fetch search suggestions from CMPs within the given timeout.
+        List<SearchSuggestion> cloudSearchSuggestions = new ArrayList<>();
+        CompletableFuture<List<SearchSuggestion>> cloudSuggestionsFuture =
+                CompletableFuture.supplyAsync(() ->
+                        getSuggestionsFromCloudProvider(appContext, query, cancellationSignal),
+                        executor);
+
+        List<SearchSuggestion> localSearchSuggestions = new ArrayList<>();
+        CompletableFuture<List<SearchSuggestion>> localSuggestionsFuture =
+                CompletableFuture.supplyAsync(() ->
+                        getSuggestionsFromLocalProvider(appContext, query, cancellationSignal),
+                        executor);
+        try {
+            localSearchSuggestions = localSuggestionsFuture.get(
+                    /* timeout */ 200, TimeUnit.MILLISECONDS);
+        } catch (TimeoutException e) {
+            Log.e(TAG, "Could not get search suggestions from local provider on time");
+            localSuggestionsFuture.cancel(/* mayInterruptIfRunning */ false);
+        } catch (RuntimeException | ExecutionException | InterruptedException e) {
+            Log.e(TAG, ("Something went wrong, "
+                    + "could not fetch search results from the local provider"), e);
+        }
+
+        try {
+            cloudSearchSuggestions = cloudSuggestionsFuture.get(
+                    /* timeout */ 300, TimeUnit.MILLISECONDS);
+            cloudSuggestionsFuture.thenApplyAsync(
+                    (suggestions) -> maybeCacheSearchSuggestions(query, suggestions),
+                    executor);
+        } catch (TimeoutException e) {
+            Log.e(TAG, "Could not get search suggestions from cloud provider on time");
+
+            // Only cancel suggestion request if the results don't need to be cached.
+            if (!query.isZeroState()) {
+                cloudSuggestionsFuture.cancel(/* mayInterruptIfRunning */ false);
+            }
+        } catch (RuntimeException | ExecutionException | InterruptedException e) {
+            Log.e(TAG, ("Something went wrong, "
+                    + "could not fetch search results from the cloud provider"), e);
+        }
+
+        // Fallback to cached suggestions if required.
+        if (cloudSearchSuggestions.isEmpty()) {
+            Log.d(TAG, "Attempting to fallback on cached search suggestions");
+            cloudSearchSuggestions = SearchSuggestionsDatabaseUtils.getCachedSuggestions(
+                    PickerSyncController.getInstanceOrThrow().getDbFacade().getDatabase(),
+                    query
+            );
+        }
+
+        // Get History Suggestions
+        final List<SearchSuggestion> historySuggestions =
+                SearchSuggestionsDatabaseUtils.getHistorySuggestions(
+                        PickerSyncController.getInstanceOrThrow().getDbFacade().getDatabase(),
+                        query);
+
+        // Get Default Suggestions
+        final List<SearchSuggestion> defaultSuggestions = getDefaultSuggestions();
+
+        // Merge suggestions in the order of priority
+        final List<SearchSuggestion> result = new ArrayList<>();
+        result.addAll(historySuggestions);
+        result.addAll(cloudSearchSuggestions);
+        result.addAll(localSearchSuggestions);
+        result.addAll(defaultSuggestions);
+
+        // Remove extra suggestions if the result exceeds the limit.
+        if (result.size() > query.getLimit()) {
+            result.subList(result.size() - query.getLimit(), result.size()).clear();
+        }
+
+        return suggestionsToCursor(result);
+    }
+
     /**
      * Queries the picker database and fetches the count of pre-granted media for the current
      * package and userId.
@@ -364,105 +691,6 @@ public class PickerDataLayerV2 {
                 table).toString());
     }
 
-    /**
-     * Query media from the database and prepare a cursor in response.
-     *
-     * We need to make multiple queries to prepare a response for the media query.
-     * {@link android.database.sqlite.SQLiteQueryBuilder} currently does not support the creation of
-     * a transaction in {@code DEFERRED} mode. This is why we'll perform the read queries in
-     * {@code IMMEDIATE} mode instead.
-     *
-     * @param appContext The application context.
-     * @param syncController Instance of the PickerSyncController singleton.
-     * @param query The MediaQuery object instance that tells us about the media query args.
-     * @param localAuthority The effective local authority that we need to consider for this
-     *                       transaction. If the local items should not be queries but the local
-     *                       authority has some value, the effective local authority would be null.
-     * @param cloudAuthority The effective cloud authority that we need to consider for this
-     *                       transaction. If the local items should not be queries but the local
-     *                       authority has some value, the effective local authority would
-     *                       be null.
-     * @return The cursor with the album media query results.
-     */
-    @NonNull
-    private static Cursor queryMediaInternal(
-            @NonNull Context appContext,
-            @NonNull PickerSyncController syncController,
-            @NonNull MediaQuery query,
-            @Nullable String localAuthority,
-            @Nullable String cloudAuthority
-    ) {
-        try {
-            final SQLiteDatabase database = syncController.getDbFacade().getDatabase();
-            waitForOngoingSync(appContext, localAuthority, cloudAuthority, query.getIntentAction());
-
-            try {
-                database.beginTransactionNonExclusive();
-                Cursor pageData = database.rawQuery(
-                        getMediaPageQuery(
-                                appContext,
-                            query,
-                            database,
-                            PickerSQLConstants.Table.MEDIA,
-                            localAuthority,
-                            cloudAuthority
-                        ),
-                        /* selectionArgs */ null
-                );
-                Bundle extraArgs = new Bundle();
-                Cursor nextPageKeyCursor = database.rawQuery(
-                        getMediaNextPageKeyQuery(
-                                appContext,
-                            query,
-                            database,
-                            PickerSQLConstants.Table.MEDIA,
-                            localAuthority,
-                            cloudAuthority
-                        ),
-                        /* selectionArgs */ null
-                );
-                addNextPageKey(extraArgs, nextPageKeyCursor);
-
-                Cursor prevPageKeyCursor = database.rawQuery(
-                        getMediaPreviousPageQuery(
-                                appContext,
-                                query,
-                                database,
-                                PickerSQLConstants.Table.MEDIA,
-                                localAuthority,
-                                cloudAuthority
-                        ),
-                        /* selectionArgs */ null
-                );
-                addPrevPageKey(extraArgs, prevPageKeyCursor);
-
-                if (query.shouldPopulateItemsBeforeCount()) {
-                    Cursor itemsBeforeCountCursor = database.rawQuery(
-                            getMediaItemsBeforeCountQuery(
-                                    appContext,
-                                    query,
-                                    database,
-                                    PickerSQLConstants.Table.MEDIA,
-                                    localAuthority,
-                                    cloudAuthority
-                            ),
-                            /* selectionArgs */ null
-                    );
-                    addItemsBeforeCountKey(extraArgs, itemsBeforeCountCursor);
-                }
-
-                database.setTransactionSuccessful();
-                pageData.setExtras(extraArgs);
-                Log.i(TAG, "Returning " + pageData.getCount() + " media metadata");
-                return pageData;
-            } finally {
-                database.endTransaction();
-            }
-        } catch (Exception e) {
-            throw new RuntimeException("Could not fetch media", e);
-        }
-    }
-
     private static void waitForOngoingSync(
             @NonNull Context appContext,
             @Nullable String localAuthority,
@@ -475,14 +703,14 @@ public class PickerDataLayerV2 {
         if (localAuthority != null) {
             SyncCompletionWaiter.waitForSync(
                     getWorkManager(appContext),
-                    SyncTrackerRegistry.getGrantsSyncTracker(),
-                    IMMEDIATE_GRANTS_SYNC_WORK_NAME
+                    SyncTrackerRegistry.getLocalSyncTracker(),
+                    IMMEDIATE_LOCAL_SYNC_WORK_NAME
             );
             if (isUserSelectAction) {
                 SyncCompletionWaiter.waitForSync(
                         getWorkManager(appContext),
-                        SyncTrackerRegistry.getLocalSyncTracker(),
-                        IMMEDIATE_LOCAL_SYNC_WORK_NAME
+                        SyncTrackerRegistry.getGrantsSyncTracker(),
+                        IMMEDIATE_GRANTS_SYNC_WORK_NAME
                 );
             }
         }
@@ -524,253 +752,28 @@ public class PickerDataLayerV2 {
     }
 
     /**
-     * Adds the next page key to the cursor extras from the given cursor.
-     *
-     * This is not a part of the page data. Photo Picker UI uses the Paging library requires us to
-     * provide the previous page key and the next page key as part of a page load response.
-     * The page key in this case refers to the date taken and the picker id of the first item in
-     * the page.
-     */
-    private static void addNextPageKey(Bundle extraArgs, Cursor nextPageKeyCursor) {
-        if (nextPageKeyCursor.moveToFirst()) {
-            final int pickerIdColumnIndex = nextPageKeyCursor.getColumnIndex(
-                    PickerSQLConstants.MediaResponse.PICKER_ID.getProjectedName()
-            );
-
-            if (pickerIdColumnIndex >= 0) {
-                extraArgs.putLong(PickerSQLConstants.MediaResponseExtras.NEXT_PAGE_ID.getKey(),
-                        nextPageKeyCursor.getLong(pickerIdColumnIndex)
-                );
-            }
-
-            final int dateTakenColumnIndex = nextPageKeyCursor.getColumnIndex(
-                    PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getProjectedName()
-            );
-
-            if (dateTakenColumnIndex >= 0) {
-                extraArgs.putLong(PickerSQLConstants.MediaResponseExtras
-                                .NEXT_PAGE_DATE_TAKEN.getKey(),
-                        nextPageKeyCursor.getLong(dateTakenColumnIndex)
-                );
-            }
-        }
-    }
-
-    /**
-     * Adds the previous page key to the cursor extras from the given cursor.
-     *
-     * This is not a part of the page data. Photo Picker UI uses the Paging library requires us to
-     * provide the previous page key and the next page key as part of a page load response.
-     * The page key in this case refers to the date taken and the picker id of the first item in
-     * the page.
-     */
-    private static void addPrevPageKey(Bundle extraArgs, Cursor prevPageKeyCursor) {
-        if (prevPageKeyCursor.moveToLast()) {
-            final int pickerIdColumnIndex = prevPageKeyCursor.getColumnIndex(
-                    PickerSQLConstants.MediaResponse.PICKER_ID.getProjectedName()
-            );
-
-            if (pickerIdColumnIndex >= 0) {
-                extraArgs.putLong(PickerSQLConstants.MediaResponseExtras.PREV_PAGE_ID.getKey(),
-                        prevPageKeyCursor.getLong(pickerIdColumnIndex)
-                );
-            }
-
-            final int dateTakenColumnIndex = prevPageKeyCursor.getColumnIndex(
-                    PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getProjectedName()
-            );
-
-            if (dateTakenColumnIndex >= 0) {
-                extraArgs.putLong(PickerSQLConstants.MediaResponseExtras
-                                .PREV_PAGE_DATE_TAKEN.getKey(),
-                        prevPageKeyCursor.getLong(dateTakenColumnIndex)
-                );
-            }
-        }
-    }
-
-    /**
-     * Adds items before count key to the cursor extras from the provided cursor.
-     */
-    private static void addItemsBeforeCountKey(Bundle extraArgs, Cursor itemsBeforeCountCursor) {
-        if (itemsBeforeCountCursor.moveToFirst()) {
-            final int itemsBeforeCountIndex =
-                    itemsBeforeCountCursor.getColumnIndex(PickerSQLConstants.COUNT_COLUMN);
-            extraArgs.putInt(
-                    PickerSQLConstants.MediaResponseExtras.ITEMS_BEFORE_COUNT.getKey(),
-                    itemsBeforeCountCursor.getInt(itemsBeforeCountIndex)
-            );
-        }
-    }
-
-    /**
-     * Builds and returns the SQL query to get the page contents from the Media table in Picker DB.
+     * @param appContext The application context.
+     * @param localAuthority The effective local authority that we need to consider for this
+     *                       transaction. If the local items should not be queried but the local
+     *                       authority has some value, the effective local authority would be null.
+     * @param cloudAuthority The effective cloud authority that we need to consider for this
+     *                       transaction. If the cloud items should not be queried but the cloud
+     *                       authority has some value, the effective cloud authority would be null.
      */
-    private static String getMediaPageQuery(
-            @Nullable Context appContext,
-            @NonNull MediaQuery query,
-            @NonNull SQLiteDatabase database,
-            @NonNull PickerSQLConstants.Table table,
+    private static void waitForOngoingSearchResultSync(
             @Nullable String localAuthority,
             @Nullable String cloudAuthority) {
-        SelectSQLiteQueryBuilder queryBuilder = new SelectSQLiteQueryBuilder(database)
-                .setTables(query.getTableWithRequiredJoins(table.toString(), appContext,
-                        query.getCallingPackageUid(), query.getIntentAction()))
-                .setProjection(List.of(
-                        PickerSQLConstants.MediaResponse.MEDIA_ID.getProjection(),
-                        PickerSQLConstants.MediaResponse.PICKER_ID.getProjection(),
-                        PickerSQLConstants.MediaResponse
-                                .AUTHORITY.getProjection(localAuthority, cloudAuthority),
-                        PickerSQLConstants.MediaResponse.MEDIA_SOURCE.getProjection(),
-                        PickerSQLConstants.MediaResponse.WRAPPED_URI.getProjection(
-                                localAuthority, cloudAuthority, query.getIntentAction()),
-                        PickerSQLConstants.MediaResponse
-                                .UNWRAPPED_URI.getProjection(localAuthority, cloudAuthority),
-                        PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getProjection(),
-                        PickerSQLConstants.MediaResponse.SIZE_IN_BYTES.getProjection(),
-                        PickerSQLConstants.MediaResponse.MIME_TYPE.getProjection(),
-                        PickerSQLConstants.MediaResponse.STANDARD_MIME_TYPE.getProjection(),
-                        PickerSQLConstants.MediaResponse.DURATION_MS.getProjection(),
-                        PickerSQLConstants.MediaResponse.IS_PRE_GRANTED.getProjection(
-                                query.getIntentAction())
-                ))
-                .setSortOrder(
-                        String.format(
-                                "%s DESC, %s DESC",
-                                PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getColumnName(),
-                                PickerSQLConstants.MediaResponse.PICKER_ID.getColumnName()
-                        )
-                )
-                .setLimit(query.getPageSize());
-
-        query.addWhereClause(
-                queryBuilder,
-                localAuthority,
-                cloudAuthority,
-                /* reverseOrder */ false
-        );
-
-        return queryBuilder.buildQuery();
-    }
+        final SearchState searchState = PickerSyncController.getInstanceOrThrow().getSearchState();
 
-    /**
-     * Builds and returns the SQL query to get the next page key from the Media table in Picker DB.
-     */
-    @Nullable
-    private static String getMediaNextPageKeyQuery(
-            @Nullable Context appContext,
-            @NonNull MediaQuery query,
-            @NonNull SQLiteDatabase database,
-            @NonNull PickerSQLConstants.Table table,
-            @Nullable String localAuthority,
-            @Nullable String cloudAuthority) {
-        if (query.getPageSize() == Integer.MAX_VALUE) {
-            return null;
+        if (localAuthority != null) {
+            SyncCompletionWaiter.waitForSyncWithTimeout(
+                    SyncTrackerRegistry.getLocalSearchSyncTracker(), /* timeoutInMillis */ 500);
         }
 
-        SelectSQLiteQueryBuilder queryBuilder = new SelectSQLiteQueryBuilder(database)
-                .setTables(
-                        query.getTableWithRequiredJoins(table.toString(), appContext,
-                                query.getCallingPackageUid(), query.getIntentAction()))
-                .setProjection(List.of(
-                        PickerSQLConstants.MediaResponse.PICKER_ID.getProjection(),
-                        PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getProjection()
-                ))
-                .setSortOrder(
-                        String.format(
-                                "%s DESC, %s DESC",
-                                PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getColumnName(),
-                                PickerSQLConstants.MediaResponse.PICKER_ID.getColumnName()
-                        )
-                )
-                .setLimit(1)
-                .setOffset(query.getPageSize());
-
-        query.addWhereClause(
-                queryBuilder,
-                localAuthority,
-                cloudAuthority,
-                /* reverseOrder */ false
-        );
-
-        return queryBuilder.buildQuery();
-    }
-
-    /**
-     * Builds and returns the SQL query to get the previous page contents from the Media table in
-     * Picker DB.
-     *
-     * We fetch the whole page and not just one key because it is possible that the previous page
-     * is smaller than the page size. So, we get the whole page and only use the last row item to
-     * get the previous page key.
-     */
-    private static String getMediaPreviousPageQuery(
-            @Nullable Context appContext,
-            @NonNull MediaQuery query,
-            @NonNull SQLiteDatabase database,
-            @NonNull PickerSQLConstants.Table table,
-            @Nullable String localAuthority,
-            @Nullable String cloudAuthority) {
-        SelectSQLiteQueryBuilder queryBuilder = new SelectSQLiteQueryBuilder(database)
-                .setTables(
-                        query.getTableWithRequiredJoins(table.toString(), appContext,
-                                        query.getCallingPackageUid(), query.getIntentAction()))
-                .setProjection(List.of(
-                        PickerSQLConstants.MediaResponse.PICKER_ID.getProjection(),
-                        PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getProjection()
-                )).setSortOrder(
-                        String.format(
-                                "%s ASC, %s ASC",
-                                PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getColumnName(),
-                                PickerSQLConstants.MediaResponse.PICKER_ID.getColumnName()
-                        )
-                ).setLimit(query.getPageSize());
-
-
-        query.addWhereClause(
-                queryBuilder,
-                localAuthority,
-                cloudAuthority,
-                /* reverseOrder */ true
-        );
-
-        return queryBuilder.buildQuery();
-    }
-
-    /**
-     * Builds and returns the SQL query to get the count of items before the given page from the
-     * Media table in Picker DB.
-     *
-     * The result only contains one row with one column that will hold the count of the items.
-     */
-    private static String getMediaItemsBeforeCountQuery(
-            @Nullable Context appContext,
-            @NonNull MediaQuery query,
-            @NonNull SQLiteDatabase database,
-            @NonNull PickerSQLConstants.Table table,
-            @Nullable String localAuthority,
-            @Nullable String cloudAuthority) {
-        SelectSQLiteQueryBuilder queryBuilder = new SelectSQLiteQueryBuilder(database)
-                .setTables(
-                        query.getTableWithRequiredJoins(table.toString(), appContext,
-                                query.getCallingPackageUid(), query.getIntentAction()))
-                .setProjection(List.of("Count(*) AS " + PickerSQLConstants.COUNT_COLUMN))
-                .setSortOrder(
-                        String.format(
-                                "%s ASC, %s ASC",
-                                PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getColumnName(),
-                                PickerSQLConstants.MediaResponse.PICKER_ID.getColumnName()
-                        )
-                );
-
-        query.addWhereClause(
-                queryBuilder,
-                localAuthority,
-                cloudAuthority,
-                /* reverseOrder */ true
-        );
-
-        return queryBuilder.buildQuery();
+        if (cloudAuthority != null) {
+            SyncCompletionWaiter.waitForSyncWithTimeout(
+                    SyncTrackerRegistry.getCloudSearchSyncTracker(), /* timeoutInMillis */ 3000);
+        }
     }
 
     /**
@@ -780,7 +783,8 @@ public class PickerDataLayerV2 {
     public static @NonNull StringBuilder getPackageSelectionWhereClause(String[] packageNames,
             String table) {
         StringBuilder packageSelection = new StringBuilder();
-        String packageColumn = String.format("%s.%s", table, OWNER_PACKAGE_NAME_COLUMN);
+        String packageColumn = String.format(
+                Locale.ROOT, "%s.%s", table, OWNER_PACKAGE_NAME_COLUMN);
         packageSelection.append(packageColumn).append(" IN (\'");
 
         String joinedPackageNames = String.join("\',\'", packageNames);
@@ -790,102 +794,7 @@ public class PickerDataLayerV2 {
         return packageSelection;
     }
 
-    /**
-     * Return merged albums cursor for the given merged album id.
-     *
-     * @param albumId        Merged album id.
-     * @param queryArgs      Query arguments bundle that will be used to filter albums.
-     * @param database       Instance of Picker SQLiteDatabase.
-     * @param localAuthority The local authority if local albums should be returned, otherwise this
-     *                       argument should be null.
-     * @param cloudAuthority The cloud authority if cloud albums should be returned, otherwise this
-     *                       argument should be null.
-     */
-    private static AlbumsCursorWrapper getMergedAlbumsCursor(
-            @NonNull String albumId,
-            Context appContext,
-            @NonNull Bundle queryArgs,
-            @NonNull SQLiteDatabase database,
-            @Nullable String localAuthority,
-            @Nullable String cloudAuthority) {
-        if (localAuthority == null && cloudAuthority == null) {
-            Log.e(TAG, "Cannot get merged albums when no providers are available");
-            return null;
-        }
-
-        final MediaQuery query;
-        if (albumId.equals(AlbumColumns.ALBUM_ID_VIDEOS)) {
-            VideoMediaQuery videoQuery = new VideoMediaQuery(queryArgs, 1);
-            if (!videoQuery.shouldDisplayVideosAlbum()) {
-                return null;
-            }
-            query = videoQuery;
-        } else if (albumId.equals(AlbumColumns.ALBUM_ID_FAVORITES)) {
-            query = new FavoritesMediaQuery(queryArgs, 1);
-        } else {
-            Log.e(TAG, "Cannot recognize merged album " + albumId);
-            return null;
-        }
-
-        try {
-            database.beginTransactionNonExclusive();
-            Cursor pickerDBResponse = database.rawQuery(
-                    getMediaPageQuery(
-                            appContext,
-                            query,
-                            database,
-                            PickerSQLConstants.Table.MEDIA,
-                            localAuthority,
-                            cloudAuthority
-                    ),
-                    /* selectionArgs */ null
-            );
-
-            if (pickerDBResponse.moveToFirst()) {
-                // Conform to the album response projection. Temporary code, this will change once
-                // we start caching album metadata.
-                final MatrixCursor result = new MatrixCursor(AlbumColumns.ALL_PROJECTION);
-                final String authority = pickerDBResponse.getString(pickerDBResponse.getColumnIndex(
-                        PickerSQLConstants.MediaResponse.AUTHORITY.getProjectedName()));
-                final String[] projectionValue = new String[]{
-                        /* albumId */ albumId,
-                        pickerDBResponse.getString(pickerDBResponse.getColumnIndex(
-                                PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getProjectedName())),
-                        /* displayName */ albumId,
-                        pickerDBResponse.getString(pickerDBResponse.getColumnIndex(
-                                PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())),
-                        /* count */ "0", // This value is not used anymore
-                        authority,
-                };
-                result.addRow(projectionValue);
-                return new AlbumsCursorWrapper(result, authority, localAuthority);
-            }
-
-            // Always show Videos album if cloud feature is turned on and the MIME types filter
-            // would allow for video format(s).
-            if (albumId.equals(AlbumColumns.ALBUM_ID_VIDEOS) && cloudAuthority != null) {
-                return new AlbumsCursorWrapper(
-                        getDefaultEmptyAlbum(albumId),
-                        /* albumAuthority */ localAuthority,
-                        /* localAuthority */ localAuthority);
-            }
-
-            // Always show Favorites album.
-            if (albumId.equals(AlbumColumns.ALBUM_ID_FAVORITES)) {
-                return new AlbumsCursorWrapper(
-                        getDefaultEmptyAlbum(albumId),
-                        /* albumAuthority */ localAuthority,
-                        /* localAuthority */ localAuthority);
-            }
-
-            return null;
-        } finally {
-            database.setTransactionSuccessful();
-            database.endTransaction();
-        }
-    }
-
-    private static Cursor getDefaultEmptyAlbum(@NonNull String albumId) {
+    public static Cursor getDefaultEmptyAlbum(@NonNull String albumId) {
         // Conform to the album response projection. Temporary code, this will change once we start
         // caching album metadata.
         final MatrixCursor result = new MatrixCursor(AlbumColumns.ALL_PROJECTION);
@@ -1033,211 +942,42 @@ public class PickerDataLayerV2 {
     }
 
     /**
-     * @param appContext The application context.
-     * @param syncController Instance of the PickerSyncController singleton.
-     * @param query The AlbumMediaQuery object instance that tells us about the media query args.
-     * @param localAuthority The effective local authority that we need to consider for this
-     *                       transaction. If the local items should not be queries but the local
-     *                       authority has some value, the effective local authority would be null.
-     * @param cloudAuthority The effective cloud authority that we need to consider for this
-     *                       transaction. If the local items should not be queries but the local
-     *                       authority has some value, the effective local authority would
-     *                       be null.
-     * @return The cursor with the album media query results.
-     */
-    @NonNull
-    private static Cursor queryAlbumMediaInternal(
-            @NonNull Context appContext,
-            @NonNull PickerSyncController syncController,
-            @NonNull AlbumMediaQuery query,
-            @Nullable String localAuthority,
-            @Nullable String cloudAuthority
-    ) {
-        try {
-            final SQLiteDatabase database = syncController.getDbFacade().getDatabase();
-
-            waitForOngoingAlbumSync(appContext, query, localAuthority);
-
-            try {
-                database.beginTransactionNonExclusive();
-                Cursor pageData = database.rawQuery(
-                        getMediaPageQuery(
-                                appContext,
-                                query,
-                                database,
-                                PickerSQLConstants.Table.ALBUM_MEDIA,
-                                localAuthority,
-                                cloudAuthority
-                        ),
-                        /* selectionArgs */ null
-                );
-
-                Bundle extraArgs = new Bundle();
-                Cursor nextPageKeyCursor = database.rawQuery(
-                        getMediaNextPageKeyQuery(
-                                appContext,
-                                query,
-                                database,
-                                PickerSQLConstants.Table.ALBUM_MEDIA,
-                                localAuthority,
-                                cloudAuthority
-                        ),
-                        /* selectionArgs */ null
-                );
-                addNextPageKey(extraArgs, nextPageKeyCursor);
-
-                Cursor prevPageKeyCursor = database.rawQuery(
-                        getMediaPreviousPageQuery(
-                                appContext,
-                                query,
-                                database,
-                                PickerSQLConstants.Table.ALBUM_MEDIA,
-                                localAuthority,
-                                cloudAuthority
-                        ),
-                        /* selectionArgs */ null
-                );
-                addPrevPageKey(extraArgs, prevPageKeyCursor);
-
-                if (query.shouldPopulateItemsBeforeCount()) {
-                    Cursor itemsBeforeCountCursor = database.rawQuery(
-                            getMediaItemsBeforeCountQuery(
-                                    appContext,
-                                    query,
-                                    database,
-                                    PickerSQLConstants.Table.ALBUM_MEDIA,
-                                    localAuthority,
-                                    cloudAuthority
-                            ),
-                            /* selectionArgs */ null
-                    );
-                    addItemsBeforeCountKey(extraArgs, itemsBeforeCountCursor);
-                }
-
-                database.setTransactionSuccessful();
-
-                pageData.setExtras(extraArgs);
-                Log.i(TAG, "Returning " + pageData.getCount() + " album media items for album "
-                        + query.getAlbumId());
-                return pageData;
-            } finally {
-                database.endTransaction();
-            }
-
-
-        } catch (Exception e) {
-            throw new RuntimeException("Could not fetch media", e);
-        }
-    }
-
-    /**
-     * @param albumId The album id of the request album media.
-     * @param appContext The application context.
-     * @param syncController Instance of the PickerSyncController singleton.
-     * @param queryArgs The Bundle with query args received with the request.
-     * @param localAuthority The effective local authority that we need to consider for this
-     *                       transaction. If the local items should not be queries but the local
-     *                       authority has some value, the effective local authority would be null.
-     * @param cloudAuthority The effective cloud authority that we need to consider for this
-     *                       transaction. If the local items should not be queries but the local
-     *                       authority has some value, the effective local authority would
-     *                       be null.
-     * @return The cursor with the album media query results.
+     * @param appContext Application context.
+     * @param query Query arguments that will be used to filter categories.
+     * @param cloudAuthority Effective cloud authority from which cloud categories should be
+     *                       fetched. This could be null.
+     * @param cancellationSignal CancellationSignal object that notifies that the request has been
+     *                           cancelled.
+     * @return Cursor with Categories from the cloud provider. Returns null if an error occurs in
+     * fetching the categories.
      */
-    @NonNull
-    private static Cursor queryMergedAlbumMedia(
-            @NonNull String albumId,
+    @Nullable
+    private static Cursor getCloudCategories(
             @NonNull Context appContext,
+            @NonNull MediaQuery query,
+            @Nullable String cloudAuthority,
             @NonNull PickerSyncController syncController,
-            @NonNull Bundle queryArgs,
-            @Nullable String localAuthority,
-            @Nullable String cloudAuthority
-    ) {
+            @Nullable CancellationSignal cancellationSignal) {
         try {
-            MediaQuery query;
-            switch (albumId) {
-                case AlbumColumns.ALBUM_ID_FAVORITES:
-                    query = new FavoritesMediaQuery(queryArgs);
-                    break;
-                case AlbumColumns.ALBUM_ID_VIDEOS:
-                    query = new VideoMediaQuery(queryArgs);
-                    break;
-                default:
-                    throw new IllegalArgumentException("Cannot recognize album " + albumId);
+            if (cloudAuthority == null) {
+                Log.d(TAG, "Cannot fetch cloud categories when cloud authority is null.");
+                return null;
             }
-
-            final SQLiteDatabase database = syncController.getDbFacade().getDatabase();
-
-            waitForOngoingSync(appContext, localAuthority, cloudAuthority, query.getIntentAction());
-
-            try {
-                database.beginTransactionNonExclusive();
-                Cursor pageData = database.rawQuery(
-                        getMediaPageQuery(
-                                appContext,
-                                query,
-                                database,
-                                PickerSQLConstants.Table.MEDIA,
-                                localAuthority,
-                                cloudAuthority
-                        ),
-                        /* selectionArgs */ null
-                );
-
-                Bundle extraArgs = new Bundle();
-                Cursor nextPageKeyCursor = database.rawQuery(
-                        getMediaNextPageKeyQuery(
-                                appContext,
-                                query,
-                                database,
-                                PickerSQLConstants.Table.MEDIA,
-                                localAuthority,
-                                cloudAuthority
-                        ),
-                        /* selectionArgs */ null
-                );
-                addNextPageKey(extraArgs, nextPageKeyCursor);
-
-                Cursor prevPageKeyCursor = database.rawQuery(
-                        getMediaPreviousPageQuery(
-                                appContext,
-                                query,
-                                database,
-                                PickerSQLConstants.Table.MEDIA,
-                                localAuthority,
-                                cloudAuthority
-                        ),
-                        /* selectionArgs */ null
-                );
-                addPrevPageKey(extraArgs, prevPageKeyCursor);
-
-                if (query.shouldPopulateItemsBeforeCount()) {
-                    Cursor itemsBeforeCountCursor = database.rawQuery(
-                            getMediaItemsBeforeCountQuery(
-                                    appContext,
-                                    query,
-                                    database,
-                                    PickerSQLConstants.Table.MEDIA,
-                                    localAuthority,
-                                    cloudAuthority
-                            ),
-                            /* selectionArgs */ null
-                    );
-                    addItemsBeforeCountKey(extraArgs, itemsBeforeCountCursor);
-                }
-
-                database.setTransactionSuccessful();
-
-                pageData.setExtras(extraArgs);
-                Log.i(TAG, "Returning " + pageData.getCount() + " album media items for album "
-                        + albumId);
-                return pageData;
-            } finally {
-                database.endTransaction();
+            final PickerSearchProviderClient searchClient = PickerSearchProviderClient.create(
+                    appContext, cloudAuthority);
+            if (syncController.getCategoriesState().areCategoriesEnabled(
+                    appContext, cloudAuthority)) {
+                Log.d(TAG, "Media categories feature is enabled. Fetching cloud categories.");
+                return searchClient.fetchMediaCategoriesFromCmp(
+                        /* parentCategoryId */ null,
+                        query.prepareCMPQueryArgs(),
+                        /* cancellationSignal */ cancellationSignal);
             }
-        } catch (Exception e) {
-            throw new RuntimeException("Could not fetch media", e);
+        } catch (RuntimeException e) {
+            Log.e(TAG, "Could not fetch cloud categories.", e);
         }
+
+        return null;
     }
 
     /**
@@ -1391,7 +1131,8 @@ public class PickerDataLayerV2 {
         query.processUrisForSelection(query.getPreSelectionUris(), effectiveLocalAuthority,
                 effectiveCloudAuthority, effectiveCloudAuthority == null, appContext,
                 query.getCallingPackageUid());
-        return queryPreSelectedMediaInternal(
+
+        return PickerMediaDatabaseUtil.queryPreSelectedMedia(
                 appContext,
                 syncController,
                 query,
@@ -1401,49 +1142,251 @@ public class PickerDataLayerV2 {
     }
 
     /**
-     * Query media from the database filtered by pre-selection uris and prepare a cursor in
-     * response.
+     * Handle Picker application's request to create a new search request and return a Bundle with
+     * the search request Id.
+     * Also trigger search results sync with the providers and saves the incoming search request in
+     * the search history table.
      *
-     * @param appContext The application context.
-     * @param syncController Instance of the PickerSyncController singleton.
-     * @param query The MediaQuery object instance that tells us about the media query args.
-     * @param localAuthority The effective local authority that we need to consider for this
-     *                       transaction. If the local items should not be queries but the local
-     *                       authority has some value, the effective local authority would be null.
-     * @param cloudAuthority The effective cloud authority that we need to consider for this
-     *                       transaction. If the local items should not be queries but the local
-     *                       authority has some value, the effective local authority would
-     *                       be null.
-     * @return The cursor with the album media query results.
+     * @param appContext Application context.
+     * @param extras Bundle with input parameters.
+     * @return a response Bundle.
      */
     @NonNull
-    private static Cursor queryPreSelectedMediaInternal(
+    public static Bundle handleNewSearchRequest(
             @NonNull Context appContext,
-            @NonNull PickerSyncController syncController,
-            @NonNull MediaQuery query,
-            @Nullable String localAuthority,
-            @Nullable String cloudAuthority
-    ) {
+            @NonNull Bundle extras) {
+        // By default use ForkJoinPool.commonPool() to reduce resource usage instead of creating a
+        // custom pool. Its threads are slowly reclaimed during periods of non-use, and reinstated
+        // upon subsequent use.
+        return handleNewSearchRequest(appContext, extras, ForkJoinPool.commonPool(),
+                getWorkManager(appContext));
+    }
 
-        final SQLiteDatabase database = syncController.getDbFacade().getDatabase();
-        waitForOngoingSync(appContext, localAuthority, cloudAuthority, query.getIntentAction());
+    /**
+     * Handle Picker application's request to create a new search request and return a Bundle with
+     * the search request Id.
+     * Also trigger search results sync with the providers and saves the incoming search request in
+     * the search history table.
+     *
+     * @param appContext Application context.
+     * @param extras Bundle with input parameters.
+     * @param executor Executor to asynchronously save the request as search history in database.
+     * @param workManager An instance of {@link WorkManager}
+     * @return a response Bundle.
+     */
+    @NonNull
+    public static Bundle handleNewSearchRequest(@NonNull Context appContext,
+                                                @NonNull Bundle extras,
+                                                @NonNull Executor executor,
+                                                @NonNull WorkManager workManager) {
+        requireNonNull(extras);
+
+        final SearchRequest searchRequest = SearchRequest.create(extras);
+        final SQLiteDatabase database = PickerSyncController.getInstanceOrThrow().getDbFacade()
+                .getDatabase();
+
+        SearchRequestDatabaseUtil.saveSearchRequest(database, searchRequest);
+        final int searchRequestId =
+                SearchRequestDatabaseUtil.getSearchRequestID(database, searchRequest);
+
+        if (searchRequestId == -1) {
+            throw new RuntimeException("Could not create search request!");
+        } else {
+            // Asynchronously save data in search history table.
+            CompletableFuture<Boolean> ignored = CompletableFuture.supplyAsync(
+                    () -> SearchSuggestionsDatabaseUtils.saveSearchHistory(database, searchRequest),
+                    executor);
 
-        try {
-            Cursor pageData = database.rawQuery(
-                    getMediaPageQuery(
-                            appContext,
-                            query,
-                            database,
-                            PickerSQLConstants.Table.MEDIA,
-                            localAuthority,
-                            cloudAuthority
-                    ),
-                    /* selectionArgs */ null
-            );
-            Log.i(TAG, "Returning " + pageData.getCount() + " media metadata");
-            return pageData;
-        } catch (Exception e) {
-            throw new RuntimeException("Could not fetch media", e);
+            // Schedule search results sync
+            scheduleSearchResultsSync(appContext, searchRequest, searchRequestId, extras,
+                    workManager);
+
+            return getSearchRequestInitResponse(searchRequestId);
+        }
+    }
+
+    /**
+     * Handles Photopicker's request to trigger a sync for media sets for the given category
+     * based on whether the providers implement search categories.
+     * @param extras Bundle with all input parameters
+     * @param appContext The application context
+     */
+    public static void triggerMediaSetsSync(
+            @NonNull Bundle extras, @NonNull Context appContext) {
+        requireNonNull(extras);
+        requireNonNull(appContext);
+        triggerMediaSetsSync(extras, appContext, getWorkManager(appContext));
+    }
+
+    /**
+     * Handles Photopicker's request to trigger a sync for media sets for the given category
+     * based on whether the providers implement search categories.
+     * @param extras Bundle with all input parameters
+     * @param appContext The application context
+     * @param workManager An instance of {@link WorkManager}
+     */
+    public static void triggerMediaSetsSync(
+            @NonNull Bundle extras, @NonNull Context appContext, @NonNull WorkManager workManager) {
+
+        requireNonNull(workManager);
+
+        MediaSetsSyncRequestParams mediaSetsSyncRequestParams =
+                new MediaSetsSyncRequestParams(extras);
+        final Set<String> providers = new HashSet<>(
+                Objects.requireNonNull(extras.getStringArrayList("providers")));
+
+        scheduleMediaSetsSync(appContext, mediaSetsSyncRequestParams, providers, workManager);
+    }
+
+    /**
+     * Schedules MediaSets sync for both local and cloud provider if the corresponding
+     * providers implement Categories.
+     * @param appContext  The application context
+     * @param requestParams Wrapper object to hold all media set sync parameters
+     * @param providers List of available providers
+     * @param workManager An instance of {@link WorkManager}
+     */
+    private static void scheduleMediaSetsSync(
+            @NonNull Context appContext, @NonNull MediaSetsSyncRequestParams requestParams,
+            @NonNull Set<String> providers, @NonNull WorkManager workManager) {
+
+        final PickerSyncManager syncManager = new PickerSyncManager(workManager, appContext);
+        final PickerSyncController syncController = PickerSyncController.getInstanceOrThrow();
+        int syncSource = syncController.getLocalProvider().equals(requestParams.getAuthority())
+                ? SYNC_LOCAL_ONLY : SYNC_CLOUD_ONLY;
+
+        // Schedule local sync only if the provider holds local authority
+        if (syncSource == SYNC_LOCAL_ONLY && syncController.shouldQueryLocalMediaSets(providers)) {
+            syncManager.syncMediaSetsForProvider(requestParams, SYNC_LOCAL_ONLY);
+        } else if (syncController.shouldQueryCloudMediaSets(
+                providers, requestParams.getAuthority())) {
+            // Schedule cloud sync otherwise
+            syncManager.syncMediaSetsForProvider(requestParams, SYNC_CLOUD_ONLY);
+        } else {
+            Log.e(TAG, "Unrecognised provider authority received for MediaSetSync, skipping");
+        }
+    }
+
+    /**
+     * Schedules search results sync for the incoming search request with local or cloud providers,
+     * or both.
+     *
+     * @param appContext      Application context.
+     * @param searchRequest   Search request for which search results need to be synced.
+     * @param searchRequestId Identifier of the search request.
+     * @param extras          Bundle with input parameters.
+     * @param workManager     An instance of {@link WorkManager}
+     */
+    private static void scheduleSearchResultsSync(
+            @NonNull Context appContext,
+            @NonNull SearchRequest searchRequest,
+            int searchRequestId,
+            @NonNull Bundle extras,
+            WorkManager workManager) {
+        final PickerSyncManager syncManager = new PickerSyncManager(workManager, appContext);
+        final Set<String> providers = new HashSet<>(
+                Objects.requireNonNull(extras.getStringArrayList("providers")));
+
+        scheduleSyncWithLocalProvider(searchRequest, searchRequestId, syncManager, providers);
+        scheduleSyncWithCloudProvider(searchRequest, searchRequestId, syncManager, providers);
+    }
+
+    /**
+     * Schedules search results sync for the incoming search request with local provider if local
+     * search is enabled.
+     *
+     * @param searchRequest Search request for which search results need to be synced.
+     * @param searchRequestId Identifier of the search request.
+     * @param syncManager An instance of PickerSyncManager that helps us schedule work manager
+     *                    sync requests.
+     * @param providers Set of valid providers we can sync search results from.
+     */
+    private static void scheduleSyncWithLocalProvider(
+            @NonNull SearchRequest searchRequest,
+            int searchRequestId,
+            @NonNull PickerSyncManager syncManager,
+            @NonNull Set<String> providers) {
+        final PickerSyncController syncController = PickerSyncController.getInstanceOrThrow();
+
+        if (!syncController.shouldQueryLocalMediaForSearch(providers)) {
+            Log.d(TAG, "Search is not enabled for the current local authority. "
+                    + "Not syncing search results with local provider for request id "
+                    + searchRequestId);
+            return;
+        }
+
+        if (searchRequest instanceof SearchSuggestionRequest) {
+            final SearchSuggestion suggestion =
+                    ((SearchSuggestionRequest) searchRequest).getSearchSuggestion();
+            if (suggestion.getSearchSuggestionType() == SEARCH_SUGGESTION_ALBUM) {
+                if (!syncController.getLocalProvider().equals(suggestion.getAuthority())) {
+                    Log.d(TAG, "Album search suggestion does not belong to local provider. "
+                            + "Not syncing search results with local provider for request id "
+                            + searchRequestId);
+                    return;
+                }
+            }
+        }
+
+        syncManager.syncSearchResultsForProvider(
+                searchRequestId,
+                PickerSyncManager.SYNC_LOCAL_ONLY,
+                syncController.getLocalProvider());
+    }
+
+    /**
+     * Schedules search results sync for the incoming search request with cloud provider if cloud
+     * search is enabled.
+     *
+     * @param searchRequest Search request for which search results need to be synced.
+     * @param searchRequestId Identifier of the search request.
+     * @param syncManager An instance of PickerSyncManager that helps us schedule work manager
+     *                    sync requests.
+     * @param providers Set of valid providers we can sync search results from.
+     */
+    private static void scheduleSyncWithCloudProvider(
+            @NonNull SearchRequest searchRequest,
+            int searchRequestId,
+            @NonNull PickerSyncManager syncManager,
+            @NonNull Set<String> providers) {
+        final PickerSyncController syncController = PickerSyncController.getInstanceOrThrow();
+        final String cloudAuthority =
+                syncController.getCloudProviderOrDefault(/* defaultValue */ null);
+
+        if (!syncController.shouldQueryCloudMediaForSearch(providers, cloudAuthority)) {
+            Log.d(TAG, "Search is not enabled for the current cloud authority. "
+                    + "Not syncing search results with cloud provider for request id "
+                    + searchRequestId);
+            return;
+        }
+
+        if (searchRequest instanceof SearchSuggestionRequest) {
+            final SearchSuggestion suggestion =
+                    ((SearchSuggestionRequest) searchRequest).getSearchSuggestion();
+            if (suggestion.getSearchSuggestionType() == SEARCH_SUGGESTION_ALBUM) {
+                if (!cloudAuthority.equals(suggestion.getAuthority())) {
+                    Log.d(TAG, "Album search suggestion does not belong to cloud provider. "
+                            + "Not syncing search results with cloud provider for request id "
+                            + searchRequestId);
+                    return;
+                }
+            }
         }
+
+        syncManager.syncSearchResultsForProvider(
+                searchRequestId,
+                PickerSyncManager.SYNC_CLOUD_ONLY,
+                cloudAuthority);
+    }
+
+    /**
+     * @param searchRequestId Identifier of a search request.
+     * @return A response bundle containing the search request id.
+     */
+    @NonNull
+    private static Bundle getSearchRequestInitResponse(int searchRequestId) {
+        final Bundle response = new Bundle();
+        response.putInt("search_request_id", searchRequestId);
+        return response;
     }
 }
diff --git a/src/com/android/providers/media/photopicker/v2/PickerUriResolverV2.java b/src/com/android/providers/media/photopicker/v2/PickerUriResolverV2.java
index a15c7ee32..3667c7631 100644
--- a/src/com/android/providers/media/photopicker/v2/PickerUriResolverV2.java
+++ b/src/com/android/providers/media/photopicker/v2/PickerUriResolverV2.java
@@ -42,9 +42,10 @@ public class PickerUriResolverV2 {
     public static final String MEDIA_PATH_SEGMENT = "media";
     public static final String ALBUM_PATH_SEGMENT = "album";
     public static final String UPDATE_PATH_SEGMENT = "update";
-    public static final String MEDIA_GRANTS_COUNT_PATH_SEGMENT = "media_grants_count";
-    public static final String PREVIEW_PATH_SEGMENT = "preview";
-    public static final String PRE_SELECTION_PATH_SEGMENT = "pre_selection";
+    private static final String MEDIA_GRANTS_COUNT_PATH_SEGMENT = "media_grants_count";
+    private static final String PREVIEW_PATH_SEGMENT = "preview";
+    private static final String PRE_SELECTION_PATH_SEGMENT = "pre_selection";
+    private static final String SEARCH_RESULT_MEDIA_PATH_SEGMENT = "search_media";
 
 
     static final UriMatcher sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
@@ -56,6 +57,7 @@ public class PickerUriResolverV2 {
     static final int PICKER_INTERNAL_MEDIA_GRANTS_COUNT = 6;
     static final int PICKER_INTERNAL_MEDIA_PREVIEW = 7;
     static final int PICKER_INTERNAL_PRE_SELECTION = 8;
+    static final int PICKER_INTERNAL_SEARCH_MEDIA = 9;
 
     @Retention(RetentionPolicy.SOURCE)
     @IntDef({
@@ -68,6 +70,7 @@ public class PickerUriResolverV2 {
             PICKER_INTERNAL_MEDIA_GRANTS_COUNT,
             PICKER_INTERNAL_MEDIA_PREVIEW,
             PICKER_INTERNAL_PRE_SELECTION,
+            PICKER_INTERNAL_SEARCH_MEDIA,
     })
     private @interface PickerQuery {}
 
@@ -99,6 +102,11 @@ public class PickerUriResolverV2 {
         sUriMatcher.addURI(MediaStore.AUTHORITY,
                 BASE_PICKER_PATH + MEDIA_PATH_SEGMENT + "/" + PRE_SELECTION_PATH_SEGMENT,
                 PICKER_INTERNAL_PRE_SELECTION);
+        sUriMatcher.addURI(
+                MediaStore.AUTHORITY,
+                BASE_PICKER_PATH + SEARCH_RESULT_MEDIA_PATH_SEGMENT + "/*",
+                PICKER_INTERNAL_SEARCH_MEDIA
+        );
     }
 
     /**
@@ -135,6 +143,13 @@ public class PickerUriResolverV2 {
                 return PickerDataLayerV2.queryPreviewMedia(appContext, queryArgs);
             case PICKER_INTERNAL_PRE_SELECTION:
                 return PickerDataLayerV2.queryMediaForPreSelection(appContext, queryArgs);
+            case PICKER_INTERNAL_SEARCH_MEDIA:
+                final int searchRequestId =
+                        Integer.parseInt(requireNonNull(uri.getLastPathSegment()));
+                return PickerDataLayerV2.querySearchMedia(
+                        appContext,
+                        requireNonNull(queryArgs),
+                        searchRequestId);
             default:
                 throw new UnsupportedOperationException("Could not recognize content URI " + uri);
         }
diff --git a/src/com/android/providers/media/photopicker/v2/SearchSuggestionsProvider.java b/src/com/android/providers/media/photopicker/v2/SearchSuggestionsProvider.java
new file mode 100644
index 000000000..80f2e1b51
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/SearchSuggestionsProvider.java
@@ -0,0 +1,238 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2;
+
+import static android.provider.MediaStore.MY_USER_ID;
+
+import static androidx.annotation.VisibleForTesting.PACKAGE_PRIVATE;
+
+import static java.util.Objects.requireNonNull;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.database.MatrixCursor;
+import android.os.CancellationSignal;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+
+import com.android.providers.media.PickerUriResolver;
+import com.android.providers.media.photopicker.PickerSyncController;
+import com.android.providers.media.photopicker.SearchState;
+import com.android.providers.media.photopicker.sync.PickerSearchProviderClient;
+import com.android.providers.media.photopicker.v2.model.SearchSuggestion;
+import com.android.providers.media.photopicker.v2.sqlite.PickerSQLConstants;
+import com.android.providers.media.photopicker.v2.sqlite.SearchSuggestionsDatabaseUtils;
+import com.android.providers.media.photopicker.v2.sqlite.SearchSuggestionsQuery;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Class that encapsulates logic to provide search suggestions.
+ */
+public class SearchSuggestionsProvider {
+    private static final String TAG = "SearchSuggestionsProvider";
+
+    /**
+     * Caches input search suggestions if they are zero state suggestions.
+     *
+     * @param query SearchSuggestionsQuery object
+     * @param suggestions List of search suggestions received from a cloud media provider.
+     * @return true if the suggestions were cached, else returns false.
+     */
+    @VisibleForTesting(otherwise = PACKAGE_PRIVATE)
+    public static boolean maybeCacheSearchSuggestions(
+            @NonNull SearchSuggestionsQuery query,
+            @Nullable List<SearchSuggestion> suggestions) {
+        if (!query.isZeroState()) {
+            Log.d(TAG, "Skip caching search suggestions for non-zero state");
+            return false;
+        }
+
+        if (suggestions == null || suggestions.isEmpty()) {
+            Log.d(TAG, "Received no suggestions to cache.");
+            return false;
+        }
+
+        final String authority = suggestions.get(0).getAuthority();
+
+        try {
+            final int numberOfInsertedRows = SearchSuggestionsDatabaseUtils.cacheSearchSuggestions(
+                    PickerSyncController.getInstanceOrThrow().getDbFacade().getDatabase(),
+                    authority,
+                    suggestions);
+
+            Log.d(TAG, String.format("Cached %d search suggestions from authority %s",
+                    numberOfInsertedRows, authority));
+            return true;
+        } catch (RuntimeException e) {
+            Log.e(TAG, String.format("Could not cache search suggestions from authority %s",
+                    authority));
+            return false;
+        }
+    }
+
+    /**
+     * Converts suggestions to a cursor with
+     * {@link PickerSQLConstants.SearchSuggestionsResponseColumns}
+     *
+     * @param suggestions Input list of suggestions.
+     * @return a cursor with formatted suggestions.
+     */
+    @VisibleForTesting(otherwise = PACKAGE_PRIVATE)
+    public static Cursor suggestionsToCursor(
+            @NonNull List<SearchSuggestion> suggestions) {
+        requireNonNull(suggestions);
+
+        final MatrixCursor cursor = new MatrixCursor(List.of(
+                PickerSQLConstants.SearchSuggestionsResponseColumns.AUTHORITY.getProjection(),
+                PickerSQLConstants.SearchSuggestionsResponseColumns.MEDIA_SET_ID.getProjection(),
+                PickerSQLConstants.SearchSuggestionsResponseColumns.SEARCH_TEXT.getProjection(),
+                PickerSQLConstants.SearchSuggestionsResponseColumns.SUGGESTION_TYPE.getProjection(),
+                PickerSQLConstants.SearchSuggestionsResponseColumns.COVER_MEDIA_ID.getProjection()
+        ).toArray(new String[5]));
+
+        for (SearchSuggestion suggestion : suggestions) {
+            final String coverMediaUri;
+            if (suggestion.getAuthority() != null && suggestion.getCoverMediaId() != null) {
+                coverMediaUri = PickerUriResolver
+                        .getMediaUri(MY_USER_ID + "@" + suggestion.getAuthority())
+                        .buildUpon().appendPath(suggestion.getCoverMediaId())
+                        .build().toString();
+            } else {
+                coverMediaUri = null;
+            }
+
+            final ArrayList<Object> row = new ArrayList<Object>();
+            row.add(suggestion.getAuthority());
+            row.add(suggestion.getMediaSetId());
+            row.add(suggestion.getSearchText());
+            row.add(suggestion.getSearchSuggestionType());
+            row.add(coverMediaUri);
+            cursor.addRow(row.toArray(new Object[5]));
+        }
+
+        return cursor;
+    }
+
+    static List<SearchSuggestion> getDefaultSuggestions() {
+        //TODO(b/378511004) to be implemented
+        return new ArrayList<>();
+    }
+
+    /**
+     * Fetches suggestions from a cloud provider.
+     *
+     * @param appContext Application context.
+     * @param query A SearchSuggestionsQuery object.
+     * @param cancellationSignal CancellationSignal that helps you propagate that the query has been
+     *                          cancelled.
+     * @return A list of valid search suggestions received from the cloud provider.
+     */
+    @VisibleForTesting(otherwise = PACKAGE_PRIVATE)
+    @NonNull
+    public static List<SearchSuggestion> getSuggestionsFromCloudProvider(
+            @NonNull Context appContext,
+            @NonNull SearchSuggestionsQuery query,
+            @Nullable CancellationSignal cancellationSignal) {
+        final PickerSyncController syncController = PickerSyncController.getInstanceOrThrow();
+        final SearchState searchState = syncController.getSearchState();
+        final String cloudAuthority = syncController
+                .getCloudProviderOrDefault(/* defaultValue */ null);
+
+        final String effectiveCloudAuthority =
+                (syncController.shouldQueryCloudMedia(query.getProviderAuthorities(),
+                        cloudAuthority) && searchState.isCloudSearchEnabled(appContext))
+                        ? cloudAuthority
+                        : null;
+
+        if (effectiveCloudAuthority == null) {
+            return new ArrayList<>();
+        }
+
+        return getSuggestionsFromCmp(appContext, query, effectiveCloudAuthority,
+                cancellationSignal);
+    }
+
+    /**
+     * Fetches suggestions from a local provider.
+     *
+     * @param appContext Application context.
+     * @param query A SearchSuggestionsQuery object.
+     * @param cancellationSignal CancellationSignal that helps you propagate that the query has been
+     *                          cancelled.
+     * @return A list of valid search suggestions received from the local provider.
+     */
+    @VisibleForTesting(otherwise = PACKAGE_PRIVATE)
+    @NonNull
+    public static List<SearchSuggestion> getSuggestionsFromLocalProvider(
+            @NonNull Context appContext,
+            @NonNull SearchSuggestionsQuery query,
+            @Nullable CancellationSignal cancellationSignal) {
+        final PickerSyncController syncController = PickerSyncController.getInstanceOrThrow();
+        final SearchState searchState = syncController.getSearchState();
+
+        final String effectiveLocalAuthority =
+                (query.getProviderAuthorities().contains(syncController.getLocalProvider())
+                        && searchState.isLocalSearchEnabled())
+                        ? syncController.getLocalProvider()
+                        : null;
+
+        if (effectiveLocalAuthority == null) {
+            return new ArrayList<>();
+        }
+
+        return getSuggestionsFromCmp(appContext, query, effectiveLocalAuthority,
+                cancellationSignal);
+    }
+
+    /**
+     * Fetches suggestions from a cloud media provider. This should be an asynchronous call because
+     * it might take a while to fetch the results. It is recommended to cancel the request using
+     * input CancellationSignal when the results are no longer needed.
+     *
+     * @param appContext Application context.
+     * @param query A SearchSuggestionsQuery object.
+     * @param cancellationSignal CancellationSignal that helps you propagate that the query has been
+     *                          cancelled.
+     * @param authority Authority of the cloud media provider. This could be the authority of the
+     *                  local provider or the cloud provider.
+     * @return A list of valid search suggestions received from the cloud media provider.
+     */
+    @NonNull
+    private static List<SearchSuggestion> getSuggestionsFromCmp(
+            @NonNull Context appContext,
+            @NonNull SearchSuggestionsQuery query,
+            @NonNull String authority,
+            @Nullable CancellationSignal cancellationSignal) {
+        final PickerSearchProviderClient searchClient =
+                PickerSearchProviderClient.create(appContext, authority);
+
+        try (Cursor cursor = searchClient.fetchSearchSuggestionsFromCmp(
+                query.getPrefix(), query.getLimit(), cancellationSignal)) {
+
+            if (cursor != null) {
+                return SearchSuggestionsDatabaseUtils.extractSearchSuggestions(cursor, authority);
+            }
+        }
+
+        return new ArrayList<>();
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/v2/model/AlbumMediaQuery.java b/src/com/android/providers/media/photopicker/v2/model/AlbumMediaQuery.java
index 06bfe9cad..10079537b 100644
--- a/src/com/android/providers/media/photopicker/v2/model/AlbumMediaQuery.java
+++ b/src/com/android/providers/media/photopicker/v2/model/AlbumMediaQuery.java
@@ -18,6 +18,7 @@ package com.android.providers.media.photopicker.v2.model;
 
 import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_ALBUM_ID;
 import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_CLOUD_ID;
+import static com.android.providers.media.photopicker.v2.sqlite.MediaProjection.prependTableName;
 
 import static java.util.Objects.requireNonNull;
 
@@ -26,7 +27,10 @@ import android.os.Bundle;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
-import com.android.providers.media.photopicker.v2.SelectSQLiteQueryBuilder;
+import com.android.providers.media.photopicker.v2.sqlite.PickerSQLConstants;
+import com.android.providers.media.photopicker.v2.sqlite.SelectSQLiteQueryBuilder;
+
+import java.util.Locale;
 
 /**
  * This is a convenience class for Album content related SQL queries performed on the Picker
@@ -67,17 +71,26 @@ public class AlbumMediaQuery extends MediaQuery {
     @Override
     public void addWhereClause(
             @NonNull SelectSQLiteQueryBuilder queryBuilder,
+            @NonNull PickerSQLConstants.Table table,
             @Nullable String localAuthority,
             @Nullable String cloudAuthority,
             boolean reverseOrder
     ) {
-        super.addWhereClause(queryBuilder, localAuthority, cloudAuthority, reverseOrder);
+        super.addWhereClause(queryBuilder, table, localAuthority, cloudAuthority, reverseOrder);
 
-        queryBuilder.appendWhereStandalone(KEY_ALBUM_ID + " = '" + mAlbumId + "'");
+        queryBuilder.appendWhereStandalone(
+                String.format(
+                        Locale.ROOT,
+                        "%s = '%s'",
+                        prependTableName(table, KEY_ALBUM_ID),
+                        mAlbumId
+                )
+        );
 
         // Don't include cloud items if the album authority is not equal to the cloud authority.
         if (!mAlbumAuthority.equals(cloudAuthority)) {
-            queryBuilder.appendWhereStandalone(KEY_CLOUD_ID + " IS NULL");
+            queryBuilder.appendWhereStandalone(
+                    prependTableName(table, KEY_CLOUD_ID) + " IS NULL");
         }
     }
 }
diff --git a/src/com/android/providers/media/photopicker/v2/model/AlbumsCursorWrapper.java b/src/com/android/providers/media/photopicker/v2/model/AlbumsCursorWrapper.java
index 04a632a6d..ca82f6db4 100644
--- a/src/com/android/providers/media/photopicker/v2/model/AlbumsCursorWrapper.java
+++ b/src/com/android/providers/media/photopicker/v2/model/AlbumsCursorWrapper.java
@@ -33,7 +33,7 @@ import androidx.annotation.Nullable;
 
 import com.android.providers.media.PickerUriResolver;
 import com.android.providers.media.photopicker.v2.PickerDataLayerV2;
-import com.android.providers.media.photopicker.v2.PickerSQLConstants;
+import com.android.providers.media.photopicker.v2.sqlite.PickerSQLConstants;
 
 /**
  * A wrapper for Albums cursor to map a value from the cursor received from CMP to the value in the
diff --git a/src/com/android/providers/media/photopicker/v2/model/FavoritesMediaQuery.java b/src/com/android/providers/media/photopicker/v2/model/FavoritesMediaQuery.java
index dfd34a899..c867bd0fc 100644
--- a/src/com/android/providers/media/photopicker/v2/model/FavoritesMediaQuery.java
+++ b/src/com/android/providers/media/photopicker/v2/model/FavoritesMediaQuery.java
@@ -19,6 +19,7 @@ package com.android.providers.media.photopicker.v2.model;
 import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_CLOUD_ID;
 import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_IS_FAVORITE;
 import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_LOCAL_ID;
+import static com.android.providers.media.photopicker.v2.sqlite.MediaProjection.prependTableName;
 
 import android.database.sqlite.SQLiteQueryBuilder;
 import android.os.Bundle;
@@ -26,7 +27,10 @@ import android.os.Bundle;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
-import com.android.providers.media.photopicker.v2.SelectSQLiteQueryBuilder;
+import com.android.providers.media.photopicker.v2.sqlite.PickerSQLConstants;
+import com.android.providers.media.photopicker.v2.sqlite.SelectSQLiteQueryBuilder;
+
+import java.util.Locale;
 
 /**
  * This is a convenience class for Favorites album related SQL queries performed on the Picker
@@ -51,14 +55,15 @@ public class FavoritesMediaQuery extends MediaQuery {
     @Override
     public void addWhereClause(
             @NonNull SelectSQLiteQueryBuilder queryBuilder,
+            @NonNull PickerSQLConstants.Table table,
             @Nullable String localAuthority,
             @Nullable String cloudAuthority,
             boolean reverseOrder) {
-        super.addWhereClause(queryBuilder, localAuthority, cloudAuthority, reverseOrder);
+        super.addWhereClause(queryBuilder, table, localAuthority, cloudAuthority, reverseOrder);
 
         final String localFavoriteMediaWhereClause =
-                getLocalFavoriteMediaWhereClause(queryBuilder, cloudAuthority);
-        final String cloudFavoriteMediaWhereClause = getCloudFavoriteMediaWhereClause();
+                getLocalFavoriteMediaWhereClause(queryBuilder, table, cloudAuthority);
+        final String cloudFavoriteMediaWhereClause = getCloudFavoriteMediaWhereClause(table);
 
         final String favoriteMediaWhereClause = (localFavoriteMediaWhereClause
                 + " OR " + cloudFavoriteMediaWhereClause);
@@ -67,16 +72,24 @@ public class FavoritesMediaQuery extends MediaQuery {
 
     private String getLocalFavoriteMediaWhereClause(
             @NonNull SelectSQLiteQueryBuilder queryBuilder,
+            @NonNull PickerSQLConstants.Table table,
             @Nullable String cloudAuthority) {
         if (cloudAuthority == null) {
-            return "(" + KEY_IS_FAVORITE + " = 1 AND " + KEY_CLOUD_ID + " IS NULL)";
+            return String.format(
+                    Locale.ROOT,
+                    "(%s = 1 AND %s IS NULL)",
+                    prependTableName(table, KEY_IS_FAVORITE),
+                    prependTableName(table, KEY_CLOUD_ID)
+            );
         } else {
             // Select all the deduped local media items that have been marked as favorite in the
             // local media provider or the cloud media provider.
             final String[] columns = new String[1];
-            columns[0] = KEY_LOCAL_ID;
-            final String localMediaWhereClause = KEY_LOCAL_ID + " IS NOT NULL";
-            final String favoriteMediaWhereClause = KEY_IS_FAVORITE + " = 1";
+            columns[0] = prependTableName(table, KEY_LOCAL_ID);
+            final String localMediaWhereClause =
+                    prependTableName(table, KEY_LOCAL_ID) + " IS NOT NULL";
+            final String favoriteMediaWhereClause =
+                    prependTableName(table, KEY_IS_FAVORITE) + " = 1";
 
             final String innerQuery = SQLiteQueryBuilder.buildQueryString(
                     /* distinct */ true,
@@ -89,11 +102,17 @@ public class FavoritesMediaQuery extends MediaQuery {
                     /* limit */ null
             );
 
-            return "(" + KEY_LOCAL_ID + " IN (" + innerQuery + "))";
+            return String.format(Locale.ROOT,
+                    "(%s IN (%s))",
+                    prependTableName(table, KEY_LOCAL_ID),
+                    innerQuery);
         }
     }
 
-    private String getCloudFavoriteMediaWhereClause() {
-        return "(" + KEY_IS_FAVORITE + " = 1 AND " + KEY_LOCAL_ID + " IS NULL)";
+    private String getCloudFavoriteMediaWhereClause(@NonNull PickerSQLConstants.Table table) {
+        return String.format(Locale.ROOT,
+                "(%s = 1 AND %s IS NULL)",
+                prependTableName(table, KEY_IS_FAVORITE),
+                prependTableName(table, KEY_LOCAL_ID));
     }
 }
diff --git a/src/com/android/providers/media/photopicker/v2/model/MediaGroup.java b/src/com/android/providers/media/photopicker/v2/model/MediaGroup.java
new file mode 100644
index 000000000..c2e0a9d13
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/model/MediaGroup.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.model;
+
+/**
+ * Represents types of media group objects.
+ */
+public enum MediaGroup {
+    CATEGORY,
+    MEDIA_SET,
+    ALBUM
+}
diff --git a/src/com/android/providers/media/photopicker/v2/model/MediaQuery.java b/src/com/android/providers/media/photopicker/v2/model/MediaQuery.java
index 59105279c..f04f804b0 100644
--- a/src/com/android/providers/media/photopicker/v2/model/MediaQuery.java
+++ b/src/com/android/providers/media/photopicker/v2/model/MediaQuery.java
@@ -28,6 +28,7 @@ import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_IS
 import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_LOCAL_ID;
 import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_MIME_TYPE;
 import static com.android.providers.media.photopicker.v2.PickerDataLayerV2.CURRENT_GRANTS_TABLE;
+import static com.android.providers.media.photopicker.v2.sqlite.MediaProjection.prependTableName;
 
 import android.content.Context;
 import android.content.Intent;
@@ -40,7 +41,8 @@ import androidx.annotation.Nullable;
 
 import com.android.providers.media.MediaGrants;
 import com.android.providers.media.photopicker.v2.PickerDataLayerV2;
-import com.android.providers.media.photopicker.v2.SelectSQLiteQueryBuilder;
+import com.android.providers.media.photopicker.v2.sqlite.PickerSQLConstants;
+import com.android.providers.media.photopicker.v2.sqlite.SelectSQLiteQueryBuilder;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -173,6 +175,7 @@ public class MediaQuery {
                 CURRENT_GRANTS_TABLE);
 
         return String.format(
+                Locale.ROOT,
                 "%s LEFT JOIN %s"
                         + " ON %s.%s = %s.%s ",
                 table,
@@ -187,6 +190,7 @@ public class MediaQuery {
     /**
      * @param queryBuilder Adds SQL query where clause based on the Media query arguments to the
      *                     given query builder.
+     * @param table The SQL table that is being used to fetch media metadata.
      * @param localAuthority the authority of the local provider if we should include local media in
      *                       the query response. Otherwise, this is null.
      * @param cloudAuthority The authority of the cloud provider if we should include cloud media in
@@ -198,30 +202,35 @@ public class MediaQuery {
      */
     public void addWhereClause(
             @NonNull SelectSQLiteQueryBuilder queryBuilder,
+            @NonNull PickerSQLConstants.Table table,
             @Nullable String localAuthority,
             @Nullable String cloudAuthority,
             boolean reverseOrder
     ) {
         if (mShouldDedupe) {
-            queryBuilder.appendWhereStandalone(KEY_IS_VISIBLE + " = 1");
+            queryBuilder.appendWhereStandalone(
+                    prependTableName(table, KEY_IS_VISIBLE) + " = 1");
         }
 
         if (cloudAuthority == null) {
-            queryBuilder.appendWhereStandalone(KEY_CLOUD_ID + " IS NULL");
+            queryBuilder.appendWhereStandalone(
+                    prependTableName(table, KEY_CLOUD_ID) + " IS NULL");
         }
 
         if (localAuthority == null) {
-            queryBuilder.appendWhereStandalone(KEY_LOCAL_ID + " IS NULL");
+            queryBuilder.appendWhereStandalone(
+                    prependTableName(table, KEY_CLOUD_ID) + " IS NOT NULL");
         }
 
-        addMimeTypeClause(queryBuilder);
-        addDateTakenClause(queryBuilder, reverseOrder);
+        addMimeTypeClause(queryBuilder, table);
+        addDateTakenClause(queryBuilder, table, reverseOrder);
     }
 
     /**
      * Adds the date taken clause to the given query builder.
      *
      * @param queryBuilder SelectSQLiteQueryBuilder to add the where clause
+     * @param table The SQL table that is being used to fetch media metadata.
      * @param reverseOrder Since the media results are sorted by (Date taken DESC, Picker ID DESC),
      *                     this field is true when the query is made in the reverse order of the
      *                     expected sort order i.e. (Date taken ASC, Picker ID ASC),
@@ -229,18 +238,23 @@ public class MediaQuery {
      */
     private void addDateTakenClause(
             @NonNull SelectSQLiteQueryBuilder queryBuilder,
+            @NonNull PickerSQLConstants.Table table,
             boolean reverseOrder
     ) {
         if (reverseOrder) {
             queryBuilder.appendWhereStandalone(
-                        KEY_DATE_TAKEN_MS + " > " + mDateTakenMs
-                        + " OR ( " + KEY_DATE_TAKEN_MS + " = " + mDateTakenMs
-                        + " AND " + KEY_ID + " > " + mPickerId + ")");
+                    String.format(Locale.ROOT,
+                            "%s > %s OR (%s = %s AND %s > %s)",
+                            prependTableName(table, KEY_DATE_TAKEN_MS), mDateTakenMs,
+                            prependTableName(table, KEY_DATE_TAKEN_MS), mDateTakenMs,
+                            prependTableName(table, KEY_ID), mPickerId));
         } else {
             queryBuilder.appendWhereStandalone(
-                        KEY_DATE_TAKEN_MS + " < " + mDateTakenMs
-                        + " OR ( " + KEY_DATE_TAKEN_MS + " = " + mDateTakenMs
-                        + " AND " + KEY_ID + " <= " + mPickerId + ")");
+                    String.format(Locale.ROOT,
+                            "%s < %s OR (%s = %s AND %s <= %s)",
+                            prependTableName(table, KEY_DATE_TAKEN_MS), mDateTakenMs,
+                            prependTableName(table, KEY_DATE_TAKEN_MS), mDateTakenMs,
+                            prependTableName(table, KEY_ID), mPickerId));
         }
     }
 
@@ -249,7 +263,9 @@ public class MediaQuery {
      *
      * @param queryBuilder SelectSQLiteQueryBuilder to add the where clause.
      */
-    private void addMimeTypeClause(@NonNull SelectSQLiteQueryBuilder queryBuilder) {
+    private void addMimeTypeClause(
+            @NonNull SelectSQLiteQueryBuilder queryBuilder,
+            @NonNull PickerSQLConstants.Table table) {
         if (mMimeTypes == null || mMimeTypes.isEmpty()) {
             return;
         }
@@ -257,9 +273,22 @@ public class MediaQuery {
         List<String> whereClauses = new ArrayList<>();
         for (String mimeType : mMimeTypes) {
             if (!TextUtils.isEmpty(mimeType)) {
-                whereClauses.add(KEY_MIME_TYPE + " LIKE '" + mimeType.replace('*', '%') + "'");
+                whereClauses.add(
+                        String.format(
+                                Locale.ROOT,
+                                "%s LIKE '%s'",
+                                prependTableName(table, KEY_MIME_TYPE),
+                                mimeType.replace(/* oldChar */ '*', /* newChar */ '%')
+                        )
+                );
             }
         }
-        queryBuilder.appendWhereStandalone(" ( " + TextUtils.join(" OR ", whereClauses) + " ) ");
+        queryBuilder.appendWhereStandalone(
+                String.format(
+                        Locale.ROOT,
+                        " ( %s ) ",
+                        TextUtils.join(" OR ", whereClauses)
+                )
+        );
     }
 }
diff --git a/src/com/android/providers/media/photopicker/v2/model/MediaQueryForPreSelection.java b/src/com/android/providers/media/photopicker/v2/model/MediaQueryForPreSelection.java
index 95a1fc583..02ff888ea 100644
--- a/src/com/android/providers/media/photopicker/v2/model/MediaQueryForPreSelection.java
+++ b/src/com/android/providers/media/photopicker/v2/model/MediaQueryForPreSelection.java
@@ -18,6 +18,7 @@ package com.android.providers.media.photopicker.v2.model;
 
 import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_CLOUD_ID;
 import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_LOCAL_ID;
+import static com.android.providers.media.photopicker.v2.sqlite.MediaProjection.prependTableName;
 
 import android.content.Context;
 import android.net.Uri;
@@ -28,7 +29,8 @@ import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
 import com.android.providers.media.PickerUriResolver;
-import com.android.providers.media.photopicker.v2.SelectSQLiteQueryBuilder;
+import com.android.providers.media.photopicker.v2.sqlite.PickerSQLConstants;
+import com.android.providers.media.photopicker.v2.sqlite.SelectSQLiteQueryBuilder;
 
 import java.util.ArrayList;
 import java.util.HashSet;
@@ -61,21 +63,24 @@ public class MediaQueryForPreSelection extends MediaQuery {
     @Override
     public void addWhereClause(
             @NonNull SelectSQLiteQueryBuilder queryBuilder,
+            @NonNull PickerSQLConstants.Table table,
             @Nullable String localAuthority,
             @Nullable String cloudAuthority,
             boolean reverseOrder
     ) {
-        super.addWhereClause(queryBuilder, localAuthority, cloudAuthority, reverseOrder);
+        super.addWhereClause(queryBuilder, table, localAuthority, cloudAuthority, reverseOrder);
 
-        String idSelection = addIdSelectionClause(cloudAuthority);
+        String idSelection = addIdSelectionClause(table, cloudAuthority);
         queryBuilder.appendWhereStandalone(idSelection);
     }
 
-    private String addIdSelectionClause(@Nullable String cloudAuthority) {
+    private String addIdSelectionClause(
+            @NonNull PickerSQLConstants.Table table,
+            @Nullable String cloudAuthority) {
 
         StringBuilder idSelectionClause = new StringBuilder();
 
-        idSelectionClause.append(KEY_LOCAL_ID).append(" IN (\'");
+        idSelectionClause.append(prependTableName(table, KEY_LOCAL_ID)).append(" IN (\'");
         idSelectionClause.append(String.join("\',\'", mLocalIdSelection));
         idSelectionClause.append("\')");
 
@@ -83,7 +88,7 @@ public class MediaQueryForPreSelection extends MediaQuery {
             if (!idSelectionClause.toString().isEmpty()) {
                 idSelectionClause.append(" OR ");
             }
-            idSelectionClause.append(KEY_CLOUD_ID).append(" IN (\'");
+            idSelectionClause.append(prependTableName(table, KEY_CLOUD_ID)).append(" IN (\'");
             idSelectionClause.append(String.join("\',\'", mCloudIdSelection));
             idSelectionClause.append("\')");
         }
diff --git a/src/com/android/providers/media/photopicker/v2/model/MediaSetsSyncRequestParams.java b/src/com/android/providers/media/photopicker/v2/model/MediaSetsSyncRequestParams.java
new file mode 100644
index 000000000..821306bc3
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/model/MediaSetsSyncRequestParams.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.model;
+
+import android.os.Bundle;
+
+import androidx.annotation.NonNull;
+
+import java.util.Objects;
+
+/*
+ A class to extract out all the required input parameters for syncing media sets with the given
+ provider.
+ */
+public class MediaSetsSyncRequestParams {
+
+    private final String mAuthority;
+    private final String mCategoryId;
+    private final String[] mMimeTypes;
+
+    public MediaSetsSyncRequestParams(@NonNull Bundle extras) {
+        Objects.requireNonNull(extras);
+        mAuthority = extras.getString("authority");
+        mMimeTypes = extras.getStringArray("mime_types");
+        mCategoryId = extras.getString("category_id");
+    }
+
+    public String getAuthority() {
+        return mAuthority;
+    }
+
+    public String getCategoryId() {
+        return mCategoryId;
+    }
+
+    public String[] getMimeTypes() {
+        return mMimeTypes;
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/v2/model/PreviewMediaQuery.java b/src/com/android/providers/media/photopicker/v2/model/PreviewMediaQuery.java
index 324b20a3b..b1797ace1 100644
--- a/src/com/android/providers/media/photopicker/v2/model/PreviewMediaQuery.java
+++ b/src/com/android/providers/media/photopicker/v2/model/PreviewMediaQuery.java
@@ -40,7 +40,8 @@ import androidx.annotation.Nullable;
 
 import com.android.providers.media.MediaGrants;
 import com.android.providers.media.photopicker.PickerSyncController;
-import com.android.providers.media.photopicker.v2.SelectSQLiteQueryBuilder;
+import com.android.providers.media.photopicker.v2.sqlite.PickerSQLConstants;
+import com.android.providers.media.photopicker.v2.sqlite.SelectSQLiteQueryBuilder;
 
 import java.util.ArrayList;
 import java.util.Locale;
@@ -75,11 +76,12 @@ public class PreviewMediaQuery extends MediaQuery {
     @Override
     public void addWhereClause(
             @NonNull SelectSQLiteQueryBuilder queryBuilder,
+            @NonNull PickerSQLConstants.Table table,
             @Nullable String localAuthority,
             @Nullable String cloudAuthority,
             boolean reverseOrder
     ) {
-        super.addWhereClause(queryBuilder, localAuthority, cloudAuthority, reverseOrder);
+        super.addWhereClause(queryBuilder, table, localAuthority, cloudAuthority, reverseOrder);
 
         addIdSelectionClause(queryBuilder);
     }
@@ -98,7 +100,9 @@ public class PreviewMediaQuery extends MediaQuery {
         }
 
         idSelectionPlaceholder.append(
-                String.format("(%s.%s IS NOT NULL AND %s.%s IS NULL)",
+                String.format(
+                        Locale.ROOT,
+                        "(%s.%s IS NOT NULL AND %s.%s IS NULL)",
                         // current_media_grants.file_id IS NOT NULL
                         CURRENT_GRANTS_TABLE, MediaGrants.FILE_ID_COLUMN,
                         // current_de_selections.file_id IS NULL
@@ -163,6 +167,7 @@ public class PreviewMediaQuery extends MediaQuery {
                 CURRENT_DE_SELECTIONS_TABLE);
 
         return String.format(
+                Locale.ROOT,
                 "%s LEFT JOIN %s"
                         + " ON %s.%s = %s.%s "
                         + "LEFT JOIN %s"
diff --git a/src/com/android/providers/media/photopicker/v2/model/SearchRequest.java b/src/com/android/providers/media/photopicker/v2/model/SearchRequest.java
new file mode 100644
index 000000000..c4478aac9
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/model/SearchRequest.java
@@ -0,0 +1,150 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.model;
+
+import android.os.Bundle;
+
+import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Locale;
+
+/**
+ * Represents a user initiated search request. Each search request needs to be served with search
+ * results data. This class and it's sub-classes contains properties of a search request.
+ */
+public abstract class SearchRequest {
+    @VisibleForTesting
+    public static final String DELIMITER = ";";
+    // A list of mime type filters all in lowercase, sorted by natural order.
+    @Nullable
+    protected final List<String> mMimeTypes;
+    @Nullable
+    protected String mResumeKey;
+
+    /**
+     * Creates an instance of {@link SearchRequest}.
+     *
+     * @param extras Bundle with input parameters.
+     * @return A new instance of {@link SearchRequest}.
+     */
+    public static SearchRequest create(Bundle extras) {
+        final List<String> mimeTypes = extras.getStringArrayList("mime_types") != null
+                ? new ArrayList<>(extras.getStringArrayList("mime_types")) : null;
+        final String searchText = extras.getString("search_text");
+        final String mediaSetId = extras.getString("media_set_id");
+        final String suggestionAuthority = extras.getString("authority");
+        final String searchSuggestionType = extras.getString("search_suggestion_type");
+
+        if (searchSuggestionType != null) {
+            return new SearchSuggestionRequest(
+                mimeTypes,
+                searchText,
+                mediaSetId,
+                suggestionAuthority,
+                searchSuggestionType,
+                /* resumeKey */ null
+            );
+        } else {
+            return new SearchTextRequest(
+                    mimeTypes,
+                    searchText
+            );
+        }
+    }
+
+    protected SearchRequest(@Nullable List<String> rawMimeTypes) {
+        this (
+                rawMimeTypes,
+                /* resumeKey */ null
+        );
+    }
+
+    protected SearchRequest(
+            @Nullable String rawMimeTypes,
+            @Nullable String resumeKey
+    ) {
+        this (getMimeTypesAsList(rawMimeTypes), resumeKey);
+    }
+
+    protected SearchRequest(
+            @Nullable List<String> rawMimeTypes,
+            @Nullable String resumeKey
+    ) {
+        if (rawMimeTypes != null) {
+            mMimeTypes = new ArrayList<>();
+            for (String mimeType : rawMimeTypes) {
+                mMimeTypes.add(mimeType.toLowerCase(Locale.ROOT));
+            }
+            mMimeTypes.sort(Comparator.naturalOrder());
+        } else {
+            mMimeTypes = null;
+        }
+
+        mResumeKey = resumeKey;
+    }
+
+    /**
+     * Returns the list of mime type filters as String. The mimetypes are all in lower case and
+     * sorted by natural sort order. They're separated by a chosen delimiter
+     * {@link SearchRequest#DELIMITER}. List of mime types is saved in the database as a string.
+     * If the input is null, returns null.
+     */
+    @Nullable
+    public static String getMimeTypesAsString(@Nullable List<String> mimeTypes) {
+        if (mimeTypes == null) {
+            return null;
+        } else {
+            return String.join(DELIMITER, mimeTypes).toLowerCase(Locale.ROOT);
+        }
+    }
+
+    /**
+     * Converts a string of mime types to list. The mimetypes in the given string are expected to be
+     * separated by the chosen delimiter {@link SearchRequest#DELIMITER}.
+     * If the input is null, returns null.
+     */
+    @Nullable
+    public static List<String> getMimeTypesAsList(@Nullable String rawMimeTypes) {
+        if (rawMimeTypes == null || rawMimeTypes.trim().isEmpty()) {
+            return null;
+        }
+        return Arrays.asList(rawMimeTypes.split(DELIMITER));
+    }
+
+    @Nullable
+    public List<String> getMimeTypes() {
+        return mMimeTypes;
+    }
+
+    @Nullable
+    public String getResumeKey() {
+        return mResumeKey;
+    }
+
+    /**
+     * Set the resume key for a given search request.
+     */
+    public void setResumeKey(@Nullable String mResumeKey) {
+        this.mResumeKey = mResumeKey;
+    }
+}
+
diff --git a/src/com/android/providers/media/photopicker/v2/model/SearchSuggestion.java b/src/com/android/providers/media/photopicker/v2/model/SearchSuggestion.java
new file mode 100644
index 000000000..d72de686d
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/model/SearchSuggestion.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.model;
+
+import static java.util.Objects.requireNonNull;
+
+import android.provider.CloudMediaProviderContract.SearchSuggestionType;
+
+import androidx.annotation.Nullable;
+
+/**
+ * Represents a Search Suggestion.
+ */
+public class SearchSuggestion {
+    @Nullable
+    private final String mSearchText;
+    @Nullable
+    private final String mMediaSetId;
+    @Nullable
+    private final String mAuthority;
+    @SearchSuggestionType
+    private final String mSearchSuggestionType;
+    @Nullable
+    private final String mCoverMediaId;
+
+    public SearchSuggestion(
+            @Nullable String searchText,
+            @Nullable String mediaSetId,
+            @Nullable String authority,
+            @SearchSuggestionType String searchSuggestionType,
+            @Nullable String coverMediaId) {
+        mSearchText = searchText;
+        mMediaSetId = mediaSetId;
+        mAuthority = authority;
+        mSearchSuggestionType = requireNonNull(searchSuggestionType);
+        mCoverMediaId = coverMediaId;
+    }
+
+    @Nullable
+    public String getSearchText() {
+        return mSearchText;
+    }
+
+    @Nullable
+    public String getMediaSetId() {
+        return mMediaSetId;
+    }
+
+    @Nullable
+    public String getAuthority() {
+        return mAuthority;
+    }
+
+    @SearchSuggestionType
+    public String getSearchSuggestionType() {
+        return mSearchSuggestionType;
+    }
+
+    @Nullable
+    public String getCoverMediaId() {
+        return mCoverMediaId;
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/v2/model/SearchSuggestionRequest.java b/src/com/android/providers/media/photopicker/v2/model/SearchSuggestionRequest.java
new file mode 100644
index 000000000..3c4e023fa
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/model/SearchSuggestionRequest.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.model;
+
+import android.provider.CloudMediaProviderContract.SearchSuggestionType;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import java.util.List;
+
+/**
+ * Represents a user initiated search request by choosing a search suggestion.
+ */
+public class SearchSuggestionRequest extends SearchRequest {
+    @NonNull
+    private final SearchSuggestion mSearchSuggestion;
+
+    public SearchSuggestionRequest(
+            @Nullable List<String> mimeTypes,
+            @Nullable String searchText,
+            @NonNull String mediaSetId,
+            @NonNull String authority,
+            @SearchSuggestionType String searchSuggestionType,
+            @Nullable String resumeKey) {
+        this(mimeTypes, searchText, mediaSetId, authority, searchSuggestionType, resumeKey,
+                /* coverMediaSetId */ null);
+    }
+
+    public SearchSuggestionRequest(
+            @Nullable List<String> mimeTypes,
+            @Nullable String searchText,
+            @NonNull String mediaSetId,
+            @NonNull String authority,
+            @SearchSuggestionType String searchSuggestionType,
+            @Nullable String resumeKey,
+            @Nullable String coverMediaId) {
+        super(mimeTypes, resumeKey);
+
+        mSearchSuggestion = new SearchSuggestion(searchText, mediaSetId, authority,
+                searchSuggestionType, coverMediaId);
+    }
+
+    @NonNull
+    public SearchSuggestion getSearchSuggestion() {
+        return mSearchSuggestion;
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/v2/model/SearchTextRequest.java b/src/com/android/providers/media/photopicker/v2/model/SearchTextRequest.java
new file mode 100644
index 000000000..4306d7732
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/model/SearchTextRequest.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.model;
+
+import static java.util.Objects.requireNonNull;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import java.util.List;
+
+
+/**
+ * Represents a user initiated search request by entering search text.
+ */
+public class SearchTextRequest extends SearchRequest {
+    @NonNull
+    private final String mSearchText;
+
+    public SearchTextRequest(
+            @Nullable List<String> mimeTypes,
+            @NonNull String searchText) {
+        super(mimeTypes);
+
+        mSearchText = requireNonNull(searchText);
+    }
+
+    public SearchTextRequest(
+            @Nullable List<String> mimeTypes,
+            @NonNull String searchText,
+            @Nullable String resumeKey) {
+        super(mimeTypes, resumeKey);
+
+        mSearchText = requireNonNull(searchText);
+    }
+
+    @NonNull
+    public String getSearchText() {
+        return mSearchText;
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/MediaGroupCursorUtils.java b/src/com/android/providers/media/photopicker/v2/sqlite/MediaGroupCursorUtils.java
new file mode 100644
index 000000000..de10bb816
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/MediaGroupCursorUtils.java
@@ -0,0 +1,371 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.sqlite;
+
+import static android.provider.MediaStore.MY_USER_ID;
+
+import static java.util.Objects.requireNonNull;
+
+import android.database.Cursor;
+import android.database.MatrixCursor;
+import android.net.Uri;
+import android.provider.CloudMediaProviderContract;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import com.android.providers.media.PickerUriResolver;
+import com.android.providers.media.photopicker.PickerSyncController;
+import com.android.providers.media.photopicker.data.PickerDbFacade;
+import com.android.providers.media.photopicker.v2.model.MediaGroup;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+
+/**
+ * Utility class that prepares cursor response in the format
+ * {@link PickerSQLConstants.MediaGroupResponseColumns}.
+ */
+public class MediaGroupCursorUtils {
+    private static final String TAG = "MediaGroupCursorUtils";
+
+    private static final String[] ALL_MEDIA_GROUP_RESPONSE_PROJECTION = new String[]{
+            PickerSQLConstants.MediaGroupResponseColumns.MEDIA_GROUP.getColumnName(),
+            PickerSQLConstants.MediaGroupResponseColumns.GROUP_ID.getColumnName(),
+            PickerSQLConstants.MediaGroupResponseColumns.PICKER_ID.getColumnName(),
+            PickerSQLConstants.MediaGroupResponseColumns.DISPLAY_NAME.getColumnName(),
+            PickerSQLConstants.MediaGroupResponseColumns.AUTHORITY.getColumnName(),
+            PickerSQLConstants.MediaGroupResponseColumns.UNWRAPPED_COVER_URI.getColumnName(),
+            PickerSQLConstants.MediaGroupResponseColumns
+                    .ADDITIONAL_UNWRAPPED_COVER_URI_1.getColumnName(),
+            PickerSQLConstants.MediaGroupResponseColumns
+                    .ADDITIONAL_UNWRAPPED_COVER_URI_2.getColumnName(),
+            PickerSQLConstants.MediaGroupResponseColumns
+                    .ADDITIONAL_UNWRAPPED_COVER_URI_3.getColumnName(),
+            PickerSQLConstants.MediaGroupResponseColumns.CATEGORY_TYPE.getColumnName(),
+            PickerSQLConstants.MediaGroupResponseColumns.IS_LEAF_CATEGORY.getColumnName(),
+    };
+
+    /**
+     * @param cursor Input
+     * {@link com.android.providers.media.photopicker.v2.model.AlbumsCursorWrapper}
+     * @return Cursor with the columns {@link PickerSQLConstants.MediaGroupResponseColumns}.
+     */
+    @Nullable
+    public static Cursor getMediaGroupCursorForAlbums(@Nullable Cursor cursor) {
+        if (cursor == null) {
+            return null;
+        }
+
+        final MatrixCursor response = new MatrixCursor(ALL_MEDIA_GROUP_RESPONSE_PROJECTION);
+
+        // Get the list of Uris from the cursor.
+        final List<String> uris = new ArrayList<>();
+        if (cursor.moveToFirst()) {
+            do {
+                final String unwrappedCoverUri =
+                        cursor.getString(cursor.getColumnIndexOrThrow(PickerSQLConstants
+                                .AlbumResponse.UNWRAPPED_COVER_URI.getColumnName()));
+                if (unwrappedCoverUri != null) {
+                    uris.add(unwrappedCoverUri);
+                }
+            } while (cursor.moveToNext());
+        }
+
+        // Get list of local ids if local copy exists for corresponding cloud ids.
+        final Map<String, String> cloudToLocalIdMap = getLocalIds(uris);
+
+        if (cursor.moveToFirst()) {
+            do {
+                final String albumId = cursor.getString(cursor.getColumnIndexOrThrow(
+                                PickerSQLConstants.AlbumResponse.ALBUM_ID.getColumnName()));
+
+                final String pickerId = cursor.getString(cursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.AlbumResponse.PICKER_ID.getColumnName()));
+
+                final String displayName = cursor.getString(cursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.AlbumResponse.ALBUM_NAME.getColumnName()));
+
+                final String authority = cursor.getString(cursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.AlbumResponse.AUTHORITY.getColumnName()));
+
+                final String unwrappedCoverUri = maybeGetLocalUri(
+                        cursor.getString(cursor.getColumnIndexOrThrow(PickerSQLConstants
+                                .AlbumResponse.UNWRAPPED_COVER_URI.getColumnName())),
+                        cloudToLocalIdMap);
+
+                response.addRow(new Object[]{
+                        MediaGroup.ALBUM.name(),
+                        albumId,
+                        pickerId,
+                        displayName,
+                        authority,
+                        unwrappedCoverUri,
+                        /* MediaGroupResponseColumns.ADDITIONAL_UNWRAPPED_COVER_URI_1 */ null,
+                        /* MediaGroupResponseColumns.ADDITIONAL_UNWRAPPED_COVER_URI_2 */ null,
+                        /* MediaGroupResponseColumns.ADDITIONAL_UNWRAPPED_COVER_URI_3 */ null,
+                        /* MediaGroupResponseColumns.CATEGORY_TYPE */ null,
+                        /* MediaGroupResponseColumns.IS_LEAF_CATEGORY */ null
+                });
+            } while (cursor.moveToNext());
+        }
+
+        return response;
+    }
+
+    /**
+     * @param cursor Input
+     * {@link CloudMediaProviderContract.MediaCategoryColumns} cursor.
+     * @return Cursor with the columns {@link PickerSQLConstants.MediaGroupResponseColumns}.
+     */
+    @Nullable
+    public static Cursor getMediaGroupCursorForCategories(
+            @Nullable Cursor cursor,
+            @NonNull String authority) {
+        if (cursor == null) {
+            return null;
+        }
+
+        final MatrixCursor response = new MatrixCursor(ALL_MEDIA_GROUP_RESPONSE_PROJECTION);
+
+        final List<String> uris = new ArrayList<>();
+        final List<String> mediaCoverIdColumns = List.of(
+                CloudMediaProviderContract.MediaCategoryColumns.MEDIA_COVER_ID1,
+                CloudMediaProviderContract.MediaCategoryColumns.MEDIA_COVER_ID2,
+                CloudMediaProviderContract.MediaCategoryColumns.MEDIA_COVER_ID3,
+                CloudMediaProviderContract.MediaCategoryColumns.MEDIA_COVER_ID4
+        );
+        if (cursor.moveToFirst()) {
+            do {
+                for (String columnName : mediaCoverIdColumns) {
+                    final String mediaCoverId = cursor.getString(
+                            cursor.getColumnIndexOrThrow(columnName));
+                    if (mediaCoverId != null) {
+                        uris.add(getUri(mediaCoverId, authority).toString());
+                    }
+                }
+            } while (cursor.moveToNext());
+        }
+
+        // Get list of local ids if local copy exists for corresponding cloud ids.
+        final Map<String, String> cloudToLocalIdMap = getLocalIds(uris);
+
+        if (cursor.moveToFirst()) {
+            if (cursor.getCount() > 1) {
+                Log.e(TAG, "Only one category of type PEOPLE AND PETS is expected but received "
+                        + cursor.getCount());
+            }
+
+            final String categoryType = cursor.getString(cursor.getColumnIndexOrThrow(
+                    CloudMediaProviderContract.MediaCategoryColumns.MEDIA_CATEGORY_TYPE));
+
+            if (!CloudMediaProviderContract.MEDIA_CATEGORY_TYPE_PEOPLE_AND_PETS
+                    .equals(categoryType)) {
+                Log.e(TAG, "Could not recognize category type. Skipping it: " + categoryType);
+                return response;
+            }
+
+            final String categoryId = requireNonNull(
+                    cursor.getString(cursor.getColumnIndexOrThrow(
+                    CloudMediaProviderContract.MediaCategoryColumns.ID)));
+
+            final String displayName = cursor.getString(cursor.getColumnIndexOrThrow(
+                    CloudMediaProviderContract.MediaCategoryColumns.DISPLAY_NAME));
+
+            final String mediaCoverId1 = cursor.getString(
+                    cursor.getColumnIndexOrThrow(
+                            CloudMediaProviderContract.MediaCategoryColumns.MEDIA_COVER_ID1));
+            final String coverUri1 = maybeGetLocalUri(
+                    getUri(mediaCoverId1, authority).toString(),
+                    cloudToLocalIdMap);
+
+            final String mediaCoverId2 = cursor.getString(
+                    cursor.getColumnIndexOrThrow(
+                            CloudMediaProviderContract.MediaCategoryColumns.MEDIA_COVER_ID2));
+            final String coverUri2 = maybeGetLocalUri(
+                    getUri(mediaCoverId2, authority).toString(),
+                    cloudToLocalIdMap);
+
+            final String mediaCoverId3 = cursor.getString(
+                    cursor.getColumnIndexOrThrow(
+                            CloudMediaProviderContract.MediaCategoryColumns.MEDIA_COVER_ID3));
+            final String coverUri3 = maybeGetLocalUri(
+                    getUri(mediaCoverId3, authority).toString(),
+                    cloudToLocalIdMap);
+
+            final String mediaCoverId4 = cursor.getString(
+                    cursor.getColumnIndexOrThrow(
+                            CloudMediaProviderContract.MediaCategoryColumns.MEDIA_COVER_ID4));
+            final String coverUri4 = maybeGetLocalUri(
+                    getUri(mediaCoverId4, authority).toString(),
+                    cloudToLocalIdMap);
+
+            response.addRow(new Object[]{
+                    MediaGroup.CATEGORY.name(),
+                    categoryId,
+                    /* pickerId */ null,
+                    displayName,
+                    authority,
+                    coverUri1,
+                    coverUri2,
+                    coverUri3,
+                    coverUri4,
+                    categoryType,
+                    // Default is 1, we don't have recursive categories yet.
+                    /* MediaGroupResponseColumns.IS_LEAF_CATEGORY */ 1
+            });
+        }
+
+        return response;
+    }
+
+    /**
+     * @param uris List of Uris received in a cursor. These could be local Uris, or cloud Uris.
+     * @return A map of valid cloud id -> local ids. Cloud ids will be extracted from input list of
+     * uris.
+     */
+    public static Map<String, String> getLocalIds(@NonNull List<String> uris) {
+        final PickerSyncController syncController = PickerSyncController.getInstanceOrThrow();
+        final String localAuthority = syncController.getLocalProvider();
+
+        // Filter cloud Ids from the input list of Uris.
+        final Map<String, String> cloudToLocalIdMap = new HashMap<>();
+
+        try {
+            requireNonNull(uris);
+
+            final List<String> cloudUris = new ArrayList<>();
+            for (String inputUri : uris) {
+                final Uri coverUri = Uri.parse(inputUri);
+                final String authority = coverUri.getAuthority();
+
+                if (Objects.equals(localAuthority, authority)) {
+                    Log.d(TAG, "Cover uri already refers to a local media item.");
+                } else {
+                    cloudUris.add(coverUri.getLastPathSegment());
+                }
+            }
+
+            // Get a map of local ids for their corresponding cloud ids from the database.
+            final SelectSQLiteQueryBuilder localUriQueryBuilder =
+                    new SelectSQLiteQueryBuilder(syncController.getDbFacade().getDatabase());
+            localUriQueryBuilder.setTables(PickerSQLConstants.Table.MEDIA.name())
+                    .setProjection(new String[]{
+                            PickerDbFacade.KEY_LOCAL_ID,
+                            PickerDbFacade.KEY_CLOUD_ID});
+            localUriQueryBuilder.appendWhereStandalone(String.format(
+                    Locale.ROOT, "%s IN ('%s')", PickerDbFacade.KEY_CLOUD_ID,
+                    String.join("','", cloudUris)));
+            localUriQueryBuilder.appendWhereStandalone(String.format(
+                    Locale.ROOT, "%s IS NULL", PickerDbFacade.KEY_IS_VISIBLE));
+            localUriQueryBuilder.appendWhereStandalone(String.format(
+                    Locale.ROOT, "%s IS NOT NULL", PickerDbFacade.KEY_LOCAL_ID));
+
+            try (Cursor cursor = syncController.getDbFacade().getDatabase()
+                    .rawQuery(localUriQueryBuilder.buildQuery(), /*selectionArgs*/ null)) {
+                if (cursor.moveToFirst()) {
+                    do {
+                        final String localId = cursor.getString(cursor.getColumnIndexOrThrow(
+                                PickerDbFacade.KEY_LOCAL_ID));
+                        final String cloudId = cursor.getString(cursor.getColumnIndexOrThrow(
+                                PickerDbFacade.KEY_CLOUD_ID));
+                        cloudToLocalIdMap.put(cloudId, localId);
+                    } while (cursor.moveToNext());
+                }
+            }
+
+            // Validate that local ids correspond to a valid local media item on the device.
+            final SelectSQLiteQueryBuilder validateLocalIdQueryBuilder =
+                    new SelectSQLiteQueryBuilder(syncController.getDbFacade().getDatabase());
+            validateLocalIdQueryBuilder.setTables(PickerSQLConstants.Table.MEDIA.name())
+                    .setProjection(new String[]{PickerDbFacade.KEY_LOCAL_ID});
+            validateLocalIdQueryBuilder.appendWhereStandalone(String.format(
+                    Locale.ROOT, "%s IS NULL", PickerDbFacade.KEY_CLOUD_ID));
+            validateLocalIdQueryBuilder.appendWhereStandalone(String.format(
+                    Locale.ROOT, "%s = 1", PickerDbFacade.KEY_IS_VISIBLE));
+            validateLocalIdQueryBuilder.appendWhereStandalone(String.format(
+                    Locale.ROOT, "%s IN ('%s')", PickerDbFacade.KEY_LOCAL_ID,
+                    String.join("','", cloudToLocalIdMap.values())));
+
+            final Set<String> validLocalIds = new HashSet<>();
+            try (Cursor cursor = syncController.getDbFacade().getDatabase()
+                    .rawQuery(validateLocalIdQueryBuilder.buildQuery(), /*selectionArgs*/ null)) {
+                if (cursor.moveToFirst()) {
+                    do {
+                        final String localId = cursor.getString(cursor.getColumnIndexOrThrow(
+                                PickerDbFacade.KEY_LOCAL_ID));
+                        validLocalIds.add(localId);
+                    } while (cursor.moveToNext());
+                }
+            }
+
+            // Filter map so that it only contains valid local Ids.
+            cloudToLocalIdMap.keySet().removeIf(
+                    cloudId -> !validLocalIds.contains(cloudToLocalIdMap.get(cloudId)));
+        } catch (Exception e) {
+            Log.e(TAG, "Could not get local ids for cloud items", e);
+        }
+
+        return cloudToLocalIdMap;
+    }
+
+    /**
+     * Checks if the input coverUri points to a cloud media object. If it does, then tries to
+     * find the local copy of it and returns the URI of the local copy. Otherwise returns the input
+     * coverUri as it is.
+     */
+    private static String maybeGetLocalUri(
+            @Nullable String rawCoverUri,
+            @NonNull Map<String, String> cloudToLocalIdMap) {
+        if (rawCoverUri == null) {
+            return null;
+        }
+
+        try {
+            final Uri coverUri = Uri.parse(rawCoverUri);
+            final String mediaId = coverUri.getLastPathSegment();
+            if (cloudToLocalIdMap.containsKey(mediaId)) {
+                return getUri(cloudToLocalIdMap.get(mediaId), coverUri.getAuthority()).toString();
+            } else {
+                return rawCoverUri;
+            }
+        } catch (RuntimeException e) {
+            Log.e(TAG, "Error occurred in parsing Uri received from CMP", e);
+        }
+
+        return rawCoverUri;
+    }
+
+    private static Uri getUri(String mediaId, String authority) {
+        return PickerUriResolver
+                .getMediaUri(getEncodedUserAuthority(authority))
+                .buildUpon()
+                .appendPath(mediaId)
+                .build();
+    }
+
+    private static String getEncodedUserAuthority(String authority) {
+        return MY_USER_ID + "@" + authority;
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsCloudSubQuery.java b/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsCloudSubQuery.java
new file mode 100644
index 000000000..d9c5a8e16
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsCloudSubQuery.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.sqlite;
+
+import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_CLOUD_ID;
+
+import android.os.Bundle;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import java.util.Locale;
+
+/**
+ * Utility class to query cloud media items from media_in_media_sets table and media table in
+ * Picker DB.
+ */
+public class MediaInMediaSetsCloudSubQuery extends MediaInMediaSetsSubQuery {
+    public MediaInMediaSetsCloudSubQuery(Bundle queryArgs, String mediaSetPickerId) {
+        super(queryArgs, mediaSetPickerId);
+    }
+
+    @Override
+    public String getTableWithRequiredJoins() {
+        return String.format(
+                Locale.ROOT,
+                " %s INNER JOIN %s ON %s.%s = %s.%s ",
+                PickerSQLConstants.Table.MEDIA.name(),
+                PickerSQLConstants.Table.MEDIA_IN_MEDIA_SETS.name(),
+                PickerSQLConstants.Table.MEDIA.name(),
+                KEY_CLOUD_ID,
+                PickerSQLConstants.Table.MEDIA_IN_MEDIA_SETS.name(),
+                PickerSQLConstants.SearchResultMediaTableColumns.CLOUD_ID.getColumnName());
+    }
+
+    @Override
+    public void addWhereClause(
+            @NonNull SelectSQLiteQueryBuilder queryBuilder,
+            @NonNull PickerSQLConstants.Table table,
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority,
+            boolean reverseOrder
+    ) {
+        super.addWhereClause(queryBuilder, table, localAuthority, cloudAuthority, reverseOrder);
+
+        queryBuilder.appendWhereStandalone(
+                String.format(
+                        Locale.ROOT,
+                        "%s.%s IS NOT NULL",
+                        PickerSQLConstants.Table.MEDIA.name(),
+                        KEY_CLOUD_ID));
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsDatabaseUtil.java b/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsDatabaseUtil.java
new file mode 100644
index 000000000..40592e22f
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsDatabaseUtil.java
@@ -0,0 +1,336 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.sqlite;
+
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_IGNORE;
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_REPLACE;
+
+import static com.android.providers.media.photopicker.v2.sqlite.PickerMediaDatabaseUtil.addNextPageKey;
+import static com.android.providers.media.photopicker.v2.sqlite.PickerMediaDatabaseUtil.addPrevPageKey;
+
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.net.Uri;
+import android.os.Bundle;
+import android.provider.CloudMediaProviderContract;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import com.android.providers.media.photopicker.PickerSyncController;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+import java.util.Objects;
+
+/**
+ * Utility class for insertion or querying the media items in various media sets
+ */
+public class MediaInMediaSetsDatabaseUtil {
+
+    private static final String TAG = "MediaInMediaSetsDatabaseUtil";
+
+    /**
+     * Caches the metadata of a media item identified by the given mediaSet into the
+     * media_in_media_sets table.
+     *
+     * @param database The database to insert into
+     * @param mediaListToInsert The ContentValues list of the items to insert
+     * @param authority Authority of the media set
+     * @return The number of items inserted into the table
+     */
+    public static int cacheMediaOfMediaSet(
+            @NonNull SQLiteDatabase database,
+            @Nullable List<ContentValues> mediaListToInsert,
+            @NonNull String authority) {
+
+        Objects.requireNonNull(database);
+        Objects.requireNonNull(authority);
+
+        final boolean isLocal = PickerSyncController.getInstanceOrThrow()
+                .getLocalProvider()
+                .equals(authority);
+
+        if (mediaListToInsert == null || mediaListToInsert.isEmpty()) {
+            Log.e(TAG, "Received cursor is either null or empty. Nothing to insert.");
+            return 0;
+        }
+
+        try {
+            // Start a transaction with EXCLUSIVE lock.
+            database.beginTransaction();
+
+            // Number of rows inserted or replaced
+            int numberOfMediaRowsInserted = 0;
+            for (ContentValues mediaValues : mediaListToInsert) {
+                try {
+                    // Prefer media received from local provider over cloud provider to avoid
+                    // joining with media table on cloud_id when not required.
+                    final int conflictResolutionStrategy = isLocal
+                            ? CONFLICT_REPLACE
+                            : CONFLICT_IGNORE;
+                    final long rowId = database.insertWithOnConflict(
+                            PickerSQLConstants.Table.MEDIA_IN_MEDIA_SETS.name(),
+                            null,
+                            mediaValues,
+                            conflictResolutionStrategy
+                    );
+
+                    if (rowId == -1) {
+                        Log.d(TAG, "Did not insert row in the media_in_media_sets_table"
+                                + " due to IGNORE conflict resolution strategy " + mediaValues);
+                    } else {
+                        numberOfMediaRowsInserted++;
+                    }
+                } catch (SQLException e) {
+                    Log.e(TAG, "Could not insert row in the media_in_media_sets_table "
+                            + mediaValues + " due to ", e);
+                }
+            }
+            // Mark transaction as successful so that it gets committed after it ends.
+            if (database.inTransaction()) {
+                database.setTransactionSuccessful();
+            }
+            return numberOfMediaRowsInserted;
+        } catch (RuntimeException e) {
+            // Do not mark transaction as successful so that it gets rolled back after it ends.
+            throw new RuntimeException("Could not insert items in the database", e);
+        } finally {
+            // Mark transaction as ended. The inserted items will either be committed if the
+            // transaction has been set as successful, or rolled back otherwise.
+            if (database.inTransaction()) {
+                database.endTransaction();
+            }
+        }
+    }
+
+    /**
+     * Fetches the media items of a particular mediaSet. The mediaItems belonging to a particular
+     * mediaSet are fetched from the media_in_media_sets table. The metadata of these items is
+     * fetched from the media table by joining the two together.
+     *
+     * @param syncController       Instance of the PickerSyncController singleton.
+     * @param mediaInMediaSetQuery The MediaInMediaSetsQuery object that tells us about the
+     * @param localAuthority       The effective local authority to consider for this transaction
+     * @param cloudAuthority       The effective cloud authority to consider for this transaction
+     * @return A cursor with all the media items for that mediaSet and their metadata
+     */
+    public static Cursor queryMediaInMediaSet(@NonNull PickerSyncController syncController,
+            @NonNull MediaInMediaSetsQuery mediaInMediaSetQuery,
+            @Nullable String localAuthority, @Nullable String cloudAuthority) {
+
+        final SQLiteDatabase database = syncController.getDbFacade().getDatabase();
+
+        try {
+            database.beginTransactionNonExclusive();
+            Cursor pageData = database.rawQuery(
+                    getSearchMediaInMediaSetsPageQuery(
+                            mediaInMediaSetQuery,
+                            database,
+                            mediaInMediaSetQuery.getTableWithRequiredJoins(
+                                    database, localAuthority, cloudAuthority,
+                                    /* reverseOrder */ false)
+                    ),
+                    /* selectionArgs */ null
+            );
+
+            Bundle extraArgs = new Bundle();
+
+            Cursor nextPageKeyCursor = database.rawQuery(
+                    getMediaInMediaSetsNextPageKeyQuery(
+                            mediaInMediaSetQuery,
+                            database,
+                            mediaInMediaSetQuery.getTableWithRequiredJoins(
+                                    database, localAuthority, cloudAuthority,
+                                    /* reverseOrder */ false)
+                    ),
+                    /* selectionArgs */ null
+            );
+            addNextPageKey(extraArgs, nextPageKeyCursor);
+
+            Cursor prevPageKeyCursor = database.rawQuery(
+                    getMediaInMediaSetsPreviousPageQuery(
+                            mediaInMediaSetQuery,
+                            database,
+                            mediaInMediaSetQuery.getTableWithRequiredJoins(
+                                    database, localAuthority, cloudAuthority,
+                                    /* reverseOrder */ true)
+                    ),
+                    /* selectionArgs */ null
+            );
+            addPrevPageKey(extraArgs, prevPageKeyCursor);
+
+            database.setTransactionSuccessful();
+            pageData.setExtras(extraArgs);
+            Log.i(TAG, "Returning " + pageData.getCount() + " media metadata");
+            return pageData;
+        } catch (Exception e) {
+            throw new RuntimeException("Could not fetch media from the media set", e);
+        } finally {
+            database.endTransaction();
+        }
+    }
+
+    /**
+     * Returns the database query to fetch the media for the given media set. The media table is
+     * joined with the media_in_media_sets table to get the items of that mediaSet and their
+     * metadata from the media table. The join is made on local_id and cloud_id separately for
+     * the given mediaSet. These are then further combined to give all the results filtered by
+     * other arguments provided.
+     */
+    private static String getSearchMediaInMediaSetsPageQuery(
+            @NonNull MediaInMediaSetsQuery query,
+            @NonNull SQLiteDatabase database,
+            @NonNull String table) {
+        SelectSQLiteQueryBuilder queryBuilder = new SelectSQLiteQueryBuilder(database)
+                .setTables(table)
+                .setProjection(List.of(
+                        PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName(),
+                        PickerSQLConstants.MediaResponse.PICKER_ID.getProjectedName(),
+                        PickerSQLConstants.MediaResponse
+                                .AUTHORITY.getProjectedName(),
+                        PickerSQLConstants.MediaResponse.MEDIA_SOURCE.getProjectedName(),
+                        PickerSQLConstants.MediaResponse.WRAPPED_URI.getProjectedName(),
+                        PickerSQLConstants.MediaResponse
+                                .UNWRAPPED_URI.getProjectedName(),
+                        PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getProjectedName(),
+                        PickerSQLConstants.MediaResponse.SIZE_IN_BYTES.getProjectedName(),
+                        PickerSQLConstants.MediaResponse.MIME_TYPE.getProjectedName(),
+                        PickerSQLConstants.MediaResponse.STANDARD_MIME_TYPE.getProjectedName(),
+                        PickerSQLConstants.MediaResponse.DURATION_MS.getProjectedName(),
+                        PickerSQLConstants.MediaResponse.IS_PRE_GRANTED.getProjectedName()
+                ))
+                .setSortOrder(
+                        String.format(
+                                Locale.ROOT,
+                                "%s DESC, %s DESC",
+                                PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getProjectedName(),
+                                PickerSQLConstants.MediaResponse.PICKER_ID.getProjectedName()
+                        )
+                )
+                .setLimit(query.getPageSize());
+
+        return queryBuilder.buildQuery();
+    }
+
+    /**
+     * Builds and returns the sql query to fetch the first item of the next page.
+     */
+    @Nullable
+    private static String getMediaInMediaSetsNextPageKeyQuery(
+            @NonNull MediaInMediaSetsQuery query,
+            @NonNull SQLiteDatabase database,
+            @NonNull String table) {
+        if (query.getPageSize() == Integer.MAX_VALUE) {
+            return null;
+        }
+
+        SelectSQLiteQueryBuilder queryBuilder = new SelectSQLiteQueryBuilder(database)
+                .setTables(table)
+                .setProjection(List.of(
+                        PickerSQLConstants.MediaResponse.PICKER_ID.getProjectedName(),
+                        PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getProjectedName()
+                ))
+                .setSortOrder(
+                        String.format(
+                                Locale.ROOT,
+                                "%s DESC, %s DESC",
+                                PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getProjectedName(),
+                                PickerSQLConstants.MediaResponse.PICKER_ID.getProjectedName()
+                        )
+                )
+                .setLimit(1)
+                .setOffset(query.getPageSize());
+
+        return queryBuilder.buildQuery();
+    }
+
+    /**
+     * Builds and returns the sql query to fetch all the media items of the previous page.
+     */
+    private static String getMediaInMediaSetsPreviousPageQuery(
+            @NonNull MediaInMediaSetsQuery query,
+            @NonNull SQLiteDatabase database,
+            @NonNull String table) {
+        SelectSQLiteQueryBuilder queryBuilder = new SelectSQLiteQueryBuilder(database)
+                .setTables(table)
+                .setProjection(List.of(
+                        PickerSQLConstants.MediaResponse.PICKER_ID.getProjectedName(),
+                        PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getProjectedName()
+                )).setSortOrder(
+                        String.format(
+                                Locale.ROOT,
+                                "%s ASC, %s ASC",
+                                PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getProjectedName(),
+                                PickerSQLConstants.MediaResponse.PICKER_ID.getProjectedName()
+                        )
+                ).setLimit(query.getPageSize());
+
+        return queryBuilder.buildQuery();
+    }
+
+    /**
+     * Extracts the metadata from the provided cursor and creates a list of content values to
+     * insert into the media_in_media_sets_table
+     */
+    public static List<ContentValues> getMediaContentValuesFromCursor(
+            @NonNull Cursor mediaCursor, @NonNull String mediaSetPickerId, boolean isLocal) {
+        Objects.requireNonNull(mediaSetPickerId);
+        Objects.requireNonNull(mediaCursor);
+
+        List<ContentValues> contentValuesList = new ArrayList<>(mediaCursor.getCount());
+        if (mediaCursor.moveToFirst()) {
+            do {
+                // Extract metadata of each media item
+                String mediaId = mediaCursor.getString(
+                        mediaCursor.getColumnIndexOrThrow(
+                                CloudMediaProviderContract.MediaColumns.ID));
+                String mediaStoreUri = mediaCursor.getString(
+                        mediaCursor.getColumnIndexOrThrow(
+                                CloudMediaProviderContract.MediaColumns.MEDIA_STORE_URI));
+                Uri mediaUri = mediaStoreUri == null ? null : Uri.parse(mediaStoreUri);
+                String extractedLocalId = mediaStoreUri == null ? null
+                        : String.valueOf(ContentUris.parseId(mediaUri));
+
+                String localId = isLocal ? mediaId : extractedLocalId;
+                String cloudId = isLocal ? null : mediaId;
+
+                ContentValues insertValue = new ContentValues();
+                insertValue.put(
+                        PickerSQLConstants.MediaInMediaSetsTableColumns.LOCAL_ID.getColumnName(),
+                        localId
+                );
+                insertValue.put(
+                        PickerSQLConstants.MediaInMediaSetsTableColumns.CLOUD_ID.getColumnName(),
+                        cloudId
+                );
+                insertValue.put(
+                        PickerSQLConstants.MediaInMediaSetsTableColumns.MEDIA_SETS_PICKER_ID
+                                .getColumnName(),
+                        mediaSetPickerId
+                );
+                contentValuesList.add(insertValue);
+            } while (mediaCursor.moveToNext());
+        }
+        return contentValuesList;
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsLocalSubQuery.java b/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsLocalSubQuery.java
new file mode 100644
index 000000000..d00e4306c
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsLocalSubQuery.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.sqlite;
+
+import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_CLOUD_ID;
+import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_LOCAL_ID;
+
+import android.os.Bundle;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import java.util.Locale;
+
+/**
+ * Utility class to query local media items from media_in_media_sets table and media table in
+ * Picker DB.
+ */
+public class MediaInMediaSetsLocalSubQuery extends MediaInMediaSetsSubQuery {
+    public MediaInMediaSetsLocalSubQuery(Bundle queryArgs, String mediaSetPickerId) {
+        super(queryArgs, mediaSetPickerId);
+    }
+
+    @Override
+    public String getTableWithRequiredJoins() {
+        return String.format(
+                Locale.ROOT,
+                " %s INNER JOIN %s ON %s.%s = %s.%s ",
+                PickerSQLConstants.Table.MEDIA.name(),
+                PickerSQLConstants.Table.MEDIA_IN_MEDIA_SETS.name(),
+                PickerSQLConstants.Table.MEDIA.name(),
+                KEY_LOCAL_ID,
+                PickerSQLConstants.Table.MEDIA_IN_MEDIA_SETS.name(),
+                PickerSQLConstants.MediaInMediaSetsTableColumns.LOCAL_ID.getColumnName());
+    }
+
+    @Override
+    public void addWhereClause(
+            @NonNull SelectSQLiteQueryBuilder queryBuilder,
+            @NonNull PickerSQLConstants.Table table,
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority,
+            boolean reverseOrder
+    ) {
+        super.addWhereClause(queryBuilder, table, localAuthority, cloudAuthority, reverseOrder);
+
+        queryBuilder.appendWhereStandalone(
+                String.format(
+                        Locale.ROOT,
+                        "%s.%s IS NULL",
+                        PickerSQLConstants.Table.MEDIA.name(),
+                        KEY_CLOUD_ID));
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsQuery.java b/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsQuery.java
new file mode 100644
index 000000000..f0ba09f1a
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsQuery.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.sqlite;
+
+import android.database.sqlite.SQLiteDatabase;
+import android.os.Bundle;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+import java.util.Objects;
+
+/**
+ * Utility class to query media items from media_in_media_sets_table table and media table in
+ * Picker DB.
+ */
+public class MediaInMediaSetsQuery {
+
+    @Nullable
+    private final String mIntentAction;
+    @NonNull
+    private final List<String> mProviders;
+    protected final int mPageSize;
+    @NonNull
+    final MediaInMediaSetsLocalSubQuery mLocalMediaSubQuery;
+    @NonNull
+    final MediaInMediaSetsCloudSubQuery mCloudMediaSubquery;
+
+
+    public MediaInMediaSetsQuery(Bundle queryArgs, @NonNull String mediaPickerSetId) {
+        Objects.requireNonNull(mediaPickerSetId);
+        if (mediaPickerSetId.isEmpty()) {
+            throw new RuntimeException("MediaSet pickerId to query media cannot be null");
+        }
+        mIntentAction = queryArgs.getString("intent_action");
+        mProviders = new ArrayList<>(
+                Objects.requireNonNull(queryArgs.getStringArrayList("providers")));
+        mPageSize = queryArgs.getInt("page_size", Integer.MAX_VALUE);
+
+        mLocalMediaSubQuery = new MediaInMediaSetsLocalSubQuery(queryArgs, mediaPickerSetId);
+        mCloudMediaSubquery = new MediaInMediaSetsCloudSubQuery(queryArgs, mediaPickerSetId);
+    }
+
+    /**
+     * @param database SQLiteDatabase wrapper for Picker DB
+     * @param localAuthority authority of the local provider if it should be queried,
+     *                       otherwise null.
+     * @param cloudAuthority authority of the cloud provider if it should be queried,
+     *                       otherwise null.
+     * @param reverseOrder true when the sort order needs to be reversed.
+     * @return A string that contains the table clause of the sql query after joining the
+     * media table and media_in_media_sets table.
+     */
+    public String getTableWithRequiredJoins(@NonNull SQLiteDatabase database,
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority,
+            boolean reverseOrder) {
+
+        final MediaProjection mediaProjection = new MediaProjection(
+                localAuthority,
+                cloudAuthority,
+                mIntentAction,
+                PickerSQLConstants.Table.MEDIA
+        );
+
+        final String localMediaRawQuery = getSubQuery(
+                database,
+                mLocalMediaSubQuery,
+                localAuthority,
+                cloudAuthority,
+                mediaProjection,
+                reverseOrder
+        );
+        final String cloudMediaRawQuery = getSubQuery(
+                database,
+                mCloudMediaSubquery,
+                localAuthority,
+                cloudAuthority,
+                mediaProjection,
+                reverseOrder
+        );
+        return String.format(
+                Locale.ROOT,
+                "( %s UNION ALL %s )",
+                localMediaRawQuery,
+                cloudMediaRawQuery);
+    }
+
+    private String getSubQuery(
+            @NonNull SQLiteDatabase database,
+            @NonNull MediaInMediaSetsSubQuery mediaInMediaSetSubQuery,
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority,
+            @NonNull MediaProjection mediaProjection,
+            boolean reverseOrder) {
+        final SelectSQLiteQueryBuilder subQueryBuilder =
+                new SelectSQLiteQueryBuilder(database);
+        subQueryBuilder
+                .setTables(mediaInMediaSetSubQuery.getTableWithRequiredJoins())
+                .setProjection(mediaProjection.getAll());
+        mediaInMediaSetSubQuery.addWhereClause(
+                subQueryBuilder,
+                PickerSQLConstants.Table.MEDIA,
+                localAuthority,
+                cloudAuthority,
+                reverseOrder
+        );
+        return subQueryBuilder.buildQuery();
+    }
+
+    @Nullable
+    public String getIntentAction() {
+        return mIntentAction;
+    }
+
+    @NonNull
+    public List<String> getProviders() {
+        return mProviders;
+    }
+
+    public int getPageSize() {
+        return mPageSize;
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsSubQuery.java b/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsSubQuery.java
new file mode 100644
index 000000000..2e37e5255
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsSubQuery.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.sqlite;
+
+import android.os.Bundle;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import com.android.providers.media.photopicker.v2.model.MediaQuery;
+
+import java.util.Locale;
+
+/**
+ * Utility class to query either local or cloud media items from media_in_media_sets table
+ * and media table in Picker DB.
+ */
+public abstract class MediaInMediaSetsSubQuery extends MediaQuery {
+    private final String mMediaSetPickerId;
+
+    public MediaInMediaSetsSubQuery(Bundle queryArgs, String mediaSetPickerId) {
+        super(queryArgs);
+
+        mMediaSetPickerId = mediaSetPickerId;
+    }
+
+    /**
+     * @return A string that contains the table clause of the sql query after joining the
+     * media table and media_in_media_sets table.
+     */
+    public abstract String getTableWithRequiredJoins();
+
+    @Override
+    public void addWhereClause(
+            @NonNull SelectSQLiteQueryBuilder queryBuilder,
+            @NonNull PickerSQLConstants.Table table,
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority,
+            boolean reverseOrder
+    ) {
+        super.addWhereClause(queryBuilder, table, localAuthority, cloudAuthority, reverseOrder);
+
+        queryBuilder.appendWhereStandalone(
+                String.format(
+                        Locale.ROOT,
+                        "%s.%s = '%s'",
+                        PickerSQLConstants.Table.MEDIA_IN_MEDIA_SETS.name(),
+                        PickerSQLConstants.MediaInMediaSetsTableColumns
+                                .MEDIA_SETS_PICKER_ID.getColumnName(),
+                        mMediaSetPickerId));
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/MediaProjection.java b/src/com/android/providers/media/photopicker/v2/sqlite/MediaProjection.java
new file mode 100644
index 000000000..dc6a1f35b
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/MediaProjection.java
@@ -0,0 +1,242 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.sqlite;
+
+import static com.android.providers.media.PickerUriResolver.getPickerSegmentFromIntentAction;
+import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_CLOUD_ID;
+import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_LOCAL_ID;
+
+import static java.util.Objects.requireNonNull;
+
+import android.content.Context;
+import android.os.Bundle;
+import android.provider.MediaStore;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import com.android.providers.media.MediaGrants;
+import com.android.providers.media.photopicker.v2.PickerDataLayerV2;
+import com.android.providers.media.photopicker.v2.model.MediaSource;
+
+import java.util.List;
+import java.util.Locale;
+
+/**
+ * Utility class to generate and return sql projection for {@link PickerSQLConstants.MediaResponse}.
+ * {@link PickerSQLConstants.MediaResponse} contains the columns returned in the response of
+ * {@link PickerDataLayerV2#queryMedia(Context, Bundle)},
+ * {@link PickerDataLayerV2#queryAlbumMedia(Context, Bundle, String)} and
+ * {@link PickerDataLayerV2#queryPreviewMedia(Context, Bundle)}
+ */
+public class MediaProjection {
+    @Nullable
+    private final String mLocalAuthority;
+    @Nullable
+    private final String mCloudAuthority;
+    @Nullable
+    private final String mIntentAction;
+    @Nullable
+    private final PickerSQLConstants.Table mTableName;
+    private static final String DEFAULT_PROJECTION = "%s AS %s";
+
+    public MediaProjection(
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority,
+            @Nullable String intentAction,
+            @Nullable PickerSQLConstants.Table tableName) {
+        mLocalAuthority = localAuthority;
+        mCloudAuthority = cloudAuthority;
+        mIntentAction = intentAction;
+        mTableName = tableName;
+    }
+
+    /**
+     * Returns a list of all media response sql projections for the given media tables.
+     */
+    public List<String> getAll() {
+        return List.of(
+                get(PickerSQLConstants.MediaResponse.MEDIA_ID),
+                get(PickerSQLConstants.MediaResponse.PICKER_ID),
+                get(PickerSQLConstants.MediaResponse.AUTHORITY),
+                get(PickerSQLConstants.MediaResponse.MEDIA_SOURCE),
+                get(PickerSQLConstants.MediaResponse.WRAPPED_URI),
+                get(PickerSQLConstants.MediaResponse.UNWRAPPED_URI),
+                get(PickerSQLConstants.MediaResponse.DATE_TAKEN_MS),
+                get(PickerSQLConstants.MediaResponse.SIZE_IN_BYTES),
+                get(PickerSQLConstants.MediaResponse.MIME_TYPE),
+                get(PickerSQLConstants.MediaResponse.STANDARD_MIME_TYPE),
+                get(PickerSQLConstants.MediaResponse.DURATION_MS),
+                get(PickerSQLConstants.MediaResponse.IS_PRE_GRANTED)
+        );
+    }
+
+    /**
+     * Returns the sql projection on media tables for a given media response column.
+     */
+    public String get(@NonNull PickerSQLConstants.MediaResponse mediaResponseColumn) {
+        requireNonNull(mediaResponseColumn);
+
+        switch (mediaResponseColumn) {
+            case MEDIA_ID:
+                return String.format(
+                        Locale.ROOT,
+                        DEFAULT_PROJECTION,
+                        getMediaId(),
+                        mediaResponseColumn.getProjectedName());
+            case MEDIA_SOURCE:
+                return String.format(
+                        Locale.ROOT,
+                        DEFAULT_PROJECTION,
+                        getMediaSource(),
+                        mediaResponseColumn.getProjectedName());
+            case WRAPPED_URI:
+                return String.format(
+                        Locale.ROOT,
+                        DEFAULT_PROJECTION,
+                        getWrappedUri(mLocalAuthority, mCloudAuthority, mIntentAction),
+                        mediaResponseColumn.getProjectedName());
+            case AUTHORITY:
+                return String.format(
+                        Locale.ROOT,
+                        DEFAULT_PROJECTION,
+                        getAuthority(mLocalAuthority, mCloudAuthority),
+                        mediaResponseColumn.getProjectedName());
+            case UNWRAPPED_URI:
+                return String.format(
+                        Locale.ROOT,
+                        DEFAULT_PROJECTION,
+                        getUnwrappedUri(mLocalAuthority, mCloudAuthority),
+                        mediaResponseColumn.getProjectedName());
+            case IS_PRE_GRANTED:
+                return String.format(
+                        Locale.ROOT,
+                        DEFAULT_PROJECTION,
+                        getIsPregranted(mIntentAction),
+                        mediaResponseColumn.getProjectedName());
+            default:
+                if (mediaResponseColumn.getColumnName() == null) {
+                    throw new IllegalArgumentException(
+                            "Could not get projection for " + mediaResponseColumn.name()
+                    );
+                }
+                return String.format(
+                        Locale.ROOT,
+                        DEFAULT_PROJECTION,
+                        prependTableName(mTableName, mediaResponseColumn.getColumnName()),
+                        mediaResponseColumn.getProjectedName());
+        }
+    }
+
+
+    private String getMediaId() {
+        return String.format(
+                Locale.ROOT,
+                "IFNULL(%s, %s)",
+                getCloudIdColumn(),
+                getLocalIdColumn()
+        );
+    }
+
+    private String getMediaSource() {
+        return String.format(
+                Locale.ROOT,
+                "CASE WHEN %s IS NULL THEN '%s' ELSE '%s' END",
+                getCloudIdColumn(),
+                MediaSource.LOCAL,
+                MediaSource.REMOTE
+        );
+    }
+
+    private String getAuthority(
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority
+    ) {
+        return String.format(
+                Locale.ROOT,
+                "CASE WHEN %s IS NULL THEN '%s' ELSE '%s' END",
+                getCloudIdColumn(),
+                localAuthority,
+                cloudAuthority
+        );
+    }
+
+    private String getWrappedUri(
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority,
+            @Nullable String intentAction
+    ) {
+        // The format is:
+        // content://media/picker/<user-id>/<cloud-provider-authority>/media/<media-id>
+        return String.format(
+                Locale.ROOT,
+                "'content://%s/%s/%s/' || %s || '/media/' || %s",
+                MediaStore.AUTHORITY,
+                getPickerSegmentFromIntentAction(intentAction),
+                MediaStore.MY_USER_ID,
+                getAuthority(localAuthority, cloudAuthority),
+                getMediaId()
+        );
+    }
+
+    private String getUnwrappedUri(
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority
+    ) {
+        // The format is:
+        // content://<cloud-provider-authority>/media/<media-id>
+        return String.format(
+                Locale.ROOT,
+                "'content://%s@' || %s || '/media/' || %s",
+                MediaStore.MY_USER_ID,
+                getAuthority(localAuthority, cloudAuthority),
+                getMediaId()
+        );
+    }
+
+    private String getIsPregranted(String intentAction) {
+        if (MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP.equals(intentAction)) {
+            return String.format(
+                    Locale.ROOT, "CASE WHEN %s.%s IS NOT NULL THEN 1 ELSE 0 END",
+                    PickerDataLayerV2.CURRENT_GRANTS_TABLE, MediaGrants.FILE_ID_COLUMN);
+        } else {
+            return "0"; // default case for other intent actions
+        }
+    }
+
+    private String getCloudIdColumn() {
+        return prependTableName(mTableName, KEY_CLOUD_ID);
+    }
+
+    private String getLocalIdColumn() {
+        return prependTableName(mTableName, KEY_LOCAL_ID);
+    }
+
+    /**
+     * Prepend the in table name to the given column for sql statements and return the
+     * resultant string.
+     */
+    public static String prependTableName(
+            @NonNull PickerSQLConstants.Table table,
+            @NonNull String columnName) {
+        if (table == null) {
+            return columnName;
+        } else {
+            return String.format(Locale.ROOT, "%s.%s", table.name(), columnName);
+        }
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/MediaSetsDatabaseUtil.java b/src/com/android/providers/media/photopicker/v2/sqlite/MediaSetsDatabaseUtil.java
new file mode 100644
index 000000000..3e554978a
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/MediaSetsDatabaseUtil.java
@@ -0,0 +1,342 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.sqlite;
+
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_IGNORE;
+
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.provider.CloudMediaProviderContract;
+import android.util.Log;
+import android.util.Pair;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Locale;
+import java.util.Objects;
+
+/**
+ * Utility class which holds functionality for inserting and querying media set data
+ */
+public class MediaSetsDatabaseUtil {
+
+    private static final String TAG = "MediaSetsDatabaseUtil";
+    public static final String DELIMITER = ";";
+
+    /**
+     * Inserts metadata about a media set into the media sets table. Insertions that violate the
+     * schema constraints are ignored and not inserted.
+     * @param database The database to insert into
+     * @param mediaSetMetadataCursor Cursor received from CMP which holds the metadata of the media
+     *                               sets
+     * @param categoryId Id of the category to which the media set belongs
+     * @param authority Authority of the media set
+     * @param mimeTypes Mime type filters for the provided query
+     * @return the number rows inserted
+     */
+    public static int cacheMediaSets(
+            @NonNull SQLiteDatabase database, @NonNull Cursor mediaSetMetadataCursor,
+            @NonNull String categoryId, @NonNull String authority,
+            @Nullable List<String> mimeTypes) {
+
+        Objects.requireNonNull(database);
+        Objects.requireNonNull(mediaSetMetadataCursor);
+        Objects.requireNonNull(categoryId);
+        Objects.requireNonNull(authority);
+
+        String mimeTypesAsString = getMimeTypesAsString(mimeTypes);
+        List<ContentValues> insertValues = getMediaSetContentValues(
+                mediaSetMetadataCursor, categoryId, authority, mimeTypesAsString);
+
+        if (insertValues.isEmpty()) {
+            Log.e(TAG, "Cursor received from CMP is empty, nothing to cache.");
+            return 0;
+        }
+
+        try {
+
+            database.beginTransaction();
+            int numberOfMediaSetsInserted = 0;
+
+            for (ContentValues contentValue: insertValues) {
+                try {
+                    final long insertResult = database.insertWithOnConflict(
+                            /* tableName */ PickerSQLConstants.Table.MEDIA_SETS.name(),
+                            /* nullColumnHack */ null,
+                            contentValue,
+                            CONFLICT_IGNORE
+                    );
+
+                    if (insertResult == -1) {
+                        Log.d(TAG, "Could not save MediaSet data due to a conflict constraint");
+                    } else {
+                        numberOfMediaSetsInserted++;
+                    }
+
+                } catch (SQLException e) {
+                    Log.e(TAG, "Could not insert media set row into the media sets table "
+                            + contentValue, e);
+                }
+            }
+            // Mark transaction as successful so that it gets committed after it ends.
+            if (database.inTransaction()) {
+                database.setTransactionSuccessful();
+            }
+
+            return numberOfMediaSetsInserted;
+        } catch (RuntimeException e) {
+            throw new RuntimeException("Couldn't insert values into the database ",  e);
+        } finally {
+            // Mark transaction as ended. The inserted items will either be committed if the
+            // transaction has been set as successful, or roll-backed otherwise.
+            if (database.inTransaction()) {
+                database.endTransaction();
+            }
+        }
+    }
+
+    /**
+     * Returns mediaSetId corresponding to the given mediaSetPickerId
+     * @param database Database to read from
+     * @param mediaSetPickerId Unique pickerDB id
+     * @return mediaSetId and mimeTypes for the given mediaSetPickerId wrapped in a Pair object
+     */
+    public static Pair<String, String[]> getMediaSetIdAndMimeType(
+            @NonNull SQLiteDatabase database,
+            @NonNull String mediaSetPickerId) {
+        Objects.requireNonNull(database);
+        Objects.requireNonNull(mediaSetPickerId);
+
+        SelectSQLiteQueryBuilder queryBuilder = new SelectSQLiteQueryBuilder(database)
+                .setTables(PickerSQLConstants.Table.MEDIA_SETS.name())
+                .setProjection(List.of(
+                        PickerSQLConstants.MediaSetsTableColumns.MEDIA_SET_ID.getColumnName(),
+                        PickerSQLConstants.MediaSetsTableColumns.MIME_TYPE_FILTER.getColumnName()
+                ));
+        queryBuilder.appendWhereStandalone(String.format(
+                Locale.ROOT,
+                "%s = '%s'",
+                PickerSQLConstants.MediaSetsTableColumns.PICKER_ID.getColumnName(),
+                mediaSetPickerId
+        ));
+        try (Cursor cursor = database.rawQuery(queryBuilder.buildQuery(), /*selectionArgs*/null)) {
+            String mediaSetId = "";
+            String mimeTypes = "";
+            if (cursor.moveToFirst()) {
+                mediaSetId = cursor.getString(cursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaSetsTableColumns.MEDIA_SET_ID.getColumnName()));
+                mimeTypes = cursor.getString(cursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaSetsTableColumns.MIME_TYPE_FILTER.getColumnName()));
+                return new Pair<>(mediaSetId, mimeTypes.split(MediaSetsDatabaseUtil.DELIMITER));
+            } else {
+                throw new IllegalArgumentException(
+                        "No entry found in the database corresponding to "
+                                + " the given mediaSetPickerId " + mediaSetPickerId
+                                + ". Cannot fetch mediaSetId and mimeTypes.");
+            }
+        }
+    }
+
+
+    /**
+     * Fetches the metadata of all the media sets under the given category
+     * @param database The database to query on
+     * @param categoryId The id of the category for which the media sets are to be queried
+     * @return Cursor containing metadata of all the media sets under the given category
+     */
+    public static Cursor getMediaSetsForCategory(
+            @NonNull SQLiteDatabase database, @NonNull String categoryId,
+            @NonNull String authority, @Nullable List<String> mimeTypes) {
+        Objects.requireNonNull(database);
+        Objects.requireNonNull(categoryId);
+        Objects.requireNonNull(authority);
+
+        final List<String> projection = List.of(
+                PickerSQLConstants.MediaSetsTableColumns.PICKER_ID.getColumnName(),
+                PickerSQLConstants.MediaSetsTableColumns.MEDIA_SET_AUTHORITY.getColumnName(),
+                PickerSQLConstants.MediaSetsTableColumns.MEDIA_SET_ID.getColumnName(),
+                PickerSQLConstants.MediaSetsTableColumns.DISPLAY_NAME.getColumnName(),
+                PickerSQLConstants.MediaSetsTableColumns.COVER_ID.getColumnName()
+        );
+        final SelectSQLiteQueryBuilder queryBuilder = new SelectSQLiteQueryBuilder(database)
+                .setTables(PickerSQLConstants.Table.MEDIA_SETS.name())
+                .setProjection(projection)
+                .setSortOrder(String.format(
+                        Locale.ROOT,
+                        "%s ASC",
+                        PickerSQLConstants.MediaSetsTableColumns.PICKER_ID.getColumnName()
+                ));
+        queryBuilder
+                .appendWhereStandalone(
+                        String.format(Locale.ROOT, " %s = '%s' ",
+                                PickerSQLConstants.MediaSetsTableColumns.CATEGORY_ID
+                                        .getColumnName(), categoryId))
+                .appendWhereStandalone(
+                        String.format(Locale.ROOT, " %s = '%s' ",
+                                PickerSQLConstants.MediaSetsTableColumns.MEDIA_SET_AUTHORITY
+                                        .getColumnName(), authority)
+                )
+                .appendWhereStandalone(
+                        String.format(Locale.ROOT, " %s = '%s' ",
+                                PickerSQLConstants.MediaSetsTableColumns.MIME_TYPE_FILTER
+                                        .getColumnName(), getMimeTypesAsString(mimeTypes)));
+
+        return database.rawQuery(queryBuilder.buildQuery(), /*selectionArgs*/ null);
+    }
+
+    /**
+     * Fetches the media resume key for the media under the media set identified by the
+     * mediaPickerId
+     * @param database The database to query on
+     * @param mediaPickerId The pickerId of the media set in the media set table for which the
+     *                      key needs to be updated
+     * @return The cursor which contains the media resume key for the media in that media set
+     */
+    public static String getMediaResumeKey(
+            @NonNull SQLiteDatabase database, @NonNull String mediaPickerId) {
+        Objects.requireNonNull(database);
+        Objects.requireNonNull(mediaPickerId);
+
+        final List<String> projection = List.of(
+                PickerSQLConstants.MediaSetsTableColumns.MEDIA_IN_MEDIA_SET_SYNC_RESUME_KEY
+                        .getColumnName());
+        final SelectSQLiteQueryBuilder queryBuilder = new SelectSQLiteQueryBuilder(database)
+                .setTables(PickerSQLConstants.Table.MEDIA_SETS.name())
+                .setProjection(projection);
+        queryBuilder.appendWhereStandalone(
+                String.format(Locale.ROOT, " %s = '%s' ",
+                        PickerSQLConstants.MediaSetsTableColumns.PICKER_ID.getColumnName(),
+                        mediaPickerId)
+        );
+
+        Cursor cursor = database.rawQuery(queryBuilder.buildQuery(), /*selectionArgs*/ null);
+
+        if (cursor.moveToFirst()) {
+            return cursor.getString(cursor.getColumnIndexOrThrow(
+                    PickerSQLConstants.MediaSetsTableColumns.MEDIA_IN_MEDIA_SET_SYNC_RESUME_KEY
+                            .getColumnName()));
+        } else {
+            // Cursor is empty
+            // No match for the mediaSetPickerId found, throwing an error
+            throw new RuntimeException("mediaSetPickerId " + mediaPickerId + " not found in "
+                    + "the media_sets table");
+        }
+    }
+
+    /**
+     * Updates the resume key used to help with syncing of media items under a given media set
+     * @param database The database to query on
+     * @param mediaSetPickerId The pickerId of the media set in the media set table for which the
+     *                         key needs to be updated
+     * @param resumeKey The new value of the resume key
+     */
+    public static void updateMediaInMediaSetSyncResumeKey(@NonNull SQLiteDatabase database,
+            @NonNull String mediaSetPickerId, @Nullable String resumeKey) {
+        Objects.requireNonNull(database);
+        Objects.requireNonNull(mediaSetPickerId);
+
+        String table = PickerSQLConstants.Table.MEDIA_SETS.name();
+
+        ContentValues updateValues = new ContentValues();
+        updateValues.put(
+                PickerSQLConstants.MediaSetsTableColumns.MEDIA_IN_MEDIA_SET_SYNC_RESUME_KEY
+                .getColumnName(),
+                resumeKey);
+
+        database.update(
+                table,
+                updateValues,
+                String.format(
+                        Locale.ROOT,
+                        "%s = '%s'",
+                        PickerSQLConstants.MediaSetsTableColumns.PICKER_ID.getColumnName(),
+                        mediaSetPickerId
+                ),
+                null
+        );
+    }
+
+    private static List<ContentValues> getMediaSetContentValues(
+            Cursor mediaSetCursor, String categoryId, String authority, String mimeTypes) {
+
+        List<ContentValues> contentValuesList = new ArrayList<>();
+
+        // Extract all properties of the media sets returned by the CMP from the cursor
+        if (mediaSetCursor.moveToFirst()) {
+            do {
+                int mediaSetIdIndex = mediaSetCursor.getColumnIndex(
+                        CloudMediaProviderContract.MediaSetColumns.ID);
+                String mediaSetId = mediaSetCursor.getString(mediaSetIdIndex);
+                if (mediaSetId == null || mediaSetId.isEmpty()) {
+                    Log.e(TAG, "Retrieved mediaSetId was empty. Skipping this set.");
+                    continue;
+                }
+                int mediaSetDisplayNameIndex = mediaSetCursor.getColumnIndex(
+                        CloudMediaProviderContract.MediaSetColumns.DISPLAY_NAME);
+                String mediaSetDisplayName = mediaSetCursor.getString(mediaSetDisplayNameIndex);
+                int mediaSetCoverIdIndex = mediaSetCursor.getColumnIndex(CloudMediaProviderContract
+                        .MediaSetColumns.MEDIA_COVER_ID);
+                String mediaCoverId = mediaSetCursor.getString(mediaSetCoverIdIndex);
+
+                ContentValues insertValues = new ContentValues();
+                insertValues.put(
+                        PickerSQLConstants.MediaSetsTableColumns.MEDIA_SET_ID.getColumnName(),
+                        mediaSetId
+                );
+                insertValues.put(
+                        PickerSQLConstants.MediaSetsTableColumns.DISPLAY_NAME.getColumnName(),
+                        mediaSetDisplayName
+                );
+                insertValues.put(
+                        PickerSQLConstants.MediaSetsTableColumns.COVER_ID.getColumnName(),
+                        mediaCoverId
+                );
+                insertValues.put(
+                        PickerSQLConstants.MediaSetsTableColumns.CATEGORY_ID.getColumnName(),
+                        categoryId
+                );
+                insertValues.put(
+                        PickerSQLConstants.MediaSetsTableColumns.MEDIA_SET_AUTHORITY
+                                .getColumnName(), authority
+                );
+                insertValues.put(
+                        PickerSQLConstants.MediaSetsTableColumns.MIME_TYPE_FILTER.getColumnName(),
+                        mimeTypes
+                );
+                contentValuesList.add(insertValues);
+            } while (mediaSetCursor.moveToNext());
+        }
+        return contentValuesList;
+    }
+
+
+    private static String getMimeTypesAsString(@Nullable List<String> mimeTypes) {
+        if (mimeTypes == null || mimeTypes.isEmpty()) {
+            return "";
+        }
+        List<String> modifiableList = new ArrayList<>(mimeTypes);
+        modifiableList.replaceAll(s -> s.toLowerCase(Locale.ROOT));
+        modifiableList.sort(Comparator.naturalOrder());
+        return String.join(DELIMITER, modifiableList);
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/PickerMediaDatabaseUtil.java b/src/com/android/providers/media/photopicker/v2/sqlite/PickerMediaDatabaseUtil.java
new file mode 100644
index 000000000..2bfb1b955
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/PickerMediaDatabaseUtil.java
@@ -0,0 +1,763 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.sqlite;
+
+import static com.android.providers.media.photopicker.v2.PickerDataLayerV2.getDefaultEmptyAlbum;
+import static com.android.providers.media.photopicker.v2.sqlite.MediaProjection.prependTableName;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.database.MatrixCursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.os.Bundle;
+import android.provider.CloudMediaProviderContract;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import com.android.providers.media.photopicker.PickerSyncController;
+import com.android.providers.media.photopicker.v2.model.AlbumMediaQuery;
+import com.android.providers.media.photopicker.v2.model.AlbumsCursorWrapper;
+import com.android.providers.media.photopicker.v2.model.FavoritesMediaQuery;
+import com.android.providers.media.photopicker.v2.model.MediaQuery;
+import com.android.providers.media.photopicker.v2.model.VideoMediaQuery;
+
+import java.util.List;
+import java.util.Locale;
+
+/**
+ * Utility class for querying the Picker DB to fetch media metadata.
+ */
+public class PickerMediaDatabaseUtil {
+    private static final String TAG = "PickerMediaDBUtil";
+
+    /**
+     * Query media from the database and prepare a cursor in response.
+     *
+     * We need to make multiple queries to prepare a response for the media query.
+     * {@link android.database.sqlite.SQLiteQueryBuilder} currently does not support the creation of
+     * a transaction in {@code DEFERRED} mode. This is why we'll perform the read queries in
+     * {@code IMMEDIATE} mode instead.
+     *
+     * @param appContext The application context.
+     * @param syncController Instance of the PickerSyncController singleton.
+     * @param query The MediaQuery object instance that tells us about the media query args.
+     * @param localAuthority The effective local authority that we need to consider for this
+     *                       transaction. If the local items should not be queries but the local
+     *                       authority has some value, the effective local authority would be null.
+     * @param cloudAuthority The effective cloud authority that we need to consider for this
+     *                       transaction. If the local items should not be queries but the local
+     *                       authority has some value, the effective local authority would
+     *                       be null.
+     * @return The cursor with the album media query results.
+     */
+    @NonNull
+    public static Cursor queryMedia(
+            @NonNull Context appContext,
+            @NonNull PickerSyncController syncController,
+            @NonNull MediaQuery query,
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority
+    ) {
+        try {
+            final SQLiteDatabase database = syncController.getDbFacade().getDatabase();
+
+            try {
+                database.beginTransactionNonExclusive();
+
+                Cursor pageData = database.rawQuery(
+                        getMediaPageQuery(
+                                appContext,
+                                query,
+                                database,
+                                PickerSQLConstants.Table.MEDIA,
+                                localAuthority,
+                                cloudAuthority
+                        ),
+                        /* selectionArgs */ null
+                );
+                Bundle extraArgs = new Bundle();
+                Cursor nextPageKeyCursor = database.rawQuery(
+                        getMediaNextPageKeyQuery(
+                                appContext,
+                                query,
+                                database,
+                                PickerSQLConstants.Table.MEDIA,
+                                localAuthority,
+                                cloudAuthority
+                        ),
+                        /* selectionArgs */ null
+                );
+                addNextPageKey(extraArgs, nextPageKeyCursor);
+
+                Cursor prevPageKeyCursor = database.rawQuery(
+                        getMediaPreviousPageQuery(
+                                appContext,
+                                query,
+                                database,
+                                PickerSQLConstants.Table.MEDIA,
+                                localAuthority,
+                                cloudAuthority
+                        ),
+                        /* selectionArgs */ null
+                );
+                addPrevPageKey(extraArgs, prevPageKeyCursor);
+
+                if (query.shouldPopulateItemsBeforeCount()) {
+                    Cursor itemsBeforeCountCursor = database.rawQuery(
+                            getMediaItemsBeforeCountQuery(
+                                    appContext,
+                                    query,
+                                    database,
+                                    PickerSQLConstants.Table.MEDIA,
+                                    localAuthority,
+                                    cloudAuthority
+                            ),
+                            /* selectionArgs */ null
+                    );
+                    addItemsBeforeCountKey(extraArgs, itemsBeforeCountCursor);
+                }
+
+                database.setTransactionSuccessful();
+                pageData.setExtras(extraArgs);
+                Log.i(TAG, "Returning " + pageData.getCount() + " media metadata");
+                return pageData;
+            } finally {
+                database.endTransaction();
+            }
+        } catch (Exception e) {
+            throw new RuntimeException("Could not fetch media", e);
+        }
+    }
+
+
+    /**
+     * @param appContext The application context.
+     * @param syncController Instance of the PickerSyncController singleton.
+     * @param query The AlbumMediaQuery object instance that tells us about the media query args.
+     * @param localAuthority The effective local authority that we need to consider for this
+     *                       transaction. If the local items should not be queries but the local
+     *                       authority has some value, the effective local authority would be null.
+     * @param cloudAuthority The effective cloud authority that we need to consider for this
+     *                       transaction. If the local items should not be queries but the local
+     *                       authority has some value, the effective local authority would
+     *                       be null.
+     * @return The cursor with the album media query results.
+     */
+    @NonNull
+    public static Cursor queryAlbumMedia(
+            @NonNull Context appContext,
+            @NonNull PickerSyncController syncController,
+            @NonNull AlbumMediaQuery query,
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority
+    ) {
+        try {
+            final SQLiteDatabase database = syncController.getDbFacade().getDatabase();
+
+            try {
+                database.beginTransactionNonExclusive();
+                Cursor pageData = database.rawQuery(
+                        getMediaPageQuery(
+                                appContext,
+                                query,
+                                database,
+                                PickerSQLConstants.Table.ALBUM_MEDIA,
+                                localAuthority,
+                                cloudAuthority
+                        ),
+                        /* selectionArgs */ null
+                );
+
+                Bundle extraArgs = new Bundle();
+                Cursor nextPageKeyCursor = database.rawQuery(
+                        getMediaNextPageKeyQuery(
+                                appContext,
+                                query,
+                                database,
+                                PickerSQLConstants.Table.ALBUM_MEDIA,
+                                localAuthority,
+                                cloudAuthority
+                        ),
+                        /* selectionArgs */ null
+                );
+                addNextPageKey(extraArgs, nextPageKeyCursor);
+
+                Cursor prevPageKeyCursor = database.rawQuery(
+                        getMediaPreviousPageQuery(
+                                appContext,
+                                query,
+                                database,
+                                PickerSQLConstants.Table.ALBUM_MEDIA,
+                                localAuthority,
+                                cloudAuthority
+                        ),
+                        /* selectionArgs */ null
+                );
+                addPrevPageKey(extraArgs, prevPageKeyCursor);
+
+                if (query.shouldPopulateItemsBeforeCount()) {
+                    Cursor itemsBeforeCountCursor = database.rawQuery(
+                            getMediaItemsBeforeCountQuery(
+                                    appContext,
+                                    query,
+                                    database,
+                                    PickerSQLConstants.Table.ALBUM_MEDIA,
+                                    localAuthority,
+                                    cloudAuthority
+                            ),
+                            /* selectionArgs */ null
+                    );
+                    addItemsBeforeCountKey(extraArgs, itemsBeforeCountCursor);
+                }
+
+                database.setTransactionSuccessful();
+
+                pageData.setExtras(extraArgs);
+                Log.i(TAG, "Returning " + pageData.getCount() + " album media items for album "
+                        + query.getAlbumId());
+                return pageData;
+            } finally {
+                database.endTransaction();
+            }
+
+
+        } catch (Exception e) {
+            throw new RuntimeException("Could not fetch media", e);
+        }
+    }
+
+    /**
+     * Query media from the database filtered by pre-selection uris and prepare a cursor in
+     * response.
+     *
+     * @param appContext The application context.
+     * @param syncController Instance of the PickerSyncController singleton.
+     * @param query The MediaQuery object instance that tells us about the media query args.
+     * @param localAuthority The effective local authority that we need to consider for this
+     *                       transaction. If the local items should not be queries but the local
+     *                       authority has some value, the effective local authority would be null.
+     * @param cloudAuthority The effective cloud authority that we need to consider for this
+     *                       transaction. If the local items should not be queries but the local
+     *                       authority has some value, the effective local authority would
+     *                       be null.
+     * @return The cursor with the album media query results.
+     */
+    @NonNull
+    public static Cursor queryPreSelectedMedia(
+            @NonNull Context appContext,
+            @NonNull PickerSyncController syncController,
+            @NonNull MediaQuery query,
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority
+    ) {
+
+        final SQLiteDatabase database = syncController.getDbFacade().getDatabase();
+
+        try {
+            Cursor pageData = database.rawQuery(
+                    getMediaPageQuery(
+                            appContext,
+                            query,
+                            database,
+                            PickerSQLConstants.Table.MEDIA,
+                            localAuthority,
+                            cloudAuthority
+                    ),
+                    /* selectionArgs */ null
+            );
+            Log.i(TAG, "Returning " + pageData.getCount() + " media metadata");
+            return pageData;
+        } catch (Exception e) {
+            throw new RuntimeException("Could not fetch media", e);
+        }
+    }
+
+
+    /**
+     * @param albumId The album id of the request album media.
+     * @param appContext The application context.
+     * @param syncController Instance of the PickerSyncController singleton.
+     * @param queryArgs The Bundle with query args received with the request.
+     * @param localAuthority The effective local authority that we need to consider for this
+     *                       transaction. If the local items should not be queries but the local
+     *                       authority has some value, the effective local authority would be null.
+     * @param cloudAuthority The effective cloud authority that we need to consider for this
+     *                       transaction. If the local items should not be queries but the local
+     *                       authority has some value, the effective local authority would
+     *                       be null.
+     * @return The cursor with the album media query results.
+     */
+    @NonNull
+    public static Cursor queryMergedAlbumMedia(
+            @NonNull String albumId,
+            @NonNull Context appContext,
+            @NonNull PickerSyncController syncController,
+            @NonNull Bundle queryArgs,
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority
+    ) {
+        try {
+            MediaQuery query;
+            switch (albumId) {
+                case CloudMediaProviderContract.AlbumColumns.ALBUM_ID_FAVORITES:
+                    query = new FavoritesMediaQuery(queryArgs);
+                    break;
+                case CloudMediaProviderContract.AlbumColumns.ALBUM_ID_VIDEOS:
+                    query = new VideoMediaQuery(queryArgs);
+                    break;
+                default:
+                    throw new IllegalArgumentException("Cannot recognize album " + albumId);
+            }
+
+            final SQLiteDatabase database = syncController.getDbFacade().getDatabase();
+
+            try {
+                database.beginTransactionNonExclusive();
+                Cursor pageData = database.rawQuery(
+                        getMediaPageQuery(
+                                appContext,
+                                query,
+                                database,
+                                PickerSQLConstants.Table.MEDIA,
+                                localAuthority,
+                                cloudAuthority
+                        ),
+                        /* selectionArgs */ null
+                );
+
+                Bundle extraArgs = new Bundle();
+                Cursor nextPageKeyCursor = database.rawQuery(
+                        getMediaNextPageKeyQuery(
+                                appContext,
+                                query,
+                                database,
+                                PickerSQLConstants.Table.MEDIA,
+                                localAuthority,
+                                cloudAuthority
+                        ),
+                        /* selectionArgs */ null
+                );
+                addNextPageKey(extraArgs, nextPageKeyCursor);
+
+                Cursor prevPageKeyCursor = database.rawQuery(
+                        getMediaPreviousPageQuery(
+                                appContext,
+                                query,
+                                database,
+                                PickerSQLConstants.Table.MEDIA,
+                                localAuthority,
+                                cloudAuthority
+                        ),
+                        /* selectionArgs */ null
+                );
+                addPrevPageKey(extraArgs, prevPageKeyCursor);
+
+                if (query.shouldPopulateItemsBeforeCount()) {
+                    Cursor itemsBeforeCountCursor = database.rawQuery(
+                            getMediaItemsBeforeCountQuery(
+                                    appContext,
+                                    query,
+                                    database,
+                                    PickerSQLConstants.Table.MEDIA,
+                                    localAuthority,
+                                    cloudAuthority
+                            ),
+                            /* selectionArgs */ null
+                    );
+                    addItemsBeforeCountKey(extraArgs, itemsBeforeCountCursor);
+                }
+
+                database.setTransactionSuccessful();
+
+                pageData.setExtras(extraArgs);
+                Log.i(TAG, "Returning " + pageData.getCount() + " album media items for album "
+                        + albumId);
+                return pageData;
+            } finally {
+                database.endTransaction();
+            }
+        } catch (Exception e) {
+            throw new RuntimeException("Could not fetch media", e);
+        }
+    }
+
+
+    /**
+     * Return merged albums cursor for the given merged album id.
+     *
+     * @param albumId        Merged album id.
+     * @param queryArgs      Query arguments bundle that will be used to filter albums.
+     * @param database       Instance of Picker SQLiteDatabase.
+     * @param localAuthority The local authority if local albums should be returned, otherwise this
+     *                       argument should be null.
+     * @param cloudAuthority The cloud authority if cloud albums should be returned, otherwise this
+     *                       argument should be null.
+     */
+    public static AlbumsCursorWrapper getMergedAlbumsCursor(
+            @NonNull String albumId,
+            Context appContext,
+            @NonNull Bundle queryArgs,
+            @NonNull SQLiteDatabase database,
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority) {
+        if (localAuthority == null && cloudAuthority == null) {
+            Log.e(TAG, "Cannot get merged albums when no providers are available");
+            return null;
+        }
+
+        final MediaQuery query;
+        if (albumId.equals(CloudMediaProviderContract.AlbumColumns.ALBUM_ID_VIDEOS)) {
+            VideoMediaQuery videoQuery = new VideoMediaQuery(queryArgs, 1);
+            if (!videoQuery.shouldDisplayVideosAlbum()) {
+                return null;
+            }
+            query = videoQuery;
+        } else if (albumId.equals(CloudMediaProviderContract.AlbumColumns.ALBUM_ID_FAVORITES)) {
+            query = new FavoritesMediaQuery(queryArgs, 1);
+        } else {
+            Log.e(TAG, "Cannot recognize merged album " + albumId);
+            return null;
+        }
+
+        try {
+            database.beginTransactionNonExclusive();
+            Cursor pickerDBResponse = database.rawQuery(
+                    getMediaPageQuery(
+                            appContext,
+                            query,
+                            database,
+                            PickerSQLConstants.Table.MEDIA,
+                            localAuthority,
+                            cloudAuthority
+                    ),
+                    /* selectionArgs */ null
+            );
+
+            if (pickerDBResponse.moveToFirst()) {
+                // Conform to the album response projection. Temporary code, this will change once
+                // we start caching album metadata.
+                final MatrixCursor result =
+                        new MatrixCursor(CloudMediaProviderContract.AlbumColumns.ALL_PROJECTION);
+                final String authority = pickerDBResponse.getString(pickerDBResponse.getColumnIndex(
+                        PickerSQLConstants.MediaResponse.AUTHORITY.getProjectedName()));
+                final String[] projectionValue = new String[]{
+                        /* albumId */ albumId,
+                        pickerDBResponse.getString(pickerDBResponse.getColumnIndex(
+                                PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getProjectedName())),
+                        /* displayName */ albumId,
+                        pickerDBResponse.getString(pickerDBResponse.getColumnIndex(
+                                PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())),
+                        /* count */ "0", // This value is not used anymore
+                        authority,
+                };
+                result.addRow(projectionValue);
+                return new AlbumsCursorWrapper(result, authority, localAuthority);
+            }
+
+            pickerDBResponse.close();
+
+            // Always show Videos album if cloud feature is turned on and the MIME types filter
+            // would allow for video format(s).
+            if (albumId.equals(CloudMediaProviderContract.AlbumColumns.ALBUM_ID_VIDEOS)
+                    && cloudAuthority != null) {
+                return new AlbumsCursorWrapper(
+                        getDefaultEmptyAlbum(albumId),
+                        /* albumAuthority */ localAuthority,
+                        /* localAuthority */ localAuthority);
+            }
+
+            // Always show Favorites album.
+            if (albumId.equals(CloudMediaProviderContract.AlbumColumns.ALBUM_ID_FAVORITES)) {
+                return new AlbumsCursorWrapper(
+                        getDefaultEmptyAlbum(albumId),
+                        /* albumAuthority */ localAuthority,
+                        /* localAuthority */ localAuthority);
+            }
+
+            return null;
+        } finally {
+            database.setTransactionSuccessful();
+            database.endTransaction();
+        }
+    }
+
+    /**
+     * Builds and returns the SQL query to get the page contents from the Media table in Picker DB.
+     */
+    private static String getMediaPageQuery(
+            @Nullable Context appContext,
+            @NonNull MediaQuery query,
+            @NonNull SQLiteDatabase database,
+            @NonNull PickerSQLConstants.Table table,
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority) {
+        final MediaProjection projectionUtil = new MediaProjection(
+                localAuthority,
+                cloudAuthority,
+                query.getIntentAction(),
+                table
+        );
+
+        SelectSQLiteQueryBuilder queryBuilder = new SelectSQLiteQueryBuilder(database)
+                .setTables(query.getTableWithRequiredJoins(table.toString(), appContext,
+                        query.getCallingPackageUid(), query.getIntentAction()))
+                .setProjection(projectionUtil.getAll())
+                .setSortOrder(getSortOrder(table, /* reverseOrder */ false))
+                .setLimit(query.getPageSize());
+
+        query.addWhereClause(
+                queryBuilder,
+                table,
+                localAuthority,
+                cloudAuthority,
+                /* reverseOrder */ false
+        );
+
+        return queryBuilder.buildQuery();
+    }
+
+    /**
+     * Builds and returns the SQL query to get the next page key from the Media table in Picker DB.
+     */
+    @Nullable
+    private static String getMediaNextPageKeyQuery(
+            @Nullable Context appContext,
+            @NonNull MediaQuery query,
+            @NonNull SQLiteDatabase database,
+            @NonNull PickerSQLConstants.Table table,
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority) {
+        if (query.getPageSize() == Integer.MAX_VALUE) {
+            return null;
+        }
+
+        final MediaProjection projectionUtil = new MediaProjection(
+                localAuthority,
+                cloudAuthority,
+                query.getIntentAction(),
+                table
+        );
+
+        SelectSQLiteQueryBuilder queryBuilder = new SelectSQLiteQueryBuilder(database)
+                .setTables(
+                        query.getTableWithRequiredJoins(table.toString(), appContext,
+                                query.getCallingPackageUid(), query.getIntentAction()))
+                .setProjection(List.of(
+                        projectionUtil.get(PickerSQLConstants.MediaResponse.PICKER_ID),
+                        projectionUtil.get(PickerSQLConstants.MediaResponse.DATE_TAKEN_MS)
+                ))
+                .setSortOrder(getSortOrder(table, /* reverseOrder */ false))
+                .setLimit(1)
+                .setOffset(query.getPageSize());
+
+        query.addWhereClause(
+                queryBuilder,
+                table,
+                localAuthority,
+                cloudAuthority,
+                /* reverseOrder */ false
+        );
+
+        return queryBuilder.buildQuery();
+    }
+
+    /**
+     * Builds and returns the SQL query to get the previous page contents from the Media table in
+     * Picker DB.
+     *
+     * We fetch the whole page and not just one key because it is possible that the previous page
+     * is smaller than the page size. So, we get the whole page and only use the last row item to
+     * get the previous page key.
+     */
+    private static String getMediaPreviousPageQuery(
+            @Nullable Context appContext,
+            @NonNull MediaQuery query,
+            @NonNull SQLiteDatabase database,
+            @NonNull PickerSQLConstants.Table table,
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority) {
+        final MediaProjection projectionUtil = new MediaProjection(
+                localAuthority,
+                cloudAuthority,
+                query.getIntentAction(),
+                table
+        );
+
+        final SelectSQLiteQueryBuilder queryBuilder = new SelectSQLiteQueryBuilder(database)
+                .setTables(
+                        query.getTableWithRequiredJoins(table.toString(), appContext,
+                                query.getCallingPackageUid(), query.getIntentAction()))
+                .setProjection(List.of(
+                        projectionUtil.get(PickerSQLConstants.MediaResponse.PICKER_ID),
+                        projectionUtil.get(PickerSQLConstants.MediaResponse.DATE_TAKEN_MS)
+                )).setSortOrder(getSortOrder(table, /* reverseOrder */ true)
+                ).setLimit(query.getPageSize());
+
+
+        query.addWhereClause(
+                queryBuilder,
+                table,
+                localAuthority,
+                cloudAuthority,
+                /* reverseOrder */ true
+        );
+
+        return queryBuilder.buildQuery();
+    }
+
+    /**
+     * Builds and returns the SQL query to get the count of items before the given page from the
+     * Media table in Picker DB.
+     *
+     * The result only contains one row with one column that will hold the count of the items.
+     */
+    private static String getMediaItemsBeforeCountQuery(
+            @Nullable Context appContext,
+            @NonNull MediaQuery query,
+            @NonNull SQLiteDatabase database,
+            @NonNull PickerSQLConstants.Table table,
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority) {
+        SelectSQLiteQueryBuilder queryBuilder = new SelectSQLiteQueryBuilder(database)
+                .setTables(
+                        query.getTableWithRequiredJoins(table.toString(), appContext,
+                                query.getCallingPackageUid(), query.getIntentAction()))
+                .setProjection(List.of("Count(*) AS " + PickerSQLConstants.COUNT_COLUMN))
+                .setSortOrder(getSortOrder(table, /* reverseOrder */ true));
+
+        query.addWhereClause(
+                queryBuilder,
+                table,
+                localAuthority,
+                cloudAuthority,
+                /* reverseOrder */ true
+        );
+
+        return queryBuilder.buildQuery();
+    }
+
+    /**
+     * Adds the previous page key to the cursor extras from the given cursor.
+     *
+     * This is not a part of the page data. Photo Picker UI uses the Paging library requires us to
+     * provide the previous page key and the next page key as part of a page load response.
+     * The page key in this case refers to the date taken and the picker id of the first item in
+     * the page.
+     */
+    public static void addPrevPageKey(Bundle extraArgs, Cursor prevPageKeyCursor) {
+        if (prevPageKeyCursor.moveToLast()) {
+            final int pickerIdColumnIndex = prevPageKeyCursor.getColumnIndex(
+                    PickerSQLConstants.MediaResponse.PICKER_ID.getProjectedName()
+            );
+
+            if (pickerIdColumnIndex >= 0) {
+                extraArgs.putLong(PickerSQLConstants.MediaResponseExtras.PREV_PAGE_ID.getKey(),
+                        prevPageKeyCursor.getLong(pickerIdColumnIndex)
+                );
+            }
+
+            final int dateTakenColumnIndex = prevPageKeyCursor.getColumnIndex(
+                    PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getProjectedName()
+            );
+
+            if (dateTakenColumnIndex >= 0) {
+                extraArgs.putLong(PickerSQLConstants.MediaResponseExtras
+                                .PREV_PAGE_DATE_TAKEN.getKey(),
+                        prevPageKeyCursor.getLong(dateTakenColumnIndex)
+                );
+            }
+        }
+    }
+
+    /**
+     * Adds items before count key to the cursor extras from the provided cursor.
+     */
+    private static void addItemsBeforeCountKey(Bundle extraArgs, Cursor itemsBeforeCountCursor) {
+        if (itemsBeforeCountCursor.moveToFirst()) {
+            final int itemsBeforeCountIndex =
+                    itemsBeforeCountCursor.getColumnIndex(PickerSQLConstants.COUNT_COLUMN);
+            extraArgs.putInt(
+                    PickerSQLConstants.MediaResponseExtras.ITEMS_BEFORE_COUNT.getKey(),
+                    itemsBeforeCountCursor.getInt(itemsBeforeCountIndex)
+            );
+        }
+    }
+
+
+    /**
+     * Adds the next page key to the cursor extras from the given cursor.
+     *
+     * This is not a part of the page data. Photo Picker UI uses the Paging library requires us to
+     * provide the previous page key and the next page key as part of a page load response.
+     * The page key in this case refers to the date taken and the picker id of the first item in
+     * the page.
+     */
+    public static void addNextPageKey(Bundle extraArgs, Cursor nextPageKeyCursor) {
+        if (nextPageKeyCursor.moveToFirst()) {
+            final int pickerIdColumnIndex = nextPageKeyCursor.getColumnIndex(
+                    PickerSQLConstants.MediaResponse.PICKER_ID.getProjectedName()
+            );
+
+            if (pickerIdColumnIndex >= 0) {
+                extraArgs.putLong(PickerSQLConstants.MediaResponseExtras.NEXT_PAGE_ID.getKey(),
+                        nextPageKeyCursor.getLong(pickerIdColumnIndex)
+                );
+            }
+
+            final int dateTakenColumnIndex = nextPageKeyCursor.getColumnIndex(
+                    PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getProjectedName()
+            );
+
+            if (dateTakenColumnIndex >= 0) {
+                extraArgs.putLong(PickerSQLConstants.MediaResponseExtras
+                                .NEXT_PAGE_DATE_TAKEN.getKey(),
+                        nextPageKeyCursor.getLong(dateTakenColumnIndex)
+                );
+            }
+        }
+    }
+
+    private static String getSortOrder(
+            @NonNull PickerSQLConstants.Table table,
+            boolean reverseOrder) {
+        if (reverseOrder) {
+            return String.format(
+                    Locale.ROOT,
+                    "%s ASC, %s ASC",
+                    prependTableName(
+                            table,
+                            PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getColumnName()),
+                    prependTableName(
+                            table,
+                            PickerSQLConstants.MediaResponse.PICKER_ID.getColumnName())
+            );
+        } else  {
+            return String.format(
+                    Locale.ROOT,
+                    "%s DESC, %s DESC",
+                    prependTableName(
+                            table,
+                            PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getColumnName()),
+                    prependTableName(
+                            table,
+                            PickerSQLConstants.MediaResponse.PICKER_ID.getColumnName())
+            );
+        }
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/v2/PickerSQLConstants.java b/src/com/android/providers/media/photopicker/v2/sqlite/PickerSQLConstants.java
similarity index 50%
rename from src/com/android/providers/media/photopicker/v2/PickerSQLConstants.java
rename to src/com/android/providers/media/photopicker/v2/sqlite/PickerSQLConstants.java
index 872342ecc..db3fa931e 100644
--- a/src/com/android/providers/media/photopicker/v2/PickerSQLConstants.java
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/PickerSQLConstants.java
@@ -14,14 +14,13 @@
  * limitations under the License.
  */
 
-package com.android.providers.media.photopicker.v2;
+package com.android.providers.media.photopicker.v2.sqlite;
+
+import static androidx.annotation.VisibleForTesting.PACKAGE_PRIVATE;
 
-import static com.android.providers.media.PickerUriResolver.getPickerSegmentFromIntentAction;
-import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_CLOUD_ID;
 import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_DATE_TAKEN_MS;
 import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_DURATION_MS;
 import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_ID;
-import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_LOCAL_ID;
 import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_MIME_TYPE;
 import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_SIZE_BYTES;
 import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_STANDARD_MIME_TYPE_EXTENSION;
@@ -29,34 +28,40 @@ import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_ST
 import static java.util.Objects.requireNonNull;
 
 import android.provider.CloudMediaProviderContract;
-import android.provider.MediaStore;
 
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
-
-import com.android.providers.media.MediaGrants;
-import com.android.providers.media.photopicker.v2.model.MediaSource;
+import androidx.annotation.VisibleForTesting;
 
 import java.util.Arrays;
+import java.util.Objects;
 
 /**
  * Helper class that keeps track of Picker related Constants.
  */
 public class PickerSQLConstants {
+    public static final int DEFAULT_SEARCH_SUGGESTIONS_LIMIT = 50;
+    public static final int DEFAULT_SEARCH_HISTORY_SUGGESTIONS_LIMIT = 3;
     static final String COUNT_COLUMN = "Count";
 
     /**
      * An enum that holds the table names in Picker DB
      */
-    enum Table {
+    public enum Table {
         MEDIA,
         ALBUM_MEDIA,
+        SEARCH_REQUEST,
+        SEARCH_RESULT_MEDIA,
+        SEARCH_HISTORY,
+        SEARCH_SUGGESTION,
+        MEDIA_SETS,
+        MEDIA_IN_MEDIA_SETS
     }
 
     /**
      * An enum that holds the columns names for the Available Providers query response.
      */
-    enum AvailableProviderResponse {
+    public enum AvailableProviderResponse {
         AUTHORITY("authority"),
         MEDIA_SOURCE("media_source"),
         UID("uid"),
@@ -73,7 +78,7 @@ public class PickerSQLConstants {
         }
     }
 
-    enum CollectionInfoResponse {
+    public enum CollectionInfoResponse {
         AUTHORITY("authority"),
         COLLECTION_ID("collection_id"),
         ACCOUNT_NAME("account_name");
@@ -131,9 +136,9 @@ public class PickerSQLConstants {
     }
 
     /**
-     * An enum that holds the DB columns names and projections for the Media SQL query response.
+     * An enum that holds the DB columns names and projected names for the Media SQL query response.
      */
-    enum MediaResponse {
+    public enum MediaResponse {
         MEDIA_ID(CloudMediaProviderContract.MediaColumns.ID),
         AUTHORITY(CloudMediaProviderContract.MediaColumns.AUTHORITY),
         MEDIA_SOURCE("media_source"),
@@ -148,7 +153,6 @@ public class PickerSQLConstants {
         DURATION_MS(KEY_DURATION_MS, CloudMediaProviderContract.MediaColumns.DURATION_MILLIS),
         IS_PRE_GRANTED("is_pre_granted");
 
-        private static final String DEFAULT_PROJECTION = "%s AS %s";
         @Nullable
         private final String mColumnName;
         @NonNull
@@ -173,174 +177,199 @@ public class PickerSQLConstants {
         public String getProjectedName() {
             return mProjectedName;
         }
+    }
 
-        @NonNull
-        public String getProjection(
-                @Nullable String localAuthority,
-                @Nullable String cloudAuthority,
-                @Nullable String intentAction
-        ) {
-            switch (this) {
-                case WRAPPED_URI:
-                    return String.format(
-                            DEFAULT_PROJECTION,
-                            getWrappedUri(localAuthority, cloudAuthority, intentAction),
-                            mProjectedName
-                    );
-                default:
-                    return getProjection(localAuthority, cloudAuthority);
-            }
+    public enum MediaResponseExtras {
+        PREV_PAGE_ID("prev_page_picker_id"),
+        PREV_PAGE_DATE_TAKEN("prev_page_date_taken"),
+        NEXT_PAGE_ID("next_page_picker_id"),
+        NEXT_PAGE_DATE_TAKEN("next_page_date_taken"),
+        ITEMS_BEFORE_COUNT("items_before_count");
+
+        private final String mKey;
+
+        MediaResponseExtras(String key) {
+            mKey = key;
         }
 
-        @NonNull
-        public String getProjection(
-                @Nullable String localAuthority,
-                @Nullable String cloudAuthority
-        ) {
-            switch (this) {
-                case AUTHORITY:
-                    return String.format(
-                            DEFAULT_PROJECTION,
-                            getAuthority(localAuthority, cloudAuthority),
-                            mProjectedName
-                    );
-                case UNWRAPPED_URI:
-                    return String.format(
-                            DEFAULT_PROJECTION,
-                            getUnwrappedUri(localAuthority, cloudAuthority),
-                            mProjectedName
-                    );
-                default:
-                    return getProjection();
-            }
+        public String getKey() {
+            return mKey;
         }
+    }
 
-        @NonNull
-        public String getProjection() {
-            switch (this) {
-                case MEDIA_ID:
-                    return String.format(
-                            DEFAULT_PROJECTION,
-                            getMediaId(),
-                            mProjectedName
-                    );
-                case MEDIA_SOURCE:
-                    return String.format(
-                            DEFAULT_PROJECTION,
-                            getMediaSource(),
-                            mProjectedName
-                    );
-                default:
-                    if (mColumnName == null) {
-                        throw new IllegalArgumentException(
-                                "Could not get projection for " + this.name()
-                        );
-                    }
-                    return String.format(DEFAULT_PROJECTION, mColumnName, mProjectedName);
-            }
+    public enum SearchRequestTableColumns {
+        SEARCH_REQUEST_ID("_id"),
+        SYNC_RESUME_KEY("sync_resume_key"),
+        SEARCH_TEXT("search_text"),
+        MEDIA_SET_ID("media_set_id"),
+        SUGGESTION_TYPE("suggestion_type"),
+        AUTHORITY("authority"),
+        MIME_TYPES("mime_types");
+
+        private final String mColumnName;
+
+        SearchRequestTableColumns(@NonNull String columnName) {
+            mColumnName = columnName;
         }
 
-        @NonNull
-        public String getProjection(String intentAction) {
-            switch (this) {
-                case IS_PRE_GRANTED:
-                    return String.format(DEFAULT_PROJECTION, getIsPregranted(intentAction),
-                            mProjectedName);
-                default:
-                    if (mColumnName == null) {
-                        throw new IllegalArgumentException(
-                                "Could not get projection for " + this.name()
-                        );
-                    }
-                    return String.format(DEFAULT_PROJECTION, mColumnName, mProjectedName);
-            }
+        public String getColumnName() {
+            return mColumnName;
+        }
+    }
+
+    @VisibleForTesting(otherwise = PACKAGE_PRIVATE)
+    public enum SearchResultMediaTableColumns {
+        PICKER_ID("_id"),
+        SEARCH_REQUEST_ID("search_request_id"),
+        LOCAL_ID("local_id"),
+        CLOUD_ID("cloud_id");
+
+        private final String mColumnName;
+
+        SearchResultMediaTableColumns(@NonNull String columnName) {
+            mColumnName = columnName;
+        }
+
+        public String getColumnName() {
+            return mColumnName;
+        }
+    }
+
+
+    @VisibleForTesting(otherwise = PACKAGE_PRIVATE)
+    public enum SearchHistoryTableColumns {
+        PICKER_ID("_id"),
+        AUTHORITY("authority"),
+        SEARCH_TEXT("search_text"),
+        MEDIA_SET_ID("media_set_id"),
+        COVER_MEDIA_ID("cover_media_id"),
+        CREATION_TIME_MS("creation_time_ms");
+
+        private final String mColumnName;
+
+        SearchHistoryTableColumns(@NonNull String columnName) {
+            mColumnName = columnName;
         }
 
-        private String getMediaId() {
-            return String.format(
-                    "IFNULL(%s, %s)",
-                    KEY_CLOUD_ID,
-                    KEY_LOCAL_ID
-            );
+        public String getColumnName() {
+            return mColumnName;
         }
+    }
+
+    @VisibleForTesting(otherwise = PACKAGE_PRIVATE)
+    public enum SearchSuggestionsTableColumns {
+        PICKER_ID("_id"),
+        AUTHORITY("authority"),
+        SEARCH_TEXT("search_text"),
+        MEDIA_SET_ID("media_set_id"),
+        COVER_MEDIA_ID("cover_media_id"),
+        SUGGESTION_TYPE("suggestion_type"),
+        CREATION_TIME_MS("creation_time_ms");
+
+        private final String mColumnName;
 
-        private String getMediaSource() {
-            return String.format(
-                    "CASE WHEN %s IS NULL THEN '%s' ELSE '%s' END",
-                    KEY_CLOUD_ID,
-                    MediaSource.LOCAL,
-                    MediaSource.REMOTE
-            );
+        SearchSuggestionsTableColumns(@NonNull String columnName) {
+            mColumnName = columnName;
         }
 
-        private String getAuthority(
-                @Nullable String localAuthority,
-                @Nullable String cloudAuthority
-        ) {
-            return String.format(
-                    "CASE WHEN %s IS NULL THEN '%s' ELSE '%s' END",
-                    KEY_CLOUD_ID,
-                    localAuthority,
-                    cloudAuthority
-            );
+        public String getColumnName() {
+            return mColumnName;
         }
+    }
+
+    public enum MediaSetsTableColumns {
+        PICKER_ID("_id"),
+        CATEGORY_ID("category_id"),
+        MEDIA_SET_ID("media_set_id"),
+        DISPLAY_NAME("display_name"),
+        COVER_ID("cover_id"),
+        MEDIA_SET_AUTHORITY("media_set_authority"),
+        MIME_TYPE_FILTER("mime_type_filter"),
+        MEDIA_IN_MEDIA_SET_SYNC_RESUME_KEY("media_in_media_set_sync_resume_key");
+
+        private final String mColumnName;
 
-        private String getWrappedUri(
-                @Nullable String localAuthority,
-                @Nullable String cloudAuthority,
-                @Nullable String intentAction
-        ) {
-            // The format is:
-            // content://media/picker/<user-id>/<cloud-provider-authority>/media/<media-id>
-            return String.format(
-                    "'content://%s/%s/%s/' || %s || '/media/' || %s",
-                    MediaStore.AUTHORITY,
-                    getPickerSegmentFromIntentAction(intentAction),
-                    MediaStore.MY_USER_ID,
-                    getAuthority(localAuthority, cloudAuthority),
-                    getMediaId()
-            );
+        MediaSetsTableColumns(@NonNull String columnName) {
+            Objects.requireNonNull(columnName);
+            mColumnName = columnName;
         }
 
-        private String getUnwrappedUri(
-                @Nullable String localAuthority,
-                @Nullable String cloudAuthority
-        ) {
-            // The format is:
-            // content://<cloud-provider-authority>/media/<media-id>
-            return String.format(
-                    "'content://%s@' || %s || '/media/' || %s",
-                    MediaStore.MY_USER_ID,
-                    getAuthority(localAuthority, cloudAuthority),
-                    getMediaId()
-            );
+        public String getColumnName() {
+            return mColumnName;
         }
+    }
 
-        private String getIsPregranted(String intentAction) {
-            if (MediaStore.ACTION_USER_SELECT_IMAGES_FOR_APP.equals(intentAction)) {
-                return String.format("CASE WHEN %s.%s IS NOT NULL THEN 1 ELSE 0 END",
-                        PickerDataLayerV2.CURRENT_GRANTS_TABLE, MediaGrants.FILE_ID_COLUMN);
-            } else {
-                return "0"; // default case for other intent actions
-            }
+
+    public enum SearchSuggestionsResponseColumns {
+        AUTHORITY("authority"),
+        MEDIA_SET_ID("media_set_id"),
+        SEARCH_TEXT("display_text"),
+        COVER_MEDIA_ID("cover_media_id"),
+        SUGGESTION_TYPE("suggestion_type");
+
+        private final String mProjection;
+
+        SearchSuggestionsResponseColumns(@NonNull String projection) {
+            mProjection = projection;
+        }
+
+        public String getProjection() {
+            return mProjection;
         }
     }
 
-    enum MediaResponseExtras {
-        PREV_PAGE_ID("prev_page_picker_id"),
-        PREV_PAGE_DATE_TAKEN("prev_page_date_taken"),
-        NEXT_PAGE_ID("next_page_picker_id"),
-        NEXT_PAGE_DATE_TAKEN("next_page_date_taken"),
-        ITEMS_BEFORE_COUNT("items_before_count");
+    public enum MediaInMediaSetsTableColumns {
+        PICKER_ID("_id"),
+        LOCAL_ID("local_id"),
+        CLOUD_ID("cloud_id"),
+        MEDIA_SETS_PICKER_ID("media_set_picker_id");
 
-        private final String mKey;
+        private final String mColumnName;
 
-        MediaResponseExtras(String key) {
-            mKey = key;
+        MediaInMediaSetsTableColumns(@NonNull String columnName) {
+            Objects.requireNonNull(columnName);
+            mColumnName = columnName;
         }
 
-        public String getKey() {
-            return mKey;
+        public String getColumnName() {
+            return mColumnName;
+        }
+    }
+
+    public enum MediaGroupResponseColumns {
+        /** Type of media group - Album, Category or MediaSet. This cannot be null. */
+        MEDIA_GROUP("media_group"),
+        /** Identifier received from CMP. This cannot be null. */
+        GROUP_ID("group_id"),
+        /** Identifier used in Picker Backend, if any. */
+        PICKER_ID("picker_id"),
+        /** Display name for the group, if any. */
+        DISPLAY_NAME("display_name"),
+        /** Source provider's authority. */
+        AUTHORITY("authority"),
+        /** Cover image Uri for the group. */
+        UNWRAPPED_COVER_URI("cover_uri_1"),
+        /** Additional cover image Uri for the category. */
+        ADDITIONAL_UNWRAPPED_COVER_URI_1("cover_uri_2"),
+        /** Additional cover image Uri for the category. */
+        ADDITIONAL_UNWRAPPED_COVER_URI_2("cover_uri_3"),
+        /** Additional cover image Uri for the category. */
+        ADDITIONAL_UNWRAPPED_COVER_URI_3("cover_uri_4"),
+        /** If the media group is category, this will be populated with the category type. */
+        CATEGORY_TYPE("category_type"),
+        /** True, if the media category is leaf category which contains media sets,
+         * otherwise false. */
+        IS_LEAF_CATEGORY("is_leaf_category");
+
+        private final String mColumnName;
+
+        MediaGroupResponseColumns(@NonNull String columnName) {
+            Objects.requireNonNull(columnName);
+            mColumnName = columnName;
+        }
+
+        public String getColumnName() {
+            return mColumnName;
         }
     }
 }
diff --git a/src/com/android/providers/media/photopicker/v2/SQLiteQueryBuilder.java b/src/com/android/providers/media/photopicker/v2/sqlite/SQLiteQueryBuilder.java
similarity index 97%
rename from src/com/android/providers/media/photopicker/v2/SQLiteQueryBuilder.java
rename to src/com/android/providers/media/photopicker/v2/sqlite/SQLiteQueryBuilder.java
index c242eca2e..cb048ceae 100644
--- a/src/com/android/providers/media/photopicker/v2/SQLiteQueryBuilder.java
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/SQLiteQueryBuilder.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.android.providers.media.photopicker.v2;
+package com.android.providers.media.photopicker.v2.sqlite;
 
 import android.database.sqlite.SQLiteDatabase;
 
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/SearchCloudMediaSubquery.java b/src/com/android/providers/media/photopicker/v2/sqlite/SearchCloudMediaSubquery.java
new file mode 100644
index 000000000..f1d22420b
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/SearchCloudMediaSubquery.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.sqlite;
+
+import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_CLOUD_ID;
+
+import android.os.Bundle;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import java.util.Locale;
+
+/**
+ * Utility class to query cloud media items from search_result_media table and media table in
+ * Picker DB.
+ */
+public class SearchCloudMediaSubquery extends SearchMediaSubQuery {
+    public SearchCloudMediaSubquery(Bundle queryArgs, int searchRequestID) {
+        super(queryArgs, searchRequestID);
+    }
+
+    @Override
+    public String getTableWithRequiredJoins() {
+        return String.format(
+                Locale.ROOT,
+                " %s INNER JOIN %s ON %s.%s = %s.%s ",
+                PickerSQLConstants.Table.MEDIA.name(),
+                PickerSQLConstants.Table.SEARCH_RESULT_MEDIA.name(),
+                PickerSQLConstants.Table.MEDIA.name(),
+                KEY_CLOUD_ID,
+                PickerSQLConstants.Table.SEARCH_RESULT_MEDIA.name(),
+                PickerSQLConstants.SearchResultMediaTableColumns.CLOUD_ID.getColumnName());
+    }
+
+    @Override
+    public void addWhereClause(
+            @NonNull SelectSQLiteQueryBuilder queryBuilder,
+            @NonNull PickerSQLConstants.Table table,
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority,
+            boolean reverseOrder
+    ) {
+        super.addWhereClause(queryBuilder, table, localAuthority, cloudAuthority, reverseOrder);
+
+        queryBuilder.appendWhereStandalone(
+                String.format(
+                        Locale.ROOT,
+                        "%s.%s IS NOT NULL",
+                        PickerSQLConstants.Table.MEDIA.name(),
+                        KEY_CLOUD_ID));
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/SearchLocalMediaSubQuery.java b/src/com/android/providers/media/photopicker/v2/sqlite/SearchLocalMediaSubQuery.java
new file mode 100644
index 000000000..4fbf855c3
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/SearchLocalMediaSubQuery.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.sqlite;
+
+import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_CLOUD_ID;
+import static com.android.providers.media.photopicker.data.PickerDbFacade.KEY_LOCAL_ID;
+
+import android.os.Bundle;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import java.util.Locale;
+
+/**
+ * Utility class to query local media items from search_result_media table and media table in
+ * Picker DB.
+ */
+public class SearchLocalMediaSubQuery extends SearchMediaSubQuery {
+    public SearchLocalMediaSubQuery(Bundle queryArgs, int searchRequestID) {
+        super(queryArgs, searchRequestID);
+    }
+
+    @Override
+    public String getTableWithRequiredJoins() {
+        return String.format(
+                Locale.ROOT,
+                " %s INNER JOIN %s ON %s.%s = %s.%s ",
+                PickerSQLConstants.Table.MEDIA.name(),
+                PickerSQLConstants.Table.SEARCH_RESULT_MEDIA.name(),
+                PickerSQLConstants.Table.MEDIA.name(),
+                KEY_LOCAL_ID,
+                PickerSQLConstants.Table.SEARCH_RESULT_MEDIA.name(),
+                PickerSQLConstants.SearchResultMediaTableColumns.LOCAL_ID.getColumnName());
+    }
+
+    @Override
+    public void addWhereClause(
+            @NonNull SelectSQLiteQueryBuilder queryBuilder,
+            @NonNull PickerSQLConstants.Table table,
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority,
+            boolean reverseOrder
+    ) {
+        super.addWhereClause(queryBuilder, table, localAuthority, cloudAuthority, reverseOrder);
+
+        // In order to identify if a row represents local media item and not a cloud media item,
+        // check if the cloud_id is null. We can't have a check on local_id because local_id can be
+        // populated for a cloud media item as well.
+        queryBuilder.appendWhereStandalone(
+                String.format(
+                        Locale.ROOT,
+                        "%s.%s IS NULL",
+                        PickerSQLConstants.Table.MEDIA.name(),
+                        KEY_CLOUD_ID));
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/SearchMediaQuery.java b/src/com/android/providers/media/photopicker/v2/sqlite/SearchMediaQuery.java
new file mode 100644
index 000000000..df3c052c7
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/SearchMediaQuery.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.sqlite;
+
+import android.database.sqlite.SQLiteDatabase;
+import android.os.Bundle;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+import java.util.Objects;
+
+/**
+ * Utility class to query media items from search_result_media table and media table in Picker DB.
+ */
+public class SearchMediaQuery {
+    @Nullable
+    private final String mIntentAction;
+    @NonNull
+    private final List<String> mProviders;
+    protected final int mPageSize;
+    @NonNull
+    final SearchLocalMediaSubQuery mLocalMediaSubQuery;
+    @NonNull
+    final SearchCloudMediaSubquery mCloudMediaSubquery;
+
+    public SearchMediaQuery(Bundle queryArgs, int searchRequestID) {
+        mIntentAction = queryArgs.getString("intent_action");
+        mProviders = new ArrayList<>(
+                Objects.requireNonNull(queryArgs.getStringArrayList("providers")));
+        mPageSize = queryArgs.getInt("page_size", Integer.MAX_VALUE);
+
+        mLocalMediaSubQuery = new SearchLocalMediaSubQuery(queryArgs, searchRequestID);
+        mCloudMediaSubquery = new SearchCloudMediaSubquery(queryArgs, searchRequestID);
+    }
+
+    /**
+     * @param database SQLiteDatabase wrapper for Picker DB
+     * @param localAuthority authority of the local provider if it should be queried,
+     *                       otherwise null.
+     * @param cloudAuthority authority of the cloud provider if it should be queried,
+     *                       otherwise null.
+     * @param reverseOrder true when the sort order needs to be reversed.
+     * @return A string that contains the table clause of the sql query after joining the
+     * media table and search_result_media.
+     */
+    public String getTableWithRequiredJoins(@NonNull SQLiteDatabase database,
+                                            @Nullable String localAuthority,
+                                            @Nullable String cloudAuthority,
+                                            boolean reverseOrder) {
+
+        final MediaProjection mediaProjection = new MediaProjection(
+                localAuthority,
+                cloudAuthority,
+                mIntentAction,
+                PickerSQLConstants.Table.MEDIA
+        );
+
+        final String localMediaRawQuery = getSubQuery(
+                database,
+                mLocalMediaSubQuery,
+                localAuthority,
+                cloudAuthority,
+                mediaProjection,
+                reverseOrder
+        );
+        final String cloudMediaRawQuery = getSubQuery(
+                database,
+                mCloudMediaSubquery,
+                localAuthority,
+                cloudAuthority,
+                mediaProjection,
+                reverseOrder
+        );
+        return String.format(
+                Locale.ROOT,
+                "( %s UNION ALL %s )",
+                localMediaRawQuery,
+                cloudMediaRawQuery);
+    }
+
+    private String getSubQuery(
+            @NonNull SQLiteDatabase database,
+            @NonNull SearchMediaSubQuery searchMediaSubquery,
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority,
+            @NonNull MediaProjection mediaProjection,
+            boolean reverseOrder) {
+        final SelectSQLiteQueryBuilder subQueryBuilder =
+                new SelectSQLiteQueryBuilder(database);
+        subQueryBuilder
+                .setTables(searchMediaSubquery.getTableWithRequiredJoins())
+                .setProjection(mediaProjection.getAll());
+        searchMediaSubquery.addWhereClause(
+                subQueryBuilder,
+                PickerSQLConstants.Table.MEDIA,
+                localAuthority,
+                cloudAuthority,
+                reverseOrder
+        );
+        return subQueryBuilder.buildQuery();
+    }
+
+    @Nullable
+    public String getIntentAction() {
+        return mIntentAction;
+    }
+
+    @NonNull
+    public List<String> getProviders() {
+        return mProviders;
+    }
+
+    public int getPageSize() {
+        return mPageSize;
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/SearchMediaSubQuery.java b/src/com/android/providers/media/photopicker/v2/sqlite/SearchMediaSubQuery.java
new file mode 100644
index 000000000..1b4f34b65
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/SearchMediaSubQuery.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.sqlite;
+
+import android.os.Bundle;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import com.android.providers.media.photopicker.v2.model.MediaQuery;
+
+import java.util.Locale;
+
+/**
+ * Utility class to query either local or cloud media items from search_result_media table
+ * and media table in Picker DB.
+ */
+public abstract class SearchMediaSubQuery extends MediaQuery {
+    private final int mSearchRequestID;
+
+    public SearchMediaSubQuery(Bundle queryArgs, int searchRequestID) {
+        super(queryArgs);
+
+        mSearchRequestID = searchRequestID;
+    }
+
+    /**
+     * @return A string that contains the table clause of the sql query after joining the
+     * media table and search_result_media.
+     */
+    public abstract String getTableWithRequiredJoins();
+
+    @Override
+    public void addWhereClause(
+            @NonNull SelectSQLiteQueryBuilder queryBuilder,
+            @NonNull PickerSQLConstants.Table table,
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority,
+            boolean reverseOrder
+    ) {
+        super.addWhereClause(queryBuilder, table, localAuthority, cloudAuthority, reverseOrder);
+
+        queryBuilder.appendWhereStandalone(
+                String.format(
+                        Locale.ROOT,
+                        "%s.%s = '%d'",
+                        PickerSQLConstants.Table.SEARCH_RESULT_MEDIA.name(),
+                        PickerSQLConstants.SearchResultMediaTableColumns
+                                .SEARCH_REQUEST_ID.getColumnName(),
+                        mSearchRequestID));
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/SearchRequestDatabaseUtil.java b/src/com/android/providers/media/photopicker/v2/sqlite/SearchRequestDatabaseUtil.java
new file mode 100644
index 000000000..ebe8b2139
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/SearchRequestDatabaseUtil.java
@@ -0,0 +1,426 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.sqlite;
+
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_IGNORE;
+
+import static java.util.Objects.requireNonNull;
+
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import com.android.providers.media.photopicker.v2.model.SearchRequest;
+import com.android.providers.media.photopicker.v2.model.SearchSuggestionRequest;
+import com.android.providers.media.photopicker.v2.model.SearchTextRequest;
+
+import java.util.List;
+import java.util.Locale;
+
+/**
+ * Convenience class for running Picker Search Request related sql queries.
+ */
+public class SearchRequestDatabaseUtil {
+    private static final String TAG = "SearchDatabaseUtil";
+
+    // Note that SQLite treats all null values as different. So, if you apply a
+    // UNIQUE(...) constraint on some columns and if any of those columns holds a null value,
+    // the unique constraint will not be applied. This is why in the search request table,
+    // a placeholder value will be used instead of null so that the unique constraint gets
+    // applied to all search requests saved in the table.
+    // The placeholder values should not be a valid value to any of the columns in the unique
+    // constraint.
+    public static final String PLACEHOLDER_FOR_NULL = "";
+
+    /**
+     * Tries to insert the given search request in the DB with the REPLACE constraint conflict
+     * resolution strategy.
+     *
+     * @param database The database you need to run the query on.
+     * @param searchRequest An object that contains search request details.
+     * @return The row id of the inserted row or -1 in case of a SQLite constraint conflict.
+     * @throws RuntimeException if an error occurs in running the sql command.
+     */
+    public static long saveSearchRequest(
+            @NonNull SQLiteDatabase database,
+            @NonNull SearchRequest searchRequest) {
+        final String table = PickerSQLConstants.Table.SEARCH_REQUEST.name();
+
+        try {
+            final long result = database.insertWithOnConflict(
+                    table,
+                    /* nullColumnHack */ null,
+                    searchRequestToContentValues(searchRequest),
+                    CONFLICT_IGNORE
+            );
+
+            if (result == -1) {
+                Log.e(TAG, "Could not save request due to a conflict constraint");
+            }
+            return result;
+        } catch (RuntimeException e) {
+            throw new RuntimeException("Could not save search request ", e);
+        }
+    }
+
+    /**
+     * Update resume key for the given search request ID.
+     *
+     * @param database The database you need to run the query on.
+     * @param searchRequestId Identifier for a search request.
+     * @param resumeKey The resume key that can be used to fetch the next page of results,
+     *                  or indicate that the sync is complete.
+     * @throws RuntimeException if an error occurs in running the sql command.
+     */
+    public static void updateResumeKey(
+            @NonNull SQLiteDatabase database,
+            int searchRequestId,
+            @Nullable String resumeKey) {
+        final String table = PickerSQLConstants.Table.SEARCH_REQUEST.name();
+
+        ContentValues contentValues = new ContentValues();
+        contentValues.put(
+                PickerSQLConstants.SearchRequestTableColumns.SYNC_RESUME_KEY.getColumnName(),
+                resumeKey);
+
+        database.update(
+                table,
+                contentValues,
+                String.format(
+                        Locale.ROOT,
+                        "%s.%s = %d",
+                        table,
+                        PickerSQLConstants.SearchRequestTableColumns
+                                .SEARCH_REQUEST_ID.getColumnName(),
+                        searchRequestId
+                ),
+                null
+        );
+    }
+
+    /**
+     * Queries the database to try and fetch a unique search request ID for the given search
+     * request.
+     *
+     * @param database The database you need to run the query on.
+     * @param searchRequest Object that contains search request details.
+     * @return the ID of the given search request or -1 if it can't find the search request in the
+     * database. In case multiple search requests are a match, the first one is returned.
+     */
+    public static int getSearchRequestID(
+            @NonNull SQLiteDatabase database,
+            @NonNull SearchRequest searchRequest) {
+        final SelectSQLiteQueryBuilder queryBuilder = new SelectSQLiteQueryBuilder(database)
+                .setTables(PickerSQLConstants.Table.SEARCH_REQUEST.name())
+                .setProjection(List.of(
+                        PickerSQLConstants.SearchRequestTableColumns
+                                .SEARCH_REQUEST_ID.getColumnName()));
+
+        addSearchRequestIDWhereClause(queryBuilder, searchRequest);
+
+        try (Cursor cursor = database.rawQuery(
+                queryBuilder.buildQuery(), /* selectionArgs */ null)) {
+            if (cursor.moveToFirst()) {
+                if (cursor.getCount() > 1) {
+                    Log.e(TAG, "Cursor cannot have more than one search request match "
+                            + "- returning the first match");
+                }
+                return cursor.getInt(
+                        cursor.getColumnIndexOrThrow(
+                                PickerSQLConstants.SearchRequestTableColumns.SEARCH_REQUEST_ID
+                                        .getColumnName()
+                        )
+                );
+            }
+
+            // If the cursor is empty, return -1;
+            Log.w(TAG, "Search request does not exist in the DB.");
+            return -1;
+        } catch (RuntimeException e) {
+            Log.e(TAG, "Could not fetch search request ID.", e);
+            return -1;
+        }
+    }
+
+    /**
+     * Queries the database to try and fetch search request details for the given search request ID.
+     *
+     * @param database The database you need to run the query on.
+     * @param searchRequestID ID of the search request.
+     * @return the search request object corresponding to the given search request id,
+     * or null if it can't find the search request in the database. In case multiple search
+     * requests are a match, the first one is returned.
+     */
+    @Nullable
+    public static SearchRequest getSearchRequestDetails(
+            @NonNull SQLiteDatabase database,
+            @NonNull int searchRequestID
+    ) {
+        final List<String> projection = List.of(
+                PickerSQLConstants.SearchRequestTableColumns.SYNC_RESUME_KEY.getColumnName(),
+                PickerSQLConstants.SearchRequestTableColumns.SEARCH_TEXT.getColumnName(),
+                PickerSQLConstants.SearchRequestTableColumns.MEDIA_SET_ID.getColumnName(),
+                PickerSQLConstants.SearchRequestTableColumns.AUTHORITY.getColumnName(),
+                PickerSQLConstants.SearchRequestTableColumns.SUGGESTION_TYPE.getColumnName(),
+                PickerSQLConstants.SearchRequestTableColumns.MIME_TYPES.getColumnName()
+        );
+        final SelectSQLiteQueryBuilder queryBuilder = new SelectSQLiteQueryBuilder(database)
+                .setTables(PickerSQLConstants.Table.SEARCH_REQUEST.name())
+                .setProjection(projection);
+
+        addSearchRequestDetailsWhereClause(queryBuilder, searchRequestID);
+
+        try (Cursor cursor = database.rawQuery(
+                queryBuilder.buildQuery(), /* selectionArgs */ null)) {
+            if (cursor.moveToFirst()) {
+                if (cursor.getCount() > 1) {
+                    Log.e(TAG, "Cursor cannot have more than one search request match "
+                            + "- returning the first match");
+                }
+
+                final String authority = getColumnValueOrNull(
+                        cursor,
+                        PickerSQLConstants.SearchRequestTableColumns.AUTHORITY.getColumnName()
+                );
+                final String mimeTypes = getColumnValueOrNull(
+                        cursor,
+                        PickerSQLConstants.SearchRequestTableColumns.MIME_TYPES.getColumnName()
+                );
+                final String searchText = getColumnValueOrNull(
+                            cursor,
+                            PickerSQLConstants.SearchRequestTableColumns.SEARCH_TEXT.getColumnName()
+                );
+                final String resumeKey = getColumnValueOrNull(
+                        cursor,
+                        PickerSQLConstants.SearchRequestTableColumns.SYNC_RESUME_KEY.getColumnName()
+                );
+
+                final SearchRequest searchRequest;
+                if (authority == null) {
+                    // This is a search text request
+                    searchRequest = new SearchTextRequest(
+                            SearchRequest.getMimeTypesAsList(mimeTypes),
+                            requireNonNull(searchText),
+                            resumeKey
+                    );
+                } else {
+                    // This is a search suggestion request
+                    final String mediaSetID = requireNonNull(
+                            getColumnValueOrNull(
+                                    cursor,
+                                    PickerSQLConstants.SearchRequestTableColumns
+                                            .MEDIA_SET_ID.getColumnName()
+                            )
+                    );
+                    final String suggestionType = requireNonNull(
+                            getColumnValueOrNull(
+                                    cursor,
+                                    PickerSQLConstants.SearchRequestTableColumns
+                                            .SUGGESTION_TYPE.getColumnName()
+                            )
+                    );
+
+                    searchRequest = new SearchSuggestionRequest(
+                            SearchRequest.getMimeTypesAsList(mimeTypes),
+                            searchText,
+                            mediaSetID,
+                            authority,
+                            suggestionType,
+                            resumeKey
+                    );
+                }
+                return searchRequest;
+            }
+
+            // If the cursor is empty, return null;
+            Log.w(TAG, "Search request does not exist in the DB.");
+            return null;
+        } catch (RuntimeException e) {
+            Log.e(TAG, "Could not fetch search request details.", e);
+            return null;
+        }
+    }
+
+
+    /**
+     * @return ContentValues that contains a mapping of column names of search_request table as key
+     * and search request data as values. This is intended to be used in SQLite insert queries.
+     */
+    @NonNull
+    private static ContentValues searchRequestToContentValues(
+            @NonNull SearchRequest searchRequest) {
+        requireNonNull(searchRequest);
+
+        final ContentValues values = new ContentValues();
+
+        // Insert value or placeholder for null for unique column.
+        values.put(
+                PickerSQLConstants.SearchRequestTableColumns.MIME_TYPES.getColumnName(),
+                getValueOrPlaceholder(
+                        SearchRequest.getMimeTypesAsString(searchRequest.getMimeTypes())));
+
+        // Insert value as it is for a non-unique column.
+        values.put(
+                PickerSQLConstants.SearchRequestTableColumns.SYNC_RESUME_KEY.getColumnName(),
+                searchRequest.getResumeKey());
+
+        if (searchRequest instanceof SearchTextRequest searchTextRequest) {
+            // Insert placeholder for null for unique column.
+            values.put(
+                    PickerSQLConstants.SearchRequestTableColumns.SEARCH_TEXT.getColumnName(),
+                    getValueOrPlaceholder(searchTextRequest.getSearchText()));
+            values.put(
+                    PickerSQLConstants.SearchRequestTableColumns.MEDIA_SET_ID.getColumnName(),
+                    PLACEHOLDER_FOR_NULL);
+            values.put(
+                    PickerSQLConstants.SearchRequestTableColumns.AUTHORITY.getColumnName(),
+                    PLACEHOLDER_FOR_NULL);
+            values.put(
+                    PickerSQLConstants.SearchRequestTableColumns.SUGGESTION_TYPE.getColumnName(),
+                    PLACEHOLDER_FOR_NULL);
+        } else if (searchRequest instanceof SearchSuggestionRequest searchSuggestionRequest) {
+            // Insert value or placeholder for null for unique column.
+            values.put(
+                    PickerSQLConstants.SearchRequestTableColumns.SEARCH_TEXT.getColumnName(),
+                    getValueOrPlaceholder(
+                            searchSuggestionRequest.getSearchSuggestion().getSearchText()));
+            values.put(
+                    PickerSQLConstants.SearchRequestTableColumns.MEDIA_SET_ID.getColumnName(),
+                    getValueOrPlaceholder(
+                            searchSuggestionRequest.getSearchSuggestion().getMediaSetId()));
+            values.put(
+                    PickerSQLConstants.SearchRequestTableColumns.AUTHORITY.getColumnName(),
+                    getValueOrPlaceholder(searchSuggestionRequest
+                            .getSearchSuggestion().getAuthority()));
+            values.put(
+                    PickerSQLConstants.SearchRequestTableColumns.SUGGESTION_TYPE.getColumnName(),
+                    getValueOrPlaceholder(searchSuggestionRequest.getSearchSuggestion()
+                            .getSearchSuggestionType()));
+        } else {
+            throw new IllegalStateException(
+                    "Could not identify search request type " + searchRequest);
+        }
+
+        return values;
+    }
+
+    /**
+     * @param queryBuilder Adds where clauses based on the given searchRequest.
+     * @param searchRequest Object that contains search request details.
+     */
+    private static void addSearchRequestIDWhereClause(
+            @NonNull SelectSQLiteQueryBuilder queryBuilder,
+            @NonNull SearchRequest searchRequest) {
+        String searchText;
+        String mediaSetId = null;
+        String authority = null;
+        String suggestionType = null;
+        if (searchRequest instanceof SearchTextRequest searchTextRequest) {
+            searchText = getValueOrPlaceholder(searchTextRequest.getSearchText());
+        } else if (searchRequest instanceof SearchSuggestionRequest searchSuggestionRequest) {
+            searchText = getValueOrPlaceholder(
+                    searchSuggestionRequest.getSearchSuggestion().getSearchText());
+            mediaSetId = getValueOrPlaceholder(searchSuggestionRequest
+                    .getSearchSuggestion().getMediaSetId());
+            authority = getValueOrPlaceholder(searchSuggestionRequest
+                    .getSearchSuggestion().getAuthority());
+            suggestionType = getValueOrPlaceholder(searchSuggestionRequest
+                            .getSearchSuggestion().getSearchSuggestionType());
+        } else {
+            throw new IllegalStateException(
+                    "Could not identify search request type " + searchRequest);
+        }
+
+        addWhereClause(
+                queryBuilder,
+                PickerSQLConstants.SearchRequestTableColumns.MIME_TYPES.getColumnName(),
+                SearchRequest.getMimeTypesAsString(searchRequest.getMimeTypes()));
+        addWhereClause(
+                queryBuilder,
+                PickerSQLConstants.SearchRequestTableColumns.SEARCH_TEXT.getColumnName(),
+                searchText);
+        addWhereClause(
+                queryBuilder,
+                PickerSQLConstants.SearchRequestTableColumns.MEDIA_SET_ID.getColumnName(),
+                mediaSetId);
+        addWhereClause(
+                queryBuilder,
+                PickerSQLConstants.SearchRequestTableColumns.AUTHORITY.getColumnName(),
+                authority);
+        addWhereClause(
+                queryBuilder,
+                PickerSQLConstants.SearchRequestTableColumns.SUGGESTION_TYPE.getColumnName(),
+                suggestionType);
+    }
+
+    private static void addSearchRequestDetailsWhereClause(
+            @NonNull SelectSQLiteQueryBuilder queryBuilder,
+            @NonNull int searchRequestID
+    ) {
+        queryBuilder.appendWhereStandalone(
+                String.format(Locale.ROOT, " %s = '%s' ",
+                        PickerSQLConstants.SearchRequestTableColumns
+                                .SEARCH_REQUEST_ID.getColumnName(),
+                        searchRequestID));
+    }
+
+    /**
+     * @param queryBuilder Adds an equality where clauses based on the given column name and value.
+     * @param columnName Column name on which an equals check needs to be added.
+     * @param value The desired value that needs to be added to the where clause equality check.
+     *              If the value is null, it will be replaced by a non-null placeholder used in the
+     *              table for empty/null values.
+     */
+    private static void addWhereClause(
+            @NonNull SelectSQLiteQueryBuilder queryBuilder,
+            @NonNull String columnName,
+            @Nullable String value) {
+        value = getValueOrPlaceholder(value);
+        queryBuilder.appendWhereStandalone(String.format(Locale.ROOT,
+                " %s = '%s' ", columnName, value));
+    }
+
+    /**
+     * @param value Input value that can be nullable.
+     * @return If the input value is null, returns it as it is , otherwise returns a non-null
+     * placeholder for empty/null values.
+     */
+    @NonNull
+    private static String getValueOrPlaceholder(@Nullable String value) {
+        if (value == null) {
+            return PLACEHOLDER_FOR_NULL;
+        }
+        return value;
+    }
+
+    @Nullable
+    private static String getColumnValueOrNull(@NonNull Cursor cursor, @NonNull String columnName) {
+        return getValueOrNull(cursor.getString(cursor.getColumnIndexOrThrow(columnName)));
+    }
+
+    @Nullable
+    private static String getValueOrNull(@NonNull String value) {
+        if (PLACEHOLDER_FOR_NULL.equals(value)) {
+            return null;
+        }
+        return value;
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/SearchResultsDatabaseUtil.java b/src/com/android/providers/media/photopicker/v2/sqlite/SearchResultsDatabaseUtil.java
new file mode 100644
index 000000000..d6052c469
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/SearchResultsDatabaseUtil.java
@@ -0,0 +1,370 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.sqlite;
+
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_IGNORE;
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_REPLACE;
+
+import static com.android.providers.media.photopicker.v2.sqlite.PickerMediaDatabaseUtil.addNextPageKey;
+import static com.android.providers.media.photopicker.v2.sqlite.PickerMediaDatabaseUtil.addPrevPageKey;
+
+import static java.util.Objects.requireNonNull;
+
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.net.Uri;
+import android.os.Bundle;
+import android.provider.CloudMediaProviderContract;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import com.android.providers.media.photopicker.PickerSyncController;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+
+/**
+ * Convenience class for running Picker Search Results related sql queries.
+ */
+public class SearchResultsDatabaseUtil {
+    private static final String TAG = "SearchResultsDatabaseUtil";
+
+    /**
+     * Utility method that extracts ContentValues in a format that can be inserted in the
+     * search_result_table.
+     *
+     * @param searchRequestId Identifier for a search request.
+     * @param cursor Cursor received from a CloudMediaProvider with the projection
+     *               {@link CloudMediaProviderContract.MediaColumns}
+     * @param isLocal true if the received cursor came from the local provider, otherwise false.
+     * @return a list of ContentValues that can be inserted in the search_result_media table.
+     */
+    @NonNull
+    public static List<ContentValues> extractContentValuesList(
+            int searchRequestId, @NonNull Cursor cursor, boolean isLocal
+    ) {
+        final List<ContentValues> contentValuesList = new ArrayList<>(cursor.getCount());
+        if (cursor.moveToFirst()) {
+            do {
+                contentValuesList.add(extractContentValues(searchRequestId, cursor, isLocal));
+            } while (cursor.moveToNext());
+        }
+        return contentValuesList;
+    }
+
+    @NonNull
+    private static ContentValues extractContentValues(
+            int searchRequestId,
+            @NonNull Cursor cursor,
+            boolean isLocal) {
+        final ContentValues contentValues = new ContentValues();
+
+        final String id = cursor.getString(cursor.getColumnIndexOrThrow(
+                CloudMediaProviderContract.MediaColumns.ID));
+        final String rawMediaStoreUri = cursor.getString(cursor.getColumnIndexOrThrow(
+                CloudMediaProviderContract.MediaColumns.MEDIA_STORE_URI));
+        final Uri mediaStoreUri = rawMediaStoreUri == null ? null : Uri.parse(rawMediaStoreUri);
+        final String extractedLocalId = mediaStoreUri == null ? null
+                : String.valueOf(ContentUris.parseId(mediaStoreUri));
+
+        final String localId = isLocal ? id : extractedLocalId;
+        final String cloudId = isLocal ? null : id;
+
+        contentValues.put(
+                PickerSQLConstants.SearchResultMediaTableColumns.SEARCH_REQUEST_ID.getColumnName(),
+                searchRequestId
+        );
+        contentValues.put(
+                PickerSQLConstants.SearchResultMediaTableColumns.LOCAL_ID.getColumnName(),
+                localId
+        );
+        contentValues.put(
+                PickerSQLConstants.SearchResultMediaTableColumns.CLOUD_ID.getColumnName(),
+                cloudId
+        );
+
+        return contentValues;
+    }
+
+    /**
+     * Saved the search results media items received from CMP in the database as a temporary cache.
+     *
+     * @param database SQLite database object that holds DB connection(s) and provides a wrapper
+     *                 for executing DB queries.
+     * @param authority Authority of the CMP that is the source of search results media.
+     * @param contentValuesList List of ContentValues that contain the search results media.
+     *                          Each ContentValue in the list represents a media item.
+     * @return The number of items inserted in the DB.
+     * @throws RuntimeException if no items could be inserted in the database due to an unexpected
+     * exception.
+     */
+    public static int cacheSearchResults(
+            @NonNull SQLiteDatabase database,
+            @NonNull String authority,
+            @Nullable List<ContentValues> contentValuesList) {
+        requireNonNull(database);
+        requireNonNull(authority);
+
+        if (contentValuesList == null || contentValuesList.isEmpty()) {
+            Log.e(TAG, "Cursor is either null or empty. Nothing to do.");
+            return 0;
+        }
+
+        final boolean isLocal = PickerSyncController.getInstanceOrThrow()
+                .getLocalProvider()
+                .equals(authority);
+
+        try {
+            // Start a transaction with EXCLUSIVE lock.
+            database.beginTransaction();
+
+            // Number of rows inserted or replaced
+            int numberOfRowsInserted = 0;
+            for (ContentValues contentValues : contentValuesList) {
+                try {
+                    // Prefer media received from local provider over cloud provider to avoid
+                    // joining with media table on cloud_id when not required.
+                    final int conflictResolutionStrategy = isLocal
+                            ? CONFLICT_REPLACE
+                            : CONFLICT_IGNORE;
+                    final long rowID = database.insertWithOnConflict(
+                            PickerSQLConstants.Table.SEARCH_RESULT_MEDIA.name(),
+                            null,
+                            contentValues,
+                            conflictResolutionStrategy
+                    );
+
+                    if (rowID == -1) {
+                        Log.d(TAG, "Did not insert row in the search results media table"
+                                + " due to IGNORE conflict resolution strategy " + contentValues);
+                    } else {
+                        numberOfRowsInserted++;
+                    }
+                } catch (SQLException e) {
+                    // Skip the row that could not be inserted.
+                    Log.e(TAG, "Could not insert row in the search results media table "
+                            + contentValues, e);
+                }
+            }
+
+            // Mark transaction as successful so that it gets committed after it ends.
+            if (database.inTransaction()) {
+                database.setTransactionSuccessful();
+            }
+
+            return numberOfRowsInserted;
+        } catch (RuntimeException e) {
+            // Do not mark transaction as successful so that it gets roll-backed. after it ends.
+            throw new RuntimeException("Could not insert items in the DB", e);
+        } finally {
+            // Mark transaction as ended. The inserted items will either be committed if the
+            // transaction has been set as successful, or roll-backed otherwise.
+            if (database.inTransaction()) {
+                database.endTransaction();
+            }
+        }
+    }
+
+    /**
+     * Query media from the database and prepare a cursor in response.
+     *
+     * To get search media, we'll fetch media IDs for a corresponding search request ID from the
+     * search_result_media table and then enrich it with media metadata from the media table using
+     * sql joins.
+     *
+     * We need to make multiple queries to prepare a response for the media query.
+     * {@link android.database.sqlite.SQLiteQueryBuilder} currently does not support the creation of
+     * a transaction in {@code DEFERRED} mode. This is why we'll perform the read queries in
+     * {@code IMMEDIATE} mode instead.
+     *
+     * @param syncController Instance of the PickerSyncController singleton.
+     * @param query The MediaQuery object instance that tells us about the media query args.
+     * @param localAuthority The effective local authority that we need to consider for this
+     *                       transaction. If the local items should not be queries but the local
+     *                       authority has some value, the effective local authority would be null.
+     * @param cloudAuthority The effective cloud authority that we need to consider for this
+     *                       transaction. If the local items should not be queries but the local
+     *                       authority has some value, the effective local authority would
+     *                       be null.
+     * @return The cursor with the album media query results.
+     */
+    @NonNull
+    public static Cursor querySearchMedia(
+            @NonNull PickerSyncController syncController,
+            @NonNull SearchMediaQuery query,
+            @Nullable String localAuthority,
+            @Nullable String cloudAuthority
+    ) {
+        final SQLiteDatabase database = syncController.getDbFacade().getDatabase();
+
+        try {
+            database.beginTransactionNonExclusive();
+            Cursor pageData = database.rawQuery(
+                    getSearchMediaPageQuery(
+                            query,
+                            database,
+                            query.getTableWithRequiredJoins(
+                                    database, localAuthority, cloudAuthority,
+                                    /* reverseOrder */ false)
+                    ),
+                    /* selectionArgs */ null
+            );
+
+            Bundle extraArgs = new Bundle();
+            Cursor nextPageKeyCursor = database.rawQuery(
+                    getSearchMediaNextPageKeyQuery(
+                            query,
+                            database,
+                            query.getTableWithRequiredJoins(
+                                    database, localAuthority, cloudAuthority,
+                                    /* reverseOrder */ false)
+                    ),
+                    /* selectionArgs */ null
+            );
+            addNextPageKey(extraArgs, nextPageKeyCursor);
+
+            Cursor prevPageKeyCursor = database.rawQuery(
+                    getSearchMediaPreviousPageQuery(
+                            query,
+                            database,
+                            query.getTableWithRequiredJoins(
+                                    database, localAuthority, cloudAuthority,
+                                    /* reverseOrder */ true)
+                    ),
+                    /* selectionArgs */ null
+            );
+            addPrevPageKey(extraArgs, prevPageKeyCursor);
+
+            database.setTransactionSuccessful();
+            pageData.setExtras(extraArgs);
+            Log.i(TAG, "Returning " + pageData.getCount() + " media metadata");
+            return pageData;
+        } catch (Exception e) {
+            throw new RuntimeException("Could not fetch media", e);
+        } finally {
+            database.endTransaction();
+        }
+    }
+
+    /**
+     * Builds and returns the SQL query to get the page contents for the search results from
+     * Picker DB. To get the media items, we need to query the search_result_media table
+     * and join with media table.
+     */
+    public static String getSearchMediaPageQuery(
+            @NonNull SearchMediaQuery query,
+            @NonNull SQLiteDatabase database,
+            @NonNull String table) {
+        SelectSQLiteQueryBuilder queryBuilder = new SelectSQLiteQueryBuilder(database)
+                .setTables(table)
+                .setProjection(List.of(
+                        PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName(),
+                        PickerSQLConstants.MediaResponse.PICKER_ID.getProjectedName(),
+                        PickerSQLConstants.MediaResponse
+                                .AUTHORITY.getProjectedName(),
+                        PickerSQLConstants.MediaResponse.MEDIA_SOURCE.getProjectedName(),
+                        PickerSQLConstants.MediaResponse.WRAPPED_URI.getProjectedName(),
+                        PickerSQLConstants.MediaResponse
+                                .UNWRAPPED_URI.getProjectedName(),
+                        PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getProjectedName(),
+                        PickerSQLConstants.MediaResponse.SIZE_IN_BYTES.getProjectedName(),
+                        PickerSQLConstants.MediaResponse.MIME_TYPE.getProjectedName(),
+                        PickerSQLConstants.MediaResponse.STANDARD_MIME_TYPE.getProjectedName(),
+                        PickerSQLConstants.MediaResponse.DURATION_MS.getProjectedName(),
+                        PickerSQLConstants.MediaResponse.IS_PRE_GRANTED.getProjectedName()
+                ))
+                .setSortOrder(
+                        String.format(
+                                Locale.ROOT,
+                                "%s DESC, %s DESC",
+                                PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getProjectedName(),
+                                PickerSQLConstants.MediaResponse.PICKER_ID.getProjectedName()
+                        )
+                )
+                .setLimit(query.getPageSize());
+
+        return queryBuilder.buildQuery();
+    }
+
+    /**
+     * Builds and returns the SQL query to get the next page's first row for the search results
+     * query.
+     */
+    @Nullable
+    public static String getSearchMediaNextPageKeyQuery(
+            @NonNull SearchMediaQuery query,
+            @NonNull SQLiteDatabase database,
+            @NonNull String table) {
+        if (query.getPageSize() == Integer.MAX_VALUE) {
+            return null;
+        }
+
+        SelectSQLiteQueryBuilder queryBuilder = new SelectSQLiteQueryBuilder(database)
+                .setTables(table)
+                .setProjection(List.of(
+                        PickerSQLConstants.MediaResponse.PICKER_ID.getProjectedName(),
+                        PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getProjectedName()
+                ))
+                .setSortOrder(
+                        String.format(
+                                Locale.ROOT,
+                                "%s DESC, %s DESC",
+                                PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getProjectedName(),
+                                PickerSQLConstants.MediaResponse.PICKER_ID.getProjectedName()
+                        )
+                )
+                .setLimit(1)
+                .setOffset(query.getPageSize());
+
+        return queryBuilder.buildQuery();
+    }
+
+    /**
+     * Builds and returns the SQL query to get the previous page contents for the search results
+     * from the previous page.
+     *
+     * We fetch the whole page and not just one key because it is possible that the previous page
+     * is smaller than the page size. So, we get the whole page and only use the last row item to
+     * get the previous page key.
+     */
+    public static String getSearchMediaPreviousPageQuery(
+            @NonNull SearchMediaQuery query,
+            @NonNull SQLiteDatabase database,
+            @NonNull String table) {
+        SelectSQLiteQueryBuilder queryBuilder = new SelectSQLiteQueryBuilder(database)
+                .setTables(table)
+                .setProjection(List.of(
+                        PickerSQLConstants.MediaResponse.PICKER_ID.getProjectedName(),
+                        PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getProjectedName()
+                )).setSortOrder(
+                        String.format(
+                                Locale.ROOT,
+                                "%s ASC, %s ASC",
+                                PickerSQLConstants.MediaResponse.DATE_TAKEN_MS.getProjectedName(),
+                                PickerSQLConstants.MediaResponse.PICKER_ID.getProjectedName()
+                        )
+                ).setLimit(query.getPageSize());
+
+        return queryBuilder.buildQuery();
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/SearchSuggestionsDatabaseUtils.java b/src/com/android/providers/media/photopicker/v2/sqlite/SearchSuggestionsDatabaseUtils.java
new file mode 100644
index 000000000..3a0b11788
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/SearchSuggestionsDatabaseUtils.java
@@ -0,0 +1,550 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.sqlite;
+
+import static android.database.sqlite.SQLiteDatabase.CONFLICT_REPLACE;
+import static android.provider.CloudMediaProviderContract.SEARCH_SUGGESTION_HISTORY;
+import static android.provider.CloudMediaProviderContract.SEARCH_SUGGESTION_FACE;
+
+import static java.util.Objects.requireNonNull;
+
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.database.DatabaseUtils;
+import android.database.sqlite.SQLiteDatabase;
+import android.provider.CloudMediaProviderContract;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import com.android.providers.media.photopicker.v2.model.SearchRequest;
+import com.android.providers.media.photopicker.v2.model.SearchSuggestion;
+import com.android.providers.media.photopicker.v2.model.SearchSuggestionRequest;
+import com.android.providers.media.photopicker.v2.model.SearchTextRequest;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Convenience class for running Picker Search Suggestions related sql queries.
+ */
+public class SearchSuggestionsDatabaseUtils {
+    private static final String TAG = "SearchSuggestionsDBUtil";
+    private static final int TTL_HISTORY_SUGGESTIONS_IN_DAYS = 60;
+    private static final int TTL_CACHED_SUGGESTIONS_IN_DAYS = 30;
+
+    /**
+     * Save Search Request as search history to serve as search suggestions later.
+     *
+     * @param database Instance of Picker Database.
+     * @param searchRequest Search Request issued by the user.
+     * @return true if the search history was saved successfully, else returns false.
+     */
+    public static boolean saveSearchHistory(
+            @NonNull SQLiteDatabase database,
+            @NonNull SearchRequest searchRequest) {
+        requireNonNull(database);
+        requireNonNull(searchRequest);
+
+        try {
+            // Note that CONFLICT_REPLACE create a new row in case of a conflict so the
+            // _id might change. If you need the _id to remain the same, use update instead.
+            final long result = database.insertWithOnConflict(
+                    PickerSQLConstants.Table.SEARCH_HISTORY.name(),
+                    /* nullColumnHack */ null,
+                    searchRequestToHistoryContentValues(searchRequest),
+                    CONFLICT_REPLACE
+            );
+
+            if (result == -1) {
+                throw new RuntimeException(
+                        "Search history was not saved due to a constraint conflict.");
+            }
+
+            return true;
+        } catch (RuntimeException e) {
+            Log.e(TAG, "Could not save search history ", e);
+            return false;
+        }
+    }
+
+    /**
+     * Fetch Search history as suggestions.
+     *
+     * @param database Instance of Picker Database.
+     * @param query SearchSuggestionsQuery that holds search suggestions query inputs.
+     */
+    public static List<SearchSuggestion> getHistorySuggestions(
+            @NonNull SQLiteDatabase database,
+            @NonNull SearchSuggestionsQuery query) {
+        requireNonNull(database);
+        requireNonNull(query);
+
+        final SelectSQLiteQueryBuilder queryBuilder = new SelectSQLiteQueryBuilder(database)
+                .setTables(PickerSQLConstants.Table.SEARCH_HISTORY.name())
+                .setProjection(List.of(
+                        PickerSQLConstants.SearchHistoryTableColumns.SEARCH_TEXT.getColumnName(),
+                        PickerSQLConstants.SearchHistoryTableColumns.MEDIA_SET_ID.getColumnName(),
+                        PickerSQLConstants.SearchHistoryTableColumns.AUTHORITY.getColumnName(),
+                        PickerSQLConstants.SearchHistoryTableColumns.COVER_MEDIA_ID.getColumnName()
+                )).setLimit(query.getHistoryLimit())
+                .setSortOrder(String.format(
+                        Locale.ROOT,
+                        "%s DESC",
+                        PickerSQLConstants.SearchHistoryTableColumns.PICKER_ID.getColumnName()));
+
+        final long creationThreshold = System.currentTimeMillis()
+                - TimeUnit.DAYS.toMillis(TTL_HISTORY_SUGGESTIONS_IN_DAYS);
+        queryBuilder.appendWhereStandalone(String.format(
+                Locale.ROOT,
+                " %s >= %d ",
+                PickerSQLConstants.SearchHistoryTableColumns.CREATION_TIME_MS,
+                creationThreshold));
+
+        if (query.getProviderAuthorities() != null && !query.getProviderAuthorities().isEmpty()) {
+            queryBuilder.appendWhereStandalone(String.format(
+                    Locale.ROOT,
+                    "(%s IS NULL) OR (%s IN ('%s'))",
+                    PickerSQLConstants.SearchHistoryTableColumns.AUTHORITY,
+                    PickerSQLConstants.SearchHistoryTableColumns.AUTHORITY,
+                    String.join("','", query.getProviderAuthorities())));
+        } else {
+            queryBuilder.appendWhereStandalone(String.format(
+                    Locale.ROOT,
+                    "%s IS NULL",
+                    PickerSQLConstants.SearchHistoryTableColumns.AUTHORITY));
+        }
+
+
+        final List<SearchSuggestion> historySuggestions = new ArrayList<>();
+        try (Cursor cursor = database.rawQuery(
+                queryBuilder.buildQuery(), /* selectionArgs */ null)) {
+            if (cursor.moveToFirst()) {
+                do {
+                    final SearchSuggestion historySuggestion = getHistorySuggestion(cursor);
+                    if (historySuggestion != null) {
+                        if (query.isZeroState() || (historySuggestion.getSearchText() != null
+                                && historySuggestion.getSearchText().toLowerCase(Locale.ROOT)
+                                .startsWith(query.getPrefix().toLowerCase(Locale.ROOT)))) {
+                            historySuggestions.add(historySuggestion);
+                        }
+                    }
+                } while (cursor.moveToNext());
+            }
+
+            Log.d(TAG, "Number of history suggestions: " + historySuggestions.size());
+            return historySuggestions;
+        } catch (RuntimeException e) {
+            Log.e(TAG, "Could not fetch search history suggestions.", e);
+            return new ArrayList<>();
+        }
+    }
+
+    /**
+     * Fetch cached suggestions received from cloud media providers.
+     *
+     * @param database Instance of Picker Database.
+     * @param query SearchSuggestionsQuery that holds search suggestions query inputs.
+     */
+    public static List<SearchSuggestion> getCachedSuggestions(
+            @NonNull SQLiteDatabase database,
+            @NonNull SearchSuggestionsQuery query) {
+        requireNonNull(database);
+        requireNonNull(query);
+
+        if (query.getProviderAuthorities() == null || query.getProviderAuthorities().isEmpty()) {
+            Log.e(TAG, "Available providers list is empty");
+            return new ArrayList<>();
+        }
+
+        final SelectSQLiteQueryBuilder queryBuilder = new SelectSQLiteQueryBuilder(database)
+                .setTables(PickerSQLConstants.Table.SEARCH_SUGGESTION.name())
+                .setProjection(List.of(
+                        PickerSQLConstants.SearchSuggestionsTableColumns
+                                .SEARCH_TEXT.getColumnName(),
+                        PickerSQLConstants.SearchSuggestionsTableColumns
+                                .MEDIA_SET_ID.getColumnName(),
+                        PickerSQLConstants.SearchSuggestionsTableColumns
+                                .AUTHORITY.getColumnName(),
+                        PickerSQLConstants.SearchSuggestionsTableColumns
+                                .COVER_MEDIA_ID.getColumnName(),
+                        PickerSQLConstants.SearchSuggestionsTableColumns
+                                .SUGGESTION_TYPE.getColumnName()
+                )).setLimit(query.getLimit())
+                .setSortOrder(String.format(
+                        Locale.ROOT,
+                        "%s ASC",
+                        PickerSQLConstants.SearchSuggestionsTableColumns
+                                .PICKER_ID.getColumnName()));
+
+        final long creationThreshold = System.currentTimeMillis()
+                - TimeUnit.DAYS.toMillis(TTL_CACHED_SUGGESTIONS_IN_DAYS);
+        queryBuilder.appendWhereStandalone(String.format(
+                Locale.ROOT,
+                " %s >= %d ",
+                PickerSQLConstants.SearchSuggestionsTableColumns.CREATION_TIME_MS,
+                creationThreshold));
+
+        queryBuilder.appendWhereStandalone(String.format(
+                Locale.ROOT,
+                "%s IN ('%s')",
+                PickerSQLConstants.SearchSuggestionsTableColumns.AUTHORITY,
+                String.join("','", query.getProviderAuthorities())));
+
+        final List<SearchSuggestion> suggestions = new ArrayList<>();
+        try (Cursor cursor = database.rawQuery(
+                queryBuilder.buildQuery(), /* selectionArgs */ null)) {
+            if (cursor.moveToFirst()) {
+                do {
+                    final SearchSuggestion suggestion = getSuggestion(cursor);
+                    if (suggestion != null) {
+                        if (query.isZeroState() || (suggestion.getSearchText() != null
+                                && suggestion.getSearchText().toLowerCase(Locale.ROOT)
+                                .startsWith(query.getPrefix().toLowerCase(Locale.ROOT)))) {
+                            suggestions.add(suggestion);
+                        }
+                    }
+                } while (cursor.moveToNext());
+            }
+
+            Log.d(TAG, "Number of fetched cached suggestions: " + suggestions.size());
+            return suggestions;
+        } catch (RuntimeException e) {
+            Log.e(TAG, "Could not fetch search suggestions.", e);
+            return new ArrayList<>();
+        }
+    }
+
+    /**
+     * Extract search suggestions from the input cursor received from cloud media provider.
+     *
+     * @param cursor Cursor received from cloud media provider.
+     * @param authority Authority of the cloud media provider.
+     * @return A list of valid SearchSuggestions. If an invalid search suggestion is encountered
+     * it will not be included in the returned list.
+     */
+    @NonNull
+    public static List<SearchSuggestion> extractSearchSuggestions(
+            @NonNull Cursor cursor,
+            @NonNull String authority) {
+        requireNonNull(cursor);
+        requireNonNull(authority);
+
+        final List<SearchSuggestion> searchSuggestions = new ArrayList<>(cursor.getCount());
+        if (cursor.moveToFirst()) {
+            do {
+                try {
+                    searchSuggestions.add(extractSearchSuggestion(cursor, authority));
+                } catch (RuntimeException e) {
+                    ContentValues contentValues = new ContentValues();
+                    DatabaseUtils.cursorRowToContentValues(cursor, contentValues);
+                    Log.e(TAG, "Invalid search suggestion - skipping it: " + contentValues);
+                }
+            } while (cursor.moveToNext());
+        }
+
+        return searchSuggestions;
+    }
+
+    /**
+     * Save zero-state search suggestions received from cloud media providers in the database.
+     *
+     * @param database Instance of Picker Database.
+     * @param authority Authority of the source cloud media provider of the suggestions.
+     * @param searchSuggestions List of search suggestions that need to be cached.
+     * @return number of search suggestions cached in the database.
+     */
+    public static int cacheSearchSuggestions(
+            @NonNull SQLiteDatabase database,
+            @NonNull String authority,
+            @NonNull List<SearchSuggestion> searchSuggestions) {
+        requireNonNull(database);
+        requireNonNull(authority);
+        requireNonNull(searchSuggestions);
+
+        try {
+            // Start a database write transaction.
+            database.beginTransaction();
+
+            // Delete all cached suggestions for the authority
+            final String[] deletionArgs = new String[1];
+            deletionArgs[0] = authority;
+            database.delete(
+                    PickerSQLConstants.Table.SEARCH_SUGGESTION.name(),
+                    /* whereClause */ String.format(
+                            Locale.ROOT,
+                            "%s = ?",
+                            PickerSQLConstants.SearchSuggestionsTableColumns
+                                    .AUTHORITY.getColumnName()
+                    ),
+                    /* whereArgs */ deletionArgs
+            );
+
+            // Insert suggestions for the authority
+            int numberOfRowsInserted = 0;
+            for (SearchSuggestion suggestion : searchSuggestions) {
+                final ContentValues contentValues = getContentValues(suggestion);
+                try {
+                    final long rowID = database.insertWithOnConflict(
+                            PickerSQLConstants.Table.SEARCH_SUGGESTION.name(),
+                            null,
+                            contentValues,
+                            CONFLICT_REPLACE
+                    );
+
+                    if (rowID == -1) {
+                        throw new RuntimeException("Could not cache search suggestion due to "
+                                + "constraint conflict");
+                    } else {
+                        numberOfRowsInserted++;
+                    }
+                } catch (RuntimeException e) {
+                    // Skip the row that could not be inserted.
+                    Log.e(TAG, "Could not insert row in the search suggestions table "
+                            + contentValues, e);
+                }
+            }
+
+            // Mark transaction as successful so that it gets committed after it ends.
+            if (database.inTransaction()) {
+                Log.d(TAG, "Marked transaction as successful");
+                database.setTransactionSuccessful();
+            }
+
+            Log.d(TAG, "Number of suggestions cached in the DB: " + numberOfRowsInserted);
+            return numberOfRowsInserted;
+        } catch (RuntimeException e) {
+            // Do not mark transaction as successful so that it gets roll-backed. after it ends.
+            throw new RuntimeException("Could not insert items in the DB", e);
+        } finally {
+            // Mark transaction as ended. The inserted items will either be committed if the
+            // transaction has been set as successful, or roll-backed otherwise.
+            if (database.inTransaction()) {
+                database.endTransaction();
+            }
+        }
+    }
+
+    /**
+     * @param suggestion Input search suggestion to be saved to be saved in
+     * {@link PickerSQLConstants.Table#SEARCH_SUGGESTION}
+     * @return ContentValues that contains the search suggestion data to be saved in the format
+     * {@link PickerSQLConstants.SearchSuggestionsTableColumns}
+     */
+    private static ContentValues getContentValues(SearchSuggestion suggestion) {
+        final ContentValues contentValues = new ContentValues();
+
+        contentValues.put(
+                PickerSQLConstants.SearchSuggestionsTableColumns.SEARCH_TEXT.getColumnName(),
+                suggestion.getSearchText()
+        );
+        contentValues.put(
+                PickerSQLConstants.SearchSuggestionsTableColumns.MEDIA_SET_ID.getColumnName(),
+                suggestion.getMediaSetId()
+        );
+        contentValues.put(
+                PickerSQLConstants.SearchSuggestionsTableColumns.AUTHORITY.getColumnName(),
+                suggestion.getAuthority()
+        );
+        contentValues.put(
+                PickerSQLConstants.SearchSuggestionsTableColumns.COVER_MEDIA_ID.getColumnName(),
+                suggestion.getCoverMediaId()
+        );
+        contentValues.put(
+                PickerSQLConstants.SearchSuggestionsTableColumns.SUGGESTION_TYPE.getColumnName(),
+                suggestion.getSearchSuggestionType()
+        );
+        contentValues.put(
+                PickerSQLConstants.SearchSuggestionsTableColumns.CREATION_TIME_MS.getColumnName(),
+                System.currentTimeMillis()
+        );
+
+        return contentValues;
+    }
+
+    /**
+     * Extract search suggestion from the current row in the given cursor.
+     *
+     * @param cursor The input cursor received from cloud media provider with suggestions.
+     * @param authority The authority of the cloud media provider.
+     * @return The extracted SearchSuggestion.
+     * @throws IllegalArgumentException if the input cursor has invalid values.
+     */
+    @NonNull
+    private static SearchSuggestion extractSearchSuggestion(
+            @NonNull Cursor cursor,
+            @NonNull String authority) {
+        requireNonNull(cursor);
+        requireNonNull(authority);
+
+        String searchText = cursor.getString(cursor.getColumnIndexOrThrow(
+                CloudMediaProviderContract.SearchSuggestionColumns.DISPLAY_TEXT));
+        final String mediaSetId = cursor.getString(cursor.getColumnIndexOrThrow(
+                CloudMediaProviderContract.SearchSuggestionColumns.MEDIA_SET_ID));
+        final String suggestionType = cursor.getString(cursor.getColumnIndexOrThrow(
+                CloudMediaProviderContract.SearchSuggestionColumns.TYPE));
+        final String coverMediaId = cursor.getString(cursor.getColumnIndexOrThrow(
+                CloudMediaProviderContract.SearchSuggestionColumns.MEDIA_COVER_ID));
+
+        if (mediaSetId == null || mediaSetId.trim().isEmpty()) {
+            throw new IllegalArgumentException("Media set ID cannot be null or empty");
+        }
+        if (searchText.trim().isEmpty()) {
+            searchText = null;
+        }
+        if (suggestionType == null) {
+            throw new IllegalArgumentException("Suggestion type cannot be null");
+        }
+
+        if (searchText == null && (suggestionType != SEARCH_SUGGESTION_FACE)) {
+            throw new IllegalArgumentException(
+                    "Only FACE type suggestions can have null search text");
+        }
+
+        return new SearchSuggestion(
+                searchText,
+                mediaSetId,
+                authority,
+                suggestionType,
+                coverMediaId
+        );
+    }
+
+    /**
+     * Get search history suggestion from the current row in the given cursor.
+     *
+     * @param cursor The input cursor sourced from the picker database.
+     * @return a history type SearchSuggestion or null if data in the cursor is invalid.
+     */
+    @Nullable
+    private static SearchSuggestion getHistorySuggestion(Cursor cursor) {
+        requireNonNull(cursor);
+
+        try {
+            final String searchText = cursor.getString(cursor.getColumnIndexOrThrow(
+                    PickerSQLConstants.SearchHistoryTableColumns.SEARCH_TEXT.getColumnName()));
+            final String mediaSetId = cursor.getString(cursor.getColumnIndexOrThrow(
+                    PickerSQLConstants.SearchHistoryTableColumns.MEDIA_SET_ID.getColumnName()));
+            final String authority = cursor.getString(cursor.getColumnIndexOrThrow(
+                    PickerSQLConstants.SearchHistoryTableColumns.AUTHORITY.getColumnName()));
+            final String coverMediaId = cursor.getString(cursor.getColumnIndexOrThrow(
+                    PickerSQLConstants.SearchHistoryTableColumns.COVER_MEDIA_ID.getColumnName()));
+
+            return new SearchSuggestion(
+                    searchText,
+                    mediaSetId,
+                    authority,
+                    SEARCH_SUGGESTION_HISTORY,
+                    coverMediaId
+            );
+        } catch (RuntimeException e) {
+            final ContentValues contentValues = new ContentValues();
+            DatabaseUtils.cursorRowToContentValues(cursor, contentValues);
+            Log.e(TAG, "Invalid history suggestion: " + contentValues, e);
+            return null;
+        }
+
+    }
+
+    /**
+     * Get search suggestion from the current row in the given cursor.
+     *
+     * @param cursor The input cursor sourced from the picker database.
+     * @return a SearchSuggestion object or null if data in the cursor is invalid.
+     */
+    @Nullable
+    private static SearchSuggestion getSuggestion(Cursor cursor) {
+        requireNonNull(cursor);
+
+        try {
+            final String searchText = cursor.getString(cursor.getColumnIndexOrThrow(
+                    PickerSQLConstants.SearchSuggestionsTableColumns.SEARCH_TEXT.getColumnName()));
+            final String mediaSetId = cursor.getString(cursor.getColumnIndexOrThrow(
+                    PickerSQLConstants.SearchSuggestionsTableColumns.MEDIA_SET_ID.getColumnName()));
+            final String authority = cursor.getString(cursor.getColumnIndexOrThrow(
+                    PickerSQLConstants.SearchSuggestionsTableColumns.AUTHORITY.getColumnName()));
+            final String coverMediaId = cursor.getString(cursor.getColumnIndexOrThrow(
+                    PickerSQLConstants.SearchSuggestionsTableColumns
+                            .COVER_MEDIA_ID.getColumnName()));
+            final String type = cursor.getString(cursor.getColumnIndexOrThrow(
+                    PickerSQLConstants.SearchSuggestionsTableColumns
+                            .SUGGESTION_TYPE.getColumnName()));
+
+            return new SearchSuggestion(
+                    searchText,
+                    mediaSetId,
+                    authority,
+                    type,
+                    coverMediaId
+            );
+        } catch (RuntimeException e) {
+            final ContentValues contentValues = new ContentValues();
+            DatabaseUtils.cursorRowToContentValues(cursor, contentValues);
+            Log.e(TAG, "Invalid suggestion: " + contentValues, e);
+            return null;
+        }
+    }
+
+    /**
+     * @param searchRequest Input search request to be saved to be saved in
+     * {@link PickerSQLConstants.Table#SEARCH_HISTORY}
+     * @return ContentValues that contains the search history data to be saved in the format
+     * {@link PickerSQLConstants.SearchHistoryTableColumns}
+     */
+    @NonNull
+    private static ContentValues searchRequestToHistoryContentValues(
+            @NonNull SearchRequest searchRequest) {
+        requireNonNull(searchRequest);
+
+        final ContentValues values = new ContentValues();
+
+        values.put(
+                PickerSQLConstants.SearchHistoryTableColumns.CREATION_TIME_MS.getColumnName(),
+                System.currentTimeMillis());
+
+        if (searchRequest instanceof SearchTextRequest searchTextRequest) {
+            values.put(
+                    PickerSQLConstants.SearchHistoryTableColumns.SEARCH_TEXT.getColumnName(),
+                    searchTextRequest.getSearchText());
+        } else if (searchRequest instanceof SearchSuggestionRequest searchSuggestionRequest) {
+            values.put(
+                    PickerSQLConstants.SearchHistoryTableColumns.SEARCH_TEXT.getColumnName(),
+                    searchSuggestionRequest.getSearchSuggestion().getSearchText());
+
+            values.put(
+                    PickerSQLConstants.SearchHistoryTableColumns.MEDIA_SET_ID.getColumnName(),
+                    searchSuggestionRequest.getSearchSuggestion().getMediaSetId());
+
+            values.put(
+                    PickerSQLConstants.SearchHistoryTableColumns.AUTHORITY.getColumnName(),
+                    searchSuggestionRequest.getSearchSuggestion().getAuthority());
+
+            values.put(
+                    PickerSQLConstants.SearchHistoryTableColumns.COVER_MEDIA_ID.getColumnName(),
+                    searchSuggestionRequest.getSearchSuggestion().getCoverMediaId());
+        } else {
+            throw new IllegalStateException(
+                    "Could not identify search request type " + searchRequest);
+        }
+
+        return values;
+    }
+}
+
diff --git a/src/com/android/providers/media/photopicker/v2/sqlite/SearchSuggestionsQuery.java b/src/com/android/providers/media/photopicker/v2/sqlite/SearchSuggestionsQuery.java
new file mode 100644
index 000000000..2f46394fd
--- /dev/null
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/SearchSuggestionsQuery.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.sqlite;
+
+import static com.android.providers.media.photopicker.v2.sqlite.PickerSQLConstants.DEFAULT_SEARCH_HISTORY_SUGGESTIONS_LIMIT;
+import static com.android.providers.media.photopicker.v2.sqlite.PickerSQLConstants.DEFAULT_SEARCH_SUGGESTIONS_LIMIT;
+
+import android.os.Bundle;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
+
+/**
+ * This is a convenience class for Search suggestions related query input parameters.
+ */
+public class SearchSuggestionsQuery {
+    private static final String TAG = "SearchSuggestionsQuery";
+    private int mLimit;
+    private int mHistoryLimit;
+    @NonNull
+    private final String mPrefix;
+    @NonNull
+    private final List<String> mProviderAuthorities;
+    private final boolean mIsZeroState;
+
+    public SearchSuggestionsQuery(
+            @NonNull String prefix,
+            @NonNull List<String> providers) {
+        mLimit = DEFAULT_SEARCH_SUGGESTIONS_LIMIT;
+        mHistoryLimit = DEFAULT_SEARCH_HISTORY_SUGGESTIONS_LIMIT;
+        mPrefix = prefix.trim();
+        mProviderAuthorities = providers;
+        mIsZeroState = mPrefix.isEmpty();
+    }
+
+
+
+    public SearchSuggestionsQuery(
+            @NonNull Bundle queryArgs) {
+        mLimit = queryArgs.getInt("limit", DEFAULT_SEARCH_SUGGESTIONS_LIMIT);
+        mHistoryLimit = queryArgs.getInt(
+                "history_limit", DEFAULT_SEARCH_HISTORY_SUGGESTIONS_LIMIT);
+        mPrefix = Objects.requireNonNull(queryArgs.getString("prefix")).trim();
+        mProviderAuthorities = new ArrayList<>(
+                Objects.requireNonNull(queryArgs.getStringArrayList("providers")));
+        mIsZeroState = mPrefix.isEmpty();
+
+        if (mLimit <= 0) {
+            Log.e(TAG, "Limit should be a positive integer - changing it to default limit.");
+            mLimit = DEFAULT_SEARCH_SUGGESTIONS_LIMIT;
+        }
+        if (mHistoryLimit <= 0) {
+            Log.e(TAG, "History limit should be a positive integer - "
+                    + "changing it to default limit.");
+            mHistoryLimit = DEFAULT_SEARCH_HISTORY_SUGGESTIONS_LIMIT;
+        }
+    }
+
+    public int getLimit() {
+        return mLimit;
+    }
+
+    public int getHistoryLimit() {
+        return mHistoryLimit;
+    }
+
+    @NonNull
+    public String getPrefix() {
+        return mPrefix;
+    }
+
+    @NonNull
+    public List<String> getProviderAuthorities() {
+        return mProviderAuthorities;
+    }
+
+    public boolean isZeroState() {
+        return mIsZeroState;
+    }
+}
diff --git a/src/com/android/providers/media/photopicker/v2/SelectSQLiteQueryBuilder.java b/src/com/android/providers/media/photopicker/v2/sqlite/SelectSQLiteQueryBuilder.java
similarity index 94%
rename from src/com/android/providers/media/photopicker/v2/SelectSQLiteQueryBuilder.java
rename to src/com/android/providers/media/photopicker/v2/sqlite/SelectSQLiteQueryBuilder.java
index 2196c6a2a..db1b617a7 100644
--- a/src/com/android/providers/media/photopicker/v2/SelectSQLiteQueryBuilder.java
+++ b/src/com/android/providers/media/photopicker/v2/sqlite/SelectSQLiteQueryBuilder.java
@@ -14,15 +14,15 @@
  * limitations under the License.
  */
 
-package com.android.providers.media.photopicker.v2;
+package com.android.providers.media.photopicker.v2.sqlite;
 
-import android.annotation.SuppressLint;
 import android.database.sqlite.SQLiteDatabase;
 
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
 import java.util.List;
+import java.util.Locale;
 
 /**
  * Helper SQLite Query Builder class that uses the Builder pattern to make writing Select SQL
@@ -31,8 +31,6 @@ import java.util.List;
  * This is a thin wrapper around {@link android.database.sqlite.SQLiteQueryBuilder}.
  */
 public class SelectSQLiteQueryBuilder extends SQLiteQueryBuilder<SelectSQLiteQueryBuilder> {
-    @NonNull
-    private SQLiteDatabase mDatabase;
     @NonNull
     private String mTables;
     @Nullable
@@ -46,8 +44,6 @@ public class SelectSQLiteQueryBuilder extends SQLiteQueryBuilder<SelectSQLiteQue
 
     public SelectSQLiteQueryBuilder(@NonNull SQLiteDatabase database) {
         super(database);
-
-        mDatabase = database;
     }
 
     @Override
@@ -137,6 +133,7 @@ public class SelectSQLiteQueryBuilder extends SQLiteQueryBuilder<SelectSQLiteQue
     /**
      * @return the raw select query built using class variables.
      */
+    @Override
     public String buildQuery() {
         return mSQLiteQueryBuilder.buildQuery(
                 mProjection,
@@ -152,7 +149,7 @@ public class SelectSQLiteQueryBuilder extends SQLiteQueryBuilder<SelectSQLiteQue
      * @return The SQLiteDatabase instance this query will run on.
      */
     public SQLiteDatabase getDatabase() {
-        return mDatabase;
+        return mSQLiteDatabase;
     }
 
     /**
@@ -165,14 +162,13 @@ public class SelectSQLiteQueryBuilder extends SQLiteQueryBuilder<SelectSQLiteQue
     /**
      * @return the limit clause built from the limit and offset class variables.
      */
-    @SuppressLint("DefaultLocale")
     private String buildLimitClause() {
         if (mLimit == null) {
             return null;
         } else if (mOffset == null) {
             return mLimit.toString();
         } else {
-            return String.format("%d OFFSET %d", mLimit, mOffset);
+            return String.format(Locale.ROOT, "%d OFFSET %d", mLimit, mOffset);
         }
     }
 }
diff --git a/src/com/android/providers/media/photopicker/viewmodel/PickerViewModel.java b/src/com/android/providers/media/photopicker/viewmodel/PickerViewModel.java
index 2e0bad27b..231ae8160 100644
--- a/src/com/android/providers/media/photopicker/viewmodel/PickerViewModel.java
+++ b/src/com/android/providers/media/photopicker/viewmodel/PickerViewModel.java
@@ -210,12 +210,22 @@ public class PickerViewModel extends AndroidViewModel {
         mIsLocalOnly = false;
 
         initConfigStore();
+    }
 
+    /**
+     * Init the User Managers ({@link UserIdManager} and {@link UserManagerState}) and other
+     * {@link PickerViewModel} dependencies depending upon the user managers.
+     *
+     * <p> Note: This must be called immediately after the constructor by all callers. </p>
+     *
+     * @param userIdManager the {@link UserIdManager} to be used for initializations.
+     */
+    public void initUserManagers(UserIdManager userIdManager) {
         if (mConfigStore.isPrivateSpaceInPhotoPickerEnabled() && SdkLevel.isAtLeastS()) {
             mUserManagerState = UserManagerState.create(mAppContext);
             mUserIdManager = null;
         } else {
-            mUserIdManager = UserIdManager.create(mAppContext);
+            mUserIdManager = userIdManager;
             mUserManagerState = null;
         }
 
diff --git a/src/com/android/providers/media/scan/ModernMediaScanner.java b/src/com/android/providers/media/scan/ModernMediaScanner.java
index 2a60faf73..066fbd785 100644
--- a/src/com/android/providers/media/scan/ModernMediaScanner.java
+++ b/src/com/android/providers/media/scan/ModernMediaScanner.java
@@ -51,6 +51,7 @@ import static android.text.format.DateUtils.HOUR_IN_MILLIS;
 import static android.text.format.DateUtils.MINUTE_IN_MILLIS;
 
 import static com.android.providers.media.flags.Flags.enableOemMetadata;
+import static com.android.providers.media.flags.Flags.indexMediaLatitudeLongitude;
 import static com.android.providers.media.util.FileUtils.canonicalize;
 import static com.android.providers.media.util.IsoInterface.MAX_XMP_SIZE_BYTES;
 import static com.android.providers.media.util.Metrics.translateReason;
@@ -112,8 +113,10 @@ import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.annotation.VisibleForTesting;
 
+import com.android.modules.utils.BackgroundThread;
 import com.android.modules.utils.build.SdkLevel;
 import com.android.providers.media.ConfigStore;
+import com.android.providers.media.MediaProvider;
 import com.android.providers.media.MediaVolume;
 import com.android.providers.media.backupandrestore.RestoreExecutor;
 import com.android.providers.media.flags.Flags;
@@ -396,6 +399,20 @@ public class ModernMediaScanner implements MediaScanner {
         }
     }
 
+    /**
+     * Invalidate FUSE dentry cache while setting directory dirty
+     */
+    private void invalidateFuseDentryInBg(File file) {
+        BackgroundThread.getExecutor().execute(() -> {
+            try (ContentProviderClient client =
+                         mContext.getContentResolver().acquireContentProviderClient(
+                                 MediaStore.AUTHORITY)) {
+                ((MediaProvider) client.getLocalContentProvider()).invalidateFuseDentry(file);
+            }
+        });
+    }
+
+
     @Override
     public void onDirectoryDirty(@NonNull File dir) {
         requireNonNull(dir);
@@ -409,6 +426,7 @@ public class ModernMediaScanner implements MediaScanner {
         synchronized (mPendingCleanDirectories) {
             mPendingCleanDirectories.remove(dir.getPath().toLowerCase(Locale.ROOT));
             FileUtils.setDirectoryDirty(dir, /* isDirty */ true);
+            invalidateFuseDentryInBg(dir);
         }
     }
 
@@ -1071,6 +1089,9 @@ public class ModernMediaScanner implements MediaScanner {
                             dir.toFile().getPath().toLowerCase(Locale.ROOT))) {
                         // If |dir| is still clean, then persist
                         FileUtils.setDirectoryDirty(dir.toFile(), false /* isDirty */);
+                        if (!MediaStore.VOLUME_INTERNAL.equals(mVolumeName)) {
+                            invalidateFuseDentryInBg(dir.toFile());
+                        }
                         mIsDirectoryTreeDirty = false;
                     }
                 }
@@ -1544,6 +1565,12 @@ public class ModernMediaScanner implements MediaScanner {
                         parseOptional(mmr.extractMetadata(METADATA_KEY_COLOR_RANGE)));
                 withOptionalValue(op, FileColumns._VIDEO_CODEC_TYPE,
                         parseOptional(mmr.extractMetadata(METADATA_KEY_VIDEO_CODEC_MIME_TYPE)));
+
+                // TODO b/373352459 Latitude and Longitude for backup and restore
+                // Fill up the latitude and longitude columns
+                if (indexMediaLatitudeLongitude()) {
+                    populateVideoGeolocationCoordinates(op, mmr);
+                }
             }
 
             // Also hunt around for XMP metadata
@@ -1557,6 +1584,38 @@ public class ModernMediaScanner implements MediaScanner {
         return op;
     }
 
+    private void populateVideoGeolocationCoordinates(
+            ContentProviderOperation.Builder op, MediaMetadataRetriever mmr) {
+        // Extract geolocation data
+        final int locationArraySize = 2;
+        // First element of the array is the latitude and the second is the longitude
+        final int latitudeIndex = 0;
+        final int longitudeIndex = 1;
+        String imageGeolocationCoordinates = mmr.extractMetadata(
+                MediaMetadataRetriever.METADATA_KEY_LOCATION);
+        if (imageGeolocationCoordinates != null) {
+            // The extracted geolocation string is of the form +90.87-87.68.
+            // where the first half +90.87 is the latitude including the first
+            // leading +/- sign and the second half -87.68. is the longitude including the
+            // last '.' character. The following processing includes the signs and
+            // discards the last '.' character.
+            String[] locationParts = imageGeolocationCoordinates.split("(?=[+-])");
+            if (locationParts.length == locationArraySize) {
+                float latitude = Float.parseFloat(locationParts[latitudeIndex]);
+                // Remove last character which is a '.' in the string
+                float longitude = Float.parseFloat(
+                        locationParts[longitudeIndex].substring(
+                                0, locationParts[longitudeIndex].length() - 1));
+                op.withValue(VideoColumns.LATITUDE, latitude);
+                op.withValue(VideoColumns.LONGITUDE, longitude);
+            } else {
+                Log.e(TAG, "Couldn't extract image geolocation coordinates");
+            }
+        }
+    }
+
+
+
     private @NonNull ContentProviderOperation.Builder scanItemImage(long existingId,
             File file, BasicFileAttributes attrs, String mimeType, int mediaType,
             String volumeName) {
@@ -1587,6 +1646,12 @@ public class ModernMediaScanner implements MediaScanner {
             withOptionalValue(op, ImageColumns.SCENE_CAPTURE_TYPE,
                     parseOptional(exif.getAttribute(ExifInterface.TAG_SCENE_CAPTURE_TYPE)));
 
+            // TODO b/373352459 Latitude and Longitude for backup and restore
+            // Fill up the latitude and longitude columns
+            if (indexMediaLatitudeLongitude()) {
+                populateImageGeolocationCoordinates(op, exif);
+            }
+
             // Also hunt around for XMP metadata
             final XmpInterface xmp = XmpDataParser.createXmpInterface(exif);
             withXmpValues(op, xmp, mimeType);
@@ -1598,6 +1663,18 @@ public class ModernMediaScanner implements MediaScanner {
         return op;
     }
 
+    private void populateImageGeolocationCoordinates(
+            ContentProviderOperation.Builder op, ExifInterface exif) {
+        // Array to hold the geolocation coordinates - latitude and longitude
+        final int locationArraySize = 2;
+        float[] locationCoordinates = new float[locationArraySize];
+        if (exif.getLatLong(locationCoordinates)) {
+            // First element is the latitude and the second is the longitude
+            op.withValue(ImageColumns.LATITUDE, locationCoordinates[/* latitudeIndex */ 0]);
+            op.withValue(ImageColumns.LONGITUDE, locationCoordinates[/* longitudeIndex */ 1]);
+        }
+    }
+
     private @NonNull ContentProviderOperation.Builder scanItemFile(long existingId,
             File file, BasicFileAttributes attrs, String mimeType, int mediaType,
             String volumeName) {
diff --git a/src/com/android/providers/media/search/SearchUtilConstants.java b/src/com/android/providers/media/search/SearchUtilConstants.java
new file mode 100644
index 000000000..1e117c2c8
--- /dev/null
+++ b/src/com/android/providers/media/search/SearchUtilConstants.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.search;
+
+/**
+ * Helper class for picker search which holds all the relevant media status table constants like
+ * the table name and the table columns.
+ */
+public class SearchUtilConstants {
+    /*
+     Name of the media status table.
+     */
+    public final String MEDIA_STATUS_TABLE = "search_index_processing_status";
+    /*
+     Column holding the media_id assigned to each media item on insertion into the files table.
+     */
+    public final String MEDIA_ID_COLUMN = "media_id";
+    /*
+     Column holding the display name assigned to each media item on insertion into the files table.
+     */
+    public final String DISPLAY_NAME_COLUMN = "display_name";
+    /*
+     Column holding the date at which the media item is first created and inserted into the
+     files table.
+     */
+    public final String DATE_TAKEN_COLUMN = "date_taken";
+    /*
+     Column holding the mime type of each media item referenced from the files table..
+     */
+    public final String MIME_TYPE_COLUMN = "mime_type";
+    /*
+     Columns holding the size in bytes of each media item referenced from the files table.
+     */
+    public final String SIZE_COLUMN = "size";
+    /*
+     Column holding the generation number of each media item referenced from the files table.
+     */
+    public final String GENERATION_NUMBER_COLUMN = "generation_number";
+    /*
+      Column holding the latitude of the media item referenced from the files table.
+     */
+    public final String LATITUDE = "latitude";
+    /*
+     Column holding the longitude of the media item referenced from the files table.
+     */
+    public final String LONGITUDE = "longitude";
+    /*
+     Column denoting the metadata processing status of each media item. By metadata, we mean the
+     display_name, mime_type and date_taken for each media item.
+     It is 0 in case of unprocessed metadata and set to 1 when metadata is processed.
+     */
+    public final String METADATA_PROCESSING_STATUS_COLUMN = "metadata_processing_status";
+    /*
+     Column denoting the location processing status of each media item. By location, we mean the
+     geolocation of the media item.
+     It is 0 in case of unprocessed location and set to 1 when location is processed.
+     */
+    public final String LOCATION_PROCESSING_STATUS_COLUMN = "location_processing_status";
+    /*
+     Column denoting the ocr processing status of each media item. OCR refers to the text included
+     in the media item and is relevant only for images.
+     It is 0 in case of unprocessed media text and set to 1 when the media item is processed.
+     */
+    public final String OCR_PROCESSING_STATUS_COLUMN = "ocr_latin_processing_status";
+    /*
+     Column denoting the label processing status of each media item. Labels refer to descriptive
+     terms for a media item and is relevant for images only.
+     It is 0 in case the media item has not been processed for corresponding labels and 1 otherwise.
+     */
+    public final String LABEL_PROCESSING_STATUS_COLUMN = "label_processing_status";
+}
diff --git a/src/com/android/providers/media/search/exceptions/SqliteCheckedException.java b/src/com/android/providers/media/search/exceptions/SqliteCheckedException.java
new file mode 100644
index 000000000..53d4d4c4c
--- /dev/null
+++ b/src/com/android/providers/media/search/exceptions/SqliteCheckedException.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.search.exceptions;
+
+public class SqliteCheckedException extends Exception {
+    public SqliteCheckedException(String message, Throwable cause) {
+        super(message, cause);
+    }
+}
diff --git a/src/com/android/providers/media/util/FileUtils.java b/src/com/android/providers/media/util/FileUtils.java
index 1f927f35d..b4e6aecd6 100644
--- a/src/com/android/providers/media/util/FileUtils.java
+++ b/src/com/android/providers/media/util/FileUtils.java
@@ -1004,6 +1004,7 @@ public class FileUtils {
             "(?i)^/storage/[^/]+(?:/[0-9]+)?/"
                     + "(?:(?:Android/(?:data|obb|sandbox)$)|"
                     + "(?:\\.transforms$)|"
+                    + "(?:\\.picker_transcoded$)|"
                     + "(?:(?:Movies|Music|Pictures)/.thumbnails$))");
 
     /**
diff --git a/src/com/android/providers/media/util/SyntheticPathUtils.java b/src/com/android/providers/media/util/SyntheticPathUtils.java
index 6d7380259..49cf8fd7b 100644
--- a/src/com/android/providers/media/util/SyntheticPathUtils.java
+++ b/src/com/android/providers/media/util/SyntheticPathUtils.java
@@ -18,6 +18,7 @@ package com.android.providers.media.util;
 
 import static com.android.providers.media.PickerUriResolver.PICKER_GET_CONTENT_SEGMENT;
 import static com.android.providers.media.PickerUriResolver.PICKER_SEGMENT;
+import static com.android.providers.media.PickerUriResolver.PICKER_TRANSCODED_SEGMENT;
 import static com.android.providers.media.util.FileUtils.buildPath;
 import static com.android.providers.media.util.FileUtils.buildPrimaryVolumeFile;
 import static com.android.providers.media.util.FileUtils.extractFileName;
@@ -76,9 +77,11 @@ public final class SyntheticPathUtils {
                 PICKER_SEGMENT)).getAbsolutePath();
         final String pickerGetContentDir = buildPrimaryVolumeFile(userId,
                 getPickerRelativePath(PICKER_GET_CONTENT_SEGMENT)).getAbsolutePath();
+        final String pickerTranscodedDir = buildPrimaryVolumeFile(userId, getPickerRelativePath(
+                PICKER_TRANSCODED_SEGMENT)).getAbsolutePath();
 
         return path != null && (startsWith(path, pickerDir) || startsWith(path,
-                pickerGetContentDir));
+                pickerGetContentDir) || startsWith(path, pickerTranscodedDir));
     }
 
     public static boolean isSyntheticPath(String path, int userId) {
diff --git a/tests/Android.bp b/tests/Android.bp
index 61a0e8dcb..f18d04ae7 100644
--- a/tests/Android.bp
+++ b/tests/Android.bp
@@ -226,6 +226,8 @@ android_test {
         "SettingsLibSelectorWithWidgetPreference",
         "mediaprovider_flags_java_lib",
         "flag-junit",
+        "androidx.media3.media3-common",
+        "androidx.media3.media3-transformer",
     ],
 
     certificate: "media",
diff --git a/tests/AndroidManifest.xml b/tests/AndroidManifest.xml
index e785e929d..f57aaed20 100644
--- a/tests/AndroidManifest.xml
+++ b/tests/AndroidManifest.xml
@@ -97,6 +97,12 @@
           </intent-filter>
         </provider>
 
+        <provider android:name="com.android.providers.media.cloudproviders.SearchProvider"
+            android:authorities="com.android.providers.media.photopicker.tests.cloud_search_provider"
+            android:permission="com.android.providers.media.permission.MANAGE_CLOUD_MEDIA_PROVIDERS"
+            android:exported="true">
+        </provider>
+
         <provider android:name="com.android.providers.media.cloudproviders.CloudProviderPrimary"
                   android:authorities="com.android.providers.media.photopicker.tests.cloud_primary"
                   android:permission="com.android.providers.media.permission.MANAGE_CLOUD_MEDIA_PROVIDERS"
@@ -129,6 +135,12 @@
                   android:exported="true">
         </provider>
 
+        <provider android:name="com.android.providers.media.photopickersearch.CloudMediaProviderSearch"
+            android:permission="com.android.providers.media.permission.MANAGE_CLOUD_MEDIA_PROVIDERS"
+            android:authorities="com.android.providers.media.photopicker.tests.cloud_provider_for_search_client"
+            android:exported="true">
+        </provider>
+
         <service
             android:name=
                 "com.android.providers.media.stableuris.job.StableUriIdleMaintenanceService"
diff --git a/tests/hostsidetests/photopicker/Android.bp b/tests/hostsidetests/photopicker/Android.bp
index d9041efd8..d4c961798 100644
--- a/tests/hostsidetests/photopicker/Android.bp
+++ b/tests/hostsidetests/photopicker/Android.bp
@@ -18,7 +18,7 @@ java_test_host {
         "tradefed",
         "compatibility-host-util",
     ],
-    data: [
+    device_common_data: [
         ":TestCloudMediaProviderApp",
     ],
 }
diff --git a/tests/src/com/android/providers/media/IdleServiceTest.java b/tests/src/com/android/providers/media/IdleServiceTest.java
index 1fe0d8bec..27f495343 100644
--- a/tests/src/com/android/providers/media/IdleServiceTest.java
+++ b/tests/src/com/android/providers/media/IdleServiceTest.java
@@ -261,7 +261,7 @@ public class IdleServiceTest {
             final int initialGenerationModified;
             try (Cursor cr = resolver.query(uri, projection, null, null, null)) {
                 assertThat(cr.getCount()).isEqualTo(1);
-                assertThat(cr.moveToFirst()).isNotNull();
+                assertThat(cr.moveToFirst()).isTrue();
                 assertThat(cr.isNull(0)).isTrue();
                 initialGenerationModified = cr.getInt(1);
             }
@@ -275,7 +275,7 @@ public class IdleServiceTest {
 
             try (Cursor cr = resolver.query(uri, projection, null, null, null)) {
                 assertThat(cr.getCount()).isEqualTo(1);
-                assertThat(cr.moveToFirst()).isNotNull();
+                assertThat(cr.moveToFirst()).isTrue();
                 assertThat(cr.getInt(0)).isEqualTo(_SPECIAL_FORMAT_NONE);
                 // Make sure that updating special format column doesn't update GENERATION_MODIFIED
                 assertThat(cr.getInt(1)).isEqualTo(initialGenerationModified);
diff --git a/tests/src/com/android/providers/media/IsolatedContext.java b/tests/src/com/android/providers/media/IsolatedContext.java
index d0c1001c7..fa9a103ba 100644
--- a/tests/src/com/android/providers/media/IsolatedContext.java
+++ b/tests/src/com/android/providers/media/IsolatedContext.java
@@ -35,6 +35,7 @@ import androidx.annotation.VisibleForTesting;
 import com.android.providers.media.cloudproviders.CloudProviderPrimary;
 import com.android.providers.media.cloudproviders.FlakyCloudProvider;
 import com.android.providers.media.dao.FileRow;
+import com.android.providers.media.flags.Flags;
 import com.android.providers.media.photopicker.PhotoPickerProvider;
 import com.android.providers.media.photopicker.PickerSyncController;
 import com.android.providers.media.util.FileUtils;
@@ -63,6 +64,17 @@ public class IsolatedContext extends ContextWrapper {
 
     public IsolatedContext(Context base, String tag, boolean asFuseThread,
             UserHandle userHandle, ConfigStore configStore) {
+        this(base, tag, asFuseThread, userHandle, configStore, new MaliciousAppDetector(base));
+    }
+
+    public IsolatedContext(Context base, String tag, boolean asFuseThread,
+            MaliciousAppDetector maliciousAppDetector) {
+        this(base, tag, asFuseThread, base.getUser(), new TestConfigStore(), maliciousAppDetector);
+    }
+
+    public IsolatedContext(Context base, String tag, boolean asFuseThread,
+            UserHandle userHandle, ConfigStore configStore,
+            MaliciousAppDetector maliciousAppDetector) {
         super(base);
         mDir = new File(base.getFilesDir(), tag);
         mDir.mkdirs();
@@ -71,7 +83,7 @@ public class IsolatedContext extends ContextWrapper {
         mResolver = new MockContentResolver(this);
         mUserHandle = userHandle;
 
-        mMediaProvider = getMockedMediaProvider(asFuseThread, configStore);
+        mMediaProvider = getMockedMediaProvider(asFuseThread, configStore, maliciousAppDetector);
         attachInfoAndAddProvider(base, mMediaProvider, MediaStore.AUTHORITY);
 
         MediaDocumentsProvider documentsProvider = new MediaDocumentsProvider();
@@ -98,7 +110,7 @@ public class IsolatedContext extends ContextWrapper {
     }
 
     private MediaProvider getMockedMediaProvider(boolean asFuseThread,
-            ConfigStore configStore) {
+            ConfigStore configStore, MaliciousAppDetector maliciousAppDetector) {
         return new MediaProvider() {
             @Override
             public boolean isFuseThread() {
@@ -124,6 +136,22 @@ public class IsolatedContext extends ContextWrapper {
             protected void updateQuotaTypeForUri(@NonNull FileRow row) {
                 return;
             }
+
+            @Override
+            boolean shouldLockdownMediaStoreVersion() {
+                // TODO(b/370999570): Set to true once Baklava is in dev
+                return false;
+            }
+
+            @Override
+            protected MaliciousAppDetector createMaliciousAppDetector() {
+                return maliciousAppDetector;
+            }
+
+            @Override
+            protected boolean shouldCheckForMaliciousActivity() {
+                return Flags.enableMaliciousAppDetector();
+            }
         };
     }
 
diff --git a/tests/src/com/android/providers/media/LocalUriMatcherTest.java b/tests/src/com/android/providers/media/LocalUriMatcherTest.java
index aceaa9b45..04b5a288f 100644
--- a/tests/src/com/android/providers/media/LocalUriMatcherTest.java
+++ b/tests/src/com/android/providers/media/LocalUriMatcherTest.java
@@ -52,6 +52,8 @@ public class LocalUriMatcherTest {
                 LocalUriMatcher.PICKER_GET_CONTENT_ID,
                 assembleTestUri(
                         new String[]{"picker_get_content", "0", "anything", "media", "anything"}));
+        assertMatchesPublic(LocalUriMatcher.PICKER_TRANSCODED_ID, assembleTestUri(
+                new String[]{"picker_transcoded", "0", "anything", "media", "anything"}));
 
         assertMatchesPublic(LocalUriMatcher.CLI, assembleTestUri(new String[] {"cli"}));
 
diff --git a/tests/src/com/android/providers/media/MaliciousAppCheckerTest.java b/tests/src/com/android/providers/media/MaliciousAppCheckerTest.java
new file mode 100644
index 000000000..6014bd60b
--- /dev/null
+++ b/tests/src/com/android/providers/media/MaliciousAppCheckerTest.java
@@ -0,0 +1,139 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+import android.Manifest;
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.content.Context;
+import android.net.Uri;
+import android.os.Build;
+import android.os.SystemClock;
+import android.platform.test.annotations.EnableFlags;
+import android.platform.test.flag.junit.SetFlagsRule;
+import android.provider.MediaStore;
+
+import androidx.test.InstrumentationRegistry;
+import androidx.test.filters.SdkSuppress;
+import androidx.test.runner.AndroidJUnit4;
+
+import com.android.providers.media.flags.Flags;
+
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RunWith(AndroidJUnit4.class)
+@SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
+public class MaliciousAppCheckerTest {
+    private static Context sIsolatedContext;
+    private static ContentResolver sIsolatedResolver;
+    private static final int FILE_CREATION_THRESHOLD_LIMIT = 5;
+    private static final int FREQUENCY_OF_MALICIOUS_INSERTION_CHECK = 1;
+    private static MaliciousAppDetector sMaliciousAppDetector;
+    @Rule public final SetFlagsRule mSetFlagsRule = new SetFlagsRule();
+
+    @BeforeClass
+    public static void setUpBeforeClass() {
+        InstrumentationRegistry.getInstrumentation().getUiAutomation()
+                .adoptShellPermissionIdentity(Manifest.permission.LOG_COMPAT_CHANGE,
+                        Manifest.permission.READ_COMPAT_CHANGE_CONFIG,
+                        Manifest.permission.READ_DEVICE_CONFIG,
+                        // Adding this to use getUserHandles() api of UserManagerService which
+                        // requires either MANAGE_USERS or CREATE_USERS. Since shell does not have
+                        // MANAGER_USERS permissions, using CREATE_USERS in test. This works with
+                        // MANAGE_USERS permission for MediaProvider module.
+                        Manifest.permission.CREATE_USERS,
+                        Manifest.permission.INTERACT_ACROSS_USERS);
+    }
+
+    @Before
+    public void setUp() {
+        resetIsolatedContext();
+        sMaliciousAppDetector = new MaliciousAppDetector(sIsolatedContext,
+                FILE_CREATION_THRESHOLD_LIMIT, FREQUENCY_OF_MALICIOUS_INSERTION_CHECK);
+    }
+
+    @AfterClass
+    public static void tearDown() {
+        InstrumentationRegistry.getInstrumentation()
+                .getUiAutomation().dropShellPermissionIdentity();
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_MALICIOUS_APP_DETECTOR)
+    public void testCannotCreateFileLimitExceeded() throws Exception {
+        resetIsolatedContext();
+        sMaliciousAppDetector.clearSharedPref();
+
+        createTempFilesInDownloadFolder(FILE_CREATION_THRESHOLD_LIMIT);
+        // add sleep to wait for the background process
+        SystemClock.sleep(1000);
+        int uid = android.os.Process.myUid();
+        boolean isAllowedToCreateFile = sMaliciousAppDetector.isAppAllowedToCreateFiles(uid);
+
+        assertFalse("File should not be allowed to create after limit exceeded",
+                isAllowedToCreateFile);
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_MALICIOUS_APP_DETECTOR)
+    public void testCreateFileWithinLimit() throws Exception {
+        resetIsolatedContext();
+        sMaliciousAppDetector.clearSharedPref();
+
+        // create files less than the threshold limit
+        createTempFilesInDownloadFolder(FILE_CREATION_THRESHOLD_LIMIT - 1);
+        // add sleep to wait for the background process
+        SystemClock.sleep(1000);
+        int uid = android.os.Process.myUid();
+        boolean isAllowedToCreateFile = sMaliciousAppDetector.isAppAllowedToCreateFiles(uid);
+
+        assertTrue("File should be allowed to create within limit", isAllowedToCreateFile);
+    }
+
+    private void createTempFilesInDownloadFolder(int numberOfFilesToCreate) {
+        final Uri downloadUri = MediaStore.Downloads
+                .getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY);
+        for (int index = 0; index < numberOfFilesToCreate; index++) {
+            final ContentValues values = new ContentValues();
+            values.put(MediaStore.Images.Media.DISPLAY_NAME, "test_" + index + ".txt");
+            values.put(MediaStore.Files.FileColumns.OWNER_PACKAGE_NAME,
+                    sIsolatedContext.getPackageName());
+            sIsolatedResolver.insert(downloadUri, values);
+        }
+    }
+
+    private static void resetIsolatedContext() {
+        if (sIsolatedResolver != null) {
+            // This is necessary, we wait for all unfinished tasks to finish before we create a
+            // new IsolatedContext.
+            MediaStore.waitForIdle(sIsolatedResolver);
+        }
+
+        Context context = InstrumentationRegistry.getTargetContext();
+        sIsolatedContext = new IsolatedContext(context, "modern", /*asFuseThread*/ false,
+                sMaliciousAppDetector);
+        sIsolatedResolver = sIsolatedContext.getContentResolver();
+    }
+}
diff --git a/tests/src/com/android/providers/media/MediaIndexingDatabaseOperationsTest.java b/tests/src/com/android/providers/media/MediaIndexingDatabaseOperationsTest.java
new file mode 100644
index 000000000..8048ec2c2
--- /dev/null
+++ b/tests/src/com/android/providers/media/MediaIndexingDatabaseOperationsTest.java
@@ -0,0 +1,220 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+import android.Manifest;
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.platform.app.InstrumentationRegistry;
+
+import com.android.providers.media.search.SearchUtilConstants;
+import com.android.providers.media.search.exceptions.SqliteCheckedException;
+
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.List;
+
+@RunWith(AndroidJUnit4.class)
+public class MediaIndexingDatabaseOperationsTest {
+
+    private Context mContext;
+    private IsolatedContext mIsolatedContext;
+    private MediaIndexingDatabaseOperationsTestExtension mIndexingDatabaseOperations;
+    private DatabaseHelper mDatabaseHelper;
+    private SearchTestingUtils mSearchTestingUtils;
+    private SearchUtilConstants mSearchUtilConstants;
+
+    @BeforeClass
+    public static void setUpBeforeClass() {
+        // Permissions needed to insert files via the content resolver
+        androidx.test.platform.app.InstrumentationRegistry.getInstrumentation()
+                .getUiAutomation()
+                .adoptShellPermissionIdentity(
+                        Manifest.permission.LOG_COMPAT_CHANGE,
+                        Manifest.permission.READ_COMPAT_CHANGE_CONFIG,
+                        Manifest.permission.WRITE_MEDIA_STORAGE);
+    }
+
+    @AfterClass
+    public static void tearDownAfterClass() {
+        InstrumentationRegistry.getInstrumentation()
+                .getUiAutomation().dropShellPermissionIdentity();
+    }
+
+    @Before
+    public void setup() {
+        mContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+        mIsolatedContext = new IsolatedContext(mContext,
+                /* tag */"MediaItemsIndexingDatabaseHelperTest", /*asFuseThread*/ false);
+        mIndexingDatabaseOperations = new MediaIndexingDatabaseOperationsTestExtension(
+                mIsolatedContext);
+        mDatabaseHelper = mIsolatedContext.getExternalDatabase();
+        mSearchTestingUtils = new SearchTestingUtils(mDatabaseHelper);
+        mSearchUtilConstants = new SearchUtilConstants();
+    }
+
+    @Test
+    public void testInsertMediaItemIntoMediaIndexingTable()
+            throws SqliteCheckedException {
+        String mediaIdToInsert = "1000";
+
+        // Insert the mediaItemId into the status table
+        ContentValues insertValues = new ContentValues();
+        insertValues.put(mSearchUtilConstants.MEDIA_ID_COLUMN, mediaIdToInsert);
+
+        mIndexingDatabaseOperations.insertIntoMediaStatusTable(
+                mDatabaseHelper, List.of(insertValues));
+
+        // Assert that the value was inserted and its processing status to be 0
+        Cursor cursor = mSearchTestingUtils.getMediaItemDataFromStatusTable(
+                Long.parseLong(mediaIdToInsert));
+        if (cursor.moveToFirst()) {
+            int metadataStatusIndex = cursor.getColumnIndexOrThrow(
+                    mSearchUtilConstants.METADATA_PROCESSING_STATUS_COLUMN);
+            int labelStatusIndex = cursor.getColumnIndexOrThrow(
+                    mSearchUtilConstants.LABEL_PROCESSING_STATUS_COLUMN);
+            int ocrStatusIndex = cursor.getColumnIndexOrThrow(
+                    mSearchUtilConstants.OCR_PROCESSING_STATUS_COLUMN);
+            int locationStatusIndex = cursor.getColumnIndexOrThrow(
+                    mSearchUtilConstants.LOCATION_PROCESSING_STATUS_COLUMN);
+            int metadataStatus = cursor.getInt(metadataStatusIndex);
+            int locationStatus = cursor.getInt(locationStatusIndex);
+            int ocrStatus = cursor.getInt(ocrStatusIndex);
+            int labelStatus = cursor.getInt(labelStatusIndex);
+            assertEquals(/* expectedProcessingStatus */ 0, metadataStatus);
+            assertEquals(/* expectedProcessingStatus */ 0, locationStatus);
+            assertEquals(/* expectedProcessingStatus */ 0, ocrStatus);
+            assertEquals(/* expectedProcessingStatus */ 0, labelStatus);
+        }
+    }
+
+    @Test
+    public void testQueryExternalDatabaseTable() throws SqliteCheckedException {
+        String mediaIdToQuery = "1000";
+        ContentValues insertValues = new ContentValues();
+        insertValues.put(mSearchUtilConstants.MEDIA_ID_COLUMN, mediaIdToQuery);
+
+        String testSelection = mSearchUtilConstants.MEDIA_ID_COLUMN + " = ?";
+        String[] testSelectionArgs = new String[]{ mediaIdToQuery };
+        String[] columns = new String[] { mSearchUtilConstants.METADATA_PROCESSING_STATUS_COLUMN };
+        // Insert the mediaItemId into the status table
+        mIndexingDatabaseOperations.insertIntoMediaStatusTable(
+                mDatabaseHelper, List.of(insertValues));
+
+        // Query media indexing table
+        Cursor cursor = mIndexingDatabaseOperations.queryExternalDatabaseTable(
+                mDatabaseHelper, /* tableName */ mSearchUtilConstants.MEDIA_STATUS_TABLE,
+                columns, testSelection, testSelectionArgs, null, null);
+
+        // Assert on the retrieved cursor
+        assertNotNull("Cursor was found to be null", cursor);
+        assertEquals("Expected cursor size did not match",
+                /* expected cursorSize */ 1, cursor.getCount());
+        // Assert the status to be 0
+        if (cursor.moveToFirst()) {
+            assertEquals("testId processing status was expected to be 0",
+                    /* expected processingStatus */ 0, cursor.getInt(0));
+        }
+    }
+
+    @Test
+    public void testUpdateStatusTableValues() throws SqliteCheckedException {
+        String mediaIdToUpdate = "1000";
+        ContentValues insertValues = new ContentValues();
+        insertValues.put(mSearchUtilConstants.MEDIA_ID_COLUMN, mediaIdToUpdate);
+
+        // Insert the mediaItemId into the status table
+        mIndexingDatabaseOperations.insertIntoMediaStatusTable(
+                mDatabaseHelper, List.of(insertValues));
+
+        // Update the metadata indexing status column
+        ContentValues updateValues = new ContentValues();
+        updateValues.put(mSearchUtilConstants.METADATA_PROCESSING_STATUS_COLUMN, 1);
+        String[] updateIds = new String[] { mediaIdToUpdate };
+        mIndexingDatabaseOperations.updateStatusTableValues(
+                mDatabaseHelper, updateIds, updateValues);
+
+        // Assert that the value was updated to 1
+        Cursor cursor = mSearchTestingUtils.getMediaItemDataFromStatusTable(
+                Long.parseLong(mediaIdToUpdate));
+        if (cursor.moveToFirst()) {
+            int metadataStatusIndex = cursor.getColumnIndexOrThrow(
+                    mSearchUtilConstants.METADATA_PROCESSING_STATUS_COLUMN);
+            int metadataStatus = cursor.getInt(metadataStatusIndex);
+            assertEquals(/* expected value after update */ 1, metadataStatus);
+        }
+    }
+
+    @Test
+    public void testDeleteMediaItemFromMediaIndexingTable()
+            throws SqliteCheckedException {
+        String mediaItemToDelete = "1000";
+        String testSelection = mSearchUtilConstants.MEDIA_ID_COLUMN + " = ?";
+        String[] testSelectionArgs = new String[]{ mediaItemToDelete };
+        String[] columns = new String[] { mSearchUtilConstants.METADATA_PROCESSING_STATUS_COLUMN };
+        ContentValues insertValues = new ContentValues();
+        insertValues.put(mSearchUtilConstants.MEDIA_ID_COLUMN, mediaItemToDelete);
+
+        // Insert the mediaItemId into the status table
+        mIndexingDatabaseOperations.insertIntoMediaStatusTable(
+                mDatabaseHelper, List.of(insertValues));
+
+        // Delete the item from the indexing table
+        mIndexingDatabaseOperations.deleteMediaItemFromMediaStatusTable(
+                mDatabaseHelper, mediaItemToDelete);
+
+        // Assert that the item does not exist in the indexing table
+        Cursor cursor = mIndexingDatabaseOperations.queryExternalDatabaseTable(
+                mDatabaseHelper, /* tableName */ mSearchUtilConstants.MEDIA_STATUS_TABLE,
+                columns, testSelection, testSelectionArgs, null, null);
+        assertEquals(/* expected cursorSize */ 0, cursor.getCount());
+    }
+
+    @Test
+    public void testGetDatabaseHelper() {
+        DatabaseHelper testHelper = mIndexingDatabaseOperations.getDatabaseHelper(mContext);
+        assertNotNull(testHelper);
+        assertTrue(testHelper.isExternal());
+    }
+
+
+    private static class MediaIndexingDatabaseOperationsTestExtension extends
+            MediaIndexingDatabaseOperations {
+        IsolatedContext mIsolatedContext;
+
+        MediaIndexingDatabaseOperationsTestExtension(IsolatedContext context) {
+            mIsolatedContext = context;
+        }
+
+        @Override
+        public DatabaseHelper getDatabaseHelper(Context context) {
+            return mIsolatedContext.getExternalDatabase();
+        }
+
+    }
+}
diff --git a/tests/src/com/android/providers/media/MediaProviderTest.java b/tests/src/com/android/providers/media/MediaProviderTest.java
index 0b634e94a..1a213eefa 100644
--- a/tests/src/com/android/providers/media/MediaProviderTest.java
+++ b/tests/src/com/android/providers/media/MediaProviderTest.java
@@ -16,6 +16,8 @@
 
 package com.android.providers.media;
 
+import static android.content.ContentResolver.QUERY_ARG_SQL_GROUP_BY;
+import static android.content.ContentResolver.QUERY_ARG_SQL_HAVING;
 import static android.provider.MediaStore.getGeneration;
 
 import static com.android.providers.media.scan.MediaScannerTest.stage;
@@ -59,6 +61,7 @@ import android.os.Environment;
 import android.os.RemoteException;
 import android.os.UserHandle;
 import android.os.UserManager;
+import android.platform.test.annotations.EnableFlags;
 import android.provider.MediaStore;
 import android.provider.MediaStore.Audio.AudioColumns;
 import android.provider.MediaStore.Files.FileColumns;
@@ -79,8 +82,11 @@ import androidx.test.runner.AndroidJUnit4;
 import com.android.providers.media.MediaProvider.FallbackException;
 import com.android.providers.media.MediaProvider.VolumeArgumentException;
 import com.android.providers.media.MediaProvider.VolumeNotFoundException;
+import com.android.providers.media.flags.Flags;
 import com.android.providers.media.photopicker.PickerSyncController;
 import com.android.providers.media.photopicker.data.ItemsProvider;
+import com.android.providers.media.scan.MediaScanner;
+import com.android.providers.media.scan.ModernMediaScanner;
 import com.android.providers.media.util.FileUtils;
 import com.android.providers.media.util.FileUtilsTest;
 import com.android.providers.media.util.SQLiteQueryBuilder;
@@ -311,8 +317,6 @@ public class MediaProviderTest {
     public void testMetadata() {
         assertNotNull(MediaStore.getVersion(sIsolatedContext,
                 MediaStore.VOLUME_EXTERNAL_PRIMARY));
-        assertNotNull(getGeneration(sIsolatedResolver,
-                MediaStore.VOLUME_EXTERNAL_PRIMARY));
     }
 
     /**
@@ -1945,6 +1949,148 @@ public class MediaProviderTest {
 
     }
 
+    @Test
+    @EnableFlags(Flags.FLAG_INDEX_MEDIA_LATITUDE_LONGITUDE)
+    public void testQueryingMediaGeolocationDataInProjectionShouldReturnNull() throws Exception {
+        // Check with both upper and lower case column names
+        String[][] projections = new String[][] {
+                new String[] {
+                        ImageColumns.DISPLAY_NAME,
+                        ImageColumns.LATITUDE,
+                        ImageColumns.LONGITUDE
+                },
+                new String[] {
+                        ImageColumns.DISPLAY_NAME,
+                        "LATITUDE",
+                        "LONGITUDE"
+                },
+                new String[] {
+                        ImageColumns.DISPLAY_NAME,
+                        ImageColumns.LATITUDE + " AS LAT",
+                        ImageColumns.LONGITUDE + " AS LONG"
+                }
+        };
+
+        for (int i = 0; i < projections.length; i++) {
+            String[] projection = projections[i];
+            String testFileName = "test_file";
+            final File downloads = new File(Environment.getExternalStorageDirectory(),
+                    Environment.DIRECTORY_DOWNLOADS);
+            File file = stage(R.raw.lg_g4_iso_800_jpg, new File(downloads, testFileName));
+            ModernMediaScanner modernMediaScanner = new ModernMediaScanner(sIsolatedContext,
+                    new TestConfigStore());
+            Uri testFileUri = modernMediaScanner.scanFile(file, MediaScanner.REASON_UNKNOWN);
+            try (Cursor cursor = sIsolatedContext.getContentResolver()
+                    .query(testFileUri, projection, null, null, null);) {
+                assertNotNull(cursor);
+                int nameIndex = cursor.getColumnIndex(ImageColumns.DISPLAY_NAME);
+                int latitudeIndex = cursor.getColumnIndex(ImageColumns.LATITUDE);
+                int longitudeIndex = cursor.getColumnIndex(ImageColumns.LONGITUDE);
+
+                assertThat(cursor.getCount()).isEqualTo(1);
+                cursor.moveToFirst();
+                // Assert name column accessed is non-null and valid
+                assertTrue(cursor.getString(nameIndex).contains(testFileName));
+                // Geolocation data fields should be NULL
+                assertTrue("Latitude is not null", cursor.isNull(latitudeIndex));
+                assertTrue("Longitude is not null", cursor.isNull(longitudeIndex));
+            } finally {
+                // Cleanup
+                file.delete();
+            }
+        }
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_INDEX_MEDIA_LATITUDE_LONGITUDE)
+    public void testQueryingMediaGeolocationDataInSelectionShouldReturnEmptyCursor()
+            throws Exception {
+        final File downloads = new File(Environment.getExternalStorageDirectory(),
+                Environment.DIRECTORY_DOWNLOADS);
+        File file = stage(R.raw.lg_g4_iso_800_jpg, new File(downloads, "test"));
+        ModernMediaScanner modernMediaScanner = new ModernMediaScanner(sIsolatedContext,
+                new TestConfigStore());
+        Uri testFileUri = modernMediaScanner.scanFile(file, MediaScanner.REASON_UNKNOWN);
+
+        String[] projection = new String[] {
+                ImageColumns._ID,
+                ImageColumns.DISPLAY_NAME
+        };
+        String selection = ImageColumns.LATITUDE + " = ?";
+        String[] selectionArgs = new String[] { "67.8" };
+        try (Cursor cursor = sIsolatedContext.getContentResolver()
+                .query(testFileUri, projection, selection, selectionArgs, null);) {
+            assertNotNull(cursor);
+            // Should no return any results
+            assertThat(cursor.getCount()).isEqualTo(0);
+        } finally {
+            // Clean up
+            file.delete();
+        }
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_INDEX_MEDIA_LATITUDE_LONGITUDE)
+    public void testQueryingMediaGeolocationDataInOrderByShouldReturnNonEmptyCursor()
+            throws Exception {
+        String testFileName = "test";
+        final File downloads = new File(Environment.getExternalStorageDirectory(),
+                Environment.DIRECTORY_DOWNLOADS);
+        File file = stage(R.raw.lg_g4_iso_800_jpg, new File(downloads, testFileName));
+        ModernMediaScanner modernMediaScanner = new ModernMediaScanner(sIsolatedContext,
+                new TestConfigStore());
+        Uri testFileUri = modernMediaScanner.scanFile(file, MediaScanner.REASON_UNKNOWN);
+
+        String[] projection = new String[] {
+                ImageColumns._ID,
+                ImageColumns.DISPLAY_NAME
+        };
+        try (Cursor cursor = sIsolatedContext.getContentResolver()
+                .query(testFileUri, projection, null, null, ImageColumns.LONGITUDE);) {
+            assertNotNull(cursor);
+            // Should return non-empty results
+            assertThat(cursor.getCount()).isEqualTo(1);
+            int nameIndex = cursor.getColumnIndex(ImageColumns.DISPLAY_NAME);
+            cursor.moveToFirst();
+            // Assert name column accessed is non-null and valid
+            assertTrue(cursor.getString(nameIndex).contains(testFileName));
+        } finally {
+            // Clean up
+            file.delete();
+        }
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_INDEX_MEDIA_LATITUDE_LONGITUDE)
+    public void testQueryingMediaGeolocationDataInGroupByAndHavingShouldReturnEmptyCursor()
+            throws Exception {
+        String testFileName = "test";
+        final File downloads = new File(Environment.getExternalStorageDirectory(),
+                Environment.DIRECTORY_DOWNLOADS);
+        File file = stage(R.raw.lg_g4_iso_800_jpg, new File(downloads, testFileName));
+        ModernMediaScanner modernMediaScanner = new ModernMediaScanner(sIsolatedContext,
+                new TestConfigStore());
+        Uri testFileUri = modernMediaScanner.scanFile(file, MediaScanner.REASON_UNKNOWN);
+
+        String[] projection = new String[] {
+                ImageColumns._ID,
+                ImageColumns.DISPLAY_NAME
+        };
+        Bundle queryArgs = new Bundle();
+        queryArgs.putString(QUERY_ARG_SQL_GROUP_BY, ImageColumns.LATITUDE);
+        queryArgs.putString(QUERY_ARG_SQL_HAVING, ImageColumns.LONGITUDE + " > 100");
+        try (Cursor cursor = sIsolatedContext.getContentResolver()
+                .query(testFileUri, projection, queryArgs, null);) {
+            assertNotNull(cursor);
+            // Should not return any results
+            assertThat(cursor.getCount()).isEqualTo(0);
+        } finally {
+            // Clean up
+            file.delete();
+        }
+    }
+
+
     private void testRedactionForFileExtension(int resId, String extension) throws Exception {
         final File dir = Environment
                 .getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS);
@@ -1987,4 +2133,24 @@ public class MediaProviderTest {
         sIsolatedResolver = sIsolatedContext.getContentResolver();
         sItemsProvider = new ItemsProvider(sIsolatedContext);
     }
+
+    @Test
+    public void testGetType() throws Exception {
+        final File dir = Environment
+                .getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS);
+        final File file = new File(dir, "test" + System.nanoTime() + ".jpg");
+        stage(R.raw.lg_g4_iso_800_jpg, file);
+        final Uri uri = MediaStore.scanFile(sIsolatedResolver, file);
+        try (ContentProviderClient cpc = sIsolatedResolver
+                .acquireContentProviderClient(MediaStore.AUTHORITY)) {
+            final MediaProvider mp = (MediaProvider) cpc.getLocalContentProvider();
+            final Uri redactedUri = mp.getRedactedUri(uri);
+
+            final String actualType = mp.getType(redactedUri);
+
+            assertEquals("image/dng", actualType);
+        } finally {
+            file.delete();
+        }
+    }
 }
diff --git a/tests/src/com/android/providers/media/PhotoPickerTranscodeHelperTest.java b/tests/src/com/android/providers/media/PhotoPickerTranscodeHelperTest.java
new file mode 100644
index 000000000..7b01f57f2
--- /dev/null
+++ b/tests/src/com/android/providers/media/PhotoPickerTranscodeHelperTest.java
@@ -0,0 +1,287 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media;
+
+import static android.os.Environment.DIRECTORY_DOWNLOADS;
+import static android.os.Environment.getExternalStorageDirectory;
+
+import static androidx.test.InstrumentationRegistry.getTargetContext;
+
+import static com.android.providers.media.PhotoPickerTranscodeHelper.Media3Transcoder;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Context;
+import android.net.Uri;
+import android.os.CancellationSignal;
+import android.os.ParcelFileDescriptor;
+import android.os.UserHandle;
+
+import androidx.annotation.NonNull;
+import androidx.test.runner.AndroidJUnit4;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+import java.util.Arrays;
+import java.util.List;
+
+@RunWith(AndroidJUnit4.class)
+public class PhotoPickerTranscodeHelperTest {
+
+    private final int mTestUserId = UserHandle.myUserId();
+    private final String mTestHost = "test";
+    private final String mTestMediaId = "123";
+    private final Uri mTestUri = Uri.parse("content://media/picker/" + mTestUserId + "/"
+            + mTestHost + "/media/" + mTestMediaId);
+    private PhotoPickerTranscodeHelper mHelper;
+    private File mTestDirectory;
+
+    @Before
+    public void setUp() {
+        mTestDirectory = new File(getExternalStorageDirectory(),
+                DIRECTORY_DOWNLOADS + "/.picker_transcoded");
+        mHelper = new PhotoPickerTranscodeHelper(mTestDirectory);
+    }
+
+    @After
+    public void tearDown() {
+        mTestDirectory.delete();
+    }
+
+    @Test
+    public void transcode() throws IOException {
+        // Act & Assert.
+        PhotoPickerTranscodeHelper helper = getTranscodeHelper(new Media3Transcoder() {
+            @Override
+            int transcode(@NonNull Context context, @NonNull Uri sourceUri,
+                    @NonNull String destinationPath, int timeoutSec, boolean useOpenGl) {
+                return Media3Transcoder.TRANSCODING_SUCCESS;
+            }
+        });
+        assertThat(helper.transcode(getTargetContext(), mTestUri)).isTrue();
+    }
+
+    @Test
+    public void transcode_doNotUseTranscoder_whenCacheFileExists() throws IOException {
+        // Pre-create corresponded cached transcoded file.
+        final File cachedFile = new File(mTestDirectory, mTestHost + "_" + mTestMediaId);
+        if (cachedFile.createNewFile()) {
+            assertThat(cachedFile.exists()).isTrue();
+        }
+
+        // Act & Assert.
+        PhotoPickerTranscodeHelper helper = getTranscodeHelper(new Media3Transcoder() {
+            @Override
+            int transcode(@NonNull Context context, @NonNull Uri sourceUri,
+                    @NonNull String destinationPath, int timeoutSec, boolean useOpenGl) {
+                return PhotoPickerTranscodeHelper.Media3Transcoder.TRANSCODING_OTHER_EXCEPTION;
+            }
+        });
+        assertThat(helper.transcode(getTargetContext(), mTestUri)).isTrue();
+
+        // Cleanup.
+        cachedFile.delete();
+    }
+
+    @Test
+    public void transcode_canRetry_whenOpenGlExportFailed() throws IOException {
+        // Act & Assert.
+        PhotoPickerTranscodeHelper helper = getTranscodeHelper(new Media3Transcoder() {
+
+            private boolean mHasTriedWithOpenGl = false;
+
+            @Override
+            int transcode(@NonNull Context context, @NonNull Uri sourceUri,
+                    @NonNull String destinationPath, int timeoutSec, boolean useOpenGl) {
+                if (useOpenGl) {
+                    mHasTriedWithOpenGl = true;
+                    return Media3Transcoder.TRANSCODING_EXPORT_EXCEPTION;
+                } else if (mHasTriedWithOpenGl) {
+                    return Media3Transcoder.TRANSCODING_SUCCESS;
+                } else {
+                    return Media3Transcoder.TRANSCODING_OTHER_EXCEPTION;
+                }
+            }
+        });
+        assertThat(helper.transcode(getTargetContext(), mTestUri)).isTrue();
+    }
+
+    @Test
+    public void transcode_returnFalse_whenTranscoderFailed() throws IOException {
+        // Act & Assert.
+        PhotoPickerTranscodeHelper helper = getTranscodeHelper(new Media3Transcoder() {
+            @Override
+            int transcode(@NonNull Context context, @NonNull Uri sourceUri,
+                    @NonNull String destinationPath, int timeoutSec, boolean useOpenGl) {
+                return Media3Transcoder.TRANSCODING_EXPORT_EXCEPTION;
+            }
+        });
+        assertThat(helper.transcode(getTargetContext(), mTestUri)).isFalse();
+    }
+
+    @Test
+    public void transcode_returnFalse_whenTimeout() throws IOException {
+        // Act & Assert.
+        PhotoPickerTranscodeHelper helper = getTranscodeHelper(new Media3Transcoder() {
+            @Override
+            int transcode(@NonNull Context context, @NonNull Uri sourceUri,
+                    @NonNull String destinationPath, int timeoutSec, boolean useOpenGl) {
+                return Media3Transcoder.TRANSCODING_TIMEOUT_EXCEPTION;
+            }
+        });
+        assertThat(helper.transcode(getTargetContext(), mTestUri)).isFalse();
+    }
+
+    @Test
+    public void openTranscodedFile() throws IOException {
+        // Pre-create corresponded cached transcoded file.
+        final File cachedFile = new File(mTestDirectory, mTestHost + "_" + mTestMediaId);
+        if (cachedFile.createNewFile()) {
+            assertThat(cachedFile.exists()).isTrue();
+        }
+
+        // Act & Assert.
+        ParcelFileDescriptor pfd = mHelper.openTranscodedFile(mTestHost, mTestMediaId);
+        assertThat(pfd).isNotNull();
+
+        // Cleanup.
+        cachedFile.delete();
+    }
+
+    @Test
+    public void getTranscodedFileSize() throws IOException {
+        // Pre-create corresponded cached transcoded file.
+        final File cachedFile = new File(mTestDirectory, mTestHost + "_" + mTestMediaId);
+        if (cachedFile.createNewFile()) {
+            assertThat(cachedFile.exists()).isTrue();
+        }
+        final RandomAccessFile raf = new RandomAccessFile(cachedFile, "rw");
+        raf.setLength(3);
+
+        // Act & Assert.
+        long fileSize = mHelper.getTranscodedFileSize(mTestHost, mTestMediaId);
+        assertThat(fileSize).isEqualTo(3);
+
+        // Cleanup.
+        cachedFile.delete();
+    }
+
+    @Test
+    public void freeCache() throws IOException {
+        final List<String> fileNamesToBeFreed = Arrays.asList("100", "101", "102");
+        createTestFiles(fileNamesToBeFreed);
+
+        // Act.
+        mHelper.freeCache(1024);
+
+        // Assert.
+        for (String fileName : fileNamesToBeFreed) {
+            final File file = new File(mTestDirectory, fileName);
+            assertThat(file.exists()).isFalse();
+        }
+    }
+
+    @Test
+    public void freeCache_returnCorrectBytesFreed() throws IOException {
+        // Pre-create corresponded cached transcoded file.
+        final File cachedFile = new File(mTestDirectory, mTestHost + "_" + mTestMediaId);
+        if (cachedFile.createNewFile()) {
+            assertThat(cachedFile.exists()).isTrue();
+        }
+        final RandomAccessFile raf = new RandomAccessFile(cachedFile, "rw");
+        raf.setLength(17);
+
+        // Act.
+        final long bytesFreed = mHelper.freeCache(1024);
+
+        // Assert.
+        assertThat(cachedFile.exists()).isFalse();
+        assertThat(bytesFreed).isEqualTo(17);
+    }
+
+    @Test
+    public void cleanAllTranscodedFiles() throws IOException {
+        final List<String> fileNamesToBeFreed = Arrays.asList("100", "101", "102");
+        createTestFiles(fileNamesToBeFreed);
+
+        // Act.
+        mHelper.cleanAllTranscodedFiles(null);
+
+        // Assert.
+        for (String fileName : fileNamesToBeFreed) {
+            final File file = new File(mTestDirectory, fileName);
+            assertThat(file.exists()).isFalse();
+        }
+    }
+
+    @Test
+    public void cleanAllTranscodedFiles_notPerform_whenCancellationsSignalSet() throws IOException {
+        final List<String> fileNamesToBeFreed = Arrays.asList("100", "101", "102");
+        createTestFiles(fileNamesToBeFreed);
+
+        // Act.
+        CancellationSignal signal = new CancellationSignal();
+        signal.cancel();
+        mHelper.cleanAllTranscodedFiles(signal);
+
+        // Assert.
+        for (String fileName : fileNamesToBeFreed) {
+            final File file = new File(mTestDirectory, fileName);
+            assertThat(file.exists()).isTrue();
+
+            // Cleanup.
+            file.delete();
+        }
+    }
+
+    @Test
+    public void deleteCachedTranscodedFile() throws IOException {
+        final long localId = 123;
+        final File fileToBeDeleted = new File(mTestDirectory, mTestHost + "_" + "123");
+        if (fileToBeDeleted.createNewFile()) {
+            assertThat(fileToBeDeleted.exists()).isTrue();
+        }
+
+        // Act.
+        mHelper.deleteCachedTranscodedFile(mTestHost, localId);
+
+        // Assert.
+        assertThat(fileToBeDeleted.exists()).isFalse();
+    }
+
+    @NonNull
+    private PhotoPickerTranscodeHelper getTranscodeHelper(@NonNull Media3Transcoder transcoder) {
+        PhotoPickerTranscodeHelper helper = new PhotoPickerTranscodeHelper(mTestDirectory);
+        helper.setTranscoder(transcoder);
+        return helper;
+    }
+
+    private void createTestFiles(@NonNull List<String> fileNames) throws IOException {
+        for (String fileName : fileNames) {
+            File file = new File(mTestDirectory, fileName);
+            if (file.createNewFile()) {
+                assertThat(file.exists()).isTrue();
+            }
+        }
+    }
+}
diff --git a/tests/src/com/android/providers/media/PickerUriResolverTest.java b/tests/src/com/android/providers/media/PickerUriResolverTest.java
index 3f6641b53..e571cefb4 100644
--- a/tests/src/com/android/providers/media/PickerUriResolverTest.java
+++ b/tests/src/com/android/providers/media/PickerUriResolverTest.java
@@ -282,6 +282,21 @@ public class PickerUriResolverTest {
         }
     }
 
+    @Test
+    public void testOpenPickerTranscodedFile() throws Exception {
+        final Uri transcodedUri = Uri.parse(
+                "content://media/picker_transcoded/0/com.android.providers.media"
+                        + ".photopicker/media/" + TEST_ID);
+        updateReadUriPermission(transcodedUri, /* grant */ true);
+
+        // Act & Assert.
+        try (ParcelFileDescriptor pfd = sTestPickerUriResolver.openFile(transcodedUri,
+                "r", /* signal */ null,
+                LocalCallingIdentity.forTest(sCurrentContext, /* uid */ -1, /* permission */0))) {
+            assertThat(pfd).isNotNull();
+        }
+    }
+
     @Test
     public void testProcessUrisForSelection_withoutPermissionOrAuthorityChecks() {
         sTestPickerUri = getPickerUriForId(ContentUris.parseId(sMediaStoreUriInOtherContext),
diff --git a/tests/src/com/android/providers/media/SearchTestingUtils.java b/tests/src/com/android/providers/media/SearchTestingUtils.java
new file mode 100644
index 000000000..bd8ada470
--- /dev/null
+++ b/tests/src/com/android/providers/media/SearchTestingUtils.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media;
+
+import android.content.ContentResolver;
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Bundle;
+import android.provider.MediaStore;
+
+import com.android.providers.media.search.SearchUtilConstants;
+
+/**
+ * Holds utility functions for testing picker search workers
+ */
+public class SearchTestingUtils {
+
+    private final DatabaseHelper mDatabaseHelper;
+    private final SearchUtilConstants mSearchUtilConstants;
+
+    public SearchTestingUtils(DatabaseHelper databaseHelper) {
+        mDatabaseHelper = databaseHelper;
+        mSearchUtilConstants = new SearchUtilConstants();
+    }
+
+    /**
+     * Returns the processing statuses from the status table for the test file id
+     */
+    public Cursor getMediaItemDataFromStatusTable(Long testFileId) {
+        return mDatabaseHelper.runWithoutTransaction(database -> {
+            return database.query(
+                    /* tableName */ mSearchUtilConstants.MEDIA_STATUS_TABLE,
+                    /* columns */ new String[] {
+                            mSearchUtilConstants.METADATA_PROCESSING_STATUS_COLUMN,
+                            mSearchUtilConstants.LABEL_PROCESSING_STATUS_COLUMN,
+                            mSearchUtilConstants.LOCATION_PROCESSING_STATUS_COLUMN,
+                            mSearchUtilConstants.OCR_PROCESSING_STATUS_COLUMN,
+                            mSearchUtilConstants.DISPLAY_NAME_COLUMN
+                    },
+                    /* selection */ mSearchUtilConstants.MEDIA_ID_COLUMN + " = ?",
+                    /* selectionArgs */ new String[] { String.valueOf(testFileId) },
+                    /* groupBy */ null, /* having */ null, /*orderBy*/ null, /* limit */null);
+        });
+
+    }
+
+    /**
+     * Marks the testFileId as trashed in the files table
+     */
+    public void trashMediaItem(String testFileId) {
+        ContentValues contentValues = new ContentValues();
+        contentValues.put(MediaStore.Files.FileColumns.IS_TRASHED, 1);
+        String updateColumn = MediaStore.Files.FileColumns._ID + " = ?";
+        String[] updateArguments = new String[] { testFileId };
+        mDatabaseHelper.runWithTransaction(database -> {
+            return database.update(
+                    MediaStore.Files.TABLE, contentValues, updateColumn, updateArguments);
+        });
+    }
+
+    /**
+     * Inserts the given values into the status table
+     */
+    public void insertMediaItemIntoMediaStatusTable(
+            DatabaseHelper databaseHelper, ContentValues insertValues) {
+        databaseHelper.runWithTransaction(database -> {
+            return database.insert(
+                    mSearchUtilConstants.MEDIA_STATUS_TABLE,
+                    /* nullColumnHack */ null,
+                    insertValues);
+        });
+    }
+
+    /**
+     * Updates the given media item data in the specified table with the given values
+     */
+    public void updateMediaItem(String tableName, String mediaId, ContentValues updateValues) {
+        String updateColumn = getUpdateColumn(tableName);
+        String[] updateArguments = new String[] { mediaId };
+        mDatabaseHelper.runWithTransaction(database -> {
+            return database.update(tableName, updateValues, updateColumn, updateArguments);
+        });
+    }
+
+    private String getUpdateColumn(String tableName) {
+        if (tableName.equals(mSearchUtilConstants.MEDIA_STATUS_TABLE)) {
+            return mSearchUtilConstants.MEDIA_ID_COLUMN + " = ?";
+        } else if (tableName.equals(MediaStore.Files.TABLE)) {
+            return MediaStore.Files.FileColumns._ID + " = ?";
+        }
+        throw new IllegalArgumentException("Invalid table name");
+    }
+
+    /**
+     * Deletes the created test file after the tests have executed
+     */
+    public void deleteTestFile(ContentResolver isolatedResolver, long testFileId) {
+        Uri testFileUri = MediaStore.Files.getContentUri(MediaStore.VOLUME_EXTERNAL, testFileId);
+        isolatedResolver.delete(testFileUri, Bundle.EMPTY);
+    }
+}
diff --git a/tests/src/com/android/providers/media/TestDatabaseBackupAndRecovery.java b/tests/src/com/android/providers/media/TestDatabaseBackupAndRecovery.java
index 5a2f2017c..259d5caea 100644
--- a/tests/src/com/android/providers/media/TestDatabaseBackupAndRecovery.java
+++ b/tests/src/com/android/providers/media/TestDatabaseBackupAndRecovery.java
@@ -16,7 +16,6 @@
 
 package com.android.providers.media;
 
-import android.content.Context;
 import android.provider.MediaStore;
 
 import com.android.providers.media.fuse.FuseDaemon;
@@ -98,10 +97,10 @@ public class TestDatabaseBackupAndRecovery extends DatabaseBackupAndRecovery {
     }
 
     @Override
-    protected void waitForVolumeToBeAttached(Set<String> setupCompleteVolumes) {
+    protected void waitForVolumeToBeAttached(String volumeName) {
     }
 
     @Override
-    protected void queuePublicVolumeRecovery(Context context) {
+    protected void markPublicVolumesRecovery() {
     }
 }
diff --git a/tests/src/com/android/providers/media/cloudproviders/SearchProvider.java b/tests/src/com/android/providers/media/cloudproviders/SearchProvider.java
new file mode 100644
index 000000000..f6b269ccc
--- /dev/null
+++ b/tests/src/com/android/providers/media/cloudproviders/SearchProvider.java
@@ -0,0 +1,196 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.cloudproviders;
+
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.CLOUD_ID_1;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.CLOUD_ID_2;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.CLOUD_ID_3;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.CLOUD_ID_4;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.LOCAL_ID_1;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.LOCAL_ID_2;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.getAlbumCursor;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.getCloudMediaCursor;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.getLocalMediaCursor;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.getMediaCategoriesCursor;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.getSuggestionCursor;
+
+import android.content.res.AssetFileDescriptor;
+import android.database.Cursor;
+import android.database.MatrixCursor;
+import android.database.MergeCursor;
+import android.graphics.Point;
+import android.os.Bundle;
+import android.os.CancellationSignal;
+import android.os.ParcelFileDescriptor;
+import android.provider.CloudMediaProvider;
+import android.provider.CloudMediaProviderContract;
+
+import java.io.FileNotFoundException;
+import java.util.List;
+
+public class SearchProvider extends CloudMediaProvider {
+    public static final String AUTHORITY =
+            "com.android.providers.media.photopicker.tests.cloud_search_provider";
+
+    public static final MergeCursor DEFAULT_CLOUD_MEDIA = new MergeCursor(List.of(
+            getCloudMediaCursor(CLOUD_ID_1, LOCAL_ID_1, 0),
+            getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0),
+            getCloudMediaCursor(CLOUD_ID_3, null, 0),
+            getCloudMediaCursor(CLOUD_ID_4, null, 0)
+    ).toArray(new Cursor[0]));
+
+    public static final MergeCursor DEFAULT_CLOUD_SEARCH_RESULTS = new MergeCursor(List.of(
+            getCloudMediaCursor(CLOUD_ID_1, LOCAL_ID_1, 1),
+            getCloudMediaCursor(CLOUD_ID_3, null, 0)
+    ).toArray(new Cursor[0]));
+
+    public static final MergeCursor DEFAULT_LOCAL_SEARCH_RESULTS = new MergeCursor(List.of(
+            getLocalMediaCursor(LOCAL_ID_1, 1),
+            getLocalMediaCursor(LOCAL_ID_2, 0)
+    ).toArray(new Cursor[0]));
+
+    private static Cursor sSearchResults = DEFAULT_CLOUD_SEARCH_RESULTS;
+
+    public static final MergeCursor DEFAULT_SUGGESTION_RESULTS = new MergeCursor(List.of(
+            getSuggestionCursor(CLOUD_ID_1),
+            getSuggestionCursor(CLOUD_ID_2)
+    ).toArray(new Cursor[0]));
+
+    private static Cursor sSearchSuggestions = DEFAULT_SUGGESTION_RESULTS;
+
+    public static final MergeCursor DEFAULT_CATEGORY_RESULTS = new MergeCursor(List.of(
+            getMediaCategoriesCursor("people_and_pets")
+    ).toArray(new Cursor[0]));
+
+    private static Cursor sMediaCategories = DEFAULT_CATEGORY_RESULTS;
+
+    public static final MergeCursor DEFAULT_ALBUM_RESULTS = new MergeCursor(List.of(
+            getAlbumCursor("cloud_album", 0L, /* coverId */ CLOUD_ID_1, AUTHORITY)
+    ).toArray(new Cursor[0]));
+
+    private static Cursor sAlbums = DEFAULT_ALBUM_RESULTS;
+
+    @Override
+    public Cursor onSearchMedia(String mediaSetId, String fallbackSearchText,
+                                Bundle extras, CancellationSignal cancellationSignal) {
+        return sSearchResults;
+    }
+
+    @Override
+    public Cursor onSearchMedia(String searchText,
+                                Bundle extras, CancellationSignal cancellationSignal) {
+        return sSearchResults;
+    }
+
+    @Override
+    public Cursor onQueryMediaInMediaSet(String mediaSetId,
+            Bundle extras, CancellationSignal cancellationSignal) {
+        return sSearchResults;
+    }
+
+    @Override
+    public Cursor onQuerySearchSuggestions(String prefixText, Bundle extras,
+                                           CancellationSignal cancellationSignal) {
+        return sSearchSuggestions;
+    }
+
+    @Override
+    public Cursor onQueryMediaSets(String mediaCategoryId,
+            Bundle extras, CancellationSignal cancellationSignal) {
+        return getCursorForMediaSetSyncTest();
+    }
+
+    @Override
+    public Cursor onQueryMediaCategories(String parentCategoryId, Bundle extras,
+                                         CancellationSignal cancellationSignal) {
+        return sMediaCategories;
+    }
+
+    @Override
+    public Cursor onQueryAlbums(Bundle extras) {
+        return sAlbums;
+    }
+
+    @Override
+    public CloudMediaProviderContract.Capabilities onGetCapabilities() {
+        return new CloudMediaProviderContract.Capabilities.Builder()
+                .setSearchEnabled(true)
+                .setMediaCategoriesEnabled(true)
+                .build();
+    }
+
+    @Override
+    public boolean onCreate() {
+        return true;
+    }
+
+    @Override
+    public Cursor onQueryMedia(Bundle extras) {
+        throw new UnsupportedOperationException("onQueryMedia not supported");
+    }
+
+    @Override
+    public Cursor onQueryDeletedMedia(Bundle extras) {
+        throw new UnsupportedOperationException("onQueryDeletedMedia not supported");
+    }
+
+    @Override
+    public AssetFileDescriptor onOpenPreview(
+            String mediaId,
+            Point size,
+            Bundle extras,
+            CancellationSignal signal) throws FileNotFoundException {
+        throw new UnsupportedOperationException("onOpenPreview not supported");
+    }
+
+    @Override
+    public ParcelFileDescriptor onOpenMedia(
+            String mediaId,
+            Bundle extras,
+            CancellationSignal signal) throws FileNotFoundException {
+        throw new UnsupportedOperationException("onOpenMedia not supported");
+    }
+
+    @Override
+    public Bundle onGetMediaCollectionInfo(Bundle extras) {
+        throw new UnsupportedOperationException("onGetMediaCollectionInfo not supported");
+    }
+
+    public static void setSearchResults(Cursor searchResults) {
+        sSearchResults = searchResults;
+    }
+
+    public static Cursor getSearchResults() {
+        return sSearchResults;
+    }
+
+    /*
+     Returns a media set data cursor for tests
+     */
+    public static Cursor getCursorForMediaSetSyncTest() {
+        String[] columns = new String[]{
+                CloudMediaProviderContract.MediaSetColumns.ID,
+                CloudMediaProviderContract.MediaSetColumns.DISPLAY_NAME,
+                CloudMediaProviderContract.MediaSetColumns.MEDIA_COVER_ID
+        };
+
+        MatrixCursor cursor = new MatrixCursor(columns);
+        cursor.addRow(new Object[] { "mediaSetId", "name", "id" });
+
+        return cursor;
+    }
+}
diff --git a/tests/src/com/android/providers/media/photopicker/CategoriesStateTest.java b/tests/src/com/android/providers/media/photopicker/CategoriesStateTest.java
new file mode 100644
index 000000000..6b6e06387
--- /dev/null
+++ b/tests/src/com/android/providers/media/photopicker/CategoriesStateTest.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+import android.content.Context;
+import android.os.Build;
+import android.platform.test.annotations.DisableFlags;
+import android.platform.test.annotations.EnableFlags;
+import android.platform.test.flag.junit.SetFlagsRule;
+
+import androidx.test.filters.SdkSuppress;
+import androidx.test.platform.app.InstrumentationRegistry;
+
+import com.android.providers.media.TestConfigStore;
+import com.android.providers.media.cloudproviders.SearchProvider;
+import com.android.providers.media.flags.Flags;
+
+import org.junit.Before;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+
+@SdkSuppress(minSdkVersion = Build.VERSION_CODES.TIRAMISU)
+public class CategoriesStateTest {
+
+    private Context mContext;
+
+    @ClassRule
+    public static final SetFlagsRule.ClassRule mSetFlagsClassRule = new SetFlagsRule.ClassRule();
+    @Rule
+    public final SetFlagsRule mSetFlagsRule = mSetFlagsClassRule.createSetFlagsRule();
+
+    @Before
+    public void setup() {
+        mContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+    }
+
+    @Test
+    @EnableFlags({Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH,
+            Flags.FLAG_ENABLE_CLOUD_MEDIA_PROVIDER_CAPABILITIES})
+    public void testAreMediaCategoriesEnabledWithValidAuthority() {
+        final TestConfigStore configStore = new TestConfigStore();
+        configStore.setIsModernPickerEnabled(true);
+
+        final CategoriesState categoriesState = new CategoriesState(configStore);
+        assertTrue(categoriesState.areCategoriesEnabled(mContext, SearchProvider.AUTHORITY));
+    }
+
+    @Test
+    @EnableFlags({Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH,
+            Flags.FLAG_ENABLE_CLOUD_MEDIA_PROVIDER_CAPABILITIES})
+    public void testAreMediaCategoriesEnabledWithVInvalidAuthority() {
+        final TestConfigStore configStore = new TestConfigStore();
+        configStore.setIsModernPickerEnabled(true);
+
+        final CategoriesState categoriesState = new CategoriesState(configStore);
+        assertFalse(categoriesState.areCategoriesEnabled(mContext, "invalid"));
+    }
+
+    @Test
+    @EnableFlags({Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH,
+            Flags.FLAG_ENABLE_CLOUD_MEDIA_PROVIDER_CAPABILITIES})
+    public void testAreMediaCategoriesEnabledWithModernPickerDisabled() {
+        final TestConfigStore configStore = new TestConfigStore();
+        configStore.setIsModernPickerEnabled(false);
+
+        final CategoriesState categoriesState = new CategoriesState(configStore);
+        assertFalse(categoriesState.areCategoriesEnabled(mContext, SearchProvider.AUTHORITY));
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_CLOUD_MEDIA_PROVIDER_CAPABILITIES)
+    @DisableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    public void testAreMediaCategoriesEnabledWithPhotopickerSearchFlagDisabled() {
+        final TestConfigStore configStore = new TestConfigStore();
+        configStore.setIsModernPickerEnabled(true);
+
+        final CategoriesState categoriesState = new CategoriesState(configStore);
+        assertFalse(categoriesState.areCategoriesEnabled(mContext, "invalid"));
+    }
+
+    @Test
+    @EnableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    @DisableFlags(Flags.FLAG_ENABLE_CLOUD_MEDIA_PROVIDER_CAPABILITIES)
+    public void testAreMediaCategoriesEnabledWithCapabilitiesFlagDisabled() {
+        final TestConfigStore configStore = new TestConfigStore();
+        configStore.setIsModernPickerEnabled(true);
+
+        final CategoriesState categoriesState = new CategoriesState(configStore);
+        assertFalse(categoriesState.areCategoriesEnabled(mContext, "invalid"));
+    }
+}
diff --git a/tests/src/com/android/providers/media/photopicker/PhotoPickerCloudTestUtils.java b/tests/src/com/android/providers/media/photopicker/PhotoPickerCloudTestUtils.java
index 6839a8b20..f013e8587 100644
--- a/tests/src/com/android/providers/media/photopicker/PhotoPickerCloudTestUtils.java
+++ b/tests/src/com/android/providers/media/photopicker/PhotoPickerCloudTestUtils.java
@@ -17,6 +17,7 @@
 package com.android.providers.media.photopicker;
 
 import static android.Manifest.permission.READ_DEVICE_CONFIG;
+import static android.Manifest.permission.WRITE_ALLOWLISTED_DEVICE_CONFIG;
 import static android.Manifest.permission.WRITE_DEVICE_CONFIG;
 
 import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;
@@ -108,7 +109,8 @@ public class PhotoPickerCloudTestUtils {
 
     private static void writeDeviceConfigProp(
             @NonNull String namespace, @NonNull String name, @NonNull String value) {
-        getInstrumentation().getUiAutomation().adoptShellPermissionIdentity(WRITE_DEVICE_CONFIG);
+        getInstrumentation().getUiAutomation().adoptShellPermissionIdentity(WRITE_DEVICE_CONFIG,
+                WRITE_ALLOWLISTED_DEVICE_CONFIG);
 
         try {
             DeviceConfig.setProperty(namespace, name, value, /* makeDefault= */ false);
@@ -118,7 +120,8 @@ public class PhotoPickerCloudTestUtils {
     }
 
     private static void deleteDeviceConfigProp(@NonNull String namespace, @NonNull String name) {
-        getInstrumentation().getUiAutomation().adoptShellPermissionIdentity(WRITE_DEVICE_CONFIG);
+        getInstrumentation().getUiAutomation().adoptShellPermissionIdentity(WRITE_DEVICE_CONFIG,
+                WRITE_ALLOWLISTED_DEVICE_CONFIG);
         try {
             if (SdkLevel.isAtLeastU()) {
                 DeviceConfig.deleteProperty(namespace, name);
diff --git a/tests/src/com/android/providers/media/photopicker/PickerDataLayerTest.java b/tests/src/com/android/providers/media/photopicker/PickerDataLayerTest.java
index d1cfb8e7e..234c1c90c 100644
--- a/tests/src/com/android/providers/media/photopicker/PickerDataLayerTest.java
+++ b/tests/src/com/android/providers/media/photopicker/PickerDataLayerTest.java
@@ -144,8 +144,7 @@ public class PickerDataLayerTest {
 
         initializeTestWorkManager(mContext);
         final WorkManager workManager = WorkManager.getInstance(mContext);
-        final PickerSyncManager syncManager = new PickerSyncManager(
-                workManager, mContext, mConfigStore, /* schedulePeriodicSyncs */ false);
+        final PickerSyncManager syncManager = new PickerSyncManager(workManager, mContext);
         mDataLayer = new PickerDataLayer(mContext, mFacade, mController, mConfigStore, syncManager);
 
         // Set cloud provider to null to discard
diff --git a/tests/src/com/android/providers/media/photopicker/PickerSearchUtils.java b/tests/src/com/android/providers/media/photopicker/PickerSearchUtils.java
new file mode 100644
index 000000000..4a1607858
--- /dev/null
+++ b/tests/src/com/android/providers/media/photopicker/PickerSearchUtils.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker;
+
+import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;
+
+import android.content.pm.PackageManager;
+
+public class PickerSearchUtils {
+    /**
+     * @return true if search feature is supported on the given device type, otherwise return false.
+     */
+    public static boolean isHardwareSupportedForSearch() {
+        // The Search feature in Picker is disabled for Watches and IoT devices.
+        final PackageManager pm = getInstrumentation().getContext().getPackageManager();
+        return !pm.hasSystemFeature(PackageManager.FEATURE_EMBEDDED)
+                && !pm.hasSystemFeature(PackageManager.FEATURE_WATCH);
+    }
+}
diff --git a/tests/src/com/android/providers/media/photopicker/SearchStateTest.java b/tests/src/com/android/providers/media/photopicker/SearchStateTest.java
new file mode 100644
index 000000000..3719f0282
--- /dev/null
+++ b/tests/src/com/android/providers/media/photopicker/SearchStateTest.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker;
+
+import static com.android.providers.media.photopicker.PickerSearchUtils.isHardwareSupportedForSearch;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.MockitoAnnotations.initMocks;
+
+import android.content.Context;
+import android.os.Build;
+import android.platform.test.annotations.DisableFlags;
+import android.platform.test.annotations.EnableFlags;
+import android.platform.test.flag.junit.SetFlagsRule;
+
+import androidx.test.filters.SdkSuppress;
+import androidx.test.platform.app.InstrumentationRegistry;
+
+import com.android.providers.media.TestConfigStore;
+import com.android.providers.media.cloudproviders.SearchProvider;
+import com.android.providers.media.flags.Flags;
+
+import org.junit.Assume;
+import org.junit.Before;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.mockito.Mock;
+
+// SetFlagsRule.ClassRule is not available in lower Android versions and Search feature will only
+// be enabled for Android T+ devices.
+@SdkSuppress(minSdkVersion = Build.VERSION_CODES.TIRAMISU)
+public class SearchStateTest {
+    @Mock
+    private PickerSyncController mMockSyncController;
+    private Context mContext;
+    private TestConfigStore mConfigStore;
+
+
+    @ClassRule
+    public static final SetFlagsRule.ClassRule mSetFlagsClassRule = new SetFlagsRule.ClassRule();
+    @Rule public final SetFlagsRule mSetFlagsRule = mSetFlagsClassRule.createSetFlagsRule();
+
+    @Before
+    public void setup() {
+        initMocks(this);
+
+        Assume.assumeTrue(isHardwareSupportedForSearch());
+        PickerSyncController.setInstance(mMockSyncController);
+        mContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+
+        mConfigStore = new TestConfigStore();
+        mConfigStore.setIsModernPickerEnabled(true);
+    }
+
+    @EnableFlags({
+            Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH,
+            Flags.FLAG_ENABLE_CLOUD_MEDIA_PROVIDER_CAPABILITIES
+    })
+    @DisableFlags(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+    @Test
+    public void testSearchAPIFlagIsDisabled() {
+        doReturn(SearchProvider.AUTHORITY)
+                .when(mMockSyncController).getCloudProviderOrDefault(any());
+
+        final SearchState searchState = new SearchState(mConfigStore);
+        final boolean isCloudSearchEnabled = searchState.isCloudSearchEnabled(mContext);
+
+        assertThat(isCloudSearchEnabled).isFalse();
+    }
+
+    @EnableFlags({
+            Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH,
+            Flags.FLAG_ENABLE_CLOUD_MEDIA_PROVIDER_CAPABILITIES
+    })
+    @DisableFlags(Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH)
+    @Test
+    public void testSearchFeatureFlagIsDisabled() {
+        doReturn(SearchProvider.AUTHORITY)
+                .when(mMockSyncController).getCloudProviderOrDefault(any());
+
+        final SearchState searchState = new SearchState(mConfigStore);
+        final boolean isCloudSearchEnabled = searchState.isCloudSearchEnabled(mContext);
+
+        assertThat(isCloudSearchEnabled).isFalse();
+    }
+
+    @EnableFlags({
+            Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH,
+            Flags.FLAG_ENABLE_CLOUD_MEDIA_PROVIDER_CAPABILITIES,
+            Flags.FLAG_ENABLE_PHOTOPICKER_SEARCH
+    })
+    @Test
+    public void testProviderCloudSearchIsEnabled() {
+        doReturn(SearchProvider.AUTHORITY)
+                .when(mMockSyncController).getCloudProviderOrDefault(any());
+
+        final SearchState searchState = new SearchState(mConfigStore);
+        assertThat(searchState.isCloudSearchEnabled(mContext)).isTrue();
+        assertThat(searchState.isCloudSearchEnabled(mContext, SearchProvider.AUTHORITY)).isTrue();
+        assertThat(searchState.isCloudSearchEnabled(mContext, "random")).isFalse();
+    }
+}
diff --git a/tests/src/com/android/providers/media/photopicker/espresso/PhotoPickerTestActivity.java b/tests/src/com/android/providers/media/photopicker/espresso/PhotoPickerTestActivity.java
index 502623520..3443b0c1e 100644
--- a/tests/src/com/android/providers/media/photopicker/espresso/PhotoPickerTestActivity.java
+++ b/tests/src/com/android/providers/media/photopicker/espresso/PhotoPickerTestActivity.java
@@ -28,6 +28,7 @@ import com.android.internal.logging.UiEventLogger;
 import com.android.providers.media.TestConfigStore;
 import com.android.providers.media.photopicker.PhotoPickerActivity;
 import com.android.providers.media.photopicker.data.ItemsProvider;
+import com.android.providers.media.photopicker.data.UserIdManager;
 import com.android.providers.media.photopicker.metrics.PhotoPickerUiEventLogger;
 import com.android.providers.media.photopicker.viewmodel.PickerViewModel;
 
@@ -53,6 +54,12 @@ public class PhotoPickerTestActivity extends PhotoPickerActivity {
         return pickerViewModel;
     }
 
+    @Override
+    @NonNull
+    protected UserIdManager getUserIdManager() {
+        return PhotoPickerBaseTest.getMockUserIdManager();
+    }
+
     TestConfigStore getConfigStore() {
         return mConfigStore;
     }
diff --git a/tests/src/com/android/providers/media/photopicker/sync/MediaInMediaSetsSyncWorkerTest.java b/tests/src/com/android/providers/media/photopicker/sync/MediaInMediaSetsSyncWorkerTest.java
new file mode 100644
index 000000000..d74709dfb
--- /dev/null
+++ b/tests/src/com/android/providers/media/photopicker/sync/MediaInMediaSetsSyncWorkerTest.java
@@ -0,0 +1,475 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.sync;
+
+import static com.android.providers.media.photopicker.PickerSyncController.LOCAL_PICKER_PROVIDER_AUTHORITY;
+import static com.android.providers.media.photopicker.sync.MediaInMediaSetsSyncWorker.SYNC_COMPLETE_RESUME_KEY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_CLOUD_ONLY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_LOCAL_ONLY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_AUTHORITY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_MEDIA_SET_PICKER_ID;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_SYNC_SOURCE;
+import static com.android.providers.media.photopicker.sync.SyncWorkerTestUtils.initializeTestWorkManager;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.MockitoAnnotations.initMocks;
+
+import android.content.ContentUris;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.MatrixCursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.net.Uri;
+import android.platform.test.annotations.EnableFlags;
+import android.provider.CloudMediaProviderContract;
+
+import androidx.test.platform.app.InstrumentationRegistry;
+import androidx.work.Data;
+import androidx.work.OneTimeWorkRequest;
+import androidx.work.WorkInfo;
+import androidx.work.WorkManager;
+
+import com.android.providers.media.cloudproviders.SearchProvider;
+import com.android.providers.media.flags.Flags;
+import com.android.providers.media.photopicker.PickerSyncController;
+import com.android.providers.media.photopicker.data.PickerDatabaseHelper;
+import com.android.providers.media.photopicker.data.PickerDbFacade;
+import com.android.providers.media.photopicker.v2.sqlite.MediaSetsDatabaseUtil;
+import com.android.providers.media.photopicker.v2.sqlite.PickerSQLConstants;
+import com.android.providers.media.photopicker.v2.sqlite.SelectSQLiteQueryBuilder;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ExecutionException;
+
+@EnableFlags(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+public class MediaInMediaSetsSyncWorkerTest {
+    @Mock
+    private PickerSyncController mMockSyncController;
+    @Mock
+    private SyncTracker mMockLocalMediaInMediaSetTracker;
+    @Mock
+    private SyncTracker mMockCloudMediaInMediaSetTracker;
+    private Context mContext;
+    private SQLiteDatabase mDatabase;
+    private PickerDbFacade mFacade;
+
+    @Before
+    public void setup() {
+        initMocks(this);
+
+        mContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+        initializeTestWorkManager(mContext);
+
+        SyncTrackerRegistry.setLocalMediaInMediaSetTracker(mMockLocalMediaInMediaSetTracker);
+        SyncTrackerRegistry.setCloudMediaInMediaSetTracker(mMockCloudMediaInMediaSetTracker);
+        PickerSyncController.setInstance(mMockSyncController);
+
+        final File dbPath = mContext.getDatabasePath(PickerDatabaseHelper.PICKER_DATABASE_NAME);
+        dbPath.delete();
+        final PickerDatabaseHelper helper = new PickerDatabaseHelper(mContext);
+        mDatabase = helper.getWritableDatabase();
+        mFacade = new PickerDbFacade(
+                mContext, new PickerSyncLockManager(), LOCAL_PICKER_PROVIDER_AUTHORITY);
+        mFacade.setCloudProvider(SearchProvider.AUTHORITY);
+
+        doReturn(LOCAL_PICKER_PROVIDER_AUTHORITY).when(mMockSyncController).getLocalProvider();
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController).getCloudProvider();
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController)
+                .getCloudProviderOrDefault(any());
+        doReturn(mFacade).when(mMockSyncController).getDbFacade();
+        doReturn(new PickerSyncLockManager()).when(mMockSyncController).getPickerSyncLockManager();
+    }
+
+    @After
+    public void teardown() {
+        mDatabase.close();
+        File dbPath = mContext.getDatabasePath(PickerDatabaseHelper.PICKER_DATABASE_NAME);
+        dbPath.delete();
+    }
+
+    @Test
+    public void testMediaInMediaSetSyncWithInvalidSyncSource() throws
+            ExecutionException, InterruptedException {
+        // Setup
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(MediaInMediaSetsSyncWorker.class)
+                        .setInputData(
+                                new Data(Map.of(SYNC_WORKER_INPUT_SYNC_SOURCE, 56,
+                                        SYNC_WORKER_INPUT_MEDIA_SET_PICKER_ID, "mediaSetPickerId",
+                                        SYNC_WORKER_INPUT_AUTHORITY, SearchProvider.AUTHORITY)))
+                        .build();
+
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.FAILED);
+    }
+
+    @Test
+    public void testMediaInMediaSetSyncWithInvalidMediaSetPickerId() throws
+            ExecutionException, InterruptedException {
+        // Setup
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(MediaInMediaSetsSyncWorker.class)
+                        .setInputData(
+                                new Data(Map.of(SYNC_WORKER_INPUT_SYNC_SOURCE, SYNC_LOCAL_ONLY,
+                                        SYNC_WORKER_INPUT_MEDIA_SET_PICKER_ID, "",
+                                        SYNC_WORKER_INPUT_AUTHORITY, SearchProvider.AUTHORITY)))
+                        .build();
+
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.FAILED);
+    }
+
+    @Test
+    public void testMediaInMediaSetSyncWithInvalidMediaSetAuthority() throws
+            ExecutionException, InterruptedException {
+        // Setup
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(MediaInMediaSetsSyncWorker.class)
+                        .setInputData(
+                                new Data(Map.of(SYNC_WORKER_INPUT_SYNC_SOURCE, SYNC_LOCAL_ONLY,
+                                        SYNC_WORKER_INPUT_MEDIA_SET_PICKER_ID, "mediaSetPickerId",
+                                        SYNC_WORKER_INPUT_AUTHORITY, "")))
+                        .build();
+
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.FAILED);
+    }
+
+    @Test
+    public void testMediaInMediaSetSyncWithCloudProvider() throws
+            ExecutionException, InterruptedException {
+
+        String categoryId = "categoryId";
+        String auth = String.valueOf(SYNC_CLOUD_ONLY);
+        String mediaSetPickerId = "";
+        Cursor c = getCursorForMediaSetInsertionTest();
+        List<String> mimeTypes = new ArrayList<>();
+        mimeTypes.add("img");
+
+        int mediaSetsInserted = MediaSetsDatabaseUtil.cacheMediaSets(
+                mDatabase, c, categoryId, auth, mimeTypes);
+        assertEquals("Count of inserted media sets should be equal to the cursor size",
+                /*expected*/ c.getCount(), /*actual*/ mediaSetsInserted);
+        Cursor fetchMediaSetCursor = MediaSetsDatabaseUtil.getMediaSetsForCategory(
+                mDatabase, categoryId, auth, mimeTypes);
+        if (fetchMediaSetCursor.moveToFirst()) {
+            mediaSetPickerId = fetchMediaSetCursor.getString(
+                    fetchMediaSetCursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaSetsTableColumns.PICKER_ID.getColumnName()));
+        }
+
+        final Cursor inputCursor = SearchProvider.DEFAULT_CLOUD_SEARCH_RESULTS;
+        SearchProvider.setSearchResults(inputCursor);
+
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(MediaInMediaSetsSyncWorker.class)
+                        .setInputData(new Data(
+                                Map.of(
+                                        SYNC_WORKER_INPUT_SYNC_SOURCE, SYNC_CLOUD_ONLY,
+                                        SYNC_WORKER_INPUT_MEDIA_SET_PICKER_ID, mediaSetPickerId,
+                                        SYNC_WORKER_INPUT_AUTHORITY, SearchProvider.AUTHORITY)))
+                        .build();
+
+        // Test run
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.SUCCEEDED);
+
+        try (Cursor mediaInMediaSetsTableCursor = mDatabase.rawQuery(
+                new SelectSQLiteQueryBuilder(mDatabase).setTables(
+                        PickerSQLConstants.Table.MEDIA_IN_MEDIA_SETS.name()
+                ).buildQuery(), null
+        )) {
+            assertWithMessage("Cursor should not be null")
+                    .that(mediaInMediaSetsTableCursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(mediaInMediaSetsTableCursor.getCount())
+                    .isEqualTo(inputCursor.getCount());
+
+            if (mediaInMediaSetsTableCursor.moveToFirst() && inputCursor.moveToFirst()) {
+
+                do {
+
+                    assertEquals(mediaInMediaSetsTableCursor.getString(
+                                    mediaInMediaSetsTableCursor.getColumnIndex(
+                                            PickerSQLConstants.MediaInMediaSetsTableColumns.CLOUD_ID
+                                                    .getColumnName())),
+                            inputCursor.getString(
+                                    inputCursor.getColumnIndex(
+                                            CloudMediaProviderContract.MediaColumns.ID
+                                    ))
+                    );
+
+                    assertEquals(mediaInMediaSetsTableCursor.getString(
+                                    mediaInMediaSetsTableCursor.getColumnIndex(
+                                            PickerSQLConstants.MediaInMediaSetsTableColumns
+                                                    .MEDIA_SETS_PICKER_ID.getColumnName())),
+                            mediaSetPickerId
+                    );
+
+                    String mediaStoreUri = inputCursor.getString(inputCursor.getColumnIndex(
+                            CloudMediaProviderContract.MediaColumns.MEDIA_STORE_URI
+                    ));
+
+                    if (mediaStoreUri == null) {
+                        assertTrue(mediaInMediaSetsTableCursor.isNull(
+                                mediaInMediaSetsTableCursor.getColumnIndex(
+                                        PickerSQLConstants.MediaInMediaSetsTableColumns
+                                                .LOCAL_ID.getColumnName()))
+                        );
+                    } else {
+                        String localId = String.valueOf(
+                                ContentUris.parseId(Uri.parse(mediaStoreUri)));
+                        assertEquals(mediaInMediaSetsTableCursor.getString(
+                                        mediaInMediaSetsTableCursor.getColumnIndex(
+                                                PickerSQLConstants.MediaInMediaSetsTableColumns
+                                                        .LOCAL_ID.getColumnName())), localId
+                        );
+                    }
+
+                } while (mediaInMediaSetsTableCursor.moveToNext() && inputCursor.moveToNext());
+            }
+        }
+
+        verify(mMockLocalMediaInMediaSetTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockLocalMediaInMediaSetTracker, times(/* wantedNumberOfInvocations */ 0))
+                .markSyncCompleted(any());
+
+        verify(mMockCloudMediaInMediaSetTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockCloudMediaInMediaSetTracker, times(/* wantedNumberOfInvocations */ 1))
+                .markSyncCompleted(any());
+    }
+
+    @Test
+    public void testMediaInMediaSetsSyncLocalProvider() throws
+            ExecutionException, InterruptedException {
+
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController).getLocalProvider();
+
+        String categoryId = "categoryId";
+        String auth = String.valueOf(SYNC_LOCAL_ONLY);
+        String mediaSetPickerId = "";
+        Cursor c = getCursorForMediaSetInsertionTest();
+        List<String> mimeTypes = new ArrayList<>();
+        mimeTypes.add("img");
+
+        int mediaSetsInserted = MediaSetsDatabaseUtil.cacheMediaSets(
+                mDatabase, c, categoryId, auth, mimeTypes);
+        assertEquals("Count of inserted media sets should be equal to the cursor size",
+                /*expected*/ c.getCount(), /*actual*/ mediaSetsInserted);
+        Cursor fetchMediaSetCursor = MediaSetsDatabaseUtil.getMediaSetsForCategory(
+                mDatabase, categoryId, auth, mimeTypes);
+        if (fetchMediaSetCursor.moveToFirst()) {
+            mediaSetPickerId = fetchMediaSetCursor.getString(
+                    fetchMediaSetCursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaSetsTableColumns.PICKER_ID.getColumnName()));
+        }
+
+        final Cursor inputCursor = SearchProvider.DEFAULT_LOCAL_SEARCH_RESULTS;
+        SearchProvider.setSearchResults(inputCursor);
+
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(MediaInMediaSetsSyncWorker.class)
+                        .setInputData(new Data(
+                                Map.of(
+                                        SYNC_WORKER_INPUT_SYNC_SOURCE, SYNC_LOCAL_ONLY,
+                                        SYNC_WORKER_INPUT_MEDIA_SET_PICKER_ID, mediaSetPickerId,
+                                        SYNC_WORKER_INPUT_AUTHORITY, SearchProvider.AUTHORITY)))
+                        .build();
+
+        // Test run
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.SUCCEEDED);
+
+        try (Cursor mediaInMediaSetsTableCursor = mDatabase.rawQuery(
+                new SelectSQLiteQueryBuilder(mDatabase).setTables(
+                        PickerSQLConstants.Table.MEDIA_IN_MEDIA_SETS.name()
+                ).buildQuery(), null
+        )) {
+            assertWithMessage("Cursor should not be null")
+                    .that(mediaInMediaSetsTableCursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(mediaInMediaSetsTableCursor.getCount())
+                    .isEqualTo(inputCursor.getCount());
+
+            if (mediaInMediaSetsTableCursor.moveToFirst() && inputCursor.moveToFirst()) {
+
+                do {
+
+                    assertEquals(mediaInMediaSetsTableCursor.getString(
+                                    mediaInMediaSetsTableCursor.getColumnIndex(
+                                            PickerSQLConstants.MediaInMediaSetsTableColumns.LOCAL_ID
+                                                    .getColumnName())),
+                            inputCursor.getString(
+                                    inputCursor.getColumnIndex(
+                                            CloudMediaProviderContract.MediaColumns.ID
+                                    ))
+                    );
+
+                    assertEquals(mediaInMediaSetsTableCursor.getString(
+                                    mediaInMediaSetsTableCursor.getColumnIndex(
+                                            PickerSQLConstants.MediaInMediaSetsTableColumns
+                                                    .MEDIA_SETS_PICKER_ID.getColumnName())),
+                            mediaSetPickerId
+                    );
+
+                    assertTrue(mediaInMediaSetsTableCursor.isNull(
+                            mediaInMediaSetsTableCursor.getColumnIndex(
+                                    PickerSQLConstants.MediaInMediaSetsTableColumns
+                                            .CLOUD_ID.getColumnName()))
+                    );
+
+                } while (mediaInMediaSetsTableCursor.moveToNext() && inputCursor.moveToNext());
+            }
+        }
+        verify(mMockLocalMediaInMediaSetTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockLocalMediaInMediaSetTracker, times(/* wantedNumberOfInvocations */ 1))
+                .markSyncCompleted(any());
+
+        verify(mMockCloudMediaInMediaSetTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockCloudMediaInMediaSetTracker, times(/* wantedNumberOfInvocations */ 0))
+                .markSyncCompleted(any());
+    }
+
+    private Cursor getCursorForMediaSetInsertionTest() {
+        String[] columns = new String[]{
+                CloudMediaProviderContract.MediaSetColumns.ID,
+                CloudMediaProviderContract.MediaSetColumns.DISPLAY_NAME,
+                CloudMediaProviderContract.MediaSetColumns.MEDIA_COVER_ID
+        };
+
+        final String mediaSetId = "mediaSetId";
+        final String displayName = "name";
+        final String coverId = "coverId";
+        MatrixCursor cursor = new MatrixCursor(columns);
+        cursor.addRow(new Object[] { mediaSetId, displayName, coverId });
+
+        return cursor;
+    }
+
+    @Test
+    public void testMediaInMediaSetSyncComplete() throws
+            ExecutionException, InterruptedException {
+
+        String categoryId = "categoryId";
+        String auth = String.valueOf(SYNC_CLOUD_ONLY);
+        String mediaSetPickerId = "";
+        Cursor c = getCursorForMediaSetInsertionTest();
+        List<String> mimeTypes = new ArrayList<>();
+        mimeTypes.add("img");
+
+        int mediaSetsInserted = MediaSetsDatabaseUtil.cacheMediaSets(
+                mDatabase, c, categoryId, auth, mimeTypes);
+        assertEquals("Count of inserted media sets should be equal to the cursor size",
+                /*expected*/ c.getCount(), /*actual*/ mediaSetsInserted);
+        Cursor fetchMediaSetCursor = MediaSetsDatabaseUtil.getMediaSetsForCategory(
+                mDatabase, categoryId, auth, mimeTypes);
+        if (fetchMediaSetCursor.moveToFirst()) {
+            mediaSetPickerId = fetchMediaSetCursor.getString(
+                    fetchMediaSetCursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaSetsTableColumns.PICKER_ID.getColumnName()));
+        }
+        MediaSetsDatabaseUtil.updateMediaInMediaSetSyncResumeKey(
+                mDatabase, mediaSetPickerId, SYNC_COMPLETE_RESUME_KEY);
+
+        final Cursor inputCursor = SearchProvider.DEFAULT_CLOUD_SEARCH_RESULTS;
+        SearchProvider.setSearchResults(inputCursor);
+
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(MediaInMediaSetsSyncWorker.class)
+                        .setInputData(
+                                new Data(Map.of(SYNC_WORKER_INPUT_SYNC_SOURCE, SYNC_CLOUD_ONLY,
+                                        SYNC_WORKER_INPUT_MEDIA_SET_PICKER_ID, mediaSetPickerId,
+                                        SYNC_WORKER_INPUT_AUTHORITY, SearchProvider.AUTHORITY)))
+                        .build();
+
+        // Test run
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.SUCCEEDED);
+
+        try (Cursor mediaInMediaSetsTableCursor = mDatabase.rawQuery(
+                new SelectSQLiteQueryBuilder(mDatabase).setTables(
+                        PickerSQLConstants.Table.MEDIA_IN_MEDIA_SETS.name()
+                ).buildQuery(), null
+        )) {
+            assertWithMessage("Cursor should not be null")
+                    .that(mediaInMediaSetsTableCursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(mediaInMediaSetsTableCursor.getCount())
+                    .isEqualTo(0);
+
+            verify(mMockLocalMediaInMediaSetTracker, times(/* wantedNumberOfInvocations */ 0))
+                    .createSyncFuture(any());
+            verify(mMockLocalMediaInMediaSetTracker, times(/* wantedNumberOfInvocations */ 0))
+                    .markSyncCompleted(any());
+
+            verify(mMockCloudMediaInMediaSetTracker, times(/* wantedNumberOfInvocations */ 0))
+                    .createSyncFuture(any());
+            verify(mMockCloudMediaInMediaSetTracker, times(/* wantedNumberOfInvocations */ 1))
+                    .markSyncCompleted(any());
+        }
+    }
+}
diff --git a/tests/src/com/android/providers/media/photopicker/sync/MediaSetsSyncWorkerTest.java b/tests/src/com/android/providers/media/photopicker/sync/MediaSetsSyncWorkerTest.java
new file mode 100644
index 000000000..3d0b36252
--- /dev/null
+++ b/tests/src/com/android/providers/media/photopicker/sync/MediaSetsSyncWorkerTest.java
@@ -0,0 +1,343 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.sync;
+
+import static com.android.providers.media.photopicker.PickerSyncController.LOCAL_PICKER_PROVIDER_AUTHORITY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.EXTRA_MIME_TYPES;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_CLOUD_ONLY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_LOCAL_ONLY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_AUTHORITY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_CATEGORY_ID;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_SYNC_SOURCE;
+import static com.android.providers.media.photopicker.sync.SyncWorkerTestUtils.initializeTestWorkManager;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.CLOUD_PROVIDER;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.MockitoAnnotations.initMocks;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.platform.test.annotations.EnableFlags;
+import android.provider.CloudMediaProviderContract;
+
+import androidx.test.platform.app.InstrumentationRegistry;
+import androidx.work.Data;
+import androidx.work.OneTimeWorkRequest;
+import androidx.work.WorkInfo;
+import androidx.work.WorkManager;
+
+import com.android.providers.media.cloudproviders.SearchProvider;
+import com.android.providers.media.flags.Flags;
+import com.android.providers.media.photopicker.PickerSyncController;
+import com.android.providers.media.photopicker.data.PickerDatabaseHelper;
+import com.android.providers.media.photopicker.data.PickerDbFacade;
+import com.android.providers.media.photopicker.v2.sqlite.PickerSQLConstants;
+import com.android.providers.media.photopicker.v2.sqlite.SelectSQLiteQueryBuilder;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+
+import java.io.File;
+import java.util.Map;
+import java.util.concurrent.ExecutionException;
+
+@EnableFlags(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+public class MediaSetsSyncWorkerTest {
+
+    private SQLiteDatabase mDatabase;
+    private PickerDbFacade mFacade;
+    private Context mContext;
+    @Mock
+    private PickerSyncController mMockSyncController;
+    @Mock
+    private SyncTracker mLocalMediaSetsSyncTracker;
+    @Mock
+    private SyncTracker mCloudMediaSetsSyncTracker;
+    private final String mCategoryId = "categoryId";
+    private final String[] mMimeTypes = new String[] { "image/*" };
+
+    @Before
+    public void setup() {
+        initMocks(this);
+        mContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+        initializeTestWorkManager(mContext);
+        PickerSyncController.setInstance(mMockSyncController);
+        SyncTrackerRegistry.setCloudMediaSetsSyncTracker(mCloudMediaSetsSyncTracker);
+        SyncTrackerRegistry.setLocalMediaSetsSyncTracker(mLocalMediaSetsSyncTracker);
+        final File dbPath = mContext.getDatabasePath(PickerDatabaseHelper.PICKER_DATABASE_NAME);
+        dbPath.delete();
+        final PickerDatabaseHelper helper = new PickerDatabaseHelper(mContext);
+        mDatabase = helper.getWritableDatabase();
+        mFacade = new PickerDbFacade(
+                mContext, new PickerSyncLockManager(), LOCAL_PICKER_PROVIDER_AUTHORITY);
+        mFacade.setCloudProvider(CLOUD_PROVIDER);
+        doReturn(mFacade).when(mMockSyncController).getDbFacade();
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController).getLocalProvider();
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController).getCloudProvider();
+    }
+
+    @After
+    public void teardown() {
+        mDatabase.close();
+        File dbPath = mContext.getDatabasePath(PickerDatabaseHelper.PICKER_DATABASE_NAME);
+        dbPath.delete();
+    }
+
+    @Test
+    public void testMediaSetsSyncWithInvalidSyncSource()
+            throws ExecutionException, InterruptedException {
+        // Setup
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(MediaSetsSyncWorker.class)
+                        .setInputData(
+                                new Data(Map.of(SYNC_WORKER_INPUT_SYNC_SOURCE, 56,
+                                        SYNC_WORKER_INPUT_CATEGORY_ID, mCategoryId,
+                                        EXTRA_MIME_TYPES, mMimeTypes)))
+                        .build();
+
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.FAILED);
+    }
+
+    @Test
+    public void testMediaSetsSyncWithMissingSyncSource()
+            throws ExecutionException, InterruptedException {
+        // Setup
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(MediaSetsSyncWorker.class)
+                        .setInputData(
+                                new Data(Map.of(
+                                        SYNC_WORKER_INPUT_CATEGORY_ID, mCategoryId,
+                                        SYNC_WORKER_INPUT_AUTHORITY, SearchProvider.AUTHORITY,
+                                        EXTRA_MIME_TYPES, mMimeTypes)))
+                        .build();
+
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.FAILED);
+    }
+
+    @Test
+    public void testMediaSetsSyncWithInvalidCategoryId()
+            throws ExecutionException, InterruptedException {
+        // Setup
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(MediaSetsSyncWorker.class)
+                        .setInputData(
+                                new Data(Map.of(
+                                        SYNC_WORKER_INPUT_SYNC_SOURCE, SYNC_LOCAL_ONLY,
+                                        SYNC_WORKER_INPUT_CATEGORY_ID, "",
+                                        SYNC_WORKER_INPUT_AUTHORITY, SearchProvider.AUTHORITY,
+                                        EXTRA_MIME_TYPES, mMimeTypes)))
+                        .build();
+
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.FAILED);
+    }
+
+    @Test
+    public void testMediaSetsSyncWithMissingCategoryId()
+            throws ExecutionException, InterruptedException {
+        // Setup
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(MediaSetsSyncWorker.class)
+                        .setInputData(
+                                new Data(Map.of(
+                                        SYNC_WORKER_INPUT_SYNC_SOURCE, SYNC_LOCAL_ONLY,
+                                        SYNC_WORKER_INPUT_AUTHORITY, SearchProvider.AUTHORITY,
+                                        EXTRA_MIME_TYPES, mMimeTypes)))
+                        .build();
+
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.FAILED);
+    }
+
+    @Test
+    public void testMediaSetsSyncWithMissingCategoryAuthority()
+            throws ExecutionException, InterruptedException {
+        // Setup
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(MediaSetsSyncWorker.class)
+                        .setInputData(
+                                new Data(Map.of(
+                                        SYNC_WORKER_INPUT_SYNC_SOURCE, SYNC_CLOUD_ONLY,
+                                        SYNC_WORKER_INPUT_CATEGORY_ID, mCategoryId,
+                                        EXTRA_MIME_TYPES, mMimeTypes)))
+                        .build();
+
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.FAILED);
+    }
+
+    @Test
+    public void testMediaSetsSyncWithValidSyncSourceAndCategoryIdForCloudAuth() throws
+            ExecutionException, InterruptedException {
+
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(MediaSetsSyncWorker.class)
+                        .setInputData(
+                                new Data(Map.of(SYNC_WORKER_INPUT_SYNC_SOURCE, SYNC_CLOUD_ONLY,
+                                        SYNC_WORKER_INPUT_CATEGORY_ID, mCategoryId,
+                                        SYNC_WORKER_INPUT_AUTHORITY, SearchProvider.AUTHORITY,
+                                        EXTRA_MIME_TYPES, mMimeTypes)))
+                        .build();
+
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.SUCCEEDED);
+
+        Cursor cursorFromSearchProvider = SearchProvider.getCursorForMediaSetSyncTest();
+
+        try (Cursor cursorFromMediaSetTable = mDatabase.rawQuery(
+                new SelectSQLiteQueryBuilder(mDatabase).setTables(
+                        PickerSQLConstants.Table.MEDIA_SETS.name()
+                ).buildQuery(), null
+        )) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursorFromMediaSetTable)
+                    .isNotNull();
+            assertEquals(cursorFromMediaSetTable.getCount(), cursorFromSearchProvider.getCount());
+
+            compareMediaSetCursorsForMediaSetProperties(
+                    cursorFromMediaSetTable, cursorFromSearchProvider);
+        }
+
+        verify(mLocalMediaSetsSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mLocalMediaSetsSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .markSyncCompleted(any());
+
+        verify(mCloudMediaSetsSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mCloudMediaSetsSyncTracker, times(/* wantedNumberOfInvocations */ 1))
+                .markSyncCompleted(any());
+    }
+
+    @Test
+    public void testMediaSetsSyncWithValidSyncSourceAndCategoryIdForLocalAuth() throws
+            ExecutionException, InterruptedException {
+
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(MediaSetsSyncWorker.class)
+                        .setInputData(
+                                new Data(Map.of(
+                                        SYNC_WORKER_INPUT_SYNC_SOURCE, SYNC_LOCAL_ONLY,
+                                        SYNC_WORKER_INPUT_CATEGORY_ID, mCategoryId,
+                                        SYNC_WORKER_INPUT_AUTHORITY, SearchProvider.AUTHORITY,
+                                        EXTRA_MIME_TYPES, mMimeTypes)))
+                        .build();
+
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.SUCCEEDED);
+
+        Cursor cursorFromSearchProvider = SearchProvider.getCursorForMediaSetSyncTest();
+
+        try (Cursor cursorFromMediaSetTable = mDatabase.rawQuery(
+                new SelectSQLiteQueryBuilder(mDatabase).setTables(
+                        PickerSQLConstants.Table.MEDIA_SETS.name()
+                ).buildQuery(), null
+        )) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursorFromMediaSetTable)
+                    .isNotNull();
+            assertEquals(cursorFromMediaSetTable.getCount(), cursorFromSearchProvider.getCount());
+
+            compareMediaSetCursorsForMediaSetProperties(
+                    cursorFromMediaSetTable, cursorFromSearchProvider);
+        }
+    }
+
+
+    private void compareMediaSetCursorsForMediaSetProperties(
+            Cursor cursorFromMediaSetTable, Cursor cursorFromSearchProvider) {
+
+        if (cursorFromMediaSetTable.moveToFirst() && cursorFromSearchProvider.moveToFirst()) {
+
+            assertEquals(/*expected*/cursorFromMediaSetTable.getString(
+                            cursorFromMediaSetTable.getColumnIndex(
+                                    PickerSQLConstants.MediaSetsTableColumns.CATEGORY_ID
+                                            .getColumnName())),
+                    /*actual*/mCategoryId);
+
+            assertEquals(cursorFromMediaSetTable.getString(
+                            cursorFromMediaSetTable.getColumnIndex(
+                                    PickerSQLConstants.MediaSetsTableColumns.DISPLAY_NAME
+                                            .getColumnName())),
+                    cursorFromSearchProvider.getString(
+                            cursorFromSearchProvider.getColumnIndex(
+                                    CloudMediaProviderContract.MediaSetColumns.DISPLAY_NAME
+                            ))
+            );
+
+            assertEquals(cursorFromMediaSetTable.getString(
+                            cursorFromMediaSetTable.getColumnIndex(
+                                    PickerSQLConstants.MediaSetsTableColumns.MEDIA_SET_ID
+                                            .getColumnName())),
+                    cursorFromSearchProvider.getString(
+                            cursorFromSearchProvider.getColumnIndex(
+                                    CloudMediaProviderContract.MediaSetColumns.ID
+                            ))
+            );
+
+            assertEquals(cursorFromMediaSetTable.getString(
+                            cursorFromMediaSetTable.getColumnIndex(
+                                    PickerSQLConstants.MediaSetsTableColumns.COVER_ID
+                                            .getColumnName())),
+                    cursorFromSearchProvider.getString(
+                            cursorFromSearchProvider.getColumnIndex(
+                                    CloudMediaProviderContract.MediaSetColumns.MEDIA_COVER_ID
+                            ))
+            );
+        }
+    }
+}
diff --git a/tests/src/com/android/providers/media/photopicker/sync/PickerSyncManagerTest.java b/tests/src/com/android/providers/media/photopicker/sync/PickerSyncManagerTest.java
index 857d14359..049655e47 100644
--- a/tests/src/com/android/providers/media/photopicker/sync/PickerSyncManagerTest.java
+++ b/tests/src/com/android/providers/media/photopicker/sync/PickerSyncManagerTest.java
@@ -16,10 +16,14 @@
 
 package com.android.providers.media.photopicker.sync;
 
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.EXTRA_MIME_TYPES;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.SHOULD_SYNC_GRANTS;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_CLOUD_ONLY;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_LOCAL_AND_CLOUD;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_LOCAL_ONLY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_AUTHORITY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_CATEGORY_ID;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_SEARCH_REQUEST_ID;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_SYNC_SOURCE;
 import static com.android.providers.media.util.BackgroundThreadUtils.waitForIdle;
 
@@ -37,6 +41,7 @@ import static org.mockito.MockitoAnnotations.initMocks;
 import android.content.Context;
 import android.content.Intent;
 import android.content.res.Resources;
+import android.os.Bundle;
 
 import androidx.work.ExistingPeriodicWorkPolicy;
 import androidx.work.ExistingWorkPolicy;
@@ -48,8 +53,10 @@ import androidx.work.WorkManager;
 import androidx.work.WorkRequest;
 
 import com.android.providers.media.TestConfigStore;
+import com.android.providers.media.cloudproviders.SearchProvider;
 import com.android.providers.media.photopicker.PickerSyncController;
 import com.android.providers.media.photopicker.data.PickerSyncRequestExtras;
+import com.android.providers.media.photopicker.v2.model.MediaSetsSyncRequestParams;
 
 import com.google.common.util.concurrent.ListenableFuture;
 
@@ -59,6 +66,7 @@ import org.mockito.ArgumentCaptor;
 import org.mockito.Captor;
 import org.mockito.Mock;
 
+import java.util.ArrayList;
 import java.util.List;
 
 public class PickerSyncManagerTest {
@@ -95,7 +103,7 @@ public class PickerSyncManagerTest {
 
     @Test
     public void testScheduleEndlessWorker() {
-        setupPickerSyncManager(/* schedulePeriodicSyncs */ false);
+        setupPickerSyncManager(/* schedulePeriodicSyncs */ true);
 
         // The third call here comes from the EndlessWorker
         verify(mMockWorkManager, times(1))
@@ -264,7 +272,8 @@ public class PickerSyncManagerTest {
         reset(mMockWorkManager);
         mPickerSyncManager.syncMediaImmediately(new PickerSyncRequestExtras(/* albumId */null,
                 /* albumAuthority */ null, /* initLocalDataOnly */ true,
-                /* callingPackageUid */ 0, /* shouldSyncGrants */ true, null));
+                /* callingPackageUid */ 0, /* shouldSyncGrants */ true, null),
+                mConfigStore);
         verify(mMockWorkManager, times(2))
                 .enqueueUniqueWork(anyString(), any(), mOneTimeWorkRequestArgumentCaptor.capture());
 
@@ -296,7 +305,8 @@ public class PickerSyncManagerTest {
         reset(mMockWorkManager);
         mPickerSyncManager.syncMediaImmediately(new PickerSyncRequestExtras(/* albumId */null,
                 /* albumAuthority */ null, /* initLocalDataOnly */ true,
-                /* callingPackageUid */ 0, /* shouldSyncGrants */ false, null));
+                /* callingPackageUid */ 0, /* shouldSyncGrants */ false, null),
+                mConfigStore);
         verify(mMockWorkManager, times(2))
                 .enqueueUniqueWork(anyString(), any(), mOneTimeWorkRequestArgumentCaptor.capture());
 
@@ -326,7 +336,8 @@ public class PickerSyncManagerTest {
 
         mPickerSyncManager.syncMediaImmediately(new PickerSyncRequestExtras(/* albumId */null,
                 /* albumAuthority */ null, /* initLocalDataOnly */ false,
-                /* callingPackageUid */ 0, /* shouldSyncGrants */ false, null));
+                /* callingPackageUid */ 0, /* shouldSyncGrants */ false, null),
+                mConfigStore);
         verify(mMockWorkManager, times(3))
                 .enqueueUniqueWork(anyString(), any(), mOneTimeWorkRequestArgumentCaptor.capture());
 
@@ -456,8 +467,167 @@ public class PickerSyncManagerTest {
         doReturn(mMockOperation).when(mMockWorkContinuation).enqueue();
         doReturn(mMockFuture).when(mMockOperation).getResult();
 
-        mPickerSyncManager =
-                new PickerSyncManager(mMockWorkManager, mMockContext,
-                        mConfigStore, schedulePeriodicSyncs);
+        mPickerSyncManager = new PickerSyncManager(mMockWorkManager, mMockContext);
+        if (schedulePeriodicSyncs) {
+            mPickerSyncManager.schedulePeriodicSync(
+                    mConfigStore, /* periodicSyncInitialDelay */ 0L);
+        }
+        waitForIdle();
+    }
+
+    @Test
+    public void testSearchResultsLocalSync() {
+        setupPickerSyncManager(/* schedulePeriodicSyncs */ false);
+
+        reset(mMockWorkManager);
+        mPickerSyncManager.syncSearchResultsForProvider(
+                /* searchRequestId */ 10,
+                SYNC_LOCAL_ONLY,
+                PickerSyncController.LOCAL_PICKER_PROVIDER_AUTHORITY
+        );
+        verify(mMockWorkManager, times(1))
+                .enqueueUniqueWork(anyString(), any(), mOneTimeWorkRequestArgumentCaptor.capture());
+
+        final List<OneTimeWorkRequest> workRequestList =
+                mOneTimeWorkRequestArgumentCaptor.getAllValues();
+        assertThat(workRequestList.size()).isEqualTo(1);
+
+        WorkRequest workRequest = workRequestList.get(0);
+        assertThat(workRequest.getWorkSpec().workerClassName)
+                .isEqualTo(SearchResultsSyncWorker.class.getName());
+        assertThat(workRequest.getWorkSpec().expedited).isTrue();
+        assertThat(workRequest.getWorkSpec().isPeriodic()).isFalse();
+        assertThat(workRequest.getWorkSpec().id).isNotNull();
+        assertThat(workRequest.getWorkSpec().constraints.requiresBatteryNotLow()).isFalse();
+        assertThat(workRequest.getWorkSpec().input
+                .getInt(SYNC_WORKER_INPUT_SYNC_SOURCE, -1))
+                .isEqualTo(SYNC_LOCAL_ONLY);
+        assertThat(workRequest.getWorkSpec().input
+                .getInt(SYNC_WORKER_INPUT_SEARCH_REQUEST_ID, -1))
+                .isEqualTo(10);
+    }
+
+    @Test
+    public void testSearchResultsCloudSync() {
+        setupPickerSyncManager(/* schedulePeriodicSyncs */ false);
+
+        reset(mMockWorkManager);
+        mPickerSyncManager.syncSearchResultsForProvider(
+                /* searchRequestId */ 10,
+                SYNC_CLOUD_ONLY,
+                PickerSyncController.LOCAL_PICKER_PROVIDER_AUTHORITY
+        );
+        verify(mMockWorkManager, times(1))
+                .enqueueUniqueWork(anyString(), any(), mOneTimeWorkRequestArgumentCaptor.capture());
+
+        final List<OneTimeWorkRequest> workRequestList =
+                mOneTimeWorkRequestArgumentCaptor.getAllValues();
+        assertThat(workRequestList.size()).isEqualTo(1);
+
+        WorkRequest workRequest = workRequestList.get(0);
+        assertThat(workRequest.getWorkSpec().workerClassName)
+                .isEqualTo(SearchResultsSyncWorker.class.getName());
+        assertThat(workRequest.getWorkSpec().expedited).isTrue();
+        assertThat(workRequest.getWorkSpec().isPeriodic()).isFalse();
+        assertThat(workRequest.getWorkSpec().id).isNotNull();
+        assertThat(workRequest.getWorkSpec().constraints.requiresBatteryNotLow()).isFalse();
+        assertThat(workRequest.getWorkSpec().input
+                .getInt(SYNC_WORKER_INPUT_SYNC_SOURCE, -1))
+                .isEqualTo(SYNC_CLOUD_ONLY);
+        assertThat(workRequest.getWorkSpec().input
+                .getInt(SYNC_WORKER_INPUT_SEARCH_REQUEST_ID, -1))
+                .isEqualTo(10);
+    }
+
+    @Test
+    public void testMediaSetsSyncLocalProvider() {
+        setupPickerSyncManager(/*schedulePeriodicSyncs*/ false);
+
+        reset(mMockWorkManager);
+
+        String categoryId = "id";
+        String[] mimeTypes = new String[] { "image/*" };
+        Bundle extras = new Bundle();
+        extras.putString("authority", SearchProvider.AUTHORITY);
+        extras.putStringArray("mime_types", mimeTypes);
+        extras.putString("category_id", categoryId);
+        extras.putStringArrayList("providers", new ArrayList<>(List.of(
+                PickerSyncController.LOCAL_PICKER_PROVIDER_AUTHORITY)));
+
+        MediaSetsSyncRequestParams requestParams = new MediaSetsSyncRequestParams(extras);
+
+        mPickerSyncManager.syncMediaSetsForProvider(requestParams, SYNC_LOCAL_ONLY);
+        verify(mMockWorkManager, times(1))
+                .enqueueUniqueWork(anyString(), any(), mOneTimeWorkRequestArgumentCaptor.capture());
+
+        final List<OneTimeWorkRequest> workRequestList =
+                mOneTimeWorkRequestArgumentCaptor.getAllValues();
+        assertThat(workRequestList.size()).isEqualTo(1);
+
+        WorkRequest workRequest = workRequestList.get(0);
+        assertThat(workRequest.getWorkSpec().workerClassName)
+                .isEqualTo(MediaSetsSyncWorker.class.getName());
+        assertThat(workRequest.getWorkSpec().expedited).isTrue();
+        assertThat(workRequest.getWorkSpec().isPeriodic()).isFalse();
+        assertThat(workRequest.getWorkSpec().id).isNotNull();
+        assertThat(workRequest.getWorkSpec().constraints.requiresBatteryNotLow()).isFalse();
+        assertThat(workRequest.getWorkSpec().input
+                .getInt(SYNC_WORKER_INPUT_SYNC_SOURCE, -1))
+                .isEqualTo(SYNC_LOCAL_ONLY);
+        assertThat(workRequest.getWorkSpec().input
+                .getString(SYNC_WORKER_INPUT_CATEGORY_ID))
+                .isEqualTo(categoryId);
+        assertThat(workRequest.getWorkSpec().input
+                .getString(SYNC_WORKER_INPUT_AUTHORITY))
+                .isEqualTo(SearchProvider.AUTHORITY);
+        assertThat(workRequest.getWorkSpec().input
+                .getStringArray(EXTRA_MIME_TYPES))
+                .isEqualTo(mimeTypes);
+    }
+
+    @Test
+    public void testMediaSetsSyncCloudProvider() {
+        setupPickerSyncManager(/*schedulePeriodicSyncs*/ false);
+
+        reset(mMockWorkManager);
+
+        String categoryId = "id";
+        String[] mimeTypes = new String[] { "image/*" };
+        Bundle extras = new Bundle();
+        extras.putString("authority", SearchProvider.AUTHORITY);
+        extras.putStringArray("mime_types", mimeTypes);
+        extras.putString("category_id", categoryId);
+        extras.putStringArrayList("providers", new ArrayList<>(List.of(
+                SearchProvider.AUTHORITY)));
+
+        MediaSetsSyncRequestParams requestParams = new MediaSetsSyncRequestParams(extras);
+
+        mPickerSyncManager.syncMediaSetsForProvider(requestParams, SYNC_CLOUD_ONLY);
+        verify(mMockWorkManager, times(1))
+                .enqueueUniqueWork(anyString(), any(), mOneTimeWorkRequestArgumentCaptor.capture());
+
+        final List<OneTimeWorkRequest> workRequestList =
+                mOneTimeWorkRequestArgumentCaptor.getAllValues();
+        assertThat(workRequestList.size()).isEqualTo(1);
+
+        WorkRequest workRequest = workRequestList.get(0);
+        assertThat(workRequest.getWorkSpec().workerClassName)
+                .isEqualTo(MediaSetsSyncWorker.class.getName());
+        assertThat(workRequest.getWorkSpec().expedited).isTrue();
+        assertThat(workRequest.getWorkSpec().isPeriodic()).isFalse();
+        assertThat(workRequest.getWorkSpec().id).isNotNull();
+        assertThat(workRequest.getWorkSpec().constraints.requiresBatteryNotLow()).isFalse();
+        assertThat(workRequest.getWorkSpec().input
+                .getInt(SYNC_WORKER_INPUT_SYNC_SOURCE, -1))
+                .isEqualTo(SYNC_CLOUD_ONLY);
+        assertThat(workRequest.getWorkSpec().input
+                .getString(SYNC_WORKER_INPUT_CATEGORY_ID))
+                .isEqualTo(categoryId);
+        assertThat(workRequest.getWorkSpec().input
+                .getString(SYNC_WORKER_INPUT_AUTHORITY))
+                .isEqualTo(SearchProvider.AUTHORITY);
+        assertThat(workRequest.getWorkSpec().input
+                .getStringArray(EXTRA_MIME_TYPES))
+                .isEqualTo(mimeTypes);
     }
 }
diff --git a/tests/src/com/android/providers/media/photopicker/sync/SearchResultsSyncWorkerTest.java b/tests/src/com/android/providers/media/photopicker/sync/SearchResultsSyncWorkerTest.java
new file mode 100644
index 000000000..d6ea0c4e4
--- /dev/null
+++ b/tests/src/com/android/providers/media/photopicker/sync/SearchResultsSyncWorkerTest.java
@@ -0,0 +1,677 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.sync;
+
+import static android.provider.CloudMediaProviderContract.SEARCH_SUGGESTION_ALBUM;
+import static android.provider.CloudMediaProviderContract.SEARCH_SUGGESTION_FACE;
+
+import static com.android.providers.media.photopicker.PickerSyncController.LOCAL_PICKER_PROVIDER_AUTHORITY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_LOCAL_ONLY;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_SYNC_SOURCE;
+import static com.android.providers.media.photopicker.sync.SearchResultsSyncWorker.SYNC_COMPLETE_RESUME_KEY;
+import static com.android.providers.media.photopicker.sync.SyncWorkerTestUtils.getCloudSearchResultsSyncInputData;
+import static com.android.providers.media.photopicker.sync.SyncWorkerTestUtils.getInvalidSearchResultsSyncInputData;
+import static com.android.providers.media.photopicker.sync.SyncWorkerTestUtils.getLocalSearchResultsSyncInputData;
+import static com.android.providers.media.photopicker.sync.SyncWorkerTestUtils.initializeTestWorkManager;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.MockitoAnnotations.initMocks;
+
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.DatabaseUtils;
+import android.database.sqlite.SQLiteDatabase;
+import android.net.Uri;
+import android.provider.CloudMediaProviderContract;
+
+import androidx.test.platform.app.InstrumentationRegistry;
+import androidx.work.Data;
+import androidx.work.OneTimeWorkRequest;
+import androidx.work.WorkInfo;
+import androidx.work.WorkManager;
+
+import com.android.providers.media.cloudproviders.SearchProvider;
+import com.android.providers.media.photopicker.PickerSyncController;
+import com.android.providers.media.photopicker.SearchState;
+import com.android.providers.media.photopicker.data.PickerDatabaseHelper;
+import com.android.providers.media.photopicker.data.PickerDbFacade;
+import com.android.providers.media.photopicker.v2.model.SearchSuggestionRequest;
+import com.android.providers.media.photopicker.v2.model.SearchTextRequest;
+import com.android.providers.media.photopicker.v2.sqlite.PickerSQLConstants;
+import com.android.providers.media.photopicker.v2.sqlite.SearchRequestDatabaseUtil;
+import com.android.providers.media.photopicker.v2.sqlite.SelectSQLiteQueryBuilder;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+
+import java.io.File;
+import java.util.Map;
+import java.util.concurrent.ExecutionException;
+
+public class SearchResultsSyncWorkerTest {
+    @Mock
+    private PickerSyncController mMockSyncController;
+    @Mock
+    private SyncTracker mMockLocalSearchSyncTracker;
+    @Mock
+    private SyncTracker mMockCloudSearchSyncTracker;
+    @Mock
+    private SearchState mSearchState;
+    private Context mContext;
+    private SQLiteDatabase mDatabase;
+    private PickerDbFacade mFacade;
+
+    @Before
+    public void setup() {
+        initMocks(this);
+
+        mContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+        initializeTestWorkManager(mContext);
+
+        SyncTrackerRegistry.setLocalSearchSyncTracker(mMockLocalSearchSyncTracker);
+        SyncTrackerRegistry.setCloudSearchSyncTracker(mMockCloudSearchSyncTracker);
+        PickerSyncController.setInstance(mMockSyncController);
+
+        final File dbPath = mContext.getDatabasePath(PickerDatabaseHelper.PICKER_DATABASE_NAME);
+        dbPath.delete();
+        final PickerDatabaseHelper helper = new PickerDatabaseHelper(mContext);
+        mDatabase = helper.getWritableDatabase();
+        mFacade = new PickerDbFacade(
+                mContext, new PickerSyncLockManager(), LOCAL_PICKER_PROVIDER_AUTHORITY);
+        mFacade.setCloudProvider(SearchProvider.AUTHORITY);
+
+        doReturn(LOCAL_PICKER_PROVIDER_AUTHORITY).when(mMockSyncController).getLocalProvider();
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController).getCloudProvider();
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController)
+                .getCloudProviderOrDefault(any());
+        doReturn(mFacade).when(mMockSyncController).getDbFacade();
+        doReturn(mSearchState).when(mMockSyncController).getSearchState();
+        doReturn(true).when(mSearchState).isCloudSearchEnabled(any());
+        doReturn(true).when(mSearchState).isCloudSearchEnabled(any(), any());
+        doReturn(new PickerSyncLockManager()).when(mMockSyncController).getPickerSyncLockManager();
+    }
+
+    @Test
+    public void testInvalidSyncSource()
+            throws ExecutionException, InterruptedException {
+        // Setup
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(SearchResultsSyncWorker.class)
+                        .setInputData(
+                                getInvalidSearchResultsSyncInputData(/* searchRequestId */ 10))
+                        .build();
+
+        // Test run
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.FAILED);
+
+        verify(mMockLocalSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockLocalSearchSyncTracker, times(/* wantedNumberOfInvocations */ 1))
+                .markSyncCompleted(any());
+
+        verify(mMockCloudSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockCloudSearchSyncTracker, times(/* wantedNumberOfInvocations */ 1))
+                .markSyncCompleted(any());
+    }
+
+    @Test
+    public void testMissingSearchRequestId()
+            throws ExecutionException, InterruptedException {
+        // Setup
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(SearchResultsSyncWorker.class)
+                        .setInputData(
+                                new Data(Map.of(SYNC_WORKER_INPUT_SYNC_SOURCE, SYNC_LOCAL_ONLY)))
+                        .build();
+
+        // Test run
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.FAILED);
+
+        verify(mMockLocalSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockLocalSearchSyncTracker, times(/* wantedNumberOfInvocations */ 1))
+                .markSyncCompleted(any());
+
+        verify(mMockCloudSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockCloudSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .markSyncCompleted(any());
+    }
+
+    @Test
+    public void testInvalidSearchRequestId()
+            throws ExecutionException, InterruptedException {
+        // Setup
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(SearchResultsSyncWorker.class)
+                        .setInputData(getLocalSearchResultsSyncInputData(/* searchRequestId */ 10))
+                        .build();
+
+        // Test run
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.FAILED);
+
+        verify(mMockLocalSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockLocalSearchSyncTracker, times(/* wantedNumberOfInvocations */ 1))
+                .markSyncCompleted(any());
+
+        verify(mMockCloudSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockCloudSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .markSyncCompleted(any());
+    }
+
+    @Test
+    public void testInvalidAlbumSuggestionsSearchRequestId()
+            throws ExecutionException, InterruptedException {
+        // Setup cloud search results sync for local album
+        SearchSuggestionRequest searchRequest = new SearchSuggestionRequest(
+                null,
+                "search text",
+                "media-set-id",
+                SearchProvider.AUTHORITY,
+                SEARCH_SUGGESTION_ALBUM,
+                null
+        );
+
+        SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest);
+        final int searchRequestId =
+                SearchRequestDatabaseUtil.getSearchRequestID(mDatabase, searchRequest);
+
+        assertWithMessage("Could not find search request is the database " + searchRequest)
+                .that(searchRequestId)
+                .isNotEqualTo(-1);
+
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(SearchResultsSyncWorker.class)
+                        .setInputData(getLocalSearchResultsSyncInputData(searchRequestId))
+                        .build();
+
+        // Test run
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.FAILED);
+    }
+
+    @Test
+    public void testTextSearchSyncWithCloudProvider()
+            throws ExecutionException, InterruptedException {
+        // Setup
+        SearchTextRequest searchRequest = new SearchTextRequest(
+                null,
+                "search text",
+                null
+        );
+
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController).getCloudProvider();
+
+        SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest);
+        final int searchRequestId =
+                SearchRequestDatabaseUtil.getSearchRequestID(mDatabase, searchRequest);
+
+        assertWithMessage("Could not find search request is the database " + searchRequest)
+                .that(searchRequestId)
+                .isNotEqualTo(-1);
+
+        final Cursor inputCursor = SearchProvider.DEFAULT_CLOUD_SEARCH_RESULTS;
+        SearchProvider.setSearchResults(inputCursor);
+
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(SearchResultsSyncWorker.class)
+                        .setInputData(getCloudSearchResultsSyncInputData(searchRequestId))
+                        .build();
+
+        // Test run
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.SUCCEEDED);
+
+        try (Cursor cursor = mDatabase.rawQuery(
+                new SelectSQLiteQueryBuilder(mDatabase).setTables(
+                        PickerSQLConstants.Table.SEARCH_RESULT_MEDIA.name()
+                ).buildQuery(), null
+        )) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(inputCursor.getCount());
+
+            if (cursor.moveToFirst() && inputCursor.moveToFirst()) {
+                do {
+                    final ContentValues dbValues = new ContentValues();
+                    DatabaseUtils.cursorRowToContentValues(cursor, dbValues);
+
+                    final ContentValues inputValues = new ContentValues();
+                    DatabaseUtils.cursorRowToContentValues(inputCursor, inputValues);
+
+                    assertWithMessage("Cloud id is not as expected")
+                            .that(dbValues.getAsString(PickerSQLConstants
+                                    .SearchResultMediaTableColumns.CLOUD_ID.getColumnName()))
+                            .isEqualTo(inputValues.get(CloudMediaProviderContract.MediaColumns.ID));
+
+                    assertWithMessage("Search request id is not as expected")
+                            .that(dbValues.getAsInteger(
+                                    PickerSQLConstants.SearchResultMediaTableColumns
+                                            .SEARCH_REQUEST_ID.getColumnName()))
+                            .isEqualTo(searchRequestId);
+
+                    final String inputMediaStoreUri = inputValues
+                            .getAsString(CloudMediaProviderContract.MediaColumns.MEDIA_STORE_URI);
+                    if (inputMediaStoreUri == null) {
+                        assertWithMessage("Local id is not null")
+                                .that(dbValues.getAsInteger(
+                                        PickerSQLConstants.SearchResultMediaTableColumns
+                                                .LOCAL_ID.getColumnName()))
+                                .isNull();
+                    } else {
+                        assertWithMessage("Local id is not as expected")
+                                .that(dbValues.getAsInteger(
+                                        PickerSQLConstants.SearchResultMediaTableColumns
+                                                .LOCAL_ID.getColumnName()))
+                                .isEqualTo(ContentUris.parseId(Uri.parse(inputMediaStoreUri)));
+                    }
+                } while (cursor.moveToNext() && inputCursor.moveToNext());
+            }
+        }
+
+        verify(mMockLocalSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockLocalSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .markSyncCompleted(any());
+
+        verify(mMockCloudSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockCloudSearchSyncTracker, times(/* wantedNumberOfInvocations */ 1))
+                .markSyncCompleted(any());
+    }
+
+    @Test
+    public void testTextSearchSyncWithLocalProvider()
+            throws ExecutionException, InterruptedException {
+        // Setup
+        SearchTextRequest searchRequest = new SearchTextRequest(
+                null,
+                "search text",
+                null
+        );
+
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController).getLocalProvider();
+
+        SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest);
+        final int searchRequestId =
+                SearchRequestDatabaseUtil.getSearchRequestID(mDatabase, searchRequest);
+
+        assertWithMessage("Could not find search request is the database " + searchRequest)
+                .that(searchRequestId)
+                .isNotEqualTo(-1);
+
+        final Cursor inputCursor = SearchProvider.DEFAULT_LOCAL_SEARCH_RESULTS;
+        SearchProvider.setSearchResults(inputCursor);
+
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(SearchResultsSyncWorker.class)
+                        .setInputData(getLocalSearchResultsSyncInputData(searchRequestId))
+                        .build();
+
+        // Test run
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.SUCCEEDED);
+
+        try (Cursor cursor = mDatabase.rawQuery(
+                new SelectSQLiteQueryBuilder(mDatabase).setTables(
+                        PickerSQLConstants.Table.SEARCH_RESULT_MEDIA.name()
+                ).buildQuery(), null
+        )) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(inputCursor.getCount());
+
+            if (cursor.moveToFirst() && inputCursor.moveToFirst()) {
+                do {
+                    final ContentValues dbValues = new ContentValues();
+                    DatabaseUtils.cursorRowToContentValues(cursor, dbValues);
+
+                    final ContentValues inputValues = new ContentValues();
+                    DatabaseUtils.cursorRowToContentValues(inputCursor, inputValues);
+
+                    assertWithMessage("Local id is not as expected")
+                            .that(dbValues.getAsString(PickerSQLConstants
+                                    .SearchResultMediaTableColumns.LOCAL_ID.getColumnName()))
+                            .isEqualTo(inputValues.get(CloudMediaProviderContract.MediaColumns.ID));
+
+                    assertWithMessage("Cloud id is not null")
+                            .that(dbValues.getAsString(PickerSQLConstants
+                                    .SearchResultMediaTableColumns.CLOUD_ID.getColumnName()))
+                            .isNull();
+
+                    assertWithMessage("Search request id is not as expected")
+                            .that(dbValues.getAsInteger(
+                                    PickerSQLConstants.SearchResultMediaTableColumns
+                                            .SEARCH_REQUEST_ID.getColumnName()))
+                            .isEqualTo(searchRequestId);
+                } while (cursor.moveToNext() && inputCursor.moveToNext());
+            }
+        }
+
+        verify(mMockLocalSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockLocalSearchSyncTracker, times(/* wantedNumberOfInvocations */ 1))
+                .markSyncCompleted(any());
+
+        verify(mMockCloudSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockCloudSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .markSyncCompleted(any());
+    }
+
+    @Test
+    public void testSuggestionSearchSyncWithCloudProvider()
+            throws ExecutionException, InterruptedException {
+        // Setup
+        SearchSuggestionRequest searchRequest = new SearchSuggestionRequest(
+                null,
+                "search text",
+                "media-set-id",
+                LOCAL_PICKER_PROVIDER_AUTHORITY,
+                SEARCH_SUGGESTION_FACE,
+                null
+        );
+
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController).getCloudProvider();
+
+        SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest);
+        final int searchRequestId =
+                SearchRequestDatabaseUtil.getSearchRequestID(mDatabase, searchRequest);
+
+        assertWithMessage("Could not find search request is the database " + searchRequest)
+                .that(searchRequestId)
+                .isNotEqualTo(-1);
+
+        final Cursor inputCursor = SearchProvider.DEFAULT_CLOUD_SEARCH_RESULTS;
+        SearchProvider.setSearchResults(inputCursor);
+
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(SearchResultsSyncWorker.class)
+                        .setInputData(getCloudSearchResultsSyncInputData(searchRequestId))
+                        .build();
+
+        // Test run
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.SUCCEEDED);
+
+        try (Cursor cursor = mDatabase.rawQuery(
+                new SelectSQLiteQueryBuilder(mDatabase).setTables(
+                        PickerSQLConstants.Table.SEARCH_RESULT_MEDIA.name()
+                ).buildQuery(), null
+        )) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(inputCursor.getCount());
+
+            if (cursor.moveToFirst() && inputCursor.moveToFirst()) {
+                do {
+                    final ContentValues dbValues = new ContentValues();
+                    DatabaseUtils.cursorRowToContentValues(cursor, dbValues);
+
+                    final ContentValues inputValues = new ContentValues();
+                    DatabaseUtils.cursorRowToContentValues(inputCursor, inputValues);
+
+                    assertWithMessage("Cloud id is not as expected")
+                            .that(dbValues.getAsString(PickerSQLConstants
+                                    .SearchResultMediaTableColumns.CLOUD_ID.getColumnName()))
+                            .isEqualTo(inputValues.get(CloudMediaProviderContract.MediaColumns.ID));
+
+                    assertWithMessage("Search request id is not as expected")
+                            .that(dbValues.getAsInteger(
+                                    PickerSQLConstants.SearchResultMediaTableColumns
+                                            .SEARCH_REQUEST_ID.getColumnName()))
+                            .isEqualTo(searchRequestId);
+
+                    final String inputMediaStoreUri = inputValues
+                            .getAsString(CloudMediaProviderContract.MediaColumns.MEDIA_STORE_URI);
+                    if (inputMediaStoreUri == null) {
+                        assertWithMessage("Local id is not null")
+                                .that(dbValues.getAsInteger(
+                                        PickerSQLConstants.SearchResultMediaTableColumns
+                                                .LOCAL_ID.getColumnName()))
+                                .isNull();
+                    } else {
+                        assertWithMessage("Local id is not as expected")
+                                .that(dbValues.getAsInteger(
+                                        PickerSQLConstants.SearchResultMediaTableColumns
+                                                .LOCAL_ID.getColumnName()))
+                                .isEqualTo(ContentUris.parseId(Uri.parse(inputMediaStoreUri)));
+                    }
+                } while (cursor.moveToNext() && inputCursor.moveToNext());
+            }
+        }
+
+        verify(mMockLocalSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockLocalSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .markSyncCompleted(any());
+
+        verify(mMockCloudSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockCloudSearchSyncTracker, times(/* wantedNumberOfInvocations */ 1))
+                .markSyncCompleted(any());
+    }
+
+    @Test
+    public void testSuggestionSearchSyncWithLocalProvider()
+            throws ExecutionException, InterruptedException {
+        // Setup
+        SearchSuggestionRequest searchRequest = new SearchSuggestionRequest(
+                null,
+                "search text",
+                "media-set-id",
+                SearchProvider.AUTHORITY,
+                SEARCH_SUGGESTION_FACE,
+                "Random-resume-key"
+        );
+
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController).getLocalProvider();
+
+        SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest);
+        final int searchRequestId =
+                SearchRequestDatabaseUtil.getSearchRequestID(mDatabase, searchRequest);
+
+        assertWithMessage("Could not find search request is the database " + searchRequest)
+                .that(searchRequestId)
+                .isNotEqualTo(-1);
+
+        final Cursor inputCursor = SearchProvider.DEFAULT_LOCAL_SEARCH_RESULTS;
+        SearchProvider.setSearchResults(inputCursor);
+
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(SearchResultsSyncWorker.class)
+                        .setInputData(getLocalSearchResultsSyncInputData(searchRequestId))
+                        .build();
+
+        // Test run
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.SUCCEEDED);
+
+        try (Cursor cursor = mDatabase.rawQuery(
+                new SelectSQLiteQueryBuilder(mDatabase).setTables(
+                        PickerSQLConstants.Table.SEARCH_RESULT_MEDIA.name()
+                ).buildQuery(), null
+        )) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(inputCursor.getCount());
+
+            if (cursor.moveToFirst() && inputCursor.moveToFirst()) {
+                do {
+                    final ContentValues dbValues = new ContentValues();
+                    DatabaseUtils.cursorRowToContentValues(cursor, dbValues);
+
+                    final ContentValues inputValues = new ContentValues();
+                    DatabaseUtils.cursorRowToContentValues(inputCursor, inputValues);
+
+                    assertWithMessage("Local id is not as expected")
+                            .that(dbValues.getAsString(PickerSQLConstants
+                                    .SearchResultMediaTableColumns.LOCAL_ID.getColumnName()))
+                            .isEqualTo(inputValues.get(CloudMediaProviderContract.MediaColumns.ID));
+
+                    assertWithMessage("Cloud id is not null")
+                            .that(dbValues.getAsString(PickerSQLConstants
+                                    .SearchResultMediaTableColumns.CLOUD_ID.getColumnName()))
+                            .isNull();
+
+                    assertWithMessage("Search request id is not as expected")
+                            .that(dbValues.getAsInteger(
+                                    PickerSQLConstants.SearchResultMediaTableColumns
+                                            .SEARCH_REQUEST_ID.getColumnName()))
+                            .isEqualTo(searchRequestId);
+                } while (cursor.moveToNext() && inputCursor.moveToNext());
+            }
+        }
+
+        verify(mMockLocalSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockLocalSearchSyncTracker, times(/* wantedNumberOfInvocations */ 1))
+                .markSyncCompleted(any());
+
+        verify(mMockCloudSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockCloudSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .markSyncCompleted(any());
+    }
+
+    @Test
+    public void testSyncWasAlreadyComplete()
+            throws ExecutionException, InterruptedException {
+        // Setup
+        SearchSuggestionRequest searchRequest = new SearchSuggestionRequest(
+                null,
+                "search text",
+                "media-set-id",
+                LOCAL_PICKER_PROVIDER_AUTHORITY,
+                SEARCH_SUGGESTION_FACE,
+                SYNC_COMPLETE_RESUME_KEY
+        );
+
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController).getCloudProvider();
+
+        SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest);
+        final int searchRequestId =
+                SearchRequestDatabaseUtil.getSearchRequestID(mDatabase, searchRequest);
+
+        assertWithMessage("Could not find search request is the database " + searchRequest)
+                .that(searchRequestId)
+                .isNotEqualTo(-1);
+
+        final Cursor inputCursor = SearchProvider.DEFAULT_CLOUD_SEARCH_RESULTS;
+        SearchProvider.setSearchResults(inputCursor);
+
+        final OneTimeWorkRequest request =
+                new OneTimeWorkRequest.Builder(SearchResultsSyncWorker.class)
+                        .setInputData(getCloudSearchResultsSyncInputData(searchRequestId))
+                        .build();
+
+        // Test run
+        final WorkManager workManager = WorkManager.getInstance(mContext);
+        workManager.enqueue(request).getResult().get();
+
+        // Verify
+        final WorkInfo workInfo = workManager.getWorkInfoById(request.getId()).get();
+        assertThat(workInfo.getState()).isEqualTo(WorkInfo.State.SUCCEEDED);
+
+        try (Cursor cursor = mDatabase.rawQuery(
+                new SelectSQLiteQueryBuilder(mDatabase).setTables(
+                        PickerSQLConstants.Table.SEARCH_RESULT_MEDIA.name()
+                ).buildQuery(), null
+        )) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(0);
+        }
+
+        verify(mMockLocalSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockLocalSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .markSyncCompleted(any());
+
+        verify(mMockCloudSearchSyncTracker, times(/* wantedNumberOfInvocations */ 0))
+                .createSyncFuture(any());
+        verify(mMockCloudSearchSyncTracker, times(/* wantedNumberOfInvocations */ 1))
+                .markSyncCompleted(any());
+    }
+}
diff --git a/tests/src/com/android/providers/media/photopicker/sync/SyncWorkerTestUtils.java b/tests/src/com/android/providers/media/photopicker/sync/SyncWorkerTestUtils.java
index 52702ac7f..b21602e64 100644
--- a/tests/src/com/android/providers/media/photopicker/sync/SyncWorkerTestUtils.java
+++ b/tests/src/com/android/providers/media/photopicker/sync/SyncWorkerTestUtils.java
@@ -24,6 +24,7 @@ import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYN
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_ALBUM_ID;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_AUTHORITY;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_RESET_TYPE;
+import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_SEARCH_REQUEST_ID;
 import static com.android.providers.media.photopicker.sync.PickerSyncManager.SYNC_WORKER_INPUT_SYNC_SOURCE;
 
 import android.content.Context;
@@ -108,6 +109,21 @@ public class SyncWorkerTestUtils {
                 SYNC_WORKER_INPUT_ALBUM_ID, albumId));
     }
 
+    public static Data getLocalSearchResultsSyncInputData(int searchRequestId) {
+        return new Data(Map.of(SYNC_WORKER_INPUT_SYNC_SOURCE, SYNC_LOCAL_ONLY,
+                SYNC_WORKER_INPUT_SEARCH_REQUEST_ID, searchRequestId));
+    }
+
+    public static Data getCloudSearchResultsSyncInputData(int searchRequestId) {
+        return new Data(Map.of(SYNC_WORKER_INPUT_SYNC_SOURCE, SYNC_CLOUD_ONLY,
+                SYNC_WORKER_INPUT_SEARCH_REQUEST_ID, searchRequestId));
+    }
+
+    public static Data getInvalidSearchResultsSyncInputData(int searchRequestId) {
+        return new Data(Map.of(SYNC_WORKER_INPUT_SYNC_SOURCE, SYNC_LOCAL_AND_CLOUD,
+                SYNC_WORKER_INPUT_SEARCH_REQUEST_ID, searchRequestId));
+    }
+
     static <W extends Worker> W buildTestWorker(@NonNull Context context,
             @NonNull Class<W> workerClass) {
         return TestWorkerBuilder.from(context, workerClass)
diff --git a/tests/src/com/android/providers/media/photopicker/util/CloudProviderUtilsTest.java b/tests/src/com/android/providers/media/photopicker/util/CloudProviderUtilsTest.java
index 8649d4d56..bebbb557a 100644
--- a/tests/src/com/android/providers/media/photopicker/util/CloudProviderUtilsTest.java
+++ b/tests/src/com/android/providers/media/photopicker/util/CloudProviderUtilsTest.java
@@ -36,7 +36,6 @@ import java.util.Set;
 
 
 public class CloudProviderUtilsTest {
-
     @Test
     public void getAllAvailableCloudProvidersTest() {
         final Context context = InstrumentationRegistry.getTargetContext();
diff --git a/tests/src/com/android/providers/media/photopicker/util/PickerDbTestUtils.java b/tests/src/com/android/providers/media/photopicker/util/PickerDbTestUtils.java
index df29f9d40..a5b4aa959 100644
--- a/tests/src/com/android/providers/media/photopicker/util/PickerDbTestUtils.java
+++ b/tests/src/com/android/providers/media/photopicker/util/PickerDbTestUtils.java
@@ -16,6 +16,8 @@
 
 package com.android.providers.media.photopicker.util;
 
+import static android.provider.CloudMediaProviderContract.SEARCH_SUGGESTION_ALBUM;
+
 import static com.android.providers.media.util.MimeUtils.getExtensionFromMimeType;
 
 import static com.google.common.truth.Truth.assertWithMessage;
@@ -312,6 +314,52 @@ public class PickerDbTestUtils {
                 SIZE_BYTES, mimeType, STANDARD_MIME_TYPE_EXTENSION, isFavorite);
     }
 
+    public static Cursor getSuggestionCursor(String mediaSetId) {
+        String[] projectionKey = new String[]{
+                CloudMediaProviderContract.SearchSuggestionColumns.MEDIA_SET_ID,
+                CloudMediaProviderContract.SearchSuggestionColumns.DISPLAY_TEXT,
+                CloudMediaProviderContract.SearchSuggestionColumns.TYPE,
+                CloudMediaProviderContract.SearchSuggestionColumns.MEDIA_COVER_ID,
+        };
+
+        String[] projectionValue = new String[]{
+                mediaSetId,
+                "display_text",
+                SEARCH_SUGGESTION_ALBUM,
+                CLOUD_ID_1,
+        };
+
+        MatrixCursor c = new MatrixCursor(projectionKey);
+        c.addRow(projectionValue);
+        return c;
+    }
+
+    public static Cursor getMediaCategoriesCursor(String categoryId) {
+        String[] projectionKey = new String[]{
+                CloudMediaProviderContract.MediaCategoryColumns.ID,
+                CloudMediaProviderContract.MediaCategoryColumns.DISPLAY_NAME,
+                CloudMediaProviderContract.MediaCategoryColumns.MEDIA_CATEGORY_TYPE,
+                CloudMediaProviderContract.MediaCategoryColumns.MEDIA_COVER_ID1,
+                CloudMediaProviderContract.MediaCategoryColumns.MEDIA_COVER_ID2,
+                CloudMediaProviderContract.MediaCategoryColumns.MEDIA_COVER_ID3,
+                CloudMediaProviderContract.MediaCategoryColumns.MEDIA_COVER_ID4,
+        };
+
+        String[] projectionValue = new String[]{
+                categoryId,
+                "display_text",
+                CloudMediaProviderContract.MEDIA_CATEGORY_TYPE_PEOPLE_AND_PETS,
+                CLOUD_ID_1,
+                CLOUD_ID_2,
+                /* MEDIA_COVER_ID3 */ null,
+                /* MEDIA_COVER_ID4 */ null
+        };
+
+        MatrixCursor c = new MatrixCursor(
+                CloudMediaProviderContract.MediaCategoryColumns.ALL_PROJECTION);
+        c.addRow(projectionValue);
+        return c;
+    }
     public static String toMediaStoreUri(String localId) {
         if (localId == null) {
             return null;
diff --git a/tests/src/com/android/providers/media/photopicker/v2/PickerDataLayerV2Test.java b/tests/src/com/android/providers/media/photopicker/v2/PickerDataLayerV2Test.java
index 852d5c7ae..02a1dbc7e 100644
--- a/tests/src/com/android/providers/media/photopicker/v2/PickerDataLayerV2Test.java
+++ b/tests/src/com/android/providers/media/photopicker/v2/PickerDataLayerV2Test.java
@@ -49,12 +49,16 @@ import static com.android.providers.media.photopicker.util.PickerDbTestUtils.get
 import static com.android.providers.media.photopicker.v2.PickerDataLayerV2.COLUMN_GRANTS_COUNT;
 import static com.android.providers.media.photopicker.v2.model.AlbumsCursorWrapper.EMPTY_MEDIA_ID;
 
+import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
 
 import static org.junit.Assert.assertEquals;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
 import static org.mockito.MockitoAnnotations.initMocks;
 
 import android.content.Context;
@@ -75,15 +79,30 @@ import android.test.mock.MockContentProvider;
 import android.test.mock.MockContentResolver;
 
 import androidx.test.InstrumentationRegistry;
+import androidx.work.ExistingWorkPolicy;
+import androidx.work.OneTimeWorkRequest;
+import androidx.work.Operation;
+import androidx.work.WorkManager;
 
 import com.android.providers.media.PickerUriResolver;
+import com.android.providers.media.cloudproviders.SearchProvider;
+import com.android.providers.media.photopicker.CategoriesState;
 import com.android.providers.media.photopicker.PickerSyncController;
+import com.android.providers.media.photopicker.SearchState;
 import com.android.providers.media.photopicker.data.ItemsProvider;
 import com.android.providers.media.photopicker.data.PickerDatabaseHelper;
 import com.android.providers.media.photopicker.data.PickerDbFacade;
 import com.android.providers.media.photopicker.data.model.UserId;
 import com.android.providers.media.photopicker.sync.PickerSyncLockManager;
+import com.android.providers.media.photopicker.v2.model.MediaGroup;
 import com.android.providers.media.photopicker.v2.model.MediaSource;
+import com.android.providers.media.photopicker.v2.model.SearchSuggestion;
+import com.android.providers.media.photopicker.v2.model.SearchTextRequest;
+import com.android.providers.media.photopicker.v2.sqlite.PickerSQLConstants;
+import com.android.providers.media.photopicker.v2.sqlite.SearchSuggestionsDatabaseUtils;
+import com.android.providers.media.photopicker.v2.sqlite.SearchSuggestionsQuery;
+
+import com.google.common.util.concurrent.ListenableFuture;
 
 import org.junit.After;
 import org.junit.Before;
@@ -95,6 +114,7 @@ import java.io.File;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import java.util.concurrent.Executor;
 
 public class PickerDataLayerV2Test {
     @Mock
@@ -103,6 +123,16 @@ public class PickerDataLayerV2Test {
     private Context mMockContext;
     @Mock
     private PackageManager mMockPackageManager;
+    @Mock
+    private SearchState mSearchState;
+    @Mock
+    private WorkManager mMockWorkManager;
+    @Mock
+    private Operation mMockOperation;
+    @Mock
+    private ListenableFuture<Operation.State.SUCCESS> mMockFuture;
+    @Mock
+    CategoriesState mCategoriesState;
     private PickerDbFacade mFacade;
     private Context mContext;
     private MockContentResolver mMockContentResolver;
@@ -149,6 +179,8 @@ public class PickerDataLayerV2Test {
         doReturn(CLOUD_PROVIDER).when(mMockSyncController).getCloudProvider();
         doReturn(CLOUD_PROVIDER).when(mMockSyncController).getCloudProviderOrDefault(any());
         doReturn(mFacade).when(mMockSyncController).getDbFacade();
+        doReturn(mSearchState).when(mMockSyncController).getSearchState();
+        doReturn(mCategoriesState).when(mMockSyncController).getCategoriesState();
         doReturn(new PickerSyncLockManager()).when(mMockSyncController).getPickerSyncLockManager();
         doReturn(mMockContentResolver).when(mMockContext).getContentResolver();
     }
@@ -2077,6 +2109,323 @@ public class PickerDataLayerV2Test {
         }
     }
 
+    @Test
+    public void testQuerySearchSuggestionsZeroState() {
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController).getCloudProvider();
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController)
+                .getCloudProviderOrDefault(any());
+        doReturn(mSearchState).when(mMockSyncController).getSearchState();
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any());
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any(), any());
+        doReturn(true).when(mSearchState).isCloudSearchEnabled(any());
+
+        final Bundle bundle = new Bundle();
+        bundle.putString("prefix", "");
+        bundle.putStringArrayList("providers", new ArrayList<>(List.of(SearchProvider.AUTHORITY)));
+        final SearchSuggestionsQuery query = new SearchSuggestionsQuery(bundle);
+
+        // Async tasks are run synchronously during tests to make tests deterministic and prevent
+        // flaky test results.
+        final Executor currentThreadExecutor = Runnable::run;
+
+        try (Cursor cursor = PickerDataLayerV2.querySearchSuggestions(
+                mContext, bundle, currentThreadExecutor, null)) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(SearchProvider.DEFAULT_SUGGESTION_RESULTS.getCount());
+
+            final String projection = PickerSQLConstants.SearchSuggestionsResponseColumns
+                            .MEDIA_SET_ID.getProjection();
+            if (cursor.moveToFirst() && SearchProvider.DEFAULT_SUGGESTION_RESULTS.moveToFirst()) {
+                do {
+                    assertWithMessage("Media ID is not as expected")
+                            .that(cursor.getString(cursor.getColumnIndexOrThrow(projection)))
+                            .isEqualTo(SearchProvider.DEFAULT_SUGGESTION_RESULTS.getString(
+                                    SearchProvider.DEFAULT_SUGGESTION_RESULTS
+                                            .getColumnIndexOrThrow(projection)));
+                } while (cursor.moveToNext()
+                        && SearchProvider.DEFAULT_SUGGESTION_RESULTS.moveToNext());
+            }
+        }
+
+        final List<SearchSuggestion> searchSuggestions = SearchSuggestionsDatabaseUtils
+                .getCachedSuggestions(mFacade.getDatabase(), query);
+
+        assertWithMessage("Suggestions should not be null")
+                .that(searchSuggestions)
+                .isNotNull();
+
+        assertWithMessage("Suggestions size is not as expected")
+                .that(searchSuggestions.size())
+                .isEqualTo(SearchProvider.DEFAULT_SUGGESTION_RESULTS.getCount());
+    }
+
+    @Test
+    public void testQuerySearchSuggestionsNonZeroState() {
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController).getCloudProvider();
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController)
+                .getCloudProviderOrDefault(any());
+        doReturn(mSearchState).when(mMockSyncController).getSearchState();
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any());
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any(), any());
+        doReturn(true).when(mSearchState).isCloudSearchEnabled(any());
+
+        final Bundle bundle = new Bundle();
+        bundle.putString("prefix", "x");
+        bundle.putStringArrayList("providers", new ArrayList<>(List.of(SearchProvider.AUTHORITY)));
+        final SearchSuggestionsQuery query = new SearchSuggestionsQuery(bundle);
+
+        // Async tasks are run synchronously during tests to make tests deterministic and prevent
+        // flaky test results.
+        final Executor currentThreadExecutor = Runnable::run;
+
+        try (Cursor cursor = PickerDataLayerV2.querySearchSuggestions(
+                mContext, bundle, currentThreadExecutor, null)) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(SearchProvider.DEFAULT_SUGGESTION_RESULTS.getCount());
+
+            final String projection = PickerSQLConstants.SearchSuggestionsResponseColumns
+                    .MEDIA_SET_ID.getProjection();
+            if (cursor.moveToFirst() && SearchProvider.DEFAULT_SUGGESTION_RESULTS.moveToFirst()) {
+                do {
+                    assertWithMessage("Media ID is not as expected")
+                            .that(cursor.getString(cursor.getColumnIndexOrThrow(projection)))
+                            .isEqualTo(SearchProvider.DEFAULT_SUGGESTION_RESULTS.getString(
+                                    SearchProvider.DEFAULT_SUGGESTION_RESULTS
+                                            .getColumnIndexOrThrow(projection)));
+                } while (cursor.moveToNext()
+                        && SearchProvider.DEFAULT_SUGGESTION_RESULTS.moveToNext());
+            }
+        }
+
+        final List<SearchSuggestion> searchSuggestions = SearchSuggestionsDatabaseUtils
+                .getCachedSuggestions(mFacade.getDatabase(), query);
+
+        assertWithMessage("Suggestions should not be null")
+                .that(searchSuggestions)
+                .isNotNull();
+
+        assertWithMessage("Suggestions size is not as expected")
+                .that(searchSuggestions.size())
+                .isEqualTo(0);
+    }
+
+    @Test
+    public void testQuerySearchSuggestionsWithHistory() {
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController).getCloudProvider();
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController)
+                .getCloudProviderOrDefault(any());
+        doReturn(mSearchState).when(mMockSyncController).getSearchState();
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any());
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any(), any());
+        doReturn(true).when(mSearchState).isCloudSearchEnabled(any());
+
+        final Bundle bundle = new Bundle();
+        bundle.putString("prefix", "");
+        bundle.putStringArrayList("providers", new ArrayList<>(List.of(SearchProvider.AUTHORITY)));
+        final SearchSuggestionsQuery query = new SearchSuggestionsQuery(bundle);
+
+        // Async tasks are run synchronously during tests to make tests deterministic and prevent
+        // flaky test results.
+        final Executor currentThreadExecutor = Runnable::run;
+
+        SearchSuggestionsDatabaseUtils.saveSearchHistory(
+                mFacade.getDatabase(),
+                new SearchTextRequest(null, "mountains"));
+
+        try (Cursor cursor = PickerDataLayerV2.querySearchSuggestions(
+                mContext, bundle, currentThreadExecutor, null)) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(SearchProvider.DEFAULT_SUGGESTION_RESULTS.getCount() + 1);
+
+            final String projection = PickerSQLConstants.SearchSuggestionsResponseColumns
+                    .MEDIA_SET_ID.getProjection();
+
+            cursor.moveToFirst();
+            assertWithMessage("Media ID is not as expected")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(projection)))
+                    .isNull();
+
+            if (cursor.moveToNext() && SearchProvider.DEFAULT_SUGGESTION_RESULTS.moveToFirst()) {
+                do {
+                    assertWithMessage("Media ID is not as expected")
+                            .that(cursor.getString(cursor.getColumnIndexOrThrow(projection)))
+                            .isEqualTo(SearchProvider.DEFAULT_SUGGESTION_RESULTS.getString(
+                                    SearchProvider.DEFAULT_SUGGESTION_RESULTS
+                                            .getColumnIndexOrThrow(projection)));
+                } while (cursor.moveToNext()
+                        && SearchProvider.DEFAULT_SUGGESTION_RESULTS.moveToNext());
+            }
+        }
+    }
+
+    @Test
+    public void testHandleNewSearchRequest() {
+        doReturn(true).when(mMockSyncController).shouldQueryLocalMediaForSearch(any());
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMediaForSearch(any(), any());
+        doReturn(mMockOperation).when(mMockWorkManager)
+                .enqueueUniqueWork(anyString(), any(ExistingWorkPolicy.class),
+                        any(OneTimeWorkRequest.class));
+        doReturn(mMockFuture).when(mMockOperation).getResult();
+
+        final String searchText = "volcano";
+        final Bundle extras = getCreateSearchRequestExtras(new SearchTextRequest(null, searchText));
+        final Executor currentThreadExecutor = Runnable::run;
+
+        final Bundle result = PickerDataLayerV2.handleNewSearchRequest(
+                mMockContext, extras, currentThreadExecutor, mMockWorkManager);
+
+        // Assert that a new search request was created
+        assertThat(result).isNotNull();
+        assertThat(result.getInt("search_request_id")).isEqualTo(1);
+
+        // Assert that both local and cloud syncs were scheduled
+        verify(mMockWorkManager, times(2))
+                .enqueueUniqueWork(anyString(), any(ExistingWorkPolicy.class),
+                        any(OneTimeWorkRequest.class));
+
+        // Assert that search request was saved as search history in database
+        final List<SearchSuggestion> suggestions =
+                SearchSuggestionsDatabaseUtils.getHistorySuggestions(
+                        mFacade.getDatabase(),
+                        new SearchSuggestionsQuery("", new ArrayList<>()));
+        assertThat(suggestions.size()).isEqualTo(1);
+        assertThat(suggestions.get(0).getSearchText()).isEqualTo(searchText);
+    }
+
+    @Test
+    public void testTriggerMediaSetsSyncRequest() {
+        doReturn(true).when(mMockSyncController).shouldQueryLocalMediaSets(any());
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMediaSets(any(), any());
+        doReturn(mMockOperation).when(mMockWorkManager)
+                .enqueueUniqueWork(anyString(), any(ExistingWorkPolicy.class),
+                        any(OneTimeWorkRequest.class));
+        doReturn(mMockFuture).when(mMockOperation).getResult();
+
+        Bundle extras = new Bundle();
+        extras.putString("authority", SearchProvider.AUTHORITY);
+        extras.putStringArray("mime_types", new String[] { "image/*" });
+        extras.putString("category_id", "id");
+        extras.putStringArrayList("providers", new ArrayList<>(List.of(SearchProvider.AUTHORITY)));
+
+        PickerDataLayerV2.triggerMediaSetsSync(extras, mContext, mMockWorkManager);
+
+        // Assert that both local and cloud syncs were scheduled
+        verify(mMockWorkManager, times(1))
+                .enqueueUniqueWork(anyString(), any(ExistingWorkPolicy.class),
+                        any(OneTimeWorkRequest.class));
+    }
+
+    @Test
+    public void testQueryCategoriesAndAlbums() {
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController).getCloudProvider();
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController)
+                .getCloudProviderOrDefault(any());
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any());
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any(), any());
+        doReturn(true).when(mCategoriesState).areCategoriesEnabled(any(), any());
+
+        final Cursor cursor1 = getLocalMediaCursor(LOCAL_ID_1, 0);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getCloudMediaCursor(CLOUD_ID_1, LOCAL_ID_1, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor2, 1);
+
+        try (Cursor cursor = PickerDataLayerV2.queryCategoriesAndAlbums(
+                mContext,
+                getMediaQueryExtras(Long.MAX_VALUE, Long.MAX_VALUE, 100,
+                        new ArrayList<>(Arrays.asList(LOCAL_PROVIDER, SearchProvider.AUTHORITY))),
+                /* cancellationSignal */ null)) {
+            assertWithMessage("Count of albums and categories")
+                    .that(cursor.getCount())
+                    .isEqualTo(5);
+
+            cursor.moveToFirst();
+            assertWithMessage("Unexpected media group")
+                    .that(MediaGroup.valueOf(
+                            cursor.getString(cursor.getColumnIndexOrThrow(
+                                    PickerSQLConstants.MediaGroupResponseColumns
+                                            .MEDIA_GROUP.getColumnName()))))
+                    .isEqualTo(MediaGroup.ALBUM);
+            assertWithMessage("Unexpected album id")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaGroupResponseColumns.GROUP_ID.getColumnName())))
+                    .isEqualTo(CloudMediaProviderContract.AlbumColumns.ALBUM_ID_FAVORITES);
+
+            cursor.moveToNext();
+            assertWithMessage("Unexpected media group")
+                    .that(MediaGroup.valueOf(
+                            cursor.getString(cursor.getColumnIndexOrThrow(
+                                    PickerSQLConstants.MediaGroupResponseColumns
+                                            .MEDIA_GROUP.getColumnName()))))
+                    .isEqualTo(MediaGroup.ALBUM);
+
+            assertWithMessage("Unexpected album id")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaGroupResponseColumns.GROUP_ID.getColumnName())))
+                    .isEqualTo(CloudMediaProviderContract.AlbumColumns.ALBUM_ID_CAMERA);
+
+            cursor.moveToNext();
+            // Assert that the next media groupd is people and pets category
+            assertWithMessage("Unexpected media group")
+                    .that(MediaGroup.valueOf(
+                            cursor.getString(cursor.getColumnIndexOrThrow(
+                                    PickerSQLConstants.MediaGroupResponseColumns
+                                            .MEDIA_GROUP.getColumnName()))))
+                    .isEqualTo(MediaGroup.CATEGORY);
+
+            cursor.moveToNext();
+            assertWithMessage("Unexpected media group")
+                    .that(MediaGroup.valueOf(
+                            cursor.getString(cursor.getColumnIndexOrThrow(
+                                    PickerSQLConstants.MediaGroupResponseColumns
+                                            .MEDIA_GROUP.getColumnName()))))
+                    .isEqualTo(MediaGroup.ALBUM);
+
+            assertWithMessage("Unexpected album id")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaGroupResponseColumns.GROUP_ID.getColumnName())))
+                    .isEqualTo(CloudMediaProviderContract.AlbumColumns.ALBUM_ID_VIDEOS);
+
+            cursor.moveToNext();
+            // Assert that the next media groupd is a cloud album
+            assertWithMessage("Unexpected media group")
+                    .that(MediaGroup.valueOf(
+                            cursor.getString(cursor.getColumnIndexOrThrow(
+                                    PickerSQLConstants.MediaGroupResponseColumns
+                                            .MEDIA_GROUP.getColumnName()))))
+                    .isEqualTo(MediaGroup.ALBUM);
+
+            final Uri coverUri = Uri.parse(
+                    cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaGroupResponseColumns
+                                    .UNWRAPPED_COVER_URI.getColumnName())));
+            assertWithMessage("Unexpected media group")
+                    .that(coverUri.getLastPathSegment())
+                    .isEqualTo(LOCAL_ID_1);
+        }
+    }
+
+    private static Bundle getCreateSearchRequestExtras(SearchTextRequest searchTextRequest) {
+        final Bundle bundle = new Bundle();
+        bundle.putString("search_text", searchTextRequest.getSearchText());
+        bundle.putStringArrayList("providers", new ArrayList<>(List.of(SearchProvider.AUTHORITY)));
+        return bundle;
+    }
+
     private static void assertMediaCursor(Cursor cursor, String id, String authority,
             Long dateTaken, String mimeType) {
         assertMediaCursor(cursor, id, authority, dateTaken, mimeType,
diff --git a/tests/src/com/android/providers/media/photopicker/v2/PickerUriResolverV2Test.java b/tests/src/com/android/providers/media/photopicker/v2/PickerUriResolverV2Test.java
index 8b89795de..4c03b59e7 100644
--- a/tests/src/com/android/providers/media/photopicker/v2/PickerUriResolverV2Test.java
+++ b/tests/src/com/android/providers/media/photopicker/v2/PickerUriResolverV2Test.java
@@ -25,33 +25,46 @@ import org.junit.Test;
 public class PickerUriResolverV2Test {
     @Test
     public void testMediaQuery() {
-        assertEquals(PickerUriResolverV2.sUriMatcher.match(
-                Uri.parse("content://media/picker_internal/v2/media")),
-                PickerUriResolverV2.PICKER_INTERNAL_MEDIA
+        assertEquals(
+                PickerUriResolverV2.PICKER_INTERNAL_MEDIA,
+                PickerUriResolverV2.sUriMatcher.match(
+                        Uri.parse("content://media/picker_internal/v2/media"))
         );
     }
 
     @Test
     public void testAlbumQuery() {
-        assertEquals(PickerUriResolverV2.sUriMatcher.match(
-                Uri.parse("content://media/picker_internal/v2/album")),
-                PickerUriResolverV2.PICKER_INTERNAL_ALBUM
+        assertEquals(
+                PickerUriResolverV2.PICKER_INTERNAL_ALBUM,
+                PickerUriResolverV2.sUriMatcher.match(
+                        Uri.parse("content://media/picker_internal/v2/album"))
         );
     }
 
     @Test
     public void testAlbumContentQuery() {
-        assertEquals(PickerUriResolverV2.sUriMatcher.match(
-                Uri.parse("content://media/picker_internal/v2/album/album_id")),
-                PickerUriResolverV2.PICKER_INTERNAL_ALBUM_CONTENT
+        assertEquals(
+                PickerUriResolverV2.PICKER_INTERNAL_ALBUM_CONTENT,
+                PickerUriResolverV2.sUriMatcher.match(
+                        Uri.parse("content://media/picker_internal/v2/album/album_id"))
         );
     }
 
     @Test
     public void testAvailableProvidersQuery() {
-        assertEquals(PickerUriResolverV2.sUriMatcher.match(
-                Uri.parse("content://media/picker_internal/v2/available_providers")),
-                PickerUriResolverV2.PICKER_INTERNAL_AVAILABLE_PROVIDERS
+        assertEquals(
+                PickerUriResolverV2.PICKER_INTERNAL_AVAILABLE_PROVIDERS,
+                PickerUriResolverV2.sUriMatcher.match(
+                        Uri.parse("content://media/picker_internal/v2/available_providers"))
+        );
+    }
+
+    @Test
+    public void testSearchResultsQuery() {
+        assertEquals(
+                PickerUriResolverV2.PICKER_INTERNAL_SEARCH_MEDIA,
+                PickerUriResolverV2.sUriMatcher.match(
+                        Uri.parse("content://media/picker_internal/v2/search_media/132"))
         );
     }
 }
diff --git a/tests/src/com/android/providers/media/photopicker/v2/SearchSuggestionsProviderTest.java b/tests/src/com/android/providers/media/photopicker/v2/SearchSuggestionsProviderTest.java
new file mode 100644
index 000000000..adc000bd1
--- /dev/null
+++ b/tests/src/com/android/providers/media/photopicker/v2/SearchSuggestionsProviderTest.java
@@ -0,0 +1,288 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2;
+
+import static android.provider.CloudMediaProviderContract.SEARCH_SUGGESTION_ALBUM;
+import static android.provider.CloudMediaProviderContract.SEARCH_SUGGESTION_HISTORY;
+import static android.provider.CloudMediaProviderContract.SEARCH_SUGGESTION_FACE;
+
+import static com.android.providers.media.photopicker.PickerSyncController.LOCAL_PICKER_PROVIDER_AUTHORITY;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.MockitoAnnotations.initMocks;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.os.Bundle;
+import android.platform.test.annotations.EnableFlags;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.test.platform.app.InstrumentationRegistry;
+
+import com.android.providers.media.cloudproviders.SearchProvider;
+import com.android.providers.media.flags.Flags;
+import com.android.providers.media.photopicker.PickerSyncController;
+import com.android.providers.media.photopicker.SearchState;
+import com.android.providers.media.photopicker.data.PickerDatabaseHelper;
+import com.android.providers.media.photopicker.data.PickerDbFacade;
+import com.android.providers.media.photopicker.sync.PickerSyncLockManager;
+import com.android.providers.media.photopicker.v2.model.SearchSuggestion;
+import com.android.providers.media.photopicker.v2.sqlite.PickerSQLConstants;
+import com.android.providers.media.photopicker.v2.sqlite.SearchSuggestionsDatabaseUtils;
+import com.android.providers.media.photopicker.v2.sqlite.SearchSuggestionsQuery;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+
+@EnableFlags(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+public class SearchSuggestionsProviderTest {
+    @Mock
+    private PickerSyncController mMockSyncController;
+    @Mock
+    private SearchState mSearchState;
+    private Context mContext;
+    private SQLiteDatabase mDatabase;
+    private PickerDbFacade mFacade;
+
+    @Before
+    public void setup() {
+        initMocks(this);
+
+        mContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+        PickerSyncController.setInstance(mMockSyncController);
+
+        final File dbPath = mContext.getDatabasePath(PickerDatabaseHelper.PICKER_DATABASE_NAME);
+        dbPath.delete();
+        final PickerDatabaseHelper helper = new PickerDatabaseHelper(mContext);
+        mDatabase = helper.getWritableDatabase();
+        mFacade = new PickerDbFacade(
+                mContext, new PickerSyncLockManager(), LOCAL_PICKER_PROVIDER_AUTHORITY);
+        mFacade.setCloudProvider(SearchProvider.AUTHORITY);
+
+        doReturn(LOCAL_PICKER_PROVIDER_AUTHORITY).when(mMockSyncController).getLocalProvider();
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController).getCloudProvider();
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController)
+                .getCloudProviderOrDefault(any());
+        doReturn(mFacade).when(mMockSyncController).getDbFacade();
+        doReturn(mSearchState).when(mMockSyncController).getSearchState();
+        doReturn(new PickerSyncLockManager()).when(mMockSyncController).getPickerSyncLockManager();
+    }
+
+    @Test
+    public void testCacheSearchSuggestionsNonZeroState() {
+        final SearchSuggestionsQuery query = new SearchSuggestionsQuery(getQueryArgs("x"));
+        final SearchSuggestion suggestion = new SearchSuggestion(
+                "search-text",
+                "media-set-id",
+                "authority",
+                SEARCH_SUGGESTION_ALBUM,
+                null);
+
+        final boolean result = SearchSuggestionsProvider
+                .maybeCacheSearchSuggestions(query, List.of(suggestion));
+
+        assertThat(result).isFalse();
+    }
+
+    @Test
+    public void testCacheEmptySearchSuggestions() {
+        final SearchSuggestionsQuery query = new SearchSuggestionsQuery(getQueryArgs(""));
+
+        final boolean result = SearchSuggestionsProvider
+                .maybeCacheSearchSuggestions(query, List.of());
+
+        assertThat(result).isFalse();
+    }
+
+    @Test
+    public void testCacheSearchSuggestions() {
+        final SearchSuggestionsQuery query = new SearchSuggestionsQuery(getQueryArgs(""));
+        final String mediaSetId = "media-set-id";
+        final SearchSuggestion suggestion = new SearchSuggestion(
+                "search-text",
+                mediaSetId,
+                SearchProvider.AUTHORITY,
+                SEARCH_SUGGESTION_ALBUM,
+                null);
+
+        final boolean result = SearchSuggestionsProvider
+                .maybeCacheSearchSuggestions(query, List.of(suggestion));
+
+        assertThat(result).isTrue();
+
+        final List<SearchSuggestion> searchSuggestionsResult =
+                SearchSuggestionsDatabaseUtils.getCachedSuggestions(mDatabase, query);
+
+        assertWithMessage("Search suggestions should not be null")
+                .that(searchSuggestionsResult)
+                .isNotNull();
+
+        assertWithMessage("Search suggestions size is not as expected")
+                .that(searchSuggestionsResult.size())
+                .isEqualTo(1);
+
+        assertWithMessage("Search suggestion media set id is not as expected")
+                .that(searchSuggestionsResult.get(0).getMediaSetId())
+                .isEqualTo(mediaSetId);
+    }
+
+    @Test
+    public void testSuggestionsToCursor() {
+        final String authority = "authority";
+        final SearchSuggestion albumSuggestion = new SearchSuggestion(
+                "album",
+                "album-set-id",
+                authority,
+                SEARCH_SUGGESTION_ALBUM,
+                null);
+        final SearchSuggestion faceSuggestion = new SearchSuggestion(
+                null,
+                "face-set-id",
+                authority,
+                SEARCH_SUGGESTION_FACE,
+                "id");
+        final SearchSuggestion historySuggestion = new SearchSuggestion(
+                "history",
+                null,
+                null,
+                SEARCH_SUGGESTION_HISTORY,
+                null);
+
+        try (Cursor cursor = SearchSuggestionsProvider
+                .suggestionsToCursor(List.of(albumSuggestion, faceSuggestion, historySuggestion))) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(3);
+
+            cursor.moveToFirst();
+            assertWithMessage("Media ID is not as expected")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.SearchSuggestionsResponseColumns
+                                    .MEDIA_SET_ID.getProjection())))
+                    .isEqualTo("album-set-id");
+
+            cursor.moveToNext();
+            assertWithMessage("Media ID is not as expected")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.SearchSuggestionsResponseColumns
+                                    .MEDIA_SET_ID.getProjection())))
+                    .isEqualTo("face-set-id");
+
+            cursor.moveToNext();
+            assertWithMessage("Media ID is not as expected")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.SearchSuggestionsResponseColumns
+                                    .MEDIA_SET_ID.getProjection())))
+                    .isNull();
+        }
+    }
+
+    @Test
+    public void testSuggestionsFromCloudProvider() {
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any());
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any(), any());
+        doReturn(true).when(mSearchState).isCloudSearchEnabled(any());
+
+        final List<SearchSuggestion> searchSuggestions =
+                SearchSuggestionsProvider.getSuggestionsFromCloudProvider(
+                        mContext, new SearchSuggestionsQuery(getQueryArgs("")), null);
+
+        assertWithMessage("Suggestions should not be null")
+                .that(searchSuggestions)
+                .isNotNull();
+
+        assertWithMessage("Suggestions size is not as expected")
+                .that(searchSuggestions.size())
+                .isEqualTo(SearchProvider.DEFAULT_SUGGESTION_RESULTS.getCount());
+
+        SearchProvider.DEFAULT_SUGGESTION_RESULTS.moveToFirst();
+        for (int iterator = 0; iterator < searchSuggestions.size(); iterator++) {
+            assertWithMessage("Media ID is not as expected")
+                    .that(searchSuggestions.get(iterator).getMediaSetId())
+                    .isEqualTo(SearchProvider.DEFAULT_SUGGESTION_RESULTS.getString(
+                            SearchProvider.DEFAULT_SUGGESTION_RESULTS.getColumnIndexOrThrow(
+                                    PickerSQLConstants.SearchSuggestionsResponseColumns
+                                    .MEDIA_SET_ID.getProjection())));
+
+            SearchProvider.DEFAULT_SUGGESTION_RESULTS.moveToNext();
+        }
+    }
+
+    @Test
+    public void testSuggestionsFromInactiveCloudProvider() {
+        doReturn(false).when(mMockSyncController).shouldQueryCloudMedia(any());
+        doReturn(false).when(mMockSyncController).shouldQueryCloudMedia(any(), any());
+        doReturn(true).when(mSearchState).isCloudSearchEnabled(any());
+
+        final List<SearchSuggestion> searchSuggestions =
+                SearchSuggestionsProvider.getSuggestionsFromCloudProvider(
+                        mContext, new SearchSuggestionsQuery(getQueryArgs("")), null);
+
+        assertWithMessage("Suggestions should not be null")
+                .that(searchSuggestions)
+                .isNotNull();
+
+        assertWithMessage("Suggestions size is not as expected")
+                .that(searchSuggestions.size())
+                .isEqualTo(0);
+    }
+
+    @Test
+    public void testSuggestionsFromCloudProviderWithSearchDisabled() {
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any());
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any(), any());
+        doReturn(false).when(mSearchState).isCloudSearchEnabled(any());
+
+        final List<SearchSuggestion> searchSuggestions =
+                SearchSuggestionsProvider.getSuggestionsFromCloudProvider(
+                        mContext, new SearchSuggestionsQuery(getQueryArgs("")), null);
+
+        assertWithMessage("Suggestions should not be null")
+                .that(searchSuggestions)
+                .isNotNull();
+
+        assertWithMessage("Suggestions size is not as expected")
+                .that(searchSuggestions.size())
+                .isEqualTo(0);
+    }
+
+    private Bundle getQueryArgs(@Nullable String prefix) {
+        return getQueryArgs(prefix, new ArrayList<>(List.of(SearchProvider.AUTHORITY)));
+    }
+
+    private Bundle getQueryArgs(@Nullable String prefix, @NonNull ArrayList<String> providers) {
+        final Bundle bundle = new Bundle();
+        bundle.putString("prefix", prefix);
+        bundle.putStringArrayList("providers", providers);
+        return bundle;
+    }
+}
diff --git a/tests/src/com/android/providers/media/photopicker/v2/sqlite/MediaGroupCursorUtilsTest.java b/tests/src/com/android/providers/media/photopicker/v2/sqlite/MediaGroupCursorUtilsTest.java
new file mode 100644
index 000000000..238e1f72a
--- /dev/null
+++ b/tests/src/com/android/providers/media/photopicker/v2/sqlite/MediaGroupCursorUtilsTest.java
@@ -0,0 +1,180 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2;
+
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.CLOUD_ID_1;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.LOCAL_ID_1;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.LOCAL_ID_2;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.LOCAL_PROVIDER;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.assertAddMediaOperation;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.getCloudMediaCursor;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.getLocalMediaCursor;
+
+import static com.google.common.truth.Truth.assertWithMessage;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.MockitoAnnotations.initMocks;
+
+import android.content.Context;
+import android.database.Cursor;
+
+import androidx.test.InstrumentationRegistry;
+
+import com.android.providers.media.cloudproviders.SearchProvider;
+import com.android.providers.media.photopicker.PickerSyncController;
+import com.android.providers.media.photopicker.data.PickerDatabaseHelper;
+import com.android.providers.media.photopicker.data.PickerDbFacade;
+import com.android.providers.media.photopicker.sync.PickerSyncLockManager;
+import com.android.providers.media.photopicker.v2.sqlite.MediaGroupCursorUtils;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+
+import java.io.File;
+import java.util.List;
+import java.util.Map;
+
+public class MediaGroupCursorUtilsTest {
+    @Mock
+    private PickerSyncController mMockSyncController;
+    private PickerDbFacade mFacade;
+    private Context mContext;
+
+    @Before
+    public void setUp() {
+        initMocks(this);
+        PickerSyncController.setInstance(mMockSyncController);
+        mContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+        File dbPath = mContext.getDatabasePath(PickerDatabaseHelper.PICKER_DATABASE_NAME);
+        dbPath.delete();
+        mFacade = new PickerDbFacade(mContext, new PickerSyncLockManager(), LOCAL_PROVIDER);
+        mFacade.setCloudProvider(SearchProvider.AUTHORITY);
+
+        doReturn(mFacade).when(mMockSyncController).getDbFacade();
+        doReturn(LOCAL_PROVIDER).when(mMockSyncController).getLocalProvider();
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController).getCloudProvider();
+        doReturn(SearchProvider.AUTHORITY).when(mMockSyncController)
+                .getCloudProviderOrDefault(any());
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any());
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any(), any());
+    }
+
+    @After
+    public void tearDown() {
+        if (mFacade != null) {
+            mFacade.setCloudProvider(null);
+        }
+    }
+
+    @Test
+    public void testGetLocalIdForCloudUri() {
+        final Cursor cursor1 = getLocalMediaCursor(LOCAL_ID_1, 0);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getCloudMediaCursor(CLOUD_ID_1, LOCAL_ID_1, 0);
+        assertAddMediaOperation(mFacade, SearchProvider.AUTHORITY, cursor2, 1);
+        final Cursor cursor3 = getLocalMediaCursor(LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor3, 1);
+
+        final List<String> mediaUris = List.of(
+                "content://" + SearchProvider.AUTHORITY + "/" + CLOUD_ID_1,
+                "content://" + LOCAL_PROVIDER + "/" + LOCAL_ID_1
+        );
+
+        final Map<String, String> result = MediaGroupCursorUtils.getLocalIds(mediaUris);
+
+        assertWithMessage("Result map should not be null")
+                .that(result)
+                .isNotNull();
+        assertWithMessage("Result map size is not as expected")
+                .that(result.size())
+                .isEqualTo(1);
+        assertWithMessage("Result map should contain cloud id as key")
+                .that(result.containsKey(CLOUD_ID_1))
+                .isTrue();
+        assertWithMessage("Mapped local id is incorrect")
+                .that(result.get(CLOUD_ID_1))
+                .isEqualTo(LOCAL_ID_1);
+    }
+
+    @Test
+    public void testGetLocalIdForCloudUriNoMatch() {
+        final Cursor cursor1 = getLocalMediaCursor(LOCAL_ID_1, 0);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getCloudMediaCursor(CLOUD_ID_1, /* localId */ null, 0);
+        assertAddMediaOperation(mFacade, SearchProvider.AUTHORITY, cursor2, 1);
+        final Cursor cursor3 = getLocalMediaCursor(LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor3, 1);
+
+        final List<String> mediaUris = List.of(
+                "content://" + SearchProvider.AUTHORITY + "/" + CLOUD_ID_1
+        );
+
+        final Map<String, String> result = MediaGroupCursorUtils.getLocalIds(mediaUris);
+
+        assertWithMessage("Result map should not be null")
+                .that(result)
+                .isNotNull();
+        assertWithMessage("Result map size is not as expected")
+                .that(result.size())
+                .isEqualTo(0);
+    }
+
+    @Test
+    public void testGetValidLocalIdForCloudUri() {
+        final Cursor cursor1 = getLocalMediaCursor(LOCAL_ID_1, 0);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getCloudMediaCursor(CLOUD_ID_1, LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, SearchProvider.AUTHORITY, cursor2, 1);
+
+        final List<String> mediaUris = List.of(
+                "content://" + SearchProvider.AUTHORITY + "/" + CLOUD_ID_1
+        );
+
+        final Map<String, String> result = MediaGroupCursorUtils.getLocalIds(mediaUris);
+
+        assertWithMessage("Result map should not be null")
+                .that(result)
+                .isNotNull();
+        assertWithMessage("Result map size is not as expected")
+                .that(result.size())
+                .isEqualTo(0);
+    }
+
+    @Test
+    public void testGetValidLocalIdForEmptyUriList() {
+        final Cursor cursor1 = getLocalMediaCursor(LOCAL_ID_1, 0);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getCloudMediaCursor(CLOUD_ID_1, /* localId */ null, 0);
+        assertAddMediaOperation(mFacade, SearchProvider.AUTHORITY, cursor2, 1);
+        final Cursor cursor3 = getLocalMediaCursor(LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor3, 1);
+
+        final List<String> mediaUris = List.of();
+
+        final Map<String, String> result = MediaGroupCursorUtils.getLocalIds(mediaUris);
+
+        assertWithMessage("Result map should not be null")
+                .that(result)
+                .isNotNull();
+        assertWithMessage("Result map size is not as expected")
+                .that(result.size())
+                .isEqualTo(0);
+    }
+}
diff --git a/tests/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsDatabaseUtilTest.java b/tests/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsDatabaseUtilTest.java
new file mode 100644
index 000000000..b4eb2af3d
--- /dev/null
+++ b/tests/src/com/android/providers/media/photopicker/v2/sqlite/MediaInMediaSetsDatabaseUtilTest.java
@@ -0,0 +1,623 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.sqlite;
+
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.CLOUD_ID_1;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.CLOUD_ID_2;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.CLOUD_ID_3;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.CLOUD_PROVIDER;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.DATE_TAKEN_MS;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.GENERATION_MODIFIED;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.GIF_IMAGE_MIME_TYPE;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.JPEG_IMAGE_MIME_TYPE;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.LOCAL_ID_1;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.LOCAL_ID_2;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.LOCAL_ID_3;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.LOCAL_ID_4;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.LOCAL_PROVIDER;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.MP4_VIDEO_MIME_TYPE;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.PNG_IMAGE_MIME_TYPE;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.STANDARD_MIME_TYPE_EXTENSION;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.assertAddMediaOperation;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.getCloudMediaCursor;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.getLocalMediaCursor;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.getMediaCursor;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.toMediaStoreUri;
+
+import static com.google.common.truth.Truth.assertWithMessage;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.MockitoAnnotations.initMocks;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.os.Bundle;
+import android.provider.MediaStore;
+
+import androidx.test.platform.app.InstrumentationRegistry;
+
+import com.android.providers.media.photopicker.PickerSyncController;
+import com.android.providers.media.photopicker.data.PickerDatabaseHelper;
+import com.android.providers.media.photopicker.data.PickerDbFacade;
+import com.android.providers.media.photopicker.sync.PickerSyncLockManager;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class MediaInMediaSetsDatabaseUtilTest {
+
+    @Mock
+    private PickerSyncController mMockSyncController;
+    private SQLiteDatabase mDatabase;
+    private Context mContext;
+    private PickerDbFacade mFacade;
+
+    @Before
+    public void setUp() {
+        initMocks(this);
+        PickerSyncController.setInstance(mMockSyncController);
+        mContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+        File dbPath = mContext.getDatabasePath(PickerDatabaseHelper.PICKER_DATABASE_NAME);
+        dbPath.delete();
+        PickerDatabaseHelper helper = new PickerDatabaseHelper(mContext);
+        mDatabase = helper.getWritableDatabase();
+        mFacade = new PickerDbFacade(mContext, new PickerSyncLockManager(), LOCAL_PROVIDER);
+        mFacade.setCloudProvider(CLOUD_PROVIDER);
+        doReturn(mFacade).when(mMockSyncController).getDbFacade();
+        doReturn(LOCAL_PROVIDER).when(mMockSyncController).getLocalProvider();
+    }
+
+    @After
+    public void teardown() {
+        mDatabase.close();
+        File dbPath = mContext.getDatabasePath(PickerDatabaseHelper.PICKER_DATABASE_NAME);
+        dbPath.delete();
+    }
+
+    @Test
+    public void testQueryLocalMediaInMediaSet() {
+        final Cursor cursor1 = getLocalMediaCursor(LOCAL_ID_1, 0);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getLocalMediaCursor(LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor2, 1);
+        final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
+
+        String mediaSetPickerId = "mediaSetPickerId";
+
+        int cloudRowsInserted = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
+                mDatabase, List.of(
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, mediaSetPickerId)
+                ), CLOUD_PROVIDER
+        );
+        assertEquals(
+                "Number of rows inserted should be equal to the number of items in the cursor,",
+                /*expected*/cloudRowsInserted,
+                /*actual*/1);
+
+        int localRowsInserted = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
+                mDatabase, List.of(
+                        getContentValues(LOCAL_ID_1, null, mediaSetPickerId)
+                ), LOCAL_PROVIDER
+        );
+        assertEquals(
+                "Number of rows inserted is incorrect",
+                localRowsInserted,
+                1);
+
+        Bundle extras = new Bundle();
+        extras.putInt("page_size", 100);
+        extras.putStringArrayList("providers",
+                new ArrayList<>(Arrays.asList(LOCAL_PROVIDER, CLOUD_PROVIDER)));
+        extras.putString("intent_action", MediaStore.ACTION_PICK_IMAGES);
+        MediaInMediaSetsQuery mediaInMediaSetQuery = new MediaInMediaSetsQuery(
+                extras, mediaSetPickerId);
+        Cursor mediaCursor = MediaInMediaSetsDatabaseUtil.queryMediaInMediaSet(
+                mMockSyncController, mediaInMediaSetQuery, LOCAL_PROVIDER, CLOUD_PROVIDER);
+        assertNotNull(mediaCursor);
+        assertEquals(mediaCursor.getCount(), 2);
+
+        mediaCursor.moveToFirst();
+
+        assertWithMessage("Media ID is not as expected in the search results")
+                .that(mediaCursor.getString(mediaCursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                .isEqualTo(LOCAL_ID_2);
+        mediaCursor.moveToNext();
+
+        assertWithMessage("Media ID is not as expected in the search results")
+                .that(mediaCursor.getString(mediaCursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                .isEqualTo(LOCAL_ID_1);
+        mediaCursor.moveToNext();
+    }
+
+    @Test
+    public void testQueryCloudMediaInMediaSet() {
+        final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor2, 1);
+        final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_3, LOCAL_ID_3, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
+
+        String mediaSetPickerId = "mediaSetPickerId";
+
+        final long cloudRowsInsertedCount = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
+                mDatabase, List.of(
+                        getContentValues(null, CLOUD_ID_3, mediaSetPickerId),
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, mediaSetPickerId),
+                        getContentValues(LOCAL_ID_1, CLOUD_ID_1, mediaSetPickerId)
+                ), CLOUD_PROVIDER);
+
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(cloudRowsInsertedCount)
+                .isEqualTo(3);
+
+        Bundle extras = new Bundle();
+        extras.putInt("page_size", 100);
+        extras.putStringArrayList("providers",
+                new ArrayList<>(Arrays.asList(LOCAL_PROVIDER, CLOUD_PROVIDER)));
+        extras.putString("intent_action", MediaStore.ACTION_PICK_IMAGES);
+        MediaInMediaSetsQuery mediaInMediaSetQuery = new MediaInMediaSetsQuery(
+                extras, mediaSetPickerId);
+        Cursor mediaCursor = MediaInMediaSetsDatabaseUtil.queryMediaInMediaSet(
+                mMockSyncController, mediaInMediaSetQuery, LOCAL_PROVIDER, CLOUD_PROVIDER);
+        assertNotNull(mediaCursor);
+        assertEquals(mediaCursor.getCount(), 3);
+
+        mediaCursor.moveToFirst();
+
+        assertWithMessage("Media ID is not as expected in the search results")
+                .that(mediaCursor.getString(mediaCursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                .isEqualTo(CLOUD_ID_3);
+        mediaCursor.moveToNext();
+
+        assertWithMessage("Media ID is not as expected in the search results")
+                .that(mediaCursor.getString(mediaCursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                .isEqualTo(CLOUD_ID_2);
+        mediaCursor.moveToNext();
+
+        assertWithMessage("Media ID is not as expected in the search results")
+                .that(mediaCursor.getString(mediaCursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                .isEqualTo(CLOUD_ID_1);
+    }
+
+    @Test
+    public void testQueryMediaInMediaSetForSpecificMediaSetPickerId() {
+        final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor2, 1);
+        final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_3, LOCAL_ID_3, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
+
+        String mediaSetPickerId1 = "ms1";
+        String mediaSetPickerId2 = "ms2";
+
+        final long cloudRowsInsertedCount = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
+                mDatabase, List.of(
+                        getContentValues(null, CLOUD_ID_3, mediaSetPickerId1),
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, mediaSetPickerId2),
+                        getContentValues(LOCAL_ID_1, CLOUD_ID_1, mediaSetPickerId2)
+                ), CLOUD_PROVIDER);
+
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(cloudRowsInsertedCount)
+                .isEqualTo(3);
+
+        Bundle extras = new Bundle();
+        extras.putInt("page_size", 100);
+        extras.putStringArrayList("providers",
+                new ArrayList<>(Arrays.asList(LOCAL_PROVIDER, CLOUD_PROVIDER)));
+        extras.putString("intent_action", MediaStore.ACTION_PICK_IMAGES);
+        MediaInMediaSetsQuery mediaInMediaSetQuery = new MediaInMediaSetsQuery(
+                extras, mediaSetPickerId2);
+        Cursor mediaCursor = MediaInMediaSetsDatabaseUtil.queryMediaInMediaSet(
+                mMockSyncController, mediaInMediaSetQuery, LOCAL_PROVIDER, CLOUD_PROVIDER);
+        assertNotNull(mediaCursor);
+        assertEquals(mediaCursor.getCount(), 2);
+
+        mediaCursor.moveToFirst();
+
+        assertWithMessage("Media ID is not as expected in the search results")
+                .that(mediaCursor.getString(mediaCursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                .isEqualTo(CLOUD_ID_2);
+        mediaCursor.moveToNext();
+
+        assertWithMessage("Media ID is not as expected in the search results")
+                .that(mediaCursor.getString(mediaCursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                .isEqualTo(CLOUD_ID_1);
+    }
+
+    @Test
+    public void testQueryMediaInMediaSetsSortOrder() {
+        final long dateTaken = 0L;
+
+        final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, dateTaken + 1);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, dateTaken);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor2, 1);
+        final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_3, LOCAL_ID_3, dateTaken - 1);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
+        final Cursor cursor4 = getLocalMediaCursor(LOCAL_ID_4, dateTaken);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor4, 1);
+
+        String mediaSetPickerId = "mediaSetPickerId";
+
+        final long cloudRowsInsertedCount = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
+                mDatabase, List.of(
+                        getContentValues(null, CLOUD_ID_3, mediaSetPickerId),
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, mediaSetPickerId),
+                        getContentValues(LOCAL_ID_1, CLOUD_ID_1, mediaSetPickerId)
+                ), CLOUD_PROVIDER);
+
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(cloudRowsInsertedCount)
+                .isEqualTo(3);
+
+        int localRowsInserted = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
+                mDatabase, List.of(
+                        getContentValues(LOCAL_ID_4, null, mediaSetPickerId)
+                ), LOCAL_PROVIDER
+        );
+        assertEquals(
+                "Number of rows inserted is incorrect",
+                localRowsInserted,
+                1);
+
+        Bundle extras = new Bundle();
+        extras.putInt("page_size", 100);
+        extras.putStringArrayList("providers",
+                new ArrayList<>(Arrays.asList(LOCAL_PROVIDER, CLOUD_PROVIDER)));
+        extras.putString("intent_action", MediaStore.ACTION_PICK_IMAGES);
+        MediaInMediaSetsQuery mediaInMediaSetQuery = new MediaInMediaSetsQuery(
+                extras, mediaSetPickerId);
+        Cursor mediaCursor = MediaInMediaSetsDatabaseUtil.queryMediaInMediaSet(
+                mMockSyncController, mediaInMediaSetQuery, LOCAL_PROVIDER, CLOUD_PROVIDER);
+        assertNotNull(mediaCursor);
+        assertEquals(mediaCursor.getCount(), 4);
+
+        mediaCursor.moveToFirst();
+
+        assertWithMessage("Media ID is not as expected in the search results")
+                .that(mediaCursor.getString(mediaCursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                .isEqualTo(CLOUD_ID_1);
+        mediaCursor.moveToNext();
+
+        assertWithMessage("Media ID is not as expected in the search results")
+                .that(mediaCursor.getString(mediaCursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                .isEqualTo(LOCAL_ID_4);
+        mediaCursor.moveToNext();
+
+        assertWithMessage("Media ID is not as expected in the search results")
+                .that(mediaCursor.getString(mediaCursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                .isEqualTo(CLOUD_ID_2);
+        mediaCursor.moveToNext();
+
+        assertWithMessage("Media ID is not as expected in the search results")
+                .that(mediaCursor.getString(mediaCursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                .isEqualTo(CLOUD_ID_3);
+    }
+
+    @Test
+    public void testQueryMediaInMediaSetsPagination() {
+        final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor2, 1);
+        final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_3, LOCAL_ID_3, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
+
+        String mediaSetPickerId = "mediaSetPickerId";
+
+        final long cloudRowsInsertedCount = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
+                mDatabase, List.of(
+                        getContentValues(null, CLOUD_ID_3, mediaSetPickerId),
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, mediaSetPickerId),
+                        getContentValues(LOCAL_ID_1, CLOUD_ID_1, mediaSetPickerId)
+                ), CLOUD_PROVIDER);
+
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(cloudRowsInsertedCount)
+                .isEqualTo(3);
+
+        Bundle extras = new Bundle();
+        extras.putInt("page_size", 2);
+        extras.putStringArrayList("providers",
+                new ArrayList<>(Arrays.asList(LOCAL_PROVIDER, CLOUD_PROVIDER)));
+        extras.putString("intent_action", MediaStore.ACTION_PICK_IMAGES);
+        MediaInMediaSetsQuery mediaInMediaSetQuery = new MediaInMediaSetsQuery(
+                extras, mediaSetPickerId);
+        Cursor mediaCursor = MediaInMediaSetsDatabaseUtil.queryMediaInMediaSet(
+                mMockSyncController, mediaInMediaSetQuery, LOCAL_PROVIDER, CLOUD_PROVIDER);
+        assertNotNull(mediaCursor);
+        assertEquals(mediaCursor.getCount(), 2);
+
+        mediaCursor.moveToFirst();
+
+        assertWithMessage("Media ID is not as expected in the search results")
+                .that(mediaCursor.getString(mediaCursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                .isEqualTo(CLOUD_ID_3);
+        mediaCursor.moveToNext();
+
+        assertWithMessage("Media ID is not as expected in the search results")
+                .that(mediaCursor.getString(mediaCursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                .isEqualTo(CLOUD_ID_2);
+        mediaCursor.moveToNext();
+    }
+
+    @Test
+    public void testQueryMediaInMediaSetsMimeTypeFilter() {
+        final Cursor cursor1 = getMediaCursor(CLOUD_ID_1, DATE_TAKEN_MS, GENERATION_MODIFIED,
+                /* mediaStoreUri */ null, /* sizeBytes */ 1, MP4_VIDEO_MIME_TYPE,
+                STANDARD_MIME_TYPE_EXTENSION, /* isFavorite */ false);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getMediaCursor(CLOUD_ID_2, DATE_TAKEN_MS, GENERATION_MODIFIED,
+                /* mediaStoreUri */ toMediaStoreUri(LOCAL_ID_2), /* sizeBytes */ 1,
+                PNG_IMAGE_MIME_TYPE, STANDARD_MIME_TYPE_EXTENSION, /* isFavorite */ false);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor2, 1);
+        final Cursor cursor3 = getMediaCursor(CLOUD_ID_3, DATE_TAKEN_MS, GENERATION_MODIFIED,
+                /* mediaStoreUri */ toMediaStoreUri(LOCAL_ID_3), /* sizeBytes */ 1,
+                GIF_IMAGE_MIME_TYPE, STANDARD_MIME_TYPE_EXTENSION, /* isFavorite */ false);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
+        final Cursor cursor4 = getMediaCursor(LOCAL_ID_4, DATE_TAKEN_MS, GENERATION_MODIFIED,
+                /* mediaStoreUri */ toMediaStoreUri(LOCAL_ID_4), /* sizeBytes */ 1,
+                JPEG_IMAGE_MIME_TYPE, STANDARD_MIME_TYPE_EXTENSION, /* isFavorite */ false);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor4, 1);
+
+        String mediaSetPickerId = "mediaSetPickerId";
+
+        final long cloudRowsInsertedCount = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
+                mDatabase, List.of(
+                        getContentValues(null, CLOUD_ID_3, mediaSetPickerId),
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, mediaSetPickerId),
+                        getContentValues(LOCAL_ID_1, CLOUD_ID_1, mediaSetPickerId)
+                ), CLOUD_PROVIDER);
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(cloudRowsInsertedCount)
+                .isEqualTo(3);
+
+        int localRowsInserted = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
+                mDatabase, List.of(
+                        getContentValues(LOCAL_ID_4, null, mediaSetPickerId)
+                ), LOCAL_PROVIDER
+        );
+        assertEquals(
+                "Number of rows inserted is incorrect",
+                localRowsInserted,
+                1);
+
+        Bundle extras = new Bundle();
+        extras.putInt("page_size", 100);
+        extras.putStringArrayList("providers",
+                new ArrayList<>(Arrays.asList(LOCAL_PROVIDER, CLOUD_PROVIDER)));
+        extras.putString("intent_action", MediaStore.ACTION_PICK_IMAGES);
+        extras.putStringArrayList("mime_types", new ArrayList<>(List.of("video/mp4", "image/gif")));
+        MediaInMediaSetsQuery mediaInMediaSetQuery = new MediaInMediaSetsQuery(
+                extras, mediaSetPickerId);
+        Cursor mediaCursor = MediaInMediaSetsDatabaseUtil.queryMediaInMediaSet(
+                mMockSyncController, mediaInMediaSetQuery, LOCAL_PROVIDER, CLOUD_PROVIDER);
+        assertNotNull(mediaCursor);
+        assertEquals(mediaCursor.getCount(), 2);
+
+        mediaCursor.moveToFirst();
+
+        assertWithMessage("Media ID is not as expected in the search results")
+                .that(mediaCursor.getString(mediaCursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                .isEqualTo(CLOUD_ID_3);
+        mediaCursor.moveToNext();
+
+        assertWithMessage("Media ID is not as expected in the search results")
+                .that(mediaCursor.getString(mediaCursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                .isEqualTo(CLOUD_ID_1);
+        mediaCursor.moveToNext();
+    }
+
+    @Test
+    public void testQueryMediaInMediaSetsLocalProviderFilter() {
+        final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor2, 1);
+        final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_3, LOCAL_ID_3, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
+        final Cursor cursor4 = getLocalMediaCursor(LOCAL_ID_4, 0);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor4, 1);
+
+        String mediaSetPickerId = "mediaSetPickerId";
+
+        final long cloudRowsInsertedCount = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
+                mDatabase, List.of(
+                        getContentValues(null, CLOUD_ID_3, mediaSetPickerId),
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, mediaSetPickerId),
+                        getContentValues(LOCAL_ID_1, CLOUD_ID_1, mediaSetPickerId)
+                ), CLOUD_PROVIDER);
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(cloudRowsInsertedCount)
+                .isEqualTo(3);
+
+        int localRowsInserted = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
+                mDatabase, List.of(
+                        getContentValues(LOCAL_ID_4, null, mediaSetPickerId)
+                ), LOCAL_PROVIDER
+        );
+        assertEquals(
+                "Number of rows inserted is incorrect",
+                localRowsInserted,
+                1);
+
+        Bundle extras = new Bundle();
+        extras.putInt("page_size", 100);
+        extras.putStringArrayList("providers",
+                new ArrayList<>(Arrays.asList(LOCAL_PROVIDER)));
+        extras.putString("intent_action", MediaStore.ACTION_PICK_IMAGES);
+
+        MediaInMediaSetsQuery mediaInMediaSetQuery = new MediaInMediaSetsQuery(
+                extras, mediaSetPickerId);
+        Cursor mediaCursor = MediaInMediaSetsDatabaseUtil.queryMediaInMediaSet(
+                mMockSyncController, mediaInMediaSetQuery, LOCAL_PROVIDER, null);
+        assertNotNull(mediaCursor);
+        assertEquals(mediaCursor.getCount(), 1);
+
+        mediaCursor.moveToFirst();
+
+        assertWithMessage("Media ID is not as expected in the search results")
+                .that(mediaCursor.getString(mediaCursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                .isEqualTo(LOCAL_ID_4);
+    }
+
+    @Test
+    public void testQueryMediaInMediaSetsCloudProviderFilter() {
+        final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor2, 1);
+        final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_3, LOCAL_ID_3, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
+        final Cursor cursor4 = getLocalMediaCursor(LOCAL_ID_4, 0);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor4, 1);
+
+        String mediaSetPickerId = "mediaSetPickerId";
+
+        final long cloudRowsInsertedCount = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
+                mDatabase, List.of(
+                        getContentValues(null, CLOUD_ID_3, mediaSetPickerId),
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, mediaSetPickerId),
+                        getContentValues(LOCAL_ID_1, CLOUD_ID_1, mediaSetPickerId)
+                ), CLOUD_PROVIDER);
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(cloudRowsInsertedCount)
+                .isEqualTo(3);
+
+        int localRowsInserted = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
+                mDatabase, List.of(
+                        getContentValues(LOCAL_ID_4, null, mediaSetPickerId)
+                ), LOCAL_PROVIDER
+        );
+        assertEquals(
+                "Number of rows inserted is incorrect",
+                localRowsInserted,
+                1);
+
+        Bundle extras = new Bundle();
+        extras.putInt("page_size", 100);
+        extras.putStringArrayList("providers",
+                new ArrayList<>(Arrays.asList(CLOUD_PROVIDER)));
+        extras.putString("intent_action", MediaStore.ACTION_PICK_IMAGES);
+
+        MediaInMediaSetsQuery mediaInMediaSetQuery = new MediaInMediaSetsQuery(
+                extras, mediaSetPickerId);
+        Cursor mediaCursor = MediaInMediaSetsDatabaseUtil.queryMediaInMediaSet(
+                mMockSyncController, mediaInMediaSetQuery, null, CLOUD_PROVIDER);
+        assertNotNull(mediaCursor);
+        assertEquals(mediaCursor.getCount(), 3);
+
+        mediaCursor.moveToFirst();
+
+        assertWithMessage("Media ID is not as expected in the search results")
+                .that(mediaCursor.getString(mediaCursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                .isEqualTo(CLOUD_ID_3);
+        mediaCursor.moveToNext();
+
+        assertWithMessage("Media ID is not as expected in the search results")
+                .that(mediaCursor.getString(mediaCursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                .isEqualTo(CLOUD_ID_2);
+        mediaCursor.moveToNext();
+
+        assertWithMessage("Media ID is not as expected in the search results")
+                .that(mediaCursor.getString(mediaCursor.getColumnIndexOrThrow(
+                        PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                .isEqualTo(CLOUD_ID_1);
+        mediaCursor.moveToNext();
+    }
+
+    @Test
+    public void testCacheMediaInMediaSet() {
+        final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getLocalMediaCursor(LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor2, 1);
+        final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
+
+        String mediaSetPickerId = "mediaSetPickerId";
+
+        int cloudRowsInserted = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
+                mDatabase, List.of(
+                        getContentValues(null, CLOUD_ID_1, mediaSetPickerId),
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, mediaSetPickerId)
+                ), CLOUD_PROVIDER
+        );
+        assertEquals(
+                "Number of rows inserted is incorrect",
+                cloudRowsInserted,
+                2);
+
+        // Try to insert the item with same LOCAL_ID as before
+        int localRowsInserted = MediaInMediaSetsDatabaseUtil.cacheMediaOfMediaSet(
+                mDatabase, List.of(
+                        getContentValues(LOCAL_ID_2, null, mediaSetPickerId)
+                ), LOCAL_PROVIDER
+        );
+        assertEquals(
+                "Number of rows inserted is incorrect",
+                localRowsInserted,
+                1);
+    }
+
+    private ContentValues getContentValues(
+            String localId, String cloudId, String mediaSetPickerId) {
+        ContentValues contentValues = new ContentValues();
+        contentValues.put(
+                PickerSQLConstants.MediaInMediaSetsTableColumns.CLOUD_ID.getColumnName(), cloudId);
+        contentValues.put(
+                PickerSQLConstants.MediaInMediaSetsTableColumns.LOCAL_ID.getColumnName(), localId);
+        contentValues.put(
+                PickerSQLConstants.MediaInMediaSetsTableColumns.MEDIA_SETS_PICKER_ID
+                        .getColumnName(),
+                mediaSetPickerId);
+        return contentValues;
+    }
+}
diff --git a/tests/src/com/android/providers/media/photopicker/v2/sqlite/MediaSetsDatabaseUtilsTest.java b/tests/src/com/android/providers/media/photopicker/v2/sqlite/MediaSetsDatabaseUtilsTest.java
new file mode 100644
index 000000000..2aa00cbb4
--- /dev/null
+++ b/tests/src/com/android/providers/media/photopicker/v2/sqlite/MediaSetsDatabaseUtilsTest.java
@@ -0,0 +1,225 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.sqlite;
+
+import static com.google.common.truth.Truth.assertWithMessage;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.database.MatrixCursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.provider.CloudMediaProviderContract;
+import android.util.Pair;
+
+import androidx.test.platform.app.InstrumentationRegistry;
+
+import com.android.providers.media.photopicker.data.PickerDatabaseHelper;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class MediaSetsDatabaseUtilsTest {
+    private SQLiteDatabase mDatabase;
+    private Context mContext;
+    private final String mMediaSetId = "mediaSetId";
+    private final String mCategoryId = "categoryId";
+    private final String mAuthority = "auth";
+    private final String mMimeType = "img";
+    private final String mDisplayName = "name";
+    private final String mCoverId = "id";
+
+    @Before
+    public void setUp() {
+        mContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+        File dbPath = mContext.getDatabasePath(PickerDatabaseHelper.PICKER_DATABASE_NAME);
+        dbPath.delete();
+        PickerDatabaseHelper helper = new PickerDatabaseHelper(mContext);
+        mDatabase = helper.getWritableDatabase();
+    }
+
+    @After
+    public void teardown() {
+        mDatabase.close();
+        File dbPath = mContext.getDatabasePath(PickerDatabaseHelper.PICKER_DATABASE_NAME);
+        dbPath.delete();
+    }
+
+    @Test
+    public void testInsertMediaSetMetadataIntoMediaSetsTable() {
+        Cursor c = getCursorForMediaSetInsertionTest();
+        List<String> mimeTypes = new ArrayList<>();
+        mimeTypes.add(mMimeType);
+
+        int mediaSetsInserted = MediaSetsDatabaseUtil.cacheMediaSets(
+                mDatabase, c, mCategoryId, mAuthority, mimeTypes);
+        assertEquals("Count of inserted media sets should be equal to the cursor size",
+                /*expected*/ c.getCount(), /*actual*/ mediaSetsInserted);
+    }
+
+    @Test
+    public void testInsertMediaSetMetadataIntoMediaTableMimeTypeFilter() {
+        Cursor c = getCursorForMediaSetInsertionTest();
+        List<String> firstMimeTypeFilter = new ArrayList<>();
+        firstMimeTypeFilter.add("image/*");
+        firstMimeTypeFilter.add("video/*");
+
+        int firstInsertionCount = MediaSetsDatabaseUtil.cacheMediaSets(
+                mDatabase, c, mCategoryId, mAuthority, firstMimeTypeFilter);
+        assertEquals("Count of inserted media sets should be equal to the cursor size",
+                /*expected*/ c.getCount(), /*actual*/ firstInsertionCount);
+
+        // Reversing the order of the mimeTypeFilter.
+        // It should still be treated the same and should not be reinserted
+        List<String> secondMimeTypeFilter = new ArrayList<>();
+        secondMimeTypeFilter.add("video/*");
+        secondMimeTypeFilter.add("image/*");
+
+        int secondInsertionCount = MediaSetsDatabaseUtil.cacheMediaSets(
+                mDatabase, c, mCategoryId, mAuthority, secondMimeTypeFilter);
+        assertEquals("MediaSet metadata with same mimetype filters should not be inserted "
+                        + "again",
+                /*expected*/ 0, /*actual*/ secondInsertionCount);
+
+    }
+
+    @Test
+    public void testInsertMediaSetMetadataWhenMediaSetIdIsNull() {
+        List<String> mimeTypes = new ArrayList<>();
+        mimeTypes.add(mMimeType);
+
+        String[] columns = new String[]{
+                CloudMediaProviderContract.MediaSetColumns.ID,
+                CloudMediaProviderContract.MediaSetColumns.DISPLAY_NAME,
+                CloudMediaProviderContract.MediaSetColumns.MEDIA_COVER_ID
+        };
+
+        MatrixCursor cursor = new MatrixCursor(columns);
+        cursor.addRow(new Object[] { null, mDisplayName, mCoverId });
+
+        int mediaSetsInserted = MediaSetsDatabaseUtil.cacheMediaSets(
+                mDatabase, cursor, mCategoryId, mAuthority, mimeTypes);
+        assertEquals("Count of inserted media sets should be 0 when the mediaSetId is null",
+                /*expected*/0, /*actual*/ mediaSetsInserted);
+    }
+
+    @Test
+    public void testGetMediaSetMetadataForCategory() {
+        Cursor c = getCursorForMediaSetInsertionTest();
+        List<String> mimeTypes = new ArrayList<>();
+        mimeTypes.add(mMimeType);
+
+        long insertResult = MediaSetsDatabaseUtil.cacheMediaSets(
+                mDatabase, c, mCategoryId, mAuthority, mimeTypes);
+        // Assert successful insertion
+        assertWithMessage("MediaSet metadata insertion failed")
+                .that(insertResult)
+                .isAtLeast(/* expected min row id */ 0);
+
+        Cursor mediaSetCursor = MediaSetsDatabaseUtil.getMediaSetsForCategory(
+                mDatabase, mCategoryId, mAuthority, mimeTypes);
+        assertNotNull(mediaSetCursor);
+        assertWithMessage("Cursor size should be greater than 0. Expected size: 1")
+                .that(mediaSetCursor.getCount())
+                .isEqualTo(1);
+        if (mediaSetCursor.moveToFirst()) {
+            int mediaSetIdIndex = mediaSetCursor.getColumnIndex(PickerSQLConstants
+                    .MediaSetsTableColumns.MEDIA_SET_ID.getColumnName());
+            String retrievedMediaSetId = mediaSetCursor.getString(mediaSetIdIndex);
+            assertEquals(mMediaSetId, retrievedMediaSetId);
+        }
+    }
+
+    @Test
+    public void testUpdateAndGetMediaInMediaSetResumeKey() {
+        Cursor c = getCursorForMediaSetInsertionTest();
+        List<String> mimeTypes = new ArrayList<>();
+        mimeTypes.add(mMimeType);
+
+        long mediaSetsInserted = MediaSetsDatabaseUtil.cacheMediaSets(
+                mDatabase, c, mCategoryId, mAuthority, mimeTypes);
+        // Assert successful insertion
+        assertEquals("Count of inserted media sets should be equal to the cursor size",
+                /*expected*/ c.getCount(), /*actual*/ mediaSetsInserted);
+        Cursor fetchMediaSetCursor = MediaSetsDatabaseUtil.getMediaSetsForCategory(
+                mDatabase, mCategoryId, mAuthority, mimeTypes);
+        String mediaSetPickerId = "";
+        if (fetchMediaSetCursor.moveToFirst()) {
+            mediaSetPickerId = fetchMediaSetCursor.getString(
+                    fetchMediaSetCursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaSetsTableColumns.PICKER_ID.getColumnName()));
+        }
+
+        String resumeKey = "resume";
+        MediaSetsDatabaseUtil.updateMediaInMediaSetSyncResumeKey(
+                mDatabase, mediaSetPickerId, resumeKey);
+        String retrievedMediaSetResumeKey = MediaSetsDatabaseUtil.getMediaResumeKey(
+                mDatabase, mediaSetPickerId);
+        assertNotNull(retrievedMediaSetResumeKey);
+        assertWithMessage("Retrieved mediaSetResumeKey did not match")
+                .that(retrievedMediaSetResumeKey)
+                .isEqualTo(resumeKey);
+    }
+
+    @Test
+    public void testGetMediaSetIdAndMimeTypesUsingMediaSetPickerId() {
+        Cursor c = getCursorForMediaSetInsertionTest();
+        List<String> mimeTypes = new ArrayList<>();
+        mimeTypes.add(mMimeType);
+
+        long mediaSetsInserted = MediaSetsDatabaseUtil.cacheMediaSets(
+                mDatabase, c, mCategoryId, mAuthority, mimeTypes);
+        // Assert successful insertion
+        assertEquals("Count of inserted media sets should be equal to the cursor size",
+                /*expected*/ c.getCount(), /*actual*/ mediaSetsInserted);
+        Cursor fetchMediaSetCursor = MediaSetsDatabaseUtil.getMediaSetsForCategory(
+                mDatabase, mCategoryId, mAuthority, mimeTypes);
+        String mediaSetPickerId = "";
+        if (fetchMediaSetCursor.moveToFirst()) {
+            mediaSetPickerId = fetchMediaSetCursor.getString(
+                    fetchMediaSetCursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaSetsTableColumns.PICKER_ID.getColumnName()));
+        }
+
+        Pair<String, String[]> retrievedData = MediaSetsDatabaseUtil
+                .getMediaSetIdAndMimeType(mDatabase, mediaSetPickerId);
+        assertEquals(/*expected*/retrievedData.first, /*actual*/mMediaSetId);
+        assertTrue(Arrays.toString(retrievedData.second).contains(mMimeType));
+    }
+
+    private Cursor getCursorForMediaSetInsertionTest() {
+        String[] columns = new String[]{
+                CloudMediaProviderContract.MediaSetColumns.ID,
+                CloudMediaProviderContract.MediaSetColumns.DISPLAY_NAME,
+                CloudMediaProviderContract.MediaSetColumns.MEDIA_COVER_ID
+        };
+
+        MatrixCursor cursor = new MatrixCursor(columns);
+        cursor.addRow(new Object[] { mMediaSetId, mDisplayName, mCoverId });
+
+        return cursor;
+    }
+}
diff --git a/tests/src/com/android/providers/media/photopicker/v2/sqlite/SearchRequestDatabaseUtilTest.java b/tests/src/com/android/providers/media/photopicker/v2/sqlite/SearchRequestDatabaseUtilTest.java
new file mode 100644
index 000000000..dcbf6fc09
--- /dev/null
+++ b/tests/src/com/android/providers/media/photopicker/v2/sqlite/SearchRequestDatabaseUtilTest.java
@@ -0,0 +1,389 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.sqlite;
+
+import static android.provider.CloudMediaProviderContract.SEARCH_SUGGESTION_LOCATION;
+import static android.provider.CloudMediaProviderContract.SEARCH_SUGGESTION_TEXT;
+
+import static com.google.common.truth.Truth.assertWithMessage;
+
+import android.content.Context;
+import android.database.sqlite.SQLiteDatabase;
+
+import androidx.test.platform.app.InstrumentationRegistry;
+
+import com.android.providers.media.photopicker.data.PickerDatabaseHelper;
+import com.android.providers.media.photopicker.v2.model.SearchRequest;
+import com.android.providers.media.photopicker.v2.model.SearchSuggestionRequest;
+import com.android.providers.media.photopicker.v2.model.SearchTextRequest;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.File;
+import java.util.List;
+
+public class SearchRequestDatabaseUtilTest {
+    private SQLiteDatabase mDatabase;
+    private Context mContext;
+
+    @Before
+    public void setUp() {
+        mContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+        File dbPath = mContext.getDatabasePath(PickerDatabaseHelper.PICKER_DATABASE_NAME);
+        dbPath.delete();
+        PickerDatabaseHelper helper = new PickerDatabaseHelper(mContext);
+        mDatabase = helper.getWritableDatabase();
+    }
+
+    @After
+    public void teardown() {
+        mDatabase.close();
+        File dbPath = mContext.getDatabasePath(PickerDatabaseHelper.PICKER_DATABASE_NAME);
+        dbPath.delete();
+    }
+
+    @Test
+    public void testInsertSearchTextRequest() {
+        final SearchTextRequest searchRequest = new SearchTextRequest(
+                /* mimeTypes */ null,
+                "mountains"
+        );
+
+        final long firstInsertResult =
+                SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest);
+        assertWithMessage("Insert search request failed")
+                .that(firstInsertResult)
+                .isAtLeast(/* minimum row id */ 0);
+
+        final long secondInsertResult =
+                SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest);
+        assertWithMessage("Second insert for same search request should fail silently")
+                .that(secondInsertResult)
+                .isEqualTo(/* failed to insert row on constraint conflict */ -1);
+    }
+
+    @Test
+    public void testInsertSearchSuggestionRequest() {
+        final SearchSuggestionRequest suggestionRequest = new SearchSuggestionRequest(
+                /* mimeTypes */ null,
+                "mountains",
+                "media-set-id",
+                "authority",
+                SEARCH_SUGGESTION_TEXT,
+                null
+        );
+
+        final long firstInsertResult =
+                SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, suggestionRequest);
+        assertWithMessage("Insert search request failed")
+                .that(firstInsertResult)
+                .isAtLeast(/* minimum row id */ 0);
+
+        final long secondInsertResult =
+                SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, suggestionRequest);
+        assertWithMessage("Second insert for same search request should fail silently")
+                .that(secondInsertResult)
+                .isEqualTo(/* failed to insert row on constraint conflict */ -1);
+    }
+
+    @Test
+    public void testInsertSearchRequestsWithSameQuery() {
+        // Insert a search text request with "mountains" search text. This insert should be
+        // successful.
+        final SearchTextRequest searchRequest1 = new SearchTextRequest(
+                /* mimeTypes */ null,
+                "mountains"
+        );
+
+        final long firstInsertResult =
+                SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest1);
+        assertWithMessage("Insert search request failed")
+                .that(firstInsertResult)
+                .isAtLeast(/* minimum row id */ 0);
+
+        // Insert search suggestion request with "mountains" search text. This insert should be
+        // successful.
+        final SearchSuggestionRequest searchRequest2 = new SearchSuggestionRequest(
+                /* mimeTypes */ null,
+                "mountains",
+                "media-set-id",
+                "authority",
+                SEARCH_SUGGESTION_TEXT,
+                null
+        );
+
+        final long secondInsertResult =
+                SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest2);
+        assertWithMessage("Insert search request failed")
+                .that(secondInsertResult)
+                .isAtLeast(/* minimum row id */ 0);
+
+        // Insert search text request with "Mountains" search text. This insert should be
+        // successful since search text is text sensitive.
+        final SearchTextRequest searchRequest3 = new SearchTextRequest(
+                /* mimeTypes */ null,
+                "Mountains"
+        );
+
+        final long thirdInsertResult =
+                SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest3);
+        assertWithMessage("Insert search request failed")
+                .that(thirdInsertResult)
+                .isAtLeast(/* minimum row id */ 0);
+
+        // Insert search text request with "mountains" search text but a different media set id
+        // than before. This insert should be successful since search text is text sensitive.
+        final SearchSuggestionRequest searchRequest4 = new SearchSuggestionRequest(
+                /* mimeTypes */ null,
+                "mountains",
+                "different-media-set-id",
+                "authority",
+                SEARCH_SUGGESTION_TEXT,
+                null
+        );
+
+        final long fourthInsertResult =
+                SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest4);
+        assertWithMessage("Insert search request failed")
+                .that(fourthInsertResult)
+                .isAtLeast(/* minimum row id */ 0);
+    }
+
+    @Test
+    public void testMimeTypeUniqueConstraintSearchRequest() {
+        SearchTextRequest request = new SearchTextRequest(
+                /* mimeTypes */ List.of("image/*", "video/*", "image/gif"),
+                /* searchText */ "volcano"
+        );
+
+        final long firstInsertResult =
+                SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, request);
+        assertWithMessage("Insert search request failed")
+                .that(firstInsertResult)
+                .isAtLeast(/* minimum row id */ 0);
+
+        request = new SearchTextRequest(
+                /* mimeTypes */ List.of("image/gif", "video/*", "image/*"),
+                /* searchText */ "volcano"
+        );
+        final long secondInsertResult =
+                SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, request);
+        assertWithMessage("Second insert for same search request should fail silently")
+                .that(secondInsertResult)
+                .isEqualTo(/* failed to insert row on constraint conflict */ -1);
+
+        request = new SearchTextRequest(
+                /* mimeTypes */ List.of("image/GIF", "Video/*", "IMAGE/*"),
+                /* searchText */ "volcano"
+        );
+        final long thirdInsertResult =
+                SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, request);
+        assertWithMessage("Third insert for same search request should fail silently")
+                .that(thirdInsertResult)
+                .isEqualTo(/* failed to insert row on constraint conflict */ -1);
+    }
+
+    @Test
+    public void testGetSearchRequestID() {
+        SearchTextRequest searchRequest = new SearchTextRequest(
+                /* mimeTypes */ null,
+                "mountains"
+        );
+        assertWithMessage("Search request should not exist in database yet")
+                .that(SearchRequestDatabaseUtil.getSearchRequestID(mDatabase, searchRequest))
+                .isEqualTo(/* expectedRequestID */ -1);
+
+
+        final long firstInsertResult =
+                SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest);
+        assertWithMessage("Insert search request failed")
+                .that(firstInsertResult)
+                .isAtLeast(/* minimum row id */ 0);
+
+        assertWithMessage("Search request ID should exist in DB")
+                .that(SearchRequestDatabaseUtil.getSearchRequestID(mDatabase, searchRequest))
+                .isAtLeast(0);
+
+        searchRequest = new SearchTextRequest(
+                /* mimeTypes */ List.of("image/*"),
+                "mountains"
+        );
+        assertWithMessage("Search request should not exist in database for the given mime types")
+                .that(SearchRequestDatabaseUtil.getSearchRequestID(mDatabase, searchRequest))
+                .isEqualTo(/* expectedRequestID */ -1);
+    }
+
+    @Test
+    public void testGetSearchTextRequestDetails() {
+        final List<String> mimeTypes = List.of("video/mp4", "image/*", "image/gif");
+        final String searchText = "mountains";
+        final String resumeKey = "RANDOM_RESUME_KEY";
+        SearchTextRequest searchRequest = new SearchTextRequest(
+                mimeTypes,
+                searchText,
+                resumeKey
+        );
+
+        // Insert a search request
+        final long insertResult =
+                SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest);
+        assertWithMessage("Insert search request failed")
+                .that(insertResult)
+                .isAtLeast(/* minimum row id */ 0);
+
+        // Get search request ID
+        final int searchRequestID =
+                SearchRequestDatabaseUtil.getSearchRequestID(mDatabase, searchRequest);
+        assertWithMessage("Search request ID should exist in DB")
+                .that(searchRequestID)
+                .isAtLeast(0);
+
+        // Fetch search details from search request ID
+        final SearchRequest resultSearchRequest =
+                SearchRequestDatabaseUtil.getSearchRequestDetails(mDatabase, searchRequestID);
+        assertWithMessage("Unable to fetch search details from the database")
+                .that(resultSearchRequest)
+                .isNotNull();
+        assertWithMessage("Search request should be an instance of SearchTextRequest")
+                .that(resultSearchRequest)
+                .isInstanceOf(SearchTextRequest.class);
+        assertWithMessage("Search request mime types are not as expected")
+                .that(resultSearchRequest.getMimeTypes())
+                .containsExactlyElementsIn(mimeTypes);
+        assertWithMessage("Search request resume key is not as expected")
+                .that(resultSearchRequest.getResumeKey())
+                .isEqualTo(resumeKey);
+
+        final SearchTextRequest resultSearchTextRequest = (SearchTextRequest) resultSearchRequest;
+        assertWithMessage("Search request search text is not as expected")
+                .that(resultSearchTextRequest.getSearchText())
+                .isEqualTo(searchText);
+    }
+
+    @Test
+    public void testGetSearchSuggestionRequestDetails() {
+        final List<String> mimeTypes = List.of("video/mp4", "image/*", "image/gif");
+        final String resumeKey = "RANDOM_RESUME_KEY";
+        final String mediaSetID = "MEDIA-SET-ID";
+        final String authority = "com.random.authority";
+        final String suggestionType = SEARCH_SUGGESTION_LOCATION;
+        SearchSuggestionRequest searchRequest = new SearchSuggestionRequest(
+                mimeTypes,
+                null,
+                mediaSetID,
+                authority,
+                suggestionType,
+                resumeKey
+        );
+
+        // Insert a search request
+        final long insertResult =
+                SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest);
+        assertWithMessage("Insert search request failed")
+                .that(insertResult)
+                .isAtLeast(/* minimum row id */ 0);
+
+        // Get search request ID
+        final int searchRequestID =
+                SearchRequestDatabaseUtil.getSearchRequestID(mDatabase, searchRequest);
+        assertWithMessage("Search request ID should exist in DB")
+                .that(searchRequestID)
+                .isAtLeast(0);
+
+        // Fetch search details from search request ID
+        final SearchRequest resultSearchRequest =
+                SearchRequestDatabaseUtil.getSearchRequestDetails(mDatabase, searchRequestID);
+        assertWithMessage("Unable to fetch search details from the database")
+                .that(resultSearchRequest)
+                .isNotNull();
+        assertWithMessage("Search request should be an instance of SearchSuggestionRequest")
+                .that(resultSearchRequest)
+                .isInstanceOf(SearchSuggestionRequest.class);
+        assertWithMessage("Search request mime types are not as expected")
+                .that(resultSearchRequest.getMimeTypes())
+                .containsExactlyElementsIn(mimeTypes);
+        assertWithMessage("Search request resume key is not as expected")
+                .that(resultSearchRequest.getResumeKey())
+                .isEqualTo(resumeKey);
+
+        final SearchSuggestionRequest resultSearchSuggestionRequest =
+                (SearchSuggestionRequest) resultSearchRequest;
+        assertWithMessage("Search request search text is not as expected")
+                .that(resultSearchSuggestionRequest.getSearchSuggestion().getSearchText())
+                .isNull();
+        assertWithMessage("Search request search text is not as expected")
+                .that(resultSearchSuggestionRequest.getSearchSuggestion().getMediaSetId())
+                .isEqualTo(mediaSetID);
+        assertWithMessage("Search request search text is not as expected")
+                .that(resultSearchSuggestionRequest.getSearchSuggestion().getAuthority())
+                .isEqualTo(authority);
+        assertWithMessage("Search request search text is not as expected")
+                .that(resultSearchSuggestionRequest.getSearchSuggestion().getSearchSuggestionType())
+                .isEqualTo(suggestionType);
+    }
+
+    @Test
+    public void testResumeKeyUpdate() {
+        final List<String> mimeTypes = List.of("video/mp4", "image/*", "image/gif");
+        final String mediaSetID = "MEDIA-SET-ID";
+        final String authority = "com.random.authority";
+        final String suggestionType = SEARCH_SUGGESTION_LOCATION;
+        SearchSuggestionRequest searchRequest = new SearchSuggestionRequest(
+                mimeTypes,
+                null,
+                mediaSetID,
+                authority,
+                suggestionType,
+                null
+        );
+
+        // Insert a search request
+        final long insertResult =
+                SearchRequestDatabaseUtil.saveSearchRequest(mDatabase, searchRequest);
+        assertWithMessage("Insert search request failed")
+                .that(insertResult)
+                .isAtLeast(/* minimum row id */ 0);
+
+        // Get search request ID
+        final int searchRequestID =
+                SearchRequestDatabaseUtil.getSearchRequestID(mDatabase, searchRequest);
+        assertWithMessage("Search request ID should exist in DB")
+                .that(searchRequestID)
+                .isAtLeast(0);
+
+        // Fetch search details from search request ID
+        final SearchRequest savedSearchRequest =
+                SearchRequestDatabaseUtil.getSearchRequestDetails(mDatabase, searchRequestID);
+        assertWithMessage("Initial search request resume key is not null")
+                .that(savedSearchRequest.getResumeKey())
+                .isNull();
+
+        // Update resume key and save
+        final String randomResumeKey = "RAMDOM_RESUME_KEY";
+        savedSearchRequest.setResumeKey(randomResumeKey);
+        SearchRequestDatabaseUtil.updateResumeKey(mDatabase, searchRequestID, randomResumeKey);
+
+        // Fetch updated search details from search request ID
+        final SearchRequest updatedSearchRequest =
+                SearchRequestDatabaseUtil.getSearchRequestDetails(mDatabase, searchRequestID);
+        assertWithMessage("Initial search request resume key is not null")
+                .that(updatedSearchRequest.getResumeKey())
+                .isEqualTo(randomResumeKey);
+    }
+}
diff --git a/tests/src/com/android/providers/media/photopicker/v2/sqlite/SearchResultsDatabaseUtilTest.java b/tests/src/com/android/providers/media/photopicker/v2/sqlite/SearchResultsDatabaseUtilTest.java
new file mode 100644
index 000000000..94b1ef6c3
--- /dev/null
+++ b/tests/src/com/android/providers/media/photopicker/v2/sqlite/SearchResultsDatabaseUtilTest.java
@@ -0,0 +1,860 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.sqlite;
+
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.CLOUD_ID_1;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.CLOUD_ID_2;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.CLOUD_ID_3;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.CLOUD_PROVIDER;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.DATE_TAKEN_MS;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.GENERATION_MODIFIED;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.GIF_IMAGE_MIME_TYPE;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.JPEG_IMAGE_MIME_TYPE;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.LOCAL_ID_1;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.LOCAL_ID_2;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.LOCAL_ID_3;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.LOCAL_ID_4;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.LOCAL_PROVIDER;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.MP4_VIDEO_MIME_TYPE;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.PNG_IMAGE_MIME_TYPE;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.STANDARD_MIME_TYPE_EXTENSION;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.assertAddMediaOperation;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.getCloudMediaCursor;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.getLocalMediaCursor;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.getMediaCursor;
+import static com.android.providers.media.photopicker.util.PickerDbTestUtils.toMediaStoreUri;
+
+import static com.google.common.truth.Truth.assertWithMessage;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.MockitoAnnotations.initMocks;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.os.Bundle;
+import android.provider.MediaStore;
+
+import androidx.test.InstrumentationRegistry;
+
+import com.android.providers.media.photopicker.PickerSyncController;
+import com.android.providers.media.photopicker.SearchState;
+import com.android.providers.media.photopicker.data.PickerDatabaseHelper;
+import com.android.providers.media.photopicker.data.PickerDbFacade;
+import com.android.providers.media.photopicker.sync.PickerSyncLockManager;
+import com.android.providers.media.photopicker.v2.PickerDataLayerV2;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+public class SearchResultsDatabaseUtilTest {
+    @Mock
+    private PickerSyncController mMockSyncController;
+    @Mock
+    private SearchState mSearchState;
+    private SQLiteDatabase mDatabase;
+    private Context mContext;
+    private PickerDbFacade mFacade;
+
+    @Before
+    public void setUp() {
+        initMocks(this);
+        PickerSyncController.setInstance(mMockSyncController);
+        mContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+        File dbPath = mContext.getDatabasePath(PickerDatabaseHelper.PICKER_DATABASE_NAME);
+        dbPath.delete();
+        PickerDatabaseHelper helper = new PickerDatabaseHelper(mContext);
+        mDatabase = helper.getWritableDatabase();
+        mFacade = new PickerDbFacade(mContext, new PickerSyncLockManager(), LOCAL_PROVIDER);
+        mFacade.setCloudProvider(CLOUD_PROVIDER);
+
+        doReturn(LOCAL_PROVIDER).when(mMockSyncController).getLocalProvider();
+        doReturn(CLOUD_PROVIDER).when(mMockSyncController).getCloudProvider();
+        doReturn(CLOUD_PROVIDER).when(mMockSyncController).getCloudProviderOrDefault(any());
+        doReturn(mFacade).when(mMockSyncController).getDbFacade();
+        doReturn(mSearchState).when(mMockSyncController).getSearchState();
+        doReturn(true).when(mSearchState).isCloudSearchEnabled(any());
+        doReturn(true).when(mSearchState).isCloudSearchEnabled(any(), any());
+        doReturn(new PickerSyncLockManager()).when(mMockSyncController).getPickerSyncLockManager();
+    }
+
+    @After
+    public void teardown() {
+        mDatabase.close();
+        File dbPath = mContext.getDatabasePath(PickerDatabaseHelper.PICKER_DATABASE_NAME);
+        dbPath.delete();
+    }
+
+    @Test
+    public void testQuerySearchResultsLocalItems() {
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any());
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any(), any());
+
+        final Cursor cursor1 = getLocalMediaCursor(LOCAL_ID_1, 0);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getLocalMediaCursor(LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor2, 1);
+        final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
+
+        final int searchRequestId1 = 1;
+
+        final long cloudRowsInsertedCount = SearchResultsDatabaseUtil.cacheSearchResults(
+                mDatabase, CLOUD_PROVIDER, List.of(
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId1)));
+
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(cloudRowsInsertedCount)
+                .isEqualTo(1);
+
+        final long localRowsInsertedCount = SearchResultsDatabaseUtil.cacheSearchResults(
+                mDatabase, LOCAL_PROVIDER, List.of(
+                        getContentValues(LOCAL_ID_1, null, searchRequestId1)));
+
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(localRowsInsertedCount)
+                .isEqualTo(1);
+
+        Bundle extras = new Bundle();
+        extras.putInt("page_size", 100);
+        extras.putStringArrayList("providers",
+                new ArrayList<>(Arrays.asList(LOCAL_PROVIDER, CLOUD_PROVIDER)));
+        extras.putString("intent_action", MediaStore.ACTION_PICK_IMAGES);
+
+        try (Cursor cursor =
+                     PickerDataLayerV2.querySearchMedia(mContext, extras, searchRequestId1)) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(2);
+
+            cursor.moveToFirst();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(LOCAL_ID_2);
+
+            cursor.moveToNext();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(LOCAL_ID_1);
+        }
+    }
+
+    @Test
+    public void testQuerySearchResultsCloudItems() {
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any());
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any(), any());
+
+        final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor2, 1);
+        final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_3, LOCAL_ID_3, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
+
+        final int searchRequestId1 = 1;
+
+        // Batch insert items in the search results table.
+        final long cloudRowsInsertedCount = SearchResultsDatabaseUtil.cacheSearchResults(
+                mDatabase, CLOUD_PROVIDER, List.of(
+                        getContentValues(null, CLOUD_ID_3, searchRequestId1),
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId1),
+                        getContentValues(LOCAL_ID_1, CLOUD_ID_1, searchRequestId1)
+                ));
+
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(cloudRowsInsertedCount)
+                .isEqualTo(3);
+
+        Bundle extras = new Bundle();
+        extras.putInt("page_size", 100);
+        extras.putStringArrayList("providers",
+                new ArrayList<>(Arrays.asList(LOCAL_PROVIDER, CLOUD_PROVIDER)));
+        extras.putString("intent_action", MediaStore.ACTION_PICK_IMAGES);
+
+        try (Cursor cursor =
+                     PickerDataLayerV2.querySearchMedia(mContext, extras, searchRequestId1)) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(3);
+
+            cursor.moveToFirst();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(CLOUD_ID_3);
+
+            cursor.moveToNext();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(CLOUD_ID_2);
+
+            cursor.moveToNext();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(CLOUD_ID_1);
+        }
+    }
+
+    @Test
+    public void testQuerySearchResultsIdFilter() {
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any());
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any(), any());
+
+        final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor2, 1);
+        final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_3, LOCAL_ID_3, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
+
+        final int searchRequestId1 = 1;
+        final int searchRequestId2 = 2;
+        final int searchRequestId3 = 3;
+
+        // Batch insert items in the search results table.
+        final long cloudRowsInsertedCount = SearchResultsDatabaseUtil.cacheSearchResults(
+                mDatabase, CLOUD_PROVIDER, List.of(
+                        getContentValues(null, CLOUD_ID_3, searchRequestId3),
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId2),
+                        getContentValues(LOCAL_ID_1, CLOUD_ID_1, searchRequestId1)
+                ));
+
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(cloudRowsInsertedCount)
+                .isEqualTo(3);
+
+        Bundle extras = new Bundle();
+        extras.putInt("page_size", 100);
+        extras.putStringArrayList("providers",
+                new ArrayList<>(Arrays.asList(LOCAL_PROVIDER, CLOUD_PROVIDER)));
+        extras.putString("intent_action", MediaStore.ACTION_PICK_IMAGES);
+
+        try (Cursor cursor =
+                     PickerDataLayerV2.querySearchMedia(mContext, extras, searchRequestId2)) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(1);
+
+            cursor.moveToFirst();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(CLOUD_ID_2);
+        }
+    }
+
+    @Test
+    public void testQuerySearchResultsSortOrder() {
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any());
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any(), any());
+
+        final long dateTaken = 0L;
+
+        final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, dateTaken + 1);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, dateTaken);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor2, 1);
+        final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_3, LOCAL_ID_3, dateTaken - 1);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
+        final Cursor cursor4 = getLocalMediaCursor(LOCAL_ID_4, dateTaken);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor4, 1);
+
+        final int searchRequestId1 = 1;
+
+        // Batch insert items in the search results table.
+        final long cloudRowsInsertedCount = SearchResultsDatabaseUtil.cacheSearchResults(
+                mDatabase, CLOUD_PROVIDER, List.of(
+                        getContentValues(null, CLOUD_ID_3, searchRequestId1),
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId1),
+                        getContentValues(LOCAL_ID_1, CLOUD_ID_1, searchRequestId1)
+                ));
+
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(cloudRowsInsertedCount)
+                .isEqualTo(3);
+
+        final long rowsInsertedCount = SearchResultsDatabaseUtil.cacheSearchResults(
+                mDatabase, LOCAL_PROVIDER, List.of(
+                        getContentValues(LOCAL_ID_4, null, searchRequestId1)
+                ));
+
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(rowsInsertedCount)
+                .isEqualTo(1);
+
+        Bundle extras = new Bundle();
+        extras.putInt("page_size", 100);
+        extras.putStringArrayList("providers",
+                new ArrayList<>(Arrays.asList(LOCAL_PROVIDER, CLOUD_PROVIDER)));
+        extras.putString("intent_action", MediaStore.ACTION_PICK_IMAGES);
+
+        try (Cursor cursor =
+                     PickerDataLayerV2.querySearchMedia(mContext, extras, searchRequestId1)) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(4);
+
+            cursor.moveToFirst();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(CLOUD_ID_1);
+
+            cursor.moveToNext();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(LOCAL_ID_4);
+
+            cursor.moveToNext();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(CLOUD_ID_2);
+
+            cursor.moveToNext();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(CLOUD_ID_3);
+        }
+    }
+
+    @Test
+    public void testQuerySearchResultsPagination() {
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any());
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any(), any());
+
+        final long dateTaken = 0L;
+
+        final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, dateTaken + 1);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, dateTaken);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor2, 1);
+        final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_3, LOCAL_ID_3, dateTaken - 1);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
+        final Cursor cursor4 = getLocalMediaCursor(LOCAL_ID_4, dateTaken);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor4, 1);
+
+        final int searchRequestId1 = 1;
+
+        // Batch insert items in the search results table.
+        final long cloudRowsInsertedCount = SearchResultsDatabaseUtil.cacheSearchResults(
+                mDatabase, CLOUD_PROVIDER, List.of(
+                        getContentValues(null, CLOUD_ID_3, searchRequestId1),
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId1),
+                        getContentValues(LOCAL_ID_1, CLOUD_ID_1, searchRequestId1)
+                ));
+
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(cloudRowsInsertedCount)
+                .isEqualTo(3);
+
+        final long rowsInsertedCount = SearchResultsDatabaseUtil.cacheSearchResults(
+                mDatabase, LOCAL_PROVIDER, List.of(
+                        getContentValues(LOCAL_ID_4, null, searchRequestId1)
+                ));
+
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(rowsInsertedCount)
+                .isEqualTo(1);
+
+        Bundle extras = new Bundle();
+        extras.putInt("page_size", 2);
+        extras.putLong("picker_id", 2);
+        extras.putLong("date_taken_millis", dateTaken);
+        extras.putStringArrayList("providers",
+                new ArrayList<>(Arrays.asList(LOCAL_PROVIDER, CLOUD_PROVIDER)));
+        extras.putString("intent_action", MediaStore.ACTION_PICK_IMAGES);
+
+        try (Cursor cursor =
+                     PickerDataLayerV2.querySearchMedia(mContext, extras, searchRequestId1)) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(2);
+
+            cursor.moveToFirst();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(CLOUD_ID_2);
+
+            cursor.moveToNext();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(CLOUD_ID_3);
+        }
+    }
+
+    @Test
+    public void testQuerySearchResultsMimeTypeFilter() {
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any());
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any(), any());
+
+        final Cursor cursor1 = getMediaCursor(CLOUD_ID_1, DATE_TAKEN_MS, GENERATION_MODIFIED,
+                /* mediaStoreUri */ null, /* sizeBytes */ 1, MP4_VIDEO_MIME_TYPE,
+                STANDARD_MIME_TYPE_EXTENSION, /* isFavorite */ false);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getMediaCursor(CLOUD_ID_2, DATE_TAKEN_MS, GENERATION_MODIFIED,
+                /* mediaStoreUri */ toMediaStoreUri(LOCAL_ID_2), /* sizeBytes */ 1,
+                PNG_IMAGE_MIME_TYPE, STANDARD_MIME_TYPE_EXTENSION, /* isFavorite */ false);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor2, 1);
+        final Cursor cursor3 = getMediaCursor(CLOUD_ID_3, DATE_TAKEN_MS, GENERATION_MODIFIED,
+                /* mediaStoreUri */ toMediaStoreUri(LOCAL_ID_3), /* sizeBytes */ 1,
+                GIF_IMAGE_MIME_TYPE, STANDARD_MIME_TYPE_EXTENSION, /* isFavorite */ false);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
+        final Cursor cursor4 = getMediaCursor(LOCAL_ID_4, DATE_TAKEN_MS, GENERATION_MODIFIED,
+                /* mediaStoreUri */ toMediaStoreUri(LOCAL_ID_4), /* sizeBytes */ 1,
+                JPEG_IMAGE_MIME_TYPE, STANDARD_MIME_TYPE_EXTENSION, /* isFavorite */ false);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor4, 1);
+
+        final int searchRequestId1 = 1;
+
+        // Batch insert items in the search results table.
+        final long cloudRowsInsertedCount = SearchResultsDatabaseUtil.cacheSearchResults(
+                mDatabase, CLOUD_PROVIDER, List.of(
+                        getContentValues(null, CLOUD_ID_3, searchRequestId1),
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId1),
+                        getContentValues(LOCAL_ID_1, CLOUD_ID_1, searchRequestId1)
+                ));
+
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(cloudRowsInsertedCount)
+                .isEqualTo(3);
+
+        final long rowsInsertedCount = SearchResultsDatabaseUtil.cacheSearchResults(
+                mDatabase, LOCAL_PROVIDER, List.of(
+                        getContentValues(LOCAL_ID_4, null, searchRequestId1)
+                ));
+
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(rowsInsertedCount)
+                .isEqualTo(1);
+
+        Bundle extras = new Bundle();
+        extras.putInt("page_size", 100);
+        extras.putStringArrayList("providers",
+                new ArrayList<>(Arrays.asList(LOCAL_PROVIDER, CLOUD_PROVIDER)));
+        extras.putString("intent_action", MediaStore.ACTION_PICK_IMAGES);
+        extras.putStringArrayList("mime_types", new ArrayList<>(List.of("video/mp4", "image/gif")));
+
+        try (Cursor cursor =
+                     PickerDataLayerV2.querySearchMedia(mContext, extras, searchRequestId1)) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(2);
+
+            cursor.moveToFirst();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(CLOUD_ID_3);
+
+            cursor.moveToNext();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(CLOUD_ID_1);
+        }
+    }
+
+    @Test
+    public void testQuerySearchResultsLocalProvidersFilter() {
+        doReturn(false).when(mMockSyncController).shouldQueryCloudMedia(any());
+        doReturn(false).when(mMockSyncController).shouldQueryCloudMedia(any(), any());
+
+        final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor2, 1);
+        final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_3, LOCAL_ID_3, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
+        final Cursor cursor4 = getLocalMediaCursor(LOCAL_ID_4, 0);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor4, 1);
+
+        final int searchRequestId1 = 1;
+
+        // Batch insert items in the search results table.
+        final long cloudRowsInsertedCount = SearchResultsDatabaseUtil.cacheSearchResults(
+                mDatabase, CLOUD_PROVIDER, List.of(
+                        getContentValues(null, CLOUD_ID_3, searchRequestId1),
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId1),
+                        getContentValues(LOCAL_ID_1, CLOUD_ID_1, searchRequestId1)
+                ));
+
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(cloudRowsInsertedCount)
+                .isEqualTo(3);
+
+        final long rowsInsertedCount = SearchResultsDatabaseUtil.cacheSearchResults(
+                mDatabase, LOCAL_PROVIDER, List.of(
+                        getContentValues(LOCAL_ID_4, null, searchRequestId1)
+                ));
+
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(rowsInsertedCount)
+                .isEqualTo(1);
+
+        Bundle extras = new Bundle();
+        extras.putInt("page_size", 100);
+        extras.putStringArrayList("providers",
+                new ArrayList<>(List.of(LOCAL_PROVIDER)));
+        extras.putString("intent_action", MediaStore.ACTION_PICK_IMAGES);
+
+        try (Cursor cursor =
+                     PickerDataLayerV2.querySearchMedia(mContext, extras, searchRequestId1)) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(1);
+
+            cursor.moveToFirst();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(LOCAL_ID_4);
+        }
+    }
+
+
+    @Test
+    public void testQuerySearchResultsCloudProvidersFilter() {
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any());
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any(), any());
+
+        final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor2, 1);
+        final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_3, LOCAL_ID_3, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
+        final Cursor cursor4 = getLocalMediaCursor(LOCAL_ID_4, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor4, 1);
+
+        final int searchRequestId1 = 1;
+
+        // Batch insert items in the search results table.
+        final long rowsInsertedCount = SearchResultsDatabaseUtil.cacheSearchResults(
+                mDatabase, CLOUD_PROVIDER, List.of(
+                        getContentValues(null, CLOUD_ID_3, searchRequestId1),
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId1),
+                        getContentValues(LOCAL_ID_1, CLOUD_ID_1, searchRequestId1),
+                        getContentValues(LOCAL_ID_4, null, searchRequestId1)
+                ));
+
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(rowsInsertedCount)
+                .isEqualTo(4);
+
+        final Bundle extras = new Bundle();
+        extras.putInt("page_size", 100);
+        extras.putStringArrayList("providers", new ArrayList<>(List.of(CLOUD_PROVIDER)));
+        extras.putString("intent_action", MediaStore.ACTION_PICK_IMAGES);
+
+        try (Cursor cursor =
+                     PickerDataLayerV2.querySearchMedia(mContext, extras, searchRequestId1)) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(3);
+
+            cursor.moveToFirst();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(CLOUD_ID_3);
+
+            cursor.moveToNext();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(CLOUD_ID_2);
+
+            cursor.moveToNext();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(CLOUD_ID_1);
+        }
+    }
+
+
+    @Test
+    public void testInsertLocalItems() {
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any());
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any(), any());
+
+        final Cursor cursor1 = getLocalMediaCursor(LOCAL_ID_1, 0);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getLocalMediaCursor(LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor2, 1);
+
+        final int searchRequestId1 = 1;
+        final int searchRequestId2 = 2;
+
+        // Batch insert items in the search results table.
+        final long rowsInsertedCount = SearchResultsDatabaseUtil.cacheSearchResults(
+                mDatabase, LOCAL_PROVIDER, List.of(
+                        getContentValues(LOCAL_ID_1, null, searchRequestId1),
+                        getContentValues(LOCAL_ID_1, null, searchRequestId2),
+                        getContentValues(LOCAL_ID_2, null, searchRequestId2),
+                        getContentValues(LOCAL_ID_2, null, searchRequestId2)
+                ));
+
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(rowsInsertedCount)
+                .isEqualTo(4);
+
+        final Bundle extras = new Bundle();
+        extras.putInt("page_size", 100);
+        extras.putStringArrayList("providers",
+                new ArrayList<>(List.of(LOCAL_PROVIDER, CLOUD_PROVIDER)));
+        extras.putString("intent_action", MediaStore.ACTION_PICK_IMAGES);
+
+        // Query items for searchRequestId1
+        try (Cursor cursor =
+                     PickerDataLayerV2.querySearchMedia(mContext, extras, searchRequestId1)) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(1);
+
+            cursor.moveToFirst();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(LOCAL_ID_1);
+        }
+
+        // Query items for searchRequestId2
+        try (Cursor cursor =
+                     PickerDataLayerV2.querySearchMedia(mContext, extras, searchRequestId2)) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(2);
+
+            cursor.moveToFirst();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(LOCAL_ID_2);
+
+            cursor.moveToNext();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(LOCAL_ID_1);
+        }
+    }
+
+    @Test
+    public void testInsertCloudItems() {
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any());
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any(), any());
+
+        final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getLocalMediaCursor(LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor2, 1);
+        final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
+
+        final int searchRequestId1 = 1;
+        final int searchRequestId2 = 2;
+
+        // Batch insert items in the search results table.
+        final long rowsInsertedCount = SearchResultsDatabaseUtil.cacheSearchResults(
+                mDatabase, CLOUD_PROVIDER, List.of(
+                        getContentValues(null, CLOUD_ID_1, searchRequestId1),
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId2),
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId1),
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId1)
+                ));
+
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(rowsInsertedCount)
+                .isEqualTo(3);
+
+        final Bundle extras = new Bundle();
+        extras.putInt("page_size", 100);
+        extras.putStringArrayList("providers",
+                new ArrayList<>(List.of(LOCAL_PROVIDER, CLOUD_PROVIDER)));
+        extras.putString("intent_action", MediaStore.ACTION_PICK_IMAGES);
+
+        // Query items for searchRequestId1
+        try (Cursor cursor =
+                     PickerDataLayerV2.querySearchMedia(mContext, extras, searchRequestId1)) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(2);
+
+            cursor.moveToFirst();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(LOCAL_ID_2);
+
+            cursor.moveToNext();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(CLOUD_ID_1);
+        }
+
+        // Query items for searchRequestId2
+        try (Cursor cursor =
+                     PickerDataLayerV2.querySearchMedia(mContext, extras, searchRequestId2)) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(1);
+
+            cursor.moveToFirst();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(LOCAL_ID_2);
+        }
+    }
+
+    @Test
+    public void testInsertLocalAndCloudItems() {
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any());
+        doReturn(true).when(mMockSyncController).shouldQueryCloudMedia(any(), any());
+
+        final Cursor cursor1 = getCloudMediaCursor(CLOUD_ID_1, null, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor1, 1);
+        final Cursor cursor2 = getLocalMediaCursor(LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, LOCAL_PROVIDER, cursor2, 1);
+        final Cursor cursor3 = getCloudMediaCursor(CLOUD_ID_2, LOCAL_ID_2, 0);
+        assertAddMediaOperation(mFacade, CLOUD_PROVIDER, cursor3, 1);
+
+        final int searchRequestId1 = 1;
+
+        // Batch insert items in the search results table.
+        final long rowsInsertedCount = SearchResultsDatabaseUtil.cacheSearchResults(
+                mDatabase, CLOUD_PROVIDER, List.of(
+                        getContentValues(null, CLOUD_ID_1, searchRequestId1),
+                        getContentValues(LOCAL_ID_2, CLOUD_ID_2, searchRequestId1),
+                        getContentValues(LOCAL_ID_2, null, searchRequestId1)
+                ));
+
+        assertWithMessage("Unexpected number of rows inserted in the search results table")
+                .that(rowsInsertedCount)
+                .isEqualTo(2);
+
+        final Bundle extras = new Bundle();
+        extras.putInt("page_size", 100);
+        extras.putStringArrayList("providers",
+                new ArrayList<>(List.of(LOCAL_PROVIDER, CLOUD_PROVIDER)));
+        extras.putString("intent_action", MediaStore.ACTION_PICK_IMAGES);
+
+        // Query items for searchRequestId
+        try (Cursor cursor =
+                     PickerDataLayerV2.querySearchMedia(mContext, extras, searchRequestId1)) {
+            assertWithMessage("Cursor should not be null")
+                    .that(cursor)
+                    .isNotNull();
+
+            assertWithMessage("Cursor count is not as expected")
+                    .that(cursor.getCount())
+                    .isEqualTo(2);
+
+            cursor.moveToFirst();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(LOCAL_ID_2);
+
+            cursor.moveToNext();
+            assertWithMessage("Media ID is not as expected in the search results")
+                    .that(cursor.getString(cursor.getColumnIndexOrThrow(
+                            PickerSQLConstants.MediaResponse.MEDIA_ID.getProjectedName())))
+                    .isEqualTo(CLOUD_ID_1);
+        }
+    }
+
+    private ContentValues getContentValues(String localId, String cloudId, int searchRequestId) {
+        ContentValues contentValues = new ContentValues();
+        contentValues.put(
+                PickerSQLConstants.SearchResultMediaTableColumns.CLOUD_ID.getColumnName(), cloudId);
+        contentValues.put(
+                PickerSQLConstants.SearchResultMediaTableColumns.LOCAL_ID.getColumnName(), localId);
+        contentValues.put(
+                PickerSQLConstants.SearchResultMediaTableColumns.SEARCH_REQUEST_ID.getColumnName(),
+                searchRequestId);
+        return contentValues;
+    }
+}
diff --git a/tests/src/com/android/providers/media/photopicker/v2/sqlite/SearchSuggestionsDatabaseUtilTest.java b/tests/src/com/android/providers/media/photopicker/v2/sqlite/SearchSuggestionsDatabaseUtilTest.java
new file mode 100644
index 000000000..69af297d8
--- /dev/null
+++ b/tests/src/com/android/providers/media/photopicker/v2/sqlite/SearchSuggestionsDatabaseUtilTest.java
@@ -0,0 +1,650 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopicker.v2.sqlite;
+
+import static android.provider.CloudMediaProviderContract.SEARCH_SUGGESTION_ALBUM;
+import static android.provider.CloudMediaProviderContract.SEARCH_SUGGESTION_HISTORY;
+import static android.provider.CloudMediaProviderContract.SEARCH_SUGGESTION_FACE;
+import static android.provider.CloudMediaProviderContract.SEARCH_SUGGESTION_LOCATION;
+
+import static com.google.common.truth.Truth.assertWithMessage;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.database.MatrixCursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.os.Bundle;
+import android.provider.CloudMediaProviderContract;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.test.platform.app.InstrumentationRegistry;
+
+import com.android.providers.media.photopicker.data.PickerDatabaseHelper;
+import com.android.providers.media.photopicker.v2.model.SearchSuggestion;
+import com.android.providers.media.photopicker.v2.model.SearchSuggestionRequest;
+import com.android.providers.media.photopicker.v2.model.SearchTextRequest;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+
+public class SearchSuggestionsDatabaseUtilTest {
+    private SQLiteDatabase mDatabase;
+    private Context mContext;
+
+    @Before
+    public void setUp() {
+        mContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+        File dbPath = mContext.getDatabasePath(PickerDatabaseHelper.PICKER_DATABASE_NAME);
+        dbPath.delete();
+        PickerDatabaseHelper helper = new PickerDatabaseHelper(mContext);
+        mDatabase = helper.getWritableDatabase();
+    }
+
+    @After
+    public void teardown() {
+        mDatabase.close();
+        File dbPath = mContext.getDatabasePath(PickerDatabaseHelper.PICKER_DATABASE_NAME);
+        dbPath.delete();
+    }
+
+    @Test
+    public void testSaveTextSearchRequestHistory() {
+        final String searchText = "mountains";
+        final SearchTextRequest searchRequest = new SearchTextRequest(
+                /* mimeTypes */ null,
+                searchText
+        );
+
+        SearchSuggestionsDatabaseUtils.saveSearchHistory(mDatabase, searchRequest);
+
+        final List<SearchSuggestion> searchSuggestions =
+                SearchSuggestionsDatabaseUtils.getHistorySuggestions(
+                        mDatabase,
+                        getSearchSuggestionQuery(
+                                /* providers */ List.of(),
+                                /* limit */ 10));
+
+        assertWithMessage("Search history suggestions cannot be null")
+                .that(searchSuggestions)
+                .isNotNull();
+        assertWithMessage("Unexpected number of search history suggestions.")
+                .that(searchSuggestions.size())
+                .isEqualTo(1);
+
+        final SearchSuggestion result = searchSuggestions.get(0);
+        assertWithMessage("Search history search text is not as expected")
+                .that(result.getSearchText())
+                .isEqualTo(searchText);
+        assertWithMessage("Search history media set id is not as expected")
+                .that(result.getMediaSetId())
+                .isNull();
+        assertWithMessage("Search history authority is not as expected")
+                .that(result.getAuthority())
+                .isNull();
+        assertWithMessage("Search history suggestion type is not as expected")
+                .that(result.getSearchSuggestionType())
+                .isEqualTo(SEARCH_SUGGESTION_HISTORY);
+    }
+
+    @Test
+    public void testSaveSuggestionSearchRequestHistory() {
+        final String mediaSetID = "MEDIA-SET-ID";
+        final String authority = "com.random.authority";
+        SearchSuggestionRequest searchRequest = new SearchSuggestionRequest(
+                List.of("video/mp4", "image/*", "image/gif"),
+                null,
+                mediaSetID,
+                authority,
+                SEARCH_SUGGESTION_LOCATION,
+                null
+        );
+
+        SearchSuggestionsDatabaseUtils.saveSearchHistory(mDatabase, searchRequest);
+
+        final List<SearchSuggestion> searchSuggestions =
+                SearchSuggestionsDatabaseUtils.getHistorySuggestions(
+                        mDatabase,
+                        getSearchSuggestionQuery(
+                                /* providers */ List.of("random.authority", authority),
+                                /* limit */ 10));
+
+        assertWithMessage("Search history suggestions cannot be null")
+                .that(searchSuggestions)
+                .isNotNull();
+        assertWithMessage("Unexpected number of search history suggestions.")
+                .that(searchSuggestions.size())
+                .isEqualTo(1);
+
+        final SearchSuggestion result = searchSuggestions.get(0);
+        assertWithMessage("Search history search text is not as expected")
+                .that(result.getSearchText())
+                .isNull();
+        assertWithMessage("Search history media set id is not as expected")
+                .that(result.getMediaSetId())
+                .isEqualTo(mediaSetID);
+        assertWithMessage("Search history authority is not as expected")
+                .that(result.getAuthority())
+                .isEqualTo(authority);
+        assertWithMessage("Search history suggestion type is not as expected")
+                .that(result.getSearchSuggestionType())
+                .isEqualTo(SEARCH_SUGGESTION_HISTORY);
+    }
+
+    @Test
+    public void testQueryHistoryForProviders() {
+        final String mediaSetID = "MEDIA-SET-ID";
+        final String authority = "com.random.authority";
+        SearchSuggestionRequest searchRequest = new SearchSuggestionRequest(
+                List.of("video/mp4", "image/*", "image/gif"),
+                null,
+                mediaSetID,
+                authority,
+                SEARCH_SUGGESTION_LOCATION,
+                null
+        );
+
+        SearchSuggestionsDatabaseUtils.saveSearchHistory(mDatabase, searchRequest);
+
+        final List<SearchSuggestion> searchSuggestions =
+                SearchSuggestionsDatabaseUtils.getHistorySuggestions(
+                        mDatabase,
+                        getSearchSuggestionQuery(
+                                /* providers */ List.of("random.authority",
+                                        "another.random.authority"),
+                                /* limit */ 10));
+
+        assertWithMessage("Search history suggestions cannot be null")
+                .that(searchSuggestions)
+                .isNotNull();
+        assertWithMessage("Unexpected number of search history suggestions.")
+                .that(searchSuggestions.size())
+                .isEqualTo(0);
+    }
+
+    @Test
+    public void testQueryHistorySortOrder() {
+        final String searchText1 = "mountains";
+        final SearchTextRequest searchRequest1 = new SearchTextRequest(
+                /* mimeTypes */ null,
+                searchText1
+        );
+
+        SearchSuggestionsDatabaseUtils.saveSearchHistory(mDatabase, searchRequest1);
+
+        final String mediaSetId2 = "MEDIA-SET-ID";
+        final String authority2 = "com.random.authority";
+        SearchSuggestionRequest searchRequest2 = new SearchSuggestionRequest(
+                List.of("video/mp4", "image/*", "image/gif"),
+                null,
+                mediaSetId2,
+                authority2,
+                SEARCH_SUGGESTION_LOCATION,
+                null
+        );
+
+        SearchSuggestionsDatabaseUtils.saveSearchHistory(mDatabase, searchRequest2);
+
+        final List<SearchSuggestion> searchSuggestions =
+                SearchSuggestionsDatabaseUtils.getHistorySuggestions(
+                        mDatabase,
+                        getSearchSuggestionQuery(
+                                /* providers */ List.of(authority2),
+                                /* limit */ 10));
+
+        assertWithMessage("Search history suggestions cannot be null")
+                .that(searchSuggestions)
+                .isNotNull();
+        assertWithMessage("Unexpected number of search history suggestions.")
+                .that(searchSuggestions.size())
+                .isEqualTo(2);
+
+        final SearchSuggestion firstSuggestion = searchSuggestions.get(0);
+        assertWithMessage("Search history search text is not as expected")
+                .that(firstSuggestion.getSearchText())
+                .isNull();
+        assertWithMessage("Search history media set id is not as expected")
+                .that(firstSuggestion.getMediaSetId())
+                .isEqualTo(mediaSetId2);
+        assertWithMessage("Search history authority is not as expected")
+                .that(firstSuggestion.getAuthority())
+                .isEqualTo(authority2);
+        assertWithMessage("Search history suggestion type is not as expected")
+                .that(firstSuggestion.getSearchSuggestionType())
+                .isEqualTo(SEARCH_SUGGESTION_HISTORY);
+
+        final SearchSuggestion secondSuggestion = searchSuggestions.get(1);
+        assertWithMessage("Search history search text is not as expected")
+                .that(secondSuggestion.getSearchText())
+                .isEqualTo(searchText1);
+        assertWithMessage("Search history media set id is not as expected")
+                .that(secondSuggestion.getMediaSetId())
+                .isNull();
+        assertWithMessage("Search history authority is not as expected")
+                .that(secondSuggestion.getAuthority())
+                .isNull();
+        assertWithMessage("Search history suggestion type is not as expected")
+                .that(secondSuggestion.getSearchSuggestionType())
+                .isEqualTo(SEARCH_SUGGESTION_HISTORY);
+    }
+
+    @Test
+    public void testQueryHistoryLimit() {
+        final String searchText1 = "mountains";
+        final SearchTextRequest searchRequest1 = new SearchTextRequest(
+                /* mimeTypes */ null,
+                searchText1
+        );
+
+        SearchSuggestionsDatabaseUtils.saveSearchHistory(mDatabase, searchRequest1);
+
+        final String mediaSetId2 = "MEDIA-SET-ID";
+        final String authority2 = "com.random.authority";
+        SearchSuggestionRequest searchRequest2 = new SearchSuggestionRequest(
+                List.of("video/mp4", "image/*", "image/gif"),
+                null,
+                mediaSetId2,
+                authority2,
+                SEARCH_SUGGESTION_LOCATION,
+                null
+        );
+
+        SearchSuggestionsDatabaseUtils.saveSearchHistory(mDatabase, searchRequest2);
+
+        final List<SearchSuggestion> searchSuggestions =
+                SearchSuggestionsDatabaseUtils.getHistorySuggestions(
+                        mDatabase,
+                        getSearchSuggestionQuery(
+                                /* providers */ List.of(authority2),
+                                /* limit */ 10,
+                                /* historyLimit */ 1,
+                                /* prefix */ ""));
+
+        assertWithMessage("Search history suggestions cannot be null")
+                .that(searchSuggestions)
+                .isNotNull();
+        assertWithMessage("Unexpected number of search history suggestions.")
+                .that(searchSuggestions.size())
+                .isEqualTo(1);
+
+        final SearchSuggestion result = searchSuggestions.get(0);
+        assertWithMessage("Search history search text is not as expected")
+                .that(result.getSearchText())
+                .isNull();
+        assertWithMessage("Search history media set id is not as expected")
+                .that(result.getMediaSetId())
+                .isEqualTo(mediaSetId2);
+        assertWithMessage("Search history authority is not as expected")
+                .that(result.getAuthority())
+                .isEqualTo(authority2);
+        assertWithMessage("Search history suggestion type is not as expected")
+                .that(result.getSearchSuggestionType())
+                .isEqualTo(SEARCH_SUGGESTION_HISTORY);
+    }
+
+    @Test
+    public void testHistoryPrefixFilter() {
+        final String searchText1 = "mountains";
+        final SearchTextRequest searchRequest1 = new SearchTextRequest(
+                /* mimeTypes */ null,
+                searchText1
+        );
+        SearchSuggestionsDatabaseUtils.saveSearchHistory(mDatabase, searchRequest1);
+
+        final String searchText2 = "beaches";
+        SearchSuggestionRequest searchRequest2 = new SearchSuggestionRequest(
+                List.of("video/mp4", "image/*", "image/gif"),
+                searchText2,
+                "mediaSetId",
+                "authority",
+                SEARCH_SUGGESTION_LOCATION,
+                null
+        );
+        SearchSuggestionsDatabaseUtils.saveSearchHistory(mDatabase, searchRequest2);
+
+        final List<SearchSuggestion> searchSuggestions =
+                SearchSuggestionsDatabaseUtils.getHistorySuggestions(
+                        mDatabase,
+                        getSearchSuggestionQuery(
+                                /* providers */ List.of("authority"),
+                                /* limit */ 10,
+                                /* historyLimit */ 3,
+                                /* prefix */ "Beach"));
+
+        assertWithMessage("Search history suggestions cannot be null")
+                .that(searchSuggestions)
+                .isNotNull();
+        assertWithMessage("Unexpected number of search history suggestions.")
+                .that(searchSuggestions.size())
+                .isEqualTo(1);
+
+        final SearchSuggestion result = searchSuggestions.get(0);
+        assertWithMessage("Search history search text is not as expected")
+                .that(result.getSearchText())
+                .isEqualTo(searchText2);
+    }
+
+    @Test
+    public void testExtractSearchSuggestions() {
+        final String authority = "authority";
+        final SearchSuggestion expectedSearchSuggestion = new SearchSuggestion(
+                /* searchText */ "mountains",
+                /* mediaSetId */ "media-set-id",
+                authority,
+                SEARCH_SUGGESTION_ALBUM,
+                /* coverMediaId */ "media-id"
+        );
+
+        try (Cursor cursor = getCursor(List.of(expectedSearchSuggestion))) {
+            final List<SearchSuggestion> result =
+                    SearchSuggestionsDatabaseUtils.extractSearchSuggestions(cursor, authority);
+
+            assertWithMessage("Search suggestions cannot be null")
+                    .that(result)
+                    .isNotNull();
+            assertWithMessage("Unexpected number of search suggestions.")
+                    .that(result.size())
+                    .isEqualTo(1);
+            assertWithMessage("Search text is not as expected")
+                    .that(result.get(0).getSearchText())
+                    .isEqualTo(expectedSearchSuggestion.getSearchText());
+            assertWithMessage("Media set id is not as expected")
+                    .that(result.get(0).getMediaSetId())
+                    .isEqualTo(expectedSearchSuggestion.getMediaSetId());
+            assertWithMessage("Authority is not as expected")
+                    .that(result.get(0).getAuthority())
+                    .isEqualTo(expectedSearchSuggestion.getAuthority());
+            assertWithMessage("Suggestion type is not as expected")
+                    .that(result.get(0).getSearchSuggestionType())
+                    .isEqualTo(expectedSearchSuggestion.getSearchSuggestionType());
+        }
+    }
+
+    @Test
+    public void testSaveSuggestionSearchCache() {
+        final String mediaSetId1 = "MEDIA-SET-ID-1";
+        final String authority1 = "com.random.authority";
+        SearchSuggestion searchSuggestion1 = new SearchSuggestion(
+                /* searchText */ null,
+                mediaSetId1,
+                authority1,
+                SEARCH_SUGGESTION_LOCATION,
+                /* coverMediaId */ null
+        );
+
+        final String mediaSetId2 = "MEDIA-SET-ID-2";
+        final String authority2 = "com.another.random.authority";
+        SearchSuggestion searchSuggestion2 = new SearchSuggestion(
+                /* searchText */ null,
+                mediaSetId2,
+                authority2,
+                SEARCH_SUGGESTION_ALBUM,
+                /* coverMediaId */ null
+        );
+
+        final String mediaSetId3 = "MEDIA-SET-ID-3";
+        SearchSuggestion searchSuggestion3 = new SearchSuggestion(
+                /* searchText */ null,
+                mediaSetId3,
+                authority2,
+                SEARCH_SUGGESTION_FACE,
+                /* coverMediaId */ null
+        );
+
+        SearchSuggestionsDatabaseUtils.cacheSearchSuggestions(
+                mDatabase, authority1, List.of(searchSuggestion1));
+        SearchSuggestionsDatabaseUtils.cacheSearchSuggestions(
+                mDatabase, authority2, List.of(searchSuggestion2, searchSuggestion3));
+
+        final List<SearchSuggestion> resultSearchSuggestions1 =
+                SearchSuggestionsDatabaseUtils.getCachedSuggestions(
+                        mDatabase,
+                        getSearchSuggestionQuery(
+                            /* providers */ List.of("test", authority1),
+                            /* limit */ 10));
+
+        assertWithMessage("Search suggestions cannot be null")
+                .that(resultSearchSuggestions1)
+                .isNotNull();
+        assertWithMessage("Unexpected number of search suggestions.")
+                .that(resultSearchSuggestions1.size())
+                .isEqualTo(1);
+
+        final SearchSuggestion result1 = resultSearchSuggestions1.get(0);
+        assertWithMessage("Search search text is not as expected")
+                .that(result1.getSearchText())
+                .isNull();
+        assertWithMessage("Search media set id is not as expected")
+                .that(result1.getMediaSetId())
+                .isEqualTo(searchSuggestion1.getMediaSetId());
+        assertWithMessage("Search authority is not as expected")
+                .that(result1.getAuthority())
+                .isEqualTo(searchSuggestion1.getAuthority());
+        assertWithMessage("Search suggestion type is not as expected")
+                .that(result1.getSearchSuggestionType())
+                .isEqualTo(searchSuggestion1.getSearchSuggestionType());
+
+        final List<SearchSuggestion> resultSearchSuggestions2 =
+                SearchSuggestionsDatabaseUtils.getCachedSuggestions(
+                        mDatabase,
+                        getSearchSuggestionQuery(
+                                /* providers */ List.of("test", authority2),
+                                /* limit */ 10));
+
+        assertWithMessage("Search suggestions cannot be null")
+                .that(resultSearchSuggestions2)
+                .isNotNull();
+        assertWithMessage("Unexpected number of search suggestions.")
+                .that(resultSearchSuggestions2.size())
+                .isEqualTo(2);
+
+        final SearchSuggestion result2 = resultSearchSuggestions2.get(0);
+        assertWithMessage("Search search text is not as expected")
+                .that(result2.getSearchText())
+                .isNull();
+        assertWithMessage("Search media set id is not as expected")
+                .that(result2.getMediaSetId())
+                .isEqualTo(searchSuggestion2.getMediaSetId());
+        assertWithMessage("Search authority is not as expected")
+                .that(result2.getAuthority())
+                .isEqualTo(searchSuggestion2.getAuthority());
+        assertWithMessage("Search suggestion type is not as expected")
+                .that(result2.getSearchSuggestionType())
+                .isEqualTo(searchSuggestion2.getSearchSuggestionType());
+    }
+
+    @Test
+    public void testSuggestionsCachePrefixFilter() {
+        final String searchText1 = "BUTTER";
+        final String mediaSetId1 = "MEDIA-SET-ID-1";
+        final String authority = "com.random.authority";
+        SearchSuggestion searchSuggestion1 = new SearchSuggestion(
+                searchText1,
+                mediaSetId1,
+                authority,
+                SEARCH_SUGGESTION_LOCATION,
+                /* coverMediaId */ null
+        );
+
+        final String searchText2 = "Butterfly";
+        final String mediaSetId2 = "MEDIA-SET-ID-2";
+        SearchSuggestion searchSuggestion2 = new SearchSuggestion(
+                searchText2,
+                mediaSetId2,
+                authority,
+                SEARCH_SUGGESTION_ALBUM,
+                /* coverMediaId */ null
+        );
+
+        final String searchText3 = "dragon";
+        final String mediaSetId3 = "MEDIA-SET-ID-3";
+        SearchSuggestion searchSuggestion3 = new SearchSuggestion(
+                searchText3,
+                mediaSetId3,
+                authority,
+                SEARCH_SUGGESTION_FACE,
+                /* coverMediaId */ null
+        );
+
+        SearchSuggestionsDatabaseUtils.cacheSearchSuggestions(mDatabase, authority,
+                List.of(searchSuggestion1, searchSuggestion2, searchSuggestion3));
+
+        final List<SearchSuggestion> resultSearchSuggestions =
+                SearchSuggestionsDatabaseUtils.getCachedSuggestions(
+                        mDatabase,
+                        getSearchSuggestionQuery(
+                                /* providers */ List.of("test", authority),
+                                /* limit */ 10,
+                                /* historyLimit */ 3,
+                                /* prefix */ "but"));
+
+        assertWithMessage("Search suggestions cannot be null")
+                .that(resultSearchSuggestions)
+                .isNotNull();
+        assertWithMessage("Unexpected number of search suggestions.")
+                .that(resultSearchSuggestions.size())
+                .isEqualTo(2);
+
+        assertWithMessage("Search search text is not as expected")
+                .that(resultSearchSuggestions.get(0).getSearchText())
+                .isEqualTo(searchSuggestion1.getSearchText());
+        assertWithMessage("Search search text is not as expected")
+                .that(resultSearchSuggestions.get(1).getSearchText())
+                .isEqualTo(searchSuggestion2.getSearchText());
+    }
+
+    @Test
+    public void testSaveSuggestionWithNullMediaSetId() {
+        final String authority = "com.random.authority";
+        SearchSuggestion searchSuggestion = new SearchSuggestion(
+                /* searchText */ null,
+                /* mediaSetId */ null,
+                authority,
+                SEARCH_SUGGESTION_LOCATION,
+                /* coverMediaId */ null
+        );
+
+        SearchSuggestionsDatabaseUtils.cacheSearchSuggestions(
+                mDatabase, authority, List.of(searchSuggestion));
+
+        final List<SearchSuggestion> resultSearchSuggestions =
+                SearchSuggestionsDatabaseUtils.getCachedSuggestions(
+                        mDatabase,
+                        getSearchSuggestionQuery(
+                                /* providers */ List.of("random.authority", authority),
+                                /* limit */ 10));
+
+        assertWithMessage("Search suggestions cannot be null")
+                .that(resultSearchSuggestions)
+                .isNotNull();
+        assertWithMessage("Unexpected number of search suggestions.")
+                .that(resultSearchSuggestions.size())
+                .isEqualTo(0);
+    }
+
+    @Test
+    public void testCleanUpSearchSuggestionsBeforeCaching() {
+        final String authority = "com.random.authority";
+        SearchSuggestion searchSuggestion1 = new SearchSuggestion(
+                /* searchText */ null,
+                "media-set-id",
+                authority,
+                SEARCH_SUGGESTION_ALBUM,
+                /* coverMediaId */ null
+        );
+
+        SearchSuggestionsDatabaseUtils.cacheSearchSuggestions(
+                mDatabase, authority, List.of(searchSuggestion1));
+
+        final List<SearchSuggestion> resultSearchSuggestions1 =
+                SearchSuggestionsDatabaseUtils.getCachedSuggestions(
+                        mDatabase,
+                        getSearchSuggestionQuery(
+                                /* providers */ List.of("random.authority", authority),
+                                /* limit */ 10));
+
+        assertWithMessage("Search suggestions cannot be null")
+                .that(resultSearchSuggestions1)
+                .isNotNull();
+        assertWithMessage("Unexpected number of search suggestions.")
+                .that(resultSearchSuggestions1.size())
+                .isEqualTo(1);
+
+        SearchSuggestion searchSuggestion2 = new SearchSuggestion(
+                /* searchText */ null,
+                "media-set-id",
+                authority,
+                SEARCH_SUGGESTION_FACE,
+                /* coverMediaId */ null
+        );
+
+        SearchSuggestionsDatabaseUtils.cacheSearchSuggestions(
+                mDatabase, authority, List.of(searchSuggestion2));
+
+        final List<SearchSuggestion> resultSearchSuggestions2 =
+                SearchSuggestionsDatabaseUtils.getCachedSuggestions(
+                        mDatabase,
+                        getSearchSuggestionQuery(
+                                /* providers */ List.of("random.authority", authority),
+                                /* limit */ 10));
+
+        assertWithMessage("Search suggestions cannot be null")
+                .that(resultSearchSuggestions2)
+                .isNotNull();
+        assertWithMessage("Unexpected number of search suggestions.")
+                .that(resultSearchSuggestions2.size())
+                .isEqualTo(1);
+    }
+
+    private Cursor getCursor(@NonNull List<SearchSuggestion> searchSuggestions) {
+        final MatrixCursor cursor = new MatrixCursor(
+                CloudMediaProviderContract.SearchSuggestionColumns.ALL_PROJECTION);
+
+        for (SearchSuggestion searchSuggestion : searchSuggestions) {
+            cursor.addRow(List.of(
+                    searchSuggestion.getMediaSetId(),
+                    searchSuggestion.getSearchText(),
+                    searchSuggestion.getSearchSuggestionType(),
+                    searchSuggestion.getCoverMediaId()
+            ).toArray(new Object[4]));
+        }
+
+        return cursor;
+    }
+
+    private SearchSuggestionsQuery getSearchSuggestionQuery(@Nullable List<String> providers,
+                                                            int limit) {
+        return getSearchSuggestionQuery(providers, limit, 10, "");
+    }
+
+    private SearchSuggestionsQuery getSearchSuggestionQuery(@Nullable List<String> providers,
+                                                            int limit,
+                                                            int historyLimit,
+                                                            @Nullable String prefix) {
+        final Bundle bundle = new Bundle();
+        bundle.putInt("limit", limit);
+        bundle.putStringArrayList("providers", new ArrayList<>(providers));
+        bundle.putInt("history_limit", historyLimit);
+        bundle.putString("prefix", prefix);
+        return new SearchSuggestionsQuery(bundle);
+    }
+}
diff --git a/tests/src/com/android/providers/media/photopicker/viewmodel/PickerViewModelPaginationTest.java b/tests/src/com/android/providers/media/photopicker/viewmodel/PickerViewModelPaginationTest.java
index 8bb2500c6..432508d54 100644
--- a/tests/src/com/android/providers/media/photopicker/viewmodel/PickerViewModelPaginationTest.java
+++ b/tests/src/com/android/providers/media/photopicker/viewmodel/PickerViewModelPaginationTest.java
@@ -129,6 +129,10 @@ public class PickerViewModelPaginationTest {
         final Context isolatedContext = new IsolatedContext(sTargetContext, /* tag */ "databases",
                 /* asFuseThread */ false, sTargetContext.getUser(), testConfigStore);
         when(mApplication.getApplicationContext()).thenReturn(isolatedContext);
+
+        final UserIdManager userIdManager = mock(UserIdManager.class);
+        when(userIdManager.getCurrentUserProfileId()).thenReturn(UserId.CURRENT_USER);
+
         sInstrumentation.runOnMainSync(() -> {
             mPickerViewModel = new PickerViewModel(mApplication) {
                 @Override
@@ -136,14 +140,13 @@ public class PickerViewModelPaginationTest {
                     setConfigStore(testConfigStore);
                 }
             };
+            mPickerViewModel.initUserManagers(userIdManager);
         });
         if (testConfigStore.isPrivateSpaceInPhotoPickerEnabled() && SdkLevel.isAtLeastS()) {
             final UserManagerState userManagerState = mock(UserManagerState.class);
             when(userManagerState.getCurrentUserProfileId()).thenReturn(UserId.CURRENT_USER);
             mPickerViewModel.setUserManagerState(userManagerState);
         } else {
-            final UserIdManager userIdManager = mock(UserIdManager.class);
-            when(userIdManager.getCurrentUserProfileId()).thenReturn(UserId.CURRENT_USER);
             mPickerViewModel.setUserIdManager(userIdManager);
         }
 
diff --git a/tests/src/com/android/providers/media/photopicker/viewmodel/PickerViewModelTest.java b/tests/src/com/android/providers/media/photopicker/viewmodel/PickerViewModelTest.java
index 607dca406..31dc50652 100644
--- a/tests/src/com/android/providers/media/photopicker/viewmodel/PickerViewModelTest.java
+++ b/tests/src/com/android/providers/media/photopicker/viewmodel/PickerViewModelTest.java
@@ -157,6 +157,9 @@ public class PickerViewModelTest {
             mConfigStore.disablePrivateSpaceInPhotoPicker();
         }
 
+        final UserIdManager userIdManager = mock(UserIdManager.class);
+        when(userIdManager.getCurrentUserProfileId()).thenReturn(UserId.CURRENT_USER);
+
         getInstrumentation().runOnMainSync(() -> {
             mPickerViewModel = new PickerViewModel(mApplication) {
                 @Override
@@ -164,6 +167,7 @@ public class PickerViewModelTest {
                     setConfigStore(mConfigStore);
                 }
             };
+            mPickerViewModel.initUserManagers(userIdManager);
         });
         mItemsProvider = new TestItemsProvider(sTargetContext);
         mPickerViewModel.setItemsProvider(mItemsProvider);
@@ -176,8 +180,6 @@ public class PickerViewModelTest {
             mBannerManager = BannerTestUtils.getTestCloudBannerManager(
                     sTargetContext, userManagerState, mConfigStore);
         } else {
-            final UserIdManager userIdManager = mock(UserIdManager.class);
-            when(userIdManager.getCurrentUserProfileId()).thenReturn(UserId.CURRENT_USER);
             mPickerViewModel.setUserIdManager(userIdManager);
             mBannerManager = BannerTestUtils.getTestCloudBannerManager(
                     sTargetContext, userIdManager, mConfigStore);
diff --git a/tests/src/com/android/providers/media/photopickersearch/CloudMediaProviderSearch.java b/tests/src/com/android/providers/media/photopickersearch/CloudMediaProviderSearch.java
new file mode 100644
index 000000000..38f6f8f71
--- /dev/null
+++ b/tests/src/com/android/providers/media/photopickersearch/CloudMediaProviderSearch.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopickersearch;
+
+import android.content.res.AssetFileDescriptor;
+import android.database.Cursor;
+import android.database.MatrixCursor;
+import android.graphics.Point;
+import android.os.Bundle;
+import android.os.CancellationSignal;
+import android.os.ParcelFileDescriptor;
+import android.provider.CloudMediaProvider;
+import android.provider.CloudMediaProviderContract;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import java.io.FileNotFoundException;
+
+public class CloudMediaProviderSearch extends CloudMediaProvider {
+    public static final String SEARCH_PROVIDER_FOR_PICKER_CLIENT_AUTHORITY =
+            "com.android.providers.media.photopicker.tests.cloud_provider_for_search_client";
+    public static final String[] MEDIA_PROJECTIONS =  new String[] {
+            CloudMediaProviderContract.MediaColumns.ID
+    };
+
+    public static final String TEST_MEDIA_ID_FROM_SUGGESTED_SEARCH = "1";
+    public static final String TEST_MEDIA_ID_IN_MEDIA_SET = "2";
+    public static final String TEST_MEDIA_ID_FROM_TEXT_SEARCH = "3";
+
+    public static final String TEST_MEDIA_SET_ID = "11";
+    public static final String TEST_MEDIA_CATEGORY_ID = "111";
+    public static final String TEST_SEARCH_SUGGESTION_MEDIA_SET_ID = "2";
+
+    @Override
+    public Cursor onSearchMedia(String mediaSetId, String fallbackSearchText,
+            Bundle extras, CancellationSignal cancellationSignal) {
+        MatrixCursor mockCursor = new MatrixCursor(MEDIA_PROJECTIONS);
+        mockCursor.addRow(new Object[]{TEST_MEDIA_ID_FROM_SUGGESTED_SEARCH});
+        return mockCursor;
+    }
+
+    @Override
+    public Cursor onSearchMedia(String searchText,
+            Bundle extras, CancellationSignal cancellationSignal) {
+        MatrixCursor mockCursor = new MatrixCursor(MEDIA_PROJECTIONS);
+        mockCursor.addRow(new Object[]{TEST_MEDIA_ID_FROM_TEXT_SEARCH});
+        return mockCursor;
+    }
+
+    @Override
+    public Cursor onQueryMediaInMediaSet(String mediaSetId, Bundle extras,
+            CancellationSignal cancellationSignal) {
+        MatrixCursor mockCursor = new MatrixCursor(MEDIA_PROJECTIONS);
+        mockCursor.addRow(new Object[]{TEST_MEDIA_ID_IN_MEDIA_SET});
+        return mockCursor;
+    }
+
+    @Override
+    public Cursor onQueryMediaSets(String mediaCategoryId, Bundle extras,
+            CancellationSignal cancellationSignal) {
+        MatrixCursor mockCursor = new MatrixCursor(
+                CloudMediaProviderContract.MediaSetColumns.ALL_PROJECTION);
+        mockCursor.addRow(new Object[]{TEST_MEDIA_SET_ID, "Media Set 1", 1, 25});
+        return mockCursor;
+    }
+
+    @Override
+    public Cursor onQuerySearchSuggestions(String prefixText, Bundle extras,
+            CancellationSignal cancellationSignal) {
+        MatrixCursor mockCursor = new MatrixCursor(
+                CloudMediaProviderContract.SearchSuggestionColumns.ALL_PROJECTION);
+        mockCursor.addRow(new Object[]{TEST_SEARCH_SUGGESTION_MEDIA_SET_ID,
+                1, "song", "Suggestion 1 for " + prefixText});
+        return mockCursor;
+    }
+
+    @Override
+    public Cursor onQueryMediaCategories(String parentCategoryId,
+            Bundle extras, CancellationSignal cancellationSignal) {
+        MatrixCursor mockCursor =
+                new MatrixCursor(CloudMediaProviderContract.MediaCategoryColumns.ALL_PROJECTION);
+        mockCursor.addRow(new Object[]{TEST_MEDIA_CATEGORY_ID, 1, null, 1, 2, 3, 4});
+        return mockCursor;
+    }
+
+    @Override
+    public Bundle onGetMediaCollectionInfo(@NonNull Bundle extras) {
+        return new Bundle();
+    }
+
+    @Override
+    public Cursor onQueryMedia(@NonNull Bundle extras) {
+        return new MatrixCursor(new String[0]);
+    }
+
+    @Override
+    public Cursor onQueryDeletedMedia(@NonNull Bundle extras) {
+        return new MatrixCursor(new String[0]);
+    }
+
+    @Override
+    public AssetFileDescriptor onOpenPreview(@NonNull String mediaId, @NonNull Point size,
+            @Nullable Bundle extras, @Nullable CancellationSignal signal)
+            throws FileNotFoundException {
+        throw new UnsupportedOperationException("onOpenPreview not supported");
+    }
+
+    @Override
+    public ParcelFileDescriptor onOpenMedia(@NonNull String mediaId, @Nullable Bundle extras,
+            @Nullable CancellationSignal signal) throws FileNotFoundException {
+        throw new UnsupportedOperationException("onOpenMedia not supported");
+    }
+
+    @Override
+    public boolean onCreate() {
+        return true;
+    }
+
+}
diff --git a/tests/src/com/android/providers/media/photopickersearch/PickerSearchProviderClientTest.java b/tests/src/com/android/providers/media/photopickersearch/PickerSearchProviderClientTest.java
new file mode 100644
index 000000000..0461e9aec
--- /dev/null
+++ b/tests/src/com/android/providers/media/photopickersearch/PickerSearchProviderClientTest.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.providers.media.photopickersearch;
+
+import static com.android.providers.media.photopickersearch.CloudMediaProviderSearch.MEDIA_PROJECTIONS;
+import static com.android.providers.media.photopickersearch.CloudMediaProviderSearch.SEARCH_PROVIDER_FOR_PICKER_CLIENT_AUTHORITY;
+import static com.android.providers.media.photopickersearch.CloudMediaProviderSearch.TEST_MEDIA_CATEGORY_ID;
+import static com.android.providers.media.photopickersearch.CloudMediaProviderSearch.TEST_MEDIA_ID_FROM_SUGGESTED_SEARCH;
+import static com.android.providers.media.photopickersearch.CloudMediaProviderSearch.TEST_MEDIA_ID_FROM_TEXT_SEARCH;
+import static com.android.providers.media.photopickersearch.CloudMediaProviderSearch.TEST_MEDIA_ID_IN_MEDIA_SET;
+import static com.android.providers.media.photopickersearch.CloudMediaProviderSearch.TEST_MEDIA_SET_ID;
+import static com.android.providers.media.photopickersearch.CloudMediaProviderSearch.TEST_SEARCH_SUGGESTION_MEDIA_SET_ID;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.platform.test.annotations.RequiresFlagsEnabled;
+import android.platform.test.flag.junit.CheckFlagsRule;
+import android.platform.test.flag.junit.DeviceFlagsValueProvider;
+import android.provider.CloudMediaProviderContract;
+
+import androidx.test.InstrumentationRegistry;
+import androidx.test.runner.AndroidJUnit4;
+
+import com.android.providers.media.flags.Flags;
+import com.android.providers.media.photopicker.sync.PickerSearchProviderClient;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+@RequiresFlagsEnabled(Flags.FLAG_CLOUD_MEDIA_PROVIDER_SEARCH)
+@RunWith(AndroidJUnit4.class)
+public class PickerSearchProviderClientTest {
+
+
+    @Rule
+    public final CheckFlagsRule mCheckFlagsRule = DeviceFlagsValueProvider.createCheckFlagsRule();
+
+    private PickerSearchProviderClient mPickerSearchProviderClient;
+    private Context mContext;
+
+    @Before
+    public void setUp() {
+        mContext = InstrumentationRegistry.getTargetContext();
+        mPickerSearchProviderClient =
+                PickerSearchProviderClient.create(
+                        mContext, SEARCH_PROVIDER_FOR_PICKER_CLIENT_AUTHORITY);
+    }
+
+    @Test
+    public void testFetchSearchSuggestionsFromCmp() {
+        Cursor cursor = mPickerSearchProviderClient.fetchSearchSuggestionsFromCmp("test",
+                10,  null);
+        cursor.moveToFirst();
+        assertEquals(TEST_SEARCH_SUGGESTION_MEDIA_SET_ID, cursor.getString(cursor.getColumnIndex(
+                CloudMediaProviderContract.SearchSuggestionColumns.MEDIA_SET_ID)));
+        assertCursorColumns(cursor,
+                CloudMediaProviderContract.SearchSuggestionColumns.ALL_PROJECTION);
+    }
+
+    @Test
+    public void testFetchSuggestedSearchResultsFromCmp() {
+        Cursor cursor = mPickerSearchProviderClient.fetchSearchResultsFromCmp(
+                TEST_SEARCH_SUGGESTION_MEDIA_SET_ID, null, 1, 100,
+                null, null);
+        cursor.moveToFirst();
+        assertEquals(TEST_MEDIA_ID_FROM_SUGGESTED_SEARCH, cursor.getString(cursor.getColumnIndex(
+                CloudMediaProviderContract.MediaColumns.ID)));
+        assertCursorColumns(cursor, MEDIA_PROJECTIONS);
+    }
+
+    @Test
+    public void testFetchTextSearchResultsFromCmp() {
+        Cursor cursor = mPickerSearchProviderClient.fetchSearchResultsFromCmp(
+                null, "test", 1, 100,
+                null, null);
+        cursor.moveToFirst();
+        assertEquals(TEST_MEDIA_ID_FROM_TEXT_SEARCH, cursor.getString(cursor.getColumnIndex(
+                CloudMediaProviderContract.MediaColumns.ID)));
+        assertCursorColumns(cursor, MEDIA_PROJECTIONS);
+    }
+
+    @Test
+    public void testFetchMediasInMediaSetFromCmp() {
+        Cursor cursor = mPickerSearchProviderClient.fetchMediasInMediaSetFromCmp(TEST_MEDIA_SET_ID,
+                null, 100, CloudMediaProviderContract.SORT_ORDER_DESC_DATE_TAKEN,
+                null, null);
+        cursor.moveToFirst();
+        assertEquals(TEST_MEDIA_ID_IN_MEDIA_SET, cursor.getString(cursor.getColumnIndex(
+                CloudMediaProviderContract.MediaColumns.ID)));
+        assertCursorColumns(cursor, MEDIA_PROJECTIONS);
+    }
+
+
+    @Test
+    public void testFetchMediaCategoriesFromCmp() {
+        Cursor cursor = mPickerSearchProviderClient.fetchMediaCategoriesFromCmp(null, null, null);
+        cursor.moveToFirst();
+        assertEquals(TEST_MEDIA_CATEGORY_ID, cursor.getString(
+                cursor.getColumnIndex(CloudMediaProviderContract.MediaCategoryColumns.ID)));
+        assertCursorColumns(cursor, CloudMediaProviderContract.MediaCategoryColumns.ALL_PROJECTION);
+    }
+
+    @Test
+    public void testFetchMediaSetsFromCmp() {
+        Cursor cursor = mPickerSearchProviderClient.fetchMediaSetsFromCmp(TEST_MEDIA_CATEGORY_ID,
+                null, 10, null, null);
+        cursor.moveToFirst();
+        assertEquals(TEST_MEDIA_SET_ID, cursor.getString(
+                cursor.getColumnIndex(CloudMediaProviderContract.MediaSetColumns.ID)));
+        assertCursorColumns(cursor, CloudMediaProviderContract.MediaSetColumns.ALL_PROJECTION);
+    }
+
+    private static void assertCursorColumns(Cursor cursor, String[] projections) {
+        for (String columnName : projections) {
+            assertTrue(cursor.getColumnIndex(columnName) >= 0);
+        }
+    }
+
+}
diff --git a/tests/src/com/android/providers/media/stableuris/job/StableUriIdleMaintenanceServiceTest.java b/tests/src/com/android/providers/media/stableuris/job/StableUriIdleMaintenanceServiceTest.java
index 4a6cd851a..9784141ff 100644
--- a/tests/src/com/android/providers/media/stableuris/job/StableUriIdleMaintenanceServiceTest.java
+++ b/tests/src/com/android/providers/media/stableuris/job/StableUriIdleMaintenanceServiceTest.java
@@ -282,6 +282,7 @@ public class StableUriIdleMaintenanceServiceTest {
                 .adoptShellPermissionIdentity(
                         Manifest.permission.READ_DEVICE_CONFIG,
                         Manifest.permission.WRITE_DEVICE_CONFIG,
+                        Manifest.permission.WRITE_ALLOWLISTED_DEVICE_CONFIG,
                         Manifest.permission.WRITE_MEDIA_STORAGE,
                         android.Manifest.permission.LOG_COMPAT_CHANGE,
                         android.Manifest.permission.READ_COMPAT_CHANGE_CONFIG,
diff --git a/tests/src/com/android/providers/media/util/SyntheticPathUtilsTest.java b/tests/src/com/android/providers/media/util/SyntheticPathUtilsTest.java
index 0c8c5df10..dbfafe75b 100644
--- a/tests/src/com/android/providers/media/util/SyntheticPathUtilsTest.java
+++ b/tests/src/com/android/providers/media/util/SyntheticPathUtilsTest.java
@@ -54,6 +54,8 @@ public class SyntheticPathUtilsTest {
                 ".transforms/synthetic/picker");
         assertThat(getPickerRelativePath(PickerUriResolver.PICKER_GET_CONTENT_SEGMENT)).isEqualTo(
                 ".transforms/synthetic/picker_get_content");
+        assertThat(getPickerRelativePath(PickerUriResolver.PICKER_TRANSCODED_SEGMENT)).isEqualTo(
+                ".transforms/synthetic/picker_transcoded");
     }
 
     @Test
@@ -100,6 +102,10 @@ public class SyntheticPathUtilsTest {
                         /* userId */ 0)).isTrue();
         assertThat(isPickerPath("/storage/emulated/10/.transforms/synthetic/picker/foo",
                         /* userId */ 10)).isTrue();
+        assertThat(isPickerPath("/storage/emulated/0/.transforms/synthetic/picker_transcoded/foo",
+                /* userId */ 0)).isTrue();
+        assertThat(isPickerPath("/storage/emulated/10/.transforms/synthetic/picker_transcoded/foo",
+                /* userId */ 10)).isTrue();
         assertThat(isPickerPath("/storage/emulated/0/.transforms/synthetic/PICKER/bar/baz",
                         /* userId */ 0)).isTrue();
 
@@ -107,6 +113,10 @@ public class SyntheticPathUtilsTest {
                         /* userId */ 10)).isFalse();
         assertThat(isPickerPath("/storage/emulated/10/.transforms/synthetic/picker/foo",
                         /* userId */ 0)).isFalse();
+        assertThat(isPickerPath("/storage/emulated/0/.transforms/synthetic/picker_transcoded/foo",
+                /* userId */ 10)).isFalse();
+        assertThat(isPickerPath("/storage/emulated/10/.transforms/synthetic/picker_transcoded/foo",
+                /* userId */ 0)).isFalse();
         assertThat(isPickerPath("/storage/emulated/0/.transforms/synthetic/redacted/foo",
                         /* userId */ 0)).isFalse();
         assertThat(isPickerPath("/storage/emulated/0/.transforms/picker/foo", /* userId */ 0))
```

