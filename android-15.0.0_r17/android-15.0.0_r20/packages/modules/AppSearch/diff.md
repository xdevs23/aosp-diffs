```diff
diff --git a/NOTICE b/NOTICE
index 9ffcc081..32a74b92 100644
--- a/NOTICE
+++ b/NOTICE
@@ -1,6 +1,5 @@
 
    Copyright (c) 2006-2009, The Android Open Source Project
-   Copyright 2006, Brian Swetland <swetland@frotz.net>
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
diff --git a/apk/AndroidManifest.xml b/apk/AndroidManifest.xml
index 3b7bdb47..b567e1ed 100644
--- a/apk/AndroidManifest.xml
+++ b/apk/AndroidManifest.xml
@@ -16,10 +16,4 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
   package="com.android.appsearch.apk">
 
-    <!-- TODO(b/359911502): Remove this permission along with the other app functionality that
-           exists in app search once the new app function implementation is done.
-         Allows system applications to execute app functions provided by apps through AppSearch. -->
-    <permission android:name="android.permission.EXECUTE_APP_FUNCTION"
-                android:protectionLevel="internal|role" />
-
 </manifest>
\ No newline at end of file
diff --git a/flags/Android.bp b/flags/Android.bp
index da615fa1..630258de 100644
--- a/flags/Android.bp
+++ b/flags/Android.bp
@@ -34,6 +34,7 @@ java_aconfig_library {
     name: "appsearch_flags_java_lib",
     aconfig_declarations: "appsearch_aconfig_flags",
     visibility: [
+        "//cts/tests/appsearch:__subpackages__",
         "//packages/modules/AppSearch:__subpackages__",
     ],
     defaults: ["framework-minus-apex-aconfig-java-defaults"],
diff --git a/flags/appsearch.aconfig b/flags/appsearch.aconfig
index e17cf6ab..42b32fdb 100644
--- a/flags/appsearch.aconfig
+++ b/flags/appsearch.aconfig
@@ -41,6 +41,15 @@ flag {
     is_fixed_read_only: true
 }
 
+flag {
+    name: "enable_list_filter_match_score_expression_function"
+    is_exported: true
+    namespace: "appsearch"
+    description: "Enable the 'matchScoreExpression' function in list filter query expressions."
+    bug: "377215223"
+    is_fixed_read_only: true
+}
+
 flag {
     name: "enable_put_documents_request_add_taken_actions"
     is_exported: true
@@ -149,6 +158,15 @@ flag {
     is_exported: true
 }
 
+flag {
+    name: "enable_schema_embedding_quantization"
+    namespace: "appsearch"
+    description: "Enables embedding quantization."
+    bug: "359959345"
+    is_fixed_read_only: true
+    is_exported: true
+}
+
 flag {
     name: "enable_informational_ranking_expressions"
     namespace: "appsearch"
@@ -230,3 +248,75 @@ flag {
     is_fixed_read_only: true
     is_exported: true
 }
+
+flag {
+    name: "enable_additional_builder_copy_constructors"
+    namespace: "appsearch"
+    description: "Enables additional builder copy constructors for AppSearchSchema, SetSchemaRequest, SearchSpec, JoinSpec, AppSearchBatchResult, and GetSchemaResponse."
+    bug: "369563892"
+    is_fixed_read_only: true
+    is_exported: true
+}
+
+flag {
+    name: "enable_abstract_syntax_trees"
+    namespace: "appsearch"
+    description: "Enables abstract syntax trees to be built and used within AppSearch."
+    bug: "356661489"
+    is_fixed_read_only: true
+    is_exported: true
+}
+
+flag {
+    name: "enable_search_spec_filter_document_ids"
+    namespace: "appsearch"
+    description: "Enables the addFilterDocumentId API in the SearchSpec."
+    bug: "367464836"
+    is_fixed_read_only: true
+    is_exported: true
+}
+
+flag {
+    name: "enable_document_limiter_replace_tracking"
+    namespace: "appsearch"
+    description: "Enables the replacement of the calculation of doc limits."
+    bug: "363301147"
+    is_fixed_read_only: true
+    is_exported: true
+}
+
+flag {
+    name: "enable_scorable_property"
+    namespace: "appsearch"
+    description: "Enables the feature of scorable property."
+    bug: "357105964"
+    is_fixed_read_only: true
+    is_exported: true
+}
+
+flag {
+     name: "enable_search_result_parent_types"
+     namespace: "appsearch"
+     description: "Enables wrapping the parent types of a document in the SearchResult instead of GenericDocument."
+     bug: "371610934"
+     is_fixed_read_only: true
+     is_exported: true
+ }
+
+flag {
+    name: "enable_delete_propagation_type"
+    namespace: "appsearch"
+    description: "Enables delete propagation type related APIs."
+    bug: "376913014"
+    is_fixed_read_only: true
+    is_exported: true
+}
+
+flag {
+    name: "enable_app_functions_schema_parser"
+    namespace: "appsearch"
+    description: "Enables the AppFunctionSchemaParser for dynamic schema parsing."
+    bug: "380729091"
+    is_fixed_read_only: true
+    is_exported: true
+}
diff --git a/framework/api/current.txt b/framework/api/current.txt
index cb368b57..8d1afe99 100644
--- a/framework/api/current.txt
+++ b/framework/api/current.txt
@@ -10,17 +10,28 @@ package android.app.appsearch {
 
   public static final class AppSearchBatchResult.Builder<KeyType, ValueType> {
     ctor public AppSearchBatchResult.Builder();
+    ctor @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") public AppSearchBatchResult.Builder(@NonNull android.app.appsearch.AppSearchBatchResult<KeyType,ValueType>);
     method @NonNull public android.app.appsearch.AppSearchBatchResult<KeyType,ValueType> build();
     method @NonNull public android.app.appsearch.AppSearchBatchResult.Builder<KeyType,ValueType> setFailure(@NonNull KeyType, int, @Nullable String);
     method @NonNull public android.app.appsearch.AppSearchBatchResult.Builder<KeyType,ValueType> setResult(@NonNull KeyType, @NonNull android.app.appsearch.AppSearchResult<ValueType>);
     method @NonNull public android.app.appsearch.AppSearchBatchResult.Builder<KeyType,ValueType> setSuccess(@NonNull KeyType, @Nullable ValueType);
   }
 
+  @FlaggedApi("com.android.appsearch.flags.enable_blob_store") public final class AppSearchBlobHandle implements android.os.Parcelable {
+    method @NonNull public static android.app.appsearch.AppSearchBlobHandle createWithSha256(@NonNull byte[], @NonNull String, @NonNull String, @NonNull String);
+    method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public final int describeContents();
+    method @NonNull public String getDatabaseName();
+    method @NonNull public String getNamespace();
+    method @NonNull public String getPackageName();
+    method @NonNull public byte[] getSha256Digest();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.app.appsearch.AppSearchBlobHandle> CREATOR;
+  }
+
   public class AppSearchManager {
     method @FlaggedApi("com.android.appsearch.flags.enable_enterprise_global_search_session") public void createEnterpriseGlobalSearchSession(@NonNull java.util.concurrent.Executor, @NonNull java.util.function.Consumer<android.app.appsearch.AppSearchResult<android.app.appsearch.EnterpriseGlobalSearchSession>>);
     method public void createGlobalSearchSession(@NonNull java.util.concurrent.Executor, @NonNull java.util.function.Consumer<android.app.appsearch.AppSearchResult<android.app.appsearch.GlobalSearchSession>>);
     method public void createSearchSession(@NonNull android.app.appsearch.AppSearchManager.SearchContext, @NonNull java.util.concurrent.Executor, @NonNull java.util.function.Consumer<android.app.appsearch.AppSearchResult<android.app.appsearch.AppSearchSession>>);
-    method @FlaggedApi("com.android.appsearch.flags.enable_app_functions") @NonNull public android.app.appsearch.functions.AppFunctionManager getAppFunctionManager();
   }
 
   public static final class AppSearchManager.SearchContext {
@@ -64,7 +75,18 @@ package android.app.appsearch {
     field @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") @NonNull public static final android.os.Parcelable.Creator<android.app.appsearch.AppSearchSchema> CREATOR;
   }
 
+  @FlaggedApi("com.android.appsearch.flags.enable_blob_store") public static final class AppSearchSchema.BlobHandlePropertyConfig extends android.app.appsearch.AppSearchSchema.PropertyConfig {
+  }
+
+  @FlaggedApi("com.android.appsearch.flags.enable_blob_store") public static final class AppSearchSchema.BlobHandlePropertyConfig.Builder {
+    ctor public AppSearchSchema.BlobHandlePropertyConfig.Builder(@NonNull String);
+    method @NonNull public android.app.appsearch.AppSearchSchema.BlobHandlePropertyConfig build();
+    method @NonNull public android.app.appsearch.AppSearchSchema.BlobHandlePropertyConfig.Builder setCardinality(int);
+    method @FlaggedApi("com.android.appsearch.flags.enable_app_functions") @NonNull public android.app.appsearch.AppSearchSchema.BlobHandlePropertyConfig.Builder setDescription(@NonNull String);
+  }
+
   public static final class AppSearchSchema.BooleanPropertyConfig extends android.app.appsearch.AppSearchSchema.PropertyConfig {
+    method @FlaggedApi("com.android.appsearch.flags.enable_scorable_property") public boolean isScoringEnabled();
   }
 
   public static final class AppSearchSchema.BooleanPropertyConfig.Builder {
@@ -72,14 +94,19 @@ package android.app.appsearch {
     method @NonNull public android.app.appsearch.AppSearchSchema.BooleanPropertyConfig build();
     method @NonNull public android.app.appsearch.AppSearchSchema.BooleanPropertyConfig.Builder setCardinality(int);
     method @FlaggedApi("com.android.appsearch.flags.enable_app_functions") @NonNull public android.app.appsearch.AppSearchSchema.BooleanPropertyConfig.Builder setDescription(@NonNull String);
+    method @FlaggedApi("com.android.appsearch.flags.enable_scorable_property") @NonNull public android.app.appsearch.AppSearchSchema.BooleanPropertyConfig.Builder setScoringEnabled(boolean);
   }
 
   public static final class AppSearchSchema.Builder {
     ctor public AppSearchSchema.Builder(@NonNull String);
+    ctor @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") public AppSearchSchema.Builder(@NonNull android.app.appsearch.AppSearchSchema);
     method @NonNull public android.app.appsearch.AppSearchSchema.Builder addParentType(@NonNull String);
     method @NonNull public android.app.appsearch.AppSearchSchema.Builder addProperty(@NonNull android.app.appsearch.AppSearchSchema.PropertyConfig);
     method @NonNull public android.app.appsearch.AppSearchSchema build();
+    method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.AppSearchSchema.Builder clearParentTypes();
+    method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.AppSearchSchema.Builder clearProperties();
     method @FlaggedApi("com.android.appsearch.flags.enable_app_functions") @NonNull public android.app.appsearch.AppSearchSchema.Builder setDescription(@NonNull String);
+    method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.AppSearchSchema.Builder setSchemaType(@NonNull String);
   }
 
   public static final class AppSearchSchema.BytesPropertyConfig extends android.app.appsearch.AppSearchSchema.PropertyConfig {
@@ -111,6 +138,7 @@ package android.app.appsearch {
   }
 
   public static final class AppSearchSchema.DoublePropertyConfig extends android.app.appsearch.AppSearchSchema.PropertyConfig {
+    method @FlaggedApi("com.android.appsearch.flags.enable_scorable_property") public boolean isScoringEnabled();
   }
 
   public static final class AppSearchSchema.DoublePropertyConfig.Builder {
@@ -118,12 +146,16 @@ package android.app.appsearch {
     method @NonNull public android.app.appsearch.AppSearchSchema.DoublePropertyConfig build();
     method @NonNull public android.app.appsearch.AppSearchSchema.DoublePropertyConfig.Builder setCardinality(int);
     method @FlaggedApi("com.android.appsearch.flags.enable_app_functions") @NonNull public android.app.appsearch.AppSearchSchema.DoublePropertyConfig.Builder setDescription(@NonNull String);
+    method @FlaggedApi("com.android.appsearch.flags.enable_scorable_property") @NonNull public android.app.appsearch.AppSearchSchema.DoublePropertyConfig.Builder setScoringEnabled(boolean);
   }
 
   @FlaggedApi("com.android.appsearch.flags.enable_schema_embedding_property_config") public static final class AppSearchSchema.EmbeddingPropertyConfig extends android.app.appsearch.AppSearchSchema.PropertyConfig {
     method public int getIndexingType();
+    method @FlaggedApi("com.android.appsearch.flags.enable_schema_embedding_quantization") public int getQuantizationType();
     field public static final int INDEXING_TYPE_NONE = 0; // 0x0
     field public static final int INDEXING_TYPE_SIMILARITY = 1; // 0x1
+    field public static final int QUANTIZATION_TYPE_8_BIT = 1; // 0x1
+    field public static final int QUANTIZATION_TYPE_NONE = 0; // 0x0
   }
 
   @FlaggedApi("com.android.appsearch.flags.enable_schema_embedding_property_config") public static final class AppSearchSchema.EmbeddingPropertyConfig.Builder {
@@ -132,10 +164,12 @@ package android.app.appsearch {
     method @NonNull public android.app.appsearch.AppSearchSchema.EmbeddingPropertyConfig.Builder setCardinality(int);
     method @FlaggedApi("com.android.appsearch.flags.enable_app_functions") @NonNull public android.app.appsearch.AppSearchSchema.EmbeddingPropertyConfig.Builder setDescription(@NonNull String);
     method @NonNull public android.app.appsearch.AppSearchSchema.EmbeddingPropertyConfig.Builder setIndexingType(int);
+    method @FlaggedApi("com.android.appsearch.flags.enable_schema_embedding_quantization") @NonNull public android.app.appsearch.AppSearchSchema.EmbeddingPropertyConfig.Builder setQuantizationType(int);
   }
 
   public static final class AppSearchSchema.LongPropertyConfig extends android.app.appsearch.AppSearchSchema.PropertyConfig {
     method public int getIndexingType();
+    method @FlaggedApi("com.android.appsearch.flags.enable_scorable_property") public boolean isScoringEnabled();
     field public static final int INDEXING_TYPE_NONE = 0; // 0x0
     field public static final int INDEXING_TYPE_RANGE = 1; // 0x1
   }
@@ -146,6 +180,7 @@ package android.app.appsearch {
     method @NonNull public android.app.appsearch.AppSearchSchema.LongPropertyConfig.Builder setCardinality(int);
     method @FlaggedApi("com.android.appsearch.flags.enable_app_functions") @NonNull public android.app.appsearch.AppSearchSchema.LongPropertyConfig.Builder setDescription(@NonNull String);
     method @NonNull public android.app.appsearch.AppSearchSchema.LongPropertyConfig.Builder setIndexingType(int);
+    method @FlaggedApi("com.android.appsearch.flags.enable_scorable_property") @NonNull public android.app.appsearch.AppSearchSchema.LongPropertyConfig.Builder setScoringEnabled(boolean);
   }
 
   public abstract static class AppSearchSchema.PropertyConfig {
@@ -158,9 +193,12 @@ package android.app.appsearch {
   }
 
   public static final class AppSearchSchema.StringPropertyConfig extends android.app.appsearch.AppSearchSchema.PropertyConfig {
+    method @FlaggedApi("com.android.appsearch.flags.enable_delete_propagation_type") public int getDeletePropagationType();
     method public int getIndexingType();
     method public int getJoinableValueType();
     method public int getTokenizerType();
+    field @FlaggedApi("com.android.appsearch.flags.enable_delete_propagation_type") public static final int DELETE_PROPAGATION_TYPE_NONE = 0; // 0x0
+    field @FlaggedApi("com.android.appsearch.flags.enable_delete_propagation_type") public static final int DELETE_PROPAGATION_TYPE_PROPAGATE_FROM = 1; // 0x1
     field public static final int INDEXING_TYPE_EXACT_TERMS = 1; // 0x1
     field public static final int INDEXING_TYPE_NONE = 0; // 0x0
     field public static final int INDEXING_TYPE_PREFIXES = 2; // 0x2
@@ -176,6 +214,7 @@ package android.app.appsearch {
     ctor public AppSearchSchema.StringPropertyConfig.Builder(@NonNull String);
     method @NonNull public android.app.appsearch.AppSearchSchema.StringPropertyConfig build();
     method @NonNull public android.app.appsearch.AppSearchSchema.StringPropertyConfig.Builder setCardinality(int);
+    method @FlaggedApi("com.android.appsearch.flags.enable_delete_propagation_type") @NonNull public android.app.appsearch.AppSearchSchema.StringPropertyConfig.Builder setDeletePropagationType(int);
     method @FlaggedApi("com.android.appsearch.flags.enable_app_functions") @NonNull public android.app.appsearch.AppSearchSchema.StringPropertyConfig.Builder setDescription(@NonNull String);
     method @NonNull public android.app.appsearch.AppSearchSchema.StringPropertyConfig.Builder setIndexingType(int);
     method @NonNull public android.app.appsearch.AppSearchSchema.StringPropertyConfig.Builder setJoinableValueType(int);
@@ -184,16 +223,21 @@ package android.app.appsearch {
 
   public final class AppSearchSession implements java.io.Closeable {
     method public void close();
+    method @FlaggedApi("com.android.appsearch.flags.enable_blob_store") public void commitBlob(@NonNull java.util.Set<android.app.appsearch.AppSearchBlobHandle>, @NonNull java.util.concurrent.Executor, @NonNull java.util.function.Consumer<android.app.appsearch.AppSearchResult<android.app.appsearch.CommitBlobResponse>>);
     method public void getByDocumentId(@NonNull android.app.appsearch.GetByDocumentIdRequest, @NonNull java.util.concurrent.Executor, @NonNull android.app.appsearch.BatchResultCallback<java.lang.String,android.app.appsearch.GenericDocument>);
     method public void getNamespaces(@NonNull java.util.concurrent.Executor, @NonNull java.util.function.Consumer<android.app.appsearch.AppSearchResult<java.util.Set<java.lang.String>>>);
     method public void getSchema(@NonNull java.util.concurrent.Executor, @NonNull java.util.function.Consumer<android.app.appsearch.AppSearchResult<android.app.appsearch.GetSchemaResponse>>);
     method public void getStorageInfo(@NonNull java.util.concurrent.Executor, @NonNull java.util.function.Consumer<android.app.appsearch.AppSearchResult<android.app.appsearch.StorageInfo>>);
+    method @FlaggedApi("com.android.appsearch.flags.enable_blob_store") public void openBlobForRead(@NonNull java.util.Set<android.app.appsearch.AppSearchBlobHandle>, @NonNull java.util.concurrent.Executor, @NonNull java.util.function.Consumer<android.app.appsearch.AppSearchResult<android.app.appsearch.OpenBlobForReadResponse>>);
+    method @FlaggedApi("com.android.appsearch.flags.enable_blob_store") public void openBlobForWrite(@NonNull java.util.Set<android.app.appsearch.AppSearchBlobHandle>, @NonNull java.util.concurrent.Executor, @NonNull java.util.function.Consumer<android.app.appsearch.AppSearchResult<android.app.appsearch.OpenBlobForWriteResponse>>);
     method public void put(@NonNull android.app.appsearch.PutDocumentsRequest, @NonNull java.util.concurrent.Executor, @NonNull android.app.appsearch.BatchResultCallback<java.lang.String,java.lang.Void>);
     method public void remove(@NonNull android.app.appsearch.RemoveByDocumentIdRequest, @NonNull java.util.concurrent.Executor, @NonNull android.app.appsearch.BatchResultCallback<java.lang.String,java.lang.Void>);
     method public void remove(@NonNull String, @NonNull android.app.appsearch.SearchSpec, @NonNull java.util.concurrent.Executor, @NonNull java.util.function.Consumer<android.app.appsearch.AppSearchResult<java.lang.Void>>);
+    method @FlaggedApi("com.android.appsearch.flags.enable_blob_store") public void removeBlob(@NonNull java.util.Set<android.app.appsearch.AppSearchBlobHandle>, @NonNull java.util.concurrent.Executor, @NonNull java.util.function.Consumer<android.app.appsearch.AppSearchResult<android.app.appsearch.RemoveBlobResponse>>);
     method public void reportUsage(@NonNull android.app.appsearch.ReportUsageRequest, @NonNull java.util.concurrent.Executor, @NonNull java.util.function.Consumer<android.app.appsearch.AppSearchResult<java.lang.Void>>);
     method @NonNull public android.app.appsearch.SearchResults search(@NonNull String, @NonNull android.app.appsearch.SearchSpec);
     method public void searchSuggestion(@NonNull String, @NonNull android.app.appsearch.SearchSuggestionSpec, @NonNull java.util.concurrent.Executor, @NonNull java.util.function.Consumer<android.app.appsearch.AppSearchResult<java.util.List<android.app.appsearch.SearchSuggestionResult>>>);
+    method @FlaggedApi("com.android.appsearch.flags.enable_blob_store") public void setBlobVisibility(@NonNull android.app.appsearch.SetBlobVisibilityRequest, @NonNull java.util.concurrent.Executor, @NonNull java.util.function.Consumer<android.app.appsearch.AppSearchResult<java.lang.Void>>);
     method public void setSchema(@NonNull android.app.appsearch.SetSchemaRequest, @NonNull java.util.concurrent.Executor, @NonNull java.util.concurrent.Executor, @NonNull java.util.function.Consumer<android.app.appsearch.AppSearchResult<android.app.appsearch.SetSchemaResponse>>);
   }
 
@@ -202,6 +246,14 @@ package android.app.appsearch {
     method public default void onSystemError(@Nullable Throwable);
   }
 
+  @FlaggedApi("com.android.appsearch.flags.enable_blob_store") public final class CommitBlobResponse implements android.os.Parcelable {
+    ctor public CommitBlobResponse(@NonNull android.app.appsearch.AppSearchBatchResult<android.app.appsearch.AppSearchBlobHandle,java.lang.Void>);
+    method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public final int describeContents();
+    method @NonNull public android.app.appsearch.AppSearchBatchResult<android.app.appsearch.AppSearchBlobHandle,java.lang.Void> getResult();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.app.appsearch.CommitBlobResponse> CREATOR;
+  }
+
   @FlaggedApi("com.android.appsearch.flags.enable_schema_embedding_property_config") public final class EmbeddingVector implements android.os.Parcelable {
     ctor public EmbeddingVector(@NonNull float[], @NonNull String);
     method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public final int describeContents();
@@ -214,6 +266,7 @@ package android.app.appsearch {
   @FlaggedApi("com.android.appsearch.flags.enable_enterprise_global_search_session") public class EnterpriseGlobalSearchSession {
     method public void getByDocumentId(@NonNull String, @NonNull String, @NonNull android.app.appsearch.GetByDocumentIdRequest, @NonNull java.util.concurrent.Executor, @NonNull android.app.appsearch.BatchResultCallback<java.lang.String,android.app.appsearch.GenericDocument>);
     method public void getSchema(@NonNull String, @NonNull String, @NonNull java.util.concurrent.Executor, @NonNull java.util.function.Consumer<android.app.appsearch.AppSearchResult<android.app.appsearch.GetSchemaResponse>>);
+    method @FlaggedApi("com.android.appsearch.flags.enable_blob_store") public void openBlobForRead(@NonNull java.util.Set<android.app.appsearch.AppSearchBlobHandle>, @NonNull java.util.concurrent.Executor, @NonNull java.util.function.Consumer<android.app.appsearch.AppSearchResult<android.app.appsearch.OpenBlobForReadResponse>>);
     method @NonNull public android.app.appsearch.SearchResults search(@NonNull String, @NonNull android.app.appsearch.SearchSpec);
   }
 
@@ -224,6 +277,8 @@ package android.app.appsearch {
     method public static int getMaxIndexedProperties();
     method @NonNull public String getNamespace();
     method @Nullable public Object getProperty(@NonNull String);
+    method @FlaggedApi("com.android.appsearch.flags.enable_blob_store") @Nullable public android.app.appsearch.AppSearchBlobHandle getPropertyBlobHandle(@NonNull String);
+    method @FlaggedApi("com.android.appsearch.flags.enable_blob_store") @Nullable public android.app.appsearch.AppSearchBlobHandle[] getPropertyBlobHandleArray(@NonNull String);
     method public boolean getPropertyBoolean(@NonNull String);
     method @Nullable public boolean[] getPropertyBooleanArray(@NonNull String);
     method @Nullable public byte[] getPropertyBytes(@NonNull String);
@@ -252,6 +307,7 @@ package android.app.appsearch {
     method @NonNull public BuilderType setCreationTimestampMillis(long);
     method @FlaggedApi("com.android.appsearch.flags.enable_generic_document_builder_hidden_methods") @NonNull public BuilderType setId(@NonNull String);
     method @FlaggedApi("com.android.appsearch.flags.enable_generic_document_builder_hidden_methods") @NonNull public BuilderType setNamespace(@NonNull String);
+    method @FlaggedApi("com.android.appsearch.flags.enable_blob_store") @NonNull public BuilderType setPropertyBlobHandle(@NonNull String, @NonNull android.app.appsearch.AppSearchBlobHandle...);
     method @NonNull public BuilderType setPropertyBoolean(@NonNull String, @NonNull boolean...);
     method @NonNull public BuilderType setPropertyBytes(@NonNull String, @NonNull byte[]...);
     method @NonNull public BuilderType setPropertyDocument(@NonNull String, @NonNull android.app.appsearch.GenericDocument...);
@@ -299,9 +355,16 @@ package android.app.appsearch {
 
   public static final class GetSchemaResponse.Builder {
     ctor public GetSchemaResponse.Builder();
+    ctor @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") public GetSchemaResponse.Builder(@NonNull android.app.appsearch.GetSchemaResponse);
     method @NonNull public android.app.appsearch.GetSchemaResponse.Builder addSchema(@NonNull android.app.appsearch.AppSearchSchema);
     method @NonNull public android.app.appsearch.GetSchemaResponse.Builder addSchemaTypeNotDisplayedBySystem(@NonNull String);
     method @NonNull public android.app.appsearch.GetSchemaResponse build();
+    method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.GetSchemaResponse.Builder clearPubliclyVisibleSchema(@NonNull String);
+    method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.GetSchemaResponse.Builder clearRequiredPermissionsForSchemaTypeVisibility(@NonNull String);
+    method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.GetSchemaResponse.Builder clearSchemaTypeNotDisplayedBySystem(@NonNull String);
+    method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.GetSchemaResponse.Builder clearSchemaTypeVisibleToConfigs(@NonNull String);
+    method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.GetSchemaResponse.Builder clearSchemaTypeVisibleToPackages(@NonNull String);
+    method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.GetSchemaResponse.Builder clearSchemas();
     method @FlaggedApi("com.android.appsearch.flags.enable_set_publicly_visible_schema") @NonNull public android.app.appsearch.GetSchemaResponse.Builder setPubliclyVisibleSchema(@NonNull String, @NonNull android.app.appsearch.PackageIdentifier);
     method @NonNull public android.app.appsearch.GetSchemaResponse.Builder setRequiredPermissionsForSchemaTypeVisibility(@NonNull String, @NonNull java.util.Set<java.util.Set<java.lang.Integer>>);
     method @FlaggedApi("com.android.appsearch.flags.enable_set_schema_visible_to_configs") @NonNull public android.app.appsearch.GetSchemaResponse.Builder setSchemaTypeVisibleToConfigs(@NonNull String, @NonNull java.util.Set<android.app.appsearch.SchemaVisibilityConfig>);
@@ -313,6 +376,7 @@ package android.app.appsearch {
     method public void close();
     method public void getByDocumentId(@NonNull String, @NonNull String, @NonNull android.app.appsearch.GetByDocumentIdRequest, @NonNull java.util.concurrent.Executor, @NonNull android.app.appsearch.BatchResultCallback<java.lang.String,android.app.appsearch.GenericDocument>);
     method public void getSchema(@NonNull String, @NonNull String, @NonNull java.util.concurrent.Executor, @NonNull java.util.function.Consumer<android.app.appsearch.AppSearchResult<android.app.appsearch.GetSchemaResponse>>);
+    method @FlaggedApi("com.android.appsearch.flags.enable_blob_store") public void openBlobForRead(@NonNull java.util.Set<android.app.appsearch.AppSearchBlobHandle>, @NonNull java.util.concurrent.Executor, @NonNull java.util.function.Consumer<android.app.appsearch.AppSearchResult<android.app.appsearch.OpenBlobForReadResponse>>);
     method public void registerObserverCallback(@NonNull String, @NonNull android.app.appsearch.observer.ObserverSpec, @NonNull java.util.concurrent.Executor, @NonNull android.app.appsearch.observer.ObserverCallback) throws android.app.appsearch.exceptions.AppSearchException;
     method public void reportSystemUsage(@NonNull android.app.appsearch.ReportSystemUsageRequest, @NonNull java.util.concurrent.Executor, @NonNull java.util.function.Consumer<android.app.appsearch.AppSearchResult<java.lang.Void>>);
     method @NonNull public android.app.appsearch.SearchResults search(@NonNull String, @NonNull android.app.appsearch.SearchSpec);
@@ -338,8 +402,10 @@ package android.app.appsearch {
 
   public static final class JoinSpec.Builder {
     ctor public JoinSpec.Builder(@NonNull String);
+    ctor @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") public JoinSpec.Builder(@NonNull android.app.appsearch.JoinSpec);
     method @NonNull public android.app.appsearch.JoinSpec build();
     method @NonNull public android.app.appsearch.JoinSpec.Builder setAggregationScoringStrategy(int);
+    method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.JoinSpec.Builder setChildPropertyExpression(@NonNull String);
     method @NonNull public android.app.appsearch.JoinSpec.Builder setMaxJoinedResultCount(int);
     method @NonNull public android.app.appsearch.JoinSpec.Builder setNestedSearch(@NonNull String, @NonNull android.app.appsearch.SearchSpec);
   }
@@ -351,6 +417,24 @@ package android.app.appsearch {
     method public abstract boolean shouldMigrate(int, int);
   }
 
+  @FlaggedApi("com.android.appsearch.flags.enable_blob_store") public final class OpenBlobForReadResponse implements java.io.Closeable android.os.Parcelable {
+    ctor public OpenBlobForReadResponse(@NonNull android.app.appsearch.AppSearchBatchResult<android.app.appsearch.AppSearchBlobHandle,android.os.ParcelFileDescriptor>);
+    method public void close();
+    method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public final int describeContents();
+    method @NonNull public android.app.appsearch.AppSearchBatchResult<android.app.appsearch.AppSearchBlobHandle,android.os.ParcelFileDescriptor> getResult();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.app.appsearch.OpenBlobForReadResponse> CREATOR;
+  }
+
+  @FlaggedApi("com.android.appsearch.flags.enable_blob_store") public final class OpenBlobForWriteResponse implements java.io.Closeable android.os.Parcelable {
+    ctor public OpenBlobForWriteResponse(@NonNull android.app.appsearch.AppSearchBatchResult<android.app.appsearch.AppSearchBlobHandle,android.os.ParcelFileDescriptor>);
+    method public void close();
+    method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public final int describeContents();
+    method @NonNull public android.app.appsearch.AppSearchBatchResult<android.app.appsearch.AppSearchBlobHandle,android.os.ParcelFileDescriptor> getResult();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.app.appsearch.OpenBlobForWriteResponse> CREATOR;
+  }
+
   public class PackageIdentifier {
     ctor public PackageIdentifier(@NonNull String, @NonNull byte[]);
     method @NonNull public String getPackageName();
@@ -387,6 +471,14 @@ package android.app.appsearch {
     method @NonNull public android.app.appsearch.PutDocumentsRequest build();
   }
 
+  @FlaggedApi("com.android.appsearch.flags.enable_blob_store") public final class RemoveBlobResponse implements android.os.Parcelable {
+    ctor public RemoveBlobResponse(@NonNull android.app.appsearch.AppSearchBatchResult<android.app.appsearch.AppSearchBlobHandle,java.lang.Void>);
+    method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public final int describeContents();
+    method @NonNull public android.app.appsearch.AppSearchBatchResult<android.app.appsearch.AppSearchBlobHandle,java.lang.Void> getResult();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.app.appsearch.RemoveBlobResponse> CREATOR;
+  }
+
   public final class RemoveByDocumentIdRequest implements android.os.Parcelable {
     method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public final int describeContents();
     method @NonNull public java.util.Set<java.lang.String> getIds();
@@ -458,6 +550,7 @@ package android.app.appsearch {
     method @NonNull public java.util.List<android.app.appsearch.SearchResult> getJoinedResults();
     method @NonNull public java.util.List<android.app.appsearch.SearchResult.MatchInfo> getMatchInfos();
     method @NonNull public String getPackageName();
+    method @FlaggedApi("com.android.appsearch.flags.enable_search_result_parent_types") @NonNull public java.util.Map<java.lang.String,java.util.List<java.lang.String>> getParentTypeMap();
     method public double getRankingSignal();
     method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public void writeToParcel(@NonNull android.os.Parcel, int);
     field @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") @NonNull public static final android.os.Parcelable.Creator<android.app.appsearch.SearchResult> CREATOR;
@@ -470,6 +563,7 @@ package android.app.appsearch {
     method @NonNull public android.app.appsearch.SearchResult.Builder addMatchInfo(@NonNull android.app.appsearch.SearchResult.MatchInfo);
     method @NonNull public android.app.appsearch.SearchResult build();
     method @NonNull public android.app.appsearch.SearchResult.Builder setGenericDocument(@NonNull android.app.appsearch.GenericDocument);
+    method @FlaggedApi("com.android.appsearch.flags.enable_search_result_parent_types") @NonNull public android.app.appsearch.SearchResult.Builder setParentTypeMap(@NonNull java.util.Map<java.lang.String,java.util.List<java.lang.String>>);
     method @NonNull public android.app.appsearch.SearchResult.Builder setRankingSignal(double);
   }
 
@@ -512,6 +606,7 @@ package android.app.appsearch {
     method @NonNull public String getAdvancedRankingExpression();
     method @FlaggedApi("com.android.appsearch.flags.enable_schema_embedding_property_config") public int getDefaultEmbeddingSearchMetricType();
     method @FlaggedApi("com.android.appsearch.flags.enable_schema_embedding_property_config") @NonNull public java.util.List<android.app.appsearch.EmbeddingVector> getEmbeddingParameters();
+    method @FlaggedApi("com.android.appsearch.flags.enable_search_spec_filter_document_ids") @NonNull public java.util.List<java.lang.String> getFilterDocumentIds();
     method @NonNull public java.util.List<java.lang.String> getFilterNamespaces();
     method @NonNull public java.util.List<java.lang.String> getFilterPackageNames();
     method @FlaggedApi("com.android.appsearch.flags.enable_search_spec_filter_properties") @NonNull public java.util.Map<java.lang.String,java.util.List<java.lang.String>> getFilterProperties();
@@ -534,12 +629,15 @@ package android.app.appsearch {
     method public int getSnippetCountPerProperty();
     method public int getTermMatch();
     method @FlaggedApi("com.android.appsearch.flags.enable_list_filter_has_property_function") public boolean isListFilterHasPropertyFunctionEnabled();
+    method @FlaggedApi("com.android.appsearch.flags.enable_list_filter_match_score_expression_function") public boolean isListFilterMatchScoreExpressionFunctionEnabled();
     method public boolean isListFilterQueryLanguageEnabled();
     method public boolean isNumericSearchEnabled();
+    method @FlaggedApi("com.android.appsearch.flags.enable_scorable_property") public boolean isScorablePropertyRankingEnabled();
     method public boolean isVerbatimSearchEnabled();
     method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public void writeToParcel(@NonNull android.os.Parcel, int);
     field @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") @NonNull public static final android.os.Parcelable.Creator<android.app.appsearch.SearchSpec> CREATOR;
     field @FlaggedApi("com.android.appsearch.flags.enable_schema_embedding_property_config") public static final int EMBEDDING_SEARCH_METRIC_TYPE_COSINE = 1; // 0x1
+    field @FlaggedApi("com.android.appsearch.flags.enable_schema_embedding_property_config") public static final int EMBEDDING_SEARCH_METRIC_TYPE_DEFAULT = 0; // 0x0
     field @FlaggedApi("com.android.appsearch.flags.enable_schema_embedding_property_config") public static final int EMBEDDING_SEARCH_METRIC_TYPE_DOT_PRODUCT = 2; // 0x2
     field @FlaggedApi("com.android.appsearch.flags.enable_schema_embedding_property_config") public static final int EMBEDDING_SEARCH_METRIC_TYPE_EUCLIDEAN = 3; // 0x3
     field public static final int GROUPING_TYPE_PER_NAMESPACE = 2; // 0x2
@@ -565,8 +663,11 @@ package android.app.appsearch {
 
   public static final class SearchSpec.Builder {
     ctor public SearchSpec.Builder();
+    ctor @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") public SearchSpec.Builder(@NonNull android.app.appsearch.SearchSpec);
     method @FlaggedApi("com.android.appsearch.flags.enable_schema_embedding_property_config") @NonNull public android.app.appsearch.SearchSpec.Builder addEmbeddingParameters(@NonNull android.app.appsearch.EmbeddingVector...);
     method @FlaggedApi("com.android.appsearch.flags.enable_schema_embedding_property_config") @NonNull public android.app.appsearch.SearchSpec.Builder addEmbeddingParameters(@NonNull java.util.Collection<android.app.appsearch.EmbeddingVector>);
+    method @FlaggedApi("com.android.appsearch.flags.enable_search_spec_filter_document_ids") @NonNull public android.app.appsearch.SearchSpec.Builder addFilterDocumentIds(@NonNull java.lang.String...);
+    method @FlaggedApi("com.android.appsearch.flags.enable_search_spec_filter_document_ids") @NonNull public android.app.appsearch.SearchSpec.Builder addFilterDocumentIds(@NonNull java.util.Collection<java.lang.String>);
     method @NonNull public android.app.appsearch.SearchSpec.Builder addFilterNamespaces(@NonNull java.lang.String...);
     method @NonNull public android.app.appsearch.SearchSpec.Builder addFilterNamespaces(@NonNull java.util.Collection<java.lang.String>);
     method @NonNull public android.app.appsearch.SearchSpec.Builder addFilterPackageNames(@NonNull java.lang.String...);
@@ -582,9 +683,23 @@ package android.app.appsearch {
     method @FlaggedApi("com.android.appsearch.flags.enable_search_spec_search_string_parameters") @NonNull public android.app.appsearch.SearchSpec.Builder addSearchStringParameters(@NonNull java.lang.String...);
     method @FlaggedApi("com.android.appsearch.flags.enable_search_spec_search_string_parameters") @NonNull public android.app.appsearch.SearchSpec.Builder addSearchStringParameters(@NonNull java.util.List<java.lang.String>);
     method @NonNull public android.app.appsearch.SearchSpec build();
+    method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.SearchSpec.Builder clearEmbeddingParameters();
+    method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.SearchSpec.Builder clearFilterDocumentIds();
+    method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.SearchSpec.Builder clearFilterNamespaces();
+    method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.SearchSpec.Builder clearFilterPackageNames();
+    method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.SearchSpec.Builder clearFilterProperties();
+    method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.SearchSpec.Builder clearFilterSchemas();
+    method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.SearchSpec.Builder clearInformationalRankingExpressions();
+    method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.SearchSpec.Builder clearJoinSpec();
+    method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.SearchSpec.Builder clearProjections();
+    method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.SearchSpec.Builder clearPropertyWeights();
+    method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.SearchSpec.Builder clearResultGrouping();
+    method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.SearchSpec.Builder clearSearchSourceLogTag();
+    method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.SearchSpec.Builder clearSearchStringParameters();
     method @FlaggedApi("com.android.appsearch.flags.enable_schema_embedding_property_config") @NonNull public android.app.appsearch.SearchSpec.Builder setDefaultEmbeddingSearchMetricType(int);
     method @NonNull public android.app.appsearch.SearchSpec.Builder setJoinSpec(@NonNull android.app.appsearch.JoinSpec);
     method @FlaggedApi("com.android.appsearch.flags.enable_list_filter_has_property_function") @NonNull public android.app.appsearch.SearchSpec.Builder setListFilterHasPropertyFunctionEnabled(boolean);
+    method @FlaggedApi("com.android.appsearch.flags.enable_list_filter_match_score_expression_function") @NonNull public android.app.appsearch.SearchSpec.Builder setListFilterMatchScoreExpressionFunctionEnabled(boolean);
     method @NonNull public android.app.appsearch.SearchSpec.Builder setListFilterQueryLanguageEnabled(boolean);
     method @NonNull public android.app.appsearch.SearchSpec.Builder setMaxSnippetSize(@IntRange(from=0, to=0x2710) int);
     method @NonNull public android.app.appsearch.SearchSpec.Builder setNumericSearchEnabled(boolean);
@@ -595,6 +710,7 @@ package android.app.appsearch {
     method @NonNull public android.app.appsearch.SearchSpec.Builder setRankingStrategy(@NonNull String);
     method @NonNull public android.app.appsearch.SearchSpec.Builder setResultCountPerPage(@IntRange(from=0, to=0x2710) int);
     method @NonNull public android.app.appsearch.SearchSpec.Builder setResultGrouping(int, int);
+    method @FlaggedApi("com.android.appsearch.flags.enable_scorable_property") @NonNull public android.app.appsearch.SearchSpec.Builder setScorablePropertyRankingEnabled(boolean);
     method @FlaggedApi("com.android.appsearch.flags.enable_search_spec_set_search_source_log_tag") @NonNull public android.app.appsearch.SearchSpec.Builder setSearchSourceLogTag(@NonNull String);
     method @NonNull public android.app.appsearch.SearchSpec.Builder setSnippetCount(@IntRange(from=0, to=0x2710) int);
     method @NonNull public android.app.appsearch.SearchSpec.Builder setSnippetCountPerProperty(@IntRange(from=0, to=0x2710) int);
@@ -647,6 +763,19 @@ package android.app.appsearch {
     method @NonNull public android.app.appsearch.SearchSuggestionSpec.Builder setRankingStrategy(int);
   }
 
+  @FlaggedApi("com.android.appsearch.flags.enable_blob_store") public class SetBlobVisibilityRequest {
+    method @NonNull public java.util.Set<java.lang.String> getNamespacesNotDisplayedBySystem();
+    method @NonNull public java.util.Map<java.lang.String,java.util.Set<android.app.appsearch.SchemaVisibilityConfig>> getNamespacesVisibleToConfigs();
+  }
+
+  public static final class SetBlobVisibilityRequest.Builder {
+    ctor public SetBlobVisibilityRequest.Builder();
+    method @NonNull public android.app.appsearch.SetBlobVisibilityRequest.Builder addNamespaceVisibleToConfig(@NonNull String, @NonNull android.app.appsearch.SchemaVisibilityConfig);
+    method @NonNull public android.app.appsearch.SetBlobVisibilityRequest build();
+    method @NonNull public android.app.appsearch.SetBlobVisibilityRequest.Builder clearNamespaceVisibleToConfigs(@NonNull String);
+    method @NonNull public android.app.appsearch.SetBlobVisibilityRequest.Builder setNamespaceDisplayedBySystem(@NonNull String, boolean);
+  }
+
   public final class SetSchemaRequest {
     method @NonNull public java.util.Map<java.lang.String,android.app.appsearch.Migrator> getMigrators();
     method @FlaggedApi("com.android.appsearch.flags.enable_set_publicly_visible_schema") @NonNull public java.util.Map<java.lang.String,android.app.appsearch.PackageIdentifier> getPubliclyVisibleSchemas();
@@ -667,13 +796,16 @@ package android.app.appsearch {
 
   public static final class SetSchemaRequest.Builder {
     ctor public SetSchemaRequest.Builder();
+    ctor @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") public SetSchemaRequest.Builder(@NonNull android.app.appsearch.SetSchemaRequest);
     method @NonNull public android.app.appsearch.SetSchemaRequest.Builder addRequiredPermissionsForSchemaTypeVisibility(@NonNull String, @NonNull java.util.Set<java.lang.Integer>);
     method @FlaggedApi("com.android.appsearch.flags.enable_set_schema_visible_to_configs") @NonNull public android.app.appsearch.SetSchemaRequest.Builder addSchemaTypeVisibleToConfig(@NonNull String, @NonNull android.app.appsearch.SchemaVisibilityConfig);
     method @NonNull public android.app.appsearch.SetSchemaRequest.Builder addSchemas(@NonNull android.app.appsearch.AppSearchSchema...);
     method @NonNull public android.app.appsearch.SetSchemaRequest.Builder addSchemas(@NonNull java.util.Collection<android.app.appsearch.AppSearchSchema>);
     method @NonNull public android.app.appsearch.SetSchemaRequest build();
+    method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.SetSchemaRequest.Builder clearMigrators();
     method @NonNull public android.app.appsearch.SetSchemaRequest.Builder clearRequiredPermissionsForSchemaTypeVisibility(@NonNull String);
     method @FlaggedApi("com.android.appsearch.flags.enable_set_schema_visible_to_configs") @NonNull public android.app.appsearch.SetSchemaRequest.Builder clearSchemaTypeVisibleToConfigs(@NonNull String);
+    method @FlaggedApi("com.android.appsearch.flags.enable_additional_builder_copy_constructors") @NonNull public android.app.appsearch.SetSchemaRequest.Builder clearSchemas();
     method @NonNull public android.app.appsearch.SetSchemaRequest.Builder setForceOverride(boolean);
     method @NonNull public android.app.appsearch.SetSchemaRequest.Builder setMigrator(@NonNull String, @NonNull android.app.appsearch.Migrator);
     method @NonNull public android.app.appsearch.SetSchemaRequest.Builder setMigrators(@NonNull java.util.Map<java.lang.String,android.app.appsearch.Migrator>);
@@ -721,6 +853,8 @@ package android.app.appsearch {
     method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public final int describeContents();
     method public int getAliveDocumentsCount();
     method public int getAliveNamespacesCount();
+    method @FlaggedApi("com.android.appsearch.flags.enable_blob_store") public int getBlobCount();
+    method @FlaggedApi("com.android.appsearch.flags.enable_blob_store") public long getBlobSizeBytes();
     method public long getSizeBytes();
     method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public void writeToParcel(@NonNull android.os.Parcel, int);
     field @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") @NonNull public static final android.os.Parcelable.Creator<android.app.appsearch.StorageInfo> CREATOR;
@@ -731,70 +865,158 @@ package android.app.appsearch {
     method @NonNull public android.app.appsearch.StorageInfo build();
     method @NonNull public android.app.appsearch.StorageInfo.Builder setAliveDocumentsCount(int);
     method @NonNull public android.app.appsearch.StorageInfo.Builder setAliveNamespacesCount(int);
+    method @FlaggedApi("com.android.appsearch.flags.enable_blob_store") @NonNull public android.app.appsearch.StorageInfo.Builder setBlobCount(int);
+    method @FlaggedApi("com.android.appsearch.flags.enable_blob_store") @NonNull public android.app.appsearch.StorageInfo.Builder setBlobSizeBytes(long);
     method @NonNull public android.app.appsearch.StorageInfo.Builder setSizeBytes(long);
   }
 
 }
 
-package android.app.appsearch.exceptions {
+package android.app.appsearch.ast {
 
-  public class AppSearchException extends java.lang.Exception {
-    ctor public AppSearchException(int);
-    ctor public AppSearchException(int, @Nullable String);
-    ctor public AppSearchException(int, @Nullable String, @Nullable Throwable);
-    method public int getResultCode();
-    method @NonNull public <T> android.app.appsearch.AppSearchResult<T> toAppSearchResult();
+  @FlaggedApi("com.android.appsearch.flags.enable_abstract_syntax_trees") public interface FunctionNode extends android.app.appsearch.ast.Node {
+    method @NonNull public String getFunctionName();
+    field public static final String FUNCTION_NAME_GET_SEARCH_STRING_PARAMETER = "getSearchStringParameter";
+    field public static final String FUNCTION_NAME_HAS_PROPERTY = "hasProperty";
+    field public static final String FUNCTION_NAME_PROPERTY_DEFINED = "propertyDefined";
+    field public static final String FUNCTION_NAME_SEARCH = "search";
+    field public static final String FUNCTION_NAME_SEMANTIC_SEARCH = "semanticSearch";
+  }
+
+  @FlaggedApi("com.android.appsearch.flags.enable_abstract_syntax_trees") public final class NegationNode implements android.app.appsearch.ast.Node {
+    ctor public NegationNode(@NonNull android.app.appsearch.ast.Node);
+    method @NonNull public android.app.appsearch.ast.Node getChild();
+    method @NonNull public java.util.List<android.app.appsearch.ast.Node> getChildren();
+    method public void setChild(@NonNull android.app.appsearch.ast.Node);
+  }
+
+  @FlaggedApi("com.android.appsearch.flags.enable_abstract_syntax_trees") public interface Node {
+    method @NonNull public default java.util.List<android.app.appsearch.ast.Node> getChildren();
+  }
+
+  @FlaggedApi("com.android.appsearch.flags.enable_abstract_syntax_trees") public final class TextNode implements android.app.appsearch.ast.Node {
+    ctor public TextNode(@NonNull String);
+    ctor public TextNode(@NonNull android.app.appsearch.ast.TextNode);
+    method @NonNull public String getValue();
+    method public boolean isPrefix();
+    method public boolean isVerbatim();
+    method public void setPrefix(boolean);
+    method public void setValue(@NonNull String);
+    method public void setVerbatim(boolean);
+  }
+
+}
+
+package android.app.appsearch.ast.operators {
+
+  @FlaggedApi("com.android.appsearch.flags.enable_abstract_syntax_trees") public final class AndNode implements android.app.appsearch.ast.Node {
+    ctor public AndNode(@NonNull java.util.List<android.app.appsearch.ast.Node>);
+    ctor public AndNode(@NonNull android.app.appsearch.ast.Node, @NonNull android.app.appsearch.ast.Node, @NonNull android.app.appsearch.ast.Node...);
+    method public void addChild(@NonNull android.app.appsearch.ast.Node);
+    method @NonNull public java.util.List<android.app.appsearch.ast.Node> getChildren();
+    method public int getIndexOfChild(@NonNull android.app.appsearch.ast.Node);
+    method public boolean removeChild(@NonNull android.app.appsearch.ast.Node);
+    method public void setChild(int, @NonNull android.app.appsearch.ast.Node);
+    method public void setChildren(@NonNull java.util.List<android.app.appsearch.ast.Node>);
+  }
+
+  @FlaggedApi("com.android.appsearch.flags.enable_abstract_syntax_trees") public final class ComparatorNode implements android.app.appsearch.ast.Node {
+    ctor public ComparatorNode(int, @NonNull android.app.appsearch.PropertyPath, long);
+    method public int getComparator();
+    method @NonNull public android.app.appsearch.PropertyPath getPropertyPath();
+    method public long getValue();
+    method public void setComparator(int);
+    method public void setPropertyPath(@NonNull android.app.appsearch.PropertyPath);
+    method public void setValue(long);
+    field public static final int EQUALS = 0; // 0x0
+    field public static final int GREATER_EQUALS = 4; // 0x4
+    field public static final int GREATER_THAN = 3; // 0x3
+    field public static final int LESS_EQUALS = 2; // 0x2
+    field public static final int LESS_THAN = 1; // 0x1
+  }
+
+  @FlaggedApi("com.android.appsearch.flags.enable_abstract_syntax_trees") public final class OrNode implements android.app.appsearch.ast.Node {
+    ctor public OrNode(@NonNull java.util.List<android.app.appsearch.ast.Node>);
+    ctor public OrNode(@NonNull android.app.appsearch.ast.Node, @NonNull android.app.appsearch.ast.Node, @NonNull android.app.appsearch.ast.Node...);
+    method public void addChild(@NonNull android.app.appsearch.ast.Node);
+    method @NonNull public java.util.List<android.app.appsearch.ast.Node> getChildren();
+    method public int getIndexOfChild(@NonNull android.app.appsearch.ast.Node);
+    method public boolean removeChild(@NonNull android.app.appsearch.ast.Node);
+    method public void setChild(int, @NonNull android.app.appsearch.ast.Node);
+    method public void setChildren(@NonNull java.util.List<android.app.appsearch.ast.Node>);
+  }
+
+  @FlaggedApi("com.android.appsearch.flags.enable_abstract_syntax_trees") public final class PropertyRestrictNode implements android.app.appsearch.ast.Node {
+    ctor public PropertyRestrictNode(@NonNull android.app.appsearch.PropertyPath, @NonNull android.app.appsearch.ast.Node);
+    method @NonNull public android.app.appsearch.ast.Node getChild();
+    method @NonNull public java.util.List<android.app.appsearch.ast.Node> getChildren();
+    method @NonNull public android.app.appsearch.PropertyPath getProperty();
+    method public void setChild(@NonNull android.app.appsearch.ast.Node);
+    method public void setProperty(@NonNull android.app.appsearch.PropertyPath);
   }
 
 }
 
-package android.app.appsearch.functions {
+package android.app.appsearch.ast.query {
 
-  @FlaggedApi("com.android.appsearch.flags.enable_app_functions") public final class AppFunctionManager {
-    method public void executeAppFunction(@NonNull android.app.appsearch.functions.ExecuteAppFunctionRequest, @NonNull java.util.concurrent.Executor, @NonNull java.util.function.Consumer<android.app.appsearch.AppSearchResult<android.app.appsearch.functions.ExecuteAppFunctionResponse>>);
-    field public static final String PERMISSION_BIND_APP_FUNCTION_SERVICE = "android.permission.BIND_APP_FUNCTION_SERVICE";
+  @FlaggedApi("com.android.appsearch.flags.enable_abstract_syntax_trees") public final class GetSearchStringParameterNode implements android.app.appsearch.ast.FunctionNode {
+    ctor public GetSearchStringParameterNode(int);
+    method @NonNull public String getFunctionName();
+    method public int getSearchStringIndex();
+    method public void setSearchStringIndex(int);
   }
 
-  @FlaggedApi("com.android.appsearch.flags.enable_app_functions") public abstract class AppFunctionService extends android.app.Service {
-    ctor public AppFunctionService();
-    method @NonNull public final android.os.IBinder onBind(@Nullable android.content.Intent);
-    method @MainThread public abstract void onExecuteFunction(@NonNull android.app.appsearch.functions.ExecuteAppFunctionRequest, @NonNull java.util.function.Consumer<android.app.appsearch.AppSearchResult<android.app.appsearch.functions.ExecuteAppFunctionResponse>>);
-    field @NonNull public static final String SERVICE_INTERFACE = "android.app.appsearch.functions.AppFunctionService";
+  @FlaggedApi("com.android.appsearch.flags.enable_abstract_syntax_trees") public final class HasPropertyNode implements android.app.appsearch.ast.FunctionNode {
+    ctor public HasPropertyNode(@NonNull android.app.appsearch.PropertyPath);
+    method @NonNull public String getFunctionName();
+    method @NonNull public android.app.appsearch.PropertyPath getProperty();
+    method public void setProperty(@NonNull android.app.appsearch.PropertyPath);
   }
 
-  @FlaggedApi("com.android.appsearch.flags.enable_app_functions") public final class ExecuteAppFunctionRequest implements android.os.Parcelable {
-    method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public final int describeContents();
-    method @NonNull public android.os.Bundle getExtras();
-    method @NonNull public String getFunctionIdentifier();
-    method @NonNull public android.app.appsearch.GenericDocument getParameters();
-    method @Nullable public byte[] getSha256Certificate();
-    method @NonNull public String getTargetPackageName();
-    method public void writeToParcel(@NonNull android.os.Parcel, int);
-    field @NonNull public static final android.os.Parcelable.Creator<android.app.appsearch.functions.ExecuteAppFunctionRequest> CREATOR;
+  @FlaggedApi("com.android.appsearch.flags.enable_abstract_syntax_trees") public final class PropertyDefinedNode implements android.app.appsearch.ast.FunctionNode {
+    ctor public PropertyDefinedNode(@NonNull android.app.appsearch.PropertyPath);
+    method @NonNull public String getFunctionName();
+    method @NonNull public android.app.appsearch.PropertyPath getProperty();
+    method public void setProperty(@NonNull android.app.appsearch.PropertyPath);
   }
 
-  @FlaggedApi("com.android.appsearch.flags.enable_app_functions") public static final class ExecuteAppFunctionRequest.Builder {
-    ctor public ExecuteAppFunctionRequest.Builder(@NonNull String, @NonNull String);
-    method @NonNull public android.app.appsearch.functions.ExecuteAppFunctionRequest build();
-    method @NonNull public android.app.appsearch.functions.ExecuteAppFunctionRequest.Builder setExtras(@NonNull android.os.Bundle);
-    method @NonNull public android.app.appsearch.functions.ExecuteAppFunctionRequest.Builder setParameters(@NonNull android.app.appsearch.GenericDocument);
-    method @NonNull public android.app.appsearch.functions.ExecuteAppFunctionRequest.Builder setSha256Certificate(@Nullable byte[]);
+  @FlaggedApi("com.android.appsearch.flags.enable_abstract_syntax_trees") public final class SearchNode implements android.app.appsearch.ast.FunctionNode {
+    ctor public SearchNode(@NonNull android.app.appsearch.ast.Node, @NonNull java.util.List<android.app.appsearch.PropertyPath>);
+    ctor public SearchNode(@NonNull android.app.appsearch.ast.Node);
+    method public void addProperty(@NonNull android.app.appsearch.PropertyPath);
+    method @NonNull public android.app.appsearch.ast.Node getChild();
+    method @NonNull public java.util.List<android.app.appsearch.ast.Node> getChildren();
+    method @NonNull public String getFunctionName();
+    method @NonNull public java.util.List<android.app.appsearch.PropertyPath> getProperties();
+    method public void setChild(@NonNull android.app.appsearch.ast.Node);
+    method public void setProperties(@NonNull java.util.List<android.app.appsearch.PropertyPath>);
   }
 
-  @FlaggedApi("com.android.appsearch.flags.enable_app_functions") public final class ExecuteAppFunctionResponse implements android.os.Parcelable {
-    method @FlaggedApi("com.android.appsearch.flags.enable_safe_parcelable_2") public final int describeContents();
-    method @NonNull public android.os.Bundle getExtras();
-    method @NonNull public android.app.appsearch.GenericDocument getResult();
-    method public void writeToParcel(@NonNull android.os.Parcel, int);
-    field @NonNull public static final android.os.Parcelable.Creator<android.app.appsearch.functions.ExecuteAppFunctionResponse> CREATOR;
-    field public static final String PROPERTY_RESULT = "result";
+  @FlaggedApi("com.android.appsearch.flags.enable_abstract_syntax_trees") public final class SemanticSearchNode implements android.app.appsearch.ast.FunctionNode {
+    ctor public SemanticSearchNode(int, float, float, int);
+    ctor public SemanticSearchNode(int, float, float);
+    ctor public SemanticSearchNode(int, float);
+    ctor public SemanticSearchNode(int);
+    method public int getDistanceMetric();
+    method @NonNull public String getFunctionName();
+    method public float getLowerBound();
+    method public float getUpperBound();
+    method public int getVectorIndex();
+    method public void setBounds(float, float);
+    method public void setDistanceMetric(int);
+    method public void setVectorIndex(int);
   }
 
-  @FlaggedApi("com.android.appsearch.flags.enable_app_functions") public static final class ExecuteAppFunctionResponse.Builder {
-    ctor public ExecuteAppFunctionResponse.Builder();
-    method @NonNull public android.app.appsearch.functions.ExecuteAppFunctionResponse build();
-    method @NonNull public android.app.appsearch.functions.ExecuteAppFunctionResponse.Builder setExtras(@NonNull android.os.Bundle);
-    method @NonNull public android.app.appsearch.functions.ExecuteAppFunctionResponse.Builder setResult(@NonNull android.app.appsearch.GenericDocument);
+}
+
+package android.app.appsearch.exceptions {
+
+  public class AppSearchException extends java.lang.Exception {
+    ctor public AppSearchException(int);
+    ctor public AppSearchException(int, @Nullable String);
+    ctor public AppSearchException(int, @Nullable String, @Nullable Throwable);
+    method public int getResultCode();
+    method @NonNull public <T> android.app.appsearch.AppSearchResult<T> toAppSearchResult();
   }
 
 }
diff --git a/framework/api/system-current.txt b/framework/api/system-current.txt
index 0114c5dd..4a6194e2 100644
--- a/framework/api/system-current.txt
+++ b/framework/api/system-current.txt
@@ -7,11 +7,3 @@ package android.app.appsearch {
 
 }
 
-package android.app.appsearch.functions {
-
-  @FlaggedApi("com.android.appsearch.flags.enable_app_functions") public final class AppFunctionManager {
-    field public static final String PERMISSION_EXECUTE_APP_FUNCTION = "android.permission.EXECUTE_APP_FUNCTION";
-  }
-
-}
-
diff --git a/framework/java/android/app/appsearch/AppSearchManager.java b/framework/java/android/app/appsearch/AppSearchManager.java
index e0b9473c..e56e654a 100644
--- a/framework/java/android/app/appsearch/AppSearchManager.java
+++ b/framework/java/android/app/appsearch/AppSearchManager.java
@@ -22,7 +22,6 @@ import android.annotation.SystemService;
 import android.annotation.UserHandleAware;
 import android.app.appsearch.aidl.AppSearchAttributionSource;
 import android.app.appsearch.aidl.IAppSearchManager;
-import android.app.appsearch.functions.AppFunctionManager;
 import android.content.Context;
 import android.os.Process;
 
@@ -127,13 +126,11 @@ public class AppSearchManager {
 
     private final IAppSearchManager mService;
     private final Context mContext;
-    private final AppFunctionManager mAppFunctionManager;
 
     /** @hide */
     public AppSearchManager(@NonNull Context context, @NonNull IAppSearchManager service) {
         mContext = Objects.requireNonNull(context);
         mService = Objects.requireNonNull(service);
-        mAppFunctionManager = new AppFunctionManager(context, service);
     }
 
     /** Contains information about how to create the search session. */
@@ -279,11 +276,4 @@ public class AppSearchManager {
                 executor,
                 callback);
     }
-
-    /** Returns an instance of {@link android.app.appsearch.functions.AppFunctionManager}. */
-    @FlaggedApi(Flags.FLAG_ENABLE_APP_FUNCTIONS)
-    @NonNull
-    public AppFunctionManager getAppFunctionManager() {
-        return mAppFunctionManager;
-    }
 }
diff --git a/framework/java/android/app/appsearch/AppSearchMigrationHelper.java b/framework/java/android/app/appsearch/AppSearchMigrationHelper.java
index 11ffe38c..4eab5302 100644
--- a/framework/java/android/app/appsearch/AppSearchMigrationHelper.java
+++ b/framework/java/android/app/appsearch/AppSearchMigrationHelper.java
@@ -25,9 +25,8 @@ import android.annotation.Nullable;
 import android.annotation.WorkerThread;
 import android.app.appsearch.SetSchemaResponse.MigrationFailure;
 import android.app.appsearch.aidl.AppSearchAttributionSource;
-import android.app.appsearch.aidl.AppSearchResultParcel;
+import android.app.appsearch.aidl.AppSearchResultCallback;
 import android.app.appsearch.aidl.IAppSearchManager;
-import android.app.appsearch.aidl.IAppSearchResultCallback;
 import android.app.appsearch.aidl.PutDocumentsFromFileAidlRequest;
 import android.app.appsearch.aidl.WriteSearchResultsToFileAidlRequest;
 import android.app.appsearch.exceptions.AppSearchException;
@@ -156,10 +155,10 @@ public class AppSearchMigrationHelper implements Closeable {
                                     .build(),
                             mUserHandle,
                             /* binderCallStartTimeMillis= */ SystemClock.elapsedRealtime()),
-                    new IAppSearchResultCallback.Stub() {
+                    new AppSearchResultCallback<Void>() {
                         @Override
-                        public void onResult(AppSearchResultParcel resultParcel) {
-                            resultReference.set(resultParcel.getResult());
+                        public void onResult(@NonNull AppSearchResult<Void> result) {
+                            resultReference.set(result);
                             latch.countDown();
                         }
                     });
@@ -214,10 +213,11 @@ public class AppSearchMigrationHelper implements Closeable {
                             schemaMigrationStatsBuilder.build(),
                             totalLatencyStartTimeMillis,
                             /* binderCallStartTimeMillis= */ SystemClock.elapsedRealtime()),
-                    new IAppSearchResultCallback.Stub() {
+                    new AppSearchResultCallback<List<MigrationFailure>>() {
                         @Override
-                        public void onResult(AppSearchResultParcel resultParcel) {
-                            resultReference.set(resultParcel.getResult());
+                        public void onResult(
+                                @NonNull AppSearchResult<List<MigrationFailure>> result) {
+                            resultReference.set(result);
                             latch.countDown();
                         }
                     });
diff --git a/framework/java/android/app/appsearch/AppSearchSession.java b/framework/java/android/app/appsearch/AppSearchSession.java
index b01cba74..3486f90a 100644
--- a/framework/java/android/app/appsearch/AppSearchSession.java
+++ b/framework/java/android/app/appsearch/AppSearchSession.java
@@ -20,11 +20,14 @@ import static android.app.appsearch.AppSearchResult.RESULT_INTERNAL_ERROR;
 import static android.app.appsearch.SearchSessionUtil.safeExecute;
 
 import android.annotation.CallbackExecutor;
+import android.annotation.FlaggedApi;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.app.appsearch.aidl.AppSearchAttributionSource;
 import android.app.appsearch.aidl.AppSearchBatchResultParcel;
+import android.app.appsearch.aidl.AppSearchResultCallback;
 import android.app.appsearch.aidl.AppSearchResultParcel;
+import android.app.appsearch.aidl.CommitBlobAidlRequest;
 import android.app.appsearch.aidl.DocumentsParcel;
 import android.app.appsearch.aidl.GetDocumentsAidlRequest;
 import android.app.appsearch.aidl.GetNamespacesAidlRequest;
@@ -32,14 +35,17 @@ import android.app.appsearch.aidl.GetSchemaAidlRequest;
 import android.app.appsearch.aidl.GetStorageInfoAidlRequest;
 import android.app.appsearch.aidl.IAppSearchBatchResultCallback;
 import android.app.appsearch.aidl.IAppSearchManager;
-import android.app.appsearch.aidl.IAppSearchResultCallback;
 import android.app.appsearch.aidl.InitializeAidlRequest;
+import android.app.appsearch.aidl.OpenBlobForReadAidlRequest;
+import android.app.appsearch.aidl.OpenBlobForWriteAidlRequest;
 import android.app.appsearch.aidl.PersistToDiskAidlRequest;
 import android.app.appsearch.aidl.PutDocumentsAidlRequest;
+import android.app.appsearch.aidl.RemoveBlobAidlRequest;
 import android.app.appsearch.aidl.RemoveByDocumentIdAidlRequest;
 import android.app.appsearch.aidl.RemoveByQueryAidlRequest;
 import android.app.appsearch.aidl.ReportUsageAidlRequest;
 import android.app.appsearch.aidl.SearchSuggestionAidlRequest;
+import android.app.appsearch.aidl.SetBlobVisibilityAidlRequest;
 import android.app.appsearch.aidl.SetSchemaAidlRequest;
 import android.app.appsearch.exceptions.AppSearchException;
 import android.app.appsearch.safeparcel.GenericDocumentParcel;
@@ -53,6 +59,7 @@ import android.os.UserHandle;
 import android.util.ArraySet;
 import android.util.Log;
 
+import com.android.appsearch.flags.Flags;
 import com.android.internal.util.Preconditions;
 
 import java.io.Closeable;
@@ -137,15 +144,13 @@ public final class AppSearchSession implements Closeable {
                             mCallerAttributionSource,
                             mUserHandle,
                             /* binderCallStartTimeMillis= */ SystemClock.elapsedRealtime()),
-                    new IAppSearchResultCallback.Stub() {
+                    new AppSearchResultCallback<AppSearchSession>() {
                         @Override
-                        @SuppressWarnings({"rawtypes", "unchecked"})
-                        public void onResult(AppSearchResultParcel resultParcel) {
+                        public void onResult(@NonNull AppSearchResult<AppSearchSession> result) {
                             safeExecute(
                                     executor,
                                     callback,
                                     () -> {
-                                        AppSearchResult<Void> result = resultParcel.getResult();
                                         if (result.isSuccess()) {
                                             callback.accept(
                                                     AppSearchResult.newSuccessfulResult(
@@ -251,16 +256,13 @@ public final class AppSearchSession implements Closeable {
                             mUserHandle,
                             /* binderCallStartTimeMillis= */ SystemClock.elapsedRealtime(),
                             /* isForEnterprise= */ false),
-                    new IAppSearchResultCallback.Stub() {
+                    new AppSearchResultCallback<GetSchemaResponse>() {
                         @Override
-                        @SuppressWarnings({"rawtypes", "unchecked"})
-                        public void onResult(AppSearchResultParcel resultParcel) {
+                        public void onResult(@NonNull AppSearchResult<GetSchemaResponse> result) {
                             safeExecute(
                                     executor,
                                     callback,
                                     () -> {
-                                        AppSearchResult<GetSchemaResponse> result =
-                                                resultParcel.getResult();
                                         if (result.isSuccess()) {
                                             GetSchemaResponse response =
                                                     Objects.requireNonNull(result.getResultValue());
@@ -297,22 +299,19 @@ public final class AppSearchSession implements Closeable {
                             mDatabaseName,
                             mUserHandle,
                             /* binderCallStartTimeMillis= */ SystemClock.elapsedRealtime()),
-                    new IAppSearchResultCallback.Stub() {
+                    new AppSearchResultCallback<List<String>>() {
                         @Override
-                        @SuppressWarnings({"rawtypes", "unchecked"})
-                        public void onResult(AppSearchResultParcel resultParcel) {
+                        public void onResult(@NonNull AppSearchResult<List<String>> result) {
                             safeExecute(
                                     executor,
                                     callback,
                                     () -> {
-                                        AppSearchResult<List<String>> result =
-                                                resultParcel.getResult();
                                         if (result.isSuccess()) {
-                                            Set<String> namespaces =
-                                                    new ArraySet<>(result.getResultValue());
+                                            List<String> namespaces =
+                                                    Objects.requireNonNull(result.getResultValue());
                                             callback.accept(
                                                     AppSearchResult.newSuccessfulResult(
-                                                            namespaces));
+                                                            new ArraySet<>(namespaces)));
                                         } else {
                                             callback.accept(
                                                     AppSearchResult.newFailedResult(result));
@@ -428,6 +427,254 @@ public final class AppSearchSession implements Closeable {
         }
     }
 
+    /**
+     * Opens a batch of AppSearch Blobs for writing.
+     *
+     * <p>A "blob" is a large binary object. It is used to store a significant amount of data that
+     * is not searchable, such as images, videos, audio files, or other binary data. Unlike other
+     * fields in AppSearch, blobs are stored as blob files on disk rather than in memory, and use
+     * {@link android.os.ParcelFileDescriptor} to read and write. This allows for efficient handling
+     * of large, non-searchable content.
+     *
+     * <p>Once done writing, call {@link #commitBlob} to commit blob files.
+     *
+     * <p>This call will create a empty blob file for each given {@link AppSearchBlobHandle}, and a
+     * {@link android.os.ParcelFileDescriptor} of that blob file will be returned in the {@link
+     * OpenBlobForWriteResponse}.
+     *
+     * <p>If the blob file is already stored in AppSearch and committed. A failed {@link
+     * AppSearchResult} with error code {@link AppSearchResult#RESULT_ALREADY_EXISTS} will be
+     * associated with the {@link AppSearchBlobHandle}.
+     *
+     * <p>If the blob file is already stored in AppSearch but not committed. A {@link
+     * android.os.ParcelFileDescriptor} of that blob file will be returned for continue writing.
+     *
+     * <p>For given duplicate {@link AppSearchBlobHandle}, the same {@link
+     * android.os.ParcelFileDescriptor} pointing to the same blob file will be returned.
+     *
+     * <p>Pending blob files won't be lost or auto-commit if {@link AppSearchSession} closed.
+     * Pending blob files will be stored in disk rather than memory. You can re-open {@link
+     * AppSearchSession} and re-write the pending blob files.
+     *
+     * <p>A committed blob file will be considered as an orphan if no {@link GenericDocument}
+     * references it. Uncommitted pending blob files and orphan blobs files will be cleaned up if
+     * they has been created for an extended period (default is 1 week).
+     *
+     * <p class="caution">The returned {@link OpenBlobForWriteResponse} must be closed after use to
+     * avoid resource leaks. Failing to close it will result in system file descriptor exhaustion.
+     *
+     * @param handles The {@link AppSearchBlobHandle}s that identifies the blobs.
+     * @param executor Executor on which to invoke the callback.
+     * @param callback Callback to receive the {@link OpenBlobForWriteResponse}.
+     * @see GenericDocument.Builder#setPropertyBlobHandle
+     */
+    @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void openBlobForWrite(
+            @NonNull Set<AppSearchBlobHandle> handles,
+            @NonNull @CallbackExecutor Executor executor,
+            @NonNull Consumer<AppSearchResult<OpenBlobForWriteResponse>> callback) {
+        Preconditions.checkState(!mIsClosed, "AppSearchSession has already been closed");
+        try {
+            mService.openBlobForWrite(
+                    new OpenBlobForWriteAidlRequest(
+                            mCallerAttributionSource,
+                            mDatabaseName,
+                            new ArrayList<>(handles),
+                            mUserHandle,
+                            /* binderCallStartTimeMillis= */ SystemClock.elapsedRealtime()),
+                    new AppSearchResultCallback<OpenBlobForWriteResponse>() {
+                        @Override
+                        public void onResult(
+                                @NonNull AppSearchResult<OpenBlobForWriteResponse> result) {
+                            safeExecute(executor, callback, () -> callback.accept(result));
+                        }
+                    });
+        } catch (RemoteException e) {
+            ExceptionUtil.handleRemoteException(e);
+        }
+    }
+
+    /**
+     * Removes the blob data from AppSearch.
+     *
+     * <p>After this call, the blob data is removed immediately and cannot be recovered. It will not
+     * accessible via {@link #openBlobForRead}. {@link #openBlobForWrite} could reopen and rewrite
+     * it.
+     *
+     * <p>This API can be used to remove pending blob data and committed blob data.
+     *
+     * <p class="caution">Removing a committed blob data that is still referenced by documents will
+     * leave those documents with no readable blob content. It is highly recommended to let
+     * AppSearch control the blob data's life cycle. AppSearch automatically recycles orphaned and
+     * pending blob data. The default time to recycle pending and orphan blob file is 1 week. A blob
+     * file will be considered as an orphan if no {@link GenericDocument} references it. If you want
+     * to remove a committed blob data, you should remove the reference documents first.
+     *
+     * @param handles The {@link AppSearchBlobHandle}s that identifies the blobs.
+     * @param executor Executor on which to invoke the callback.
+     * @param callback Callback to receive the {@link CommitBlobResponse}.
+     * @see GenericDocument.Builder#setPropertyBlobHandle
+     */
+    @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void removeBlob(
+            @NonNull Set<AppSearchBlobHandle> handles,
+            @NonNull @CallbackExecutor Executor executor,
+            @NonNull Consumer<AppSearchResult<RemoveBlobResponse>> callback) {
+        Preconditions.checkState(!mIsClosed, "AppSearchSession has already been closed");
+        try {
+            mService.removeBlob(
+                    new RemoveBlobAidlRequest(
+                            mCallerAttributionSource,
+                            mDatabaseName,
+                            new ArrayList<>(handles),
+                            mUserHandle,
+                            /* binderCallStartTimeMillis= */ SystemClock.elapsedRealtime()),
+                    new AppSearchResultCallback<RemoveBlobResponse>() {
+                        @Override
+                        public void onResult(@NonNull AppSearchResult<RemoveBlobResponse> result) {
+                            safeExecute(executor, callback, () -> callback.accept(result));
+                        }
+                    });
+        } catch (RemoteException e) {
+            ExceptionUtil.handleRemoteException(e);
+        }
+    }
+
+    /**
+     * Commits the blobs to make it retrievable and immutable.
+     *
+     * <p>After this call, the blob is readable via {@link #openBlobForRead}. Any change to the
+     * content or rewrite via {@link #openBlobForWrite} of this blob won't be allowed.
+     *
+     * <p>If the blob is already stored in AppSearch and committed. A failed {@link AppSearchResult}
+     * with error code {@link AppSearchResult#I} will be associated with the {@link
+     * AppSearchBlobHandle}.
+     *
+     * <p>If the blob content doesn't match the digest in {@link AppSearchBlobHandle}, a failed
+     * {@link AppSearchResult} with error code {@link AppSearchResult#RESULT_INVALID_ARGUMENT} will
+     * be associated with the {@link AppSearchBlobHandle}. The pending Blob file will be removed
+     * from AppSearch.
+     *
+     * <p>Pending blobs won't be lost or auto-commit if {@link AppSearchSession} closed. Pending
+     * blobs will store in disk rather than memory. You can re-open {@link AppSearchSession} and
+     * re-write the pending blobs.
+     *
+     * <p>The default time to recycle pending and orphan blobs is 1 week. A blob will be considered
+     * as an orphan if no {@link GenericDocument} references it.
+     *
+     * @param handles The {@link AppSearchBlobHandle}s that identifies the blobs.
+     * @param executor Executor on which to invoke the callback.
+     * @param callback Callback to receive the {@link CommitBlobResponse}.
+     * @see GenericDocument.Builder#setPropertyBlobHandle
+     */
+    @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void commitBlob(
+            @NonNull Set<AppSearchBlobHandle> handles,
+            @NonNull @CallbackExecutor Executor executor,
+            @NonNull Consumer<AppSearchResult<CommitBlobResponse>> callback) {
+        Preconditions.checkState(!mIsClosed, "AppSearchSession has already been closed");
+        try {
+            mService.commitBlob(
+                    new CommitBlobAidlRequest(
+                            mCallerAttributionSource,
+                            mDatabaseName,
+                            new ArrayList<>(handles),
+                            mUserHandle,
+                            /* binderCallStartTimeMillis= */ SystemClock.elapsedRealtime()),
+                    new AppSearchResultCallback<CommitBlobResponse>() {
+                        @Override
+                        public void onResult(@NonNull AppSearchResult<CommitBlobResponse> result) {
+                            safeExecute(executor, callback, () -> callback.accept(result));
+                        }
+                    });
+        } catch (RemoteException e) {
+            ExceptionUtil.handleRemoteException(e);
+        }
+    }
+
+    /**
+     * Opens a batch of AppSearch Blobs for reading.
+     *
+     * <p>Only blobs committed via {@link #commitBlob} are available for reading.
+     *
+     * <p class="caution">The returned {@link OpenBlobForReadResponse} must be closed after use to
+     * avoid resource leaks. Failing to close it will result in system file descriptor exhaustion.
+     *
+     * @param handles The {@link AppSearchBlobHandle}s that identifies the blobs.
+     * @param executor Executor on which to invoke the callback.
+     * @param callback Callback to receive the {@link OpenBlobForReadResponse}.
+     * @see GenericDocument.Builder#setPropertyBlobHandle
+     */
+    @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void openBlobForRead(
+            @NonNull Set<AppSearchBlobHandle> handles,
+            @NonNull @CallbackExecutor Executor executor,
+            @NonNull Consumer<AppSearchResult<OpenBlobForReadResponse>> callback) {
+        Preconditions.checkState(!mIsClosed, "AppSearchSession has already been closed");
+        try {
+            mService.openBlobForRead(
+                    new OpenBlobForReadAidlRequest(
+                            mCallerAttributionSource,
+                            mDatabaseName,
+                            new ArrayList<>(handles),
+                            mUserHandle,
+                            /* binderCallStartTimeMillis= */ SystemClock.elapsedRealtime()),
+                    new AppSearchResultCallback<OpenBlobForReadResponse>() {
+                        @Override
+                        public void onResult(
+                                @NonNull AppSearchResult<OpenBlobForReadResponse> result) {
+                            safeExecute(executor, callback, () -> callback.accept(result));
+                        }
+                    });
+        } catch (RemoteException e) {
+            ExceptionUtil.handleRemoteException(e);
+        }
+    }
+
+    /**
+     * Sets the visibility configuration for all blob namespaces within an appsearch database.
+     *
+     * <p>Blobs under the same namespace will share same visibility settings.
+     *
+     * <p>The default setting is blobs will be only visible to the owner package and System. To
+     * configure other kinds of sharing, set {@link SchemaVisibilityConfig} via {@link
+     * SetBlobVisibilityRequest}.
+     *
+     * @param request The request holds visibility settings for all blob namespaces
+     * @param executor Executor on which to invoke the callback.
+     * @param callback Callback to receive the pending result of performing this operation which
+     *     resolves to {@code null} on success.
+     */
+    @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void setBlobVisibility(
+            @NonNull SetBlobVisibilityRequest request,
+            @NonNull @CallbackExecutor Executor executor,
+            @NonNull Consumer<AppSearchResult<Void>> callback) {
+        Preconditions.checkState(!mIsClosed, "AppSearchSession has already been closed");
+        try {
+
+            // Extract a List<VisibilityConfig> from the request
+            List<InternalVisibilityConfig> visibilityConfigs =
+                    InternalVisibilityConfig.toInternalVisibilityConfigs(request);
+
+            mService.setBlobVisibility(
+                    new SetBlobVisibilityAidlRequest(
+                            mCallerAttributionSource,
+                            mDatabaseName,
+                            new ArrayList<>(visibilityConfigs),
+                            mUserHandle,
+                            /* binderCallStartTimeMillis= */ SystemClock.elapsedRealtime()),
+                    new AppSearchResultCallback<Void>() {
+                        @Override
+                        public void onResult(@NonNull AppSearchResult<Void> result) {
+                            safeExecute(executor, callback, () -> callback.accept(result));
+                        }
+                    });
+        } catch (RemoteException e) {
+            ExceptionUtil.handleRemoteException(e);
+        }
+    }
+
     /**
      * Retrieves documents from the open {@link AppSearchSession} that match a given query string
      * and type of search provided.
@@ -536,6 +783,23 @@ public final class AppSearchSession implements Closeable {
      * match documentA. However, `propertyDefined("sender.name")` will match both documentA and
      * documentB, regardless of whether a value is actually set.
      *
+     * <p>LIST_FILTER_MATCH_SCORE_EXPRESSION_FUNCTION: This feature covers the
+     * "matchScoreExpression" function in query expressions.
+     *
+     * <p>Usage: matchScoreExpression({score_expression}, {low}, {high})
+     *
+     * <ul>
+     *   <li>matchScoreExpression matches all documents with scores falling within the specified
+     *       range. These scores are calculated using the provided score expression, which adheres
+     *       to the syntax defined in {@link SearchSpec.Builder#setRankingStrategy(String)}.
+     *   <li>"score_expression" is a string value that specifies the score expression.
+     *   <li>"low" and "high" are floating point numbers that specify the score range. The "high"
+     *       parameter is optional; if not provided, it defaults to positive infinity.
+     * </ul>
+     *
+     * <p>Ex. `matchScoreExpression("this.documentScore()", 3, 4)` will return all documents that
+     * have document scores from 3 to 4.
+     *
      * <p>SCHEMA_EMBEDDING_PROPERTY_CONFIG: This feature covers the "semanticSearch" and
      * "getEmbeddingParameter" functions in query expressions, which are used for semantic search.
      *
@@ -694,29 +958,25 @@ public final class AppSearchSession implements Closeable {
                             searchSuggestionSpec,
                             mUserHandle,
                             /* binderCallStartTimeMillis= */ SystemClock.elapsedRealtime()),
-                    new IAppSearchResultCallback.Stub() {
+                    new AppSearchResultCallback<List<SearchSuggestionResult>>() {
                         @Override
-                        @SuppressWarnings({"rawtypes", "unchecked"})
-                        public void onResult(AppSearchResultParcel resultParcel) {
+                        public void onResult(
+                                @NonNull AppSearchResult<List<SearchSuggestionResult>> result) {
                             safeExecute(
                                     executor,
                                     callback,
                                     () -> {
-                                        try {
-                                            AppSearchResult<List<SearchSuggestionResult>> result =
-                                                    resultParcel.getResult();
-                                            if (result.isSuccess()) {
-                                                callback.accept(result);
-                                            } else {
-                                                // TODO(b/261897334) save SDK errors/crashes and
-                                                // send to
-                                                //  server for logging.
-                                                callback.accept(
-                                                        AppSearchResult.newFailedResult(result));
-                                            }
-                                        } catch (Exception e) {
+                                        if (result.isSuccess()) {
+                                            List<SearchSuggestionResult> suggestions =
+                                                    Objects.requireNonNull(result.getResultValue());
+                                            callback.accept(
+                                                    AppSearchResult.newSuccessfulResult(
+                                                            suggestions));
+                                        } else {
+                                            // TODO(b/261897334) save SDK errors/crashes and
+                                            // send to server for logging.
                                             callback.accept(
-                                                    AppSearchResult.throwableToFailedResult(e));
+                                                    AppSearchResult.newFailedResult(result));
                                         }
                                     });
                         }
@@ -762,14 +1022,10 @@ public final class AppSearchSession implements Closeable {
                             /* systemUsage= */ false,
                             mUserHandle,
                             /* binderCallStartTimeMillis= */ SystemClock.elapsedRealtime()),
-                    new IAppSearchResultCallback.Stub() {
+                    new AppSearchResultCallback<Void>() {
                         @Override
-                        @SuppressWarnings({"rawtypes", "unchecked"})
-                        public void onResult(AppSearchResultParcel resultParcel) {
-                            safeExecute(
-                                    executor,
-                                    callback,
-                                    () -> callback.accept(resultParcel.getResult()));
+                        public void onResult(@NonNull AppSearchResult<Void> result) {
+                            safeExecute(executor, callback, () -> callback.accept(result));
                         }
                     });
             mIsMutated = true;
@@ -886,14 +1142,10 @@ public final class AppSearchSession implements Closeable {
                             searchSpec,
                             mUserHandle,
                             /* binderCallStartTimeMillis= */ SystemClock.elapsedRealtime()),
-                    new IAppSearchResultCallback.Stub() {
+                    new AppSearchResultCallback<Void>() {
                         @Override
-                        @SuppressWarnings({"rawtypes", "unchecked"})
-                        public void onResult(AppSearchResultParcel resultParcel) {
-                            safeExecute(
-                                    executor,
-                                    callback,
-                                    () -> callback.accept(resultParcel.getResult()));
+                        public void onResult(@NonNull AppSearchResult<Void> result) {
+                            safeExecute(executor, callback, () -> callback.accept(result));
                         }
                     });
             mIsMutated = true;
@@ -924,20 +1176,19 @@ public final class AppSearchSession implements Closeable {
                             mDatabaseName,
                             mUserHandle,
                             /* binderCallStartTimeMillis= */ SystemClock.elapsedRealtime()),
-                    new IAppSearchResultCallback.Stub() {
+                    new AppSearchResultCallback<StorageInfo>() {
                         @Override
-                        @SuppressWarnings({"rawtypes", "unchecked"})
-                        public void onResult(AppSearchResultParcel resultParcel) {
+                        public void onResult(@NonNull AppSearchResult<StorageInfo> result) {
                             safeExecute(
                                     executor,
                                     callback,
                                     () -> {
-                                        AppSearchResult<StorageInfo> result =
-                                                resultParcel.getResult();
+                                        StorageInfo storageInfo =
+                                                Objects.requireNonNull(result.getResultValue());
                                         if (result.isSuccess()) {
                                             callback.accept(
                                                     AppSearchResult.newSuccessfulResult(
-                                                            result.getResultValue()));
+                                                            storageInfo));
                                         } else {
                                             callback.accept(
                                                     AppSearchResult.newFailedResult(result));
@@ -994,73 +1245,69 @@ public final class AppSearchSession implements Closeable {
                             mUserHandle,
                             /* binderCallStartTimeMillis= */ SystemClock.elapsedRealtime(),
                             SchemaMigrationStats.NO_MIGRATION);
-            mService.setSchema(
-                    setSchemaAidlRequest,
-                    new IAppSearchResultCallback.Stub() {
-                        @Override
-                        @SuppressWarnings({"rawtypes", "unchecked"})
-                        public void onResult(AppSearchResultParcel resultParcel) {
-                            safeExecute(
-                                    executor,
-                                    callback,
-                                    () -> {
-                                        AppSearchResult<InternalSetSchemaResponse> result =
-                                                resultParcel.getResult();
-                                        if (result.isSuccess()) {
-                                            try {
-                                                InternalSetSchemaResponse
-                                                        internalSetSchemaResponse =
-                                                                result.getResultValue();
-                                                if (internalSetSchemaResponse == null) {
-                                                    // Ideally internalSetSchemaResponse should
-                                                    // always be non-null as result is success. In
-                                                    // other cases we directly put result in
-                                                    // AppSearchResult.newSuccessfulResult which
-                                                    // accepts a Nullable value, here we need to
-                                                    // get response by
-                                                    // internalSetSchemaResponse
-                                                    // .getSetSchemaResponse().
-                                                    callback.accept(
-                                                            AppSearchResult.newFailedResult(
-                                                                    RESULT_INTERNAL_ERROR,
-                                                                    "Received null"
-                                                                            + " InternalSetSchema"
-                                                                            + "Response"
-                                                                            + " during setSchema"
-                                                                            + " call"));
-                                                    return;
-                                                }
-                                                if (!internalSetSchemaResponse.isSuccess()) {
-                                                    // check is the set schema call failed
-                                                    // because incompatible changes. That's the only
-                                                    // case we swallowed in the
-                                                    // AppSearchImpl#setSchema().
-                                                    callback.accept(
-                                                            AppSearchResult.newFailedResult(
-                                                                    AppSearchResult
-                                                                            .RESULT_INVALID_SCHEMA,
-                                                                    internalSetSchemaResponse
-                                                                            .getErrorMessage()));
-                                                    return;
-                                                }
-                                                callback.accept(
-                                                        AppSearchResult.newSuccessfulResult(
-                                                                internalSetSchemaResponse
-                                                                        .getSetSchemaResponse()));
-                                            } catch (RuntimeException e) {
-                                                // TODO(b/261897334) save SDK errors/crashes and
-                                                // send to
-                                                //  server for logging.
-                                                callback.accept(
-                                                        AppSearchResult.throwableToFailedResult(e));
-                                            }
-                                        } else {
+            AppSearchResultCallback<InternalSetSchemaResponse> callbackBase =
+                    new AppSearchResultCallback<>() {
+                @Override
+                public void onResult(@NonNull AppSearchResult<InternalSetSchemaResponse> result) {
+                    safeExecute(
+                            executor,
+                            callback,
+                            () -> {
+                                if (result.isSuccess()) {
+                                    try {
+                                        InternalSetSchemaResponse internalSetSchemaResponse =
+                                                result.getResultValue();
+                                        if (internalSetSchemaResponse == null) {
+                                            // Ideally internalSetSchemaResponse should
+                                            // always be non-null as result is success. In
+                                            // other cases we directly put result in
+                                            // AppSearchResult.newSuccessfulResult which
+                                            // accepts a Nullable value, here we need to
+                                            // get response by
+                                            // internalSetSchemaResponse
+                                            // .getSetSchemaResponse().
                                             callback.accept(
-                                                    AppSearchResult.newFailedResult(result));
+                                                    AppSearchResult.newFailedResult(
+                                                            RESULT_INTERNAL_ERROR,
+                                                            "Received null"
+                                                                    + " InternalSetSchema"
+                                                                    + "Response"
+                                                                    + " during setSchema"
+                                                                    + " call"));
+                                            return;
                                         }
-                                    });
-                        }
-                    });
+                                        if (!internalSetSchemaResponse.isSuccess()) {
+                                            // check is the set schema call failed
+                                            // because incompatible changes. That's the only
+                                            // case we swallowed in the
+                                            // AppSearchImpl#setSchema().
+                                            callback.accept(
+                                                    AppSearchResult.newFailedResult(
+                                                            AppSearchResult
+                                                                    .RESULT_INVALID_SCHEMA,
+                                                            internalSetSchemaResponse
+                                                                    .getErrorMessage()));
+                                            return;
+                                        }
+                                        callback.accept(
+                                                AppSearchResult.newSuccessfulResult(
+                                                        internalSetSchemaResponse
+                                                                .getSetSchemaResponse()));
+                                    } catch (RuntimeException e) {
+                                        // TODO(b/261897334) save SDK errors/crashes and
+                                        // send to
+                                        //  server for logging.
+                                        callback.accept(
+                                                AppSearchResult.throwableToFailedResult(e));
+                                    }
+                                } else {
+                                    callback.accept(
+                                            AppSearchResult.newFailedResult(result));
+                                }
+                            });
+                }
+            };
+            mService.setSchema(setSchemaAidlRequest, callbackBase);
         } catch (RemoteException e) {
             ExceptionUtil.handleRemoteException(e);
         }
@@ -1163,11 +1410,12 @@ public final class AppSearchSession implements Closeable {
                                         SchemaMigrationStats.FIRST_CALL_GET_INCOMPATIBLE);
                         mService.setSchema(
                                 setSchemaAidlRequest,
-                                new IAppSearchResultCallback.Stub() {
+                                new AppSearchResultCallback<InternalSetSchemaResponse>() {
                                     @Override
-                                    @SuppressWarnings({"rawtypes", "unchecked"})
-                                    public void onResult(AppSearchResultParcel resultParcel) {
-                                        setSchemaResultRef.set(resultParcel.getResult());
+                                    public void onResult(
+                                            @NonNull AppSearchResult<InternalSetSchemaResponse>
+                                                    result) {
+                                        setSchemaResultRef.set(result);
                                         setSchemaLatch.countDown();
                                     }
                                 });
@@ -1260,12 +1508,11 @@ public final class AppSearchSession implements Closeable {
                                                 SchemaMigrationStats.SECOND_CALL_APPLY_NEW_SCHEMA);
                                 mService.setSchema(
                                         setSchemaAidlRequest1,
-                                        new IAppSearchResultCallback.Stub() {
+                                        new AppSearchResultCallback<InternalSetSchemaResponse>() {
                                             @Override
-                                            @SuppressWarnings({"rawtypes", "unchecked"})
-                                            public void onResult(
-                                                    AppSearchResultParcel resultParcel) {
-                                                setSchema2ResultRef.set(resultParcel.getResult());
+                                            public void onResult(@NonNull AppSearchResult<
+                                                    InternalSetSchemaResponse> result) {
+                                                setSchema2ResultRef.set(result);
                                                 setSchema2Latch.countDown();
                                             }
                                         });
diff --git a/framework/java/android/app/appsearch/BatchResultCallback.java b/framework/java/android/app/appsearch/BatchResultCallback.java
index f49a3ed1..7ba95f49 100644
--- a/framework/java/android/app/appsearch/BatchResultCallback.java
+++ b/framework/java/android/app/appsearch/BatchResultCallback.java
@@ -41,8 +41,8 @@ public interface BatchResultCallback<KeyType, ValueType> {
      * <p>This method is only called the infrastructure is fundamentally broken or unavailable, such
      * that none of the requests could be started. For example, it will be called if the AppSearch
      * service unexpectedly fails to initialize and can't be recovered by any means, or if
-     * communicating to the server over Binder fails (e.g. system service crashed or device is
-     * rebooting).
+     * communicating to the server over Binder fails (for example system service crashed or device
+     * is rebooting).
      *
      * <p>The error is not expected to be recoverable and there is no specific recommended action
      * other than displaying a permanent message to the user.
diff --git a/framework/java/android/app/appsearch/FrameworkAppSearchEnvironment.java b/framework/java/android/app/appsearch/FrameworkAppSearchEnvironment.java
index adecb94b..f3d035e6 100644
--- a/framework/java/android/app/appsearch/FrameworkAppSearchEnvironment.java
+++ b/framework/java/android/app/appsearch/FrameworkAppSearchEnvironment.java
@@ -100,4 +100,10 @@ public class FrameworkAppSearchEnvironment implements AppSearchEnvironment {
     public boolean isInfoLoggingEnabled() {
         return true;
     }
+
+    /** Returns the {@code EnvironmentType} for this environment. */
+    @Override
+    public int getEnvironment() {
+        return FRAMEWORK_ENVIRONMENT;
+    }
 }
diff --git a/framework/java/android/app/appsearch/GlobalSearchSession.java b/framework/java/android/app/appsearch/GlobalSearchSession.java
index 92a12e2c..2dbd9f29 100644
--- a/framework/java/android/app/appsearch/GlobalSearchSession.java
+++ b/framework/java/android/app/appsearch/GlobalSearchSession.java
@@ -19,12 +19,13 @@ package android.app.appsearch;
 import static android.app.appsearch.SearchSessionUtil.safeExecute;
 
 import android.annotation.CallbackExecutor;
+import android.annotation.FlaggedApi;
 import android.annotation.NonNull;
 import android.app.appsearch.aidl.AppSearchAttributionSource;
+import android.app.appsearch.aidl.AppSearchResultCallback;
 import android.app.appsearch.aidl.AppSearchResultParcel;
 import android.app.appsearch.aidl.IAppSearchManager;
 import android.app.appsearch.aidl.IAppSearchObserverProxy;
-import android.app.appsearch.aidl.IAppSearchResultCallback;
 import android.app.appsearch.aidl.PersistToDiskAidlRequest;
 import android.app.appsearch.aidl.RegisterObserverCallbackAidlRequest;
 import android.app.appsearch.aidl.ReportUsageAidlRequest;
@@ -41,6 +42,7 @@ import android.util.ArrayMap;
 import android.util.ArraySet;
 import android.util.Log;
 
+import com.android.appsearch.flags.Flags;
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.util.Preconditions;
 
@@ -48,6 +50,7 @@ import java.io.Closeable;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
+import java.util.Set;
 import java.util.concurrent.Executor;
 import java.util.function.Consumer;
 
@@ -132,6 +135,29 @@ public class GlobalSearchSession extends ReadOnlyGlobalSearchSession implements
         super.getByDocumentId(packageName, databaseName, request, executor, callback);
     }
 
+    /**
+     * Opens a batch of AppSearch Blobs for reading.
+     *
+     * <p>See {@link AppSearchSession#openBlobForRead} for a general description when a blob is for
+     * read.
+     *
+     * <p class="caution">The returned {@link OpenBlobForReadResponse} must be closed after use to
+     * avoid resource leaks. Failing to close it will result in system file descriptor exhaustion.
+     *
+     * @param handles The {@link AppSearchBlobHandle}s that identifies the blobs.
+     * @param executor Executor on which to invoke the callback.
+     * @param callback Callback to receive the {@link OpenBlobForReadResponse}.
+     * @see GenericDocument.Builder#setPropertyBlobHandle
+     */
+    @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void openBlobForRead(
+            @NonNull Set<AppSearchBlobHandle> handles,
+            @NonNull @CallbackExecutor Executor executor,
+            @NonNull Consumer<AppSearchResult<OpenBlobForReadResponse>> callback) {
+        Preconditions.checkState(!mIsClosed, "GlobalSearchSession has already been closed");
+        super.openBlobForRead(handles, executor, callback);
+    }
+
     /**
      * Retrieves documents from all AppSearch databases that the querying application has access to.
      *
@@ -225,14 +251,10 @@ public class GlobalSearchSession extends ReadOnlyGlobalSearchSession implements
                             /* systemUsage= */ true,
                             mUserHandle,
                             /* binderCallStartTimeMillis= */ SystemClock.elapsedRealtime()),
-                    new IAppSearchResultCallback.Stub() {
+                    new AppSearchResultCallback<Void>() {
                         @Override
-                        @SuppressWarnings({"rawtypes", "unchecked"})
-                        public void onResult(AppSearchResultParcel resultParcel) {
-                            safeExecute(
-                                    executor,
-                                    callback,
-                                    () -> callback.accept(resultParcel.getResult()));
+                        public void onResult(@NonNull AppSearchResult<Void> result) {
+                            safeExecute(executor, callback, () -> callback.accept(result));
                         }
                     });
             mIsMutated = true;
diff --git a/framework/java/android/app/appsearch/ParcelableUtil.java b/framework/java/android/app/appsearch/ParcelableUtil.java
index 3e0fe78f..26d0974a 100644
--- a/framework/java/android/app/appsearch/ParcelableUtil.java
+++ b/framework/java/android/app/appsearch/ParcelableUtil.java
@@ -16,6 +16,7 @@
 
 package android.app.appsearch;
 
+import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.SuppressLint;
@@ -29,6 +30,8 @@ import java.io.DataOutputStream;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 
 /**
  * Wrapper class to provide implementation for readBlob/writeBlob for all API levels.
@@ -43,6 +46,33 @@ public class ParcelableUtil {
     // under the transaction buffer limit.
     private static final int DOCUMENT_SIZE_LIMIT_IN_BYTES = 64 * 1024;
 
+    /**
+     * IntDef for how a {@link android.app.appsearch.aidl.AppSearchBatchResultParcelV2} or {@link
+     * android.app.appsearch.aidl.AppSearchResultParcelV2} write to or read from {@link Parcel}.
+     */
+    @IntDef(
+            prefix = "WRITE_PARCEL_MODE_",
+            value = {
+                WRITE_PARCEL_MODE_MARSHALL_WRITE_IN_BLOB,
+                WRITE_PARCEL_MODE_DIRECTLY_WRITE_TO_PARCEL
+            })
+    @Retention(RetentionPolicy.SOURCE)
+    public @interface WriteParcelMode {}
+
+    /**
+     * We could use Parcel.writeBlob() and Parcel.readBlob(). Parcel.writeBlob() API could automatic
+     * use Android Shared Memory it detects the data size is larger than 16 KiB. The data must be
+     * marshalled to byte array to use that API. This could help us to avoid exceed binder
+     * transaction limit when sending large objects.
+     */
+    public static final int WRITE_PARCEL_MODE_MARSHALL_WRITE_IN_BLOB = 1;
+
+    /**
+     * Directly write this object to parcel. We cannot marshall binder object and FDs. If a result
+     * contains such objects, we should always directly write it to and read it from parcel.
+     */
+    public static final int WRITE_PARCEL_MODE_DIRECTLY_WRITE_TO_PARCEL = 2;
+
     // TODO(b/232805516): Update SDK_INT in Android.bp to safeguard from unexpected compiler issues.
     @SuppressLint("ObsoleteSdkInt")
     public static void writeBlob(@NonNull Parcel parcel, @NonNull byte[] bytes) {
diff --git a/framework/java/android/app/appsearch/ReadOnlyGlobalSearchSession.java b/framework/java/android/app/appsearch/ReadOnlyGlobalSearchSession.java
index a50fbaf8..eae229bd 100644
--- a/framework/java/android/app/appsearch/ReadOnlyGlobalSearchSession.java
+++ b/framework/java/android/app/appsearch/ReadOnlyGlobalSearchSession.java
@@ -19,22 +19,26 @@ package android.app.appsearch;
 import static android.app.appsearch.SearchSessionUtil.safeExecute;
 
 import android.annotation.CallbackExecutor;
+import android.annotation.FlaggedApi;
 import android.annotation.NonNull;
 import android.app.appsearch.aidl.AppSearchAttributionSource;
-import android.app.appsearch.aidl.AppSearchResultParcel;
+import android.app.appsearch.aidl.AppSearchResultCallback;
 import android.app.appsearch.aidl.GetDocumentsAidlRequest;
 import android.app.appsearch.aidl.GetSchemaAidlRequest;
 import android.app.appsearch.aidl.IAppSearchManager;
-import android.app.appsearch.aidl.IAppSearchResultCallback;
 import android.app.appsearch.aidl.InitializeAidlRequest;
+import android.app.appsearch.aidl.OpenBlobForReadAidlRequest;
 import android.app.appsearch.util.ExceptionUtil;
 import android.os.RemoteException;
 import android.os.SystemClock;
 import android.os.UserHandle;
 
+import com.android.appsearch.flags.Flags;
 import com.android.internal.annotations.VisibleForTesting;
 
+import java.util.ArrayList;
 import java.util.Objects;
+import java.util.Set;
 import java.util.concurrent.Executor;
 import java.util.function.Consumer;
 
@@ -82,15 +86,13 @@ public abstract class ReadOnlyGlobalSearchSession {
                             mCallerAttributionSource,
                             mUserHandle,
                             /* binderCallStartTimeMillis= */ SystemClock.elapsedRealtime()),
-                    new IAppSearchResultCallback.Stub() {
+                    new AppSearchResultCallback<Void>() {
                         @Override
-                        @SuppressWarnings({"rawtypes", "unchecked"})
-                        public void onResult(AppSearchResultParcel resultParcel) {
+                        public void onResult(@NonNull AppSearchResult<Void> result) {
                             safeExecute(
                                     executor,
                                     callback,
                                     () -> {
-                                        AppSearchResult<Void> result = resultParcel.getResult();
                                         if (result.isSuccess()) {
                                             callback.accept(
                                                     AppSearchResult.newSuccessfulResult(null));
@@ -155,6 +157,45 @@ public abstract class ReadOnlyGlobalSearchSession {
         }
     }
 
+    /**
+     * Opens a batch of AppSearch Blobs for reading.
+     *
+     * <p>See {@link AppSearchSession#openBlobForRead} for a general description when a blob is for
+     * read.
+     *
+     * <p class="caution">The returned {@link OpenBlobForReadResponse} must be closed after use to
+     * avoid resource leaks. Failing to close it will result in system file descriptor exhaustion.
+     *
+     * @param handles The {@link AppSearchBlobHandle}s that identifies the blobs.
+     * @param executor Executor on which to invoke the callback.
+     * @param callback Callback to receive the {@link OpenBlobForReadResponse}.
+     * @see GenericDocument.Builder#setPropertyBlobHandle
+     */
+    @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void openBlobForRead(
+            @NonNull Set<AppSearchBlobHandle> handles,
+            @NonNull @CallbackExecutor Executor executor,
+            @NonNull Consumer<AppSearchResult<OpenBlobForReadResponse>> callback) {
+        try {
+            mService.openBlobForRead(
+                    new OpenBlobForReadAidlRequest(
+                            mCallerAttributionSource,
+                            /* callingDatabaseName= */ null,
+                            new ArrayList<>(handles),
+                            mUserHandle,
+                            /* binderCallStartTimeMillis= */ SystemClock.elapsedRealtime()),
+                    new AppSearchResultCallback<OpenBlobForReadResponse>() {
+                        @Override
+                        public void onResult(
+                                @NonNull AppSearchResult<OpenBlobForReadResponse> result) {
+                            safeExecute(executor, callback, () -> callback.accept(result));
+                        }
+                    });
+        } catch (RemoteException e) {
+            ExceptionUtil.handleRemoteException(e);
+        }
+    }
+
     /**
      * Retrieves documents from all AppSearch databases that the querying application has access to.
      *
@@ -221,25 +262,10 @@ public abstract class ReadOnlyGlobalSearchSession {
                             mUserHandle,
                             /* binderCallStartTimeMillis= */ SystemClock.elapsedRealtime(),
                             mIsForEnterprise),
-                    new IAppSearchResultCallback.Stub() {
-                        @SuppressWarnings({"rawtypes", "unchecked"})
+                    new AppSearchResultCallback<GetSchemaResponse>() {
                         @Override
-                        public void onResult(AppSearchResultParcel resultParcel) {
-                            safeExecute(
-                                    executor,
-                                    callback,
-                                    () -> {
-                                        AppSearchResult<GetSchemaResponse> result =
-                                                resultParcel.getResult();
-                                        if (result.isSuccess()) {
-                                            GetSchemaResponse response = result.getResultValue();
-                                            callback.accept(
-                                                    AppSearchResult.newSuccessfulResult(response));
-                                        } else {
-                                            callback.accept(
-                                                    AppSearchResult.newFailedResult(result));
-                                        }
-                                    });
+                        public void onResult(@NonNull AppSearchResult<GetSchemaResponse> result) {
+                            safeExecute(executor, callback, () -> callback.accept(result));
                         }
                     });
         } catch (RemoteException e) {
diff --git a/framework/java/android/app/appsearch/SearchResults.java b/framework/java/android/app/appsearch/SearchResults.java
index 6b6aa0a7..893a4187 100644
--- a/framework/java/android/app/appsearch/SearchResults.java
+++ b/framework/java/android/app/appsearch/SearchResults.java
@@ -24,11 +24,10 @@ import android.annotation.CallbackExecutor;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.app.appsearch.aidl.AppSearchAttributionSource;
-import android.app.appsearch.aidl.AppSearchResultParcel;
+import android.app.appsearch.aidl.AppSearchResultCallback;
 import android.app.appsearch.aidl.GetNextPageAidlRequest;
 import android.app.appsearch.aidl.GlobalSearchAidlRequest;
 import android.app.appsearch.aidl.IAppSearchManager;
-import android.app.appsearch.aidl.IAppSearchResultCallback;
 import android.app.appsearch.aidl.InvalidateNextPageTokenAidlRequest;
 import android.app.appsearch.aidl.SearchAidlRequest;
 import android.app.appsearch.util.ExceptionUtil;
@@ -187,16 +186,13 @@ public class SearchResults implements Closeable {
         }
     }
 
-    private IAppSearchResultCallback wrapCallback(
+    private AppSearchResultCallback<SearchResultPage> wrapCallback(
             @NonNull @CallbackExecutor Executor executor,
             @NonNull Consumer<AppSearchResult<List<SearchResult>>> callback) {
-        return new IAppSearchResultCallback.Stub() {
+        return new AppSearchResultCallback<>() {
             @Override
-            public void onResult(AppSearchResultParcel resultParcel) {
-                safeExecute(
-                        executor,
-                        callback,
-                        () -> invokeCallback(resultParcel.getResult(), callback));
+            public void onResult(@NonNull AppSearchResult<SearchResultPage> result) {
+                safeExecute(executor, callback, () -> invokeCallback(result, callback));
             }
         };
     }
diff --git a/framework/java/android/app/appsearch/aidl/AppSearchBatchResultParcel.java b/framework/java/android/app/appsearch/aidl/AppSearchBatchResultParcel.java
index bec3400c..7c207d26 100644
--- a/framework/java/android/app/appsearch/aidl/AppSearchBatchResultParcel.java
+++ b/framework/java/android/app/appsearch/aidl/AppSearchBatchResultParcel.java
@@ -39,9 +39,11 @@ import java.util.Objects;
  * wraps an {@link AppSearchBatchResult} that has String keys and Parcelable values. It provides
  * parcelability of the whole structure.
  *
+ * @deprecated This class is deprecated, you should use {@link AppSearchBatchResultParcelV2}.
  * @param <ValueType> The type of result object for successful calls. Must be a parcelable type.
  * @hide
  */
+@Deprecated
 @SafeParcelable.Class(creator = "AppSearchBatchResultParcelCreator", creatorIsFinal = false)
 public final class AppSearchBatchResultParcel<ValueType> extends AbstractSafeParcelable {
 
diff --git a/framework/java/android/app/appsearch/aidl/AppSearchBatchResultParcelV2.aidl b/framework/java/android/app/appsearch/aidl/AppSearchBatchResultParcelV2.aidl
new file mode 100644
index 00000000..29fac383
--- /dev/null
+++ b/framework/java/android/app/appsearch/aidl/AppSearchBatchResultParcelV2.aidl
@@ -0,0 +1,19 @@
+/**
+ * Copyright 2021, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.app.appsearch.aidl;
+
+/** {@hide} */
+parcelable AppSearchBatchResultParcelV2<KeyType, ValueType>;
diff --git a/framework/java/android/app/appsearch/aidl/AppSearchBatchResultParcelV2.java b/framework/java/android/app/appsearch/aidl/AppSearchBatchResultParcelV2.java
new file mode 100644
index 00000000..838d0014
--- /dev/null
+++ b/framework/java/android/app/appsearch/aidl/AppSearchBatchResultParcelV2.java
@@ -0,0 +1,291 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch.aidl;
+
+import static android.app.appsearch.ParcelableUtil.WRITE_PARCEL_MODE_DIRECTLY_WRITE_TO_PARCEL;
+import static android.app.appsearch.ParcelableUtil.WRITE_PARCEL_MODE_MARSHALL_WRITE_IN_BLOB;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.app.appsearch.AppSearchBatchResult;
+import android.app.appsearch.AppSearchBlobHandle;
+import android.app.appsearch.AppSearchResult;
+import android.app.appsearch.ParcelableUtil;
+import android.app.appsearch.safeparcel.AbstractSafeParcelable;
+import android.app.appsearch.safeparcel.SafeParcelable;
+import android.os.Build;
+import android.os.Bundle;
+import android.os.Parcel;
+import android.os.ParcelFileDescriptor;
+import android.os.Parcelable;
+
+import com.android.appsearch.flags.Flags;
+
+import java.util.Map;
+import java.util.Objects;
+
+/**
+ * Parcelable wrapper around {@link AppSearchBatchResult}.
+ *
+ * <p>{@link AppSearchBatchResult} can contain any type of key and value, including non-parcelable
+ * values. For the specific case of sending {@link AppSearchBatchResult} across Binder, this class
+ * wraps an {@link AppSearchBatchResult} and provides parcelability of the whole structure.
+ *
+ * <p>Compare to deprecated {@link AppSearchBatchResultParcel}, this class could config how to write
+ * it to the parcel. Therefore binder objects and {@link ParcelFileDescriptor} is supported in this
+ * class. This class could also support general type as KeyType.
+ *
+ * @see ParcelableUtil#WRITE_PARCEL_MODE_MARSHALL_WRITE_IN_BLOB
+ * @see ParcelableUtil#WRITE_PARCEL_MODE_DIRECTLY_WRITE_TO_PARCEL
+ * @param <KeyType> The type of the keys for which the results will be reported. We are passing the
+ *     class name of the KeyType to parcelable. Do not rename the class of KeyType, since that may
+ *     cause compatibility issue for GmsCore.
+ * @param <ValueType> The type of result object for successful calls. Must be a parcelable type.
+ * @hide
+ */
+@SafeParcelable.Class(creator = "AppSearchBatchResultParcelV2Creator", creatorIsFinal = false)
+public final class AppSearchBatchResultParcelV2<KeyType, ValueType> extends AbstractSafeParcelable {
+    private static final String TAG = "AppSearchBatchResultPar";
+
+    @NonNull
+    // Provide ClassLoader when read from bundle in getResult() method
+    @SuppressWarnings("rawtypes")
+    public static final Parcelable.Creator<AppSearchBatchResultParcelV2> CREATOR =
+            new AppSearchBatchResultParcelV2Creator() {
+                @Override
+                public AppSearchBatchResultParcelV2 createFromParcel(Parcel in) {
+                    int writeParcelModel = in.readInt();
+                    switch (writeParcelModel) {
+                        case WRITE_PARCEL_MODE_MARSHALL_WRITE_IN_BLOB:
+                            byte[] dataBlob = Objects.requireNonNull(ParcelableUtil.readBlob(in));
+                            Parcel unmarshallParcel = Parcel.obtain();
+                            try {
+                                unmarshallParcel.unmarshall(dataBlob, 0, dataBlob.length);
+                                unmarshallParcel.setDataPosition(0);
+                                return directlyReadFromParcel(unmarshallParcel);
+                            } finally {
+                                unmarshallParcel.recycle();
+                            }
+                        case WRITE_PARCEL_MODE_DIRECTLY_WRITE_TO_PARCEL:
+                            return directlyReadFromParcel(in);
+                        default:
+                            throw new UnsupportedOperationException(
+                                    "Cannot write AppSearchBatchResultParcelV2 to Parcel with "
+                                            + "unknown model: "
+                                            + writeParcelModel);
+                    }
+                }
+            };
+
+    /** The Creator used to directly write to parcel with calling {@link Parcel#writeBlob}. */
+    @NonNull
+    private static final Parcelable.Creator<AppSearchBatchResultParcelV2> CREATOR_WITHOUT_BLOB =
+            new AppSearchBatchResultParcelV2Creator();
+
+    static AppSearchBatchResultParcelV2<?, ?> directlyReadFromParcel(@NonNull Parcel data) {
+        return CREATOR_WITHOUT_BLOB.createFromParcel(data);
+    }
+
+    static void directlyWriteToParcel(
+            @NonNull AppSearchBatchResultParcelV2<?, ?> result, @NonNull Parcel data, int flags) {
+        AppSearchBatchResultParcelV2Creator.writeToParcel(result, data, flags);
+    }
+
+    /**
+     * The flags indicate how we write this object to parcel and read it.
+     *
+     * @see ParcelableUtil#WRITE_PARCEL_MODE_MARSHALL_WRITE_IN_BLOB
+     * @see ParcelableUtil#WRITE_PARCEL_MODE_DIRECTLY_WRITE_TO_PARCEL
+     */
+    @Field(id = 1)
+    @ParcelableUtil.WriteParcelMode
+    int mWriteParcelModel;
+
+    @Field(id = 2)
+    @NonNull
+    final String mKeyClassName;
+
+    // Map stores keys of AppSearchBatchResult. The key will be an integer of a consecutive
+    // increasing sequence. Associated with mAppSearchResultValueBundle.
+    @Field(id = 3)
+    @NonNull
+    final Bundle mKeyBundle;
+
+    // Map stores keys of AppSearchBatchResult. The key will be an integer of a consecutive
+    // increasing sequence. Associated with mKeyBundle.
+    @Field(id = 4)
+    @NonNull
+    final Bundle mAppSearchResultValueBundle;
+
+    @Nullable private AppSearchBatchResult<KeyType, ValueType> mResultCached;
+
+    @Constructor
+    AppSearchBatchResultParcelV2(
+            @Param(id = 1) @ParcelableUtil.WriteParcelMode int writeParcelModel,
+            @Param(id = 2) String keyClassName,
+            @Param(id = 3) Bundle keyBundle,
+            @Param(id = 4) Bundle appSearchResultValueBundle) {
+        mWriteParcelModel = writeParcelModel;
+        mKeyClassName = keyClassName;
+        mKeyBundle = keyBundle;
+        mAppSearchResultValueBundle = appSearchResultValueBundle;
+    }
+
+    /**
+     * Creates a new {@link AppSearchBatchResultParcel} from the given {@link AppSearchBatchResult}
+     * results which has {@link AppSearchBlobHandle} as keys and {@link ParcelFileDescriptor} as
+     * values.
+     */
+    @SuppressWarnings("unchecked")
+    @NonNull
+    @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
+    public static AppSearchBatchResultParcelV2<AppSearchBlobHandle, ParcelFileDescriptor>
+            fromBlobHandleToPfd(
+                    @NonNull
+                            AppSearchBatchResult<AppSearchBlobHandle, ParcelFileDescriptor>
+                                    result) {
+        Bundle keyAppSearchResultBundle = new Bundle();
+        Bundle valueAppSearchResultBundle = new Bundle();
+        int i = 0;
+        for (Map.Entry<AppSearchBlobHandle, AppSearchResult<ParcelFileDescriptor>> entry :
+                result.getAll().entrySet()) {
+            AppSearchResultParcelV2<ParcelFileDescriptor> valueAppSearchBinderResultParcel;
+            // Create result from value in success case and errorMessage in failure case.
+            if (entry.getValue().isSuccess()) {
+                valueAppSearchBinderResultParcel =
+                        AppSearchResultParcelV2.fromParcelFileDescriptor(
+                                entry.getValue().getResultValue());
+            } else {
+                valueAppSearchBinderResultParcel =
+                        AppSearchResultParcelV2.fromFailedResult(entry.getValue());
+            }
+            keyAppSearchResultBundle.putParcelable(String.valueOf(i), entry.getKey());
+            valueAppSearchResultBundle.putParcelable(
+                    String.valueOf(i), valueAppSearchBinderResultParcel);
+            ++i;
+        }
+        // We cannot marshall PFD!! We have to directly write this object to parcel.
+        return new AppSearchBatchResultParcelV2<>(
+                WRITE_PARCEL_MODE_DIRECTLY_WRITE_TO_PARCEL,
+                AppSearchBlobHandle.class.getName(),
+                keyAppSearchResultBundle,
+                valueAppSearchResultBundle);
+    }
+
+    /**
+     * Creates a new {@link AppSearchBatchResultParcel} from the given {@link AppSearchBatchResult}
+     * results which has {@link AppSearchBlobHandle} as keys and {@code Void} as values.
+     */
+    @NonNull
+    @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
+    public static AppSearchBatchResultParcelV2<AppSearchBlobHandle, Void> fromBlobHandleToVoid(
+            @NonNull AppSearchBatchResult<AppSearchBlobHandle, Void> result) {
+        Bundle keyAppSearchResultBundle = new Bundle();
+        Bundle valueAppSearchResultBundle = new Bundle();
+        int i = 0;
+        for (Map.Entry<AppSearchBlobHandle, AppSearchResult<Void>> entry :
+                result.getAll().entrySet()) {
+            AppSearchResultParcelV2<ParcelFileDescriptor> valueAppSearchResultParcel;
+            // Create result from value in success case and errorMessage in failure case.
+            if (entry.getValue().isSuccess()) {
+                valueAppSearchResultParcel = AppSearchResultParcelV2.fromVoid();
+            } else {
+                valueAppSearchResultParcel =
+                        AppSearchResultParcelV2.fromFailedResult(entry.getValue());
+            }
+            keyAppSearchResultBundle.putParcelable(String.valueOf(i), entry.getKey());
+            valueAppSearchResultBundle.putParcelable(String.valueOf(i), valueAppSearchResultParcel);
+            ++i;
+        }
+        return new AppSearchBatchResultParcelV2<>(
+                WRITE_PARCEL_MODE_MARSHALL_WRITE_IN_BLOB,
+                AppSearchBlobHandle.class.getName(),
+                keyAppSearchResultBundle,
+                valueAppSearchResultBundle);
+    }
+
+    /** Gets the {@link AppSearchBatchResult} out of this {@link AppSearchBatchResultParcelV2}. */
+    @NonNull
+    @SuppressWarnings("unchecked")
+    public AppSearchBatchResult<KeyType, ValueType> getResult() {
+        if (mResultCached == null) {
+            AppSearchBatchResult.Builder<KeyType, ValueType> builder =
+                    new AppSearchBatchResult.Builder<>();
+
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
+                try {
+                    java.lang.Class<?> clazz = java.lang.Class.forName(mKeyClassName);
+                    for (String key : mKeyBundle.keySet()) {
+                        builder.setResult(
+                                (KeyType) mKeyBundle.getParcelable(key, clazz),
+                                mAppSearchResultValueBundle
+                                        .getParcelable(key, AppSearchResultParcelV2.class)
+                                        .getResult());
+                    }
+                } catch (ClassNotFoundException e) {
+                    // Impossible, the key type name should always match the KeyType.
+                    throw new RuntimeException("Class not found: " + e.getMessage(), e);
+                }
+            } else {
+                for (String key : mKeyBundle.keySet()) {
+                    builder.setResult(
+                            mKeyBundle.getParcelable(key),
+                            ((AppSearchResultParcelV2)
+                                            mAppSearchResultValueBundle.getParcelable(key))
+                                    .getResult());
+                }
+            }
+
+            mResultCached = builder.build();
+        }
+        return mResultCached;
+    }
+
+    /** @hide */
+    @Override
+    @SuppressWarnings("unchecked")
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        dest.writeInt(mWriteParcelModel);
+        switch (mWriteParcelModel) {
+            case WRITE_PARCEL_MODE_MARSHALL_WRITE_IN_BLOB:
+                byte[] bytes;
+                // Create a parcel object to serialize results. So that we can use
+                // Parcel.writeBlob() to
+                // send data. WriteBlob() could take care of whether to pass data via binder
+                // directly or
+                // Android shared memory if the data is large.
+                Parcel data = Parcel.obtain();
+                try {
+                    directlyWriteToParcel(this, data, flags);
+                    bytes = data.marshall();
+                } finally {
+                    data.recycle();
+                }
+                ParcelableUtil.writeBlob(dest, bytes);
+                break;
+            case WRITE_PARCEL_MODE_DIRECTLY_WRITE_TO_PARCEL:
+                directlyWriteToParcel(this, dest, flags);
+                break;
+            default:
+                throw new UnsupportedOperationException(
+                        "Cannot read AppSearchBatchResultParcelV2 from Parcel with "
+                                + "unknown model: "
+                                + mWriteParcelModel);
+        }
+    }
+}
diff --git a/framework/java/android/app/appsearch/aidl/AppSearchResultCallback.java b/framework/java/android/app/appsearch/aidl/AppSearchResultCallback.java
new file mode 100644
index 00000000..abb47d9b
--- /dev/null
+++ b/framework/java/android/app/appsearch/aidl/AppSearchResultCallback.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch.aidl;
+
+import android.annotation.NonNull;
+import android.app.appsearch.AppSearchResult;
+import android.os.RemoteException;
+
+/**
+ * The base implementation class for {@link IAppSearchResultCallback}, which could extract {@link
+ * AppSearchResult} from either {@link AppSearchResultParcel} or {@link AppSearchResultParcelV2}.
+ *
+ * @param <ValueType> The type of result object for successful calls.
+ * @hide
+ */
+public abstract class AppSearchResultCallback<ValueType> extends IAppSearchResultCallback.Stub {
+
+    /**
+     * Invokes a callback function with an {@link AppSearchResult} that has been extracted from
+     * either an {@link AppSearchResultParcel} or an {@link AppSearchResultParcelV2}.
+     */
+    public abstract void onResult(@NonNull AppSearchResult<ValueType> result);
+
+    @Override
+    public void onResult(AppSearchResultParcel appSearchResultParcel) throws RemoteException {
+        onResult(appSearchResultParcel.getResult());
+    }
+
+    @Override
+    public void onResultV2(AppSearchResultParcelV2 appSearchResultParcelV2) throws RemoteException {
+        onResult(appSearchResultParcelV2.getResult());
+    }
+}
diff --git a/framework/java/android/app/appsearch/aidl/AppSearchResultParcel.java b/framework/java/android/app/appsearch/aidl/AppSearchResultParcel.java
index 08d6309d..6d225824 100644
--- a/framework/java/android/app/appsearch/aidl/AppSearchResultParcel.java
+++ b/framework/java/android/app/appsearch/aidl/AppSearchResultParcel.java
@@ -27,7 +27,6 @@ import android.app.appsearch.SearchSuggestionResult;
 import android.app.appsearch.SetSchemaResponse.MigrationFailure;
 import android.app.appsearch.StorageInfo;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
-import android.app.appsearch.functions.ExecuteAppFunctionResponse;
 import android.app.appsearch.safeparcel.AbstractSafeParcelable;
 import android.app.appsearch.safeparcel.GenericDocumentParcel;
 import android.app.appsearch.safeparcel.SafeParcelable;
@@ -45,9 +44,11 @@ import java.util.Objects;
  * AppSearchResult} that contains a parcelable type and provides parcelability of the whole
  * structure.
  *
+ * @deprecated This class is deprecated, you should use {@link AppSearchResultParcelV2}.
  * @param <ValueType> The type of result object for successful calls. Must be a parcelable type.
  * @hide
  */
+@Deprecated
 @SafeParcelable.Class(creator = "AppSearchResultParcelCreator", creatorIsFinal = false)
 public final class AppSearchResultParcel<ValueType> extends AbstractSafeParcelable {
 
@@ -118,10 +119,6 @@ public final class AppSearchResultParcel<ValueType> extends AbstractSafeParcelab
     @Nullable
     StorageInfo mStorageInfo;
 
-    @Field(id = 11)
-    @Nullable
-    ExecuteAppFunctionResponse mExecuteAppFunctionResponse;
-
     @NonNull AppSearchResult<ValueType> mResultCached;
 
     /**
@@ -150,8 +147,7 @@ public final class AppSearchResultParcel<ValueType> extends AbstractSafeParcelab
             @Param(id = 7) @Nullable SearchResultPage searchResultPage,
             @Param(id = 8) @Nullable List<MigrationFailure> migrationFailures,
             @Param(id = 9) @Nullable List<SearchSuggestionResult> searchSuggestionResults,
-            @Param(id = 10) @Nullable StorageInfo storageInfo,
-            @Param(id = 11) @Nullable ExecuteAppFunctionResponse executeAppFunctionResponse) {
+            @Param(id = 10) @Nullable StorageInfo storageInfo) {
         mResultCode = resultCode;
         mErrorMessage = errorMessage;
         if (resultCode == AppSearchResult.RESULT_OK) {
@@ -163,7 +159,6 @@ public final class AppSearchResultParcel<ValueType> extends AbstractSafeParcelab
             mMigrationFailures = migrationFailures;
             mSearchSuggestionResults = searchSuggestionResults;
             mStorageInfo = storageInfo;
-            mExecuteAppFunctionResponse = executeAppFunctionResponse;
             if (mInternalSetSchemaResponse != null) {
                 mResultCached =
                         (AppSearchResult<ValueType>)
@@ -195,10 +190,6 @@ public final class AppSearchResultParcel<ValueType> extends AbstractSafeParcelab
                 mResultCached =
                         (AppSearchResult<ValueType>)
                                 AppSearchResult.newSuccessfulResult(mStorageInfo);
-            } else if (mExecuteAppFunctionResponse != null) {
-                mResultCached =
-                        (AppSearchResult<ValueType>)
-                                AppSearchResult.newSuccessfulResult(mExecuteAppFunctionResponse);
             } else {
                 // Default case where code is OK and value is null.
                 mResultCached = AppSearchResult.newSuccessfulResult(null);
@@ -318,17 +309,6 @@ public final class AppSearchResultParcel<ValueType> extends AbstractSafeParcelab
                 .build();
     }
 
-    /**
-     * Creates a new {@link AppSearchResultParcel} from the given result in case a successful {@link
-     * ExecuteAppFunctionResponse}.
-     */
-    public static AppSearchResultParcel<ExecuteAppFunctionResponse> fromExecuteAppFunctionResponse(
-            ExecuteAppFunctionResponse executeAppFunctionResponse) {
-        return new AppSearchResultParcel.Builder<ExecuteAppFunctionResponse>(
-                        AppSearchResult.RESULT_OK)
-                .setExecuteAppFunctionResponse(executeAppFunctionResponse)
-                .build();
-    }
 
     @NonNull
     public AppSearchResult<ValueType> getResult() {
@@ -379,7 +359,6 @@ public final class AppSearchResultParcel<ValueType> extends AbstractSafeParcelab
         @Nullable private List<MigrationFailure> mMigrationFailures;
         @Nullable private List<SearchSuggestionResult> mSearchSuggestionResults;
         @Nullable private StorageInfo mStorageInfo;
-        @Nullable private ExecuteAppFunctionResponse mExecuteAppFunctionResponse;
 
         /** Builds an {@link AppSearchResultParcel.Builder}. */
         Builder(int resultCode) {
@@ -442,12 +421,6 @@ public final class AppSearchResultParcel<ValueType> extends AbstractSafeParcelab
             return this;
         }
 
-        @CanIgnoreReturnValue
-        Builder<ValueType> setExecuteAppFunctionResponse(
-                ExecuteAppFunctionResponse executeAppFunctionResponse) {
-            mExecuteAppFunctionResponse = executeAppFunctionResponse;
-            return this;
-        }
 
         /**
          * Builds an {@link AppSearchResultParcel} object from the contents of this {@link
@@ -465,8 +438,7 @@ public final class AppSearchResultParcel<ValueType> extends AbstractSafeParcelab
                     mSearchResultPage,
                     mMigrationFailures,
                     mSearchSuggestionResults,
-                    mStorageInfo,
-                    mExecuteAppFunctionResponse);
+                    mStorageInfo);
         }
     }
 }
diff --git a/framework/java/android/app/appsearch/aidl/AppSearchResultParcelV2.aidl b/framework/java/android/app/appsearch/aidl/AppSearchResultParcelV2.aidl
new file mode 100644
index 00000000..ec935d67
--- /dev/null
+++ b/framework/java/android/app/appsearch/aidl/AppSearchResultParcelV2.aidl
@@ -0,0 +1,19 @@
+/**
+ * Copyright 2021, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.app.appsearch.aidl;
+
+/** {@hide} */
+parcelable AppSearchResultParcelV2<ValueType>;
diff --git a/framework/java/android/app/appsearch/aidl/AppSearchResultParcelV2.java b/framework/java/android/app/appsearch/aidl/AppSearchResultParcelV2.java
new file mode 100644
index 00000000..764478f8
--- /dev/null
+++ b/framework/java/android/app/appsearch/aidl/AppSearchResultParcelV2.java
@@ -0,0 +1,402 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch.aidl;
+
+import static android.app.appsearch.ParcelableUtil.WRITE_PARCEL_MODE_DIRECTLY_WRITE_TO_PARCEL;
+import static android.app.appsearch.ParcelableUtil.WRITE_PARCEL_MODE_MARSHALL_WRITE_IN_BLOB;
+
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.app.appsearch.AppSearchResult;
+import android.app.appsearch.CommitBlobResponse;
+import android.app.appsearch.OpenBlobForReadResponse;
+import android.app.appsearch.OpenBlobForWriteResponse;
+import android.app.appsearch.ParcelableUtil;
+import android.app.appsearch.RemoveBlobResponse;
+import android.app.appsearch.annotation.CanIgnoreReturnValue;
+import android.app.appsearch.safeparcel.AbstractSafeParcelable;
+import android.app.appsearch.safeparcel.SafeParcelable;
+import android.os.Parcel;
+import android.os.ParcelFileDescriptor;
+import android.os.Parcelable;
+
+import java.util.Objects;
+
+/**
+ * Parcelable wrapper around {@link AppSearchResult}.
+ *
+ * <p>{@link AppSearchResult} can contain any value, including non-parcelable values. For the
+ * specific case of sending {@link AppSearchResult} across Binder, this class wraps an {@link
+ * AppSearchResult} that contains a parcelable type and provides parcelability of the whole
+ * structure.
+ *
+ * <p>Compare to deprecated {@link AppSearchResultParcel}, this class could config how to write it
+ * to the parcel. Therefore binder objects and {@link ParcelFileDescriptor} is supported in this
+ * class.
+ *
+ * @see ParcelableUtil#WRITE_PARCEL_MODE_MARSHALL_WRITE_IN_BLOB
+ * @see ParcelableUtil#WRITE_PARCEL_MODE_DIRECTLY_WRITE_TO_PARCEL
+ * @param <ValueType> The type of result object for successful calls. Must be a parcelable type.
+ * @hide
+ */
+@SafeParcelable.Class(creator = "AppSearchResultParcelV2Creator", creatorIsFinal = false)
+public final class AppSearchResultParcelV2<ValueType> extends AbstractSafeParcelable {
+    private static final String TAG = "AppSearchResultParcelV2";
+
+    @NonNull
+    @SuppressWarnings("rawtypes")
+    public static final Parcelable.Creator<AppSearchResultParcelV2> CREATOR =
+            new AppSearchResultParcelV2Creator() {
+                @Override
+                public AppSearchResultParcelV2 createFromParcel(Parcel in) {
+                    int writeParcelModel = in.readInt();
+                    switch (writeParcelModel) {
+                        case WRITE_PARCEL_MODE_MARSHALL_WRITE_IN_BLOB:
+                            byte[] dataBlob = Objects.requireNonNull(ParcelableUtil.readBlob(in));
+                            Parcel unmarshallParcel = Parcel.obtain();
+                            try {
+                                unmarshallParcel.unmarshall(dataBlob, 0, dataBlob.length);
+                                unmarshallParcel.setDataPosition(0);
+                                return directlyReadFromParcel(unmarshallParcel);
+                            } finally {
+                                unmarshallParcel.recycle();
+                            }
+                        case WRITE_PARCEL_MODE_DIRECTLY_WRITE_TO_PARCEL:
+                            return directlyReadFromParcel(in);
+                        default:
+                            throw new UnsupportedOperationException(
+                                    "Cannot read AppSearchResultParcelV2 from Parcel with "
+                                            + "unknown model: "
+                                            + writeParcelModel);
+                    }
+                }
+            };
+
+    @NonNull
+    private static final Parcelable.Creator<AppSearchResultParcelV2> CREATOR_WITHOUT_BLOB =
+            new AppSearchResultParcelV2Creator();
+
+    static AppSearchResultParcelV2<?> directlyReadFromParcel(@NonNull Parcel data) {
+        return CREATOR_WITHOUT_BLOB.createFromParcel(data);
+    }
+
+    static void directlyWriteToParcel(
+            @NonNull AppSearchResultParcelV2<?> result, @NonNull Parcel data, int flags) {
+        AppSearchResultParcelV2Creator.writeToParcel(result, data, flags);
+    }
+
+    /**
+     * The flags indicate how we write this object to parcel and read it.
+     *
+     * @see ParcelableUtil#WRITE_PARCEL_MODE_MARSHALL_WRITE_IN_BLOB
+     * @see ParcelableUtil#WRITE_PARCEL_MODE_DIRECTLY_WRITE_TO_PARCEL
+     */
+    @Field(id = 1)
+    @ParcelableUtil.WriteParcelMode
+    int mWriteParcelMode;
+
+    @Field(id = 2)
+    @AppSearchResult.ResultCode
+    int mResultCode;
+
+    @Field(id = 3)
+    @Nullable
+    String mErrorMessage;
+
+    @Field(id = 4)
+    @Nullable
+    ParcelFileDescriptor mParcelFileDescriptor;
+
+    @Field(id = 5)
+    @Nullable
+    OpenBlobForWriteResponse mOpenBlobForWriteResponse;
+
+    @Field(id = 6)
+    @Nullable
+    CommitBlobResponse mCommitBlobResponse;
+
+    @Field(id = 7)
+    @Nullable
+    OpenBlobForReadResponse mOpenBlobForReadResponse;
+
+    @Field(id = 8)
+    @Nullable
+    RemoveBlobResponse mRemoveBlobResponse;
+
+    @NonNull AppSearchResult<ValueType> mResultCached;
+
+    /**
+     * Creates an AppSearchResultParcelV2 for given value type.
+     *
+     * @param resultCode A {@link AppSearchResult} result code for {@link IAppSearchManager} API
+     *     response.
+     * @param errorMessage An error message in case of a failed response.
+     */
+    @Constructor
+    AppSearchResultParcelV2(
+            @Param(id = 1) int writeParcelMode,
+            @Param(id = 2) @AppSearchResult.ResultCode int resultCode,
+            @Param(id = 3) @Nullable String errorMessage,
+            @Param(id = 4) @Nullable ParcelFileDescriptor parcelFileDescriptor,
+            @Param(id = 5) @Nullable OpenBlobForWriteResponse openBlobForWriteResponse,
+            @Param(id = 6) @Nullable CommitBlobResponse commitBlobResponse,
+            @Param(id = 7) @Nullable OpenBlobForReadResponse openBlobForReadResponse,
+            @Param(id = 8) @Nullable RemoveBlobResponse removeBlobResponse) {
+        mWriteParcelMode = writeParcelMode;
+        mResultCode = resultCode;
+        mErrorMessage = errorMessage;
+        if (resultCode == AppSearchResult.RESULT_OK) {
+            mParcelFileDescriptor = parcelFileDescriptor;
+            mOpenBlobForWriteResponse = openBlobForWriteResponse;
+            mCommitBlobResponse = commitBlobResponse;
+            mOpenBlobForReadResponse = openBlobForReadResponse;
+            mRemoveBlobResponse = removeBlobResponse;
+            if (mParcelFileDescriptor != null) {
+                mResultCached =
+                        (AppSearchResult<ValueType>)
+                                AppSearchResult.newSuccessfulResult(mParcelFileDescriptor);
+            } else if (mOpenBlobForWriteResponse != null) {
+                mResultCached =
+                        (AppSearchResult<ValueType>)
+                                AppSearchResult.newSuccessfulResult(mOpenBlobForWriteResponse);
+            } else if (mCommitBlobResponse != null) {
+                mResultCached =
+                        (AppSearchResult<ValueType>)
+                                AppSearchResult.newSuccessfulResult(mCommitBlobResponse);
+            } else if (mOpenBlobForReadResponse != null) {
+                mResultCached =
+                        (AppSearchResult<ValueType>)
+                                AppSearchResult.newSuccessfulResult(mOpenBlobForReadResponse);
+            } else if (mRemoveBlobResponse != null) {
+                mResultCached =
+                        (AppSearchResult<ValueType>)
+                                AppSearchResult.newSuccessfulResult(mRemoveBlobResponse);
+            } else {
+                // Default case where code is OK and value is null.
+                mResultCached = AppSearchResult.newSuccessfulResult(null);
+            }
+        } else {
+            mResultCached = AppSearchResult.newFailedResult(mResultCode, mErrorMessage);
+        }
+    }
+
+    /**
+     * Creates a new {@link AppSearchResultParcelV2} from the given result in case a successful Void
+     * response.
+     */
+    public static AppSearchResultParcelV2 fromVoid() {
+        // We can marshall a void results, but since it is always a small object, we can directly
+        // write it to parcel.
+        return new AppSearchResultParcelV2.Builder<>(
+                        WRITE_PARCEL_MODE_DIRECTLY_WRITE_TO_PARCEL, AppSearchResult.RESULT_OK)
+                .build();
+    }
+
+    /** Creates a new failed {@link AppSearchResultParcelV2} from result code and error message. */
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    public static AppSearchResultParcelV2 fromFailedResult(AppSearchResult failedResult) {
+        if (failedResult.isSuccess()) {
+            throw new IllegalStateException(
+                    "Creating a failed AppSearchResultParcelV2 from a " + "successful response");
+        }
+        // We can marshall a failed results, but since it is always a small object, we can directly
+        // write it to parcel.
+        return new AppSearchResultParcelV2.Builder<>(
+                        WRITE_PARCEL_MODE_DIRECTLY_WRITE_TO_PARCEL, failedResult.getResultCode())
+                .setErrorMessage(failedResult.getErrorMessage())
+                .build();
+    }
+
+    /**
+     * Creates a new {@link AppSearchResultParcelV2} from the given result in case a successful
+     * {@link ParcelFileDescriptor}.
+     */
+    public static AppSearchResultParcelV2<ParcelFileDescriptor> fromParcelFileDescriptor(
+            ParcelFileDescriptor parcelFileDescriptor) {
+        // We CANNOT marshall a FD, we have to directly write it to parcel.
+        return new AppSearchResultParcelV2.Builder<ParcelFileDescriptor>(
+                        WRITE_PARCEL_MODE_DIRECTLY_WRITE_TO_PARCEL, AppSearchResult.RESULT_OK)
+                .setParcelFileDescriptor(parcelFileDescriptor)
+                .build();
+    }
+
+    /**
+     * Creates a new {@link AppSearchResultParcelV2} from the given result in case a successful
+     * {@link OpenBlobForWriteResponse}.
+     */
+    public static AppSearchResultParcelV2<OpenBlobForWriteResponse> fromOpenBlobForWriteResponse(
+            OpenBlobForWriteResponse openBlobForWriteResponse) {
+        // We CANNOT marshall OpenBlobForWriteResponse, since it contains FD, we have to directly
+        // write it to parcel.
+        return new AppSearchResultParcelV2.Builder<OpenBlobForWriteResponse>(
+                        WRITE_PARCEL_MODE_DIRECTLY_WRITE_TO_PARCEL, AppSearchResult.RESULT_OK)
+                .setOpenBlobForWriteResponse(openBlobForWriteResponse)
+                .build();
+    }
+
+    /**
+     * Creates a new {@link AppSearchResultParcelV2} from the given result in case a successful
+     * {@link RemoveBlobResponse}.
+     */
+    public static AppSearchResultParcelV2<RemoveBlobResponse> fromRemoveBlobResponseParcel(
+            RemoveBlobResponse removeBlobResponse) {
+        return new AppSearchResultParcelV2.Builder<RemoveBlobResponse>(
+                        WRITE_PARCEL_MODE_MARSHALL_WRITE_IN_BLOB, AppSearchResult.RESULT_OK)
+                .setRemoveBlobResponse(removeBlobResponse)
+                .build();
+    }
+
+    /**
+     * Creates a new {@link AppSearchResultParcelV2} from the given result in case a successful
+     * {@link CommitBlobResponse}.
+     */
+    public static AppSearchResultParcelV2<CommitBlobResponse> fromCommitBlobResponseParcel(
+            CommitBlobResponse commitBlobResponse) {
+        return new AppSearchResultParcelV2.Builder<CommitBlobResponse>(
+                        WRITE_PARCEL_MODE_MARSHALL_WRITE_IN_BLOB, AppSearchResult.RESULT_OK)
+                .setCommitBlobResponse(commitBlobResponse)
+                .build();
+    }
+
+    /**
+     * Creates a new {@link AppSearchResultParcelV2} from the given result in case a successful
+     * {@link OpenBlobForReadResponse}.
+     */
+    public static AppSearchResultParcelV2<OpenBlobForReadResponse> fromOpenBlobForReadResponse(
+            OpenBlobForReadResponse OpenBlobForReadResponse) {
+        // We CANNOT marshall OpenBlobForReadResponse, since it contains FD, we have to directly
+        // write it to parcel.
+        return new AppSearchResultParcelV2.Builder<OpenBlobForReadResponse>(
+                        WRITE_PARCEL_MODE_DIRECTLY_WRITE_TO_PARCEL, AppSearchResult.RESULT_OK)
+                .setOpenBlobForReadResponse(OpenBlobForReadResponse)
+                .build();
+    }
+
+    @NonNull
+    public AppSearchResult<ValueType> getResult() {
+        return mResultCached;
+    }
+
+    /** @hide */
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        dest.writeInt(mWriteParcelMode);
+        switch (mWriteParcelMode) {
+            case WRITE_PARCEL_MODE_MARSHALL_WRITE_IN_BLOB:
+                byte[] bytes;
+                // Create a parcel object to serialize results. So that we can use
+                // Parcel.writeBlob() to
+                // send data. WriteBlob() could take care of whether to pass data via binder
+                // directly or
+                // Android shared memory if the data is large.
+                Parcel data = Parcel.obtain();
+                try {
+                    directlyWriteToParcel(this, data, flags);
+                    bytes = data.marshall();
+                } finally {
+                    data.recycle();
+                }
+                ParcelableUtil.writeBlob(dest, bytes);
+                break;
+            case WRITE_PARCEL_MODE_DIRECTLY_WRITE_TO_PARCEL:
+                directlyWriteToParcel(this, dest, flags);
+                break;
+            default:
+                throw new UnsupportedOperationException(
+                        "Cannot write AppSearchResultParcelV2 to Parcel with unknown model: "
+                                + mWriteParcelMode);
+        }
+    }
+
+    /**
+     * Builder for {@link AppSearchResultParcelV2} objects.
+     *
+     * @param <ValueType> The type of the result objects for successful results.
+     */
+    static final class Builder<ValueType> {
+
+        @ParcelableUtil.WriteParcelMode private final int mWriteParcelMode;
+        @AppSearchResult.ResultCode private final int mResultCode;
+        @Nullable private String mErrorMessage;
+        @Nullable private ParcelFileDescriptor mParcelFileDescriptor;
+        @Nullable private OpenBlobForWriteResponse mOpenBlobForWriteResponse;
+        @Nullable private CommitBlobResponse mCommitBlobResponse;
+        @Nullable private OpenBlobForReadResponse mOpenBlobForReadResponse;
+        @Nullable private RemoveBlobResponse mRemoveBlobResponse;
+
+        /** Builds an {@link AppSearchResultParcelV2.Builder}. */
+        Builder(@ParcelableUtil.WriteParcelMode int writeParcelMode, int resultCode) {
+            mWriteParcelMode = writeParcelMode;
+            mResultCode = resultCode;
+        }
+
+        @CanIgnoreReturnValue
+        Builder<ValueType> setErrorMessage(@Nullable String errorMessage) {
+            mErrorMessage = errorMessage;
+            return this;
+        }
+
+        @CanIgnoreReturnValue
+        Builder<ValueType> setParcelFileDescriptor(ParcelFileDescriptor parcelFileDescriptor) {
+            mParcelFileDescriptor = parcelFileDescriptor;
+            return this;
+        }
+
+        @CanIgnoreReturnValue
+        Builder<ValueType> setOpenBlobForWriteResponse(
+                OpenBlobForWriteResponse openBlobForWriteResponse) {
+            mOpenBlobForWriteResponse = openBlobForWriteResponse;
+            return this;
+        }
+
+        @CanIgnoreReturnValue
+        Builder<ValueType> setRemoveBlobResponse(RemoveBlobResponse removeBlobResponse) {
+            mRemoveBlobResponse = removeBlobResponse;
+            return this;
+        }
+
+        @CanIgnoreReturnValue
+        Builder<ValueType> setCommitBlobResponse(CommitBlobResponse commitBlobResponse) {
+            mCommitBlobResponse = commitBlobResponse;
+            return this;
+        }
+
+        @CanIgnoreReturnValue
+        Builder<ValueType> setOpenBlobForReadResponse(
+                OpenBlobForReadResponse OpenBlobForReadResponse) {
+            mOpenBlobForReadResponse = OpenBlobForReadResponse;
+            return this;
+        }
+
+        /**
+         * Builds an {@link AppSearchResultParcelV2} object from the contents of this {@link
+         * AppSearchResultParcelV2.Builder}.
+         */
+        @NonNull
+        AppSearchResultParcelV2<ValueType> build() {
+            return new AppSearchResultParcelV2<>(
+                    mWriteParcelMode,
+                    mResultCode,
+                    mErrorMessage,
+                    mParcelFileDescriptor,
+                    mOpenBlobForWriteResponse,
+                    mCommitBlobResponse,
+                    mOpenBlobForReadResponse,
+                    mRemoveBlobResponse);
+        }
+    }
+}
diff --git a/framework/java/android/app/appsearch/functions/ExecuteAppFunctionRequest.aidl b/framework/java/android/app/appsearch/aidl/CommitBlobAidlRequest.aidl
similarity index 88%
rename from framework/java/android/app/appsearch/functions/ExecuteAppFunctionRequest.aidl
rename to framework/java/android/app/appsearch/aidl/CommitBlobAidlRequest.aidl
index e2601ccf..276efc28 100644
--- a/framework/java/android/app/appsearch/functions/ExecuteAppFunctionRequest.aidl
+++ b/framework/java/android/app/appsearch/aidl/CommitBlobAidlRequest.aidl
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package android.app.appsearch.functions;
+package android.app.appsearch.aidl;
 
 /** {@hide} */
-parcelable ExecuteAppFunctionRequest;
+parcelable CommitBlobAidlRequest;
\ No newline at end of file
diff --git a/framework/java/android/app/appsearch/aidl/CommitBlobAidlRequest.java b/framework/java/android/app/appsearch/aidl/CommitBlobAidlRequest.java
new file mode 100644
index 00000000..4b4b7050
--- /dev/null
+++ b/framework/java/android/app/appsearch/aidl/CommitBlobAidlRequest.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch.aidl;
+
+import android.annotation.ElapsedRealtimeLong;
+import android.annotation.NonNull;
+import android.app.appsearch.AppSearchBlobHandle;
+import android.app.appsearch.safeparcel.AbstractSafeParcelable;
+import android.app.appsearch.safeparcel.SafeParcelable;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.os.UserHandle;
+
+import java.util.Collections;
+import java.util.List;
+import java.util.Objects;
+
+/**
+ * Encapsulates a request to make a binder call to commit a batch of blob to AppSearch
+ *
+ * @hide
+ */
+@SafeParcelable.Class(creator = "CommitBlobAidlRequestCreator")
+public final class CommitBlobAidlRequest extends AbstractSafeParcelable {
+    @NonNull
+    public static final Parcelable.Creator<CommitBlobAidlRequest> CREATOR =
+            new CommitBlobAidlRequestCreator();
+
+    @NonNull
+    @Field(id = 1, getter = "getCallerAttributionSource")
+    private final AppSearchAttributionSource mCallerAttributionSource;
+
+    @NonNull
+    @Field(id = 2, getter = "getCallingDatabaseName")
+    private final String mCallingDatabaseName;
+
+    @NonNull
+    @Field(id = 3, getter = "getBlobHandles")
+    private final List<AppSearchBlobHandle> mBlobHandles;
+
+    @NonNull
+    @Field(id = 4, getter = "getUserHandle")
+    private final UserHandle mUserHandle;
+
+    @Field(id = 5, getter = "getBinderCallStartTimeMillis")
+    private final long mBinderCallStartTimeMillis;
+
+    /**
+     * Commit a batch of blob to AppSearch
+     *
+     * @param callerAttributionSource The permission identity of the package that is getting this
+     *     document.
+     * @param callingDatabaseName The database name of these blob stored in.
+     * @param blobHandles The blobs to commit
+     * @param userHandle Handle of the calling user.
+     * @param binderCallStartTimeMillis start timestamp of binder call in Millis.
+     */
+    @Constructor
+    public CommitBlobAidlRequest(
+            @Param(id = 1) @NonNull AppSearchAttributionSource callerAttributionSource,
+            @Param(id = 2) @NonNull String callingDatabaseName,
+            @Param(id = 3) @NonNull List<AppSearchBlobHandle> blobHandles,
+            @Param(id = 4) @NonNull UserHandle userHandle,
+            @Param(id = 5) long binderCallStartTimeMillis) {
+        mCallerAttributionSource = Objects.requireNonNull(callerAttributionSource);
+        mCallingDatabaseName = Objects.requireNonNull(callingDatabaseName);
+        mBlobHandles = Objects.requireNonNull(blobHandles);
+        mUserHandle = Objects.requireNonNull(userHandle);
+        mBinderCallStartTimeMillis = binderCallStartTimeMillis;
+    }
+
+    @NonNull
+    public AppSearchAttributionSource getCallerAttributionSource() {
+        return mCallerAttributionSource;
+    }
+
+    @NonNull
+    public String getCallingDatabaseName() {
+        return mCallingDatabaseName;
+    }
+
+    /** Gets the {@code list} of {@link AppSearchBlobHandle} to commit blob to AppSearch. */
+    @NonNull
+    public List<AppSearchBlobHandle> getBlobHandles() {
+        return Collections.unmodifiableList(mBlobHandles);
+    }
+
+    @NonNull
+    public UserHandle getUserHandle() {
+        return mUserHandle;
+    }
+
+    @ElapsedRealtimeLong
+    public long getBinderCallStartTimeMillis() {
+        return mBinderCallStartTimeMillis;
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        CommitBlobAidlRequestCreator.writeToParcel(this, dest, flags);
+    }
+}
diff --git a/framework/java/android/app/appsearch/aidl/ExecuteAppFunctionAidlRequest.java b/framework/java/android/app/appsearch/aidl/ExecuteAppFunctionAidlRequest.java
deleted file mode 100644
index 9008633a..00000000
--- a/framework/java/android/app/appsearch/aidl/ExecuteAppFunctionAidlRequest.java
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.app.appsearch.aidl;
-
-import android.annotation.ElapsedRealtimeLong;
-import android.annotation.NonNull;
-import android.app.appsearch.functions.ExecuteAppFunctionRequest;
-import android.app.appsearch.safeparcel.AbstractSafeParcelable;
-import android.app.appsearch.safeparcel.SafeParcelable;
-import android.os.Parcel;
-import android.os.Parcelable;
-import android.os.UserHandle;
-
-import java.util.Objects;
-
-/**
- * Encapsulates a request to make a binder call to execute an app function.
- *
- * @hide
- */
-@SafeParcelable.Class(creator = "ExecuteAppFunctionAidlRequestCreator")
-public final class ExecuteAppFunctionAidlRequest extends AbstractSafeParcelable {
-    @NonNull
-    public static final Parcelable.Creator<ExecuteAppFunctionAidlRequest> CREATOR =
-            new ExecuteAppFunctionAidlRequestCreator();
-
-    @NonNull
-    @Field(id = 1, getter = "getClientRequest")
-    private final ExecuteAppFunctionRequest mClientRequest;
-
-    @NonNull
-    @Field(id = 2, getter = "getCallerAttributionSource")
-    private final AppSearchAttributionSource mCallerAttributionSource;
-
-    @Field(id = 3, getter = "getUserHandle")
-    private final UserHandle mUserHandle;
-
-    @Field(id = 4, getter = "getBinderCallStartTimeMillis")
-    @ElapsedRealtimeLong
-    private final long mBinderCallStartTimeMillis;
-
-    @Constructor
-    public ExecuteAppFunctionAidlRequest(
-            @Param(id = 1) @NonNull ExecuteAppFunctionRequest clientRequest,
-            @Param(id = 2) @NonNull AppSearchAttributionSource callerAttributionSource,
-            @Param(id = 3) @NonNull UserHandle userHandle,
-            @Param(id = 4) long binderCallStartTimeMillis) {
-        mClientRequest = Objects.requireNonNull(clientRequest);
-        mCallerAttributionSource = Objects.requireNonNull(callerAttributionSource);
-        mUserHandle = Objects.requireNonNull(userHandle);
-        mBinderCallStartTimeMillis = binderCallStartTimeMillis;
-    }
-
-    /** Returns the original request created by the client. */
-    @NonNull
-    public ExecuteAppFunctionRequest getClientRequest() {
-        return mClientRequest;
-    }
-
-    @NonNull
-    public AppSearchAttributionSource getCallerAttributionSource() {
-        return mCallerAttributionSource;
-    }
-
-    @NonNull
-    public UserHandle getUserHandle() {
-        return mUserHandle;
-    }
-
-    @ElapsedRealtimeLong
-    public long getBinderCallStartTimeMillis() {
-        return mBinderCallStartTimeMillis;
-    }
-
-    @Override
-    public void writeToParcel(@NonNull Parcel dest, int flags) {
-        ExecuteAppFunctionAidlRequestCreator.writeToParcel(this, dest, flags);
-    }
-}
diff --git a/framework/java/android/app/appsearch/aidl/IAppSearchManager.aidl b/framework/java/android/app/appsearch/aidl/IAppSearchManager.aidl
index b1d0ab0b..1838d3c9 100644
--- a/framework/java/android/app/appsearch/aidl/IAppSearchManager.aidl
+++ b/framework/java/android/app/appsearch/aidl/IAppSearchManager.aidl
@@ -20,10 +20,11 @@ import android.os.UserHandle;
 
 import android.app.appsearch.aidl.AppSearchAttributionSource;
 import android.app.appsearch.aidl.AppSearchResultParcel;
+import android.app.appsearch.aidl.AppSearchResultParcelV2;
 import android.app.appsearch.aidl.IAppSearchBatchResultCallback;
 import android.app.appsearch.aidl.IAppSearchObserverProxy;
 import android.app.appsearch.aidl.IAppSearchResultCallback;
-import android.app.appsearch.aidl.ExecuteAppFunctionAidlRequest;
+import android.app.appsearch.aidl.CommitBlobAidlRequest;
 import android.app.appsearch.aidl.DocumentsParcel;
 import android.app.appsearch.aidl.GetDocumentsAidlRequest;
 import android.app.appsearch.aidl.GetNamespacesAidlRequest;
@@ -33,15 +34,19 @@ import android.app.appsearch.aidl.GetStorageInfoAidlRequest;
 import android.app.appsearch.aidl.GlobalSearchAidlRequest;
 import android.app.appsearch.aidl.InitializeAidlRequest;
 import android.app.appsearch.aidl.InvalidateNextPageTokenAidlRequest;
+import android.app.appsearch.aidl.OpenBlobForReadAidlRequest;
+import android.app.appsearch.aidl.OpenBlobForWriteAidlRequest;
 import android.app.appsearch.aidl.PersistToDiskAidlRequest;
 import android.app.appsearch.aidl.PutDocumentsAidlRequest;
 import android.app.appsearch.aidl.PutDocumentsFromFileAidlRequest;
 import android.app.appsearch.aidl.RegisterObserverCallbackAidlRequest;
+import android.app.appsearch.aidl.RemoveBlobAidlRequest;
 import android.app.appsearch.aidl.RemoveByDocumentIdAidlRequest;
 import android.app.appsearch.aidl.RemoveByQueryAidlRequest;
 import android.app.appsearch.aidl.ReportUsageAidlRequest;
 import android.app.appsearch.aidl.SearchAidlRequest;
 import android.app.appsearch.aidl.SearchSuggestionAidlRequest;
+import android.app.appsearch.aidl.SetBlobVisibilityAidlRequest;
 import android.app.appsearch.aidl.SetSchemaAidlRequest;
 import android.app.appsearch.aidl.UnregisterObserverCallbackAidlRequest;
 import android.app.appsearch.aidl.WriteSearchResultsToFileAidlRequest;
@@ -322,15 +327,62 @@ interface IAppSearchManager {
         in UnregisterObserverCallbackAidlRequest request,
         in IAppSearchObserverProxy observerProxy) = 19;
 
+    // reserved function id = 20.
+
+    /**
+     * Opens a batch of AppSearch Blobs for writing.
+     *
+     * @param request the request to open blob for writing
+     * @param callback {@link IAppSearchResultCallback#onResult} will be called with an
+     *     OpenBlobForWriteResponse
+     */
+    void openBlobForWrite(
+       in OpenBlobForWriteAidlRequest request,
+       in IAppSearchResultCallback callback) = 21;
+
+    /**
+     * Commits the blobs to make it retrievable and immutable.
+     *
+     * @param request the request to commit blobs
+     * @param callback {@link IAppSearchResultCallback#onResult} will be called with an
+     *     CommitBlobResponse
+     */
+    void commitBlob(
+       in CommitBlobAidlRequest request,
+       in IAppSearchResultCallback callback) = 22;
+
     /**
-     * Executes an app function provided by {@link AppFunctionService} through the system.
+     * Opens a batch of AppSearch Blobs for reading.
      *
-     * @param request the request to execute an app function.
-     * @param callback the callback to report the result.
+     * @param request the request to open blob for reading
+     * @param callback {@link IAppSearchResultCallback#onResult} will be called with an
+     *    OpenBlobForReadResponse
+     */
+   void openBlobForRead(
+       in OpenBlobForReadAidlRequest request,
+       in IAppSearchResultCallback callback) = 23;
+
+   /**
+     * Removes a batch of blobs from AppSearch
+     *
+     * @param request the request to remove blobs
+     * @param callback {@link IAppSearchResultCallback#onResult} will be called with an
+     *     RemoveBlobResponse
+     */
+   void removeBlob(
+       in RemoveBlobAidlRequest request,
+       in IAppSearchResultCallback callback) = 24;
+
+   /**
+     * Set blob visibility for a specific database to AppSearch
+     *
+     * @param request the request to set blob visibility settings.
+     * @param callback {@link IAppSearchResultCallback#onResult} will be called with an
+     *     {@link AppSearchResult}&lt;{@link Void}&gt;.
      */
-   void executeAppFunction(
-       in ExecuteAppFunctionAidlRequest request,
-       in IAppSearchResultCallback callback) = 20;
+   void setBlobVisibility(
+       in SetBlobVisibilityAidlRequest request,
+       in IAppSearchResultCallback callback) = 25;
 
-    // next function transaction ID = 21;
+    // next function transaction ID = 26;
 }
diff --git a/framework/java/android/app/appsearch/aidl/IAppSearchResultCallback.aidl b/framework/java/android/app/appsearch/aidl/IAppSearchResultCallback.aidl
index 097f0d18..e6bf6486 100644
--- a/framework/java/android/app/appsearch/aidl/IAppSearchResultCallback.aidl
+++ b/framework/java/android/app/appsearch/aidl/IAppSearchResultCallback.aidl
@@ -16,8 +16,10 @@
 package android.app.appsearch.aidl;
 
 import android.app.appsearch.aidl.AppSearchResultParcel;
+import android.app.appsearch.aidl.AppSearchResultParcelV2;
 
 /** {@hide} */
 oneway interface IAppSearchResultCallback {
     void onResult(in AppSearchResultParcel resultParcel);
+    void onResultV2(in AppSearchResultParcelV2 resultParcel);
 }
diff --git a/framework/java/android/app/appsearch/functions/ExecuteAppFunctionResponse.aidl b/framework/java/android/app/appsearch/aidl/OpenBlobForReadAidlRequest.aidl
similarity index 88%
rename from framework/java/android/app/appsearch/functions/ExecuteAppFunctionResponse.aidl
rename to framework/java/android/app/appsearch/aidl/OpenBlobForReadAidlRequest.aidl
index 7ed9ab95..24bb9b34 100644
--- a/framework/java/android/app/appsearch/functions/ExecuteAppFunctionResponse.aidl
+++ b/framework/java/android/app/appsearch/aidl/OpenBlobForReadAidlRequest.aidl
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package android.app.appsearch.functions;
+package android.app.appsearch.aidl;
 
 /** {@hide} */
-parcelable ExecuteAppFunctionResponse;
+parcelable OpenBlobForReadAidlRequest;
\ No newline at end of file
diff --git a/framework/java/android/app/appsearch/aidl/OpenBlobForReadAidlRequest.java b/framework/java/android/app/appsearch/aidl/OpenBlobForReadAidlRequest.java
new file mode 100644
index 00000000..f98cbb0c
--- /dev/null
+++ b/framework/java/android/app/appsearch/aidl/OpenBlobForReadAidlRequest.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch.aidl;
+
+import android.annotation.ElapsedRealtimeLong;
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.app.appsearch.AppSearchBlobHandle;
+import android.app.appsearch.safeparcel.AbstractSafeParcelable;
+import android.app.appsearch.safeparcel.SafeParcelable;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.os.UserHandle;
+
+import java.util.Collections;
+import java.util.List;
+import java.util.Objects;
+
+/**
+ * Encapsulates a request to make a binder call to open a batch of blob from AppSearch to read.
+ *
+ * @hide
+ */
+@SafeParcelable.Class(creator = "OpenBlobForReadAidlRequestCreator")
+public class OpenBlobForReadAidlRequest extends AbstractSafeParcelable {
+    @NonNull
+    public static final Parcelable.Creator<OpenBlobForReadAidlRequest> CREATOR =
+            new OpenBlobForReadAidlRequestCreator();
+
+    @NonNull
+    @Field(id = 1, getter = "getCallerAttributionSource")
+    private final AppSearchAttributionSource mCallerAttributionSource;
+
+    @Nullable
+    @Field(id = 2, getter = "getCallingDatabaseName")
+    private final String mCallingDatabaseName;
+
+    @NonNull
+    @Field(id = 3, getter = "getBlobHandles")
+    private final List<AppSearchBlobHandle> mBlobHandles;
+
+    @NonNull
+    @Field(id = 4, getter = "getUserHandle")
+    private final UserHandle mUserHandle;
+
+    @Field(id = 5, getter = "getBinderCallStartTimeMillis")
+    private final long mBinderCallStartTimeMillis;
+
+    /**
+     * Retrieves documents from the index.
+     *
+     * @param callerAttributionSource The permission identity of the package that is getting this
+     *     document.
+     * @param callingDatabaseName The database name of these blob stored in.
+     * @param blobHandles The blobs to read
+     * @param userHandle Handle of the calling user.
+     * @param binderCallStartTimeMillis start timestamp of binder call in Millis.
+     */
+    @Constructor
+    public OpenBlobForReadAidlRequest(
+            @Param(id = 1) @NonNull AppSearchAttributionSource callerAttributionSource,
+            @Param(id = 2) @Nullable String callingDatabaseName,
+            @Param(id = 3) @NonNull List<AppSearchBlobHandle> blobHandles,
+            @Param(id = 4) @NonNull UserHandle userHandle,
+            @Param(id = 5) long binderCallStartTimeMillis) {
+        mCallerAttributionSource = Objects.requireNonNull(callerAttributionSource);
+        mCallingDatabaseName = callingDatabaseName;
+        mBlobHandles = Objects.requireNonNull(blobHandles);
+        mUserHandle = Objects.requireNonNull(userHandle);
+        mBinderCallStartTimeMillis = binderCallStartTimeMillis;
+    }
+
+    @NonNull
+    public AppSearchAttributionSource getCallerAttributionSource() {
+        return mCallerAttributionSource;
+    }
+
+    @Nullable
+    public String getCallingDatabaseName() {
+        return mCallingDatabaseName;
+    }
+
+    /**
+     * Gets the {@code list} of {@link AppSearchBlobHandle} to open {@link
+     * android.os.ParcelFileDescriptor} for read blob.
+     */
+    @NonNull
+    public List<AppSearchBlobHandle> getBlobHandles() {
+        return Collections.unmodifiableList(mBlobHandles);
+    }
+
+    @NonNull
+    public UserHandle getUserHandle() {
+        return mUserHandle;
+    }
+
+    @ElapsedRealtimeLong
+    public long getBinderCallStartTimeMillis() {
+        return mBinderCallStartTimeMillis;
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        OpenBlobForReadAidlRequestCreator.writeToParcel(this, dest, flags);
+    }
+}
diff --git a/framework/java/android/app/appsearch/aidl/OpenBlobForWriteAidlRequest.aidl b/framework/java/android/app/appsearch/aidl/OpenBlobForWriteAidlRequest.aidl
new file mode 100644
index 00000000..1e7aa04d
--- /dev/null
+++ b/framework/java/android/app/appsearch/aidl/OpenBlobForWriteAidlRequest.aidl
@@ -0,0 +1,19 @@
+/**
+ * Copyright 2024, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.app.appsearch.aidl;
+
+/** {@hide} */
+parcelable OpenBlobForWriteAidlRequest;
\ No newline at end of file
diff --git a/framework/java/android/app/appsearch/aidl/OpenBlobForWriteAidlRequest.java b/framework/java/android/app/appsearch/aidl/OpenBlobForWriteAidlRequest.java
new file mode 100644
index 00000000..017baf12
--- /dev/null
+++ b/framework/java/android/app/appsearch/aidl/OpenBlobForWriteAidlRequest.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch.aidl;
+
+import android.annotation.ElapsedRealtimeLong;
+import android.annotation.NonNull;
+import android.app.appsearch.AppSearchBlobHandle;
+import android.app.appsearch.safeparcel.AbstractSafeParcelable;
+import android.app.appsearch.safeparcel.SafeParcelable;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.os.UserHandle;
+
+import java.util.Collections;
+import java.util.List;
+import java.util.Objects;
+
+/**
+ * Encapsulates a request to make a binder call to open a batch of blob from AppSearch to write.
+ *
+ * @hide
+ */
+@SafeParcelable.Class(creator = "OpenBlobForWriteAidlRequestCreator")
+public final class OpenBlobForWriteAidlRequest extends AbstractSafeParcelable {
+    @NonNull
+    public static final Parcelable.Creator<OpenBlobForWriteAidlRequest> CREATOR =
+            new OpenBlobForWriteAidlRequestCreator();
+
+    @NonNull
+    @Field(id = 1, getter = "getCallerAttributionSource")
+    private final AppSearchAttributionSource mCallerAttributionSource;
+
+    @NonNull
+    @Field(id = 2, getter = "getCallingDatabaseName")
+    private final String mCallingDatabaseName;
+
+    @NonNull
+    @Field(id = 3, getter = "getBlobHandles")
+    private final List<AppSearchBlobHandle> mBlobHandles;
+
+    @NonNull
+    @Field(id = 4, getter = "getUserHandle")
+    private final UserHandle mUserHandle;
+
+    @Field(id = 5, getter = "getBinderCallStartTimeMillis")
+    private final long mBinderCallStartTimeMillis;
+
+    /**
+     * Retrieves documents from the index.
+     *
+     * @param callerAttributionSource The permission identity of the package that is getting this
+     *     document.
+     * @param callingDatabaseName The database name of these blob stored in.
+     * @param blobHandles The blobs to write
+     * @param userHandle Handle of the calling user.
+     * @param binderCallStartTimeMillis start timestamp of binder call in Millis.
+     */
+    @Constructor
+    public OpenBlobForWriteAidlRequest(
+            @Param(id = 1) @NonNull AppSearchAttributionSource callerAttributionSource,
+            @Param(id = 2) @NonNull String callingDatabaseName,
+            @Param(id = 3) @NonNull List<AppSearchBlobHandle> blobHandles,
+            @Param(id = 4) @NonNull UserHandle userHandle,
+            @Param(id = 5) long binderCallStartTimeMillis) {
+        mCallerAttributionSource = Objects.requireNonNull(callerAttributionSource);
+        mCallingDatabaseName = Objects.requireNonNull(callingDatabaseName);
+        mBlobHandles = Objects.requireNonNull(blobHandles);
+        mUserHandle = Objects.requireNonNull(userHandle);
+        mBinderCallStartTimeMillis = binderCallStartTimeMillis;
+    }
+
+    @NonNull
+    public AppSearchAttributionSource getCallerAttributionSource() {
+        return mCallerAttributionSource;
+    }
+
+    @NonNull
+    public String getCallingDatabaseName() {
+        return mCallingDatabaseName;
+    }
+
+    /**
+     * Gets the {@code list} of {@link AppSearchBlobHandle} to open {@link
+     * android.os.ParcelFileDescriptor} for write blob.
+     */
+    @NonNull
+    public List<AppSearchBlobHandle> getBlobHandles() {
+        return Collections.unmodifiableList(mBlobHandles);
+    }
+
+    @NonNull
+    public UserHandle getUserHandle() {
+        return mUserHandle;
+    }
+
+    @ElapsedRealtimeLong
+    public long getBinderCallStartTimeMillis() {
+        return mBinderCallStartTimeMillis;
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        OpenBlobForWriteAidlRequestCreator.writeToParcel(this, dest, flags);
+    }
+}
diff --git a/framework/java/android/app/appsearch/aidl/RemoveBlobAidlRequest.aidl b/framework/java/android/app/appsearch/aidl/RemoveBlobAidlRequest.aidl
new file mode 100644
index 00000000..03e69742
--- /dev/null
+++ b/framework/java/android/app/appsearch/aidl/RemoveBlobAidlRequest.aidl
@@ -0,0 +1,19 @@
+/**
+ * Copyright 2024, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.app.appsearch.aidl;
+
+/** {@hide} */
+parcelable RemoveBlobAidlRequest;
\ No newline at end of file
diff --git a/framework/java/android/app/appsearch/aidl/RemoveBlobAidlRequest.java b/framework/java/android/app/appsearch/aidl/RemoveBlobAidlRequest.java
new file mode 100644
index 00000000..56a37c20
--- /dev/null
+++ b/framework/java/android/app/appsearch/aidl/RemoveBlobAidlRequest.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch.aidl;
+
+import android.annotation.ElapsedRealtimeLong;
+import android.annotation.NonNull;
+import android.app.appsearch.AppSearchBlobHandle;
+import android.app.appsearch.safeparcel.AbstractSafeParcelable;
+import android.app.appsearch.safeparcel.SafeParcelable;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.os.UserHandle;
+
+import java.util.Collections;
+import java.util.List;
+import java.util.Objects;
+
+/**
+ * Encapsulates a request to make a binder call to remove a batch of blob to AppSearch
+ *
+ * @hide
+ */
+@SafeParcelable.Class(creator = "RemoveBlobAidlRequestCreator")
+public final class RemoveBlobAidlRequest extends AbstractSafeParcelable {
+    @NonNull
+    public static final Parcelable.Creator<RemoveBlobAidlRequest> CREATOR =
+            new RemoveBlobAidlRequestCreator();
+
+    @NonNull
+    @Field(id = 1, getter = "getCallerAttributionSource")
+    private final AppSearchAttributionSource mCallerAttributionSource;
+
+    @NonNull
+    @Field(id = 2, getter = "getCallingDatabaseName")
+    private final String mCallingDatabaseName;
+
+    @NonNull
+    @Field(id = 3, getter = "getBlobHandles")
+    private final List<AppSearchBlobHandle> mBlobHandles;
+
+    @NonNull
+    @Field(id = 4, getter = "getUserHandle")
+    private final UserHandle mUserHandle;
+
+    @Field(id = 5, getter = "getBinderCallStartTimeMillis")
+    private final long mBinderCallStartTimeMillis;
+
+    /**
+     * Commit a batch of blob to AppSearch
+     *
+     * @param callerAttributionSource The permission identity of the package that is getting this
+     *     document.
+     * @param callingDatabaseName The database name of these blob stored in.
+     * @param blobHandles The blobs to remove
+     * @param userHandle Handle of the calling user.
+     * @param binderCallStartTimeMillis start timestamp of binder call in Millis.
+     */
+    @Constructor
+    public RemoveBlobAidlRequest(
+            @Param(id = 1) @NonNull AppSearchAttributionSource callerAttributionSource,
+            @Param(id = 2) @NonNull String callingDatabaseName,
+            @Param(id = 3) @NonNull List<AppSearchBlobHandle> blobHandles,
+            @Param(id = 4) @NonNull UserHandle userHandle,
+            @Param(id = 5) long binderCallStartTimeMillis) {
+        mCallerAttributionSource = Objects.requireNonNull(callerAttributionSource);
+        mCallingDatabaseName = Objects.requireNonNull(callingDatabaseName);
+        mBlobHandles = Objects.requireNonNull(blobHandles);
+        mUserHandle = Objects.requireNonNull(userHandle);
+        mBinderCallStartTimeMillis = binderCallStartTimeMillis;
+    }
+
+    @NonNull
+    public AppSearchAttributionSource getCallerAttributionSource() {
+        return mCallerAttributionSource;
+    }
+
+    @NonNull
+    public String getCallingDatabaseName() {
+        return mCallingDatabaseName;
+    }
+
+    /** Gets the {@code list} of {@link AppSearchBlobHandle} to remove blobs from AppSearch. */
+    @NonNull
+    public List<AppSearchBlobHandle> getBlobHandles() {
+        return Collections.unmodifiableList(mBlobHandles);
+    }
+
+    @NonNull
+    public UserHandle getUserHandle() {
+        return mUserHandle;
+    }
+
+    @ElapsedRealtimeLong
+    public long getBinderCallStartTimeMillis() {
+        return mBinderCallStartTimeMillis;
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        RemoveBlobAidlRequestCreator.writeToParcel(this, dest, flags);
+    }
+}
diff --git a/framework/java/android/app/appsearch/aidl/SetBlobVisibilityAidlRequest.aidl b/framework/java/android/app/appsearch/aidl/SetBlobVisibilityAidlRequest.aidl
new file mode 100644
index 00000000..8b5953ba
--- /dev/null
+++ b/framework/java/android/app/appsearch/aidl/SetBlobVisibilityAidlRequest.aidl
@@ -0,0 +1,19 @@
+/**
+ * Copyright 2024, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.app.appsearch.aidl;
+
+/** {@hide} */
+parcelable SetBlobVisibilityAidlRequest;
\ No newline at end of file
diff --git a/framework/java/android/app/appsearch/aidl/SetBlobVisibilityAidlRequest.java b/framework/java/android/app/appsearch/aidl/SetBlobVisibilityAidlRequest.java
new file mode 100644
index 00000000..3e169217
--- /dev/null
+++ b/framework/java/android/app/appsearch/aidl/SetBlobVisibilityAidlRequest.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch.aidl;
+
+import android.annotation.ElapsedRealtimeLong;
+import android.annotation.NonNull;
+import android.app.appsearch.InternalVisibilityConfig;
+import android.app.appsearch.safeparcel.AbstractSafeParcelable;
+import android.app.appsearch.safeparcel.SafeParcelable;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.os.UserHandle;
+
+import java.util.Collections;
+import java.util.List;
+import java.util.Objects;
+
+/**
+ * Encapsulates a request to make a binder call to set visibility configs to all blob namespaces in
+ * a database to AppSearch
+ *
+ * @hide
+ */
+@SafeParcelable.Class(creator = "SetBlobVisibilityAidlRequestCreator")
+public final class SetBlobVisibilityAidlRequest extends AbstractSafeParcelable {
+    @NonNull
+    public static final Parcelable.Creator<SetBlobVisibilityAidlRequest> CREATOR =
+            new SetBlobVisibilityAidlRequestCreator();
+
+    @NonNull
+    @Field(id = 1, getter = "getCallerAttributionSource")
+    private final AppSearchAttributionSource mCallerAttributionSource;
+
+    @NonNull
+    @Field(id = 2, getter = "getCallingDatabaseName")
+    private final String mCallingDatabaseName;
+
+    @NonNull
+    @Field(id = 3, getter = "getVisibilityConfigs")
+    private final List<InternalVisibilityConfig> mVisibilityConfigs;
+
+    @NonNull
+    @Field(id = 4, getter = "getUserHandle")
+    private final UserHandle mUserHandle;
+
+    @Field(id = 5, getter = "getBinderCallStartTimeMillis")
+    private final long mBinderCallStartTimeMillis;
+
+    /**
+     * Sets visibility configs to all blob namespaces in a database to AppSearch
+     *
+     * @param callerAttributionSource The permission identity of the package that is getting this
+     *     document.
+     * @param callingDatabaseName The database name of these blob namespaces stored in.
+     * @param visibilityConfigs List of {@link InternalVisibilityConfig} objects defining the
+     *     visibility for the blob namespaces.
+     * @param userHandle Handle of the calling user.
+     * @param binderCallStartTimeMillis start timestamp of binder call in Millis.
+     */
+    @Constructor
+    public SetBlobVisibilityAidlRequest(
+            @Param(id = 1) @NonNull AppSearchAttributionSource callerAttributionSource,
+            @Param(id = 2) @NonNull String callingDatabaseName,
+            @Param(id = 3) @NonNull List<InternalVisibilityConfig> visibilityConfigs,
+            @Param(id = 4) @NonNull UserHandle userHandle,
+            @Param(id = 5) long binderCallStartTimeMillis) {
+        mCallerAttributionSource = Objects.requireNonNull(callerAttributionSource);
+        mCallingDatabaseName = Objects.requireNonNull(callingDatabaseName);
+        mVisibilityConfigs = Objects.requireNonNull(visibilityConfigs);
+        mUserHandle = Objects.requireNonNull(userHandle);
+        mBinderCallStartTimeMillis = binderCallStartTimeMillis;
+    }
+
+    @NonNull
+    public AppSearchAttributionSource getCallerAttributionSource() {
+        return mCallerAttributionSource;
+    }
+
+    @NonNull
+    public String getCallingDatabaseName() {
+        return mCallingDatabaseName;
+    }
+
+    /**
+     * Gets the {@code list} of {@link InternalVisibilityConfig} contains visibility settings for
+     * blob namespaces.
+     */
+    @NonNull
+    public List<InternalVisibilityConfig> getVisibilityConfigs() {
+        return Collections.unmodifiableList(mVisibilityConfigs);
+    }
+
+    @NonNull
+    public UserHandle getUserHandle() {
+        return mUserHandle;
+    }
+
+    @ElapsedRealtimeLong
+    public long getBinderCallStartTimeMillis() {
+        return mBinderCallStartTimeMillis;
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        SetBlobVisibilityAidlRequestCreator.writeToParcel(this, dest, flags);
+    }
+}
diff --git a/framework/java/android/app/appsearch/functions/AppFunctionManager.java b/framework/java/android/app/appsearch/functions/AppFunctionManager.java
deleted file mode 100644
index fa916dc6..00000000
--- a/framework/java/android/app/appsearch/functions/AppFunctionManager.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.app.appsearch.functions;
-
-import android.annotation.CallbackExecutor;
-import android.annotation.FlaggedApi;
-import android.annotation.NonNull;
-import android.annotation.SystemApi;
-import android.annotation.UserHandleAware;
-import android.app.appsearch.AppSearchManager;
-import android.app.appsearch.AppSearchResult;
-import android.app.appsearch.SearchSessionUtil;
-import android.app.appsearch.aidl.AppSearchAttributionSource;
-import android.app.appsearch.aidl.AppSearchResultParcel;
-import android.app.appsearch.aidl.ExecuteAppFunctionAidlRequest;
-import android.app.appsearch.aidl.IAppSearchManager;
-import android.app.appsearch.aidl.IAppSearchResultCallback;
-import android.content.Context;
-import android.os.Process;
-import android.os.RemoteException;
-import android.os.SystemClock;
-
-import com.android.appsearch.flags.Flags;
-
-import java.util.Objects;
-import java.util.concurrent.Executor;
-import java.util.function.Consumer;
-
-/**
- * Provides app functions related functionalities.
- *
- * <p>App function is a specific piece of functionality that an app offers to the system. These
- * functionalities can be integrated into various system features.
- *
- * <p>You can obtain an instance using {@link AppSearchManager#getAppFunctionManager()}.
- */
-@FlaggedApi(Flags.FLAG_ENABLE_APP_FUNCTIONS)
-public final class AppFunctionManager {
-    /**
-     * Allows system applications to execute app functions provided by apps through AppSearch.
-     *
-     * <p>Protection level: internal|role.
-     *
-     * @hide
-     */
-    @SystemApi
-    public static final String PERMISSION_EXECUTE_APP_FUNCTION =
-            "android.permission.EXECUTE_APP_FUNCTION";
-
-    /**
-     * Must be required by a {@link android.app.appsearch.functions.AppFunctionService}, to ensure
-     * that only the system can bind to it.
-     *
-     * <p>Protection level: signature.
-     */
-    public static final String PERMISSION_BIND_APP_FUNCTION_SERVICE =
-            "android.permission.BIND_APP_FUNCTION_SERVICE";
-
-    private final IAppSearchManager mService;
-    private final Context mContext;
-
-    /** @hide */
-    public AppFunctionManager(@NonNull Context context, @NonNull IAppSearchManager service) {
-        mContext = Objects.requireNonNull(context);
-        mService = Objects.requireNonNull(service);
-    }
-
-    /**
-     * Executes an app function provided by {@link AppFunctionService} through the system.
-     *
-     * @param request The request.
-     * @param executor Executor on which to invoke the callback.
-     * @param callback A callback to receive the function execution result.
-     */
-    @UserHandleAware
-    public void executeAppFunction(
-            @NonNull ExecuteAppFunctionRequest request,
-            @NonNull @CallbackExecutor Executor executor,
-            @NonNull Consumer<AppSearchResult<ExecuteAppFunctionResponse>> callback) {
-        Objects.requireNonNull(request);
-        Objects.requireNonNull(callback);
-
-        ExecuteAppFunctionAidlRequest aidlRequest =
-                new ExecuteAppFunctionAidlRequest(
-                        request,
-                        AppSearchAttributionSource.createAttributionSource(
-                                mContext, /* callingPid= */ Process.myPid()),
-                        mContext.getUser(),
-                        SystemClock.elapsedRealtime());
-        try {
-            mService.executeAppFunction(
-                    aidlRequest,
-                    new IAppSearchResultCallback.Stub() {
-                        @Override
-                        public void onResult(AppSearchResultParcel result) {
-                            SearchSessionUtil.safeExecute(
-                                    executor, callback, () -> callback.accept(result.getResult()));
-                        }
-                    });
-        } catch (RemoteException ex) {
-            ex.rethrowFromSystemServer();
-        }
-    }
-}
diff --git a/framework/java/android/app/appsearch/functions/AppFunctionService.java b/framework/java/android/app/appsearch/functions/AppFunctionService.java
deleted file mode 100644
index 9d9441c9..00000000
--- a/framework/java/android/app/appsearch/functions/AppFunctionService.java
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.app.appsearch.functions;
-
-import android.annotation.FlaggedApi;
-import android.annotation.MainThread;
-import android.annotation.NonNull;
-import android.annotation.Nullable;
-import android.app.Service;
-import android.app.appsearch.AppSearchResult;
-import android.app.appsearch.aidl.AppSearchResultParcel;
-import android.app.appsearch.aidl.IAppFunctionService;
-import android.app.appsearch.aidl.IAppSearchResultCallback;
-import android.content.Intent;
-import android.os.Binder;
-import android.os.IBinder;
-import android.os.Process;
-
-import com.android.appsearch.flags.Flags;
-
-import java.util.function.Consumer;
-
-/**
- * Abstract base class to provide app functions to the system.
- *
- * <p>Include the following in the manifest:
- *
- * <pre>
- * {@literal
- * <service android:name=".YourService"
- *      android:permission="android.permission.BIND_APP_FUNCTION_SERVICE">
- *    <intent-filter>
- *      <action android:name="android.app.appsearch.functions.AppFunctionService" />
- *    </intent-filter>
- * </service>
- * }
- * </pre>
- *
- * @see AppFunctionManager
- */
-@FlaggedApi(Flags.FLAG_ENABLE_APP_FUNCTIONS)
-public abstract class AppFunctionService extends Service {
-    private static final String TAG = "AppSearchAppFunction";
-
-    /**
-     * The {@link Intent} that must be declared as handled by the service. To be supported, the
-     * service must also require the {@link AppFunctionManager#PERMISSION_BIND_APP_FUNCTION_SERVICE}
-     * permission so that other applications can not abuse it.
-     */
-    @NonNull
-    public static final String SERVICE_INTERFACE =
-            "android.app.appsearch.functions.AppFunctionService";
-
-    private final Binder mBinder =
-            new IAppFunctionService.Stub() {
-                @Override
-                public void executeAppFunction(
-                        @NonNull ExecuteAppFunctionRequest request,
-                        @NonNull IAppSearchResultCallback callback) {
-                    // TODO(b/327134039): Replace this check with the new permission
-                    if (Binder.getCallingUid() != Process.SYSTEM_UID) {
-                        throw new SecurityException("Can only be called by the system server");
-                    }
-                    SafeOneTimeAppSearchResultCallback safeCallback =
-                            new SafeOneTimeAppSearchResultCallback(callback);
-                    try {
-                        AppFunctionService.this.onExecuteFunction(
-                                request,
-                                appFunctionResult -> {
-                                    AppSearchResultParcel appSearchResultParcel;
-                                    // Create result from value in success case and errorMessage in
-                                    // failure case.
-                                    if (appFunctionResult.isSuccess()) {
-                                        appSearchResultParcel =
-                                                AppSearchResultParcel
-                                                        .fromExecuteAppFunctionResponse(
-                                                                appFunctionResult.getResultValue());
-                                    } else {
-                                        appSearchResultParcel =
-                                                AppSearchResultParcel.fromFailedResult(
-                                                        appFunctionResult);
-                                    }
-                                    safeCallback.onResult(appSearchResultParcel);
-                                });
-                    } catch (Exception ex) {
-                        // Apps should handle exceptions. But if they don't, report the error on
-                        // behalf of them.
-                        AppSearchResult failedResult = AppSearchResult.throwableToFailedResult(ex);
-                        safeCallback.onResult(AppSearchResultParcel.fromFailedResult(failedResult));
-                    }
-                }
-            };
-
-    @NonNull
-    @Override
-    public final IBinder onBind(@Nullable Intent intent) {
-        return mBinder;
-    }
-
-    /**
-     * Called by the system to execute a specific app function.
-     *
-     * <p>This method is triggered when the system requests your AppFunctionService to handle a
-     * particular function you have registered and made available.
-     *
-     * <p>To ensure proper routing of function requests, assign a unique identifier to each
-     * function. This identifier doesn't need to be globally unique, but it must be unique within
-     * your app. For example, a function to order food could be identified as "orderFood". You can
-     * determine the specific function to invoke by calling {@link
-     * ExecuteAppFunctionRequest#getFunctionIdentifier()}.
-     *
-     * <p>This method is always triggered in the main thread. You should run heavy tasks on a worker
-     * thread and dispatch the result with the given callback. You should always report back the
-     * result using the callback, no matter if the execution was successful or not.
-     *
-     * @param request The function execution request.
-     * @param callback A callback to report back the result.
-     */
-    @MainThread
-    public abstract void onExecuteFunction(
-            @NonNull ExecuteAppFunctionRequest request,
-            @NonNull Consumer<AppSearchResult<ExecuteAppFunctionResponse>> callback);
-}
diff --git a/framework/java/android/app/appsearch/functions/ExecuteAppFunctionRequest.java b/framework/java/android/app/appsearch/functions/ExecuteAppFunctionRequest.java
deleted file mode 100644
index 80dd66f5..00000000
--- a/framework/java/android/app/appsearch/functions/ExecuteAppFunctionRequest.java
+++ /dev/null
@@ -1,220 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.app.appsearch.functions;
-
-import android.annotation.FlaggedApi;
-import android.annotation.NonNull;
-import android.annotation.Nullable;
-import android.app.appsearch.GenericDocument;
-import android.app.appsearch.safeparcel.AbstractSafeParcelable;
-import android.app.appsearch.safeparcel.GenericDocumentParcel;
-import android.app.appsearch.safeparcel.SafeParcelable;
-import android.os.Bundle;
-import android.os.Parcel;
-import android.os.Parcelable;
-
-import com.android.appsearch.flags.Flags;
-
-import java.util.Objects;
-import java.util.concurrent.Executor;
-import java.util.function.Consumer;
-
-/**
- * Represents a request to execute a specific app function.
- *
- * @see AppFunctionManager#executeAppFunction(ExecuteAppFunctionRequest, Executor, Consumer)
- */
-@FlaggedApi(Flags.FLAG_ENABLE_APP_FUNCTIONS)
-@SafeParcelable.Class(creator = "ExecuteAppFunctionRequestCreator")
-public final class ExecuteAppFunctionRequest extends AbstractSafeParcelable implements Parcelable {
-    @NonNull
-    public static final Parcelable.Creator<ExecuteAppFunctionRequest> CREATOR =
-            new ExecuteAppFunctionRequestCreator();
-
-    @Field(id = 1, getter = "getTargetPackageName")
-    @NonNull
-    private final String mTargetPackageName;
-
-    @Field(id = 2, getter = "getFunctionIdentifier")
-    @NonNull
-    private final String mFunctionIdentifier;
-
-    /**
-     * {@link GenericDocument} is not a Parcelable, so storing it as a GenericDocumentParcel here.
-     */
-    @Field(id = 3)
-    @NonNull
-    final GenericDocumentParcel mParameters;
-
-    @Field(id = 4, getter = "getExtras")
-    @NonNull
-    private final Bundle mExtras;
-
-    @Field(id = 5, getter = "getSha256Certificate")
-    @Nullable
-    private final byte[] mSha256Certificate;
-
-    @NonNull private final GenericDocument mParametersCached;
-
-    /** Returns the package name of the app that hosts the function. */
-    @NonNull
-    public String getTargetPackageName() {
-        return mTargetPackageName;
-    }
-
-    /** Returns the unique string identifier of the app function to be executed. */
-    @NonNull
-    public String getFunctionIdentifier() {
-        return mFunctionIdentifier;
-    }
-
-    /**
-     * Returns the parameters required to invoke this function. Within this {@link GenericDocument},
-     * the property names are the names of the function parameters and the property values are the
-     * values of those parameters
-     *
-     * <p>The document may have missing parameters. Developers are advised to implement defensive
-     * handling measures.
-     */
-    @NonNull
-    public GenericDocument getParameters() {
-        return mParametersCached;
-    }
-
-    /**
-     * Returns the expected certificate SHA-256 digests of the target package. Returns {@code null}
-     * if no certificate digest checking is configured.
-     *
-     * @see Builder#getSha256Certificate()
-     */
-    @Nullable
-    public byte[] getSha256Certificate() {
-        return mSha256Certificate;
-    }
-
-    /** Returns additional metadata relevant to this function execution request. */
-    @NonNull
-    public Bundle getExtras() {
-        return mExtras;
-    }
-
-    private ExecuteAppFunctionRequest(
-            @NonNull String targetPackageName,
-            @NonNull String functionIdentifier,
-            @NonNull GenericDocument document,
-            @NonNull Bundle extras,
-            @Nullable byte[] sha256Certificate) {
-        mTargetPackageName = Objects.requireNonNull(targetPackageName);
-        mFunctionIdentifier = Objects.requireNonNull(functionIdentifier);
-        mParametersCached = Objects.requireNonNull(document);
-        mParameters = mParametersCached.getDocumentParcel();
-        mExtras = Objects.requireNonNull(extras);
-        mSha256Certificate = sha256Certificate;
-    }
-
-    @Constructor
-    ExecuteAppFunctionRequest(
-            @Param(id = 1) @NonNull String targetPackageName,
-            @Param(id = 2) @NonNull String functionIdentifier,
-            @Param(id = 3) @NonNull GenericDocumentParcel parameters,
-            @Param(id = 4) @NonNull Bundle extras,
-            @Param(id = 5) @Nullable byte[] sha256Certificate) {
-        mTargetPackageName = Objects.requireNonNull(targetPackageName);
-        mFunctionIdentifier = Objects.requireNonNull(functionIdentifier);
-        mParameters = Objects.requireNonNull(parameters);
-        mParametersCached = new GenericDocument(mParameters);
-        mExtras = Objects.requireNonNull(extras);
-        mSha256Certificate = sha256Certificate;
-    }
-
-    @Override
-    public void writeToParcel(@NonNull Parcel dest, int flags) {
-        ExecuteAppFunctionRequestCreator.writeToParcel(this, dest, flags);
-    }
-
-    /** The builder for creating {@link ExecuteAppFunctionRequest} instances. */
-    @FlaggedApi(Flags.FLAG_ENABLE_APP_FUNCTIONS)
-    public static final class Builder {
-        @NonNull private final String mPackageName;
-        @NonNull private final String mFunctionIdentifier;
-        @NonNull private GenericDocument mParameters = GenericDocument.EMPTY;
-        @NonNull private Bundle mExtras = Bundle.EMPTY;
-        @Nullable private byte[] mSha256Certificate;
-
-        /**
-         * Creates a new instance of this builder class.
-         *
-         * @param packageName The package name of the target app providing the app function to
-         *     invoke.
-         * @param functionIdentifier The identifier used by the {@link AppFunctionService} from the
-         *     target app to uniquely identify the function to be invoked.
-         */
-        public Builder(@NonNull String packageName, @NonNull String functionIdentifier) {
-            mPackageName = Objects.requireNonNull(packageName);
-            mFunctionIdentifier = Objects.requireNonNull(functionIdentifier);
-        }
-
-        /**
-         * Sets parameters for invoking the app function. Within this {@link GenericDocument}, the
-         * property names are the names of the function parameters and the property values are the
-         * values of those parameters. Defaults to an empty {@link GenericDocument} if not set.
-         */
-        @NonNull
-        public Builder setParameters(@NonNull GenericDocument parameters) {
-            mParameters = parameters;
-            return this;
-        }
-
-        /**
-         * Sets the expected certificate SHA-256 digests for the target package. Setting this to
-         * {@code null} indicates that no certificate digest check will be performed.
-         *
-         * <p>SHA-256 certificate digests for a signed application can be retrieved with the <a
-         * href="{@docRoot}studio/command-line/apksigner/">apksigner tool</a> that is part of the
-         * Android SDK build tools. Use {@code apksigner verify --print-certs path/to/apk.apk} to
-         * retrieve the SHA-256 certificate digest for the target application. Once retrieved, the
-         * SHA-256 certificate digest should be converted to a {@code byte[]} by decoding it in
-         * base16:
-         *
-         * <pre>
-         * new android.content.pm.Signature(outputDigest).toByteArray();
-         * </pre>
-         */
-        @NonNull
-        public Builder setSha256Certificate(@Nullable byte[] sha256Certificate) {
-            mSha256Certificate = sha256Certificate;
-            return this;
-        }
-
-        /**
-         * Sets the additional metadata relevant to this function execution request. Defaults to an
-         * empty {@link Bundle} if not set.
-         */
-        @NonNull
-        public Builder setExtras(@NonNull Bundle extras) {
-            mExtras = extras;
-            return this;
-        }
-
-        /** Constructs a new {@link ExecuteAppFunctionRequest} from the contents of this builder. */
-        @NonNull
-        public ExecuteAppFunctionRequest build() {
-            return new ExecuteAppFunctionRequest(
-                    mPackageName, mFunctionIdentifier, mParameters, mExtras, mSha256Certificate);
-        }
-    }
-}
diff --git a/framework/java/android/app/appsearch/functions/ExecuteAppFunctionResponse.java b/framework/java/android/app/appsearch/functions/ExecuteAppFunctionResponse.java
deleted file mode 100644
index 7a6e1882..00000000
--- a/framework/java/android/app/appsearch/functions/ExecuteAppFunctionResponse.java
+++ /dev/null
@@ -1,135 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.app.appsearch.functions;
-
-import android.annotation.FlaggedApi;
-import android.annotation.NonNull;
-import android.app.appsearch.GenericDocument;
-import android.app.appsearch.safeparcel.AbstractSafeParcelable;
-import android.app.appsearch.safeparcel.GenericDocumentParcel;
-import android.app.appsearch.safeparcel.SafeParcelable;
-import android.os.Bundle;
-import android.os.Parcel;
-import android.os.Parcelable;
-
-import com.android.appsearch.flags.Flags;
-
-import java.util.Objects;
-import java.util.concurrent.Executor;
-import java.util.function.Consumer;
-
-/**
- * Represents a response of an execution of an app function.
- *
- * @see AppFunctionManager#executeAppFunction(ExecuteAppFunctionRequest, Executor, Consumer)
- */
-@SafeParcelable.Class(creator = "ExecuteAppFunctionResponseCreator")
-@FlaggedApi(Flags.FLAG_ENABLE_APP_FUNCTIONS)
-public final class ExecuteAppFunctionResponse extends AbstractSafeParcelable {
-    /**
-     * The name of the property that stores the result within the result {@link GenericDocument}.
-     *
-     * @see #getResult().
-     */
-    public static final String PROPERTY_RESULT = "result";
-
-    @NonNull
-    public static final Parcelable.Creator<ExecuteAppFunctionResponse> CREATOR =
-            new ExecuteAppFunctionResponseCreator();
-
-    @Field(id = 1)
-    @NonNull
-    final GenericDocumentParcel mResult;
-
-    @Field(id = 2, getter = "getExtras")
-    @NonNull
-    private final Bundle mExtras;
-
-    @NonNull private final GenericDocument mResultCached;
-
-    @Constructor
-    ExecuteAppFunctionResponse(
-            @Param(id = 1) @NonNull GenericDocumentParcel result,
-            @Param(id = 2) @NonNull Bundle extras) {
-        mResult = Objects.requireNonNull(result);
-        mResultCached = new GenericDocument(mResult);
-        mExtras = extras;
-    }
-
-    private ExecuteAppFunctionResponse(@NonNull GenericDocument result, @NonNull Bundle extras) {
-        mResultCached = Objects.requireNonNull(result);
-        mResult = mResultCached.getDocumentParcel();
-        mExtras = Objects.requireNonNull(extras);
-    }
-
-    /**
-     * Returns the return value of the executed function. An empty document indicates that the
-     * function does not produce a return value.
-     */
-    @NonNull
-    public GenericDocument getResult() {
-        return mResultCached;
-    }
-
-    /** Returns the additional metadata data relevant to this function execution response. */
-    @NonNull
-    public Bundle getExtras() {
-        return mExtras;
-    }
-
-    @Override
-    public void writeToParcel(@NonNull Parcel dest, int flags) {
-        ExecuteAppFunctionResponseCreator.writeToParcel(this, dest, flags);
-    }
-
-    /** The builder for creating {@link ExecuteAppFunctionResponse} instances. */
-    @FlaggedApi(Flags.FLAG_ENABLE_APP_FUNCTIONS)
-    public static final class Builder {
-        @NonNull private GenericDocument mResult = GenericDocument.EMPTY;
-        @NonNull private Bundle mExtras = Bundle.EMPTY;
-
-        /**
-         * Sets the result of the app function execution. The result is stored within a {@link
-         * GenericDocument} under the property name {@link #PROPERTY_RESULT}. An empty {@link
-         * GenericDocument} indicates that the function does not produce a return value. Defaults to
-         * an empty {@link GenericDocument} if not set.
-         */
-        @NonNull
-        public Builder setResult(@NonNull GenericDocument result) {
-            mResult = result;
-            return this;
-        }
-
-        /**
-         * Sets the additional metadata relevant to this function execution response. Defaults to
-         * {@link Bundle#EMPTY} if not set.
-         */
-        @NonNull
-        public Builder setExtras(@NonNull Bundle extras) {
-            mExtras = extras;
-            return this;
-        }
-
-        /**
-         * Constructs a new {@link ExecuteAppFunctionResponse} from the contents of this builder.
-         */
-        @NonNull
-        public ExecuteAppFunctionResponse build() {
-            return new ExecuteAppFunctionResponse(mResult, mExtras);
-        }
-    }
-}
diff --git a/framework/java/android/app/appsearch/functions/SafeOneTimeAppSearchResultCallback.java b/framework/java/android/app/appsearch/functions/SafeOneTimeAppSearchResultCallback.java
deleted file mode 100644
index 7b0196d7..00000000
--- a/framework/java/android/app/appsearch/functions/SafeOneTimeAppSearchResultCallback.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.app.appsearch.functions;
-
-import android.annotation.NonNull;
-import android.annotation.Nullable;
-import android.app.appsearch.AppSearchResult;
-import android.app.appsearch.aidl.AppSearchResultParcel;
-import android.app.appsearch.aidl.IAppSearchResultCallback;
-import android.os.RemoteException;
-import android.util.Log;
-
-import java.util.Objects;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.function.Consumer;
-
-/**
- * A wrapper of IAppSearchResultCallback which swallows the {@link RemoteException}. This callback
- * is intended for one-time use only. Subsequent calls to onResult() will be ignored.
- *
- * @hide
- */
-public class SafeOneTimeAppSearchResultCallback {
-    private static final String TAG = "AppSearchAppFunction";
-
-    private final AtomicBoolean mOnResultCalled = new AtomicBoolean(false);
-
-    @NonNull private final IAppSearchResultCallback mCallback;
-
-    @Nullable private final Consumer<AppSearchResult<?>> mOnDispatchCallback;
-
-    public SafeOneTimeAppSearchResultCallback(@NonNull IAppSearchResultCallback callback) {
-        this(callback, /* onDispatchCallback= */ null);
-    }
-
-    /**
-     * @param callback The callback to wrap.
-     * @param onDispatchCallback An optional callback invoked after the wrapped callback has been
-     *     dispatched with a result. This callback receives the result that has been dispatched.
-     */
-    public SafeOneTimeAppSearchResultCallback(
-            @NonNull IAppSearchResultCallback callback,
-            @Nullable Consumer<AppSearchResult<?>> onDispatchCallback) {
-        mCallback = Objects.requireNonNull(callback);
-        mOnDispatchCallback = onDispatchCallback;
-    }
-
-    public void onFailedResult(@NonNull AppSearchResult<?> result) {
-        onResult(AppSearchResultParcel.fromFailedResult(result));
-    }
-
-    public void onResult(@NonNull AppSearchResultParcel<?> result) {
-        if (!mOnResultCalled.compareAndSet(false, true)) {
-            Log.w(TAG, "Ignore subsequent calls to onResult()");
-            return;
-        }
-        try {
-            mCallback.onResult(result);
-        } catch (RemoteException ex) {
-            // Failed to notify the other end. Ignore.
-            Log.w(TAG, "Failed to invoke the callback", ex);
-        }
-        if (mOnDispatchCallback != null) {
-            mOnDispatchCallback.accept(result.getResult());
-        }
-    }
-}
diff --git a/framework/java/android/app/appsearch/functions/ServiceCallHelper.java b/framework/java/android/app/appsearch/functions/ServiceCallHelper.java
deleted file mode 100644
index 8ae262de..00000000
--- a/framework/java/android/app/appsearch/functions/ServiceCallHelper.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package android.app.appsearch.functions;
-
-import android.annotation.NonNull;
-import android.content.Intent;
-import android.os.UserHandle;
-
-/**
- * Defines a contract for establishing temporary connections to services and executing operations
- * within a specified timeout. Implementations of this interface provide mechanisms to ensure that
- * services are properly unbound after the operation completes or a timeout occurs.
- *
- * @hide
- */
-public interface ServiceCallHelper<T> {
-
-    /**
-     * Initiates service binding and executes a provided method when the service connects. Unbinds
-     * the service after execution or upon timeout. Returns the result of the bindService API.
-     *
-     * <p>When the service connection was made successfully, it's the caller responsibility to
-     * report the usage is completed and can be unbound by calling {@link
-     * ServiceUsageCompleteListener#onCompleted()}.
-     *
-     * <p>This method includes a timeout mechanism to prevent the system from being stuck in a state
-     * where a service is bound indefinitely (for example, if the binder method never returns). This
-     * helps ensure that the calling app does not remain alive unnecessarily.
-     *
-     * @param intent An Intent object that describes the service that should be bound.
-     * @param bindFlags Flags used to control the binding process See {@link
-     *     android.content.Context#bindService}.
-     * @param timeoutInMillis The maximum time in milliseconds to wait for the service connection.
-     * @param userHandle The UserHandle of the user for which the service should be bound.
-     * @param callback A callback to be invoked for various events. See {@link
-     *     RunServiceCallCallback}.
-     */
-    boolean runServiceCall(
-            @NonNull Intent intent,
-            int bindFlags,
-            long timeoutInMillis,
-            @NonNull UserHandle userHandle,
-            @NonNull RunServiceCallCallback<T> callback);
-
-    /** An interface for clients to signal that they have finished using a bound service. */
-    interface ServiceUsageCompleteListener {
-        /**
-         * Called when a client has finished using a bound service. This indicates that the service
-         * can be safely unbound.
-         */
-        void onCompleted();
-    }
-
-    interface RunServiceCallCallback<T> {
-        /**
-         * Called when the service connection has been established. Uses {@code
-         * serviceUsageCompleteListener} to report finish using the connected service.
-         */
-        void onServiceConnected(
-                @NonNull T service,
-                @NonNull ServiceUsageCompleteListener serviceUsageCompleteListener);
-
-        /** Called when the service connection was failed to establish. */
-        void onFailedToConnect();
-
-        /**
-         * Called when the whole operation(i.e. binding and the service call) takes longer than
-         * allowed.
-         */
-        void onTimedOut();
-    }
-}
diff --git a/framework/java/android/app/appsearch/functions/ServiceCallHelperImpl.java b/framework/java/android/app/appsearch/functions/ServiceCallHelperImpl.java
deleted file mode 100644
index a89e76b7..00000000
--- a/framework/java/android/app/appsearch/functions/ServiceCallHelperImpl.java
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package android.app.appsearch.functions;
-
-import android.annotation.NonNull;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.content.ServiceConnection;
-import android.os.Handler;
-import android.os.IBinder;
-import android.os.Looper;
-import android.os.UserHandle;
-import android.util.Log;
-
-import java.util.concurrent.Executor;
-import java.util.function.Function;
-
-/**
- * An implementation of {@link ServiceCallHelper} that that is based on {@link Context#bindService}.
- *
- * @hide
- */
-public class ServiceCallHelperImpl<T> implements ServiceCallHelper<T> {
-    private static final String TAG = "AppSearchAppFunction";
-
-    @NonNull private final Context mContext;
-    @NonNull private final Function<IBinder, T> mInterfaceConverter;
-    private final Handler mHandler = new Handler(Looper.getMainLooper());
-    private final Executor mExecutor;
-
-    /**
-     * @param interfaceConverter A function responsible for converting an IBinder object into the
-     *     desired service interface.
-     * @param executor An Executor instance to dispatch callback.
-     * @param context The system context.
-     */
-    public ServiceCallHelperImpl(
-            @NonNull Context context,
-            @NonNull Function<IBinder, T> interfaceConverter,
-            @NonNull Executor executor) {
-        mContext = context;
-        mInterfaceConverter = interfaceConverter;
-        mExecutor = executor;
-    }
-
-    @Override
-    public boolean runServiceCall(
-            @NonNull Intent intent,
-            int bindFlags,
-            long timeoutInMillis,
-            @NonNull UserHandle userHandle,
-            @NonNull RunServiceCallCallback<T> callback) {
-        OneOffServiceConnection serviceConnection =
-                new OneOffServiceConnection(
-                        intent, bindFlags, timeoutInMillis, userHandle, callback);
-
-        return serviceConnection.bindAndRun();
-    }
-
-    private class OneOffServiceConnection
-            implements ServiceConnection, ServiceUsageCompleteListener {
-        private final Intent mIntent;
-        private final int mFlags;
-        private final long mTimeoutMillis;
-        private final UserHandle mUserHandle;
-        private final RunServiceCallCallback<T> mCallback;
-        private final Runnable mTimeoutCallback;
-
-        OneOffServiceConnection(
-                @NonNull Intent intent,
-                int flags,
-                long timeoutMillis,
-                @NonNull UserHandle userHandle,
-                @NonNull RunServiceCallCallback<T> callback) {
-            mIntent = intent;
-            mFlags = flags;
-            mTimeoutMillis = timeoutMillis;
-            mCallback = callback;
-            mTimeoutCallback =
-                    () ->
-                            mExecutor.execute(
-                                    () -> {
-                                        safeUnbind();
-                                        mCallback.onTimedOut();
-                                    });
-            mUserHandle = userHandle;
-        }
-
-        public boolean bindAndRun() {
-            boolean bindServiceResult =
-                    mContext.bindServiceAsUser(mIntent, this, mFlags, mUserHandle);
-
-            if (bindServiceResult) {
-                mHandler.postDelayed(mTimeoutCallback, mTimeoutMillis);
-            } else {
-                safeUnbind();
-            }
-
-            return bindServiceResult;
-        }
-
-        @Override
-        public void onServiceConnected(ComponentName name, IBinder service) {
-            T serviceInterface = mInterfaceConverter.apply(service);
-
-            mExecutor.execute(() -> mCallback.onServiceConnected(serviceInterface, this));
-        }
-
-        @Override
-        public void onServiceDisconnected(ComponentName name) {
-            safeUnbind();
-            mExecutor.execute(mCallback::onFailedToConnect);
-        }
-
-        @Override
-        public void onBindingDied(ComponentName name) {
-            safeUnbind();
-            mExecutor.execute(mCallback::onFailedToConnect);
-        }
-
-        @Override
-        public void onNullBinding(ComponentName name) {
-            safeUnbind();
-            mExecutor.execute(mCallback::onFailedToConnect);
-        }
-
-        private void safeUnbind() {
-            try {
-                mHandler.removeCallbacks(mTimeoutCallback);
-                mContext.unbindService(this);
-            } catch (Exception ex) {
-                Log.w(TAG, "Failed to unbind", ex);
-            }
-        }
-
-        @Override
-        public void onCompleted() {
-            safeUnbind();
-        }
-    }
-}
diff --git a/framework/java/external/android/app/appsearch/AppSearchBatchResult.java b/framework/java/external/android/app/appsearch/AppSearchBatchResult.java
index ac89af51..ebae8838 100644
--- a/framework/java/external/android/app/appsearch/AppSearchBatchResult.java
+++ b/framework/java/external/android/app/appsearch/AppSearchBatchResult.java
@@ -15,11 +15,14 @@
  */
 package android.app.appsearch;
 
+import android.annotation.FlaggedApi;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
 import android.util.ArrayMap;
 
+import com.android.appsearch.flags.Flags;
+
 import java.util.Collections;
 import java.util.Map;
 import java.util.Objects;
@@ -132,6 +135,17 @@ public final class AppSearchBatchResult<KeyType, ValueType> {
         private ArrayMap<KeyType, AppSearchResult<ValueType>> mAll = new ArrayMap<>();
         private boolean mBuilt = false;
 
+        /** Creates a new {@link Builder}. */
+        public Builder() {}
+
+        /** Creates a new {@link Builder} from the given {@link AppSearchBatchResult}. */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        public Builder(@NonNull AppSearchBatchResult<KeyType, ValueType> appSearchBatchResult) {
+            mSuccesses.putAll(appSearchBatchResult.mSuccesses);
+            mFailures.putAll(appSearchBatchResult.mFailures);
+            mAll.putAll(appSearchBatchResult.mAll);
+        }
+
         /**
          * Associates the {@code key} with the provided successful return value.
          *
diff --git a/framework/java/external/android/app/appsearch/AppSearchBlobHandle.java b/framework/java/external/android/app/appsearch/AppSearchBlobHandle.java
index 27624cf6..f0b37c77 100644
--- a/framework/java/external/android/app/appsearch/AppSearchBlobHandle.java
+++ b/framework/java/external/android/app/appsearch/AppSearchBlobHandle.java
@@ -21,6 +21,7 @@ import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.app.appsearch.safeparcel.AbstractSafeParcelable;
 import android.app.appsearch.safeparcel.SafeParcelable;
+import android.app.appsearch.util.IndentingStringBuilder;
 import android.os.Parcel;
 import android.os.Parcelable;
 
@@ -31,16 +32,30 @@ import java.util.Arrays;
 import java.util.Objects;
 
 /**
- * An identifier to represent a Blob in AppSearch.
+ * An identifier to represent a blob in AppSearch.
  *
- * @hide
+ * <p>A "blob" is a large binary object. It is used to store a significant amount of data that is
+ * not searchable, such as images, videos, audio files, or other binary data. Unlike other fields in
+ * AppSearch, blobs are stored as blob files on disk rather than in memory, and use {@link
+ * android.os.ParcelFileDescriptor} to read and write. This allows for efficient handling of large,
+ * non-searchable content.
+ *
+ * <p>{@link AppSearchBlobHandle} is a light-weight {@code Property} of {@link GenericDocument},
+ * which is a pointer to the heavy-weight blob data.
+ *
+ * <p>The blob data could be written via {@link AppSearchSession#openBlobForWrite} and read via
+ * {@link AppSearchSession#openBlobForRead}.
+ *
+ * <p>A {@link GenericDocument} with {@link AppSearchBlobHandle} {@code Property} could be put and
+ * read without the large blob data. This offers lazy retrieval to blob data when searching {@link
+ * GenericDocument} in AppSearch.
+ *
+ * @see GenericDocument.Builder#setPropertyBlobHandle
  */
-// TODO(b/273591938) improve the java doc when we support set blob property in GenericDocument
-// TODO(b/273591938) unhide the API once it read for API review.
-
 @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
+@SuppressWarnings("HiddenSuperclass")
 @SafeParcelable.Class(creator = "AppSearchBlobHandleCreator")
-public class AppSearchBlobHandle extends AbstractSafeParcelable {
+public final class AppSearchBlobHandle extends AbstractSafeParcelable {
     /** The length of the SHA-256 digest in bytes. SHA-256 produces a 256-bit (32-byte) digest. */
     private static final int SHA_256_DIGEST_BYTE_LENGTH = 32;
 
@@ -53,8 +68,16 @@ public class AppSearchBlobHandle extends AbstractSafeParcelable {
     private final byte[] mSha256Digest;
 
     @NonNull
-    @Field(id = 2, getter = "getLabel")
-    private final String mLabel;
+    @Field(id = 2, getter = "getPackageName")
+    private final String mPackageName;
+
+    @NonNull
+    @Field(id = 3, getter = "getDatabaseName")
+    private final String mDatabaseName;
+
+    @NonNull
+    @Field(id = 4, getter = "getNamespace")
+    private final String mNamespace;
 
     @Nullable private Integer mHashCode;
 
@@ -65,19 +88,24 @@ public class AppSearchBlobHandle extends AbstractSafeParcelable {
      */
     @Constructor
     AppSearchBlobHandle(
-            @Param(id = 1) @NonNull byte[] sha256Digest, @Param(id = 2) @NonNull String label) {
+            @Param(id = 1) @NonNull byte[] sha256Digest,
+            @Param(id = 2) @NonNull String packageName,
+            @Param(id = 3) @NonNull String databaseName,
+            @Param(id = 4) @NonNull String namespace) {
         mSha256Digest = Objects.requireNonNull(sha256Digest);
         Preconditions.checkState(
                 sha256Digest.length == SHA_256_DIGEST_BYTE_LENGTH,
                 "The input digest isn't a sha-256 digest.");
-        mLabel = Objects.requireNonNull(label);
+        mPackageName = Objects.requireNonNull(packageName);
+        mDatabaseName = Objects.requireNonNull(databaseName);
+        mNamespace = Objects.requireNonNull(namespace);
     }
 
     /**
      * Returns the SHA-256 hash of the blob that this object is representing.
      *
-     * <p>For two objects of {@link AppSearchBlobHandle} to be considered equal, the {@code digest}
-     * and {@code label} must be equal.
+     * <p>For two objects of {@link AppSearchBlobHandle} to be considered equal, the {@code
+     * packageName}, {@code database}, {@code namespace} and {@code digest} must be equal.
      */
     @NonNull
     public byte[] getSha256Digest() {
@@ -85,20 +113,37 @@ public class AppSearchBlobHandle extends AbstractSafeParcelable {
     }
 
     /**
-     * Returns the label indicating what the blob is with the blob that this object is representing.
+     * Returns the package name indicating the owner app of the blob that this object is
+     * representing.
      *
-     * <p>The label is just a simple string which contains more readable information for the digest.
-     * The string is used to indicate and describe the content represented by the digest. The label
-     * cannot be used to search {@link AppSearchBlobHandle}.
+     * <p>For two objects of {@link AppSearchBlobHandle} to be considered equal, the {@code
+     * packageName}, {@code database}, {@code namespace} and {@code digest} must be equal.
+     */
+    @NonNull
+    public String getPackageName() {
+        return mPackageName;
+    }
+
+    /**
+     * Returns the name of database stored the blob that this object is representing.
      *
-     * <p>If the label is not set, then this method will return an empty string.
+     * <p>For two objects of {@link AppSearchBlobHandle} to be considered equal, the {@code
+     * packageName}, {@code database}, {@code namespace} and {@code digest} must be equal.
+     */
+    @NonNull
+    public String getDatabaseName() {
+        return mDatabaseName;
+    }
+
+    /**
+     * Returns the app-defined namespace this blob resides in.
      *
-     * <p>For two objects of {@link AppSearchBlobHandle} to be considered equal, the {@code digest}
-     * and {@code label} must be equal.
+     * <p>For two objects of {@link AppSearchBlobHandle} to be considered equal, the {@code
+     * packageName}, {@code database}, {@code namespace} and {@code digest} must be equal.
      */
     @NonNull
-    public String getLabel() {
-        return mLabel;
+    public String getNamespace() {
+        return mNamespace;
     }
 
     @Override
@@ -108,54 +153,76 @@ public class AppSearchBlobHandle extends AbstractSafeParcelable {
 
         AppSearchBlobHandle that = (AppSearchBlobHandle) o;
         if (!Arrays.equals(mSha256Digest, that.mSha256Digest)) return false;
-        return mLabel.equals(that.mLabel);
+        return mPackageName.equals(that.mPackageName)
+                && mDatabaseName.equals(that.mDatabaseName)
+                && mNamespace.equals(that.mNamespace);
     }
 
     @Override
     public int hashCode() {
         if (mHashCode == null) {
-            mHashCode = Objects.hash(Arrays.hashCode(mSha256Digest), mLabel);
+            mHashCode =
+                    Objects.hash(
+                            Arrays.hashCode(mSha256Digest),
+                            mPackageName,
+                            mDatabaseName,
+                            mNamespace);
         }
         return mHashCode;
     }
 
-    /**
-     * Create a new AppSearch blob identifier with given digest and empty label.
-     *
-     * <p>For two objects of {@link AppSearchBlobHandle} to be considered equal, the {@code digest}
-     * and {@code label} must be equal.
-     *
-     * @param digest the SHA-256 hash of the blob this is representing.
-     * @return a new instance of {@link AppSearchBlobHandle} object.
-     */
     @NonNull
-    public static AppSearchBlobHandle createWithSha256(@NonNull byte[] digest) {
-        return new AppSearchBlobHandle(digest, /* label= */ "");
+    @Override
+    public String toString() {
+        IndentingStringBuilder builder = new IndentingStringBuilder();
+        builder.append("{\n");
+        builder.increaseIndentLevel();
+        builder.append("packageName: \"").append(mPackageName).append("\",\n");
+        builder.append("databaseName: \"").append(mDatabaseName).append("\",\n");
+        builder.append("namespace: \"").append(mNamespace).append("\",\n");
+        builder.append("digest: \"");
+        for (byte b : mSha256Digest) {
+            String hex = Integer.toHexString(0xFF & b);
+            if (hex.length() == 1) {
+                builder.append('0');
+            }
+            builder.append(hex);
+        }
+        builder.append("\",\n").decreaseIndentLevel();
+        builder.append("}");
+
+        return builder.toString();
     }
 
     /**
-     * Create a new AppSearch blob identifier with given digest and label.
+     * Create a new AppSearch blob identifier with given digest, package, database and namespace.
      *
-     * <p>The label is just a simple string which contains more readable information for the digest.
-     * The string is used to indicate and describe the content represented by the digest. The label
-     * cannot be used to search {@link AppSearchBlobHandle}.
+     * <p>The package name and database name indicated where this blob will be stored. To write,
+     * commit or read this blob via {@link AppSearchSession}, it must match the package name and
+     * database name of {@link AppSearchSession}.
      *
-     * <p>For two objects of {@link AppSearchBlobHandle} to be considered equal, the {@code digest}
-     * and {@code label} must be equal.
+     * <p>For two objects of {@link AppSearchBlobHandle} to be considered equal, the {@code
+     * packageName}, {@code database}, {@code namespace} and {@code digest} must be equal.
      *
-     * @param digest the SHA-256 hash of the blob this is representing.
-     * @param label a label indicating what the blob is, that can be surfaced to the user. It is
-     *     recommended to keep this brief. The label doesn't need to be distinct.
+     * @param digest The SHA-256 hash of the blob this is representing.
+     * @param packageName The package name of the owner of this Blob.
+     * @param databaseName The database name of this blob to stored into.
+     * @param namespace The namespace of this blob resides in.
      * @return a new instance of {@link AppSearchBlobHandle} object.
      */
     @NonNull
     public static AppSearchBlobHandle createWithSha256(
-            @NonNull byte[] digest, @NonNull String label) {
+            @NonNull byte[] digest,
+            @NonNull String packageName,
+            @NonNull String databaseName,
+            @NonNull String namespace) {
         Objects.requireNonNull(digest);
         Preconditions.checkArgument(
                 digest.length == SHA_256_DIGEST_BYTE_LENGTH, "The digest is not a SHA-256 digest");
-        Objects.requireNonNull(label);
-        return new AppSearchBlobHandle(digest, label);
+        Objects.requireNonNull(packageName);
+        Objects.requireNonNull(databaseName);
+        Objects.requireNonNull(namespace);
+        return new AppSearchBlobHandle(digest, packageName, databaseName, namespace);
     }
 
     @Override
diff --git a/framework/java/external/android/app/appsearch/AppSearchEnvironment.java b/framework/java/external/android/app/appsearch/AppSearchEnvironment.java
index f6a68be5..48925af6 100644
--- a/framework/java/external/android/app/appsearch/AppSearchEnvironment.java
+++ b/framework/java/external/android/app/appsearch/AppSearchEnvironment.java
@@ -16,12 +16,15 @@
 
 package android.app.appsearch;
 
+import android.annotation.IntDef;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.content.Context;
 import android.os.UserHandle;
 
 import java.io.File;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.TimeUnit;
@@ -67,4 +70,27 @@ public interface AppSearchEnvironment {
 
     /** Returns if we can log INFO level logs. */
     boolean isInfoLoggingEnabled();
+
+    /** The different environments that AppSearch code might be built in. */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef(
+            value = {
+                JETPACK_ENVIRONMENT,
+                FRAMEWORK_ENVIRONMENT,
+                PLAY_SERVICES_ENVIRONMENT,
+            })
+    @interface EnvironmentType {}
+
+    /** This code is being built in the Jetpack Environment */
+    int JETPACK_ENVIRONMENT = 1;
+
+    /** This code is being built in the Android Framework Environment */
+    int FRAMEWORK_ENVIRONMENT = 2;
+
+    /** This code is being built in the internal environment for Play Services code. */
+    int PLAY_SERVICES_ENVIRONMENT = 3;
+
+    /** Returns the {@code EnvironmentType} for this environment. */
+    @EnvironmentType
+    int getEnvironment();
 }
diff --git a/framework/java/external/android/app/appsearch/AppSearchSchema.java b/framework/java/external/android/app/appsearch/AppSearchSchema.java
index f97ac2ff..c271d949 100644
--- a/framework/java/external/android/app/appsearch/AppSearchSchema.java
+++ b/framework/java/external/android/app/appsearch/AppSearchSchema.java
@@ -214,7 +214,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
 
     /** Builder for {@link AppSearchSchema objects}. */
     public static final class Builder {
-        private final String mSchemaType;
+        private String mSchemaType;
         private String mDescription = "";
         private ArrayList<PropertyConfigParcel> mPropertyConfigParcels = new ArrayList<>();
         private LinkedHashSet<String> mParentTypes = new LinkedHashSet<>();
@@ -226,6 +226,29 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
             mSchemaType = Objects.requireNonNull(schemaType);
         }
 
+        /** Creates a new {@link AppSearchSchema.Builder} from the given {@link AppSearchSchema}. */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        public Builder(@NonNull AppSearchSchema schema) {
+            mSchemaType = schema.getSchemaType();
+            mDescription = schema.getDescription();
+            mPropertyConfigParcels.addAll(schema.mPropertyConfigParcels);
+            mParentTypes.addAll(schema.mParentTypes);
+            for (int i = 0; i < mPropertyConfigParcels.size(); i++) {
+                mPropertyNames.add(mPropertyConfigParcels.get(i).getName());
+            }
+        }
+
+        /** Sets the schema type name. */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        @CanIgnoreReturnValue
+        @NonNull
+        public AppSearchSchema.Builder setSchemaType(@NonNull String schemaType) {
+            Objects.requireNonNull(schemaType);
+            resetIfBuilt();
+            mSchemaType = schemaType;
+            return this;
+        }
+
         /**
          * Sets a natural language description of this schema type.
          *
@@ -242,7 +265,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
             return this;
         }
 
-        /** Adds a property to the given type. */
+        /** Adds a property to the schema type. */
         @CanIgnoreReturnValue
         @NonNull
         public AppSearchSchema.Builder addProperty(@NonNull PropertyConfig propertyConfig) {
@@ -257,7 +280,21 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
         }
 
         /**
-         * Adds a parent type to the given type for polymorphism, so that the given type will be
+         * Clears all properties added through {@link #addProperty(PropertyConfig)} from the schema
+         * type.
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        @CanIgnoreReturnValue
+        @NonNull
+        public AppSearchSchema.Builder clearProperties() {
+            resetIfBuilt();
+            mPropertyConfigParcels.clear();
+            mPropertyNames.clear();
+            return this;
+        }
+
+        /**
+         * Adds a parent type to the schema type for polymorphism, so that the schema type will be
          * considered as a subtype of {@code parentSchemaType}.
          *
          * <p>Subtype relations are automatically considered transitive, so callers are only
@@ -325,6 +362,19 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
             return this;
         }
 
+        /**
+         * Clears all parent types added through {@link #addParentType(String)} from the schema
+         * type.
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        @CanIgnoreReturnValue
+        @NonNull
+        public AppSearchSchema.Builder clearParentTypes() {
+            resetIfBuilt();
+            mParentTypes.clear();
+            return this;
+        }
+
         /** Constructs a new {@link AppSearchSchema} from the contents of this builder. */
         @NonNull
         public AppSearchSchema build() {
@@ -369,6 +419,7 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
                     DATA_TYPE_BYTES,
                     DATA_TYPE_DOCUMENT,
                     DATA_TYPE_EMBEDDING,
+                    DATA_TYPE_BLOB_HANDLE,
                 })
         @Retention(RetentionPolicy.SOURCE)
         public @interface DataType {}
@@ -424,6 +475,13 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
          */
         public static final int DATA_TYPE_EMBEDDING = 7;
 
+        /**
+         * Indicates that the property is an {@link AppSearchBlobHandle}.
+         *
+         * @hide
+         */
+        public static final int DATA_TYPE_BLOB_HANDLE = 8;
+
         /**
          * The cardinality of the property (whether it is required, optional or repeated).
          *
@@ -522,6 +580,9 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
                 case PropertyConfig.DATA_TYPE_EMBEDDING:
                     builder.append("dataType: DATA_TYPE_EMBEDDING,\n");
                     break;
+                case PropertyConfig.DATA_TYPE_BLOB_HANDLE:
+                    builder.append("dataType: DATA_TYPE_BLOB_HANDLE,\n");
+                    break;
                 default:
                     builder.append("dataType: DATA_TYPE_UNKNOWN,\n");
             }
@@ -616,6 +677,8 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
                     return new DocumentPropertyConfig(propertyConfigParcel);
                 case PropertyConfig.DATA_TYPE_EMBEDDING:
                     return new EmbeddingPropertyConfig(propertyConfigParcel);
+                case PropertyConfig.DATA_TYPE_BLOB_HANDLE:
+                    return new BlobHandlePropertyConfig(propertyConfigParcel);
                 default:
                     throw new IllegalArgumentException(
                             "Unsupported property bundle of type "
@@ -760,6 +823,45 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
          */
         public static final int JOINABLE_VALUE_TYPE_QUALIFIED_ID = 1;
 
+        /**
+         * The delete propagation type of the property. By setting the delete propagation type for a
+         * property, the client can propagate deletion between the document and the referenced
+         * document. The propagation direction is determined by the delete propagation type.
+         *
+         * @hide
+         */
+        // NOTE: The integer values of these constants must match the proto enum constants in
+        // com.google.android.icing.proto.JoinableConfig.DeletePropagationType.Code.
+        @IntDef(
+                value = {
+                    DELETE_PROPAGATION_TYPE_NONE,
+                    DELETE_PROPAGATION_TYPE_PROPAGATE_FROM,
+                })
+        @Retention(RetentionPolicy.SOURCE)
+        public @interface DeletePropagationType {}
+
+        /** Does not propagate deletion. */
+        @FlaggedApi(Flags.FLAG_ENABLE_DELETE_PROPAGATION_TYPE)
+        public static final int DELETE_PROPAGATION_TYPE_NONE = 0;
+
+        /**
+         * Content in this string property will be used as a qualified id referring to another
+         * (parent) document, and the deletion of the referenced document will propagate to this
+         * (child) document.
+         *
+         * <p>Please note that this propagates further. If the child document has any children that
+         * also set delete propagation type PROPAGATE_FROM for their joinable properties, then those
+         * (grandchild) documents will be deleted.
+         *
+         * <p>Since delete propagation works between the document and the referenced document, if
+         * setting this type for delete propagation, the string property should also be qualified id
+         * joinable (i.e. having {@link StringPropertyConfig#JOINABLE_VALUE_TYPE_QUALIFIED_ID} for
+         * the joinable value type). Otherwise, throw {@link IllegalStateException} when building
+         * (see {@link StringPropertyConfig.Builder#build}).
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_DELETE_PROPAGATION_TYPE)
+        public static final int DELETE_PROPAGATION_TYPE_PROPAGATE_FROM = 1;
+
         StringPropertyConfig(@NonNull PropertyConfigParcel propertyConfigParcel) {
             super(propertyConfigParcel);
         }
@@ -802,6 +904,22 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
             return joinableConfigParcel.getJoinableValueType();
         }
 
+        /**
+         * Returns how the deletion will be propagated between this document and the referenced
+         * document whose qualified id is held by this property.
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_DELETE_PROPAGATION_TYPE)
+        @DeletePropagationType
+        public int getDeletePropagationType() {
+            JoinableConfigParcel joinableConfigParcel =
+                    mPropertyConfigParcel.getJoinableConfigParcel();
+            if (joinableConfigParcel == null) {
+                return DELETE_PROPAGATION_TYPE_NONE;
+            }
+
+            return joinableConfigParcel.getDeletePropagationType();
+        }
+
         /** Builder for {@link StringPropertyConfig}. */
         public static final class Builder {
             private final String mPropertyName;
@@ -810,7 +928,9 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
             @StringPropertyConfig.IndexingType private int mIndexingType = INDEXING_TYPE_NONE;
             @TokenizerType private int mTokenizerType = TOKENIZER_TYPE_NONE;
             @JoinableValueType private int mJoinableValueType = JOINABLE_VALUE_TYPE_NONE;
-            private boolean mDeletionPropagation = false;
+
+            @DeletePropagationType
+            private int mDeletePropagationType = DELETE_PROPAGATION_TYPE_NONE;
 
             /** Creates a new {@link StringPropertyConfig.Builder}. */
             public Builder(@NonNull String propertyName) {
@@ -905,7 +1025,50 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
                 return this;
             }
 
-            /** Constructs a new {@link StringPropertyConfig} from the contents of this builder. */
+            /**
+             * Configures how the deletion will be propagated between this document and the
+             * referenced document whose qualified id is held by this property.
+             *
+             * <p>If this method is not called, the default delete propagation type is {@link
+             * StringPropertyConfig#DELETE_PROPAGATION_TYPE_NONE}, indicating that deletion will not
+             * propagate between this document and the referenced document.
+             *
+             * <p>If the delete propagation type is not {@link
+             * StringPropertyConfig#DELETE_PROPAGATION_TYPE_NONE}, then {@link
+             * StringPropertyConfig#JOINABLE_VALUE_TYPE_QUALIFIED_ID} must also be set since the
+             * delete propagation has to use the qualified id. Otherwise, throw {@link
+             * IllegalStateException} when building.
+             */
+            @CanIgnoreReturnValue
+            @FlaggedApi(Flags.FLAG_ENABLE_DELETE_PROPAGATION_TYPE)
+            @NonNull
+            public StringPropertyConfig.Builder setDeletePropagationType(
+                    @DeletePropagationType int deletePropagationType) {
+                Preconditions.checkArgumentInRange(
+                        deletePropagationType,
+                        DELETE_PROPAGATION_TYPE_NONE,
+                        DELETE_PROPAGATION_TYPE_PROPAGATE_FROM,
+                        "deletePropagationType");
+                mDeletePropagationType = deletePropagationType;
+                return this;
+            }
+
+            /**
+             * Constructs a new {@link StringPropertyConfig} from the contents of this builder.
+             *
+             * @throws IllegalStateException if any following condition:
+             *     <ul>
+             *       <li>Tokenizer type is not {@link StringPropertyConfig#TOKENIZER_TYPE_NONE} with
+             *           indexing type {@link StringPropertyConfig#INDEXING_TYPE_NONE}.
+             *       <li>Indexing type is not {@link StringPropertyConfig#INDEXING_TYPE_NONE} with
+             *           tokenizer type {@link StringPropertyConfig#TOKENIZER_TYPE_NONE}.
+             *       <li>{@link StringPropertyConfig#JOINABLE_VALUE_TYPE_QUALIFIED_ID} is set to a
+             *           {@link PropertyConfig#CARDINALITY_REPEATED} property.
+             *       <li>Deletion type other than {@link
+             *           StringPropertyConfig#DELETE_PROPAGATION_TYPE_NONE} is used without setting
+             *           {@link StringPropertyConfig#JOINABLE_VALUE_TYPE_QUALIFIED_ID}.
+             *     </ul>
+             */
             @NonNull
             public StringPropertyConfig build() {
                 if (mTokenizerType == TOKENIZER_TYPE_NONE) {
@@ -924,16 +1087,17 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
                             mCardinality != CARDINALITY_REPEATED,
                             "Cannot set JOINABLE_VALUE_TYPE_QUALIFIED_ID with"
                                     + " CARDINALITY_REPEATED.");
-                } else {
+                }
+                if (mDeletePropagationType != DELETE_PROPAGATION_TYPE_NONE) {
                     Preconditions.checkState(
-                            !mDeletionPropagation,
-                            "Cannot set deletion "
-                                    + "propagation without setting a joinable value type");
+                            mJoinableValueType == JOINABLE_VALUE_TYPE_QUALIFIED_ID,
+                            "Cannot set delete propagation without setting "
+                                    + "JOINABLE_VALUE_TYPE_QUALIFIED_ID.");
                 }
                 PropertyConfigParcel.StringIndexingConfigParcel stringConfigParcel =
                         new StringIndexingConfigParcel(mIndexingType, mTokenizerType);
                 JoinableConfigParcel joinableConfigParcel =
-                        new JoinableConfigParcel(mJoinableValueType, mDeletionPropagation);
+                        new JoinableConfigParcel(mJoinableValueType, mDeletePropagationType);
                 return new StringPropertyConfig(
                         PropertyConfigParcel.createForString(
                                 mPropertyName,
@@ -994,6 +1158,18 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
                 default:
                     builder.append("joinableValueType: JOINABLE_VALUE_TYPE_UNKNOWN,\n");
             }
+
+            switch (getDeletePropagationType()) {
+                case StringPropertyConfig.DELETE_PROPAGATION_TYPE_NONE:
+                    builder.append("deletePropagationType: DELETE_PROPAGATION_TYPE_NONE,\n");
+                    break;
+                case StringPropertyConfig.DELETE_PROPAGATION_TYPE_PROPAGATE_FROM:
+                    builder.append(
+                            "deletePropagationType: DELETE_PROPAGATION_TYPE_PROPAGATE_FROM,\n");
+                    break;
+                default:
+                    builder.append("deletePropagationType: DELETE_PROPAGATION_TYPE_UNKNOWN,\n");
+            }
         }
     }
 
@@ -1035,12 +1211,19 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
             return indexingConfigParcel.getIndexingType();
         }
 
+        /** Returns if the property is enabled for scoring. */
+        @FlaggedApi(Flags.FLAG_ENABLE_SCORABLE_PROPERTY)
+        public boolean isScoringEnabled() {
+            return mPropertyConfigParcel.isScoringEnabled();
+        }
+
         /** Builder for {@link LongPropertyConfig}. */
         public static final class Builder {
             private final String mPropertyName;
             private String mDescription = "";
             @Cardinality private int mCardinality = CARDINALITY_OPTIONAL;
             @LongPropertyConfig.IndexingType private int mIndexingType = INDEXING_TYPE_NONE;
+            private boolean mScoringEnabled = false;
 
             /** Creates a new {@link LongPropertyConfig.Builder}. */
             public Builder(@NonNull String propertyName) {
@@ -1095,12 +1278,35 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
                 return this;
             }
 
+            /**
+             * Sets the property enabled or disabled for scoring.
+             *
+             * <p>If this method is not called, the default value is false.
+             *
+             * <p>If enabled, it can be used in the advanced ranking expression via the function of
+             * 'getScorableProperty'.
+             *
+             * <p>For the detailed documentation, see {@link
+             * SearchSpec.Builder#setRankingStrategy(String)}.
+             */
+            @CanIgnoreReturnValue
+            @FlaggedApi(Flags.FLAG_ENABLE_SCORABLE_PROPERTY)
+            @NonNull
+            public LongPropertyConfig.Builder setScoringEnabled(boolean scoringEnabled) {
+                mScoringEnabled = scoringEnabled;
+                return this;
+            }
+
             /** Constructs a new {@link LongPropertyConfig} from the contents of this builder. */
             @NonNull
             public LongPropertyConfig build() {
                 return new LongPropertyConfig(
                         PropertyConfigParcel.createForLong(
-                                mPropertyName, mDescription, mCardinality, mIndexingType));
+                                mPropertyName,
+                                mDescription,
+                                mCardinality,
+                                mIndexingType,
+                                mScoringEnabled));
             }
         }
 
@@ -1132,11 +1338,18 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
             super(propertyConfigParcel);
         }
 
+        /** Returns if the property is enabled for scoring. */
+        @FlaggedApi(Flags.FLAG_ENABLE_SCORABLE_PROPERTY)
+        public boolean isScoringEnabled() {
+            return mPropertyConfigParcel.isScoringEnabled();
+        }
+
         /** Builder for {@link DoublePropertyConfig}. */
         public static final class Builder {
             private final String mPropertyName;
             private String mDescription = "";
             @Cardinality private int mCardinality = CARDINALITY_OPTIONAL;
+            private boolean mScoringEnabled = false;
 
             /** Creates a new {@link DoublePropertyConfig.Builder}. */
             public Builder(@NonNull String propertyName) {
@@ -1174,12 +1387,31 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
                 return this;
             }
 
+            /**
+             * Sets the property enabled or disabled for scoring.
+             *
+             * <p>If this method is not called, the default value is false.
+             *
+             * <p>If enabled, it can be used in the advanced ranking expression via the function of
+             * 'getScorableProperty'.
+             *
+             * <p>For the detailed documentation, see {@link
+             * SearchSpec.Builder#setRankingStrategy(String)}.
+             */
+            @CanIgnoreReturnValue
+            @FlaggedApi(Flags.FLAG_ENABLE_SCORABLE_PROPERTY)
+            @NonNull
+            public DoublePropertyConfig.Builder setScoringEnabled(boolean scoringEnabled) {
+                mScoringEnabled = scoringEnabled;
+                return this;
+            }
+
             /** Constructs a new {@link DoublePropertyConfig} from the contents of this builder. */
             @NonNull
             public DoublePropertyConfig build() {
                 return new DoublePropertyConfig(
                         PropertyConfigParcel.createForDouble(
-                                mPropertyName, mDescription, mCardinality));
+                                mPropertyName, mDescription, mCardinality, mScoringEnabled));
             }
         }
     }
@@ -1190,11 +1422,18 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
             super(propertyConfigParcel);
         }
 
+        /** Returns if the property is enabled for scoring. */
+        @FlaggedApi(Flags.FLAG_ENABLE_SCORABLE_PROPERTY)
+        public boolean isScoringEnabled() {
+            return mPropertyConfigParcel.isScoringEnabled();
+        }
+
         /** Builder for {@link BooleanPropertyConfig}. */
         public static final class Builder {
             private final String mPropertyName;
             private String mDescription = "";
             @Cardinality private int mCardinality = CARDINALITY_OPTIONAL;
+            private boolean mScoringEnabled = false;
 
             /** Creates a new {@link BooleanPropertyConfig.Builder}. */
             public Builder(@NonNull String propertyName) {
@@ -1232,12 +1471,31 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
                 return this;
             }
 
+            /**
+             * Sets the property enabled or disabled for scoring.
+             *
+             * <p>If this method is not called, the default value is false.
+             *
+             * <p>If enabled, it can be used in the advanced ranking expression via the function of
+             * 'getScorableProperty'.
+             *
+             * <p>For the detailed documentation, see {@link
+             * SearchSpec.Builder#setRankingStrategy(String)}.
+             */
+            @CanIgnoreReturnValue
+            @FlaggedApi(Flags.FLAG_ENABLE_SCORABLE_PROPERTY)
+            @NonNull
+            public BooleanPropertyConfig.Builder setScoringEnabled(boolean scoringEnabled) {
+                mScoringEnabled = scoringEnabled;
+                return this;
+            }
+
             /** Constructs a new {@link BooleanPropertyConfig} from the contents of this builder. */
             @NonNull
             public BooleanPropertyConfig build() {
                 return new BooleanPropertyConfig(
                         PropertyConfigParcel.createForBoolean(
-                                mPropertyName, mDescription, mCardinality));
+                                mPropertyName, mDescription, mCardinality, mScoringEnabled));
             }
         }
     }
@@ -1582,6 +1840,25 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
          */
         public static final int INDEXING_TYPE_SIMILARITY = 1;
 
+        /**
+         * Indicates whether the vector contents of this property should be quantized.
+         *
+         * @hide
+         */
+        @IntDef(
+                value = {
+                    QUANTIZATION_TYPE_NONE,
+                    QUANTIZATION_TYPE_8_BIT,
+                })
+        @Retention(RetentionPolicy.SOURCE)
+        public @interface QuantizationType {}
+
+        /** Contents in this property will not be quantized. */
+        public static final int QUANTIZATION_TYPE_NONE = 0;
+
+        /** Contents in this property will be quantized to 8 bits. */
+        public static final int QUANTIZATION_TYPE_8_BIT = 1;
+
         EmbeddingPropertyConfig(@NonNull PropertyConfigParcel propertyConfigParcel) {
             super(propertyConfigParcel);
         }
@@ -1597,6 +1874,22 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
             return indexingConfigParcel.getIndexingType();
         }
 
+        /**
+         * Returns how the embedding contents of this property should be quantized.
+         *
+         * <p>If the property isn't indexed, returns {@link #QUANTIZATION_TYPE_NONE}.
+         */
+        @EmbeddingPropertyConfig.QuantizationType
+        @FlaggedApi(Flags.FLAG_ENABLE_SCHEMA_EMBEDDING_QUANTIZATION)
+        public int getQuantizationType() {
+            PropertyConfigParcel.EmbeddingIndexingConfigParcel indexingConfigParcel =
+                    mPropertyConfigParcel.getEmbeddingIndexingConfigParcel();
+            if (indexingConfigParcel == null) {
+                return QUANTIZATION_TYPE_NONE;
+            }
+            return indexingConfigParcel.getQuantizationType();
+        }
+
         /** Builder for {@link EmbeddingPropertyConfig}. */
         @FlaggedApi(Flags.FLAG_ENABLE_SCHEMA_EMBEDDING_PROPERTY_CONFIG)
         public static final class Builder {
@@ -1605,6 +1898,9 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
             @Cardinality private int mCardinality = CARDINALITY_OPTIONAL;
             @EmbeddingPropertyConfig.IndexingType private int mIndexingType = INDEXING_TYPE_NONE;
 
+            @EmbeddingPropertyConfig.QuantizationType
+            private int mQuantizationType = QUANTIZATION_TYPE_NONE;
+
             /** Creates a new {@link EmbeddingPropertyConfig.Builder}. */
             public Builder(@NonNull String propertyName) {
                 mPropertyName = Objects.requireNonNull(propertyName);
@@ -1658,6 +1954,31 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
                 return this;
             }
 
+            /**
+             * Configures whether the vector contents of this property should be quantized.
+             *
+             * <p>Quantization can reduce the size of the embedding search index, potentially
+             * leading to faster embedding search due to lower I/O bandwidth. Quantization is
+             * usually very reliable and in most cases will have a negligible impact on recall.
+             * Using quantization is strongly recommended.
+             *
+             * <p>If this method is not called, the default quantization type is {@link
+             * EmbeddingPropertyConfig#QUANTIZATION_TYPE_NONE}.
+             */
+            @FlaggedApi(Flags.FLAG_ENABLE_SCHEMA_EMBEDDING_QUANTIZATION)
+            @CanIgnoreReturnValue
+            @NonNull
+            public EmbeddingPropertyConfig.Builder setQuantizationType(
+                    @EmbeddingPropertyConfig.QuantizationType int quantizationType) {
+                Preconditions.checkArgumentInRange(
+                        quantizationType,
+                        QUANTIZATION_TYPE_NONE,
+                        QUANTIZATION_TYPE_8_BIT,
+                        "quantizationType");
+                mQuantizationType = quantizationType;
+                return this;
+            }
+
             /**
              * Constructs a new {@link EmbeddingPropertyConfig} from the contents of this builder.
              */
@@ -1665,7 +1986,73 @@ public final class AppSearchSchema extends AbstractSafeParcelable {
             public EmbeddingPropertyConfig build() {
                 return new EmbeddingPropertyConfig(
                         PropertyConfigParcel.createForEmbedding(
-                                mPropertyName, mDescription, mCardinality, mIndexingType));
+                                mPropertyName,
+                                mDescription,
+                                mCardinality,
+                                mIndexingType,
+                                mQuantizationType));
+            }
+        }
+    }
+
+    /** Configuration for a property of type {@link AppSearchBlobHandle} in a Document. */
+    @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
+    public static final class BlobHandlePropertyConfig extends PropertyConfig {
+        BlobHandlePropertyConfig(@NonNull PropertyConfigParcel propertyConfigParcel) {
+            super(propertyConfigParcel);
+        }
+
+        /** Builder for {@link BlobHandlePropertyConfig}. */
+        @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
+        public static final class Builder {
+            private final String mPropertyName;
+            private String mDescription = "";
+            @Cardinality private int mCardinality = CARDINALITY_OPTIONAL;
+
+            /** Creates a new {@link BlobHandlePropertyConfig.Builder}. */
+            public Builder(@NonNull String propertyName) {
+                mPropertyName = Objects.requireNonNull(propertyName);
+            }
+
+            /**
+             * Sets a natural language description of this property.
+             *
+             * <p>For more details about the description field, see {@link
+             * AppSearchSchema.PropertyConfig#getDescription}.
+             */
+            @CanIgnoreReturnValue
+            @FlaggedApi(Flags.FLAG_ENABLE_APP_FUNCTIONS)
+            @SuppressWarnings("MissingGetterMatchingBuilder") // getter defined in superclass
+            @NonNull
+            public Builder setDescription(@NonNull String description) {
+                mDescription = Objects.requireNonNull(description);
+                return this;
+            }
+
+            /**
+             * Sets the cardinality of the property (whether it is optional, required or repeated).
+             *
+             * <p>If this method is not called, the default cardinality is {@link
+             * PropertyConfig#CARDINALITY_OPTIONAL}.
+             */
+            @CanIgnoreReturnValue
+            @SuppressWarnings("MissingGetterMatchingBuilder") // getter defined in superclass
+            @NonNull
+            public Builder setCardinality(@Cardinality int cardinality) {
+                Preconditions.checkArgumentInRange(
+                        cardinality, CARDINALITY_REPEATED, CARDINALITY_REQUIRED, "cardinality");
+                mCardinality = cardinality;
+                return this;
+            }
+
+            /**
+             * Constructs a new {@link BlobHandlePropertyConfig} from the contents of this builder.
+             */
+            @NonNull
+            public BlobHandlePropertyConfig build() {
+                return new BlobHandlePropertyConfig(
+                        PropertyConfigParcel.createForBlobHandle(
+                                mPropertyName, mDescription, mCardinality));
             }
         }
     }
diff --git a/framework/java/external/android/app/appsearch/CommitBlobResponse.java b/framework/java/external/android/app/appsearch/CommitBlobResponse.java
new file mode 100644
index 00000000..f6722ef8
--- /dev/null
+++ b/framework/java/external/android/app/appsearch/CommitBlobResponse.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.app.appsearch;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.app.appsearch.aidl.AppSearchBatchResultParcelV2;
+import android.app.appsearch.safeparcel.AbstractSafeParcelable;
+import android.app.appsearch.safeparcel.SafeParcelable;
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import com.android.appsearch.flags.Flags;
+
+import java.util.Objects;
+
+/**
+ * The response to provide batch operation results of {@link AppSearchSession#commitBlob}.
+ *
+ * <p>This class is used to retrieve the result of a batch commit operation on a collection of blob
+ * handles.
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
+@SuppressWarnings("HiddenSuperclass")
+@SafeParcelable.Class(creator = "CommitBlobResponseCreator")
+public final class CommitBlobResponse extends AbstractSafeParcelable {
+
+    @NonNull
+    public static final Parcelable.Creator<CommitBlobResponse> CREATOR =
+            new CommitBlobResponseCreator();
+
+    @Field(id = 1, getter = "getResponseParcel")
+    private final AppSearchBatchResultParcelV2<AppSearchBlobHandle, Void> mResultParcel;
+
+    /** Creates a {@link CommitBlobResponse} with given {@link AppSearchBatchResult}. */
+    public CommitBlobResponse(@NonNull AppSearchBatchResult<AppSearchBlobHandle, Void> result) {
+        this(AppSearchBatchResultParcelV2.fromBlobHandleToVoid(result));
+    }
+
+    @Constructor
+    CommitBlobResponse(
+            @Param(id = 1) @NonNull
+                    AppSearchBatchResultParcelV2<AppSearchBlobHandle, Void> resultParcel) {
+        mResultParcel = Objects.requireNonNull(resultParcel);
+    }
+
+    /**
+     * Returns the {@link AppSearchBatchResult} object containing the results of the commit
+     * operation for each {@link AppSearchBlobHandle}.
+     *
+     * @return A {@link AppSearchBatchResult} maps {@link AppSearchBlobHandle}s which is a unique
+     *     identifier for a specific blob being committed to the outcome of that commit. If the
+     *     operation was successful, the result for that handle is {@code null}; if there was an
+     *     error, the result contains an {@link AppSearchResult} with details of the failure.
+     */
+    @NonNull
+    public AppSearchBatchResult<AppSearchBlobHandle, Void> getResult() {
+        return mResultParcel.getResult();
+    }
+
+    /**
+     * Retrieves the underlying parcel representation of the batch result.
+     *
+     * @hide
+     */
+    @NonNull
+    public AppSearchBatchResultParcelV2<AppSearchBlobHandle, Void> getResponseParcel() {
+        return mResultParcel;
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        CommitBlobResponseCreator.writeToParcel(this, dest, flags);
+    }
+}
diff --git a/framework/java/external/android/app/appsearch/FeatureConstants.java b/framework/java/external/android/app/appsearch/FeatureConstants.java
index e0846b4f..8cde9161 100644
--- a/framework/java/external/android/app/appsearch/FeatureConstants.java
+++ b/framework/java/external/android/app/appsearch/FeatureConstants.java
@@ -16,6 +16,11 @@
 
 package android.app.appsearch;
 
+import android.util.ArraySet;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Set;
 
 /**
  * A class that encapsulates all feature constants that are accessible in AppSearch framework.
@@ -40,8 +45,22 @@ public final class FeatureConstants {
     public static final String LIST_FILTER_HAS_PROPERTY_FUNCTION =
             "LIST_FILTER_HAS_PROPERTY_FUNCTION";
 
+    /** Feature constants for {@link Features#LIST_FILTER_MATCH_SCORE_EXPRESSION_FUNCTION}. */
+    public static final String LIST_FILTER_MATCH_SCORE_EXPRESSION_FUNCTION =
+            "LIST_FILTER_MATCH_SCORE_EXPRESSION_FUNCTION";
+
     /** A feature constant for the "semanticSearch" function in {@link AppSearchSession#search}. */
     public static final String EMBEDDING_SEARCH = "EMBEDDING_SEARCH";
 
+    /**
+     * A feature constant for the "getScorableProperty" function in {@link AppSearchSession#search}.
+     */
+    public static final String SCHEMA_SCORABLE_PROPERTY_CONFIG = "SCHEMA_SCORABLE_PROPERTY_CONFIG";
+
+    /** A set of scoring features. */
+    public static final Set<String> SCORABLE_FEATURE_SET =
+            Collections.unmodifiableSet(
+                    new ArraySet<>(Arrays.asList(SCHEMA_SCORABLE_PROPERTY_CONFIG)));
+
     private FeatureConstants() {}
 }
diff --git a/framework/java/external/android/app/appsearch/GenericDocument.java b/framework/java/external/android/app/appsearch/GenericDocument.java
index eb1cdb6d..f84f5513 100644
--- a/framework/java/external/android/app/appsearch/GenericDocument.java
+++ b/framework/java/external/android/app/appsearch/GenericDocument.java
@@ -21,7 +21,6 @@ import android.annotation.FlaggedApi;
 import android.annotation.IntRange;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
-import android.annotation.RequiresApi;
 import android.annotation.SuppressLint;
 import android.annotation.SystemApi;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
@@ -138,14 +137,27 @@ public class GenericDocument {
     // GenericDocument is an open class that can be extended, whereas parcelable classes must be
     // final in those methods. Thus, we make this a system api to avoid 3p apps depending on it
     // and getting confused by the inheritability.
+    @SuppressWarnings("deprecation")
     @SystemApi(client = SystemApi.Client.MODULE_LIBRARIES)
-    @RequiresApi(api = Build.VERSION_CODES.TIRAMISU)
     @FlaggedApi(Flags.FLAG_ENABLE_GENERIC_DOCUMENT_OVER_IPC)
     @NonNull
     public static GenericDocument createFromParcel(@NonNull Parcel parcel) {
         Objects.requireNonNull(parcel);
-        GenericDocumentParcel documentParcel =
-                parcel.readParcelable(GenericDocumentParcel.class.getClassLoader());
+        GenericDocumentParcel documentParcel;
+
+        // Code built in Framework cannot depend on Androidx libraries. Therefore, we must call
+        // Parcel#readParcelable directly.
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
+            documentParcel =
+                    parcel.readParcelable(
+                            GenericDocumentParcel.class.getClassLoader(),
+                            GenericDocumentParcel.class);
+        } else {
+            // The Parcel#readParcelable(ClassLoader, Class) function has a known issue on Android
+            // T. This was fixed on Android U. When on Android T, call the older version of
+            // Parcel#readParcelable.
+            documentParcel = parcel.readParcelable(GenericDocumentParcel.class.getClassLoader());
+        }
         return new GenericDocument(documentParcel);
     }
 
@@ -183,8 +195,11 @@ public class GenericDocument {
      *
      * <p>It is guaranteed that child types appear before parent types in the list.
      *
+     * @deprecated Parent types should no longer be set in {@link GenericDocument}. Use {@link
+     *     SearchResult.Builder#getParentTypeMap()} instead.
      * @hide
      */
+    @Deprecated
     @Nullable
     public List<String> getParentTypes() {
         List<String> result = mDocumentParcel.getParentTypes();
@@ -415,6 +430,11 @@ public class GenericDocument {
                     if (embeddingValues != null && index < embeddingValues.length) {
                         extractedValue = Arrays.copyOfRange(embeddingValues, index, index + 1);
                     }
+                } else if (propertyParcel.getBlobHandleValues() != null) {
+                    AppSearchBlobHandle[] blobHandlesValues = propertyParcel.getBlobHandleValues();
+                    if (blobHandlesValues != null && index < blobHandlesValues.length) {
+                        extractedValue = Arrays.copyOfRange(blobHandlesValues, index, index + 1);
+                    }
                 } else {
                     throw new IllegalStateException(
                             "Unsupported value type: " + currentElementValue);
@@ -734,6 +754,30 @@ public class GenericDocument {
         return propertyArray[0];
     }
 
+    /**
+     * Retrieves an {@link AppSearchBlobHandle} property by path.
+     *
+     * <p>See {@link #getProperty} for a detailed description of the path syntax.
+     *
+     * <p>See {@link AppSearchSession#openBlobForRead} for how to use {@link AppSearchBlobHandle} to
+     * retrieve blob data.
+     *
+     * @param path The path to look for.
+     * @return The first {@link AppSearchBlobHandle} associated with the given path or {@code null}
+     *     if there is no such value or the value is of a different type.
+     */
+    @Nullable
+    @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
+    public AppSearchBlobHandle getPropertyBlobHandle(@NonNull String path) {
+        Objects.requireNonNull(path);
+        AppSearchBlobHandle[] propertyArray = getPropertyBlobHandleArray(path);
+        if (propertyArray == null || propertyArray.length == 0) {
+            return null;
+        }
+        warnIfSinglePropertyTooLong("BlobHandle", path, propertyArray.length);
+        return propertyArray[0];
+    }
+
     /** Prints a warning to logcat if the given propertyLength is greater than 1. */
     private static void warnIfSinglePropertyTooLong(
             @NonNull String propertyType, @NonNull String path, int propertyLength) {
@@ -915,6 +959,30 @@ public class GenericDocument {
         return safeCastProperty(path, value, EmbeddingVector[].class);
     }
 
+    /**
+     * Retrieves a repeated {@code AppSearchBlobHandle[]} property by path.
+     *
+     * <p>See {@link #getProperty} for a detailed description of the path syntax.
+     *
+     * <p>If the property has not been set via {@link Builder#setPropertyBlobHandle}, this method
+     * returns {@code null}.
+     *
+     * <p>If it has been set via {@link Builder#setPropertyBlobHandle} to an empty {@code
+     * AppSearchBlobHandle[]}, this method returns an empty {@code AppSearchBlobHandle[]}.
+     *
+     * @param path The path to look for.
+     * @return The {@code AppSearchBlobHandle[]} associated with the given path, or {@code null} if
+     *     no value is set or the value is of a different type.
+     */
+    @SuppressLint({"ArrayReturn", "NullableCollection"})
+    @Nullable
+    @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
+    public AppSearchBlobHandle[] getPropertyBlobHandleArray(@NonNull String path) {
+        Objects.requireNonNull(path);
+        Object value = getProperty(path);
+        return safeCastProperty(path, value, AppSearchBlobHandle[].class);
+    }
+
     /**
      * Casts a repeated property to the provided type, logging an error and returning {@code null}
      * if the cast fails.
@@ -937,23 +1005,6 @@ public class GenericDocument {
         }
     }
 
-    /**
-     * Copies the contents of this {@link GenericDocument} into a new {@link
-     * GenericDocument.Builder}.
-     *
-     * <p>The returned builder is a deep copy whose data is separate from this document.
-     *
-     * @deprecated This API is not compliant with API guidelines. Use {@link
-     *     Builder#Builder(GenericDocument)} instead.
-     * @hide
-     */
-    // TODO(b/171882200): Expose this API in Android T
-    @NonNull
-    @Deprecated
-    public GenericDocument.Builder<GenericDocument.Builder<?>> toBuilder() {
-        return new Builder<>(new GenericDocumentParcel.Builder(mDocumentParcel));
-    }
-
     @Override
     public boolean equals(@Nullable Object other) {
         if (this == other) {
@@ -1190,12 +1241,14 @@ public class GenericDocument {
          *
          * <p>Child types must appear before parent types in the list.
          *
+         * @deprecated Parent types should no longer be set in {@link GenericDocument}. Use {@link
+         *     SearchResult.Builder#setParentTypeMap(Map)} instead.
          * @hide
          */
         @CanIgnoreReturnValue
+        @Deprecated
         @NonNull
-        public BuilderType setParentTypes(@NonNull List<String> parentTypes) {
-            Objects.requireNonNull(parentTypes);
+        public BuilderType setParentTypes(@Nullable List<String> parentTypes) {
             mDocumentParcelBuilder.setParentTypes(parentTypes);
             return mBuilderTypeInstance;
         }
@@ -1347,6 +1400,8 @@ public class GenericDocument {
         /**
          * Sets one or multiple {@code byte[]} for a property, replacing its previous values.
          *
+         * <p>For large byte data and lazy retrieval, see {@link #setPropertyBlobHandle}.
+         *
          * @param name the name associated with the {@code values}. Must match the name for this
          *     property as given in {@link AppSearchSchema.PropertyConfig#getName}.
          * @param values the {@code byte[]} of the property.
@@ -1422,6 +1477,39 @@ public class GenericDocument {
             return mBuilderTypeInstance;
         }
 
+        /**
+         * Sets one or multiple {@link AppSearchBlobHandle} values for a property, replacing its
+         * previous values.
+         *
+         * <p>{@link AppSearchBlobHandle} is a pointer to a blob of data.
+         *
+         * <p>Store large byte via the {@link android.os.ParcelFileDescriptor} returned from {@link
+         * AppSearchSession#openBlobForWrite}. Once the blob data is committed via {@link
+         * AppSearchSession#commitBlob}, the blob is retrievable via {@link
+         * AppSearchSession#openBlobForRead}.
+         *
+         * @param name the name associated with the {@code values}. Must match the name for this
+         *     property as given in {@link AppSearchSchema.PropertyConfig#getName}.
+         * @param values the {@link AppSearchBlobHandle} values of the property.
+         * @throws IllegalArgumentException if the name is empty or {@code null}.
+         */
+        @CanIgnoreReturnValue
+        @NonNull
+        @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
+        public BuilderType setPropertyBlobHandle(
+                @NonNull String name, @NonNull AppSearchBlobHandle... values) {
+            Objects.requireNonNull(name);
+            Objects.requireNonNull(values);
+            validatePropertyName(name);
+            for (int i = 0; i < values.length; i++) {
+                if (values[i] == null) {
+                    throw new IllegalArgumentException("The BlobHandle at " + i + " is null.");
+                }
+            }
+            mDocumentParcelBuilder.putInPropertyMap(name, values);
+            return mBuilderTypeInstance;
+        }
+
         /**
          * Clears the value for the property with the given name.
          *
diff --git a/framework/java/external/android/app/appsearch/GetSchemaResponse.java b/framework/java/external/android/app/appsearch/GetSchemaResponse.java
index d7c63a23..db510bd4 100644
--- a/framework/java/external/android/app/appsearch/GetSchemaResponse.java
+++ b/framework/java/external/android/app/appsearch/GetSchemaResponse.java
@@ -30,6 +30,7 @@ import android.util.ArrayMap;
 import android.util.ArraySet;
 
 import com.android.appsearch.flags.Flags;
+import com.android.internal.util.Preconditions;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -311,11 +312,27 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
 
         private boolean mBuilt = false;
 
-        /** Create a {@link Builder} object} */
+        /** Creates a new {@link Builder} */
         public Builder() {
             setVisibilitySettingSupported(true);
         }
 
+        /** Creates a new {@link Builder} from the given {@link GetSchemaResponse}. */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        public Builder(@NonNull GetSchemaResponse getSchemaResponse) {
+            setVisibilitySettingSupported(true);
+            mVersion = getSchemaResponse.mVersion;
+            mSchemas.addAll(getSchemaResponse.mSchemas);
+            if (getSchemaResponse.mVisibilityConfigs != null) {
+                int count = getSchemaResponse.mVisibilityConfigs.size();
+                for (int i = 0; i < count; i++) {
+                    InternalVisibilityConfig config = getSchemaResponse.mVisibilityConfigs.get(i);
+                    mVisibilityConfigBuilders.put(
+                            config.getSchemaType(), new InternalVisibilityConfig.Builder(config));
+                }
+            }
+        }
+
         /**
          * Sets the database overall schema version.
          *
@@ -324,6 +341,7 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
         @CanIgnoreReturnValue
         @NonNull
         public Builder setVersion(@IntRange(from = 0) int version) {
+            Preconditions.checkArgument(version >= 0, "Version must be a non-negative number.");
             resetIfBuilt();
             mVersion = version;
             return this;
@@ -339,6 +357,16 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
             return this;
         }
 
+        /** Clears all {@link AppSearchSchema}s from the list of schemas. */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        @CanIgnoreReturnValue
+        @NonNull
+        public Builder clearSchemas() {
+            resetIfBuilt();
+            mSchemas.clear();
+            return this;
+        }
+
         /**
          * Sets whether or not documents from the provided {@code schemaType} will be displayed and
          * visible on any system UI surface.
@@ -359,6 +387,26 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
             return this;
         }
 
+        /**
+         * Clears the visibility setting for the given schema type that prevents the schema from
+         * being displayed and visible on any system UI surface.
+         *
+         * @see Builder#addSchemaTypeNotDisplayedBySystem
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        @CanIgnoreReturnValue
+        @NonNull
+        public Builder clearSchemaTypeNotDisplayedBySystem(@NonNull String schemaType) {
+            Objects.requireNonNull(schemaType);
+            resetIfBuilt();
+            InternalVisibilityConfig.Builder visibilityConfigBuilder =
+                    getVisibilityConfigBuilder(schemaType);
+            if (visibilityConfigBuilder != null) {
+                visibilityConfigBuilder.setNotDisplayedBySystem(false);
+            }
+            return this;
+        }
+
         /**
          * Sets whether or not documents from the provided {@code schemaType} can be read by the
          * specified package.
@@ -394,6 +442,25 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
             return this;
         }
 
+        /**
+         * Clears the set of packages that can read the given schema type.
+         *
+         * @see Builder#setSchemaTypeVisibleToPackages
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        @CanIgnoreReturnValue
+        @NonNull
+        public Builder clearSchemaTypeVisibleToPackages(@NonNull String schemaType) {
+            Objects.requireNonNull(schemaType);
+            resetIfBuilt();
+            InternalVisibilityConfig.Builder visibilityConfigBuilder =
+                    getVisibilityConfigBuilder(schemaType);
+            if (visibilityConfigBuilder != null) {
+                visibilityConfigBuilder.clearVisibleToPackages();
+            }
+            return this;
+        }
+
         /**
          * Sets a set of required {@link android.Manifest.permission} combinations to the given
          * schema type.
@@ -425,8 +492,9 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
          */
         // TODO(b/237388235): add enterprise permissions to javadocs after they're unhidden
         // Getter getRequiredPermissionsForSchemaTypeVisibility returns a map for all schemaTypes.
+        // To use this API doesn't require permissions.
         @CanIgnoreReturnValue
-        @SuppressLint("MissingGetterMatchingBuilder")
+        @SuppressLint({"MissingGetterMatchingBuilder", "RequiresPermission"})
         // @SetSchemaRequest is an IntDef annotation applied to Set<Set<Integer>>.
         @SuppressWarnings("SupportAnnotationUsage")
         @NonNull
@@ -445,6 +513,29 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
             return this;
         }
 
+        /**
+         * Clears the set of required {@link android.Manifest.permission} combinations to read the
+         * given schema type.
+         *
+         * @see Builder#setRequiredPermissionsForSchemaTypeVisibility
+         */
+        // To use this API doesn't require permissions.
+
+        @SuppressLint("RequiresPermission")
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        @CanIgnoreReturnValue
+        @NonNull
+        public Builder clearRequiredPermissionsForSchemaTypeVisibility(@NonNull String schemaType) {
+            Objects.requireNonNull(schemaType);
+            resetIfBuilt();
+            InternalVisibilityConfig.Builder visibilityConfigBuilder =
+                    getVisibilityConfigBuilder(schemaType);
+            if (visibilityConfigBuilder != null) {
+                visibilityConfigBuilder.clearVisibleToPermissions();
+            }
+            return this;
+        }
+
         /**
          * Specify that the schema should be publicly available, to packages which already have
          * visibility to {@code packageIdentifier}.
@@ -469,6 +560,26 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
             return this;
         }
 
+        /**
+         * Clears the visibility setting that specifies that the given schema type should be
+         * publicly available to packages which already have visibility to a specified package.
+         *
+         * @see Builder#setPubliclyVisibleSchema
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        @CanIgnoreReturnValue
+        @NonNull
+        public Builder clearPubliclyVisibleSchema(@NonNull String schemaType) {
+            Objects.requireNonNull(schemaType);
+            resetIfBuilt();
+            InternalVisibilityConfig.Builder visibilityConfigBuilder =
+                    getVisibilityConfigBuilder(schemaType);
+            if (visibilityConfigBuilder != null) {
+                visibilityConfigBuilder.setPubliclyVisibleTargetPackage(null);
+            }
+            return this;
+        }
+
         /**
          * Sets the documents from the provided {@code schemaType} can be read by the caller if they
          * match the ALL visibility requirements set in {@link SchemaVisibilityConfig}.
@@ -514,6 +625,27 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
             return this;
         }
 
+        /**
+         * Clears the {@link SchemaVisibilityConfig}s for the given schema type which allow
+         * visibility to the schema if the caller matches ALL visibility requirements of ANY {@link
+         * SchemaVisibilityConfig}.
+         *
+         * @see Builder#setSchemaTypeVisibleToConfigs
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        @CanIgnoreReturnValue
+        @NonNull
+        public Builder clearSchemaTypeVisibleToConfigs(@NonNull String schemaType) {
+            Objects.requireNonNull(schemaType);
+            resetIfBuilt();
+            InternalVisibilityConfig.Builder visibilityConfigBuilder =
+                    getVisibilityConfigBuilder(schemaType);
+            if (visibilityConfigBuilder != null) {
+                visibilityConfigBuilder.clearVisibleToConfig();
+            }
+            return this;
+        }
+
         /**
          * Method to set visibility setting. If this is called with false, {@link
          * #getRequiredPermissionsForSchemaTypeVisibility()}, {@link
@@ -568,6 +700,16 @@ public final class GetSchemaResponse extends AbstractSafeParcelable {
             return builder;
         }
 
+        @Nullable
+        private InternalVisibilityConfig.Builder getVisibilityConfigBuilder(
+                @NonNull String schemaType) {
+            if (mVisibilityConfigBuilders == null) {
+                throw new IllegalStateException(
+                        "GetSchemaResponse is not configured with" + "visibility setting support");
+            }
+            return mVisibilityConfigBuilders.get(schemaType);
+        }
+
         private void resetIfBuilt() {
             if (mBuilt) {
                 // No need to copy mVisibilityConfigBuilders -- it gets copied during build().
diff --git a/framework/java/external/android/app/appsearch/InternalVisibilityConfig.java b/framework/java/external/android/app/appsearch/InternalVisibilityConfig.java
index c4544dcf..8ec15fb2 100644
--- a/framework/java/external/android/app/appsearch/InternalVisibilityConfig.java
+++ b/framework/java/external/android/app/appsearch/InternalVisibilityConfig.java
@@ -46,7 +46,7 @@ public final class InternalVisibilityConfig extends AbstractSafeParcelable {
     public static final Parcelable.Creator<InternalVisibilityConfig> CREATOR =
             new InternalVisibilityConfigCreator();
 
-    /** Build the List of {@link InternalVisibilityConfig}s from visibility settings. */
+    /** Build the List of {@link InternalVisibilityConfig}s from given {@link SetSchemaRequest}. */
     @NonNull
     public static List<InternalVisibilityConfig> toInternalVisibilityConfigs(
             @NonNull SetSchemaRequest setSchemaRequest) {
@@ -100,6 +100,42 @@ public final class InternalVisibilityConfig extends AbstractSafeParcelable {
         return result;
     }
 
+    /**
+     * Build the List of {@link InternalVisibilityConfig}s from given {@link
+     * SetBlobVisibilityRequest}.
+     */
+    @NonNull
+    public static List<InternalVisibilityConfig> toInternalVisibilityConfigs(
+            @NonNull SetBlobVisibilityRequest setBlobVisibilityRequest) {
+
+        Set<String> blobNamespacesNotDisplayedBySystem =
+                setBlobVisibilityRequest.getNamespacesNotDisplayedBySystem();
+        Map<String, Set<SchemaVisibilityConfig>> blobNamespacesVisibleToConfigs =
+                setBlobVisibilityRequest.getNamespacesVisibleToConfigs();
+
+        Set<String> allBlobNamespaces = new ArraySet<>(blobNamespacesNotDisplayedBySystem);
+        allBlobNamespaces.addAll(blobNamespacesVisibleToConfigs.keySet());
+
+        List<InternalVisibilityConfig> result = new ArrayList<>();
+        for (String namespace : allBlobNamespaces) {
+            InternalVisibilityConfig.Builder builder =
+                    new InternalVisibilityConfig.Builder(namespace)
+                            .setNotDisplayedBySystem(
+                                    blobNamespacesNotDisplayedBySystem.contains(namespace));
+
+            Set<SchemaVisibilityConfig> visibleToConfigs =
+                    blobNamespacesVisibleToConfigs.get(namespace);
+            if (visibleToConfigs != null) {
+                for (SchemaVisibilityConfig schemaVisibilityConfig : visibleToConfigs) {
+                    builder.addVisibleToConfig(schemaVisibilityConfig);
+                }
+            }
+
+            result.add(builder.build());
+        }
+        return result;
+    }
+
     @NonNull
     @Field(id = 1, getter = "getSchemaType")
     private final String mSchemaType;
diff --git a/framework/java/external/android/app/appsearch/JoinSpec.java b/framework/java/external/android/app/appsearch/JoinSpec.java
index 43375885..0e9bdbe4 100644
--- a/framework/java/external/android/app/appsearch/JoinSpec.java
+++ b/framework/java/external/android/app/appsearch/JoinSpec.java
@@ -267,7 +267,7 @@ public final class JoinSpec extends AbstractSafeParcelable {
 
         private String mNestedQuery = "";
         private SearchSpec mNestedSearchSpec = EMPTY_SEARCH_SPEC;
-        private final String mChildPropertyExpression;
+        private String mChildPropertyExpression;
         private int mMaxJoinedResultCount = DEFAULT_MAX_JOINED_RESULT_COUNT;
 
         @AggregationScoringStrategy
@@ -276,7 +276,7 @@ public final class JoinSpec extends AbstractSafeParcelable {
         /**
          * Create a specification for the joining operation in search.
          *
-         * <p>The child property expressions Specifies how to join documents. Documents with a child
+         * <p>The child property expression specifies how to join documents. Documents with a child
          * property expression equal to the qualified id of the parent will be retrieved.
          *
          * <p>Property expressions differ from {@link PropertyPath} as property expressions may
@@ -301,7 +301,8 @@ public final class JoinSpec extends AbstractSafeParcelable {
             mChildPropertyExpression = childPropertyExpression;
         }
 
-        /** @hide */
+        /** Creates a new {@link Builder} from the given {@link JoinSpec}. */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         public Builder(@NonNull JoinSpec joinSpec) {
             Objects.requireNonNull(joinSpec);
             mNestedQuery = joinSpec.getNestedQuery();
@@ -311,6 +312,32 @@ public final class JoinSpec extends AbstractSafeParcelable {
             mAggregationScoringStrategy = joinSpec.getAggregationScoringStrategy();
         }
 
+        /**
+         * Sets the child property expression.
+         *
+         * <p>The child property expression specifies how to join documents. Documents with a child
+         * property expression equal to the qualified id of the parent will be retrieved.
+         *
+         * <p>Property expressions differ from {@link PropertyPath} as property expressions may
+         * refer to document properties or nested document properties such as "person.business.id"
+         * as well as a property expression. Currently the only property expression is
+         * "this.qualifiedId()". {@link PropertyPath} objects may only reference document properties
+         * and nested document properties.
+         *
+         * <p>In order to join a child document to a parent document, the child document must
+         * contain the parent's qualified id at the property expression specified by this method.
+         *
+         * @param childPropertyExpression the property to match in the child documents.
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        @CanIgnoreReturnValue
+        @NonNull
+        public Builder setChildPropertyExpression(@NonNull String childPropertyExpression) {
+            Objects.requireNonNull(childPropertyExpression);
+            mChildPropertyExpression = childPropertyExpression;
+            return this;
+        }
+
         /**
          * Sets the query and the SearchSpec for the documents being joined. This will score and
          * rank the joined documents as well as filter the joined documents.
@@ -339,7 +366,6 @@ public final class JoinSpec extends AbstractSafeParcelable {
             Objects.requireNonNull(nestedSearchSpec);
             mNestedQuery = nestedQuery;
             mNestedSearchSpec = nestedSearchSpec;
-
             return this;
         }
 
diff --git a/framework/java/external/android/app/appsearch/OpenBlobForReadResponse.java b/framework/java/external/android/app/appsearch/OpenBlobForReadResponse.java
new file mode 100644
index 00000000..b5539649
--- /dev/null
+++ b/framework/java/external/android/app/appsearch/OpenBlobForReadResponse.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.app.appsearch;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.app.appsearch.aidl.AppSearchBatchResultParcelV2;
+import android.app.appsearch.safeparcel.AbstractSafeParcelable;
+import android.app.appsearch.safeparcel.SafeParcelable;
+import android.os.Parcel;
+import android.os.ParcelFileDescriptor;
+import android.os.Parcelable;
+
+import com.android.appsearch.flags.Flags;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.util.Objects;
+
+/**
+ * The response to provide batch operation results of {@link AppSearchSession#openBlobForRead}.
+ *
+ * <p>This class is used to retrieve the result of a batch read operation on a collection of blob
+ * handles.
+ *
+ * <p class="caution">The returned {@link android.os.ParcelFileDescriptor} must be closed after use
+ * to avoid resource leaks. Failing to close the descriptor will result in system resource
+ * exhaustion, as each open {@link android.os.ParcelFileDescriptor} occupies a limited file
+ * descriptor in the system.
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
+@SuppressWarnings("HiddenSuperclass")
+@SafeParcelable.Class(creator = "OpenBlobForReadResponseCreator")
+public final class OpenBlobForReadResponse extends AbstractSafeParcelable implements Closeable {
+
+    @NonNull
+    public static final Parcelable.Creator<OpenBlobForReadResponse> CREATOR =
+            new OpenBlobForReadResponseCreator();
+
+    @Field(id = 1)
+    final AppSearchBatchResultParcelV2<AppSearchBlobHandle, ParcelFileDescriptor> mResultParcel;
+
+    /** Creates a {@link OpenBlobForReadResponse} with given {@link AppSearchBatchResult}. */
+    public OpenBlobForReadResponse(
+            @NonNull AppSearchBatchResult<AppSearchBlobHandle, ParcelFileDescriptor> result) {
+        this(AppSearchBatchResultParcelV2.fromBlobHandleToPfd(result));
+    }
+
+    @Constructor
+    OpenBlobForReadResponse(
+            @AbstractSafeParcelable.Param(id = 1) @NonNull
+                    AppSearchBatchResultParcelV2<AppSearchBlobHandle, ParcelFileDescriptor>
+                            resultParcel) {
+        mResultParcel = Objects.requireNonNull(resultParcel);
+    }
+
+    /**
+     * Returns the {@link AppSearchBatchResult} object containing the results of the read blob for
+     * read operation for each {@link AppSearchBlobHandle}.
+     *
+     * @return A {@link AppSearchBatchResult} maps {@link AppSearchBlobHandle}s which is a unique
+     *     identifier for a specific blob being committed to the outcome of that read operation. If
+     *     the operation was successful, the result for that handle is {@link ParcelFileDescriptor};
+     *     if there was an error, the result contains an {@link AppSearchResult} with details of the
+     *     failure.
+     */
+    @NonNull
+    public AppSearchBatchResult<AppSearchBlobHandle, ParcelFileDescriptor> getResult() {
+        return mResultParcel.getResult();
+    }
+
+    @Override
+    public void close() {
+        AppSearchBatchResult<AppSearchBlobHandle, ParcelFileDescriptor> batchResult =
+                mResultParcel.getResult();
+        for (ParcelFileDescriptor pfd : batchResult.getSuccesses().values()) {
+            try {
+                pfd.close();
+            } catch (IOException ignored) {
+                // The file may be already removed, just ignoring any checked exceptions.
+            }
+        }
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        OpenBlobForReadResponseCreator.writeToParcel(this, dest, flags);
+    }
+}
diff --git a/framework/java/external/android/app/appsearch/OpenBlobForWriteResponse.java b/framework/java/external/android/app/appsearch/OpenBlobForWriteResponse.java
new file mode 100644
index 00000000..b5cb20c8
--- /dev/null
+++ b/framework/java/external/android/app/appsearch/OpenBlobForWriteResponse.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.app.appsearch;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.app.appsearch.aidl.AppSearchBatchResultParcelV2;
+import android.app.appsearch.safeparcel.AbstractSafeParcelable;
+import android.app.appsearch.safeparcel.SafeParcelable;
+import android.os.Parcel;
+import android.os.ParcelFileDescriptor;
+import android.os.Parcelable;
+
+import com.android.appsearch.flags.Flags;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.util.Objects;
+
+/**
+ * The response to provide batch operation results of {@link AppSearchSession#openBlobForWrite}.
+ *
+ * <p>This class is used to retrieve the result of a batch write operation on a collection of blob
+ * handles.
+ *
+ * <p class="caution">The returned {@link android.os.ParcelFileDescriptor} must be closed after use
+ * to avoid resource leaks. Failing to close the descriptor will result in system resource
+ * exhaustion, as each open {@link android.os.ParcelFileDescriptor} occupies a limited file
+ * descriptor in the system.
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
+@SuppressWarnings("HiddenSuperclass")
+@SafeParcelable.Class(creator = "OpenBlobForWriteResponseCreator")
+public final class OpenBlobForWriteResponse extends AbstractSafeParcelable implements Closeable {
+
+    @NonNull
+    public static final Parcelable.Creator<OpenBlobForWriteResponse> CREATOR =
+            new OpenBlobForWriteResponseCreator();
+
+    @Field(id = 1)
+    final AppSearchBatchResultParcelV2<AppSearchBlobHandle, ParcelFileDescriptor> mResultParcel;
+
+    /** Creates a {@link OpenBlobForWriteResponse} with given {@link AppSearchBatchResult}. */
+    public OpenBlobForWriteResponse(
+            @NonNull AppSearchBatchResult<AppSearchBlobHandle, ParcelFileDescriptor> result) {
+        this(AppSearchBatchResultParcelV2.fromBlobHandleToPfd(result));
+    }
+
+    @Constructor
+    OpenBlobForWriteResponse(
+            @AbstractSafeParcelable.Param(id = 1) @NonNull
+                    AppSearchBatchResultParcelV2<AppSearchBlobHandle, ParcelFileDescriptor>
+                            resultParcel) {
+        mResultParcel = Objects.requireNonNull(resultParcel);
+    }
+
+    /**
+     * Returns the {@link AppSearchBatchResult} object containing the results of the write blob for
+     * write operation for each {@link AppSearchBlobHandle}.
+     *
+     * @return A {@link AppSearchBatchResult} maps {@link AppSearchBlobHandle}s which is a unique
+     *     identifier for a specific blob being committed to the outcome of that write operation. If
+     *     the operation was successful, the result for that handle is {@link ParcelFileDescriptor};
+     *     if there was an error, the result contains an {@link AppSearchResult} with details of the
+     *     failure.
+     */
+    @NonNull
+    public AppSearchBatchResult<AppSearchBlobHandle, ParcelFileDescriptor> getResult() {
+        return mResultParcel.getResult();
+    }
+
+    @Override
+    public void close() {
+        AppSearchBatchResult<AppSearchBlobHandle, ParcelFileDescriptor> batchResult =
+                mResultParcel.getResult();
+        for (ParcelFileDescriptor pfd : batchResult.getSuccesses().values()) {
+            try {
+                pfd.close();
+            } catch (IOException ignored) {
+                // The file may be already removed, just ignoring any checked exceptions.
+            }
+        }
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        OpenBlobForWriteResponseCreator.writeToParcel(this, dest, flags);
+    }
+}
diff --git a/framework/java/external/android/app/appsearch/PackageIdentifier.java b/framework/java/external/android/app/appsearch/PackageIdentifier.java
index 68dde04d..4882b2d4 100644
--- a/framework/java/external/android/app/appsearch/PackageIdentifier.java
+++ b/framework/java/external/android/app/appsearch/PackageIdentifier.java
@@ -64,11 +64,13 @@ public class PackageIdentifier {
         return mPackageIdentifierParcel;
     }
 
+    /** Returns the name for a package. */
     @NonNull
     public String getPackageName() {
         return mPackageIdentifierParcel.getPackageName();
     }
 
+    /** Returns the SHA-256 certificate for a package. */
     @NonNull
     public byte[] getSha256Certificate() {
         return mPackageIdentifierParcel.getSha256Certificate();
diff --git a/framework/java/external/android/app/appsearch/RemoveBlobResponse.java b/framework/java/external/android/app/appsearch/RemoveBlobResponse.java
new file mode 100644
index 00000000..d63c77de
--- /dev/null
+++ b/framework/java/external/android/app/appsearch/RemoveBlobResponse.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package android.app.appsearch;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.app.appsearch.aidl.AppSearchBatchResultParcelV2;
+import android.app.appsearch.safeparcel.AbstractSafeParcelable;
+import android.app.appsearch.safeparcel.SafeParcelable;
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import com.android.appsearch.flags.Flags;
+
+import java.util.Objects;
+
+/**
+ * Results of {@link AppSearchSession#removeBlob}, containing the outcome of the removal of each
+ * handles.
+ *
+ * <p>This class is used to retrieve the result of a batch removal operation on a collection of blob
+ * handles.
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
+@SuppressWarnings("HiddenSuperclass")
+@SafeParcelable.Class(creator = "RemoveBlobResponseCreator")
+public final class RemoveBlobResponse extends AbstractSafeParcelable {
+
+    @NonNull
+    public static final Parcelable.Creator<RemoveBlobResponse> CREATOR =
+            new RemoveBlobResponseCreator();
+
+    @Field(id = 1, getter = "getResponseParcel")
+    private final AppSearchBatchResultParcelV2<AppSearchBlobHandle, Void> mResultParcel;
+
+    /** Creates a {@link RemoveBlobResponse} with given {@link AppSearchBatchResult}. */
+    public RemoveBlobResponse(@NonNull AppSearchBatchResult<AppSearchBlobHandle, Void> result) {
+        this(AppSearchBatchResultParcelV2.fromBlobHandleToVoid(result));
+    }
+
+    @Constructor
+    RemoveBlobResponse(
+            @Param(id = 1) @NonNull
+                    AppSearchBatchResultParcelV2<AppSearchBlobHandle, Void> resultParcel) {
+        mResultParcel = Objects.requireNonNull(resultParcel);
+    }
+
+    /**
+     * Returns the {@link AppSearchBatchResult} object containing the results of the removal
+     * operation for each {@link AppSearchBlobHandle}.
+     *
+     * @return A {@link AppSearchBatchResult} maps {@link AppSearchBlobHandle}s which is a unique
+     *     identifier for a specific blob being removed to the outcome of that commit. If the
+     *     operation was successful, the result for that handle is {@code null}; if there was an
+     *     error, the result contains an {@link AppSearchResult} with details of the failure.
+     */
+    @NonNull
+    public AppSearchBatchResult<AppSearchBlobHandle, Void> getResult() {
+        return mResultParcel.getResult();
+    }
+
+    /**
+     * Retrieves the underlying parcel representation of the batch result.
+     *
+     * @hide
+     */
+    @NonNull
+    public AppSearchBatchResultParcelV2<AppSearchBlobHandle, Void> getResponseParcel() {
+        return mResultParcel;
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        RemoveBlobResponseCreator.writeToParcel(this, dest, flags);
+    }
+}
diff --git a/framework/java/external/android/app/appsearch/SearchResult.java b/framework/java/external/android/app/appsearch/SearchResult.java
index 0e297c5f..22cf2e1a 100644
--- a/framework/java/external/android/app/appsearch/SearchResult.java
+++ b/framework/java/external/android/app/appsearch/SearchResult.java
@@ -23,8 +23,11 @@ import android.app.appsearch.annotation.CanIgnoreReturnValue;
 import android.app.appsearch.safeparcel.AbstractSafeParcelable;
 import android.app.appsearch.safeparcel.GenericDocumentParcel;
 import android.app.appsearch.safeparcel.SafeParcelable;
+import android.app.appsearch.util.BundleUtil;
+import android.os.Bundle;
 import android.os.Parcel;
 import android.os.Parcelable;
+import android.util.ArrayMap;
 
 import com.android.appsearch.flags.Flags;
 import com.android.internal.util.Preconditions;
@@ -32,7 +35,9 @@ import com.android.internal.util.Preconditions;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import java.util.Map;
 import java.util.Objects;
+import java.util.Set;
 
 /**
  * This class represents one of the results obtained from an AppSearch query.
@@ -80,6 +85,20 @@ public final class SearchResult extends AbstractSafeParcelable {
     @Field(id = 7, getter = "getInformationalRankingSignals")
     private final List<Double> mInformationalRankingSignals;
 
+    /**
+     * Holds the map from schema type names to the list of their parent types.
+     *
+     * <p>The map includes entries for the {@link GenericDocument}'s own type and all of the nested
+     * documents' types. Child types are guaranteed to appear before parent types in each list.
+     *
+     * <p>Parent types include transitive parents.
+     *
+     * <p>All schema names in this map are un-prefixed, for both keys and values.
+     */
+    @NonNull
+    @Field(id = 8)
+    final Bundle mParentTypeMap;
+
     /** Cache of the {@link GenericDocument}. Comes from mDocument at first use. */
     @Nullable private GenericDocument mDocumentCached;
 
@@ -95,7 +114,8 @@ public final class SearchResult extends AbstractSafeParcelable {
             @Param(id = 4) @NonNull String databaseName,
             @Param(id = 5) double rankingSignal,
             @Param(id = 6) @NonNull List<SearchResult> joinedResults,
-            @Param(id = 7) @Nullable List<Double> informationalRankingSignals) {
+            @Param(id = 7) @Nullable List<Double> informationalRankingSignals,
+            @Param(id = 8) @Nullable Bundle parentTypeMap) {
         mDocument = Objects.requireNonNull(document);
         mMatchInfos = Objects.requireNonNull(matchInfos);
         mPackageName = Objects.requireNonNull(packageName);
@@ -108,6 +128,11 @@ public final class SearchResult extends AbstractSafeParcelable {
         } else {
             mInformationalRankingSignals = Collections.emptyList();
         }
+        if (parentTypeMap != null) {
+            mParentTypeMap = parentTypeMap;
+        } else {
+            mParentTypeMap = Bundle.EMPTY;
+        }
     }
 
     /**
@@ -210,6 +235,31 @@ public final class SearchResult extends AbstractSafeParcelable {
         return mInformationalRankingSignals;
     }
 
+    /**
+     * Returns the map from schema type names to the list of their parent types.
+     *
+     * <p>The map includes entries for the {@link GenericDocument}'s own type and all of the nested
+     * documents' types. Child types are guaranteed to appear before parent types in each list.
+     *
+     * <p>Parent types include transitive parents.
+     *
+     * <p>Calling this function repeatedly is inefficient. Prefer to retain the Map returned by this
+     * function, rather than calling it multiple times.
+     */
+    @NonNull
+    @FlaggedApi(Flags.FLAG_ENABLE_SEARCH_RESULT_PARENT_TYPES)
+    public Map<String, List<String>> getParentTypeMap() {
+        Set<String> schemaTypes = mParentTypeMap.keySet();
+        Map<String, List<String>> parentTypeMap = new ArrayMap<>(schemaTypes.size());
+        for (String schemaType : schemaTypes) {
+            ArrayList<String> parentTypes = mParentTypeMap.getStringArrayList(schemaType);
+            if (parentTypes != null) {
+                parentTypeMap.put(schemaType, parentTypes);
+            }
+        }
+        return parentTypeMap;
+    }
+
     /**
      * Gets a list of {@link SearchResult} joined from the join operation.
      *
@@ -243,6 +293,7 @@ public final class SearchResult extends AbstractSafeParcelable {
         private GenericDocument mGenericDocument;
         private double mRankingSignal;
         private List<Double> mInformationalRankingSignals = new ArrayList<>();
+        private Bundle mParentTypeMap = new Bundle();
         private List<SearchResult> mJoinedResults = new ArrayList<>();
         private boolean mBuilt = false;
 
@@ -266,6 +317,7 @@ public final class SearchResult extends AbstractSafeParcelable {
             mRankingSignal = searchResult.getRankingSignal();
             mInformationalRankingSignals =
                     new ArrayList<>(searchResult.getInformationalRankingSignals());
+            setParentTypeMap(searchResult.getParentTypeMap());
             List<MatchInfo> matchInfos = searchResult.getMatchInfos();
             for (int i = 0; i < matchInfos.size(); i++) {
                 addMatchInfo(new MatchInfo.Builder(matchInfos.get(i)).build());
@@ -318,6 +370,41 @@ public final class SearchResult extends AbstractSafeParcelable {
             return this;
         }
 
+        /**
+         * Sets the map from schema type names to the list of their parent types.
+         *
+         * <p>The map should include entries for the {@link GenericDocument}'s own type and all of
+         * the nested documents' types.
+         *
+         * <p>Child types must appear before parent types in each list. Otherwise, the
+         * GenericDocument's toDocumentClass method (an AndroidX-only API) may not correctly
+         * identify the most concrete type. This could lead to unintended deserialization into a
+         * more general type instead of a more specific type.
+         *
+         * <p>Parent types should include transitive parents.
+         */
+        @CanIgnoreReturnValue
+        @FlaggedApi(Flags.FLAG_ENABLE_SEARCH_RESULT_PARENT_TYPES)
+        @NonNull
+        public Builder setParentTypeMap(@NonNull Map<String, List<String>> parentTypeMap) {
+            Objects.requireNonNull(parentTypeMap);
+            resetIfBuilt();
+            mParentTypeMap.clear();
+
+            for (Map.Entry<String, List<String>> entry : parentTypeMap.entrySet()) {
+                Objects.requireNonNull(entry.getKey());
+                Objects.requireNonNull(entry.getValue());
+
+                ArrayList<String> parentTypes = new ArrayList<>(entry.getValue().size());
+                for (int i = 0; i < entry.getValue().size(); i++) {
+                    String parentType = entry.getValue().get(i);
+                    parentTypes.add(Objects.requireNonNull(parentType));
+                }
+                mParentTypeMap.putStringArrayList(entry.getKey(), parentTypes);
+            }
+            return this;
+        }
+
         /**
          * Adds a {@link SearchResult} that was joined by the {@link JoinSpec}.
          *
@@ -355,7 +442,8 @@ public final class SearchResult extends AbstractSafeParcelable {
                     mDatabaseName,
                     mRankingSignal,
                     mJoinedResults,
-                    mInformationalRankingSignals);
+                    mInformationalRankingSignals,
+                    mParentTypeMap);
         }
 
         private void resetIfBuilt() {
@@ -363,6 +451,7 @@ public final class SearchResult extends AbstractSafeParcelable {
                 mMatchInfos = new ArrayList<>(mMatchInfos);
                 mJoinedResults = new ArrayList<>(mJoinedResults);
                 mInformationalRankingSignals = new ArrayList<>(mInformationalRankingSignals);
+                mParentTypeMap = BundleUtil.deepCopy(mParentTypeMap);
                 mBuilt = false;
             }
         }
diff --git a/framework/java/external/android/app/appsearch/SearchSpec.java b/framework/java/external/android/app/appsearch/SearchSpec.java
index 359ccc24..5b4108ed 100644
--- a/framework/java/external/android/app/appsearch/SearchSpec.java
+++ b/framework/java/external/android/app/appsearch/SearchSpec.java
@@ -153,6 +153,15 @@ public final class SearchSpec extends AbstractSafeParcelable {
     @Field(id = 23, getter = "getSearchStringParameters")
     private final List<String> mSearchStringParameters;
 
+    /**
+     * Holds the list of document ids to search over.
+     *
+     * <p>If empty, the query will search over all documents.
+     */
+    @NonNull
+    @Field(id = 24, getter = "getFilterDocumentIds")
+    private final List<String> mFilterDocumentIds;
+
     /**
      * Default number of documents per page.
      *
@@ -320,6 +329,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
 
     @IntDef(
             value = {
+                EMBEDDING_SEARCH_METRIC_TYPE_DEFAULT,
                 EMBEDDING_SEARCH_METRIC_TYPE_COSINE,
                 EMBEDDING_SEARCH_METRIC_TYPE_DOT_PRODUCT,
                 EMBEDDING_SEARCH_METRIC_TYPE_EUCLIDEAN,
@@ -327,6 +337,13 @@ public final class SearchSpec extends AbstractSafeParcelable {
     @Retention(RetentionPolicy.SOURCE)
     public @interface EmbeddingSearchMetricType {}
 
+    /**
+     * Use the default metric set in {@link SearchSpec#getDefaultEmbeddingSearchMetricType()} for
+     * embedding search and ranking.
+     */
+    @FlaggedApi(Flags.FLAG_ENABLE_SCHEMA_EMBEDDING_PROPERTY_CONFIG)
+    public static final int EMBEDDING_SEARCH_METRIC_TYPE_DEFAULT = 0;
+
     /** Cosine similarity as metric for embedding search and ranking. */
     @FlaggedApi(Flags.FLAG_ENABLE_SCHEMA_EMBEDDING_PROPERTY_CONFIG)
     public static final int EMBEDDING_SEARCH_METRIC_TYPE_COSINE = 1;
@@ -363,7 +380,8 @@ public final class SearchSpec extends AbstractSafeParcelable {
             @Param(id = 20) @Nullable List<EmbeddingVector> embeddingParameters,
             @Param(id = 21) int defaultEmbeddingSearchMetricType,
             @Param(id = 22) @Nullable List<String> informationalRankingExpressions,
-            @Param(id = 23) @Nullable List<String> searchStringParameters) {
+            @Param(id = 23) @Nullable List<String> searchStringParameters,
+            @Param(id = 24) @Nullable List<String> filterDocumentIds) {
         mTermMatchType = termMatchType;
         mSchemas = Collections.unmodifiableList(Objects.requireNonNull(schemas));
         mNamespaces = Collections.unmodifiableList(Objects.requireNonNull(namespaces));
@@ -399,6 +417,10 @@ public final class SearchSpec extends AbstractSafeParcelable {
                 (searchStringParameters != null)
                         ? Collections.unmodifiableList(searchStringParameters)
                         : Collections.emptyList();
+        mFilterDocumentIds =
+                (filterDocumentIds != null)
+                        ? Collections.unmodifiableList(filterDocumentIds)
+                        : Collections.emptyList();
     }
 
     /** Returns how the query terms should match terms in the index. */
@@ -469,6 +491,17 @@ public final class SearchSpec extends AbstractSafeParcelable {
         return mPackageNames;
     }
 
+    /**
+     * Returns the list of document ids to search over.
+     *
+     * <p>If empty, the query will search over all documents.
+     */
+    @NonNull
+    @FlaggedApi(Flags.FLAG_ENABLE_SEARCH_SPEC_FILTER_DOCUMENT_IDS)
+    public List<String> getFilterDocumentIds() {
+        return mFilterDocumentIds;
+    }
+
     /** Returns the number of results per page in the result set. */
     public int getResultCountPerPage() {
         return mResultCountPerPage;
@@ -627,7 +660,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
     /**
      * Get the maximum number of results to return for each group.
      *
-     * @return the maximum number of results to return for each group or Integer.MAX_VALUE if {@link
+     * @return the maximum number of results to return for each group or 0 if {@link
      *     Builder#setResultGrouping(int, int)} was not called.
      */
     public int getResultGroupingLimit() {
@@ -730,12 +763,25 @@ public final class SearchSpec extends AbstractSafeParcelable {
         return mEnabledFeatures.contains(FeatureConstants.LIST_FILTER_QUERY_LANGUAGE);
     }
 
+    /** Returns whether the ScorablePropertyRanking feature is enabled. */
+    @FlaggedApi(Flags.FLAG_ENABLE_SCORABLE_PROPERTY)
+    public boolean isScorablePropertyRankingEnabled() {
+        return mEnabledFeatures.contains(FeatureConstants.SCHEMA_SCORABLE_PROPERTY_CONFIG);
+    }
+
     /** Returns whether the LIST_FILTER_HAS_PROPERTY_FUNCTION feature is enabled. */
     @FlaggedApi(Flags.FLAG_ENABLE_LIST_FILTER_HAS_PROPERTY_FUNCTION)
     public boolean isListFilterHasPropertyFunctionEnabled() {
         return mEnabledFeatures.contains(FeatureConstants.LIST_FILTER_HAS_PROPERTY_FUNCTION);
     }
 
+    /** Returns whether the LIST_FILTER_MATCH_SCORE_EXPRESSION_FUNCTION feature is enabled. */
+    @FlaggedApi(Flags.FLAG_ENABLE_LIST_FILTER_MATCH_SCORE_EXPRESSION_FUNCTION)
+    public boolean isListFilterMatchScoreExpressionFunctionEnabled() {
+        return mEnabledFeatures.contains(
+                FeatureConstants.LIST_FILTER_MATCH_SCORE_EXPRESSION_FUNCTION);
+    }
+
     /**
      * Get the list of enabled features that the caller is intending to use in this search call.
      *
@@ -764,6 +810,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
         private Bundle mTypePropertyWeights = new Bundle();
         private List<EmbeddingVector> mEmbeddingParameters = new ArrayList<>();
         private List<String> mSearchStringParameters = new ArrayList<>();
+        private List<String> mFilterDocumentIds = new ArrayList<>();
 
         private int mResultCountPerPage = DEFAULT_NUM_PER_PAGE;
         @TermMatch private int mTermMatchType = TERM_MATCH_PREFIX;
@@ -784,10 +831,11 @@ public final class SearchSpec extends AbstractSafeParcelable {
         @Nullable private String mSearchSourceLogTag;
         private boolean mBuilt = false;
 
-        /** Constructs a new builder for {@link SearchSpec} objects. */
+        /** Constructs a new {@link Builder} for {@link SearchSpec} objects. */
         public Builder() {}
 
-        /** @hide */
+        /** Constructs a new {@link Builder} from the given {@link SearchSpec}. */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
         public Builder(@NonNull SearchSpec searchSpec) {
             Objects.requireNonNull(searchSpec);
             mSchemas = new ArrayList<>(searchSpec.getFilterSchemas());
@@ -822,6 +870,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
             mInformationalRankingExpressions =
                     new ArrayList<>(searchSpec.getInformationalRankingExpressions());
             mSearchSourceLogTag = searchSpec.getSearchSourceLogTag();
+            mFilterDocumentIds = new ArrayList<>(searchSpec.getFilterDocumentIds());
         }
 
         /**
@@ -869,6 +918,16 @@ public final class SearchSpec extends AbstractSafeParcelable {
             return this;
         }
 
+        /** Clears all schema type filters. */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        @CanIgnoreReturnValue
+        @NonNull
+        public Builder clearFilterSchemas() {
+            resetIfBuilt();
+            mSchemas.clear();
+            return this;
+        }
+
         /**
          * Adds property paths for the specified type to the property filter of {@link SearchSpec}
          * Entry. Only returns documents that have matches under the specified properties. If
@@ -933,6 +992,16 @@ public final class SearchSpec extends AbstractSafeParcelable {
             return addFilterProperties(schema, propertyPathsArrayList);
         }
 
+        /** Clears the property filters for all schema types. */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        @CanIgnoreReturnValue
+        @NonNull
+        public Builder clearFilterProperties() {
+            resetIfBuilt();
+            mTypePropertyFilters.clear();
+            return this;
+        }
+
         /**
          * Adds a namespace filter to {@link SearchSpec} Entry. Only search for documents that have
          * the specified namespaces.
@@ -962,6 +1031,16 @@ public final class SearchSpec extends AbstractSafeParcelable {
             return this;
         }
 
+        /** Clears all namespace filters. */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        @CanIgnoreReturnValue
+        @NonNull
+        public Builder clearFilterNamespaces() {
+            resetIfBuilt();
+            mNamespaces.clear();
+            return this;
+        }
+
         /**
          * Adds a package name filter to {@link SearchSpec} Entry. Only search for documents that
          * were indexed from the specified packages.
@@ -995,6 +1074,57 @@ public final class SearchSpec extends AbstractSafeParcelable {
             return this;
         }
 
+        /** Clears all package name filters. */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        @CanIgnoreReturnValue
+        @NonNull
+        public Builder clearFilterPackageNames() {
+            resetIfBuilt();
+            mPackageNames.clear();
+            return this;
+        }
+
+        /**
+         * Adds a document id filter to {@link SearchSpec} Entry. Only search for documents that
+         * have the specified document ids.
+         *
+         * <p>If unset, the query will search over all documents.
+         */
+        @CanIgnoreReturnValue
+        @NonNull
+        @FlaggedApi(Flags.FLAG_ENABLE_SEARCH_SPEC_FILTER_DOCUMENT_IDS)
+        public Builder addFilterDocumentIds(@NonNull String... documentIds) {
+            Objects.requireNonNull(documentIds);
+            resetIfBuilt();
+            return addFilterDocumentIds(Arrays.asList(documentIds));
+        }
+
+        /**
+         * Adds a document id filter to {@link SearchSpec} Entry. Only search for documents that
+         * have the specified document ids.
+         *
+         * <p>If unset, the query will search over all documents.
+         */
+        @CanIgnoreReturnValue
+        @NonNull
+        @FlaggedApi(Flags.FLAG_ENABLE_SEARCH_SPEC_FILTER_DOCUMENT_IDS)
+        public Builder addFilterDocumentIds(@NonNull Collection<String> documentIds) {
+            Objects.requireNonNull(documentIds);
+            resetIfBuilt();
+            mFilterDocumentIds.addAll(documentIds);
+            return this;
+        }
+
+        /** Clears the document id filters. */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        @CanIgnoreReturnValue
+        @NonNull
+        public Builder clearFilterDocumentIds() {
+            resetIfBuilt();
+            mFilterDocumentIds.clear();
+            return this;
+        }
+
         /**
          * Sets the number of results per page in the returned object.
          *
@@ -1035,8 +1165,8 @@ public final class SearchSpec extends AbstractSafeParcelable {
          * <p>The ranking expression is a mathematical expression that will be evaluated to a
          * floating-point number of double type representing the score of each document.
          *
-         * <p>Numeric literals, arithmetic operators, mathematical functions, and document-based
-         * functions are supported to build expressions.
+         * <p>Numeric literals, arithmetic operators, mathematical functions, document-based, and
+         * property-value-based functions are supported to build expressions.
          *
          * <p>The following are supported arithmetic operators:
          *
@@ -1121,6 +1251,38 @@ public final class SearchSpec extends AbstractSafeParcelable {
          *       expression.
          * </ul>
          *
+         * <p>Property-value-based functions can be called via the function of
+         * getScorableProperty(schemaType, propertyPath)
+         *
+         * <ul>
+         *   <li>In order to use this function, ScorablePropertyRanking feature must be enabled via
+         *       {@link SearchSpec.Builder#setScorablePropertyRankingEnabled(boolean)}.
+         *   <li>Param 'schemaType' must be a valid AppSearch SchemaType otherwise an error is
+         *       returned.
+         *   <li>Param 'propertyPath' must be valid and scorable otherwise an error is returned. It
+         *       is considered scorable when:
+         *       <ul>
+         *         <li>It is to a property that is set to be enabled for scoring, or that
+         *         <li>It points to a scorable property of nested schema types.
+         *       </ul>
+         *   <li>This function returns a list double values for the matched documents.
+         *       <ul>
+         *         <li>If the matched document's schema is different from 'schemaType', or the
+         *             property under the 'propertyPath' holds no element, an empty list is
+         *             returned.
+         *       </ul>
+         *   <li>Some examples below:
+         *       <p>Suppose that there are two schemas: 'Gmail' and 'Person'. 'Gmail' schema has a
+         *       property 'recipient' with schema type 'Person'. In the advanced ranking expression,
+         *       you can have:
+         *       <ul>
+         *         <li>"sum(getScorableProperty('Gmail', 'viewTimes'))"
+         *         <li>"maxOrDefault(getScorableProperty('Person', 'income'), 0)"
+         *         <li>"sum(getScorableProperty('Gmail', 'recipient.income'))"
+         *         <li>"this.documentScore() + sum(getScorableProperty('Gmail', 'viewTimes'))"
+         *       </ul>
+         * </ul>
+         *
          * <p>Some errors may occur when using advanced ranking.
          *
          * <p>Syntax Error: the expression violates the syntax of the advanced ranking language.
@@ -1215,6 +1377,16 @@ public final class SearchSpec extends AbstractSafeParcelable {
             return this;
         }
 
+        /** Clears all informational ranking expressions. */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        @CanIgnoreReturnValue
+        @NonNull
+        public Builder clearInformationalRankingExpressions() {
+            resetIfBuilt();
+            mInformationalRankingExpressions.clear();
+            return this;
+        }
+
         /**
          * Sets an optional log tag to indicate the source of this search.
          *
@@ -1246,6 +1418,16 @@ public final class SearchSpec extends AbstractSafeParcelable {
             return this;
         }
 
+        /** Clears the log tag that indicates the source of this search. */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        @CanIgnoreReturnValue
+        @NonNull
+        public Builder clearSearchSourceLogTag() {
+            resetIfBuilt();
+            mSearchSourceLogTag = null;
+            return this;
+        }
+
         /**
          * Sets the order of returned search results, the default is {@link #ORDER_DESCENDING},
          * meaning that results with higher scores come first.
@@ -1435,6 +1617,16 @@ public final class SearchSpec extends AbstractSafeParcelable {
             return addProjection(schema, propertyPathsArrayList);
         }
 
+        /** Clears the projections for all schema types. */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        @CanIgnoreReturnValue
+        @NonNull
+        public Builder clearProjections() {
+            resetIfBuilt();
+            mProjectionTypePropertyMasks.clear();
+            return this;
+        }
+
         /**
          * Sets the maximum number of results to return for each group, where groups are defined by
          * grouping type.
@@ -1465,6 +1657,17 @@ public final class SearchSpec extends AbstractSafeParcelable {
             return this;
         }
 
+        /** Clears the result grouping and limit. */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        @CanIgnoreReturnValue
+        @NonNull
+        public Builder clearResultGrouping() {
+            resetIfBuilt();
+            mGroupingTypeFlags = 0;
+            mGroupingLimit = 0;
+            return this;
+        }
+
         /**
          * Sets property weights by schema type and property path.
          *
@@ -1516,6 +1719,16 @@ public final class SearchSpec extends AbstractSafeParcelable {
             return this;
         }
 
+        /** Clears the property weights for all schema types. */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        @CanIgnoreReturnValue
+        @NonNull
+        public Builder clearPropertyWeights() {
+            resetIfBuilt();
+            mTypePropertyWeights.clear();
+            return this;
+        }
+
         /**
          * Specifies which documents to join with, and how to join.
          *
@@ -1532,6 +1745,16 @@ public final class SearchSpec extends AbstractSafeParcelable {
             return this;
         }
 
+        /** Clears the {@link JoinSpec}. */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        @CanIgnoreReturnValue
+        @NonNull
+        public Builder clearJoinSpec() {
+            resetIfBuilt();
+            mJoinSpec = null;
+            return this;
+        }
+
         /**
          * Sets property weights by schema type and property path.
          *
@@ -1608,6 +1831,16 @@ public final class SearchSpec extends AbstractSafeParcelable {
             return this;
         }
 
+        /** Clears the embedding parameters. */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        @CanIgnoreReturnValue
+        @NonNull
+        public Builder clearEmbeddingParameters() {
+            resetIfBuilt();
+            mEmbeddingParameters.clear();
+            return this;
+        }
+
         /**
          * Sets the default embedding metric type used for embedding search (see {@link
          * AppSearchSession#search}) and ranking (see {@link
@@ -1664,6 +1897,19 @@ public final class SearchSpec extends AbstractSafeParcelable {
             return this;
         }
 
+        /**
+         * Clears the list of String parameters that can be referenced in the query through the
+         * "getSearchStringParameter({index})" function.
+         */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        @CanIgnoreReturnValue
+        @NonNull
+        public Builder clearSearchStringParameters() {
+            resetIfBuilt();
+            mSearchStringParameters.clear();
+            return this;
+        }
+
         /**
          * Sets the NUMERIC_SEARCH feature as enabled/disabled according to the enabled parameter.
          *
@@ -1745,6 +1991,40 @@ public final class SearchSpec extends AbstractSafeParcelable {
             return this;
         }
 
+        /**
+         * Sets the LIST_FILTER_MATCH_SCORE_EXPRESSION_FUNCTION feature as enabled/disabled
+         * according to the enabled parameter.
+         *
+         * <p>If not enabled, the use of the "matchScoreExpression" function is disallowed. See
+         * {@link AppSearchSession#search} for more details about the function.
+         *
+         * @param enabled Enables the feature if true, otherwise disables it
+         */
+        @CanIgnoreReturnValue
+        @NonNull
+        @FlaggedApi(Flags.FLAG_ENABLE_LIST_FILTER_MATCH_SCORE_EXPRESSION_FUNCTION)
+        public Builder setListFilterMatchScoreExpressionFunctionEnabled(boolean enabled) {
+            modifyEnabledFeature(
+                    FeatureConstants.LIST_FILTER_MATCH_SCORE_EXPRESSION_FUNCTION, enabled);
+            return this;
+        }
+
+        /**
+         * Sets the ScorablePropertyRanking feature as enabled or disabled.
+         *
+         * <p>If enabled, 'getScorableProperty' function can be used in the advanced ranking
+         * expression. For details, see {@link SearchSpec.Builder#setRankingStrategy(String)}.
+         *
+         * @param enabled Enables the feature if true, otherwise disables it.
+         */
+        @CanIgnoreReturnValue
+        @FlaggedApi(Flags.FLAG_ENABLE_SCORABLE_PROPERTY)
+        @NonNull
+        public Builder setScorablePropertyRankingEnabled(boolean enabled) {
+            modifyEnabledFeature(FeatureConstants.SCHEMA_SCORABLE_PROPERTY_CONFIG, enabled);
+            return this;
+        }
+
         /**
          * Constructs a new {@link SearchSpec} from the contents of this builder.
          *
@@ -1806,7 +2086,8 @@ public final class SearchSpec extends AbstractSafeParcelable {
                     mEmbeddingParameters,
                     mDefaultEmbeddingSearchMetricType,
                     mInformationalRankingExpressions,
-                    mSearchStringParameters);
+                    mSearchStringParameters,
+                    mFilterDocumentIds);
         }
 
         private void resetIfBuilt() {
@@ -1821,6 +2102,7 @@ public final class SearchSpec extends AbstractSafeParcelable {
                 mInformationalRankingExpressions =
                         new ArrayList<>(mInformationalRankingExpressions);
                 mSearchStringParameters = new ArrayList<>(mSearchStringParameters);
+                mFilterDocumentIds = new ArrayList<>(mFilterDocumentIds);
                 mBuilt = false;
             }
         }
diff --git a/framework/java/external/android/app/appsearch/SetBlobVisibilityRequest.java b/framework/java/external/android/app/appsearch/SetBlobVisibilityRequest.java
new file mode 100644
index 00000000..91a50f8e
--- /dev/null
+++ b/framework/java/external/android/app/appsearch/SetBlobVisibilityRequest.java
@@ -0,0 +1,176 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.annotation.SuppressLint;
+import android.app.appsearch.annotation.CanIgnoreReturnValue;
+import android.util.ArrayMap;
+import android.util.ArraySet;
+
+import com.android.appsearch.flags.Flags;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+
+/**
+ * Request to configure the visibility settings of blobs in AppSearch.
+ *
+ * <p>Used with {@link AppSearchSession#setBlobVisibility} to specify visibility and display
+ * properties for blob namespaces. You can control which blob namespaces are displayed on system UI
+ * surfaces and which are accessible based on specific visibility configurations.
+ *
+ * @see AppSearchSession#openBlobForWrite
+ */
+// TODO(b/273591938) linked to GlobalSearchSession when openBlobRead is added there.
+
+@FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
+public class SetBlobVisibilityRequest {
+
+    private final Set<String> mNamespacesNotDisplayedBySystem;
+    private final Map<String, Set<SchemaVisibilityConfig>> mNamespacesVisibleToConfigs;
+
+    SetBlobVisibilityRequest(
+            @NonNull Set<String> namespacesNotDisplayedBySystem,
+            @NonNull Map<String, Set<SchemaVisibilityConfig>> namespacesVisibleToConfigs) {
+        mNamespacesNotDisplayedBySystem = Objects.requireNonNull(namespacesNotDisplayedBySystem);
+        mNamespacesVisibleToConfigs = Objects.requireNonNull(namespacesVisibleToConfigs);
+    }
+
+    /**
+     * Returns all the blob namespaces that are opted out of being displayed and visible on any
+     * system UI surface.
+     */
+    @NonNull
+    public Set<String> getNamespacesNotDisplayedBySystem() {
+        return Collections.unmodifiableSet(mNamespacesNotDisplayedBySystem);
+    }
+
+    /**
+     * Returns a mapping of blob namespaces to the set of {@link SchemaVisibilityConfig}s that have
+     * access to that namespace.
+     *
+     * <p>All conditions in a single {@link SchemaVisibilityConfig} are "AND" relationship. A caller
+     * must match all conditions to have the access. All {@link SchemaVisibilityConfig}s in the set
+     * of a blob namespace are "OR" relationship. A caller could have access if they matches any
+     * {@link SchemaVisibilityConfig} in the set.
+     *
+     * <p>This method provides the set of {@link SchemaVisibilityConfig} for all blob namespaces.
+     *
+     * @see Builder#addNamespaceVisibleToConfig
+     */
+    @NonNull
+    public Map<String, Set<SchemaVisibilityConfig>> getNamespacesVisibleToConfigs() {
+        return Collections.unmodifiableMap(mNamespacesVisibleToConfigs);
+    }
+
+    /** Builder for {@link SetBlobVisibilityRequest} objects. */
+    public static final class Builder {
+
+        private final ArrayMap<String, Set<SchemaVisibilityConfig>> mNamespacesVisibleToConfigs =
+                new ArrayMap<>();
+        private final ArraySet<String> mNamespacesNotDisplayedBySystem = new ArraySet<>();
+
+        /**
+         * Sets whether or not blobs in the specified {@code namespace} will be displayed on any
+         * system UI surface.
+         *
+         * <p>This setting applies to the provided {@code namespace} only, all other {@code
+         * namespace}s that are not included here will be reverted to the default displayed setting.
+         *
+         * <p>If this method is not called, the default behavior allows blobs to be displayed on
+         * system UI surfaces.
+         *
+         * @param namespace The name of the namespace to configure visibility for.
+         * @param displayed If {@code false}, blobs in this namespace will not appear on system UI
+         *     surfaces.
+         */
+        // Merged list available from getBlobNamespacesNotDisplayedBySystem
+        @CanIgnoreReturnValue
+        @SuppressLint("MissingGetterMatchingBuilder")
+        @NonNull
+        public Builder setNamespaceDisplayedBySystem(@NonNull String namespace, boolean displayed) {
+            Objects.requireNonNull(namespace);
+            if (displayed) {
+                mNamespacesNotDisplayedBySystem.remove(namespace);
+            } else {
+                mNamespacesNotDisplayedBySystem.add(namespace);
+            }
+            return this;
+        }
+
+        /**
+         * Specifies that blobs within the given {@code namespace} can be accessed by the caller if
+         * they meet the requirements defined in {@link SchemaVisibilityConfig}.
+         *
+         * <p>The requirements in each {@link SchemaVisibilityConfig} have an "AND" relationship,
+         * meaning that all conditions within a configuration must be met for access. For instance,
+         * the caller may need specific permissions and belong to a specific package.
+         *
+         * <p>Repeated calls to this method can add multiple {@link SchemaVisibilityConfig}s to a
+         * namespace. The caller will have access if they match any of the configurations added, so
+         * the configurations form an "OR" relationship.
+         *
+         * @param namespace The blob namespace to set visibility for.
+         * @param visibilityConfig The config hold specifying visibility settings.
+         */
+        // Merged list available from getNamespacesVisibleToConfigs
+        @CanIgnoreReturnValue
+        @SuppressLint("MissingGetterMatchingBuilder")
+        @NonNull
+        public Builder addNamespaceVisibleToConfig(
+                @NonNull String namespace, @NonNull SchemaVisibilityConfig visibilityConfig) {
+            Objects.requireNonNull(namespace);
+            Objects.requireNonNull(visibilityConfig);
+            Set<SchemaVisibilityConfig> visibleToConfigs =
+                    mNamespacesVisibleToConfigs.get(namespace);
+            if (visibleToConfigs == null) {
+                visibleToConfigs = new ArraySet<>();
+                mNamespacesVisibleToConfigs.put(namespace, visibleToConfigs);
+            }
+            visibleToConfigs.add(visibilityConfig);
+            return this;
+        }
+
+        /**
+         * Clears all visibility configurations for the specified blob {@code namespace}.
+         *
+         * <p>After calling this method, the specified namespace will have no visibility
+         * configurations, meaning it will only be accessible by default rules.
+         *
+         * @param namespace The blob namespace for which visibility config should be cleared.
+         */
+        @CanIgnoreReturnValue
+        @NonNull
+        public Builder clearNamespaceVisibleToConfigs(@NonNull String namespace) {
+            Objects.requireNonNull(namespace);
+            mNamespacesVisibleToConfigs.remove(namespace);
+            return this;
+        }
+
+        /** Builds a new {@link SetBlobVisibilityRequest} object. */
+        @NonNull
+        public SetBlobVisibilityRequest build() {
+            return new SetBlobVisibilityRequest(
+                    new ArraySet<>(mNamespacesNotDisplayedBySystem),
+                    new ArrayMap<>(mNamespacesVisibleToConfigs));
+        }
+    }
+}
diff --git a/framework/java/external/android/app/appsearch/SetSchemaRequest.java b/framework/java/external/android/app/appsearch/SetSchemaRequest.java
index f8c72a4c..d85e55f1 100644
--- a/framework/java/external/android/app/appsearch/SetSchemaRequest.java
+++ b/framework/java/external/android/app/appsearch/SetSchemaRequest.java
@@ -25,8 +25,10 @@ import android.annotation.SuppressLint;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
 import android.util.ArrayMap;
 import android.util.ArraySet;
+
 import com.android.appsearch.flags.Flags;
 import com.android.internal.util.Preconditions;
+
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Arrays;
@@ -380,6 +382,29 @@ public final class SetSchemaRequest {
         private int mVersion = DEFAULT_VERSION;
         private boolean mBuilt = false;
 
+        /** Creates a new {@link SetSchemaRequest.Builder}. */
+        public Builder() {}
+
+        /** Creates a {@link SetSchemaRequest.Builder} from the given {@link SetSchemaRequest}. */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        public Builder(@NonNull SetSchemaRequest request) {
+            mSchemas.addAll(request.mSchemas);
+            mSchemasNotDisplayedBySystem.addAll(request.mSchemasNotDisplayedBySystem);
+            for (Map.Entry<String, Set<PackageIdentifier>> entry :
+                    request.mSchemasVisibleToPackages.entrySet()) {
+                mSchemasVisibleToPackages.put(entry.getKey(), new ArraySet<>(entry.getValue()));
+            }
+            mSchemasVisibleToPermissions = deepCopy(request.mSchemasVisibleToPermissions);
+            mPubliclyVisibleSchemas.putAll(request.mPubliclyVisibleSchemas);
+            for (Map.Entry<String, Set<SchemaVisibilityConfig>> entry :
+                    request.mSchemasVisibleToConfigs.entrySet()) {
+                mSchemaVisibleToConfigs.put(entry.getKey(), new ArraySet<>(entry.getValue()));
+            }
+            mMigrators.putAll(request.mMigrators);
+            mForceOverride = request.mForceOverride;
+            mVersion = request.mVersion;
+        }
+
         /**
          * Adds one or more {@link AppSearchSchema} types to the schema.
          *
@@ -409,6 +434,16 @@ public final class SetSchemaRequest {
             return this;
         }
 
+        /** Clears all {@link AppSearchSchema}s from the list of schemas. */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        @CanIgnoreReturnValue
+        @NonNull
+        public Builder clearSchemas() {
+            resetIfBuilt();
+            mSchemas.clear();
+            return this;
+        }
+
         /**
          * Sets whether or not documents from the provided {@code schemaType} will be displayed and
          * visible on any system UI surface.
@@ -718,6 +753,16 @@ public final class SetSchemaRequest {
             return this;
         }
 
+        /** Clears all {@link Migrator}s. */
+        @FlaggedApi(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+        @CanIgnoreReturnValue
+        @NonNull
+        public Builder clearMigrators() {
+            resetIfBuilt();
+            mMigrators.clear();
+            return this;
+        }
+
         /**
          * Sets whether or not to override the current schema in the {@link AppSearchSession}
          * database.
diff --git a/framework/java/external/android/app/appsearch/StorageInfo.java b/framework/java/external/android/app/appsearch/StorageInfo.java
index d5888e2c..685171f9 100644
--- a/framework/java/external/android/app/appsearch/StorageInfo.java
+++ b/framework/java/external/android/app/appsearch/StorageInfo.java
@@ -44,14 +44,24 @@ public final class StorageInfo extends AbstractSafeParcelable {
     @Field(id = 3, getter = "getAliveNamespacesCount")
     private int mAliveNamespacesCount;
 
+    @Field(id = 4, getter = "getBlobSizeBytes")
+    private long mBlobSizeBytes;
+
+    @Field(id = 5, getter = "getBlobCount")
+    private int mBlobCount;
+
     @Constructor
     StorageInfo(
             @Param(id = 1) long sizeBytes,
             @Param(id = 2) int aliveDocumentsCount,
-            @Param(id = 3) int aliveNamespacesCount) {
+            @Param(id = 3) int aliveNamespacesCount,
+            @Param(id = 4) long blobSizeBytes,
+            @Param(id = 5) int blobCount) {
         mSizeBytes = sizeBytes;
         mAliveDocumentsCount = aliveDocumentsCount;
         mAliveNamespacesCount = aliveNamespacesCount;
+        mBlobSizeBytes = blobSizeBytes;
+        mBlobCount = blobCount;
     }
 
     /** Returns the estimated size of the session's database in bytes. */
@@ -80,11 +90,37 @@ public final class StorageInfo extends AbstractSafeParcelable {
         return mAliveNamespacesCount;
     }
 
+    /**
+     * Returns the total size of all blobs in the session's database in bytes.
+     *
+     * <p>Blobs are binary large objects associated with the documents in the database. Pending
+     * blobs that haven't been committed and orphan blobs that haven't been cleared will be counted
+     * along with alive blobs.
+     */
+    @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
+    public long getBlobSizeBytes() {
+        return mBlobSizeBytes;
+    }
+
+    /**
+     * Returns the total number of blobs in the session's database.
+     *
+     * <p>Blobs are binary large objects associated with the documents in the database. Pending
+     * blobs that haven't been committed and orphan blobs that haven't been cleared will be counted
+     * with alive blobs as well.
+     */
+    @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
+    public int getBlobCount() {
+        return mBlobCount;
+    }
+
     /** Builder for {@link StorageInfo} objects. */
     public static final class Builder {
         private long mSizeBytes;
         private int mAliveDocumentsCount;
         private int mAliveNamespacesCount;
+        private long mBlobSizeBytes;
+        private int mBlobCount;
 
         /** Sets the size in bytes. */
         @CanIgnoreReturnValue
@@ -110,10 +146,33 @@ public final class StorageInfo extends AbstractSafeParcelable {
             return this;
         }
 
+        /** Sets the size of stored blobs in bytes. */
+        @CanIgnoreReturnValue
+        @NonNull
+        @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
+        public StorageInfo.Builder setBlobSizeBytes(long blobSizeBytes) {
+            mBlobSizeBytes = blobSizeBytes;
+            return this;
+        }
+
+        /** Sets the number of stored blobs. */
+        @CanIgnoreReturnValue
+        @NonNull
+        @FlaggedApi(Flags.FLAG_ENABLE_BLOB_STORE)
+        public StorageInfo.Builder setBlobCount(int blobCount) {
+            mBlobCount = blobCount;
+            return this;
+        }
+
         /** Builds a {@link StorageInfo} object. */
         @NonNull
         public StorageInfo build() {
-            return new StorageInfo(mSizeBytes, mAliveDocumentsCount, mAliveNamespacesCount);
+            return new StorageInfo(
+                    mSizeBytes,
+                    mAliveDocumentsCount,
+                    mAliveNamespacesCount,
+                    mBlobSizeBytes,
+                    mBlobCount);
         }
     }
 
diff --git a/framework/java/external/android/app/appsearch/ast/FunctionNode.java b/framework/java/external/android/app/appsearch/ast/FunctionNode.java
new file mode 100644
index 00000000..83d4c9aa
--- /dev/null
+++ b/framework/java/external/android/app/appsearch/ast/FunctionNode.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch.ast;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.annotation.StringDef;
+
+import com.android.appsearch.flags.Flags;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * {@link Node} that represents a function.
+ *
+ * <p>Every function node will have a function name and some arguments represented as fields on the
+ * class extending {@link FunctionNode}.
+ *
+ * <p>FunctionNode should be implemented by a node that implements a specific function.
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_ABSTRACT_SYNTAX_TREES)
+public interface FunctionNode extends Node {
+    /**
+     * Enums representing functions available to use in the query language.
+     *
+     * @hide
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @StringDef({
+        FUNCTION_NAME_GET_SEARCH_STRING_PARAMETER,
+        FUNCTION_NAME_HAS_PROPERTY,
+        FUNCTION_NAME_PROPERTY_DEFINED,
+        FUNCTION_NAME_SEARCH,
+        FUNCTION_NAME_SEMANTIC_SEARCH
+    })
+    @interface FunctionName {}
+
+    /**
+     * Name of the query function represented by {@link
+     * android.app.appsearch.ast.query.GetSearchStringParameterNode}.
+     */
+    String FUNCTION_NAME_GET_SEARCH_STRING_PARAMETER = "getSearchStringParameter";
+
+    /**
+     * Name of the query function represented by {@link
+     * android.app.appsearch.ast.query.HasPropertyNode}.
+     */
+    String FUNCTION_NAME_HAS_PROPERTY = "hasProperty";
+
+    /**
+     * Name of the query function represented by {@link
+     * android.app.appsearch.ast.query.PropertyDefinedNode}.
+     */
+    String FUNCTION_NAME_PROPERTY_DEFINED = "propertyDefined";
+
+    /**
+     * Name of the query function represented by {@link android.app.appsearch.ast.query.SearchNode}.
+     */
+    String FUNCTION_NAME_SEARCH = "search";
+
+    /**
+     * Name of the query function represented by {@link
+     * android.app.appsearch.ast.query.SemanticSearchNode}.
+     */
+    String FUNCTION_NAME_SEMANTIC_SEARCH = "semanticSearch";
+
+    /** Gets the name of the node that extends the {@link FunctionNode}. */
+    @NonNull
+    @FunctionName
+    String getFunctionName();
+}
diff --git a/framework/java/external/android/app/appsearch/ast/NegationNode.java b/framework/java/external/android/app/appsearch/ast/NegationNode.java
new file mode 100644
index 00000000..44278d1a
--- /dev/null
+++ b/framework/java/external/android/app/appsearch/ast/NegationNode.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch.ast;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+
+import com.android.appsearch.flags.Flags;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Objects;
+
+/**
+ * {@link Node} that stores a child node to be logically negated with a negative sign ("-") or
+ * 'NOT'.
+ *
+ * <p>The child node stored in this node will be negated in a query search, which means search will
+ * return all documents that do not match the sub-expression represented by the child node. For
+ * example, if the child node is a {@link TextNode} containing "foo", the resulting node will be
+ * treated as the query `-foo` or alternatively `NOT foo`.
+ *
+ * <p>This node should correspond to `(NOT WS | MINUS) simple` in <a
+ * href="https://google.aip.dev/assets/misc/ebnf-filtering.txt">Google AIP EBNF Filtering
+ * Definition</a>.
+ *
+ * <p>This API may change in response to feedback and additional changes.
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_ABSTRACT_SYNTAX_TREES)
+public final class NegationNode implements Node {
+    private final List<Node> mChildren = new ArrayList<>(1);
+
+    /**
+     * Constructor for a {@link NegationNode} that takes in a child node of any {@link Node} type.
+     *
+     * <p>The resulting NegationNode represents the logical negation of its child node. For example
+     * if the child node represents `foo AND bar` then the resulting NegationNode represents `-(foo
+     * AND bar)` or alternatively `NOT (foo AND bar)`
+     *
+     * <p>This constructor is NOT a copy constructor. Passing in a {@link NegationNode} will make
+     * that {@link NegationNode} a child of another {@link NegationNode}, NOT a new {@link
+     * NegationNode} with the same child as the original {@link NegationNode}.
+     *
+     * @param childNode The {@link Node} representing some query to be logically negated.
+     */
+    public NegationNode(@NonNull Node childNode) {
+        mChildren.add(Objects.requireNonNull(childNode));
+    }
+
+    /**
+     * Retrieve the child node of this Node as a list containing the only child node.
+     *
+     * <p>This method will return the child node as a List of size one containing a {@link Node} but
+     * could be of any type that implements {@link Node}. The caller should check what type the
+     * child node is and cast it to that type accordingly.
+     *
+     * @return A list of size one containing a child {@link Node} representing a query that is being
+     *     logically negated that could be cast to a type that implements {@link Node}
+     */
+    @Override
+    @NonNull
+    public List<Node> getChildren() {
+        return Collections.unmodifiableList(mChildren);
+    }
+
+    /**
+     * Retrieve the child node of this Node.
+     *
+     * <p>This method will return the child node as a {@link Node} but could be of any type that
+     * implements {@link Node}. The caller should check what type the child node is and cast it to
+     * that type accordingly.
+     *
+     * @return The child {@link Node} representing a query that is being logically negated that
+     *     could be cast to a type that implements {@link Node}
+     */
+    @NonNull
+    public Node getChild() {
+        return mChildren.get(0);
+    }
+
+    /**
+     * Set the child node that the {@link NegationNode} holds.
+     *
+     * <p>The node will be treated such that search will return everything not matching the term
+     * contained in the child.
+     *
+     * @param child The child node that {@link NegationNode} will hold.
+     */
+    public void setChild(@NonNull Node child) {
+        mChildren.set(0, Objects.requireNonNull(child));
+    }
+
+    /**
+     * Get the string representation of {@link NegationNode}.
+     *
+     * <p>The string representation of {@link NegationNode} is "NOT" prepended to the string
+     * representation of the child {@link Node}.
+     */
+    @NonNull
+    @Override
+    public String toString() {
+        return "NOT " + getChild();
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        NegationNode that = (NegationNode) o;
+        return Objects.equals(mChildren, that.mChildren);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hashCode(mChildren);
+    }
+}
diff --git a/framework/java/external/android/app/appsearch/ast/Node.java b/framework/java/external/android/app/appsearch/ast/Node.java
new file mode 100644
index 00000000..488c43aa
--- /dev/null
+++ b/framework/java/external/android/app/appsearch/ast/Node.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch.ast;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+
+import com.android.appsearch.flags.Flags;
+
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * This is the basic Abstract Syntax Tree (AST) class. All other classes extend from this class
+ * depending on the specific node.
+ *
+ * <p>This API may change in response to feedback and additional changes.
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_ABSTRACT_SYNTAX_TREES)
+public interface Node {
+    /**
+     * Get a list of the node's child {@link Node}s.
+     *
+     * <p>By default this method will return an empty list representing that the node has no child
+     * nodes.
+     *
+     * <p>If a node type extends this interface and has child nodes, then that class should override
+     * this implementation and return a list of nodes of size equal to the number of child nodes
+     * that node has.
+     *
+     * @return An empty list of {@link Node} representing the child nodes.
+     */
+    @NonNull
+    default List<Node> getChildren() {
+        return Collections.emptyList();
+    }
+}
diff --git a/framework/java/external/android/app/appsearch/ast/TextNode.java b/framework/java/external/android/app/appsearch/ast/TextNode.java
new file mode 100644
index 00000000..badfe4ba
--- /dev/null
+++ b/framework/java/external/android/app/appsearch/ast/TextNode.java
@@ -0,0 +1,271 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch.ast;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+
+import com.android.appsearch.flags.Flags;
+
+import java.util.Objects;
+
+/**
+ * {@link Node} that stores text.
+ *
+ * <p>Text may represent a string or number. For example in the query `hello AND "world peace" -cat
+ * price:49.99`
+ *
+ * <ul>
+ *   <li>hello and cat are strings.
+ *   <li>"world peace" is a verbatim string, i.e. a quoted string that can be represented by setting
+ *       mVerbatim to true. Because it is a verbatim string, it will be treated as a single term
+ *       "world peace" instead of terms "world" and "peace".
+ *   <li>49.99 is a number. {@link TextNode}s may represent integers or doubles and treat numbers as
+ *       terms.
+ *   <li>price is NOT a string but a property path as part of a {@link
+ *       android.app.appsearch.ast.operators.PropertyRestrictNode}.
+ * </ul>
+ *
+ * <p>The node will be segmented and normalized based on the flags set in the Node. For example, if
+ * the node containing the string "foo" has both mPrefix and mVerbatim set to true, then the
+ * resulting tree will be treated as the query `"foo"*` i.e. the prefix of the quoted string "foo".
+ *
+ * <p>{@link TextNode}s is guaranteed to not have child nodes.
+ *
+ * <p>This API may change in response to feedback and additional changes.
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_ABSTRACT_SYNTAX_TREES)
+public final class TextNode implements Node {
+    private String mValue;
+    private boolean mPrefix = false;
+    private boolean mVerbatim = false;
+
+    /**
+     * Public constructor for {@link TextNode} representing text passed into the constructor as a
+     * string.
+     *
+     * <p>By default {@link #mPrefix} and {@link #mVerbatim} are both false. In other words the
+     * {@link TextNode} represents a term that is not the prefix of a potentially longer term that
+     * could be matched against and not a quoted string to be treated as a single term.
+     *
+     * @param value The text value that {@link TextNode} holds.
+     */
+    public TextNode(@NonNull String value) {
+        mValue = Objects.requireNonNull(value);
+    }
+
+    /**
+     * Copy constructor that takes in {@link TextNode}.
+     *
+     * @param original The {@link TextNode} to copy and return another {@link TextNode}.
+     */
+    public TextNode(@NonNull TextNode original) {
+        Objects.requireNonNull(original);
+        mValue = original.mValue;
+        mPrefix = original.mPrefix;
+        mVerbatim = original.mVerbatim;
+    }
+
+    /**
+     * Retrieve the string value that the TextNode holds.
+     *
+     * @return A string representing the text that the TextNode holds.
+     */
+    @NonNull
+    public String getValue() {
+        return mValue;
+    }
+
+    /**
+     * Whether or not a TextNode represents a query term that will match indexed tokens when the
+     * query term is a prefix of the token.
+     *
+     * <p>For example, if the value of the TextNode is "foo" and mPrefix is set to true, then the
+     * TextNode represents the query `foo*`, and will match against tokens like "foo", "foot", and
+     * "football".
+     *
+     * <p>If mPrefix and mVerbatim are both true, then the TextNode represents the prefix of the
+     * quoted string. For example if the value of the TextNode is "foo bar" and both mPrefix and
+     * mVerbatim are set to true, then the TextNode represents the query `"foo bar"*`.
+     *
+     * @return True, if the TextNode represents a query term that will match indexed tokens when the
+     *     query term is a prefix of the token.
+     *     <p>False, if the TextNode represents a query term that will only match exact tokens in
+     *     the index.
+     */
+    public boolean isPrefix() {
+        return mPrefix;
+    }
+
+    /**
+     * Whether or not a TextNode represents a quoted string.
+     *
+     * <p>For example, if the value of the TextNode is "foo bar" and mVerbatim is set to true, then
+     * the TextNode represents the query `"foo bar"`. "foo bar" will be treated as a single token
+     * and match documents that have a property marked as verbatim and exactly contain "foo bar".
+     *
+     * <p>If mVerbatim and mPrefix are both true, then the TextNode represents the prefix of the
+     * quoted string. For example if the value of the TextNode is "foo bar" and both mPrefix and
+     * mVerbatim are set to true, then the TextNode represents the query `"foo bar"*`.
+     *
+     * @return True, if the TextNode represents a quoted string. For example, if the value of
+     *     TextNode is "foo bar", then the query represented is `"foo bar"`. This means "foo bar"
+     *     will be treated as one term, matching documents that have a property marked as verbatim
+     *     and contains exactly "foo bar".
+     *     <p>False, if the TextNode does not represent a quoted string. For example, if the value
+     *     of TextNode is "foo bar", then the query represented is `foo bar`. This means that "foo"
+     *     and "bar" will be treated as separate terms instead of one term and implicitly ANDed,
+     *     matching documents that contain both "foo" and "bar".
+     */
+    public boolean isVerbatim() {
+        return mVerbatim;
+    }
+
+    /**
+     * Set the text value that the {@link TextNode} holds.
+     *
+     * @param value The string that the {@link TextNode} will hold.
+     */
+    public void setValue(@NonNull String value) {
+        mValue = Objects.requireNonNull(value);
+    }
+
+    /**
+     * Set whether or not the {@link TextNode} represents a prefix. If true, the {@link TextNode}
+     * represents a prefix match for {@code value}.
+     *
+     * @param isPrefix Whether or not the {@link TextNode} represents a prefix. If true, it
+     *     represents a query term that will match against indexed tokens when the query term is a
+     *     prefix of token.
+     */
+    public void setPrefix(boolean isPrefix) {
+        mPrefix = isPrefix;
+    }
+
+    /**
+     * Set whether or not the {@link TextNode} represents a quoted string, i.e. verbatim. If true,
+     * the {@link TextNode} represents a quoted string.
+     *
+     * @param isVerbatim Whether or not the {@link TextNode} represents a quoted string. If true, it
+     *     represents a quoted string.
+     */
+    public void setVerbatim(boolean isVerbatim) {
+        mVerbatim = isVerbatim;
+    }
+
+    /**
+     * Get the query string representation of {@link TextNode}.
+     *
+     * <p>If no flags are set, then the string representation is just the value held by {@link
+     * TextNode}. Otherwise the value will be formatted depending on the combination of flags set.
+     *
+     * <p>The string representation of {@link TextNode} maybe different from {@link #mValue} if it
+     * contains operators that need to be escaped for the query string to be treated as a string
+     * rather than a query.
+     */
+    @NonNull
+    @Override
+    public String toString() {
+        StringBuilder queryStringBuilder = new StringBuilder();
+        queryStringBuilder.append('(');
+        if (mVerbatim) {
+            queryStringBuilder.append('\"');
+        }
+        escapeString(queryStringBuilder);
+        if (mVerbatim) {
+            queryStringBuilder.append('\"');
+        }
+        if (mPrefix) {
+            queryStringBuilder.append('*');
+        }
+        queryStringBuilder.append(')');
+        return queryStringBuilder.toString();
+    }
+
+    /**
+     * Escapes {@link #mValue} by adding backslashes to special characters that could be interpreted
+     * by Icing as operators and making everything lower case.
+     */
+    private void escapeString(StringBuilder queryStringBuilder) {
+        for (int i = 0; i < mValue.length(); i++) {
+            char currChar = mValue.charAt(i);
+            if ((!mVerbatim && isSpecialCharacter(currChar)) || currChar == '"') {
+                // If the Text is not verbatim, we need to escape all characters that either are
+                // themselves operators or signify an operator, such as parentheses for functions.
+                // If the Text is verbatim, we only need to escape quotes.
+                queryStringBuilder.append('\\');
+            } else if (!mVerbatim && isLatinLetter(currChar) && Character.isUpperCase(currChar)) {
+                // If not verbatim, escape operators such as NOT, AND, OR.
+                currChar = Character.toLowerCase(currChar);
+            }
+            queryStringBuilder.append(currChar);
+        }
+    }
+
+    /**
+     * Returns whether or not a given character is a special symbol in the query language.
+     *
+     * <p>Special symbols include:
+     *
+     * <ul>
+     *   <li>Logical operators such as negation ("-").
+     *   <li>Numeric search operators such as less than (">").
+     *   <li>Other characters that are tricky to handle such as comma (",").
+     * </ul>
+     */
+    private boolean isSpecialCharacter(char character) {
+        switch (character) {
+            case '-':
+            case '*':
+            case ':':
+            case '"':
+            case '>':
+            case '<':
+            case '=':
+            case '(':
+            case ')':
+            case '\\':
+            case ',':
+            case '.':
+            case '&':
+            case '|':
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    /** Returns whether or not a given character is a letter in the Latin alphabet. */
+    private boolean isLatinLetter(char c) {
+        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        TextNode textNode = (TextNode) o;
+        return mPrefix == textNode.mPrefix
+                && mVerbatim == textNode.mVerbatim
+                && Objects.equals(mValue, textNode.mValue);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(mValue, mPrefix, mVerbatim);
+    }
+}
diff --git a/framework/java/external/android/app/appsearch/ast/operators/AndNode.java b/framework/java/external/android/app/appsearch/ast/operators/AndNode.java
new file mode 100644
index 00000000..62abf5aa
--- /dev/null
+++ b/framework/java/external/android/app/appsearch/ast/operators/AndNode.java
@@ -0,0 +1,161 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch.ast.operators;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.app.appsearch.ast.Node;
+import android.text.TextUtils;
+
+import com.android.appsearch.flags.Flags;
+import com.android.internal.util.Preconditions;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Objects;
+
+/** {@link Node} that represents logical AND of nodes. */
+@FlaggedApi(Flags.FLAG_ENABLE_ABSTRACT_SYNTAX_TREES)
+public final class AndNode implements Node {
+    private List<Node> mChildren;
+
+    /**
+     * Constructor for {@link AndNode} that represents logical AND over all its child nodes.
+     *
+     * @param childNodes The list of {@link Node} of at least size two representing queries to be
+     *     logically ANDed over.
+     */
+    public AndNode(@NonNull List<Node> childNodes) {
+        Objects.requireNonNull(childNodes);
+        Preconditions.checkArgument(
+                childNodes.size() >= 2,
+                /* errorMessage= */ "Number of nodes must be at least two.");
+        mChildren = new ArrayList<>(childNodes);
+    }
+
+    /**
+     * Convenience constructor for {@link AndNode} that represents logical AND over all its child
+     * nodes and takes in a varargs of nodes.
+     *
+     * @param firstChild The first node to be ANDed over, which is required.
+     * @param secondChild The second node to be ANDed over, which is required.
+     * @param additionalChildren Additional nodes to be ANDed over, which are optional.
+     */
+    public AndNode(
+            @NonNull Node firstChild,
+            @NonNull Node secondChild,
+            @NonNull Node... additionalChildren) {
+        ArrayList<Node> childNodes = new ArrayList<>();
+        childNodes.add(Objects.requireNonNull(firstChild));
+        childNodes.add(Objects.requireNonNull(secondChild));
+        childNodes.addAll(List.of(Objects.requireNonNull(additionalChildren)));
+        mChildren = childNodes;
+    }
+
+    /** Get the list of nodes being logically ANDed over by this node. */
+    @Override
+    @NonNull
+    public List<Node> getChildren() {
+        return Collections.unmodifiableList(mChildren);
+    }
+
+    /** Returns the index of the first instance of the node, or -1 if the node does not exist. */
+    public int getIndexOfChild(@NonNull Node node) {
+        Objects.requireNonNull(node);
+        return mChildren.indexOf(node);
+    }
+
+    /**
+     * Set the nodes being logically ANDed over by this node.
+     *
+     * @param childNodes A list of {@link Node} of at least size two representing the nodes to be
+     *     logically ANDed over in this node.
+     */
+    public void setChildren(@NonNull List<Node> childNodes) {
+        Objects.requireNonNull(childNodes);
+        Preconditions.checkArgument(
+                childNodes.size() >= 2,
+                /* errorMessage= */ "Number of nodes must be at least two.");
+        mChildren = new ArrayList<>(childNodes);
+    }
+
+    /**
+     * Add a child node to the end of the current list of child nodes {@link #mChildren}.
+     *
+     * @param childNode A {@link Node} to add to the end of the list of child nodes.
+     */
+    public void addChild(@NonNull Node childNode) {
+        mChildren.add(Objects.requireNonNull(childNode));
+    }
+
+    /**
+     * Replace the child node at the provided index with the provided {@link Node}.
+     *
+     * @param index The index at which to replace the child node in the list of child nodes. Must be
+     *     in range of the size of {@link #mChildren}.
+     * @param childNode The {@link Node} that is replacing the childNode at the provided index.
+     */
+    public void setChild(int index, @NonNull Node childNode) {
+        Preconditions.checkArgumentInRange(
+                index, /* lower= */ 0, /* upper= */ mChildren.size() - 1, /* valueName= */ "Index");
+        mChildren.set(index, Objects.requireNonNull(childNode));
+    }
+
+    /**
+     * Removes the given {@link Node} from the list of child nodes. If multiple copies of the node
+     * exist, then the first {@link Node} that matches the provided {@link Node} will be removed. If
+     * the node does not exist, the list will be unchanged.
+     *
+     * <p>The list of child nodes must contain at least 3 nodes to perform this operation.
+     *
+     * @return {@code true} if the node was removed, {@code false} if the node was not removed i.e.
+     *     the node was not found.
+     */
+    public boolean removeChild(@NonNull Node node) {
+        Preconditions.checkState(
+                mChildren.size() > 2,
+                "List of child nodes must " + "contain at least 3 nodes in order to remove.");
+        Objects.requireNonNull(node);
+        return mChildren.remove(node);
+    }
+
+    /**
+     * Gets the string representation of {@link AndNode}.
+     *
+     * <p>The string representation of {@link AndNode} is the string representation of {@link
+     * AndNode}'s child nodes joined with "AND", all surrounded by parentheses.
+     */
+    @NonNull
+    @Override
+    public String toString() {
+        return "(" + TextUtils.join(" AND ", mChildren) + ")";
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        AndNode andNode = (AndNode) o;
+        return Objects.equals(mChildren, andNode.mChildren);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hashCode(mChildren);
+    }
+}
diff --git a/framework/java/external/android/app/appsearch/ast/operators/ComparatorNode.java b/framework/java/external/android/app/appsearch/ast/operators/ComparatorNode.java
new file mode 100644
index 00000000..e86cb6be
--- /dev/null
+++ b/framework/java/external/android/app/appsearch/ast/operators/ComparatorNode.java
@@ -0,0 +1,181 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch.ast.operators;
+
+import android.annotation.FlaggedApi;
+import android.annotation.IntDef;
+import android.annotation.NonNull;
+import android.app.appsearch.PropertyPath;
+import android.app.appsearch.ast.Node;
+
+import com.android.appsearch.flags.Flags;
+import com.android.internal.util.Preconditions;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.Objects;
+
+/**
+ * {@link Node} that represents a numeric search expression between a property and a numeric value.
+ *
+ * <p>All numeric search expressions are represented by this {@link Node} by passing in a {@link
+ * Comparator} that represent one of the comparator operators available in the query language, a
+ * {@link PropertyPath} representing the property, and a numeric value to compare the property
+ * against.
+ *
+ * <p>This node represents comparators as defined in the <a
+ * href="https://google.aip.dev/assets/misc/ebnf-filtering.txt">Google AIP EBNF Filtering
+ * Definition</a>.
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_ABSTRACT_SYNTAX_TREES)
+public final class ComparatorNode implements Node {
+    /**
+     * Enums representing different comparators for numeric search expressions in the query
+     * language.
+     *
+     * @hide
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef(
+            value = {
+                EQUALS,
+                LESS_THAN,
+                LESS_EQUALS,
+                GREATER_THAN,
+                GREATER_EQUALS,
+            })
+    public @interface Comparator {}
+
+    public static final int EQUALS = 0;
+    public static final int LESS_THAN = 1;
+    public static final int LESS_EQUALS = 2;
+    public static final int GREATER_THAN = 3;
+    public static final int GREATER_EQUALS = 4;
+
+    private static final int MAX_COMPARATOR_VALUE = GREATER_EQUALS;
+
+    private @Comparator int mComparator;
+    private PropertyPath mPropertyPath;
+    private long mValue;
+
+    /**
+     * Construct a {@link Node} representing a numeric search expression between a property and a
+     * numeric value.
+     *
+     * @param comparator An {@code IntDef} representing what comparison is being made.
+     * @param propertyPath A {@link PropertyPath} that is property being compared i.e. the left hand
+     *     side of the comparison.
+     * @param value The numeric value being compared i.e. the right hand side of the comparison.
+     */
+    public ComparatorNode(
+            @Comparator int comparator, @NonNull PropertyPath propertyPath, long value) {
+        Preconditions.checkArgumentInRange(
+                comparator, EQUALS, MAX_COMPARATOR_VALUE, "Comparator intDef");
+        mComparator = comparator;
+        mPropertyPath = Objects.requireNonNull(propertyPath);
+        mValue = value;
+    }
+
+    /** Get the {@code @Comparator} used in the comparison. */
+    @Comparator
+    public int getComparator() {
+        return mComparator;
+    }
+
+    /**
+     * Get the {@code PropertyPath} being compared.
+     *
+     * <p>I.e. left hand side of the comparison represented by this node.
+     */
+    @NonNull
+    public PropertyPath getPropertyPath() {
+        return mPropertyPath;
+    }
+
+    /**
+     * Get the numeric value being compared.
+     *
+     * <p>I.e. the right hand side of the comparison represented by this node.
+     */
+    public long getValue() {
+        return mValue;
+    }
+
+    /** Set the {@code @Comparator} being used to compare the {@code PropertyPath} and value. */
+    public void setComparator(@Comparator int comparator) {
+        Preconditions.checkArgumentInRange(
+                comparator, EQUALS, MAX_COMPARATOR_VALUE, "Comparator intDef");
+        mComparator = comparator;
+    }
+
+    /** Set the {@code PropertyPath} being compared, i.e. the left side of the comparison. */
+    public void setPropertyPath(@NonNull PropertyPath propertyPath) {
+        mPropertyPath = Objects.requireNonNull(propertyPath);
+    }
+
+    /** Set the numeric value being compared, i.e. the right side of the comparison. */
+    public void setValue(long value) {
+        mValue = value;
+    }
+
+    /**
+     * Get the query string representation of {@link ComparatorNode}.
+     *
+     * <p>The string representation is the string representation of the property path joined from
+     * the left to the value being compared with the string representation of the {@link
+     * Comparator}.
+     */
+    @NonNull
+    @Override
+    public String toString() {
+        String comparatorString = "";
+        switch (mComparator) {
+            case ComparatorNode.EQUALS:
+                comparatorString = "==";
+                break;
+            case ComparatorNode.LESS_THAN:
+                comparatorString = "<";
+                break;
+            case ComparatorNode.LESS_EQUALS:
+                comparatorString = "<=";
+                break;
+            case ComparatorNode.GREATER_THAN:
+                comparatorString = ">";
+                break;
+            case ComparatorNode.GREATER_EQUALS:
+                comparatorString = ">=";
+        }
+        // Equivalent in behavior but more efficient than
+        // String.format("(%s %s %s)", mPropertyPath, comparatorString, mValue);
+        return "(" + mPropertyPath + " " + comparatorString + " " + mValue + ")";
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof ComparatorNode)) return false;
+        ComparatorNode that = (ComparatorNode) o;
+        return mComparator == that.mComparator
+                && mValue == that.mValue
+                && Objects.equals(mPropertyPath, that.mPropertyPath);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(mComparator, mPropertyPath, mValue);
+    }
+}
diff --git a/framework/java/external/android/app/appsearch/ast/operators/OrNode.java b/framework/java/external/android/app/appsearch/ast/operators/OrNode.java
new file mode 100644
index 00000000..d823d853
--- /dev/null
+++ b/framework/java/external/android/app/appsearch/ast/operators/OrNode.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch.ast.operators;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.app.appsearch.ast.Node;
+import android.text.TextUtils;
+
+import com.android.appsearch.flags.Flags;
+import com.android.internal.util.Preconditions;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Objects;
+
+/** {@link Node} that represents logical OR of nodes. */
+@FlaggedApi(Flags.FLAG_ENABLE_ABSTRACT_SYNTAX_TREES)
+public final class OrNode implements Node {
+    private List<Node> mChildren;
+
+    /**
+     * Constructor for {@link OrNode} that represents logical OR over all its child nodes.
+     *
+     * @param childNodes The nodes representing queries to be logically ORed over.
+     */
+    public OrNode(@NonNull List<Node> childNodes) {
+        Objects.requireNonNull(childNodes);
+        Preconditions.checkArgument(
+                childNodes.size() >= 2,
+                /* errorMessage= */ "Number of nodes must be at least two.");
+        mChildren = new ArrayList<>(childNodes);
+    }
+
+    /**
+     * Convenience constructor for {@link OrNode} that represents logical OR over all its child
+     * nodes and takes in a varargs of nodes.
+     *
+     * @param firstChild The first node to be ORed over, which is required.
+     * @param secondChild The second node to be ORed over, which is required.
+     * @param additionalChildren Additional nodes to be ORed over, which are optional.
+     */
+    public OrNode(
+            @NonNull Node firstChild,
+            @NonNull Node secondChild,
+            @NonNull Node... additionalChildren) {
+        ArrayList<Node> childNodes = new ArrayList<Node>();
+        childNodes.add(Objects.requireNonNull(firstChild));
+        childNodes.add(Objects.requireNonNull(secondChild));
+        childNodes.addAll(List.of(Objects.requireNonNull(additionalChildren)));
+        mChildren = childNodes;
+    }
+
+    /** Get the list of nodes being logically ORed over by this node. */
+    @Override
+    @NonNull
+    public List<Node> getChildren() {
+        return Collections.unmodifiableList(mChildren);
+    }
+
+    /** Returns the index of the first instance of the node, or -1 if the node does not exist. */
+    public int getIndexOfChild(@NonNull Node node) {
+        Objects.requireNonNull(node);
+        return mChildren.indexOf(node);
+    }
+
+    /**
+     * Set the nodes being logically ORed over by this node.
+     *
+     * @param childNodes A list of {@link Node} representing the nodes to be logically ORed over in
+     *     this node.
+     */
+    public void setChildren(@NonNull List<Node> childNodes) {
+        Objects.requireNonNull(childNodes);
+        Preconditions.checkArgument(
+                childNodes.size() >= 2,
+                /* errorMessage= */ "Number of nodes must be at least two.");
+        mChildren = new ArrayList<>(childNodes);
+    }
+
+    /**
+     * Add a child node to the end of the current list of child nodes {@link #mChildren}.
+     *
+     * @param childNode A {@link Node} to add to the end of the list of child nodes.
+     */
+    public void addChild(@NonNull Node childNode) {
+        mChildren.add(Objects.requireNonNull(childNode));
+    }
+
+    /**
+     * Replace the child node at the provided index with the provided {@link Node}.
+     *
+     * @param index The index at which to replace the child node in the list of child nodes. Must be
+     *     in range of the size of {@link #mChildren}.
+     * @param childNode The {@link Node} that is replacing the childNode at the provided index.
+     */
+    public void setChild(int index, @NonNull Node childNode) {
+        Preconditions.checkArgumentInRange(
+                index, /* lower= */ 0, /* upper= */ mChildren.size() - 1, /* valueName= */ "Index");
+        mChildren.set(index, Objects.requireNonNull(childNode));
+    }
+
+    /**
+     * Removes the given {@link Node} from the list of child nodes. If multiple copies of the node
+     * exist, then the first {@link Node} that matches the provided {@link Node} will be removed. If
+     * the node does not exist, the list will be unchanged.
+     *
+     * <p>The list of child nodes must contain at least 3 nodes to perform this operation.
+     *
+     * @return {@code true} if the node was removed, {@code false} if the node was not removed i.e.
+     *     the node was not found.
+     */
+    public boolean removeChild(@NonNull Node node) {
+        Preconditions.checkState(
+                mChildren.size() > 2,
+                "List of child nodes must " + "contain at least 3 nodes in order to remove.");
+        Objects.requireNonNull(node);
+        return mChildren.remove(node);
+    }
+
+    /**
+     * Gets the string representation of {@link OrNode}.
+     *
+     * <p>The string representation of {@link OrNode} is the string representation of {@link
+     * OrNode}'s child nodes joined with "OR", all surrounded by parentheses.
+     */
+    @NonNull
+    @Override
+    public String toString() {
+        return "(" + TextUtils.join(" OR ", mChildren) + ")";
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        OrNode orNode = (OrNode) o;
+        return Objects.equals(mChildren, orNode.mChildren);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hashCode(mChildren);
+    }
+}
diff --git a/framework/java/external/android/app/appsearch/ast/operators/PropertyRestrictNode.java b/framework/java/external/android/app/appsearch/ast/operators/PropertyRestrictNode.java
new file mode 100644
index 00000000..4924ab04
--- /dev/null
+++ b/framework/java/external/android/app/appsearch/ast/operators/PropertyRestrictNode.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch.ast.operators;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.app.appsearch.PropertyPath;
+import android.app.appsearch.ast.Node;
+
+import com.android.appsearch.flags.Flags;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Objects;
+
+/**
+ * {@link Node} that represents a property restrict.
+ *
+ * <p>A property restrict is an expression in the query language that allows a querier to restrict
+ * the results of a query expression to those contained in a given property path. Written as a query
+ * string, this node should be equivalent to the query `property:child`, where `property` is the
+ * property path to restrict results to and `child` is the query subexpression.
+ *
+ * <p>This node is a comparator that should correspond with HAS in the <a
+ * href="https://google.aip.dev/assets/misc/ebnf-filtering.txt">Google AIP EBNF Filtering
+ * Definition</a>.
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_ABSTRACT_SYNTAX_TREES)
+public final class PropertyRestrictNode implements Node {
+    private PropertyPath mProperty;
+    private final List<Node> mChildren = new ArrayList<>(1);
+
+    /**
+     * Constructor for building a {@link PropertyRestrictNode} that represents a restriction on a
+     * query subexpression by some property i.e. the query `property:subexpression`.
+     *
+     * @param propertyPath The property that will restrict results returned by the subexpression in
+     *     the property restrict
+     * @param childNode The subexpression to be restricted in the property restrict
+     */
+    public PropertyRestrictNode(@NonNull PropertyPath propertyPath, @NonNull Node childNode) {
+        mProperty = Objects.requireNonNull(propertyPath);
+        mChildren.add(Objects.requireNonNull(childNode));
+    }
+
+    /**
+     * Get the property in the property restriction (i.e. the left hand side of the property
+     * restrict sign (":")).
+     */
+    @NonNull
+    public PropertyPath getProperty() {
+        return mProperty;
+    }
+
+    /**
+     * Get the child {@link Node} of {@link PropertyRestrictNode} as a list containing the only
+     * child {@link Node}.
+     */
+    @NonNull
+    @Override
+    public List<Node> getChildren() {
+        return Collections.unmodifiableList(mChildren);
+    }
+
+    /**
+     * Get the subexpression in the property restriction as a {@link Node} (i.e. the right hand side
+     * of the property restrict sign (":")).
+     */
+    @NonNull
+    public Node getChild() {
+        return mChildren.get(0);
+    }
+
+    /**
+     * Set the property in the property restriction (i.e. the left hand side of the property
+     * restrict sign (":")).
+     */
+    public void setProperty(@NonNull PropertyPath propertyPath) {
+        mProperty = Objects.requireNonNull(propertyPath);
+    }
+
+    /**
+     * Set the query subexpression in the property restriction (i.e. the right hand side of the
+     * property restrict sign (":")).
+     */
+    public void setChild(@NonNull Node childNode) {
+        mChildren.set(0, Objects.requireNonNull(childNode));
+    }
+
+    /**
+     * Get the query string representation of {@link PropertyRestrictNode}.
+     *
+     * <p>The string representation is the string representation of the property path joined from
+     * the left to the query sub expression surrounded in parentheses with the property restrict
+     * symbol (":").
+     */
+    @NonNull
+    @Override
+    public String toString() {
+        return "(" + mProperty + ":" + getChild() + ")";
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof PropertyRestrictNode)) return false;
+        PropertyRestrictNode that = (PropertyRestrictNode) o;
+        return Objects.equals(mProperty, that.mProperty)
+                && Objects.equals(mChildren, that.mChildren);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(mProperty, mChildren);
+    }
+}
diff --git a/framework/java/external/android/app/appsearch/ast/query/GetSearchStringParameterNode.java b/framework/java/external/android/app/appsearch/ast/query/GetSearchStringParameterNode.java
new file mode 100644
index 00000000..66d95c13
--- /dev/null
+++ b/framework/java/external/android/app/appsearch/ast/query/GetSearchStringParameterNode.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch.ast.query;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.app.appsearch.SearchSpec;
+import android.app.appsearch.ast.FunctionNode;
+
+import com.android.appsearch.flags.Flags;
+import com.android.internal.util.Preconditions;
+
+/**
+ * {@link FunctionNode} that represents the getSearchStringParameter function.
+ *
+ * <p>The getSearchStringParameter function retrieves the String parameter stored at the index in
+ * the list provided by {@link SearchSpec#getSearchStringParameters()}.
+ *
+ * <p>The String parameter can be used in a query and is treated as plain text. It will be
+ * segmented, normalized, and stripped of punctuation. Operators such as {@code AND} will be treated
+ * as plain text while operators such as negation ("-") and property restricts (":") will be treated
+ * as punctuation and removed.
+ *
+ * <p>So for the query `foo OR getSearchStringParameter(0)`, where getSearchStringParameter(0)
+ * contains "bar AND sender:recipient", the string will be segmented into
+ *
+ * <ul>
+ *   <li>bar
+ *   <li>AND
+ *   <li>sender
+ *   <li>:
+ *   <li>recipient
+ * </ul>
+ *
+ * Then the punctuation will be removed and the remaining tokens ANDed together. This means the
+ * resulting query is equivalent to the query `foo OR (bar AND and AND sender AND recipient)`.
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_ABSTRACT_SYNTAX_TREES)
+public final class GetSearchStringParameterNode implements FunctionNode {
+    private int mSearchStringIndex;
+
+    /**
+     * Constructor for {@link GetSearchStringParameterNode} that takes in the index of the
+     * SearchString parameter provided in {@link SearchSpec#getSearchStringParameters}.
+     */
+    public GetSearchStringParameterNode(int searchStringIndex) {
+        Preconditions.checkArgument(
+                searchStringIndex >= 0, "SearchStringIndex must be non-negative.");
+        mSearchStringIndex = searchStringIndex;
+    }
+
+    /** Returns the name of the function represented by {@link GetSearchStringParameterNode}. */
+    @NonNull
+    @FunctionName
+    @Override
+    public String getFunctionName() {
+        return FUNCTION_NAME_GET_SEARCH_STRING_PARAMETER;
+    }
+
+    /**
+     * Returns the index of the SearchString parameter to be retrieved from {@link
+     * SearchSpec#getSearchStringParameters}.
+     */
+    public int getSearchStringIndex() {
+        return mSearchStringIndex;
+    }
+
+    /**
+     * Sets the index of the SearchString parameter provided in {@link
+     * SearchSpec#getSearchStringParameters} to be represented by {@link
+     * GetSearchStringParameterNode}.
+     */
+    public void setSearchStringIndex(int searchStringIndex) {
+        Preconditions.checkArgument(
+                searchStringIndex >= 0, "SearchStringIndex must be non-negative.");
+        mSearchStringIndex = searchStringIndex;
+    }
+
+    /**
+     * Returns the string representation of {@link GetSearchStringParameterNode}.
+     *
+     * <p>The string representation of {@link GetSearchStringParameterNode} is the function name
+     * followed by the {@code searchStringIndex} surrounded by parentheses. For example, the string
+     * representation of {@code GetSearchStringParameterNode(1)} is `getSearchStringParameter(1)`.
+     */
+    @NonNull
+    @Override
+    public String toString() {
+        return FunctionNode.FUNCTION_NAME_GET_SEARCH_STRING_PARAMETER
+                + "("
+                + mSearchStringIndex
+                + ")";
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        GetSearchStringParameterNode that = (GetSearchStringParameterNode) o;
+        return mSearchStringIndex == that.mSearchStringIndex;
+    }
+
+    @Override
+    public int hashCode() {
+        return Integer.hashCode(mSearchStringIndex);
+    }
+}
diff --git a/framework/java/external/android/app/appsearch/ast/query/HasPropertyNode.java b/framework/java/external/android/app/appsearch/ast/query/HasPropertyNode.java
new file mode 100644
index 00000000..a58f4278
--- /dev/null
+++ b/framework/java/external/android/app/appsearch/ast/query/HasPropertyNode.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch.ast.query;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.app.appsearch.PropertyPath;
+import android.app.appsearch.ast.FunctionNode;
+
+import com.android.appsearch.flags.Flags;
+
+import java.util.Objects;
+
+/**
+ * {@link FunctionNode} representing the `hasProperty` query function.
+ *
+ * <p>The `hasProperty` query function will return all documents that contain the given property and
+ * have values in the given property.
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_ABSTRACT_SYNTAX_TREES)
+public final class HasPropertyNode implements FunctionNode {
+    private PropertyPath mProperty;
+
+    /**
+     * Constructor for a {@link HasPropertyNode} representing the query function `hasProperty`.
+     *
+     * @param property A {@link PropertyPath} representing the property to check whether or not it
+     *     contains a value in the document.
+     */
+    public HasPropertyNode(@NonNull PropertyPath property) {
+        mProperty = Objects.requireNonNull(property);
+    }
+
+    /**
+     * Returns the name of the function represented by {@link HasPropertyNode}, stored in the enum
+     * {@link FunctionNode#FUNCTION_NAME_HAS_PROPERTY}.
+     */
+    @NonNull
+    @Override
+    @FunctionName
+    public String getFunctionName() {
+        return FunctionNode.FUNCTION_NAME_HAS_PROPERTY;
+    }
+
+    /**
+     * Gets the {@link PropertyPath} representing the property being checked for some value in the
+     * document.
+     */
+    @NonNull
+    public PropertyPath getProperty() {
+        return mProperty;
+    }
+
+    /**
+     * Sets the {@link PropertyPath} representing the property being checked for some value in the
+     * document.
+     */
+    public void setProperty(@NonNull PropertyPath property) {
+        mProperty = Objects.requireNonNull(property);
+    }
+
+    /**
+     * Get the string representation of {@link HasPropertyNode}.
+     *
+     * <p>The string representation of {@link HasPropertyNode} is the function name followed by the
+     * property path in quotes.
+     */
+    @NonNull
+    @Override
+    public String toString() {
+        return FunctionNode.FUNCTION_NAME_HAS_PROPERTY + "(\"" + mProperty + "\")";
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        HasPropertyNode that = (HasPropertyNode) o;
+        return Objects.equals(mProperty, that.mProperty);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hashCode(mProperty);
+    }
+}
diff --git a/framework/java/external/android/app/appsearch/ast/query/PropertyDefinedNode.java b/framework/java/external/android/app/appsearch/ast/query/PropertyDefinedNode.java
new file mode 100644
index 00000000..5550a8a1
--- /dev/null
+++ b/framework/java/external/android/app/appsearch/ast/query/PropertyDefinedNode.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch.ast.query;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.app.appsearch.PropertyPath;
+import android.app.appsearch.ast.FunctionNode;
+
+import com.android.appsearch.flags.Flags;
+
+import java.util.Objects;
+
+/**
+ * {@link FunctionNode} representing the `propertyDefined` query function.
+ *
+ * <p>The `propertyDefined` query function will return all documents of types that define the given
+ * property. This will include documents that do not have the property itself, so long as that
+ * property is a part of the document's schema.
+ *
+ * <p>If you need to restrict to documents that have >=1 value(s) populated for that property, see
+ * {@link HasPropertyNode}.
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_ABSTRACT_SYNTAX_TREES)
+public final class PropertyDefinedNode implements FunctionNode {
+    private PropertyPath mProperty;
+
+    /**
+     * Constructor for a {@link PropertyDefinedNode} representing the query function
+     * `propertyDefined` that takes in a {@link PropertyPath}.
+     */
+    public PropertyDefinedNode(@NonNull PropertyPath property) {
+        mProperty = Objects.requireNonNull(property);
+    }
+
+    /** Returns the name of the function represented by {@link PropertyDefinedNode}. */
+    @NonNull
+    @Override
+    @FunctionName
+    public String getFunctionName() {
+        return FUNCTION_NAME_PROPERTY_DEFINED;
+    }
+
+    /**
+     * Returns the {@link PropertyDefinedNode} representing the property being checked for in the
+     * document.
+     */
+    @NonNull
+    public PropertyPath getProperty() {
+        return mProperty;
+    }
+
+    /**
+     * Sets the property being checked for in the document, as represented by {@link
+     * PropertyDefinedNode}.
+     */
+    public void setProperty(@NonNull PropertyPath property) {
+        mProperty = Objects.requireNonNull(property);
+    }
+
+    /**
+     * Get the string representation of {@link PropertyDefinedNode}.
+     *
+     * <p>The string representation of {@link PropertyDefinedNode} is the function name followed by
+     * the property path in quotes surrounded by parentheses.
+     */
+    @NonNull
+    @Override
+    public String toString() {
+        return FUNCTION_NAME_PROPERTY_DEFINED + "(\"" + mProperty + "\")";
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        PropertyDefinedNode that = (PropertyDefinedNode) o;
+        return Objects.equals(mProperty, that.mProperty);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hashCode(mProperty);
+    }
+}
diff --git a/framework/java/external/android/app/appsearch/ast/query/SearchNode.java b/framework/java/external/android/app/appsearch/ast/query/SearchNode.java
new file mode 100644
index 00000000..9b5664eb
--- /dev/null
+++ b/framework/java/external/android/app/appsearch/ast/query/SearchNode.java
@@ -0,0 +1,226 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch.ast.query;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.app.appsearch.PropertyPath;
+import android.app.appsearch.ast.FunctionNode;
+import android.app.appsearch.ast.Node;
+
+import com.android.appsearch.flags.Flags;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Objects;
+
+/**
+ * {@link FunctionNode} that represents the search function.
+ *
+ * <p>The search function is a convenience function that takes a query string and parses it
+ * according to the supported query language, and can optionally take a list of property paths to
+ * serve as property restricts. This means that the query `search("foo bar", createList("subject",
+ * body")` is equivalent to the query `(subject:foo OR body:foo) (subject:bar OR body:bar)`.
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_ABSTRACT_SYNTAX_TREES)
+public final class SearchNode implements FunctionNode {
+    private final List<Node> mChildren = new ArrayList<>(1);
+    private final List<PropertyPath> mProperties;
+
+    /**
+     * Create a {@link SearchNode} representing the query function `search(queryString,
+     * createList(listOfProperties)`.
+     *
+     * @param childNode The query to search for represented as a {@link Node}.
+     * @param properties A list of property paths to restrict results from the query. If the list is
+     *     empty, all results from the query will be returned.
+     */
+    public SearchNode(@NonNull Node childNode, @NonNull List<PropertyPath> properties) {
+        Objects.requireNonNull(childNode);
+        Objects.requireNonNull(properties);
+        for (int i = 0; i < properties.size(); i++) {
+            Objects.requireNonNull(properties.get(i));
+        }
+        mChildren.add(childNode);
+        mProperties = new ArrayList<>(properties);
+    }
+
+    /**
+     * Create a {@link SearchNode} representing the query function `search(queryString)`.
+     *
+     * <p>By default, the query function search will have an empty list of restricts. The search
+     * function will return all results from the query.
+     *
+     * @param childNode The query to search for represented as a {@link Node}.
+     */
+    public SearchNode(@NonNull Node childNode) {
+        this(childNode, Collections.emptyList());
+    }
+
+    /** Returns the name of the function represented by {@link SearchNode}. */
+    @NonNull
+    @Override
+    @FunctionName
+    public String getFunctionName() {
+        return FUNCTION_NAME_SEARCH;
+    }
+
+    /**
+     * Returns the child {@link Node} of {@link SearchNode} as a list containing the only child
+     * {@link Node}.
+     */
+    @NonNull
+    @Override
+    public List<Node> getChildren() {
+        return Collections.unmodifiableList(mChildren);
+    }
+
+    /** Returns the child query searched for in the function. */
+    @NonNull
+    public Node getChild() {
+        return mChildren.get(0);
+    }
+
+    /**
+     * Returns the list of property restricts applied to the query. If the list is empty, there are
+     * no property restricts, which means that `search` will return all results from the query.
+     */
+    @NonNull
+    public List<PropertyPath> getProperties() {
+        return Collections.unmodifiableList(mProperties);
+    }
+
+    /** Sets the query searched for in the function. */
+    public void setChild(@NonNull Node childNode) {
+        mChildren.set(0, Objects.requireNonNull(childNode));
+    }
+
+    /** Sets what property restricts will be applied to the query. */
+    public void setProperties(@NonNull List<PropertyPath> properties) {
+        Objects.requireNonNull(properties);
+        for (int i = 0; i < properties.size(); i++) {
+            Objects.requireNonNull(properties.get(i));
+        }
+        mProperties.clear();
+        mProperties.addAll(properties);
+    }
+
+    /** Add a restrict to the end of the current list of restricts {@link #mProperties}. */
+    public void addProperty(@NonNull PropertyPath propertyPath) {
+        mProperties.add(Objects.requireNonNull(propertyPath));
+    }
+
+    /**
+     * Get the query string representation of {@link SearchNode}.
+     *
+     * <p>If there are no property restricts, then the string representation is the function name
+     * followed by the string representation of the child subquery as a string literal, surrounded
+     * by parentheses. For example the node represented by
+     *
+     * <pre>{@code
+     * TextNode node = new TextNode("foo");
+     * SearchNode searchNode = new SearchNode(node);
+     * }</pre>
+     *
+     * will be represented by the query string `search("(foo)")`.
+     *
+     * <p>If there are property restricts, i.e. {@link #getProperties()} is not empty, then in
+     * addition to the string representation of the child subquery, the property restricts will be
+     * represented as inputs to the {@code createList} function, which itself will be an input. So
+     * for the node represented by
+     *
+     * <pre>{@code
+     * List<PropertyPath> propertyPaths = List.of(new PropertyPath("example.path"),
+     *                                            new PropertyPath("anotherPath"));
+     * TextNode node = new TextNode("foo");
+     * SearchNode searchNode = new SearchNode(node, propertyPaths);
+     * }</pre>
+     *
+     * the query string will be `search("(foo)", createList("example.path", "anotherPath"))`.
+     *
+     * <p>Operators in the query string are supported. As such additional escaping are applied to
+     * ensure that operators stay scoped to the search node. This applies recursively, so if we had
+     * three layers of search i.e. a search function that takes a query containing a nested search,
+     * we would apply three levels of escaping. So for the node represented by
+     *
+     * <pre>{@code
+     * TextNode node = new TextNode("foo");
+     * node.setVerbatim(true);
+     * SearchNode nestedSearchNode = new SearchNode(node);
+     * SearchNode searchNode = new SearchNode(nestedSearchNode);
+     * }</pre>
+     *
+     * the query string of {@code searchNode} will be `search("search(\"(\\\"foo\\\")\")")`
+     */
+    @NonNull
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder(FunctionNode.FUNCTION_NAME_SEARCH);
+        builder.append("(\"");
+        builder.append(escapeQuery(getChild().toString()));
+        builder.append("\"");
+        if (!mProperties.isEmpty()) {
+            builder.append(", createList(");
+            for (int i = 0; i < mProperties.size() - 1; i++) {
+                builder.append("\"");
+                builder.append(mProperties.get(i));
+                builder.append("\", ");
+            }
+            builder.append("\"");
+            builder.append(mProperties.get(mProperties.size() - 1));
+            builder.append("\")");
+        }
+        builder.append(")");
+        return builder.toString();
+    }
+
+    /**
+     * Escapes queries passed into {@link SearchNode}. Queries are assumed to be already escaped,
+     * but need additional escaping if they are an input of {@link SearchNode}.
+     */
+    private String escapeQuery(String strLiteral) {
+        StringBuilder stringBuilder = new StringBuilder();
+        for (int i = 0; i < strLiteral.length(); i++) {
+            // We want to add an escape character if:
+            // 1. There is a quote character ('"')
+            // 2. There is an escape character ('\')
+            // It is ok to add two escape characters for escaped quote characters ('\"') because if
+            // we to unescape we need to unescape both the original escape character and the quote
+            // character.
+            if (strLiteral.charAt(i) == '"' || strLiteral.charAt(i) == '\\') {
+                stringBuilder.append('\\');
+            }
+            stringBuilder.append(strLiteral.charAt(i));
+        }
+        return stringBuilder.toString();
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        SearchNode that = (SearchNode) o;
+        return Objects.equals(mChildren, that.mChildren)
+                && Objects.equals(mProperties, that.mProperties);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(mChildren, mProperties);
+    }
+}
diff --git a/framework/java/external/android/app/appsearch/ast/query/SemanticSearchNode.java b/framework/java/external/android/app/appsearch/ast/query/SemanticSearchNode.java
new file mode 100644
index 00000000..e5f8275b
--- /dev/null
+++ b/framework/java/external/android/app/appsearch/ast/query/SemanticSearchNode.java
@@ -0,0 +1,311 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch.ast.query;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.app.appsearch.SearchSpec;
+import android.app.appsearch.ast.FunctionNode;
+
+import com.android.appsearch.flags.Flags;
+import com.android.internal.util.Preconditions;
+
+import java.util.Objects;
+
+/**
+ * {@link FunctionNode} that represents the semanticSearch function.
+ *
+ * <p>The semanticSearch function matches all documents that have at least one embedding vector with
+ * a matching model signature (see {@link
+ * android.app.appsearch.EmbeddingVector#getModelSignature()}) and a similarity score within the
+ * range specified based on the provided metric.
+ *
+ * <p>This node can be used to build a query that contains the semanticSearch function. For example,
+ * the node {@code SemanticSearchNode(0, -0.5, 0.5, DOT_PRODUCT)} is equivalent to the query
+ * `semanticSearch(getEmbeddingParameter(0), -0.5, 0.5, "DOT_PRODUCT")`.
+ */
+@FlaggedApi(Flags.FLAG_ENABLE_ABSTRACT_SYNTAX_TREES)
+public final class SemanticSearchNode implements FunctionNode {
+    private int mVectorIndex;
+    private float mLowerBound;
+    private float mUpperBound;
+    private @SearchSpec.EmbeddingSearchMetricType int mDistanceMetric;
+
+    /**
+     * Constructor for {@link SemanticSearchNode} representing the semanticSearch function in a
+     * query.
+     *
+     * @param vectorIndex The index of the embedding vector in the list of vectors returned by
+     *     {@link SearchSpec#getEmbeddingParameters()} to use in the search.
+     * @param lowerBound The lower bound on similarity score for a embedding vector such that the
+     *     associated document will be returned.
+     * @param upperBound The upper bound on similarity score for a embedding vector such that the
+     *     associated document will be returned.
+     * @param distanceMetric How distance between embedding vectors will be calculated.
+     */
+    public SemanticSearchNode(
+            int vectorIndex,
+            float lowerBound,
+            float upperBound,
+            @SearchSpec.EmbeddingSearchMetricType int distanceMetric) {
+        Preconditions.checkArgument(vectorIndex >= 0, "Vector index must be non-negative.");
+        Preconditions.checkArgument(
+                lowerBound <= upperBound,
+                "Provided lower bound must be less than or equal to"
+                        + " the provided upper bound.");
+        Preconditions.checkArgumentInRange(
+                distanceMetric,
+                SearchSpec.EMBEDDING_SEARCH_METRIC_TYPE_DEFAULT,
+                SearchSpec.EMBEDDING_SEARCH_METRIC_TYPE_EUCLIDEAN,
+                "Embedding search metric type");
+        mVectorIndex = vectorIndex;
+        mLowerBound = lowerBound;
+        mUpperBound = upperBound;
+        mDistanceMetric = distanceMetric;
+    }
+
+    /**
+     * Constructor for {@link SemanticSearchNode} representing the semanticSearch function in a
+     * query.
+     *
+     * <p>By default:
+     *
+     * <ul>
+     *   <li>The default set by the user and returned by {@link
+     *       SearchSpec#getDefaultEmbeddingSearchMetricType()} will be used to determine similarity
+     *       between embedding vectors. If no default is set, cosine similarity will be used.
+     * </ul>
+     *
+     * <p>See {@link #SemanticSearchNode(int, float, float, int)} for an explanation of the
+     * parameters.
+     */
+    public SemanticSearchNode(int vectorIndex, float lowerBound, float upperBound) {
+        this(vectorIndex, lowerBound, upperBound, SearchSpec.EMBEDDING_SEARCH_METRIC_TYPE_DEFAULT);
+    }
+
+    /**
+     * Constructor for {@link SemanticSearchNode} representing the semanticSearch function in a
+     * query.
+     *
+     * <p>By default:
+     *
+     * <ul>
+     *   <li>The default set by the user and returned by {@link
+     *       SearchSpec#getDefaultEmbeddingSearchMetricType()} will be used to determine similarity
+     *       between embedding vectors. If no default is set, cosine similarity will be used.
+     *   <li>The upper bound on similarity scores for an embedding vector such that the associated
+     *       document will be returned is positive infinity.
+     * </ul>
+     *
+     * <p>See {@link #SemanticSearchNode(int, float, float, int)} for an explanation of the
+     * parameters.
+     */
+    public SemanticSearchNode(int vectorIndex, float lowerBound) {
+        this(vectorIndex, lowerBound, Float.POSITIVE_INFINITY);
+    }
+
+    /**
+     * Constructor for {@link SemanticSearchNode} representing the semanticSearch function in a
+     * query.
+     *
+     * <p>By default:
+     *
+     * <ul>
+     *   <li>The default set by the user and returned by {@link
+     *       SearchSpec#getDefaultEmbeddingSearchMetricType()} will be used to determine similarity
+     *       between embedding vectors. If no default is set, cosine similarity will be used.
+     *   <li>The upper bound on similarity scores for an embedding vector such that the associated
+     *       document will be returned is positive infinity.
+     *   <li>The lower bound on similarity scores for an embedding vector such that the associated
+     *       document will be returned is negative infinity.
+     * </ul>
+     *
+     * <p>See {@link #SemanticSearchNode(int, float, float, int)} for an explanation of the
+     * parameters.
+     */
+    public SemanticSearchNode(int vectorIndex) {
+        this(vectorIndex, Float.NEGATIVE_INFINITY);
+    }
+
+    /** Returns the name of the function represented by {@link SemanticSearchNode}. */
+    @NonNull
+    @Override
+    @FunctionName
+    public String getFunctionName() {
+        return FUNCTION_NAME_SEMANTIC_SEARCH;
+    }
+
+    /** Returns the index of the embedding vector used in semanticSearch. */
+    public int getVectorIndex() {
+        return mVectorIndex;
+    }
+
+    /** Returns the lower bound of the range of values similarity scores must fall in. */
+    public float getLowerBound() {
+        return mLowerBound;
+    }
+
+    /** Returns the upper bound of the range of values similarity scores must fall in. */
+    public float getUpperBound() {
+        return mUpperBound;
+    }
+
+    /** Returns the distance metric used to calculated similarity between embedding vectors. */
+    @SearchSpec.EmbeddingSearchMetricType
+    public int getDistanceMetric() {
+        return mDistanceMetric;
+    }
+
+    /** Sets the index of the embedding vector that semanticSearch will use. */
+    public void setVectorIndex(int vectorIndex) {
+        Preconditions.checkArgument(vectorIndex >= 0, "Vector Index must be non-negative.");
+        mVectorIndex = vectorIndex;
+    }
+
+    /**
+     * Sets the bounds of the range of values that semanticSearch will search against.
+     *
+     * @param lowerBound The lower bound of the range of values.
+     * @param upperBound The upper bound of the range of values.
+     */
+    public void setBounds(float lowerBound, float upperBound) {
+        Preconditions.checkArgument(
+                lowerBound <= upperBound,
+                "Provided lower bound must be less than or equal to" + " the provided upper bound");
+        mLowerBound = lowerBound;
+        mUpperBound = upperBound;
+    }
+
+    /**
+     * Sets how similarity is calculated between embedding vectors.
+     *
+     * @param distanceMetric How similarity is calculated between embedding vectors.
+     */
+    public void setDistanceMetric(@SearchSpec.EmbeddingSearchMetricType int distanceMetric) {
+        Preconditions.checkArgumentInRange(
+                distanceMetric,
+                SearchSpec.EMBEDDING_SEARCH_METRIC_TYPE_DEFAULT,
+                SearchSpec.EMBEDDING_SEARCH_METRIC_TYPE_EUCLIDEAN,
+                "Embedding search metric type");
+        mDistanceMetric = distanceMetric;
+    }
+
+    /**
+     * Get the query string representation of {@link SemanticSearchNode}.
+     *
+     * <p>The query string representation will be the function name, followed by the fields of
+     * {@link SemanticSearchNode} as arguments, surrounded by parentheses, but formatted in the
+     * following way:
+     *
+     * <ul>
+     *   <li>The vector index will appear as an argument to the function `getEmbeddingParameter`.
+     *   <li>The lower bound and upper bound will appear unchanged.
+     *   <li>The distance metric will be mapped to its corresponding string literal representation.
+     *       For example, if the distance metric is 1, then the corresponding string literal would
+     *       be {@code "COSINE"}.
+     * </ul>
+     *
+     * For example, the node {@code SemanticSearchNode(0, -1.5f, 2,
+     * SearchSpec.EMBEDDING_SEARCH_METRIC_TYPE_COSINE)} will look like
+     * `semanticSearch(getEmbeddingParameter(0), -1.5, 2, "COSINE")`
+     *
+     * <p>If possible, default parameters will be left out of the query string. For example the node
+     * {@code SemanticSearchNode(0)} will look like `semanticSearch(getEmbeddingParameter(0))`.
+     * However if some defaults are set and unset, the defaults will be included in the query
+     * string. For example, if the user does something like this:
+     *
+     * <pre>{@code
+     * SemanticSearchNode semanticSearchNode = new SemanticSearchNode(0, -1, 1);
+     * semanticSearchNode.setBounds(Float.NEGATIVE_INFINITY, 1);
+     * }</pre>
+     *
+     * Then the query string will look like `semanticSearch(getEmbeddingParameter(0),
+     * -Float.MAX_VALUE, 1)` where {@code Float.MAX_VALUE} is the max value of float.
+     */
+    @NonNull
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder(FunctionNode.FUNCTION_NAME_SEMANTIC_SEARCH);
+        builder.append("(getEmbeddingParameter(");
+        builder.append(mVectorIndex);
+        builder.append(")");
+        if (mDistanceMetric != SearchSpec.EMBEDDING_SEARCH_METRIC_TYPE_DEFAULT) {
+            // String will look like
+            // semanticSearch(vectorIndex, lowerBound, upperBound, distanceMetric)
+            formatBound(builder, mLowerBound);
+            formatBound(builder, mUpperBound);
+            builder.append(", ");
+            builder.append(getEmbeddingMetricString());
+        } else if (mUpperBound != Float.POSITIVE_INFINITY) {
+            // String will look like semanticSearch(vectorIndex, lowerBound, upperBound)
+            formatBound(builder, mLowerBound);
+            formatBound(builder, mUpperBound);
+        } else if (mLowerBound != Float.NEGATIVE_INFINITY) {
+            // String will look like semanticSearch(vectorIndex, lowerBound)
+            formatBound(builder, mLowerBound);
+        }
+        builder.append(")");
+        return builder.toString();
+    }
+
+    /**
+     * Formats the bounds for semantic search query strings. If the bound is finite, no formatting
+     * is done. If the bound is infinite, the max value of float will be returned.
+     */
+    private void formatBound(StringBuilder builder, float bound) {
+        builder.append(", ");
+        if (Float.isFinite(bound)) {
+            builder.append(bound);
+        } else if (bound == Float.NEGATIVE_INFINITY) {
+            builder.append(-Float.MAX_VALUE);
+        } else {
+            builder.append(Float.MAX_VALUE);
+        }
+    }
+
+    /**
+     * Returns the name of the embedding metric that the {@link SemanticSearchNode} is using to
+     * calculate similarity.
+     */
+    private String getEmbeddingMetricString() {
+        switch (mDistanceMetric) {
+            case SearchSpec.EMBEDDING_SEARCH_METRIC_TYPE_COSINE:
+                return "\"COSINE\"";
+            case SearchSpec.EMBEDDING_SEARCH_METRIC_TYPE_DOT_PRODUCT:
+                return "\"DOT_PRODUCT\"";
+            case SearchSpec.EMBEDDING_SEARCH_METRIC_TYPE_EUCLIDEAN:
+                return "\"EUCLIDEAN\"";
+        }
+        throw new IllegalStateException("Invalid Metric Type");
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        SemanticSearchNode that = (SemanticSearchNode) o;
+        return mVectorIndex == that.mVectorIndex
+                && Float.compare(mLowerBound, that.mLowerBound) == 0
+                && Float.compare(mUpperBound, that.mUpperBound) == 0
+                && mDistanceMetric == that.mDistanceMetric;
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(mVectorIndex, mLowerBound, mUpperBound, mDistanceMetric);
+    }
+}
diff --git a/framework/java/external/android/app/appsearch/safeparcel/GenericDocumentParcel.java b/framework/java/external/android/app/appsearch/safeparcel/GenericDocumentParcel.java
index c77aa96b..8656e9e5 100644
--- a/framework/java/external/android/app/appsearch/safeparcel/GenericDocumentParcel.java
+++ b/framework/java/external/android/app/appsearch/safeparcel/GenericDocumentParcel.java
@@ -20,6 +20,7 @@ import android.annotation.CurrentTimeMillisLong;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.SuppressLint;
+import android.app.appsearch.AppSearchBlobHandle;
 import android.app.appsearch.AppSearchSchema;
 import android.app.appsearch.AppSearchSession;
 import android.app.appsearch.EmbeddingVector;
@@ -430,9 +431,12 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
          */
         @CanIgnoreReturnValue
         @NonNull
-        public Builder setParentTypes(@NonNull List<String> parentTypes) {
-            Objects.requireNonNull(parentTypes);
-            mParentTypes = new ArrayList<>(parentTypes);
+        public Builder setParentTypes(@Nullable List<String> parentTypes) {
+            if (parentTypes == null) {
+                mParentTypes = null;
+            } else {
+                mParentTypes = new ArrayList<>(parentTypes);
+            }
             return this;
         }
 
@@ -451,7 +455,7 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
             return this;
         }
 
-        /** puts an array of {@link String} in property map. */
+        /** Puts an array of {@link String} in the property map. */
         @CanIgnoreReturnValue
         @NonNull
         public Builder putInPropertyMap(@NonNull String name, @NonNull String[] values)
@@ -461,7 +465,7 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
             return this;
         }
 
-        /** puts an array of boolean in property map. */
+        /** Puts an array of boolean in the property map. */
         @CanIgnoreReturnValue
         @NonNull
         public Builder putInPropertyMap(@NonNull String name, @NonNull boolean[] values) {
@@ -470,7 +474,7 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
             return this;
         }
 
-        /** puts an array of double in property map. */
+        /** Puts an array of double in the property map. */
         @CanIgnoreReturnValue
         @NonNull
         public Builder putInPropertyMap(@NonNull String name, @NonNull double[] values) {
@@ -479,7 +483,7 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
             return this;
         }
 
-        /** puts an array of long in property map. */
+        /** Puts an array of long in the property map. */
         @CanIgnoreReturnValue
         @NonNull
         public Builder putInPropertyMap(@NonNull String name, @NonNull long[] values) {
@@ -495,7 +499,7 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
             return this;
         }
 
-        /** puts an array of {@link GenericDocumentParcel} in property map. */
+        /** Puts an array of {@link GenericDocumentParcel} in the property map. */
         @CanIgnoreReturnValue
         @NonNull
         public Builder putInPropertyMap(
@@ -505,7 +509,7 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
             return this;
         }
 
-        /** puts an array of {@link EmbeddingVector} in property map. */
+        /** Puts an array of {@link EmbeddingVector} in the property map. */
         @CanIgnoreReturnValue
         @NonNull
         public Builder putInPropertyMap(@NonNull String name, @NonNull EmbeddingVector[] values) {
@@ -514,7 +518,18 @@ public final class GenericDocumentParcel extends AbstractSafeParcelable implemen
             return this;
         }
 
-        /** Directly puts a {@link PropertyParcel} in property map. */
+        /** Puts an array of {@link AppSearchBlobHandle} in the property map. */
+        @CanIgnoreReturnValue
+        @NonNull
+        public Builder putInPropertyMap(
+                @NonNull String name, @NonNull AppSearchBlobHandle[] values) {
+            Objects.requireNonNull(values);
+            putInPropertyMap(
+                    name, new PropertyParcel.Builder(name).setBlobHandleValues(values).build());
+            return this;
+        }
+
+        /** Directly puts a {@link PropertyParcel} in the property map. */
         @CanIgnoreReturnValue
         @NonNull
         public Builder putInPropertyMap(@NonNull String name, @NonNull PropertyParcel value) {
diff --git a/framework/java/external/android/app/appsearch/safeparcel/PropertyConfigParcel.java b/framework/java/external/android/app/appsearch/safeparcel/PropertyConfigParcel.java
index 128010c0..719d5973 100644
--- a/framework/java/external/android/app/appsearch/safeparcel/PropertyConfigParcel.java
+++ b/framework/java/external/android/app/appsearch/safeparcel/PropertyConfigParcel.java
@@ -18,9 +18,11 @@ package android.app.appsearch.safeparcel;
 
 import android.annotation.NonNull;
 import android.annotation.Nullable;
+import android.app.appsearch.AppSearchBlobHandle;
 import android.app.appsearch.AppSearchSchema;
 import android.app.appsearch.AppSearchSchema.PropertyConfig.Cardinality;
 import android.app.appsearch.AppSearchSchema.PropertyConfig.DataType;
+import android.app.appsearch.AppSearchSchema.StringPropertyConfig.DeletePropagationType;
 import android.app.appsearch.AppSearchSchema.StringPropertyConfig.JoinableValueType;
 import android.app.appsearch.AppSearchSchema.StringPropertyConfig.TokenizerType;
 import android.os.Parcel;
@@ -82,6 +84,9 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
     @Field(id = 10, getter = "getEmbeddingIndexingConfigParcel")
     private final EmbeddingIndexingConfigParcel mEmbeddingIndexingConfigParcel;
 
+    @Field(id = 11, getter = "isScoringEnabled")
+    private final boolean mScoringEnabled;
+
     @Nullable private Integer mHashCode;
 
     /** Constructor for {@link PropertyConfigParcel}. */
@@ -96,7 +101,8 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
             @Param(id = 7) @Nullable IntegerIndexingConfigParcel integerIndexingConfigParcel,
             @Param(id = 8) @Nullable JoinableConfigParcel joinableConfigParcel,
             @Param(id = 9) @NonNull String description,
-            @Param(id = 10) @Nullable EmbeddingIndexingConfigParcel embeddingIndexingConfigParcel) {
+            @Param(id = 10) @Nullable EmbeddingIndexingConfigParcel embeddingIndexingConfigParcel,
+            @Param(id = 11) boolean scoringEnabled) {
         mName = Objects.requireNonNull(name);
         mDataType = dataType;
         mCardinality = cardinality;
@@ -107,6 +113,7 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
         mJoinableConfigParcel = joinableConfigParcel;
         mDescription = Objects.requireNonNull(description);
         mEmbeddingIndexingConfigParcel = embeddingIndexingConfigParcel;
+        mScoringEnabled = scoringEnabled;
     }
 
     /** Creates a {@link PropertyConfigParcel} for String. */
@@ -127,7 +134,8 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
                 /* integerIndexingConfigParcel= */ null,
                 Objects.requireNonNull(joinableConfigParcel),
                 Objects.requireNonNull(description),
-                /* embeddingIndexingConfigParcel= */ null);
+                /* embeddingIndexingConfigParcel= */ null,
+                /* scoringEnabled= */ false);
     }
 
     /** Creates a {@link PropertyConfigParcel} for Long. */
@@ -136,7 +144,8 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
             @NonNull String propertyName,
             @NonNull String description,
             @Cardinality int cardinality,
-            @AppSearchSchema.LongPropertyConfig.IndexingType int indexingType) {
+            @AppSearchSchema.LongPropertyConfig.IndexingType int indexingType,
+            boolean scoringEnabled) {
         return new PropertyConfigParcel(
                 Objects.requireNonNull(propertyName),
                 AppSearchSchema.PropertyConfig.DATA_TYPE_LONG,
@@ -147,7 +156,8 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
                 new IntegerIndexingConfigParcel(indexingType),
                 /* joinableConfigParcel= */ null,
                 Objects.requireNonNull(description),
-                /* embeddingIndexingConfigParcel= */ null);
+                /* embeddingIndexingConfigParcel= */ null,
+                scoringEnabled);
     }
 
     /** Creates a {@link PropertyConfigParcel} for Double. */
@@ -155,7 +165,8 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
     public static PropertyConfigParcel createForDouble(
             @NonNull String propertyName,
             @NonNull String description,
-            @Cardinality int cardinality) {
+            @Cardinality int cardinality,
+            boolean scoringEnabled) {
         return new PropertyConfigParcel(
                 Objects.requireNonNull(propertyName),
                 AppSearchSchema.PropertyConfig.DATA_TYPE_DOUBLE,
@@ -166,7 +177,8 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
                 /* integerIndexingConfigParcel= */ null,
                 /* joinableConfigParcel= */ null,
                 Objects.requireNonNull(description),
-                /* embeddingIndexingConfigParcel= */ null);
+                /* embeddingIndexingConfigParcel= */ null,
+                scoringEnabled);
     }
 
     /** Creates a {@link PropertyConfigParcel} for Boolean. */
@@ -174,7 +186,8 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
     public static PropertyConfigParcel createForBoolean(
             @NonNull String propertyName,
             @NonNull String description,
-            @Cardinality int cardinality) {
+            @Cardinality int cardinality,
+            boolean scoringEnabled) {
         return new PropertyConfigParcel(
                 Objects.requireNonNull(propertyName),
                 AppSearchSchema.PropertyConfig.DATA_TYPE_BOOLEAN,
@@ -185,7 +198,8 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
                 /* integerIndexingConfigParcel= */ null,
                 /* joinableConfigParcel= */ null,
                 Objects.requireNonNull(description),
-                /* embeddingIndexingConfigParcel= */ null);
+                /* embeddingIndexingConfigParcel= */ null,
+                scoringEnabled);
     }
 
     /** Creates a {@link PropertyConfigParcel} for Bytes. */
@@ -204,7 +218,8 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
                 /* integerIndexingConfigParcel= */ null,
                 /* joinableConfigParcel= */ null,
                 Objects.requireNonNull(description),
-                /* embeddingIndexingConfigParcel= */ null);
+                /* embeddingIndexingConfigParcel= */ null,
+                /* scoringEnabled= */ false);
     }
 
     /** Creates a {@link PropertyConfigParcel} for Document. */
@@ -225,7 +240,8 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
                 /* integerIndexingConfigParcel= */ null,
                 /* joinableConfigParcel= */ null,
                 Objects.requireNonNull(description),
-                /* embeddingIndexingConfigParcel= */ null);
+                /* embeddingIndexingConfigParcel= */ null,
+                /* scoringEnabled= */ false);
     }
 
     /** Creates a {@link PropertyConfigParcel} for Embedding. */
@@ -234,7 +250,8 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
             @NonNull String propertyName,
             @NonNull String description,
             @Cardinality int cardinality,
-            @AppSearchSchema.EmbeddingPropertyConfig.IndexingType int indexingType) {
+            @AppSearchSchema.EmbeddingPropertyConfig.IndexingType int indexingType,
+            @AppSearchSchema.EmbeddingPropertyConfig.QuantizationType int quantizationType) {
         return new PropertyConfigParcel(
                 Objects.requireNonNull(propertyName),
                 AppSearchSchema.PropertyConfig.DATA_TYPE_EMBEDDING,
@@ -245,7 +262,28 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
                 /* integerIndexingConfigParcel= */ null,
                 /* joinableConfigParcel= */ null,
                 Objects.requireNonNull(description),
-                new EmbeddingIndexingConfigParcel(indexingType));
+                new EmbeddingIndexingConfigParcel(indexingType, quantizationType),
+                /* scoringEnabled= */ false);
+    }
+
+    /** Creates a {@link PropertyConfigParcel} for {@link AppSearchBlobHandle}. */
+    @NonNull
+    public static PropertyConfigParcel createForBlobHandle(
+            @NonNull String propertyName,
+            @NonNull String description,
+            @Cardinality int cardinality) {
+        return new PropertyConfigParcel(
+                Objects.requireNonNull(propertyName),
+                AppSearchSchema.PropertyConfig.DATA_TYPE_BLOB_HANDLE,
+                cardinality,
+                /* schemaType= */ null,
+                /* stringIndexingConfigParcel= */ null,
+                /* documentIndexingConfigParcel= */ null,
+                /* integerIndexingConfigParcel= */ null,
+                /* joinableConfigParcel= */ null,
+                Objects.requireNonNull(description),
+                /* embeddingIndexingConfigParcel= */ null,
+                /* scoringEnabled= */ false);
     }
 
     /** Gets name for the property. */
@@ -308,6 +346,11 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
         return mEmbeddingIndexingConfigParcel;
     }
 
+    /** Gets ScorableType for the property. */
+    public boolean isScoringEnabled() {
+        return mScoringEnabled;
+    }
+
     @Override
     public void writeToParcel(@NonNull Parcel dest, int flags) {
         PropertyConfigParcelCreator.writeToParcel(this, dest, flags);
@@ -336,7 +379,8 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
                 && Objects.equals(mJoinableConfigParcel, otherProperty.mJoinableConfigParcel)
                 && Objects.equals(
                         mEmbeddingIndexingConfigParcel,
-                        otherProperty.mEmbeddingIndexingConfigParcel);
+                        otherProperty.mEmbeddingIndexingConfigParcel)
+                && mScoringEnabled == otherProperty.mScoringEnabled;
     }
 
     @Override
@@ -353,7 +397,8 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
                             mDocumentIndexingConfigParcel,
                             mIntegerIndexingConfigParcel,
                             mJoinableConfigParcel,
-                            mEmbeddingIndexingConfigParcel);
+                            mEmbeddingIndexingConfigParcel,
+                            mScoringEnabled);
         }
         return mHashCode;
     }
@@ -381,6 +426,8 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
                 + mJoinableConfigParcel
                 + ", embeddingIndexingConfigParcel: "
                 + mEmbeddingIndexingConfigParcel
+                + ", isScoringEnabled: "
+                + mScoringEnabled
                 + "}";
     }
 
@@ -395,16 +442,16 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
         @Field(id = 1, getter = "getJoinableValueType")
         private final int mJoinableValueType;
 
-        @Field(id = 2, getter = "getDeletionPropagation")
-        private final boolean mDeletionPropagation;
+        @Field(id = 3, getter = "getDeletePropagationType")
+        private final int mDeletePropagationType;
 
         /** Constructor for {@link JoinableConfigParcel}. */
         @Constructor
         public JoinableConfigParcel(
                 @Param(id = 1) @JoinableValueType int joinableValueType,
-                @Param(id = 2) boolean deletionPropagation) {
+                @Param(id = 3) @DeletePropagationType int deletePropagationType) {
             mJoinableValueType = joinableValueType;
-            mDeletionPropagation = deletionPropagation;
+            mDeletePropagationType = deletePropagationType;
         }
 
         /** Gets {@link JoinableValueType} of the join. */
@@ -413,9 +460,10 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
             return mJoinableValueType;
         }
 
-        /** Gets whether delete will be propagated. */
-        public boolean getDeletionPropagation() {
-            return mDeletionPropagation;
+        /** Gets {@link DeletePropagationType} of the join. */
+        @DeletePropagationType
+        public int getDeletePropagationType() {
+            return mDeletePropagationType;
         }
 
         @Override
@@ -425,7 +473,7 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
 
         @Override
         public int hashCode() {
-            return Objects.hash(mJoinableValueType, mDeletionPropagation);
+            return Objects.hash(mJoinableValueType, mDeletePropagationType);
         }
 
         @Override
@@ -438,7 +486,7 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
             }
             JoinableConfigParcel otherObject = (JoinableConfigParcel) other;
             return Objects.equals(mJoinableValueType, otherObject.mJoinableValueType)
-                    && Objects.equals(mDeletionPropagation, otherObject.mDeletionPropagation);
+                    && mDeletePropagationType == otherObject.mDeletePropagationType;
         }
 
         @Override
@@ -446,8 +494,8 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
         public String toString() {
             return "{joinableValueType: "
                     + mJoinableValueType
-                    + ", deletePropagation "
-                    + mDeletionPropagation
+                    + ", deletePropagationType: "
+                    + mDeletePropagationType
                     + "}";
         }
     }
@@ -507,14 +555,14 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
                 return false;
             }
             StringIndexingConfigParcel otherObject = (StringIndexingConfigParcel) other;
-            return Objects.equals(mIndexingType, otherObject.mIndexingType)
+            return mIndexingType == otherObject.mIndexingType
                     && Objects.equals(mTokenizerType, otherObject.mTokenizerType);
         }
 
         @Override
         @NonNull
         public String toString() {
-            return "{indexingType: " + mIndexingType + ", tokenizerType " + mTokenizerType + "}";
+            return "{indexingType: " + mIndexingType + ", tokenizerType: " + mTokenizerType + "}";
         }
     }
 
@@ -561,7 +609,7 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
                 return false;
             }
             IntegerIndexingConfigParcel otherObject = (IntegerIndexingConfigParcel) other;
-            return Objects.equals(mIndexingType, otherObject.mIndexingType);
+            return mIndexingType == otherObject.mIndexingType;
         }
 
         @Override
@@ -652,12 +700,19 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
         @Field(id = 1, getter = "getIndexingType")
         private final int mIndexingType;
 
+        @AppSearchSchema.EmbeddingPropertyConfig.QuantizationType
+        @Field(id = 2, getter = "getQuantizationType")
+        private final int mQuantizationType;
+
         /** Constructor for {@link EmbeddingIndexingConfigParcel}. */
         @Constructor
         public EmbeddingIndexingConfigParcel(
                 @Param(id = 1) @AppSearchSchema.EmbeddingPropertyConfig.IndexingType
-                        int indexingType) {
+                        int indexingType,
+                @Param(id = 2) @AppSearchSchema.EmbeddingPropertyConfig.QuantizationType
+                        int quantizationType) {
             mIndexingType = indexingType;
+            mQuantizationType = quantizationType;
         }
 
         /** Gets the indexing type for this embedding property. */
@@ -666,6 +721,12 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
             return mIndexingType;
         }
 
+        /** Gets the quantization type for this embedding property. */
+        @AppSearchSchema.EmbeddingPropertyConfig.QuantizationType
+        public int getQuantizationType() {
+            return mQuantizationType;
+        }
+
         @Override
         public void writeToParcel(@NonNull Parcel dest, int flags) {
             EmbeddingIndexingConfigParcelCreator.writeToParcel(this, dest, flags);
@@ -673,7 +734,7 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
 
         @Override
         public int hashCode() {
-            return Objects.hashCode(mIndexingType);
+            return Objects.hash(mIndexingType, mQuantizationType);
         }
 
         @Override
@@ -685,13 +746,18 @@ public final class PropertyConfigParcel extends AbstractSafeParcelable {
                 return false;
             }
             EmbeddingIndexingConfigParcel otherObject = (EmbeddingIndexingConfigParcel) other;
-            return Objects.equals(mIndexingType, otherObject.mIndexingType);
+            return mIndexingType == otherObject.mIndexingType
+                    && mQuantizationType == otherObject.mQuantizationType;
         }
 
         @Override
         @NonNull
         public String toString() {
-            return "{indexingType: " + mIndexingType + "}";
+            return "{indexingType: "
+                    + mIndexingType
+                    + ", quantizationType: "
+                    + mQuantizationType
+                    + "}";
         }
     }
 }
diff --git a/framework/java/external/android/app/appsearch/safeparcel/PropertyParcel.java b/framework/java/external/android/app/appsearch/safeparcel/PropertyParcel.java
index 72b994ff..7bdc1715 100644
--- a/framework/java/external/android/app/appsearch/safeparcel/PropertyParcel.java
+++ b/framework/java/external/android/app/appsearch/safeparcel/PropertyParcel.java
@@ -19,6 +19,7 @@ package android.app.appsearch.safeparcel;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.SuppressLint;
+import android.app.appsearch.AppSearchBlobHandle;
 import android.app.appsearch.EmbeddingVector;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
 import android.os.Parcel;
@@ -73,6 +74,10 @@ public final class PropertyParcel extends AbstractSafeParcelable implements Parc
     @Field(id = 8, getter = "getEmbeddingValues")
     private final EmbeddingVector[] mEmbeddingValues;
 
+    @Nullable
+    @Field(id = 9, getter = "getBlobHandleValues")
+    private final AppSearchBlobHandle[] mBlobHandleValues;
+
     @Nullable private Integer mHashCode;
 
     @Constructor
@@ -84,7 +89,8 @@ public final class PropertyParcel extends AbstractSafeParcelable implements Parc
             @Param(id = 5) @Nullable boolean[] booleanValues,
             @Param(id = 6) @Nullable byte[][] bytesValues,
             @Param(id = 7) @Nullable GenericDocumentParcel[] documentValues,
-            @Param(id = 8) @Nullable EmbeddingVector[] embeddingValues) {
+            @Param(id = 8) @Nullable EmbeddingVector[] embeddingValues,
+            @Param(id = 9) @Nullable AppSearchBlobHandle[] blobHandleValues) {
         mPropertyName = Objects.requireNonNull(propertyName);
         mStringValues = stringValues;
         mLongValues = longValues;
@@ -93,6 +99,7 @@ public final class PropertyParcel extends AbstractSafeParcelable implements Parc
         mBytesValues = bytesValues;
         mDocumentValues = documentValues;
         mEmbeddingValues = embeddingValues;
+        mBlobHandleValues = blobHandleValues;
         checkOnlyOneArrayCanBeSet();
     }
 
@@ -144,6 +151,12 @@ public final class PropertyParcel extends AbstractSafeParcelable implements Parc
         return mEmbeddingValues;
     }
 
+    /** Returns {@link AppSearchBlobHandle}s in an array. */
+    @Nullable
+    public AppSearchBlobHandle[] getBlobHandleValues() {
+        return mBlobHandleValues;
+    }
+
     /**
      * Returns the held values in an array for this property.
      *
@@ -172,6 +185,9 @@ public final class PropertyParcel extends AbstractSafeParcelable implements Parc
         if (mEmbeddingValues != null) {
             return mEmbeddingValues;
         }
+        if (mBlobHandleValues != null) {
+            return mBlobHandleValues;
+        }
         return null;
     }
 
@@ -203,6 +219,9 @@ public final class PropertyParcel extends AbstractSafeParcelable implements Parc
         if (mEmbeddingValues != null) {
             ++notNullCount;
         }
+        if (mBlobHandleValues != null) {
+            ++notNullCount;
+        }
         if (notNullCount == 0 || notNullCount > 1) {
             throw new IllegalArgumentException(
                     "One and only one type array can be set in PropertyParcel");
@@ -227,6 +246,8 @@ public final class PropertyParcel extends AbstractSafeParcelable implements Parc
                 hashCode = Arrays.hashCode(mDocumentValues);
             } else if (mEmbeddingValues != null) {
                 hashCode = Arrays.deepHashCode(mEmbeddingValues);
+            } else if (mBlobHandleValues != null) {
+                hashCode = Arrays.deepHashCode(mBlobHandleValues);
             }
             mHashCode = Objects.hash(mPropertyName, hashCode);
         }
@@ -251,7 +272,8 @@ public final class PropertyParcel extends AbstractSafeParcelable implements Parc
                 && Arrays.equals(mBooleanValues, otherPropertyParcel.mBooleanValues)
                 && Arrays.deepEquals(mBytesValues, otherPropertyParcel.mBytesValues)
                 && Arrays.equals(mDocumentValues, otherPropertyParcel.mDocumentValues)
-                && Arrays.deepEquals(mEmbeddingValues, otherPropertyParcel.mEmbeddingValues);
+                && Arrays.deepEquals(mEmbeddingValues, otherPropertyParcel.mEmbeddingValues)
+                && Arrays.deepEquals(mBlobHandleValues, otherPropertyParcel.mBlobHandleValues);
     }
 
     @Override
@@ -269,6 +291,7 @@ public final class PropertyParcel extends AbstractSafeParcelable implements Parc
         private byte[][] mBytesValues;
         private GenericDocumentParcel[] mDocumentValues;
         private EmbeddingVector[] mEmbeddingValues;
+        private AppSearchBlobHandle[] mBlobHandleValues;
 
         public Builder(@NonNull String propertyName) {
             mPropertyName = Objects.requireNonNull(propertyName);
@@ -330,6 +353,14 @@ public final class PropertyParcel extends AbstractSafeParcelable implements Parc
             return this;
         }
 
+        /** Sets {@link AppSearchBlobHandle} values. */
+        @CanIgnoreReturnValue
+        @NonNull
+        public Builder setBlobHandleValues(@NonNull AppSearchBlobHandle[] blobHandleValues) {
+            mBlobHandleValues = Objects.requireNonNull(blobHandleValues);
+            return this;
+        }
+
         /** Builds a {@link PropertyParcel}. */
         @NonNull
         public PropertyParcel build() {
@@ -341,7 +372,8 @@ public final class PropertyParcel extends AbstractSafeParcelable implements Parc
                     mBooleanValues,
                     mBytesValues,
                     mDocumentValues,
-                    mEmbeddingValues);
+                    mEmbeddingValues,
+                    mBlobHandleValues);
         }
     }
 }
diff --git a/framework/java/external/android/app/appsearch/usagereporting/ActionConstants.java b/framework/java/external/android/app/appsearch/usagereporting/ActionConstants.java
index 0959fb8e..ea6aee42 100644
--- a/framework/java/external/android/app/appsearch/usagereporting/ActionConstants.java
+++ b/framework/java/external/android/app/appsearch/usagereporting/ActionConstants.java
@@ -37,5 +37,11 @@ public final class ActionConstants {
     /** Click action type. */
     public static final int ACTION_TYPE_CLICK = 2;
 
+    /** Impression action type. */
+    public static final int ACTION_TYPE_IMPRESSION = 3;
+
+    /** Dismiss action type. */
+    public static final int ACTION_TYPE_DISMISS = 4;
+
     private ActionConstants() {}
 }
diff --git a/safeparcel-processor/Android.bp b/safeparcel-processor/Android.bp
index 16e0ef93..16d2fedf 100644
--- a/safeparcel-processor/Android.bp
+++ b/safeparcel-processor/Android.bp
@@ -28,8 +28,9 @@ java_library_host {
     ],
     java_resource_dirs: ["resources/"],
     static_libs: [
-        "jsilver",
         "androidx.annotation_annotation",
+        "guava",
+        "jsilver",
     ],
     use_tools_jar: true,
 }
diff --git a/safeparcel-processor/src/android/app/appsearch/safeparcel/SafeParcelProcessor.java b/safeparcel-processor/src/android/app/appsearch/safeparcel/SafeParcelProcessor.java
index 5d8f0c34..99ab770b 100644
--- a/safeparcel-processor/src/android/app/appsearch/safeparcel/SafeParcelProcessor.java
+++ b/safeparcel-processor/src/android/app/appsearch/safeparcel/SafeParcelProcessor.java
@@ -27,6 +27,7 @@ import com.google.clearsilver.jsilver.JSilverOptions;
 import com.google.clearsilver.jsilver.autoescape.EscapeMode;
 import com.google.clearsilver.jsilver.data.Data;
 import com.google.clearsilver.jsilver.resourceloader.ClassLoaderResourceLoader;
+import com.google.common.base.Joiner;
 
 import java.io.IOException;
 import java.io.PrintWriter;
@@ -1515,7 +1516,8 @@ public class SafeParcelProcessor extends AbstractProcessor {
                         // then expectedAlternativeCreatorTypeName needs to trim <T> part as
                         // detectedAlternativeCreatorTypeName would only return Parcel resulting
                         // in an incorrect ParcelCreatorType failure.
-                        String type = declaredType.getTypeArguments().get(0).toString(); // T
+                        StringBuilder type = new StringBuilder();
+                        Joiner.on(',').appendTo(type, declaredType.getTypeArguments());
                         expectedAlternativeCreatorTypeName =
                                 expectedAlternativeCreatorTypeName.replace("<" + type + ">", "");
                     }
diff --git a/service/java/com/android/server/appsearch/AppSearchManagerService.java b/service/java/com/android/server/appsearch/AppSearchManagerService.java
index 7fe8fbe9..3104c499 100644
--- a/service/java/com/android/server/appsearch/AppSearchManagerService.java
+++ b/service/java/com/android/server/appsearch/AppSearchManagerService.java
@@ -16,13 +16,11 @@
 package com.android.server.appsearch;
 
 import static android.app.appsearch.AppSearchResult.RESULT_DENIED;
-import static android.app.appsearch.AppSearchResult.RESULT_INTERNAL_ERROR;
 import static android.app.appsearch.AppSearchResult.RESULT_INVALID_ARGUMENT;
 import static android.app.appsearch.AppSearchResult.RESULT_NOT_FOUND;
 import static android.app.appsearch.AppSearchResult.RESULT_OK;
 import static android.app.appsearch.AppSearchResult.RESULT_RATE_LIMITED;
 import static android.app.appsearch.AppSearchResult.RESULT_SECURITY_ERROR;
-import static android.app.appsearch.AppSearchResult.RESULT_TIMED_OUT;
 import static android.app.appsearch.AppSearchResult.throwableToFailedResult;
 import static android.os.Process.INVALID_UID;
 
@@ -37,13 +35,20 @@ import android.annotation.Nullable;
 import android.annotation.UserIdInt;
 import android.annotation.WorkerThread;
 import android.app.appsearch.AppSearchBatchResult;
+import android.app.appsearch.AppSearchBlobHandle;
 import android.app.appsearch.AppSearchEnvironment;
 import android.app.appsearch.AppSearchEnvironmentFactory;
 import android.app.appsearch.AppSearchMigrationHelper;
 import android.app.appsearch.AppSearchResult;
+import android.app.appsearch.AppSearchSchema;
+import android.app.appsearch.CommitBlobResponse;
 import android.app.appsearch.GenericDocument;
 import android.app.appsearch.GetSchemaResponse;
 import android.app.appsearch.InternalSetSchemaResponse;
+import android.app.appsearch.InternalVisibilityConfig;
+import android.app.appsearch.OpenBlobForReadResponse;
+import android.app.appsearch.OpenBlobForWriteResponse;
+import android.app.appsearch.RemoveBlobResponse;
 import android.app.appsearch.SearchResultPage;
 import android.app.appsearch.SearchSpec;
 import android.app.appsearch.SearchSuggestionResult;
@@ -52,60 +57,56 @@ import android.app.appsearch.SetSchemaResponse.MigrationFailure;
 import android.app.appsearch.StorageInfo;
 import android.app.appsearch.aidl.AppSearchBatchResultParcel;
 import android.app.appsearch.aidl.AppSearchResultParcel;
-import android.app.appsearch.aidl.ExecuteAppFunctionAidlRequest;
+import android.app.appsearch.aidl.AppSearchResultParcelV2;
+import android.app.appsearch.aidl.CommitBlobAidlRequest;
 import android.app.appsearch.aidl.GetDocumentsAidlRequest;
 import android.app.appsearch.aidl.GetNamespacesAidlRequest;
 import android.app.appsearch.aidl.GetNextPageAidlRequest;
 import android.app.appsearch.aidl.GetSchemaAidlRequest;
 import android.app.appsearch.aidl.GetStorageInfoAidlRequest;
 import android.app.appsearch.aidl.GlobalSearchAidlRequest;
-import android.app.appsearch.aidl.IAppFunctionService;
 import android.app.appsearch.aidl.IAppSearchBatchResultCallback;
 import android.app.appsearch.aidl.IAppSearchManager;
 import android.app.appsearch.aidl.IAppSearchObserverProxy;
 import android.app.appsearch.aidl.IAppSearchResultCallback;
 import android.app.appsearch.aidl.InitializeAidlRequest;
 import android.app.appsearch.aidl.InvalidateNextPageTokenAidlRequest;
+import android.app.appsearch.aidl.OpenBlobForReadAidlRequest;
+import android.app.appsearch.aidl.OpenBlobForWriteAidlRequest;
 import android.app.appsearch.aidl.PersistToDiskAidlRequest;
 import android.app.appsearch.aidl.PutDocumentsAidlRequest;
 import android.app.appsearch.aidl.PutDocumentsFromFileAidlRequest;
 import android.app.appsearch.aidl.RegisterObserverCallbackAidlRequest;
+import android.app.appsearch.aidl.RemoveBlobAidlRequest;
 import android.app.appsearch.aidl.RemoveByDocumentIdAidlRequest;
 import android.app.appsearch.aidl.RemoveByQueryAidlRequest;
 import android.app.appsearch.aidl.ReportUsageAidlRequest;
 import android.app.appsearch.aidl.SearchAidlRequest;
 import android.app.appsearch.aidl.SearchSuggestionAidlRequest;
+import android.app.appsearch.aidl.SetBlobVisibilityAidlRequest;
 import android.app.appsearch.aidl.SetSchemaAidlRequest;
 import android.app.appsearch.aidl.UnregisterObserverCallbackAidlRequest;
 import android.app.appsearch.aidl.WriteSearchResultsToFileAidlRequest;
 import android.app.appsearch.exceptions.AppSearchException;
-import android.app.appsearch.functions.AppFunctionService;
-import android.app.appsearch.functions.ExecuteAppFunctionRequest;
-import android.app.appsearch.functions.SafeOneTimeAppSearchResultCallback;
-import android.app.appsearch.functions.ServiceCallHelper;
-import android.app.appsearch.functions.ServiceCallHelper.ServiceUsageCompleteListener;
-import android.app.appsearch.functions.ServiceCallHelperImpl;
 import android.app.appsearch.safeparcel.GenericDocumentParcel;
 import android.app.appsearch.stats.SchemaMigrationStats;
 import android.app.appsearch.util.ExceptionUtil;
 import android.app.appsearch.util.LogUtil;
 import android.app.role.RoleManager;
 import android.content.BroadcastReceiver;
-import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.PackageStats;
-import android.content.pm.ResolveInfo;
-import android.content.pm.ServiceInfo;
 import android.net.Uri;
 import android.os.Binder;
+import android.os.Build;
+import android.os.ParcelFileDescriptor;
 import android.os.RemoteException;
 import android.os.SystemClock;
 import android.os.UserHandle;
-import android.text.TextUtils;
 import android.util.ArraySet;
 import android.util.Log;
 
@@ -118,6 +119,7 @@ import com.android.server.appsearch.external.localstorage.stats.OptimizeStats;
 import com.android.server.appsearch.external.localstorage.stats.SearchStats;
 import com.android.server.appsearch.external.localstorage.stats.SetSchemaStats;
 import com.android.server.appsearch.external.localstorage.usagereporting.SearchSessionStatsExtractor;
+import com.android.server.appsearch.external.localstorage.visibilitystore.CallerAccess;
 import com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityStore;
 import com.android.server.appsearch.observer.AppSearchObserverProxy;
 import com.android.server.appsearch.stats.StatsCollector;
@@ -126,7 +128,6 @@ import com.android.server.appsearch.transformer.EnterpriseSearchSpecTransformer;
 import com.android.server.appsearch.util.AdbDumpUtil;
 import com.android.server.appsearch.util.ApiCallRecord;
 import com.android.server.appsearch.util.ExecutorManager;
-import com.android.server.appsearch.util.PackageManagerUtil;
 import com.android.server.appsearch.util.ServiceImplHelper;
 import com.android.server.appsearch.visibilitystore.FrameworkCallerAccess;
 import com.android.server.usage.StorageStatsManagerLocal;
@@ -183,26 +184,15 @@ public class AppSearchManagerService extends SystemService {
     // Keep a reference for the lifecycle instance, so we can access other services like
     // ContactsIndexer for dumpsys purpose.
     private final AppSearchModule.Lifecycle mLifecycle;
-    private final ServiceCallHelper<IAppFunctionService> mAppFunctionServiceCallHelper;
     private final SearchSessionStatsExtractor mSearchSessionStatsExtractor;
 
     public AppSearchManagerService(Context context, AppSearchModule.Lifecycle lifecycle) {
-        this(context, lifecycle, new ServiceCallHelperImpl<>(
-                context, IAppFunctionService.Stub::asInterface, SHARED_EXECUTOR));
-    }
-
-    @VisibleForTesting
-    public AppSearchManagerService(
-            Context context,
-            AppSearchModule.Lifecycle lifecycle,
-            ServiceCallHelper<IAppFunctionService> appFunctionServiceCallHelper) {
         super(context);
         mContext = Objects.requireNonNull(context);
         mLifecycle = Objects.requireNonNull(lifecycle);
         mAppSearchEnvironment = AppSearchEnvironmentFactory.getEnvironmentInstance();
         mAppSearchConfig = AppSearchComponentFactory.getConfigInstance(SHARED_EXECUTOR);
         mExecutorManager = new ExecutorManager(mAppSearchConfig);
-        mAppFunctionServiceCallHelper = Objects.requireNonNull(appFunctionServiceCallHelper);
         mSearchSessionStatsExtractor = new SearchSessionStatsExtractor();
     }
 
@@ -327,17 +317,15 @@ public class AppSearchManagerService extends SystemService {
                     userHandle,
                     () -> {
                         try {
-                            Context userContext = mAppSearchEnvironment
-                                    .createContextAsUser(mContext, userHandle);
+                            Context userContext =
+                                    mAppSearchEnvironment.createContextAsUser(mContext, userHandle);
                             AppSearchUserInstance instance =
                                     mAppSearchUserInstanceManager.getOrCreateUserInstance(
-                                            userContext,
-                                            userHandle,
-                                            mAppSearchConfig);
+                                            userContext, userHandle, mAppSearchConfig);
                             instance.getAppSearchImpl().clearPackageData(packageName);
                             dispatchChangeNotifications(instance);
                             instance.getLogger().removeCacheForPackage(packageName);
-                        } catch (AppSearchException | RuntimeException e) {
+                        } catch (AppSearchException | RuntimeException | IOException e) {
                             Log.e(TAG, "Unable to remove data for package: " + packageName, e);
                             ExceptionUtil.handleException(e);
                         }
@@ -437,6 +425,7 @@ public class AppSearchManagerService extends SystemService {
                 @NonNull IAppSearchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            checkUnsupportedEmbeddingUse(request.getSchemas());
 
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
             long verifyIncomingCallLatencyStartTimeMillis = SystemClock.elapsedRealtime();
@@ -1032,12 +1021,498 @@ public class AppSearchManagerService extends SystemService {
             }
         }
 
+        @Override
+        public void openBlobForWrite(
+                OpenBlobForWriteAidlRequest request, @NonNull IAppSearchResultCallback callback) {
+            Objects.requireNonNull(request);
+            Objects.requireNonNull(callback);
+            long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
+            UserHandle targetUser =
+                    mServiceImplHelper.verifyIncomingCallWithCallback(
+                            request.getCallerAttributionSource(),
+                            request.getUserHandle(),
+                            callback);
+            String callingPackageName = request.getCallerAttributionSource().getPackageName();
+            String callingDatabaseName = request.getCallingDatabaseName();
+            if (targetUser == null) {
+                return; // Verification failed; verifyIncomingCall triggered callback.
+            }
+            if (checkCallDenied(callingPackageName, callingDatabaseName,
+                    CallStats.CALL_TYPE_OPEN_WRITE_BLOB, callback, targetUser,
+                    request.getBinderCallStartTimeMillis(), totalLatencyStartTimeMillis,
+                    /* numOperations= */ request.getBlobHandles().size())) {
+                return;
+            }
+            boolean callAccepted = mExecutorManager.executeLambdaForUserAsync(targetUser, callback,
+                    callingPackageName, CallStats.CALL_TYPE_OPEN_WRITE_BLOB, () -> {
+                @AppSearchResult.ResultCode int statusCode = RESULT_OK;
+                AppSearchUserInstance instance = null;
+                int operationSuccessCount = 0;
+                int operationFailureCount = 0;
+                try {
+                    AppSearchBatchResult.Builder<AppSearchBlobHandle, ParcelFileDescriptor>
+                            resultBuilder = new AppSearchBatchResult.Builder<>();
+                    instance = mAppSearchUserInstanceManager.getUserInstance(targetUser);
+                    List<AppSearchBlobHandle> blobHandles = request.getBlobHandles();
+                    for (int i = 0; i < blobHandles.size(); i++) {
+                        AppSearchBlobHandle blobHandle = blobHandles.get(i);
+                        try {
+                            ParcelFileDescriptor pfd = instance.getAppSearchImpl()
+                                    .openWriteBlob(
+                                            callingPackageName,
+                                            callingDatabaseName,
+                                            blobHandle);
+                            resultBuilder.setSuccess(blobHandle, pfd);
+                        } catch (AppSearchException | IOException e) {
+                            AppSearchResult<ParcelFileDescriptor> result =
+                                    throwableToFailedResult(e);
+                            resultBuilder.setResult(blobHandle, result);
+                            statusCode = result.getResultCode();
+                            ++operationFailureCount;
+                        }
+                    }
+                    OpenBlobForWriteResponse response =
+                            new OpenBlobForWriteResponse(resultBuilder.build());
+                    invokeCallbackOnResult(callback,
+                            AppSearchResultParcelV2.fromOpenBlobForWriteResponse(response));
+                } catch (RuntimeException e) {
+                    ++operationFailureCount;
+                    AppSearchResult<Void> failedResult = throwableToFailedResult(e);
+                    statusCode = failedResult.getResultCode();
+                    invokeCallbackOnResult(callback,
+                            AppSearchResultParcelV2.fromFailedResult(failedResult));
+                } finally {
+                    if (instance != null) {
+                        int estimatedBinderLatencyMillis =
+                                2 * (int) (totalLatencyStartTimeMillis -
+                                        request.getBinderCallStartTimeMillis());
+                        int totalLatencyMillis =
+                                (int) (SystemClock.elapsedRealtime()
+                                        - totalLatencyStartTimeMillis);
+                        instance.getLogger().logStats(new CallStats.Builder()
+                                .setPackageName(callingPackageName)
+                                .setDatabase(request.getCallingDatabaseName())
+                                .setCallType(CallStats.CALL_TYPE_OPEN_WRITE_BLOB)
+                                .setStatusCode(statusCode)
+                                .setTotalLatencyMillis(totalLatencyMillis)
+                                // TODO(b/173532925) check the existing binder call latency chart
+                                // is good enough for us:
+                                // http://dashboards/view/_72c98f9a_91d9_41d4_ab9a_bc14f79742b4
+                                .setEstimatedBinderLatencyMillis(
+                                        estimatedBinderLatencyMillis)
+                                .setNumOperationsSucceeded(operationSuccessCount)
+                                .setNumOperationsFailed(operationFailureCount)
+                                .build());
+                    }
+                }
+            });
+            if (!callAccepted) {
+                logRateLimitedOrCallDeniedCallStats(
+                        callingPackageName,
+                        /* callingDatabaseName= */ null,
+                        CallStats.CALL_TYPE_OPEN_WRITE_BLOB,
+                        targetUser,
+                        request.getBinderCallStartTimeMillis(),
+                        totalLatencyStartTimeMillis,
+                        request.getBlobHandles().size(),
+                        RESULT_RATE_LIMITED);
+            }
+        }
+
+        @Override
+        public void removeBlob(
+                RemoveBlobAidlRequest request, @NonNull IAppSearchResultCallback callback) {
+            Objects.requireNonNull(request);
+            Objects.requireNonNull(callback);
+            long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
+            UserHandle targetUser =
+                    mServiceImplHelper.verifyIncomingCallWithCallback(
+                            request.getCallerAttributionSource(),
+                            request.getUserHandle(),
+                            callback);
+            String callingPackageName = request.getCallerAttributionSource().getPackageName();
+            String callingDatabaseName = request.getCallingDatabaseName();
+            if (targetUser == null) {
+                return; // Verification failed; verifyIncomingCall triggered callback.
+            }
+            if (checkCallDenied(callingPackageName, callingDatabaseName,
+                    CallStats.CALL_TYPE_REMOVE_BLOB, callback, targetUser,
+                    request.getBinderCallStartTimeMillis(), totalLatencyStartTimeMillis,
+                    /* numOperations= */ request.getBlobHandles().size())) {
+                return;
+            }
+            boolean callAccepted = mExecutorManager.executeLambdaForUserAsync(targetUser, callback,
+                    callingPackageName, CallStats.CALL_TYPE_REMOVE_BLOB, () -> {
+                @AppSearchResult.ResultCode int statusCode = RESULT_OK;
+                AppSearchUserInstance instance = null;
+                int operationSuccessCount = 0;
+                int operationFailureCount = 0;
+                try {
+                    AppSearchBatchResult.Builder<AppSearchBlobHandle, Void>
+                            resultBuilder = new AppSearchBatchResult.Builder<>();
+                    instance = mAppSearchUserInstanceManager.getUserInstance(targetUser);
+                    List<AppSearchBlobHandle> blobHandles = request.getBlobHandles();
+                    for (int i = 0; i < blobHandles.size(); i++) {
+                        AppSearchBlobHandle blobHandle = blobHandles.get(i);
+                        try {
+                            instance.getAppSearchImpl()
+                                    .removeBlob(
+                                            callingPackageName,
+                                            callingDatabaseName,
+                                            blobHandle);
+                            resultBuilder.setSuccess(blobHandle, null);
+                        } catch (AppSearchException | IOException e) {
+                            AppSearchResult<Void> result =
+                                    throwableToFailedResult(e);
+                            resultBuilder.setResult(blobHandle, result);
+                            statusCode = result.getResultCode();
+                            ++operationFailureCount;
+                        }
+                    }
+                    RemoveBlobResponse response = new RemoveBlobResponse(resultBuilder.build());
+                    invokeCallbackOnResult(callback,
+                            AppSearchResultParcelV2.fromRemoveBlobResponseParcel(response));
+                } catch (RuntimeException e) {
+                    ++operationFailureCount;
+                    AppSearchResult<Void> failedResult = throwableToFailedResult(e);
+                    statusCode = failedResult.getResultCode();
+                    invokeCallbackOnResult(callback,
+                            AppSearchResultParcelV2.fromFailedResult(failedResult));
+                } finally {
+                    if (instance != null) {
+                        int estimatedBinderLatencyMillis =
+                                2 * (int) (totalLatencyStartTimeMillis -
+                                        request.getBinderCallStartTimeMillis());
+                        int totalLatencyMillis =
+                                (int) (SystemClock.elapsedRealtime()
+                                        - totalLatencyStartTimeMillis);
+                        instance.getLogger().logStats(new CallStats.Builder()
+                                .setPackageName(callingPackageName)
+                                .setDatabase(request.getCallingDatabaseName())
+                                .setCallType(CallStats.CALL_TYPE_REMOVE_BLOB)
+                                .setStatusCode(statusCode)
+                                .setTotalLatencyMillis(totalLatencyMillis)
+                                // TODO(b/173532925) check the existing binder call latency chart
+                                // is good enough for us:
+                                // http://dashboards/view/_72c98f9a_91d9_41d4_ab9a_bc14f79742b4
+                                .setEstimatedBinderLatencyMillis(
+                                        estimatedBinderLatencyMillis)
+                                .setNumOperationsSucceeded(operationSuccessCount)
+                                .setNumOperationsFailed(operationFailureCount)
+                                .build());
+                    }
+                }
+            });
+            if (!callAccepted) {
+                logRateLimitedOrCallDeniedCallStats(
+                        callingPackageName,
+                        /* callingDatabaseName= */ null,
+                        CallStats.CALL_TYPE_REMOVE_BLOB,
+                        targetUser,
+                        request.getBinderCallStartTimeMillis(),
+                        totalLatencyStartTimeMillis,
+                        request.getBlobHandles().size(),
+                        RESULT_RATE_LIMITED);
+            }
+        }
+
+        @Override
+        public void commitBlob(
+                CommitBlobAidlRequest request, @NonNull IAppSearchResultCallback callback) {
+            Objects.requireNonNull(request);
+            Objects.requireNonNull(callback);
+            long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
+            UserHandle targetUser =
+                    mServiceImplHelper.verifyIncomingCallWithCallback(
+                            request.getCallerAttributionSource(),
+                            request.getUserHandle(),
+                            callback);
+            String callingPackageName = request.getCallerAttributionSource().getPackageName();
+            String callingDatabaseName = request.getCallingDatabaseName();
+            if (targetUser == null) {
+                return; // Verification failed; verifyIncomingCall triggered callback.
+            }
+            if (checkCallDenied(callingPackageName, callingDatabaseName,
+                    CallStats.CALL_TYPE_COMMIT_BLOB, callback, targetUser,
+                    request.getBinderCallStartTimeMillis(), totalLatencyStartTimeMillis,
+                    /* numOperations= */ request.getBlobHandles().size())) {
+                return;
+            }
+            boolean callAccepted = mExecutorManager.executeLambdaForUserAsync(targetUser, callback,
+                    callingPackageName, CallStats.CALL_TYPE_COMMIT_BLOB, () -> {
+                @AppSearchResult.ResultCode int statusCode = RESULT_OK;
+                AppSearchUserInstance instance = null;
+                int operationSuccessCount = 0;
+                int operationFailureCount = 0;
+                try {
+                    AppSearchBatchResult.Builder<AppSearchBlobHandle, Void>
+                            resultBuilder = new AppSearchBatchResult.Builder<>();
+                    instance = mAppSearchUserInstanceManager.getUserInstance(targetUser);
+                    List<AppSearchBlobHandle> blobHandles = request.getBlobHandles();
+                    for (int i = 0; i < blobHandles.size(); i++) {
+                        AppSearchBlobHandle blobHandle = blobHandles.get(i);
+                        try {
+                            instance.getAppSearchImpl()
+                                    .commitBlob(
+                                            callingPackageName,
+                                            callingDatabaseName,
+                                            blobHandle);
+                            resultBuilder.setSuccess(blobHandle, null);
+                        } catch (AppSearchException e) {
+                            AppSearchResult<Void> result =
+                                    throwableToFailedResult(e);
+                            resultBuilder.setResult(blobHandle, result);
+                            statusCode = result.getResultCode();
+                            ++operationFailureCount;
+                        }
+                    }
+                    CommitBlobResponse response =
+                            new CommitBlobResponse(resultBuilder.build());
+                    invokeCallbackOnResult(callback,
+                            AppSearchResultParcelV2.fromCommitBlobResponseParcel(response));
+                } catch (RuntimeException e) {
+                    ++operationFailureCount;
+                    AppSearchResult<Void> failedResult = throwableToFailedResult(e);
+                    statusCode = failedResult.getResultCode();
+                    invokeCallbackOnResult(callback,
+                            AppSearchResultParcelV2.fromFailedResult(failedResult));
+                } finally {
+                    if (instance != null) {
+                        int estimatedBinderLatencyMillis =
+                                2 * (int) (totalLatencyStartTimeMillis -
+                                        request.getBinderCallStartTimeMillis());
+                        int totalLatencyMillis =
+                                (int) (SystemClock.elapsedRealtime()
+                                        - totalLatencyStartTimeMillis);
+                        instance.getLogger().logStats(new CallStats.Builder()
+                                .setPackageName(callingPackageName)
+                                .setDatabase(request.getCallingDatabaseName())
+                                .setCallType(CallStats.CALL_TYPE_COMMIT_BLOB)
+                                .setStatusCode(statusCode)
+                                .setTotalLatencyMillis(totalLatencyMillis)
+                                // TODO(b/173532925) check the existing binder call latency chart
+                                // is good enough for us:
+                                // http://dashboards/view/_72c98f9a_91d9_41d4_ab9a_bc14f79742b4
+                                .setEstimatedBinderLatencyMillis(
+                                        estimatedBinderLatencyMillis)
+                                .setNumOperationsSucceeded(operationSuccessCount)
+                                .setNumOperationsFailed(operationFailureCount)
+                                .build());
+                    }
+
+                }
+            });
+            if (!callAccepted) {
+                logRateLimitedOrCallDeniedCallStats(
+                        callingPackageName,
+                        /* callingDatabaseName= */ null,
+                        CallStats.CALL_TYPE_COMMIT_BLOB,
+                        targetUser,
+                        request.getBinderCallStartTimeMillis(),
+                        totalLatencyStartTimeMillis,
+                        request.getBlobHandles().size(),
+                        RESULT_RATE_LIMITED);
+            }
+        }
+
+        @Override
+        public void openBlobForRead(
+                OpenBlobForReadAidlRequest request, @NonNull IAppSearchResultCallback callback) {
+            Objects.requireNonNull(request);
+            Objects.requireNonNull(callback);
+            long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
+            UserHandle targetUser =
+                    mServiceImplHelper.verifyIncomingCallWithCallback(
+                            request.getCallerAttributionSource(),
+                            request.getUserHandle(),
+                            callback);
+            String callingPackageName = request.getCallerAttributionSource().getPackageName();
+            String callingDatabaseName = request.getCallingDatabaseName();
+            boolean global = callingDatabaseName == null;
+            int callType = global ? CallStats.CALL_TYPE_GLOBAL_OPEN_READ_BLOB
+                    : CallStats.CALL_TYPE_OPEN_READ_BLOB;
+            if (targetUser == null) {
+                return; // Verification failed; verifyIncomingCall triggered callback.
+            }
+            if (checkCallDenied(callingPackageName, callingDatabaseName, callType, callback,
+                    targetUser, request.getBinderCallStartTimeMillis(), totalLatencyStartTimeMillis,
+                    /* numOperations= */ request.getBlobHandles().size())) {
+                return;
+            }
+            boolean callAccepted = mExecutorManager.executeLambdaForUserAsync(targetUser, callback,
+                    callingPackageName, callType, () -> {
+                @AppSearchResult.ResultCode int statusCode = RESULT_OK;
+                AppSearchUserInstance instance = null;
+                int operationSuccessCount = 0;
+                int operationFailureCount = 0;
+                try {
+                    AppSearchBatchResult.Builder<AppSearchBlobHandle, ParcelFileDescriptor>
+                            resultBuilder = new AppSearchBatchResult.Builder<>();
+                    instance = mAppSearchUserInstanceManager.getUserInstance(targetUser);
+                    List<AppSearchBlobHandle> blobHandles = request.getBlobHandles();
+                    for (int i = 0; i < blobHandles.size(); i++) {
+                        AppSearchBlobHandle blobHandle = blobHandles.get(i);
+                        try {
+                            ParcelFileDescriptor pfd;
+                            if (global) {
+                                boolean callerHasSystemAccess = instance.getVisibilityChecker()
+                                        .doesCallerHaveSystemAccess(callingPackageName);
+                                CallerAccess callerAccess = new FrameworkCallerAccess(
+                                        request.getCallerAttributionSource(),
+                                        callerHasSystemAccess,
+                                        /*isForEnterprise=*/ false);
+                                pfd = instance.getAppSearchImpl().globalOpenReadBlob(
+                                        blobHandle, callerAccess);
+                            } else {
+                                pfd = instance.getAppSearchImpl().openReadBlob(callingPackageName,
+                                        callingDatabaseName, blobHandle);
+                            }
+                            resultBuilder.setSuccess(blobHandle, pfd);
+                        } catch (AppSearchException | IOException e) {
+                            AppSearchResult<ParcelFileDescriptor> result =
+                                    throwableToFailedResult(e);
+                            resultBuilder.setResult(blobHandle, result);
+                            statusCode = result.getResultCode();
+                            ++operationFailureCount;
+                        }
+                    }
+                    OpenBlobForReadResponse response =
+                            new OpenBlobForReadResponse(resultBuilder.build());
+                    invokeCallbackOnResult(callback,
+                            AppSearchResultParcelV2.fromOpenBlobForReadResponse(response));
+                } catch (RuntimeException e) {
+                    ++operationFailureCount;
+                    AppSearchResult<Void> failedResult = throwableToFailedResult(e);
+                    statusCode = failedResult.getResultCode();
+                    invokeCallbackOnResult(callback,
+                            AppSearchResultParcelV2.fromFailedResult(failedResult));
+                } finally {
+                    if (instance != null) {
+                        int estimatedBinderLatencyMillis =
+                                2 * (int) (totalLatencyStartTimeMillis -
+                                        request.getBinderCallStartTimeMillis());
+                        int totalLatencyMillis =
+                                (int) (SystemClock.elapsedRealtime()
+                                        - totalLatencyStartTimeMillis);
+                        instance.getLogger().logStats(new CallStats.Builder()
+                                .setPackageName(callingPackageName)
+                                .setDatabase(request.getCallingDatabaseName())
+                                .setStatusCode(statusCode)
+                                .setCallType(callType)
+                                .setTotalLatencyMillis(totalLatencyMillis)
+                                // TODO(b/173532925) check the existing binder call latency chart
+                                // is good enough for us:
+                                // http://dashboards/view/_72c98f9a_91d9_41d4_ab9a_bc14f79742b4
+                                .setEstimatedBinderLatencyMillis(
+                                        estimatedBinderLatencyMillis)
+                                .setNumOperationsSucceeded(operationSuccessCount)
+                                .setNumOperationsFailed(operationFailureCount)
+                                .build());
+                    }
+                }
+            });
+            if (!callAccepted) {
+                logRateLimitedOrCallDeniedCallStats(
+                        callingPackageName,
+                        /* callingDatabaseName= */ null,
+                        callType,
+                        targetUser,
+                        request.getBinderCallStartTimeMillis(),
+                        totalLatencyStartTimeMillis,
+                        request.getBlobHandles().size(),
+                        RESULT_RATE_LIMITED);
+            }
+        }
+
+        @Override
+        public void setBlobVisibility(
+                SetBlobVisibilityAidlRequest request, @NonNull IAppSearchResultCallback callback) {
+            Objects.requireNonNull(request);
+            Objects.requireNonNull(callback);
+            long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
+            UserHandle targetUser =
+                    mServiceImplHelper.verifyIncomingCallWithCallback(
+                            request.getCallerAttributionSource(),
+                            request.getUserHandle(),
+                            callback);
+            String callingPackageName = request.getCallerAttributionSource().getPackageName();
+            String callingDatabaseName = request.getCallingDatabaseName();
+            if (targetUser == null) {
+                return; // Verification failed; verifyIncomingCall triggered callback.
+            }
+            if (checkCallDenied(callingPackageName, callingDatabaseName,
+                    CallStats.CALL_TYPE_SET_BLOB_VISIBILITY, callback, targetUser,
+                    request.getBinderCallStartTimeMillis(), totalLatencyStartTimeMillis,
+                    /* numOperations= */ 1)) {
+                return;
+            }
+            boolean callAccepted = mExecutorManager.executeLambdaForUserAsync(targetUser, callback,
+                    callingPackageName, CallStats.CALL_TYPE_SET_BLOB_VISIBILITY, () -> {
+                @AppSearchResult.ResultCode int statusCode = RESULT_OK;
+                AppSearchUserInstance instance = null;
+                int operationSuccessCount = 0;
+                int operationFailureCount = 0;
+                try {
+                    instance = mAppSearchUserInstanceManager.getUserInstance(targetUser);
+                    List<InternalVisibilityConfig> visibilityConfigs =
+                            request.getVisibilityConfigs();
+                    instance.getAppSearchImpl().setBlobNamespaceVisibility(
+                            callingPackageName,
+                            callingDatabaseName,
+                            visibilityConfigs);
+                    ++operationSuccessCount;
+                    invokeCallbackOnResult(callback, AppSearchResultParcelV2.fromVoid());
+                } catch (AppSearchException | RuntimeException e) {
+                    ++operationFailureCount;
+                    AppSearchResult<Void> failedResult = throwableToFailedResult(e);
+                    statusCode = failedResult.getResultCode();
+                    invokeCallbackOnResult(callback,
+                            AppSearchResultParcelV2.fromFailedResult(failedResult));
+                } finally {
+                    if (instance != null) {
+                        int estimatedBinderLatencyMillis =
+                                2 * (int) (totalLatencyStartTimeMillis -
+                                        request.getBinderCallStartTimeMillis());
+                        int totalLatencyMillis =
+                                (int) (SystemClock.elapsedRealtime()
+                                        - totalLatencyStartTimeMillis);
+                        instance.getLogger().logStats(new CallStats.Builder()
+                                .setPackageName(callingPackageName)
+                                .setDatabase(request.getCallingDatabaseName())
+                                .setCallType(CallStats.CALL_TYPE_SET_BLOB_VISIBILITY)
+                                .setStatusCode(statusCode)
+                                .setTotalLatencyMillis(totalLatencyMillis)
+                                // TODO(b/173532925) check the existing binder call latency chart
+                                // is good enough for us:
+                                // http://dashboards/view/_72c98f9a_91d9_41d4_ab9a_bc14f79742b4
+                                .setEstimatedBinderLatencyMillis(
+                                        estimatedBinderLatencyMillis)
+                                .setNumOperationsSucceeded(operationSuccessCount)
+                                .setNumOperationsFailed(operationFailureCount)
+                                .build());
+                    }
+                }
+            });
+            if (!callAccepted) {
+                logRateLimitedOrCallDeniedCallStats(
+                        callingPackageName,
+                        /* callingDatabaseName= */ null,
+                        CallStats.CALL_TYPE_SET_BLOB_VISIBILITY,
+                        targetUser,
+                        request.getBinderCallStartTimeMillis(),
+                        totalLatencyStartTimeMillis,
+                        /* numOperations= */ 1,
+                        RESULT_RATE_LIMITED);
+            }
+        }
+
         @Override
         public void search(
                 @NonNull SearchAidlRequest request,
                 @NonNull IAppSearchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            checkUnsupportedEmbeddingUse(request.getSearchSpec());
 
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
             UserHandle targetUser = mServiceImplHelper.verifyIncomingCallWithCallback(
@@ -1112,6 +1587,7 @@ public class AppSearchManagerService extends SystemService {
                 @NonNull IAppSearchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            checkUnsupportedEmbeddingUse(request.getSearchSpec());
 
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
             UserHandle targetUser = mServiceImplHelper.verifyIncomingCallWithCallback(
@@ -1379,6 +1855,7 @@ public class AppSearchManagerService extends SystemService {
                 @NonNull IAppSearchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            checkUnsupportedEmbeddingUse(request.getSearchSpec());
 
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
             UserHandle targetUser = mServiceImplHelper.verifyIncomingCallWithCallback(
@@ -1873,6 +2350,7 @@ public class AppSearchManagerService extends SystemService {
                 @NonNull IAppSearchResultCallback callback) {
             Objects.requireNonNull(request);
             Objects.requireNonNull(callback);
+            checkUnsupportedEmbeddingUse(request.getSearchSpec());
 
             long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
             UserHandle targetUser = mServiceImplHelper.verifyIncomingCallWithCallback(
@@ -2307,227 +2785,48 @@ public class AppSearchManagerService extends SystemService {
             });
         }
 
-        @Override
-        public void executeAppFunction(
-                @NonNull ExecuteAppFunctionAidlRequest request,
-                @NonNull IAppSearchResultCallback callback) {
-            Objects.requireNonNull(request);
-            Objects.requireNonNull(callback);
-
-            long totalLatencyStartTimeMillis = SystemClock.elapsedRealtime();
-
-            String callingPackageName = request.getCallerAttributionSource().getPackageName();
-            UserHandle targetUser = mServiceImplHelper.verifyIncomingCallWithCallback(
-                    request.getCallerAttributionSource(), request.getUserHandle(), callback);
-            if (targetUser == null) {
-                return;  // Verification failed; verifyIncomingCall triggered callback.
-            }
-            if (checkCallDenied(
-                    callingPackageName, /* databaseName= */ null,
-                    CallStats.CALL_TYPE_EXECUTE_APP_FUNCTION, callback, targetUser,
-                    request.getBinderCallStartTimeMillis(), totalLatencyStartTimeMillis,
-                    /* numOperations= */ 1)) {
-                return;
-            }
-
-            // Log the stats as well whenever we invoke the AppSearchResultCallback.
-            final SafeOneTimeAppSearchResultCallback safeCallback =
-                    new SafeOneTimeAppSearchResultCallback(callback, result -> {
-                        AppSearchUserInstance instance =
-                                mAppSearchUserInstanceManager.getUserInstance(targetUser);
-                        int totalLatencyMillis =
-                                (int) (SystemClock.elapsedRealtime() - totalLatencyStartTimeMillis);
-                        int estimatedBinderLatencyMillis =
-                                2 * (int) (totalLatencyStartTimeMillis
-                                        - request.getBinderCallStartTimeMillis());
-                        instance.getLogger().logStats(new CallStats.Builder()
-                                .setPackageName(callingPackageName)
-                                .setStatusCode(result.getResultCode())
-                                .setTotalLatencyMillis(totalLatencyMillis)
-                                .setCallType(CallStats.CALL_TYPE_EXECUTE_APP_FUNCTION)
-                                .setEstimatedBinderLatencyMillis(estimatedBinderLatencyMillis)
-                                .build());
-                    });
-
-            // TODO(b/327134039): Add a new policy for this in W timeframe.
-            if (mServiceImplHelper.isUserOrganizationManaged(targetUser)) {
-                safeCallback.onFailedResult(AppSearchResult.newFailedResult(
-                        RESULT_SECURITY_ERROR,
-                        "Cannot run on a device with a device owner or from the managed profile."));
-                return;
-            }
-
-            String targetPackageName = request.getClientRequest().getTargetPackageName();
-            if (TextUtils.isEmpty(targetPackageName)) {
-                safeCallback.onFailedResult(AppSearchResult.newFailedResult(
-                        RESULT_INVALID_ARGUMENT,
-                        "targetPackageName cannot be empty."));
-                return;
-            }
-            if (!verifyExecuteAppFunctionCaller(
-                    callingPackageName,
-                    targetPackageName,
-                    targetUser)) {
-                safeCallback.onFailedResult(AppSearchResult.newFailedResult(
-                        RESULT_SECURITY_ERROR,
-                        callingPackageName + " is not allowed to call executeAppFunction"));
-                return;
-            }
-
-            boolean callAccepted = mExecutorManager.executeLambdaForUserAsync(
-                    targetUser, callback, callingPackageName,
-                    CallStats.CALL_TYPE_EXECUTE_APP_FUNCTION,
-                    () -> executeAppFunctionUnchecked(
-                            request.getClientRequest(),
-                            targetUser,
-                            safeCallback));
-            if (!callAccepted) {
-                logRateLimitedOrCallDeniedCallStats(callingPackageName, /* databaseName= */ null,
-                        CallStats.CALL_TYPE_EXECUTE_APP_FUNCTION, targetUser,
-                        request.getBinderCallStartTimeMillis(), totalLatencyStartTimeMillis,
-                        /*numOperations=*/ 1, RESULT_RATE_LIMITED);
-            }
-        }
-
-        /**
-         * The same as {@link #executeAppFunction}, except this is without the caller check.
-         * This method runs on the user-local thread pool.
-         */
-        @WorkerThread
-        private void executeAppFunctionUnchecked(
-                @NonNull ExecuteAppFunctionRequest request,
-                @NonNull UserHandle userHandle,
-                @NonNull SafeOneTimeAppSearchResultCallback safeCallback) {
-            Intent serviceIntent = new Intent(AppFunctionService.SERVICE_INTERFACE);
-            serviceIntent.setPackage(request.getTargetPackageName());
-
-            Context userContext = mAppSearchEnvironment.createContextAsUser(mContext, userHandle);
-            ResolveInfo resolveInfo = userContext.getPackageManager()
-                    .resolveService(serviceIntent, 0);
-            if (resolveInfo == null || resolveInfo.serviceInfo == null) {
-                safeCallback.onFailedResult(AppSearchResult.newFailedResult(
-                        RESULT_NOT_FOUND, "Cannot find the target service."));
-                return;
-            }
-            ServiceInfo serviceInfo = resolveInfo.serviceInfo;
-            // TODO(b/359911502): Commenting out this permission check since the
-            //   BIND_APP_FUNCTION_SERVICE permission is deleted from app search.
-            //   This whole app function functionality should be removed once the new app function
-            //   manager is submitted.
-            // if (!PERMISSION_BIND_APP_FUNCTION_SERVICE.equals(serviceInfo.permission)) {
-            //     safeCallback.onFailedResult(AppSearchResult.newFailedResult(
-            //             RESULT_NOT_FOUND,
-            //             "Failed to find a valid target service. The resolved service is missing "
-            //                     + "the BIND_APP_FUNCTION_SERVICE permission."));
-            //     return;
-            // }
-            serviceIntent.setComponent(
-                    new ComponentName(serviceInfo.packageName, serviceInfo.name));
-
-            if (request.getSha256Certificate() != null) {
-                if (!PackageManagerUtil.hasSigningCertificate(
-                        mContext, request.getTargetPackageName(), request.getSha256Certificate())) {
-                    safeCallback.onFailedResult(
-                            AppSearchResult.newFailedResult(
-                                    RESULT_NOT_FOUND, "Cannot find the target service"));
-                    return;
-                }
-            }
-
-            boolean bindServiceResult = mAppFunctionServiceCallHelper.runServiceCall(
-                    serviceIntent,
-                    Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS | Context.BIND_AUTO_CREATE,
-                    mAppSearchConfig.getAppFunctionCallTimeoutMillis(),
-                    userHandle,
-                    new ServiceCallHelper.RunServiceCallCallback<>() {
-                        @Override
-                        public void onServiceConnected(
-                                @NonNull IAppFunctionService service,
-                                @NonNull ServiceUsageCompleteListener completeListener) {
-                            try {
-                                service.executeAppFunction(
-                                        request,
-                                        new IAppSearchResultCallback.Stub() {
-                                            @Override
-                                            public void onResult(
-                                                    AppSearchResultParcel resultParcel) {
-                                                safeCallback.onResult(resultParcel);
-                                                completeListener.onCompleted();
-                                            }
-                                        });
-                            } catch (Exception e) {
-                                safeCallback.onFailedResult(AppSearchResult
-                                        .throwableToFailedResult(e));
-                                completeListener.onCompleted();
-                            }
-                        }
-
-                        @Override
-                        public void onFailedToConnect() {
-                            safeCallback.onFailedResult(
-                                    AppSearchResult.newFailedResult(RESULT_INTERNAL_ERROR, null));
-                        }
-
-                        @Override
-                        public void onTimedOut() {
-                            safeCallback.onFailedResult(
-                                    AppSearchResult.newFailedResult(RESULT_TIMED_OUT, null));
-                        }
-                    });
-            if (!bindServiceResult) {
-                safeCallback.onFailedResult(AppSearchResult.newFailedResult(
-                        RESULT_INTERNAL_ERROR, "Failed to bind the target service."));
+        @BinderThread
+        private void dumpContactsIndexer(@NonNull PrintWriter pw, boolean verbose) {
+            Objects.requireNonNull(pw);
+            UserHandle currentUser = UserHandle.getUserHandleForUid(Binder.getCallingUid());
+            try {
+                pw.println("ContactsIndexer stats for " + currentUser);
+                mLifecycle.dumpContactsIndexerForUser(currentUser, pw, verbose);
+            } catch (Exception e) {
+                String errorMessage =
+                        "Unable to dump the internal contacts indexer state for the user: "
+                                + currentUser;
+                Log.e(TAG, errorMessage, e);
+                pw.println(errorMessage);
             }
         }
 
-        /**
-         * Determines whether the caller is authorized to execute an app function via
-         * {@link #executeAppFunction}.
-         * <p>
-         * Authorization is granted under the following conditions:
-         * <ul>
-         *     <li>The caller is the same app that owns the target function.</li>
-         *     <li>The caller possesses the SYSTEM_UI_INTELLIGENCE role for the target user. </li>
-         * </ul>
-         *
-         * @param callingPackage The validated package name of the calling app.
-         * @param targetPackage  The package name of the target app.
-         * @param targetUser     The target user.
-         * @return               {@code true} if the caller is authorized, {@code false} otherwise.
-         */
-        private boolean verifyExecuteAppFunctionCaller(
-                @NonNull String callingPackage,
-                @NonNull String targetPackage,
-                @NonNull UserHandle targetUser) {
-            // While adding new system role-based permissions through mainline updates is possible,
-            // granting them to system apps in previous android versions is not. System apps must
-            // request permissions in their prebuilt APKs included in the system image. We cannot
-            // modify prebuilts in older images anymore.
-            // TODO(b/327134039): Enforce permission checking for Android V+ or W+, depending on
-            // whether the new prebuilt can be included in the system image on time.
-            if (callingPackage.equals(targetPackage)) {
-                return true;
-            }
-            long originalToken = Binder.clearCallingIdentity();
+        @BinderThread
+        private void dumpAppsIndexer(@NonNull PrintWriter pw) {
+            Objects.requireNonNull(pw);
+            UserHandle currentUser = UserHandle.getUserHandleForUid(Binder.getCallingUid());
             try {
-                List<String> systemUiIntelligencePackages =
-                        mRoleManager.getRoleHoldersAsUser(SYSTEM_UI_INTELLIGENCE, targetUser);
-                return systemUiIntelligencePackages.contains(callingPackage);
-            } finally {
-                Binder.restoreCallingIdentity(originalToken);
+                pw.println("AppsIndexer stats for " + currentUser);
+                mLifecycle.dumpAppsIndexerForUser(currentUser, pw);
+            } catch (Exception e) {
+                String errorMessage =
+                        "Unable to dump the internal app indexer state for the user: "
+                                + currentUser;
+                Log.e(TAG, errorMessage, e);
+                pw.println(errorMessage);
             }
         }
 
         @BinderThread
-        private void dumpContactsIndexer(@NonNull PrintWriter pw, boolean verbose) {
+        private void dumpAppOpenEventIndexer(@NonNull PrintWriter pw) {
             Objects.requireNonNull(pw);
             UserHandle currentUser = UserHandle.getUserHandleForUid(Binder.getCallingUid());
             try {
-                pw.println("ContactsIndexer stats for " + currentUser);
-                mLifecycle.dumpContactsIndexerForUser(currentUser, pw, verbose);
+                pw.println("AppOpenEventIndexer stats for " + currentUser);
+                mLifecycle.dumpAppOpenEventIndexerForUser(currentUser, pw);
             } catch (Exception e) {
                 String errorMessage =
-                        "Unable to dump the internal contacts indexer state for the user: "
+                        "Unable to dump the internal app open event indexer state for the user: "
                                 + currentUser;
                 Log.e(TAG, errorMessage, e);
                 pw.println(errorMessage);
@@ -2606,6 +2905,8 @@ public class AppSearchManagerService extends SystemService {
             }
             dumpAppSearch(pw, verbose);
             dumpContactsIndexer(pw, verbose);
+            dumpAppsIndexer(pw);
+            dumpAppOpenEventIndexer(pw);
         }
     }
 
@@ -2838,6 +3139,46 @@ public class AppSearchManagerService extends SystemService {
                         .build());
     }
 
+    private void checkUnsupportedEmbeddingUse(@NonNull List<AppSearchSchema> schemas) {
+        // Embedding support currently only allowed on W+. This is because embedding properties are
+        // a rollback compatibility issue. Therefore, we cannot allow it to be used on devices that
+        // could be rolled back to a pre-Embedding binary until we have landed rollback
+        // compatibility work.
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.BAKLAVA) {
+            return;
+        }
+        for (int i = 0; i < schemas.size(); ++i) {
+            AppSearchSchema schema = schemas.get(i);
+            List<AppSearchSchema.PropertyConfig> properties = schema.getProperties();
+            for (int j = 0; j < properties.size(); ++j) {
+                AppSearchSchema.PropertyConfig property = properties.get(j);
+                if (property instanceof AppSearchSchema.EmbeddingPropertyConfig) {
+                    throw new UnsupportedOperationException(
+                            "SCHEMA_EMBEDDING_PROPERTY_CONFIG is not available on this AppSearch "
+                                    + "implementation.");
+                }
+            }
+        }
+    }
+
+    private void checkUnsupportedEmbeddingUse(@NonNull SearchSpec spec) {
+        // Embedding support currently only allowed on W+. This is because embedding properties are
+        // a rollback compatibility issue. Therefore, we cannot allow it to be used on devices that
+        // could be rolled back to a pre-Embedding binary until we have landed rollback
+        // compatibility work.
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.BAKLAVA) {
+            return;
+        }
+        if (!spec.getEmbeddingParameters().isEmpty()) {
+            throw new UnsupportedOperationException(
+                    "SCHEMA_EMBEDDING_PROPERTY_CONFIG is not available on this AppSearch "
+                            + "implementation.");
+        }
+        if (spec.getJoinSpec() != null) {
+            checkUnsupportedEmbeddingUse(spec.getJoinSpec().getNestedSearchSpec());
+        }
+    }
+
     /**
      * Checks if an API call for a given calling package and calling database should be denied
      * according to the denylist. If the call is denied, also logs the denial through CallStats.
diff --git a/service/java/com/android/server/appsearch/AppSearchModule.java b/service/java/com/android/server/appsearch/AppSearchModule.java
index a2463fa6..12b55c04 100644
--- a/service/java/com/android/server/appsearch/AppSearchModule.java
+++ b/service/java/com/android/server/appsearch/AppSearchModule.java
@@ -17,6 +17,7 @@
 package com.android.server.appsearch;
 
 import static com.android.server.appsearch.indexer.IndexerMaintenanceConfig.APPS_INDEXER;
+import static com.android.server.appsearch.indexer.IndexerMaintenanceConfig.APP_OPEN_EVENT_INDEXER;
 import static com.android.server.appsearch.indexer.IndexerMaintenanceConfig.CONTACTS_INDEXER;
 
 import android.annotation.BinderThread;
@@ -31,8 +32,11 @@ import android.util.Log;
 import com.android.appsearch.flags.Flags;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.SystemService;
+import com.android.server.appsearch.appsindexer.AppOpenEventIndexerConfig;
+import com.android.server.appsearch.appsindexer.AppOpenEventIndexerManagerService;
 import com.android.server.appsearch.appsindexer.AppsIndexerConfig;
 import com.android.server.appsearch.appsindexer.AppsIndexerManagerService;
+import com.android.server.appsearch.appsindexer.FrameworkAppOpenEventIndexerConfig;
 import com.android.server.appsearch.appsindexer.FrameworkAppsIndexerConfig;
 import com.android.server.appsearch.contactsindexer.ContactsIndexerConfig;
 import com.android.server.appsearch.contactsindexer.ContactsIndexerManagerService;
@@ -53,6 +57,9 @@ public class AppSearchModule {
 
         @VisibleForTesting @Nullable AppsIndexerManagerService mAppsIndexerManagerService;
 
+        @VisibleForTesting @Nullable
+        AppOpenEventIndexerManagerService mAppOpenEventIndexerManagerService;
+
         public Lifecycle(Context context) {
             super(context);
         }
@@ -87,6 +94,16 @@ public class AppSearchModule {
             return new ContactsIndexerManagerService(context, config);
         }
 
+        /** Added primarily for testing purposes. */
+        @VisibleForTesting
+        @NonNull
+        AppOpenEventIndexerManagerService createAppOpenEventIndexerManagerService(
+                @NonNull Context context, @NonNull AppOpenEventIndexerConfig config) {
+            Objects.requireNonNull(context);
+            Objects.requireNonNull(config);
+            return new AppOpenEventIndexerManagerService(context, config);
+        }
+
         @Override
         public void onStart() {
             mAppSearchManagerService =
@@ -138,6 +155,27 @@ public class AppSearchModule {
             } else if (LogUtil.INFO) {
                 Log.i(TAG, "AppsIndexer service is disabled.");
             }
+
+            AppOpenEventIndexerConfig appOpenEventIndexerConfig =
+                    new FrameworkAppOpenEventIndexerConfig();
+            // Flags.appOpenEventIndexerEnabled will be rolled out through gantry, and this check
+            // will be removed once it is fully rolled out.
+            // appOpenEventIndexerConfig.isAppOpenEventIndexerEnabled checks DeviceConfig, so we can
+            // keep this check here in case we need to turn off app open event indexer.
+            if (Flags.appOpenEventIndexerEnabled()
+                    && appOpenEventIndexerConfig.isAppOpenEventIndexerEnabled()) {
+                mAppOpenEventIndexerManagerService =
+                        createAppOpenEventIndexerManagerService(
+                                getContext(), appOpenEventIndexerConfig);
+                try {
+                    mAppOpenEventIndexerManagerService.onStart();
+                } catch (Throwable t) {
+                    Log.e(TAG, "Failed to start app open event indexer service", t);
+                    mAppOpenEventIndexerManagerService = null;
+                }
+            } else if (LogUtil.INFO) {
+                Log.i(TAG, "AppOpenEventIndexer service is disabled.");
+            }
         }
 
         /** Dumps ContactsIndexer internal state for the user. */
@@ -160,6 +198,16 @@ public class AppSearchModule {
             }
         }
 
+        @BinderThread
+        void dumpAppOpenEventIndexerForUser(
+                @NonNull UserHandle userHandle, @NonNull PrintWriter pw) {
+            if (mAppOpenEventIndexerManagerService != null) {
+                mAppOpenEventIndexerManagerService.dumpAppOpenEventIndexerForUser(userHandle, pw);
+            } else {
+                pw.println("No dumpsys for AppOpenEventIndexer as it is disabled");
+            }
+        }
+
         @Override
         public void onBootPhase(int phase) {
             mAppSearchManagerService.onBootPhase(phase);
@@ -181,6 +229,15 @@ public class AppSearchModule {
             } else {
                 mAppsIndexerManagerService.onUserUnlocking(user);
             }
+
+            if (mAppOpenEventIndexerManagerService == null) {
+                IndexerMaintenanceService.cancelUpdateJobIfScheduled(
+                        getContext(), user.getUserHandle(), APP_OPEN_EVENT_INDEXER);
+            } else {
+                // App Open Event Indexer only schedules a periodic update job on user unlock and
+                // does not run an update
+                mAppOpenEventIndexerManagerService.onUserUnlocking(user);
+            }
         }
 
         @Override
@@ -192,6 +249,9 @@ public class AppSearchModule {
             if (mAppsIndexerManagerService != null) {
                 mAppsIndexerManagerService.onUserStopping(user);
             }
+            if (mAppOpenEventIndexerManagerService != null) {
+                mAppOpenEventIndexerManagerService.onUserStopping(user);
+            }
         }
     }
 }
diff --git a/service/java/com/android/server/appsearch/AppSearchUserInstanceManager.java b/service/java/com/android/server/appsearch/AppSearchUserInstanceManager.java
index 63969432..6c5bf777 100644
--- a/service/java/com/android/server/appsearch/AppSearchUserInstanceManager.java
+++ b/service/java/com/android/server/appsearch/AppSearchUserInstanceManager.java
@@ -27,6 +27,7 @@ import android.os.UserHandle;
 import android.util.ArrayMap;
 import android.util.Log;
 
+import com.android.appsearch.flags.Flags;
 import com.android.internal.annotations.GuardedBy;
 import com.android.server.appsearch.external.localstorage.AppSearchImpl;
 import com.android.server.appsearch.external.localstorage.stats.InitializeStats;
@@ -226,12 +227,18 @@ public final class AppSearchUserInstanceManager {
         }
         VisibilityChecker visibilityCheckerImpl =
                 AppSearchComponentFactory.createVisibilityCheckerInstance(userContext);
+        FrameworkRevocableFileDescriptorStore frameworkRevocableFileDescriptorStore = null;
+        if (Flags.enableBlobStore()) {
+            frameworkRevocableFileDescriptorStore =
+                    new FrameworkRevocableFileDescriptorStore(userContext, config);
+        }
         AppSearchImpl appSearchImpl =
                 AppSearchImpl.create(
                         icingDir,
                         config,
                         initStatsBuilder,
                         visibilityCheckerImpl,
+                        frameworkRevocableFileDescriptorStore,
                         new ServiceOptimizeStrategy(config));
 
         // Update storage info file
diff --git a/service/java/com/android/server/appsearch/FrameworkRevocableFileDescriptorStore.java b/service/java/com/android/server/appsearch/FrameworkRevocableFileDescriptorStore.java
new file mode 100644
index 00000000..bc77ac13
--- /dev/null
+++ b/service/java/com/android/server/appsearch/FrameworkRevocableFileDescriptorStore.java
@@ -0,0 +1,331 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch;
+
+import android.annotation.NonNull;
+import android.app.appsearch.AppSearchResult;
+import android.app.appsearch.exceptions.AppSearchException;
+import android.content.Context;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.ParcelFileDescriptor;
+import android.os.ProxyFileDescriptorCallback;
+import android.os.storage.StorageManager;
+import android.system.ErrnoException;
+import android.system.Os;
+import android.system.OsConstants;
+import android.util.ArrayMap;
+
+import com.android.internal.annotations.GuardedBy;
+import com.android.server.appsearch.external.localstorage.RevocableFileDescriptorStore;
+
+import libcore.io.IoUtils;
+
+import java.io.FileDescriptor;
+import java.io.IOException;
+import java.io.InterruptedIOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+
+/**
+ * The Framework implementation of {@link RevocableFileDescriptorStore}.
+ *
+ * <p>We need to pass {@link ParcelFileDescriptor} cross binder to the SDK side in the framework.
+ * When sending a {@link ParcelFileDescriptor} cross the binder, the system will generate a
+ * duplicate {@link ParcelFileDescriptor} and pass that dup to the other process. AppSearch will
+ * lose the control of that dup. We need wrap the {@link ParcelFileDescriptor} to a {@link
+ * FrameworkRevocableFileDescriptor} to give us the ability the control the sending {@link
+ * ParcelFileDescriptor}.
+ *
+ * <p>This class needs {@link ProxyFileDescriptorCallback} and a {@link Handler} to build revocable
+ * file descriptors in AppSearch's server. Those could allow AppSearch's server side retain control
+ * of the original {@link ParcelFileDescriptor} and generate a revocable {@link
+ * ParcelFileDescriptor}. This RevocableFileDescriptor will be sent to the client. All operations
+ * performed on the RevocableFileDescriptor will not directly affect the actual file. Instead,
+ * AppSearch will monitor these operations on the RevocableFileDescriptor and apply them to the
+ * actual file. Consequently, AppSearch can revoke and disable the RevocableFileDescriptor on the
+ * client side at any time. These is not needed in the Jetpack since sent {@link
+ * ParcelFileDescriptor} to caller won't cross the Binder.
+ */
+public class FrameworkRevocableFileDescriptorStore implements RevocableFileDescriptorStore {
+    private static final Object sLock = new Object();
+    // The name of the background thread for close listeners to run.
+    private static final String HANDLER_NAME = "AppSearchBlobCloseListener";
+
+    @GuardedBy("sLock")
+    private static volatile Handler sRevocableFdHandler;
+
+    /**
+     * By default, when using a RevocableFileDescriptor, callbacks will be sent to the process' main
+     * looper. In this case that would be system_server's main looper, which is a heavily contended
+     * thread. It can also cause deadlocks, because the volume daemon 'vold' holds a lock while
+     * making these callbacks to the system_server, while at the same time the system_server main
+     * thread can make a call into vold, which requires that same vold lock. To avoid these issues,
+     * use a separate thread for the RevocableFileDescriptor's requests, so that it can make
+     * progress independently of system_server.
+     */
+    @NonNull
+    static Handler getRevocableFdHandler() {
+        synchronized (sLock) {
+            if (sRevocableFdHandler != null) {
+                return sRevocableFdHandler;
+            }
+            final HandlerThread t = new HandlerThread(HANDLER_NAME);
+            t.start();
+            sRevocableFdHandler = new Handler(t.getLooper());
+
+            return sRevocableFdHandler;
+        }
+    }
+
+    @GuardedBy("sLock")
+    // <packageName, List<sent fds> map to tracking all sent fds.
+    private final Map<String, List<FrameworkRevocableFileDescriptor>>
+            mSentAppSearchParcelFileDescriptorsLocked = new ArrayMap<>();
+
+    @NonNull private final Context mContext;
+
+    @NonNull private final ServiceAppSearchConfig mConfig;
+
+    public FrameworkRevocableFileDescriptorStore(
+            @NonNull Context context, @NonNull ServiceAppSearchConfig config) {
+        mContext = Objects.requireNonNull(context);
+        mConfig = Objects.requireNonNull(config);
+    }
+
+    /**
+     * Wraps the given {@link ParcelFileDescriptor} to {@link FrameworkRevocableFileDescriptor} to
+     * allow AppSearch to control the sending {@link ParcelFileDescriptor}'s life cycle.
+     *
+     * <p>AppSearch will retain control of the original {@link ParcelFileDescriptor} and generate a
+     * revocable {@link ParcelFileDescriptor} using {@link
+     * FrameworkRevocableFileDescriptor#getRevocableFileDescriptor()}. This RevocableFileDescriptor
+     * will be sent to the client. All operations performed on the RevocableFileDescriptor will not
+     * directly affect the actual file. Instead, AppSearch will monitor these operations on the
+     * RevocableFileDescriptor and apply them to the actual file. Consequently, AppSearch can revoke
+     * and disable the RevocableFileDescriptor on the client side at any time.
+     *
+     * @param packageName The package name requesting the revocable file descriptor.
+     * @param parcelFileDescriptor The original ParcelFileDescriptor to be wrapped.
+     */
+    @NonNull
+    @Override
+    public ParcelFileDescriptor wrapToRevocableFileDescriptor(
+            @NonNull String packageName, ParcelFileDescriptor parcelFileDescriptor)
+            throws IOException {
+        FrameworkRevocableFileDescriptor revocableFileDescriptor =
+                new FrameworkRevocableFileDescriptor(
+                        mContext,
+                        parcelFileDescriptor.getFileDescriptor(),
+                        getRevocableFdHandler());
+        addOnCloseListener(revocableFileDescriptor, packageName);
+        addToSentAppSearchParcelFileDescriptorMap(revocableFileDescriptor, packageName);
+        return revocableFileDescriptor.getRevocableFileDescriptor();
+    }
+
+    @Override
+    public void revokeAll() throws IOException {
+        synchronized (sLock) {
+            for (String packageName : mSentAppSearchParcelFileDescriptorsLocked.keySet()) {
+                revokeForPackage(packageName);
+            }
+        }
+    }
+
+    @Override
+    public void revokeForPackage(@NonNull String packageName) throws IOException {
+        synchronized (sLock) {
+            List<FrameworkRevocableFileDescriptor> rfds =
+                    mSentAppSearchParcelFileDescriptorsLocked.get(packageName);
+            if (rfds != null) {
+                for (int i = rfds.size() - 1; i >= 0; i--) {
+                    rfds.get(i).revoke();
+                }
+            }
+        }
+    }
+
+    @Override
+    public void checkBlobStoreLimit(@NonNull String packageName) throws AppSearchException {
+        synchronized (sLock) {
+            List<FrameworkRevocableFileDescriptor> rfdsForPackage =
+                    mSentAppSearchParcelFileDescriptorsLocked.get(packageName);
+            if (rfdsForPackage == null) {
+                return;
+            }
+            if (rfdsForPackage.size() >= mConfig.getMaxOpenBlobCount()) {
+                throw new AppSearchException(
+                        AppSearchResult.RESULT_OUT_OF_SPACE,
+                        "Package \""
+                                + packageName
+                                + "\" exceeded limit of "
+                                + mConfig.getMaxOpenBlobCount()
+                                + " opened file descriptors. Some file descriptors "
+                                + "must be closed to open additional ones.");
+            }
+        }
+    }
+
+    private void addOnCloseListener(
+            @NonNull FrameworkRevocableFileDescriptor revocableFileDescriptor,
+            @NonNull String packageName) {
+        revocableFileDescriptor.addOnCloseListener(
+                e -> {
+                    synchronized (sLock) {
+                        List<FrameworkRevocableFileDescriptor> fdsForPackage =
+                                mSentAppSearchParcelFileDescriptorsLocked.get(packageName);
+                        if (fdsForPackage != null) {
+                            fdsForPackage.remove(revocableFileDescriptor);
+                            if (fdsForPackage.isEmpty()) {
+                                mSentAppSearchParcelFileDescriptorsLocked.remove(packageName);
+                            }
+                        }
+                    }
+                });
+    }
+
+    private void addToSentAppSearchParcelFileDescriptorMap(
+            @NonNull FrameworkRevocableFileDescriptor revocableFileDescriptor,
+            @NonNull String packageName) {
+        synchronized (sLock) {
+            List<FrameworkRevocableFileDescriptor> rfdsForPackage =
+                    mSentAppSearchParcelFileDescriptorsLocked.get(packageName);
+            if (rfdsForPackage == null) {
+                rfdsForPackage = new ArrayList<>();
+                mSentAppSearchParcelFileDescriptorsLocked.put(packageName, rfdsForPackage);
+            }
+            rfdsForPackage.add(revocableFileDescriptor);
+        }
+    }
+
+    /**
+     * The Variant of {@link ParcelFileDescriptor} that allows its creator to revoke all access to
+     * the underlying resource.
+     *
+     * <p>This is useful when the code that originally opened a file needs to strongly assert that
+     * any clients are completely hands-off for security purposes.
+     *
+     * <p>Copy from frameworks/base/core/java/android/os/RevocableFileDescriptor.java. We cannot use
+     * the RevocableFileDescriptor directly because it is not a public API.
+     */
+    static class FrameworkRevocableFileDescriptor {
+        private ParcelFileDescriptor.OnCloseListener mOnCloseListener;
+
+        private final FileDescriptor mInner;
+        private final ParcelFileDescriptor mOuter;
+
+        private volatile boolean mRevoked;
+
+        FrameworkRevocableFileDescriptor(
+                @NonNull Context context, @NonNull FileDescriptor fd, @NonNull Handler handler)
+                throws IOException {
+            mInner = fd;
+            StorageManager sm = context.getSystemService(StorageManager.class);
+            mOuter =
+                    sm.openProxyFileDescriptor(
+                            ParcelFileDescriptor.MODE_READ_WRITE, mCallback, handler);
+        }
+
+        ParcelFileDescriptor getRevocableFileDescriptor() {
+            return mOuter;
+        }
+
+        /**
+         * Revoke all future access to the {@link ParcelFileDescriptor} returned by {@link
+         * #getRevocableFileDescriptor()}. From this point forward, all operations will fail with
+         * {@link OsConstants#EPERM}.
+         */
+        void revoke() {
+            mRevoked = true;
+            IoUtils.closeQuietly(mInner);
+        }
+
+        /**
+         * Callback for indicating that {@link ParcelFileDescriptor} passed to the client process
+         * ({@link #getRevocableFileDescriptor()}) has been closed.
+         */
+        void addOnCloseListener(ParcelFileDescriptor.OnCloseListener onCloseListener) {
+            mOnCloseListener = onCloseListener;
+        }
+
+        public boolean isRevoked() {
+            return mRevoked;
+        }
+
+        private final ProxyFileDescriptorCallback mCallback =
+                new ProxyFileDescriptorCallback() {
+                    private void checkRevoked() throws ErrnoException {
+                        if (mRevoked) {
+                            throw new ErrnoException("TAG", OsConstants.EPERM);
+                        }
+                    }
+
+                    @Override
+                    public long onGetSize() throws ErrnoException {
+                        checkRevoked();
+                        return Os.fstat(mInner).st_size;
+                    }
+
+                    @Override
+                    public int onRead(long offset, int size, byte[] data) throws ErrnoException {
+                        checkRevoked();
+                        int n = 0;
+                        while (n < size) {
+                            try {
+                                n += Os.pread(mInner, data, n, size - n, offset + n);
+                                break;
+                            } catch (InterruptedIOException e) {
+                                n += e.bytesTransferred;
+                            }
+                        }
+                        return n;
+                    }
+
+                    @Override
+                    public int onWrite(long offset, int size, byte[] data) throws ErrnoException {
+                        checkRevoked();
+                        int n = 0;
+                        while (n < size) {
+                            try {
+                                n += Os.pwrite(mInner, data, n, size - n, offset + n);
+                                break;
+                            } catch (InterruptedIOException e) {
+                                n += e.bytesTransferred;
+                            }
+                        }
+                        return n;
+                    }
+
+                    @Override
+                    public void onFsync() throws ErrnoException {
+                        checkRevoked();
+                        Os.fsync(mInner);
+                    }
+
+                    @Override
+                    public void onRelease() {
+                        mRevoked = true;
+                        IoUtils.closeQuietly(mInner);
+                        if (mOnCloseListener != null) {
+                            mOnCloseListener.onClose(null);
+                        }
+                    }
+                };
+    }
+}
diff --git a/service/java/com/android/server/appsearch/FrameworkServiceAppSearchConfig.java b/service/java/com/android/server/appsearch/FrameworkServiceAppSearchConfig.java
index 1467cadb..21f44629 100644
--- a/service/java/com/android/server/appsearch/FrameworkServiceAppSearchConfig.java
+++ b/service/java/com/android/server/appsearch/FrameworkServiceAppSearchConfig.java
@@ -66,8 +66,10 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
             "sampling_interval_for_optimize_stats";
     public static final String KEY_LIMIT_CONFIG_MAX_DOCUMENT_SIZE_BYTES =
             "limit_config_max_document_size_bytes";
-    public static final String KEY_LIMIT_CONFIG_MAX_DOCUMENT_COUNT =
-            "limit_config_max_document_count";
+    public static final String KEY_LIMIT_CONFIG_PER_PACKAGE_DOCUMENT_COUNT_LIMIT =
+            "limit_config_per_package_document_count_limit";
+    public static final String KEY_LIMIT_CONFIG_DOCUMENT_COUNT_LIMIT_START_THRESHOLD =
+            "limit_config_document_count_limit_start_threshold";
     public static final String KEY_LIMIT_CONFIG_MAX_SUGGESTION_COUNT =
             "limit_config_max_suggestion_count";
     public static final String KEY_BYTES_OPTIMIZE_THRESHOLD = "bytes_optimize_threshold";
@@ -109,6 +111,8 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
     public static final String KEY_APP_FUNCTION_CALL_TIMEOUT_MILLIS =
             "app_function_call_timeout_millis";
     public static final String KEY_FULLY_PERSIST_JOB_INTERVAL = "fully_persist_job_interval";
+    public static final String KEY_MAX_OPEN_BLOB_COUNT = "max_open_blob_count";
+    public static final String KEY_ORPHAN_BLOB_TIME_TO_LIVE_MS = "orphan_blob_time_to_live_ms";
 
     /**
      * This config does not need to be cached in FrameworkServiceAppSearchConfig as it is only
@@ -127,7 +131,8 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
         KEY_SAMPLING_INTERVAL_FOR_GLOBAL_SEARCH_STATS,
         KEY_SAMPLING_INTERVAL_FOR_OPTIMIZE_STATS,
         KEY_LIMIT_CONFIG_MAX_DOCUMENT_SIZE_BYTES,
-        KEY_LIMIT_CONFIG_MAX_DOCUMENT_COUNT,
+        KEY_LIMIT_CONFIG_PER_PACKAGE_DOCUMENT_COUNT_LIMIT,
+        KEY_LIMIT_CONFIG_DOCUMENT_COUNT_LIMIT_START_THRESHOLD,
         KEY_LIMIT_CONFIG_MAX_SUGGESTION_COUNT,
         KEY_BYTES_OPTIMIZE_THRESHOLD,
         KEY_TIME_OPTIMIZE_THRESHOLD_MILLIS,
@@ -155,7 +160,9 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
         KEY_USE_NEW_QUALIFIED_ID_JOIN_INDEX,
         KEY_BUILD_PROPERTY_EXISTENCE_METADATA_HITS,
         KEY_APP_FUNCTION_CALL_TIMEOUT_MILLIS,
-        KEY_FULLY_PERSIST_JOB_INTERVAL
+        KEY_FULLY_PERSIST_JOB_INTERVAL,
+        KEY_MAX_OPEN_BLOB_COUNT,
+        KEY_ORPHAN_BLOB_TIME_TO_LIVE_MS
     };
 
     // Lock needed for all the operations in this class.
@@ -360,11 +367,22 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
     }
 
     @Override
-    public int getMaxDocumentCount() {
+    public int getPerPackageDocumentCountLimit() {
         synchronized (mLock) {
             throwIfClosedLocked();
             return mBundleLocked.getInt(
-                    KEY_LIMIT_CONFIG_MAX_DOCUMENT_COUNT, DEFAULT_LIMIT_CONFIG_MAX_DOCUMENT_COUNT);
+                    KEY_LIMIT_CONFIG_PER_PACKAGE_DOCUMENT_COUNT_LIMIT,
+                    DEFAULT_LIMIT_CONFIG_PER_PACKAGE_DOCUMENT_COUNT_LIMIT);
+        }
+    }
+
+    @Override
+    public int getDocumentCountLimitStartThreshold() {
+        synchronized (mLock) {
+            throwIfClosedLocked();
+            return mBundleLocked.getInt(
+                    KEY_LIMIT_CONFIG_DOCUMENT_COUNT_LIMIT_START_THRESHOLD,
+                    DEFAULT_LIMIT_CONFIG_DOCUMENT_COUNT_LIMIT_START_THRESHOLD);
         }
     }
 
@@ -378,6 +396,14 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
         }
     }
 
+    @Override
+    public int getMaxOpenBlobCount() {
+        synchronized (mLock) {
+            throwIfClosedLocked();
+            return mBundleLocked.getInt(KEY_MAX_OPEN_BLOB_COUNT, DEFAULT_MAX_OPEN_BLOB_COUNT);
+        }
+    }
+
     @Override
     public int getCachedBytesOptimizeThreshold() {
         synchronized (mLock) {
@@ -603,6 +629,15 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
         return true;
     }
 
+    @Override
+    public long getOrphanBlobTimeToLiveMs() {
+        synchronized (mLock) {
+            throwIfClosedLocked();
+            return mBundleLocked.getLong(
+                    KEY_ORPHAN_BLOB_TIME_TO_LIVE_MS, DEFAULT_ORPHAN_BLOB_TIME_TO_LIVE_MS);
+        }
+    }
+
     @Override
     public boolean shouldStoreParentInfoAsSyntheticProperty() {
         // This option is always true in Framework.
@@ -673,10 +708,21 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
                             properties.getInt(key, DEFAULT_LIMIT_CONFIG_MAX_DOCUMENT_SIZE_BYTES));
                 }
                 break;
-            case KEY_LIMIT_CONFIG_MAX_DOCUMENT_COUNT:
+            case KEY_LIMIT_CONFIG_PER_PACKAGE_DOCUMENT_COUNT_LIMIT:
                 synchronized (mLock) {
                     mBundleLocked.putInt(
-                            key, properties.getInt(key, DEFAULT_LIMIT_CONFIG_MAX_DOCUMENT_COUNT));
+                            key,
+                            properties.getInt(
+                                    key, DEFAULT_LIMIT_CONFIG_PER_PACKAGE_DOCUMENT_COUNT_LIMIT));
+                }
+                break;
+            case KEY_LIMIT_CONFIG_DOCUMENT_COUNT_LIMIT_START_THRESHOLD:
+                synchronized (mLock) {
+                    mBundleLocked.putInt(
+                            key,
+                            properties.getInt(
+                                    key,
+                                    DEFAULT_LIMIT_CONFIG_DOCUMENT_COUNT_LIMIT_START_THRESHOLD));
                 }
                 break;
             case KEY_LIMIT_CONFIG_MAX_SUGGESTION_COUNT:
@@ -877,6 +923,17 @@ public final class FrameworkServiceAppSearchConfig implements ServiceAppSearchCo
                             key, properties.getLong(key, DEFAULT_FULLY_PERSIST_JOB_INTERVAL));
                 }
                 break;
+            case KEY_ORPHAN_BLOB_TIME_TO_LIVE_MS:
+                synchronized (mLock) {
+                    mBundleLocked.putLong(
+                            key, properties.getLong(key, DEFAULT_ORPHAN_BLOB_TIME_TO_LIVE_MS));
+                }
+                break;
+            case KEY_MAX_OPEN_BLOB_COUNT:
+                synchronized (mLock) {
+                    mBundleLocked.putInt(key, properties.getInt(key, DEFAULT_MAX_OPEN_BLOB_COUNT));
+                }
+                break;
             case KEY_BUILD_PROPERTY_EXISTENCE_METADATA_HITS:
                 // TODO(b/309826655) Set this value properly in main branch
                 // fall throw to default since we never turn this feature on in udc-mainline-prod
diff --git a/service/java/com/android/server/appsearch/ServiceAppSearchConfig.java b/service/java/com/android/server/appsearch/ServiceAppSearchConfig.java
index ab28f01f..5ea7c140 100644
--- a/service/java/com/android/server/appsearch/ServiceAppSearchConfig.java
+++ b/service/java/com/android/server/appsearch/ServiceAppSearchConfig.java
@@ -46,7 +46,8 @@ public interface ServiceAppSearchConfig extends AppSearchConfig, AutoCloseable {
     int DEFAULT_SAMPLING_INTERVAL = 10;
 
     int DEFAULT_LIMIT_CONFIG_MAX_DOCUMENT_SIZE_BYTES = 512 * 1024; // 512KiB
-    int DEFAULT_LIMIT_CONFIG_MAX_DOCUMENT_COUNT = 80_000;
+    int DEFAULT_LIMIT_CONFIG_PER_PACKAGE_DOCUMENT_COUNT_LIMIT = 80_000;
+    int DEFAULT_LIMIT_CONFIG_DOCUMENT_COUNT_LIMIT_START_THRESHOLD = 2_000_000;
     int DEFAULT_LIMIT_CONFIG_MAX_SUGGESTION_COUNT = 20_000;
     int DEFAULT_BYTES_OPTIMIZE_THRESHOLD = 10 * 1024 * 1024; // 10 MiB
     int DEFAULT_TIME_OPTIMIZE_THRESHOLD_MILLIS = 7 * 24 * 60 * 60 * 1000; // 7 days in millis
@@ -86,6 +87,12 @@ public interface ServiceAppSearchConfig extends AppSearchConfig, AutoCloseable {
     /** The default interval in millisecond to trigger fully persist job. */
     long DEFAULT_FULLY_PERSIST_JOB_INTERVAL = DAY_IN_MILLIS;
 
+    /**
+     * The default number of active fds an app is allowed to open for read and write blob from
+     * AppSearch.
+     */
+    int DEFAULT_MAX_OPEN_BLOB_COUNT = 250;
+
     /** Returns cached value for minTimeIntervalBetweenSamplesMillis. */
     long getCachedMinTimeIntervalBetweenSamplesMillis();
 
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppFunctionSchemaParser.java b/service/java/com/android/server/appsearch/appsindexer/AppFunctionSchemaParser.java
new file mode 100644
index 00000000..e06414ea
--- /dev/null
+++ b/service/java/com/android/server/appsearch/appsindexer/AppFunctionSchemaParser.java
@@ -0,0 +1,274 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.server.appsearch.appsindexer;
+
+import android.annotation.NonNull;
+import android.app.appsearch.AppSearchSchema;
+import android.app.appsearch.AppSearchSchema.BooleanPropertyConfig;
+import android.app.appsearch.AppSearchSchema.LongPropertyConfig;
+import android.app.appsearch.AppSearchSchema.PropertyConfig;
+import android.app.appsearch.AppSearchSchema.StringPropertyConfig;
+import android.app.appsearch.util.LogUtil;
+import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.res.AssetManager;
+import android.util.ArrayMap;
+import android.util.Log;
+
+import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionStaticMetadata;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.Collections;
+import java.util.Map;
+import java.util.Objects;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+import org.xmlpull.v1.XmlPullParserFactory;
+
+/**
+ * This class parses the XSD file from an app's assets and creates AppSearch schemas from document
+ * types.
+ *
+ * <p>The generated {@link AppSearchSchema} objects are used to set the schema under the {@link
+ * AppSearchHelper#APP_DATABASE} database. Within the database, each {@link AppSearchSchema} is
+ * named dynamically to be unique to the app package name.
+ *
+ * <p>Note: The XSD file should be generated by the App Functions SDK and always define
+ * AppFunctionStaticMetadata document type.
+ */
+public class AppFunctionSchemaParser {
+    private static final String TAG = "AppSearchSchemaParser";
+    private static final String XML_TAG_DOCUMENT_TYPE = "xs:documentType";
+    private static final String XML_TAG_ELEMENT = "xs:element";
+    private static final String XML_APPFN_NAMESPACE_PREFIX = "appfn:";
+    private static final String XML_TAG_STRING_TYPE = "xs:string";
+    private static final String XML_TAG_LONG_TYPE = "xs:long";
+    private static final String XML_TAG_INT_TYPE = "xs:int";
+    private static final String XML_TAG_BOOLEAN_TYPE = "xs:boolean";
+    private static final String XML_ATTRIBUTE_INDEXING_TYPE = "indexingType";
+    private static final String XML_ATTRIBUTE_TOKENIZER_TYPE = "tokenizerType";
+    private static final String XML_ATTRIBUTE_JOINABLE_VALUE_TYPE = "joinableValueType";
+    private static final String XML_ATTRIBUTE_CARDINALITY = "cardinality";
+    private static final String XML_ATTRIBUTE_SHOULD_INDEX_NESTED_PROPERTIES =
+            "shouldIndexNestedProperties";
+    private static final String XML_ATTRIBUTE_NAME = "name";
+    private static final String XML_ATTRIBUTE_TYPE = "type";
+
+    /**
+     * The maximum number of document types allowed in the XSD file. This is to prevent malicious
+     * apps from creating too many schema types in AppSearch by modifying the XSD file defined in
+     * App Functions SDK.
+     */
+    private final int mMaxAllowedDocumentType;
+
+    /**
+     * @param maxAllowedDocumentType The maximum number of document types allowed in the XSD file.
+     *     This is to prevent malicious apps from creating too many schema types in AppSearch by
+     *     modifying the XSD file defined in App Functions SDK.
+     */
+    public AppFunctionSchemaParser(int maxAllowedDocumentType) {
+        mMaxAllowedDocumentType = maxAllowedDocumentType;
+    }
+
+    /**
+     * Parses the XSD and create AppSearch schemas from document types.
+     *
+     * <p>The schema output isn't guaranteed to have valid dependencies, which can be caught during
+     * a {@link SyncAppSearchSession#setSchema} call.
+     *
+     * @param packageManager The PackageManager used to access app resources.
+     * @param packageName The package name of the app whose assets contain the XSD file.
+     * @param assetFilePath The path to the XSD file within the app's assets.
+     * @return A mapping of schema types to their corresponding {@link AppSearchSchema} objects, or
+     *     an empty map if there's an error during parsing or if the AppFunctionStaticMetadata
+     *     document type is not found.
+     */
+    @NonNull
+    public Map<String, AppSearchSchema> parseAndCreateSchemas(
+            @NonNull PackageManager packageManager,
+            @NonNull String packageName,
+            @NonNull String assetFilePath) {
+        Objects.requireNonNull(packageManager);
+        Objects.requireNonNull(packageName);
+        Objects.requireNonNull(assetFilePath);
+
+        try {
+            AssetManager assetManager =
+                    packageManager.getResourcesForApplication(packageName).getAssets();
+            InputStream xsdInputStream = assetManager.open(assetFilePath);
+            String appFunctionStaticMetadataType =
+                    AppFunctionStaticMetadata.getSchemaNameForPackage(
+                            packageName, /* schemaType= */ null);
+            Map<String, AppSearchSchema> schemas =
+                    parseDocumentTypeAndCreateSchemas(packageName, xsdInputStream);
+            if (schemas.containsKey(appFunctionStaticMetadataType)) {
+                return schemas;
+            } else if (LogUtil.DEBUG) {
+                Log.d(TAG, "AppFunctionStaticMetadata schema not found.");
+            }
+        } catch (Exception ex) {
+            // The code parses an XSD file from another app's assets, using a broad try-catch to
+            // handle potential errors since the XML structure might be unpredictable.
+            Log.e(
+                    TAG,
+                    String.format(
+                            "Failed to parse XSD from package '%s', asset file '%s'",
+                            packageName, assetFilePath),
+                    ex);
+        }
+        return Collections.emptyMap();
+    }
+
+    private Map<String, AppSearchSchema> parseDocumentTypeAndCreateSchemas(
+            @NonNull String packageName, @NonNull InputStream xsdInputStream)
+            throws XmlPullParserException, IOException {
+        Objects.requireNonNull(packageName);
+        Objects.requireNonNull(xsdInputStream);
+
+        Map<String, AppSearchSchema> schemas = new ArrayMap<>();
+        XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
+        XmlPullParser parser = factory.newPullParser();
+        parser.setInput(xsdInputStream, null);
+
+        AppSearchSchema.Builder schemaBuilder = null;
+
+        while (parser.getEventType() != XmlPullParser.END_DOCUMENT) {
+            switch (parser.getEventType()) {
+                case XmlPullParser.START_TAG:
+                    if (XML_TAG_DOCUMENT_TYPE.equals(parser.getName())) {
+                        if (schemas.size() >= mMaxAllowedDocumentType) {
+                            throw new IllegalStateException(
+                                    "Exceeded max allowed document types: "
+                                            + mMaxAllowedDocumentType);
+                        }
+
+                        String documentTypeName =
+                                parser.getAttributeValue(null, XML_ATTRIBUTE_NAME);
+                        if (documentTypeName != null) {
+                            schemaBuilder =
+                                    new AppSearchSchema.Builder(
+                                            AppFunctionStaticMetadata.getSchemaNameForPackage(
+                                                    packageName, documentTypeName));
+                        }
+                    } else if (XML_TAG_ELEMENT.equals(parser.getName()) && schemaBuilder != null) {
+                        AppSearchSchema.PropertyConfig propertyConfig =
+                                computePropertyConfigFromXsdType(parser, packageName);
+                        if (propertyConfig != null) schemaBuilder.addProperty(propertyConfig);
+                    }
+                    break;
+
+                case XmlPullParser.END_TAG:
+                    if (XML_TAG_DOCUMENT_TYPE.equals(parser.getName())) {
+                        if (schemaBuilder != null) {
+                            AppSearchSchema schema = schemaBuilder.build();
+                            schemas.put(schema.getSchemaType(), schema);
+                            schemaBuilder = null;
+                        }
+                    }
+                    break;
+            }
+            parser.next();
+        }
+
+        return schemas;
+    }
+
+    private static PropertyConfig computePropertyConfigFromXsdType(
+            @NonNull XmlPullParser parser, @NonNull String packageName)
+            throws XmlPullParserException, IOException {
+        Objects.requireNonNull(parser);
+
+        String name = parser.getAttributeValue(null, XML_ATTRIBUTE_NAME);
+        String type = parser.getAttributeValue(null, XML_ATTRIBUTE_TYPE);
+
+        if (name == null || type == null) return null;
+
+        int cardinality =
+                getAttributeIntOrDefault(
+                        parser, XML_ATTRIBUTE_CARDINALITY, PropertyConfig.CARDINALITY_OPTIONAL);
+
+        switch (type) {
+            case XML_TAG_STRING_TYPE:
+                return new StringPropertyConfig.Builder(name)
+                        .setCardinality(cardinality)
+                        .setIndexingType(
+                                getAttributeIntOrDefault(
+                                        parser,
+                                        XML_ATTRIBUTE_INDEXING_TYPE,
+                                        StringPropertyConfig.INDEXING_TYPE_NONE))
+                        .setTokenizerType(
+                                getAttributeIntOrDefault(
+                                        parser,
+                                        XML_ATTRIBUTE_TOKENIZER_TYPE,
+                                        StringPropertyConfig.TOKENIZER_TYPE_NONE))
+                        .setJoinableValueType(
+                                getAttributeIntOrDefault(
+                                        parser,
+                                        XML_ATTRIBUTE_JOINABLE_VALUE_TYPE,
+                                        StringPropertyConfig.JOINABLE_VALUE_TYPE_NONE))
+                        .build();
+            case XML_TAG_LONG_TYPE:
+            case XML_TAG_INT_TYPE:
+                return new LongPropertyConfig.Builder(name)
+                        .setCardinality(cardinality)
+                        .setIndexingType(
+                                getAttributeIntOrDefault(
+                                        parser,
+                                        XML_ATTRIBUTE_INDEXING_TYPE,
+                                        LongPropertyConfig.INDEXING_TYPE_NONE))
+                        .build();
+            case XML_TAG_BOOLEAN_TYPE:
+                return new BooleanPropertyConfig.Builder(name).setCardinality(cardinality).build();
+            default:
+                if (type.contains(XML_APPFN_NAMESPACE_PREFIX)) {
+                    String localType = type.substring(type.indexOf(':') + 1);
+                    return new AppSearchSchema.DocumentPropertyConfig.Builder(
+                                    name,
+                                    AppFunctionStaticMetadata.getSchemaNameForPackage(
+                                            packageName, localType))
+                            .setCardinality(cardinality)
+                            .setShouldIndexNestedProperties(
+                                    getAttributeBoolOrDefault(
+                                            parser,
+                                            XML_ATTRIBUTE_SHOULD_INDEX_NESTED_PROPERTIES,
+                                            true))
+                            .build();
+                }
+                throw new IllegalArgumentException("Unsupported type: " + type);
+        }
+    }
+
+    private static boolean getAttributeBoolOrDefault(
+            @NonNull XmlPullParser parser, @NonNull String attributeName, boolean defaultValue) {
+        Objects.requireNonNull(parser);
+        Objects.requireNonNull(attributeName);
+
+        String value = parser.getAttributeValue(null, attributeName);
+        return value == null ? defaultValue : Boolean.parseBoolean(value);
+    }
+
+    private static int getAttributeIntOrDefault(
+            @NonNull XmlPullParser parser, @NonNull String attributeName, int defaultValue) {
+        Objects.requireNonNull(parser);
+        Objects.requireNonNull(attributeName);
+
+        String value = parser.getAttributeValue(null, attributeName);
+        return value == null ? defaultValue : Integer.parseInt(value);
+    }
+}
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppFunctionStaticMetadataParser.java b/service/java/com/android/server/appsearch/appsindexer/AppFunctionStaticMetadataParser.java
index 89369934..2613e235 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppFunctionStaticMetadataParser.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppFunctionStaticMetadataParser.java
@@ -1,18 +1,27 @@
 package com.android.server.appsearch.appsindexer;
 
 import android.annotation.NonNull;
+import android.app.appsearch.AppSearchSchema;
+import android.app.appsearch.GenericDocument;
 import android.content.pm.PackageManager;
 
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionStaticMetadata;
 
 import java.util.List;
+import java.util.Map;
 
 /**
  * This class parses static metadata about App Functions from an XML file located within an app's
  * assets.
+ *
+ * <p>The generated {@link AppFunctionStaticMetadata} objects are inserted into AppSearch after a
+ * successful {@link SyncAppSearchSession#setSchema} call under the {@link
+ * AppSearchHelper#APP_DATABASE} database. Within the database, each {@link AppSearchSchema} is
+ * named dynamically to be unique to the app package name.
  */
 public interface AppFunctionStaticMetadataParser {
-
+    // TODO(b/367410454): Remove this method once enable_apps_indexer_incremental_put flag is
+    //  rolled out
     /**
      * Parses static metadata about App Functions from the given XML asset file.
      *
@@ -27,4 +36,43 @@ public interface AppFunctionStaticMetadataParser {
             @NonNull PackageManager packageManager,
             @NonNull String packageName,
             @NonNull String assetFilePath);
+
+    /**
+     * Parses static metadata about App Functions from the given XML asset file.
+     *
+     * @param packageManager The PackageManager used to access app resources.
+     * @param packageName The package name of the app whose assets contain the XML file.
+     * @param assetFilePath The path to the XML file within the app's assets.
+     * @return A mapping of function ids to their corresponding {@link AppFunctionStaticMetadata}
+     *     objects representing the parsed App Functions. An empty map is returned if there's an
+     *     error during parsing.
+     */
+    @NonNull
+    Map<String, AppFunctionStaticMetadata> parseIntoMap(
+            @NonNull PackageManager packageManager,
+            @NonNull String packageName,
+            @NonNull String assetFilePath);
+
+    /**
+     * Parses static metadata about App Functions from the given XML asset file, using type
+     * information from the given schemas.
+     *
+     * <p>Note: The root schema should have property with name {@link
+     * AppFunctionStaticMetadata#PROPERTY_FUNCTION_ID} to construct the mapping of function id to
+     * {@link AppFunctionStaticMetadata} else an empty map is returned.
+     *
+     * @param packageManager The PackageManager used to access app resources.
+     * @param packageName The package name of the app whose assets contain the XML file.
+     * @param assetFilePath The path to the XML file within the app's assets.
+     * @param schemas The mapping of schema types to their corresponding {@link AppSearchSchema}
+     *     objects.
+     * @return A mapping of function ids to their corresponding {@link AppFunctionStaticMetadata}
+     *     objects. An empty map is returned if there's an error during parsing.
+     */
+    @NonNull
+    Map<String, AppFunctionStaticMetadata> parseIntoMapForGivenSchemas(
+            @NonNull PackageManager packageManager,
+            @NonNull String packageName,
+            @NonNull String assetFilePath,
+            @NonNull Map<String, AppSearchSchema> schemas);
 }
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppFunctionStaticMetadataParserImpl.java b/service/java/com/android/server/appsearch/appsindexer/AppFunctionStaticMetadataParserImpl.java
index 7b143889..c6eab15f 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppFunctionStaticMetadataParserImpl.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppFunctionStaticMetadataParserImpl.java
@@ -16,8 +16,17 @@
 package com.android.server.appsearch.appsindexer;
 
 import android.annotation.NonNull;
+import android.app.appsearch.AppSearchSchema;
+import android.app.appsearch.AppSearchSchema.BooleanPropertyConfig;
+import android.app.appsearch.AppSearchSchema.LongPropertyConfig;
+import android.app.appsearch.AppSearchSchema.PropertyConfig;
+import android.app.appsearch.AppSearchSchema.StringPropertyConfig;
+import android.app.appsearch.AppSearchSchema.DocumentPropertyConfig;
+import android.app.appsearch.GenericDocument;
+import android.app.appsearch.util.LogUtil;
 import android.content.pm.PackageManager;
 import android.content.res.AssetManager;
+import android.util.ArrayMap;
 import android.util.Log;
 
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionStaticMetadata;
@@ -31,6 +40,7 @@ import java.io.InputStreamReader;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import java.util.Map;
 import java.util.Objects;
 
 /**
@@ -39,7 +49,8 @@ import java.util.Objects;
  */
 public class AppFunctionStaticMetadataParserImpl implements AppFunctionStaticMetadataParser {
     private static final String TAG = "AppSearchMetadataParser";
-    public static final String TAG_APPFUNCTION = "appfunction";
+    private static final String XML_TAG_APPFUNCTION = "appfunction";
+    private static final String XML_TAG_APPFUNCTIONS_ROOT = "appfunctions";
 
     @NonNull private final String mIndexerPackageName;
     private final int mMaxAppFunctions;
@@ -56,6 +67,8 @@ public class AppFunctionStaticMetadataParserImpl implements AppFunctionStaticMet
         mMaxAppFunctions = maxAppFunctions;
     }
 
+    // TODO(b/367410454): Remove this method once enable_apps_indexer_incremental_put flag is
+    //  rolled out
     @NonNull
     @Override
     public List<AppFunctionStaticMetadata> parse(
@@ -66,13 +79,8 @@ public class AppFunctionStaticMetadataParserImpl implements AppFunctionStaticMet
         Objects.requireNonNull(packageName);
         Objects.requireNonNull(assetFilePath);
         try {
-            XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
-            factory.setNamespaceAware(true);
-            XmlPullParser parser = factory.newPullParser();
-            AssetManager assetManager =
-                    packageManager.getResourcesForApplication(packageName).getAssets();
-            parser.setInput(new InputStreamReader(assetManager.open(assetFilePath)));
-            return parseAppFunctions(parser, packageName);
+            return parseAppFunctions(
+                    initializeParser(packageManager, packageName, assetFilePath), packageName);
         } catch (Exception ex) {
             // The code parses an XML file from another app's assets, using a broad try-catch to
             // handle potential errors since the XML structure might be unpredictable.
@@ -86,8 +94,56 @@ public class AppFunctionStaticMetadataParserImpl implements AppFunctionStaticMet
         return Collections.emptyList();
     }
 
+    @NonNull
+    @Override
+    public Map<String, AppFunctionStaticMetadata> parseIntoMap(
+            @NonNull PackageManager packageManager,
+            @NonNull String packageName,
+            @NonNull String assetFilePath) {
+        Objects.requireNonNull(packageManager);
+        Objects.requireNonNull(packageName);
+        Objects.requireNonNull(assetFilePath);
+        try {
+            return parseAppFunctionsIntoMap(
+                    initializeParser(packageManager, packageName, assetFilePath), packageName);
+        } catch (Exception ex) {
+            // The code parses an XML file from another app's assets, using a broad try-catch to
+            // handle potential errors since the XML structure might be unpredictable.
+            Log.e(
+                    TAG,
+                    String.format(
+                            "Failed to parse XML from package '%s', asset file '%s'",
+                            packageName, assetFilePath),
+                    ex);
+        }
+        return Collections.emptyMap();
+    }
+
+    /**
+     * Initializes an {@link XmlPullParser} to parse xml based on the packageName and assetFilePath.
+     */
+    @NonNull
+    private XmlPullParser initializeParser(
+            @NonNull PackageManager packageManager,
+            @NonNull String packageName,
+            @NonNull String assetFilePath)
+            throws XmlPullParserException, PackageManager.NameNotFoundException, IOException {
+        Objects.requireNonNull(packageManager);
+        Objects.requireNonNull(packageName);
+        Objects.requireNonNull(assetFilePath);
+        XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
+        factory.setNamespaceAware(true);
+        XmlPullParser parser = factory.newPullParser();
+        AssetManager assetManager =
+                packageManager.getResourcesForApplication(packageName).getAssets();
+        parser.setInput(new InputStreamReader(assetManager.open(assetFilePath)));
+        return parser;
+    }
+
+    // TODO(b/367410454): Remove this method once enable_apps_indexer_incremental_put flag is
+    //  rolled out
     /**
-     * Parses a sequence of `appfunction` elements from the XML into an a list of {@link
+     * Parses a sequence of `appfunction` elements from the XML into a list of {@link
      * AppFunctionStaticMetadata}.
      *
      * @param parser the XmlPullParser positioned at the start of the xml file
@@ -102,7 +158,7 @@ public class AppFunctionStaticMetadataParserImpl implements AppFunctionStaticMet
 
         while (eventType != XmlPullParser.END_DOCUMENT) {
             String tagName = parser.getName();
-            if (eventType == XmlPullParser.START_TAG && TAG_APPFUNCTION.equals(tagName)) {
+            if (eventType == XmlPullParser.START_TAG && XML_TAG_APPFUNCTION.equals(tagName)) {
                 AppFunctionStaticMetadata appFunction = parseAppFunction(parser, packageName);
                 appFunctions.add(appFunction);
                 if (appFunctions.size() >= mMaxAppFunctions) {
@@ -115,6 +171,35 @@ public class AppFunctionStaticMetadataParserImpl implements AppFunctionStaticMet
         return appFunctions;
     }
 
+    /**
+     * Parses a sequence of `appfunction` elements from the XML into a map of function ids to their
+     * corresponding {@link AppFunctionStaticMetadata}.
+     *
+     * @param parser the XmlPullParser positioned at the start of the xml file
+     */
+    @NonNull
+    private Map<String, AppFunctionStaticMetadata> parseAppFunctionsIntoMap(
+            @NonNull XmlPullParser parser, @NonNull String packageName)
+            throws XmlPullParserException, IOException {
+        Map<String, AppFunctionStaticMetadata> appFunctions = new ArrayMap<>();
+
+        int eventType = parser.getEventType();
+
+        while (eventType != XmlPullParser.END_DOCUMENT) {
+            String tagName = parser.getName();
+            if (eventType == XmlPullParser.START_TAG && XML_TAG_APPFUNCTION.equals(tagName)) {
+                AppFunctionStaticMetadata appFunction = parseAppFunction(parser, packageName);
+                appFunctions.put(appFunction.getFunctionId(), appFunction);
+                if (appFunctions.size() >= mMaxAppFunctions) {
+                    Log.d(TAG, "Exceeding the max number of app functions: " + packageName);
+                    return appFunctions;
+                }
+            }
+            eventType = parser.next();
+        }
+        return appFunctions;
+    }
+
     /**
      * Parses a single `appfunction` element from the XML into an {@link AppFunctionStaticMetadata}
      * object.
@@ -134,31 +219,33 @@ public class AppFunctionStaticMetadataParserImpl implements AppFunctionStaticMet
         Integer displayNameStringRes = null;
         Boolean restrictCallersWithExecuteAppFunctions = null;
         int eventType = parser.getEventType();
-        while (!(eventType == XmlPullParser.END_TAG && TAG_APPFUNCTION.equals(parser.getName()))) {
-            if (eventType == XmlPullParser.START_TAG) {
+        while (!(eventType == XmlPullParser.END_TAG
+                && XML_TAG_APPFUNCTION.equals(parser.getName()))) {
+            if (eventType == XmlPullParser.START_TAG
+                    && !XML_TAG_APPFUNCTION.equals(parser.getName())) {
                 String tagName = parser.getName();
+                String tagValue = parser.nextText().trim();
                 switch (tagName) {
                     case "function_id":
-                        functionId = parser.nextText().trim();
+                        functionId = tagValue;
                         break;
                     case "schema_name":
-                        schemaName = parser.nextText().trim();
+                        schemaName = tagValue;
                         break;
                     case "schema_version":
-                        schemaVersion = Long.parseLong(parser.nextText().trim());
+                        schemaVersion = Long.parseLong(tagValue);
                         break;
                     case "schema_category":
-                        schemaCategory = parser.nextText().trim();
+                        schemaCategory = tagValue;
                         break;
                     case "enabled_by_default":
-                        enabledByDefault = Boolean.parseBoolean(parser.nextText().trim());
+                        enabledByDefault = Boolean.parseBoolean(tagValue);
                         break;
                     case "restrict_callers_with_execute_app_functions":
-                        restrictCallersWithExecuteAppFunctions =
-                                Boolean.parseBoolean(parser.nextText().trim());
+                        restrictCallersWithExecuteAppFunctions = Boolean.parseBoolean(tagValue);
                         break;
                     case "display_name_string_res":
-                        displayNameStringRes = Integer.parseInt(parser.nextText().trim());
+                        displayNameStringRes = Integer.parseInt(tagValue);
                         break;
                 }
             }
@@ -191,4 +278,262 @@ public class AppFunctionStaticMetadataParserImpl implements AppFunctionStaticMet
         }
         return builder.build();
     }
+
+    @NonNull
+    @Override
+    public Map<String, AppFunctionStaticMetadata> parseIntoMapForGivenSchemas(
+            @NonNull PackageManager packageManager,
+            @NonNull String packageName,
+            @NonNull String assetFilePath,
+            @NonNull Map<String, AppSearchSchema> schemas) {
+        Objects.requireNonNull(packageManager);
+        Objects.requireNonNull(packageName);
+        Objects.requireNonNull(assetFilePath);
+        Objects.requireNonNull(schemas);
+
+        try {
+            return parseAppFunctionsIntoMapForGivenSchemas(
+                    initializeParser(packageManager, packageName, assetFilePath),
+                    packageName,
+                    schemas);
+        } catch (Exception ex) {
+            // The code parses an XML file from another app's assets, using a broad try-catch to
+            // handle potential errors since the XML structure might be unpredictable.
+            Log.e(
+                    TAG,
+                    String.format(
+                            "Failed to parse XML from package '%s', asset file '%s'",
+                            packageName, assetFilePath),
+                    ex);
+        }
+        return Collections.emptyMap();
+    }
+
+    @NonNull
+    private Map<String, AppFunctionStaticMetadata> parseAppFunctionsIntoMapForGivenSchemas(
+            @NonNull XmlPullParser parser,
+            @NonNull String packageName,
+            @NonNull Map<String, AppSearchSchema> schemas)
+            throws XmlPullParserException, IOException {
+        Objects.requireNonNull(parser);
+        Objects.requireNonNull(packageName);
+        Objects.requireNonNull(schemas);
+
+        Map<String, AppFunctionStaticMetadata> appFnMetadatas = new ArrayMap<>();
+
+        Map<String, PropertyConfig> qualifiedPropertyNamesToPropertyConfig =
+                buildQualifiedPropertyNameToPropertyConfigMap(schemas);
+
+        int eventType = parser.getEventType();
+
+        while (eventType != XmlPullParser.END_DOCUMENT) {
+            String tagName = parser.getName();
+            String schemaName =
+                    AppFunctionStaticMetadata.getSchemaNameForPackage(packageName, tagName);
+            if (eventType == XmlPullParser.START_TAG && schemas.containsKey(schemaName)) {
+                GenericDocument appFnMetadata =
+                        parseXmlElementToGenericDocument(
+                                parser,
+                                packageName,
+                                tagName,
+                                qualifiedPropertyNamesToPropertyConfig);
+                if (appFnMetadata != null) {
+                    appFnMetadatas.put(
+                            appFnMetadata.getPropertyString(
+                                    AppFunctionStaticMetadata.PROPERTY_FUNCTION_ID),
+                            new AppFunctionStaticMetadata(appFnMetadata));
+                } else if (!XML_TAG_APPFUNCTIONS_ROOT.equals(tagName)) {
+                    throw new XmlPullParserException("Unknwown tag: " + tagName);
+                }
+                if (appFnMetadatas.size() >= mMaxAppFunctions) {
+                    if (LogUtil.DEBUG) {
+                        Log.d(TAG, "Exceeding the max number of app functions: " + packageName);
+                    }
+                    return appFnMetadatas;
+                }
+            }
+            eventType = parser.next();
+        }
+        return appFnMetadatas;
+    }
+
+    /**
+     * Tries to parse a single XML element into a {@link GenericDocument} object.
+     *
+     * @param parser the XmlPullParser positioned at the start of an XML element.
+     * @param packageName the package name of the app that owns the XML element.
+     * @param schemaType the type of the schema that the XML element belongs to.
+     * @param qualifiedPropertyNamesToPropertyConfig the mapping of qualified property names to
+     *     their corresponding {@link PropertyConfig} objects.
+     * @return a {@link GenericDocument} object populated with the data from the XML element, or
+     *     null.
+     * @throws XmlPullParserException if the XML element is malformed.
+     */
+    @NonNull
+    private static GenericDocument parseXmlElementToGenericDocument(
+            @NonNull XmlPullParser parser,
+            @NonNull String packageName,
+            @NonNull String schemaType,
+            @NonNull Map<String, PropertyConfig> qualifiedPropertyNamesToPropertyConfig)
+            throws XmlPullParserException, IOException {
+        Objects.requireNonNull(parser);
+        Objects.requireNonNull(packageName);
+        Objects.requireNonNull(schemaType);
+        Objects.requireNonNull(qualifiedPropertyNamesToPropertyConfig);
+
+        GenericDocument.Builder docBuilder =
+                new GenericDocument.Builder(
+                        AppFunctionStaticMetadata.APP_FUNCTION_NAMESPACE,
+                        packageName + "/" + schemaType,
+                        AppFunctionStaticMetadata.getSchemaNameForPackage(packageName, schemaType));
+
+        Map<String, List<String>> primitivePropertyValues = new ArrayMap<>();
+        Map<String, List<GenericDocument>> nestedDocumentValues = new ArrayMap<>();
+        String startTag = parser.getName();
+        String currentPropertyPath = null;
+
+        while (parser.getEventType() != XmlPullParser.END_DOCUMENT) {
+            switch (parser.getEventType()) {
+                case XmlPullParser.START_TAG:
+                    currentPropertyPath = createQualifiedPropertyName(schemaType, parser.getName());
+                    PropertyConfig propertyConfig =
+                            qualifiedPropertyNamesToPropertyConfig.get(currentPropertyPath);
+                    if (propertyConfig instanceof DocumentPropertyConfig) {
+                        GenericDocument nestedDoc =
+                                parseXmlElementToGenericDocument(
+                                        parser,
+                                        packageName,
+                                        getSchemaTypeWithoutPackage(
+                                                ((DocumentPropertyConfig) propertyConfig)
+                                                        .getSchemaType()),
+                                        qualifiedPropertyNamesToPropertyConfig);
+                        nestedDocumentValues
+                                .computeIfAbsent(currentPropertyPath, k -> new ArrayList<>())
+                                .add(nestedDoc);
+                    } else if (propertyConfig != null) {
+                        primitivePropertyValues
+                                .computeIfAbsent(currentPropertyPath, k -> new ArrayList<>())
+                                .add(parser.nextText().trim());
+                    }
+                    break;
+
+                case XmlPullParser.END_TAG:
+                    if (startTag.equals(parser.getName())) {
+                        for (Map.Entry<String, List<String>> entry :
+                                primitivePropertyValues.entrySet()) {
+                            addPrimitiveProperty(
+                                    docBuilder,
+                                    qualifiedPropertyNamesToPropertyConfig.get(entry.getKey()),
+                                    entry.getValue());
+                        }
+                        for (Map.Entry<String, List<GenericDocument>> entry :
+                                nestedDocumentValues.entrySet()) {
+                            String propertyName =
+                                    qualifiedPropertyNamesToPropertyConfig
+                                            .get(entry.getKey())
+                                            .getName();
+                            docBuilder.setPropertyDocument(
+                                    propertyName, entry.getValue().toArray(new GenericDocument[0]));
+                        }
+                        return docBuilder.build();
+                    }
+                    break;
+            }
+            parser.next();
+        }
+
+        throw new IllegalStateException("Code should never reach here.");
+    }
+
+    /**
+     * Builds a mapping of qualified property names to their corresponding {@link PropertyConfig}
+     * objects.
+     *
+     * <p>The key is a concatenation of enclosing schema type and property name, separated by a
+     * period to avoid conflicts between properties with the same name in different schemas. For
+     * example, if the "Person" and "Address" schemas both have a property named "name", then the
+     * qualified property names will be "Person#name" and "Address#name" respectively.
+     *
+     * @param schemaMap the mapping of schema types to their corresponding {@link AppSearchSchema}
+     *     objects.
+     * @return a {@link Map} of qualified property names to their corresponding {@link
+     *     PropertyConfig} objects.
+     */
+    @NonNull
+    private static Map<String, PropertyConfig> buildQualifiedPropertyNameToPropertyConfigMap(
+            @NonNull Map<String, AppSearchSchema> schemaMap) {
+        Objects.requireNonNull(schemaMap);
+
+        Map<String, PropertyConfig> propertyMap = new ArrayMap<>();
+
+        for (Map.Entry<String, AppSearchSchema> entry : schemaMap.entrySet()) {
+            String schemaType = getSchemaTypeWithoutPackage(entry.getKey());
+            AppSearchSchema schema = entry.getValue();
+
+            List<AppSearchSchema.PropertyConfig> properties = schema.getProperties();
+            for (int i = 0; i < properties.size(); i++) {
+                AppSearchSchema.PropertyConfig property = properties.get(i);
+                String propertyPath = createQualifiedPropertyName(schemaType, property.getName());
+                propertyMap.put(propertyPath, property);
+            }
+        }
+
+        return propertyMap;
+    }
+
+    /**
+     * Creates a qualified property name by concatenating the schema type and property name with a #
+     * separator to avoid conflicts between properties with the same name in different schemas.
+     */
+    @NonNull
+    private static String createQualifiedPropertyName(
+            @NonNull String schemaType, @NonNull String propertyName) {
+        return Objects.requireNonNull(schemaType) + "#" + Objects.requireNonNull(propertyName);
+    }
+
+    /**
+     * Returns the schema type without the package name suffix.
+     *
+     * <p>For example, if the schema name is "Person-com.example.app", this method will return
+     * "Person".
+     */
+    @NonNull
+    private static String getSchemaTypeWithoutPackage(@NonNull String schemaName) {
+        return Objects.requireNonNull(schemaName).substring(0, schemaName.indexOf('-'));
+    }
+
+    /**
+     * Adds primitive property values to the given {@link GenericDocument.Builder} based on the
+     * given {@link PropertyConfig}.
+     *
+     * <p>Ignores unsupported data types.
+     */
+    private static void addPrimitiveProperty(
+            @NonNull GenericDocument.Builder builder,
+            @NonNull PropertyConfig propertyConfig,
+            @NonNull List<String> values) {
+        Objects.requireNonNull(builder);
+        Objects.requireNonNull(propertyConfig);
+        Objects.requireNonNull(values);
+
+        switch (propertyConfig.getDataType()) {
+            case PropertyConfig.DATA_TYPE_BOOLEAN:
+                boolean[] booleanValues = new boolean[values.size()];
+                for (int i = 0; i < values.size(); i++) {
+                    booleanValues[i] = Boolean.parseBoolean(values.get(i));
+                }
+                builder.setPropertyBoolean(propertyConfig.getName(), booleanValues);
+                break;
+            case PropertyConfig.DATA_TYPE_LONG:
+                long[] longValues = new long[values.size()];
+                for (int i = 0; i < values.size(); i++) {
+                    longValues[i] = Long.parseLong(values.get(i));
+                }
+                builder.setPropertyLong(propertyConfig.getName(), longValues);
+                break;
+            case PropertyConfig.DATA_TYPE_STRING:
+                builder.setPropertyString(propertyConfig.getName(), values.toArray(new String[0]));
+                break;
+        }
+    }
 }
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerConfig.java b/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerConfig.java
new file mode 100644
index 00000000..f367dd45
--- /dev/null
+++ b/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerConfig.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.appsindexer;
+
+import java.util.concurrent.TimeUnit;
+
+/**
+ * An interface which exposes config flags to App Open Event Indexer.
+ *
+ * <p>Implementations of this interface must be thread-safe.
+ *
+ * @hide
+ */
+public interface AppOpenEventIndexerConfig {
+    boolean DEFAULT_APP_OPEN_EVENT_INDEXER_ENABLED = true;
+
+    /**
+     * The default minimum internal in millis for two consecutive scheduled updates. This is set to
+     * 1 day rather than 30 days (like other indexers) since it does not trigger on events like
+     * package update, phone unlock, etc.
+     */
+    long DEFAULT_APP_OPEN_EVENT_INDEXER_UPDATE_INTERVAL_MILLIS = TimeUnit.DAYS.toMillis(1);
+
+    /** Returns whether App Open Event Indexer is enabled. */
+    boolean isAppOpenEventIndexerEnabled();
+
+    /* Returns the minimum internal in millis for two consecutive scheduled updates. */
+    long getAppOpenEventMaintenanceUpdateIntervalMillis();
+}
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerImpl.java b/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerImpl.java
new file mode 100644
index 00000000..6be14e91
--- /dev/null
+++ b/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerImpl.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.appsindexer;
+
+import android.annotation.NonNull;
+import android.annotation.WorkerThread;
+import android.app.appsearch.exceptions.AppSearchException;
+import android.app.usage.UsageStatsManager;
+import android.content.Context;
+
+import com.android.server.appsearch.appsindexer.appsearchtypes.AppOpenEvent;
+
+import java.io.Closeable;
+import java.util.List;
+import java.util.Objects;
+
+/**
+ * Interacts with UsageStatsManager and AppSearch to index app open events.
+ *
+ * <p>This class is NOT thread-safe.
+ *
+ * @hide
+ */
+public final class AppOpenEventIndexerImpl implements Closeable {
+    static final String TAG = "AppSearchAppOpenEventIndexerImpl";
+
+    private final Context mContext;
+    private final AppSearchHelper mAppSearchHelper;
+
+    public AppOpenEventIndexerImpl(@NonNull Context context) throws AppSearchException {
+        mContext = Objects.requireNonNull(context);
+        mAppSearchHelper = new AppSearchHelper(context);
+    }
+
+    /**
+     * Checks UsageStatsManager and AppSearch to sync the App Open Events Index in AppSearch.
+     *
+     * @param settings contains update timestamps that help the indexer determine when indexing last
+     *     ran
+     */
+    @WorkerThread
+    public void doUpdate(@NonNull AppOpenEventIndexerSettings settings) throws AppSearchException {
+        Objects.requireNonNull(settings);
+
+        UsageStatsManager usageStatsManager = mContext.getSystemService(UsageStatsManager.class);
+
+        long currentTimeMillis = System.currentTimeMillis();
+        long lastAppOpenIndexerUpdateTimeMillis = settings.getLastUpdateTimestampMillis();
+        List<AppOpenEvent> appOpenEvents =
+                AppsUtil.getAppOpenEvents(
+                        usageStatsManager, lastAppOpenIndexerUpdateTimeMillis, currentTimeMillis);
+
+        try {
+            // This should be a no-op if the schema is already set and unchanged.
+            mAppSearchHelper.setSchemaForAppOpenEvents();
+
+            mAppSearchHelper.indexAppOpenEvents(appOpenEvents);
+            settings.setLastUpdateTimestampMillis(currentTimeMillis);
+        } catch (AppSearchException e) {
+            // Reset the last update time stamp and app update timestamp so we can try again later.
+            settings.reset();
+            throw e;
+        }
+    }
+
+    /** Shuts down the {@link AppsOpenEventIndexerImpl} and its {@link AppSearchHelper}. */
+    @Override
+    public void close() {
+        mAppSearchHelper.close();
+    }
+}
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerMaintenanceConfig.java b/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerMaintenanceConfig.java
new file mode 100644
index 00000000..303f58b1
--- /dev/null
+++ b/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerMaintenanceConfig.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.server.appsearch.appsindexer;
+
+import android.annotation.NonNull;
+
+import com.android.server.appsearch.indexer.IndexerLocalService;
+import com.android.server.appsearch.indexer.IndexerMaintenanceConfig;
+
+/** Singleton class containing configuration for the app open event indexer maintenance task. */
+public class AppOpenEventIndexerMaintenanceConfig implements IndexerMaintenanceConfig {
+
+    public static final IndexerMaintenanceConfig INSTANCE =
+            new AppOpenEventIndexerMaintenanceConfig();
+
+    /** Enforces singleton class pattern. */
+    private AppOpenEventIndexerMaintenanceConfig() {}
+
+    @NonNull
+    @Override
+    public Class<? extends IndexerLocalService> getLocalService() {
+        return AppOpenEventIndexerManagerService.LocalService.class;
+    }
+
+    @Override
+    public int getMinJobId() {
+        return MIN_APP_OPEN_EVENT_INDEXER_JOB_ID;
+    }
+}
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerManagerService.java b/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerManagerService.java
new file mode 100644
index 00000000..04eb1a07
--- /dev/null
+++ b/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerManagerService.java
@@ -0,0 +1,219 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.appsindexer;
+
+import android.annotation.BinderThread;
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.app.appsearch.AppSearchEnvironment;
+import android.app.appsearch.AppSearchEnvironmentFactory;
+import android.app.appsearch.exceptions.AppSearchException;
+import android.app.appsearch.util.LogUtil;
+import android.content.Context;
+import android.os.CancellationSignal;
+import android.os.UserHandle;
+import android.util.ArrayMap;
+import android.util.Log;
+import android.util.Slog;
+
+import com.android.internal.annotations.GuardedBy;
+import com.android.internal.annotations.VisibleForTesting;
+import com.android.server.LocalManagerRegistry;
+import com.android.server.SystemService;
+import com.android.server.appsearch.indexer.IndexerLocalService;
+
+import java.io.File;
+import java.io.PrintWriter;
+import java.util.Map;
+import java.util.Objects;
+
+/**
+ * Manages the per device-user AppOpenEventIndexer instance to index apps into AppSearch.
+ *
+ * <p>Unlike apps indexer and contacts indexer, this does not hook into package update, phone
+ * unlock/stop, etc. It only runs when the maintenance job runs.
+ *
+ * <p>This class is thread-safe.
+ *
+ * @hide
+ */
+public final class AppOpenEventIndexerManagerService extends SystemService {
+    private static final String TAG = "AppSearchAppOpenEventIn";
+    private final Context mContext;
+    @VisibleForTesting final LocalService mLocalService;
+    @VisibleForTesting @Nullable final Runnable mCallback;
+
+    private final AppOpenEventIndexerConfig mAppOpenEventIndexerConfig;
+
+    // Map of AppOpenEventIndexerUserInstances indexed by the UserHandle
+    @GuardedBy("mAppOpenEventIndexersLocked")
+    private final Map<UserHandle, AppOpenEventIndexerUserInstance> mAppOpenEventIndexersLocked =
+            new ArrayMap<>();
+
+    /** Constructs a {@link AppOpenEventIndexerManagerService}. */
+    public AppOpenEventIndexerManagerService(
+            @NonNull Context context,
+            @NonNull AppOpenEventIndexerConfig appOpenEventIndexerConfig) {
+        this(context, appOpenEventIndexerConfig, /* callback= */ null);
+    }
+
+    /**
+     * Constructs a {@link AppOpenEventIndexerManagerService} for testing with a callback for
+     * synchronization.
+     */
+    @VisibleForTesting
+    public AppOpenEventIndexerManagerService(
+            @NonNull Context context,
+            @NonNull AppOpenEventIndexerConfig appOpenEventIndexerConfig,
+            @Nullable Runnable callback) {
+        super(context);
+        mContext = Objects.requireNonNull(context);
+        mAppOpenEventIndexerConfig = Objects.requireNonNull(appOpenEventIndexerConfig);
+        mCallback = callback;
+        mLocalService = new LocalService();
+    }
+
+    @Override
+    public void onStart() {
+        LocalManagerRegistry.addManager(LocalService.class, mLocalService);
+    }
+
+    /** Handles user stopping by shutting down the instance for the user. */
+    @Override
+    public void onUserStopping(@NonNull TargetUser user) {
+        try {
+            Objects.requireNonNull(user);
+            UserHandle userHandle = user.getUserHandle();
+            synchronized (mAppOpenEventIndexersLocked) {
+                AppOpenEventIndexerUserInstance instance =
+                        mAppOpenEventIndexersLocked.get(userHandle);
+                if (instance != null) {
+                    mAppOpenEventIndexersLocked.remove(userHandle);
+                    try {
+                        instance.shutdown();
+                    } catch (InterruptedException e) {
+                        Log.w(
+                                TAG,
+                                "Failed to shutdown app open event indexer for " + userHandle,
+                                e);
+                    }
+                }
+            }
+        } catch (RuntimeException e) {
+            Slog.wtf(TAG, "AppOpenEventIndexerManagerService.onUserStopping() failed ", e);
+        }
+    }
+
+    /** Dumps AppOpenEventIndexer internal state for the user. */
+    @BinderThread
+    public void dumpAppOpenEventIndexerForUser(
+            @NonNull UserHandle userHandle, @NonNull PrintWriter pw) {
+        try {
+            Objects.requireNonNull(userHandle);
+            Objects.requireNonNull(pw);
+            synchronized (mAppOpenEventIndexersLocked) {
+                AppOpenEventIndexerUserInstance instance =
+                        mAppOpenEventIndexersLocked.get(userHandle);
+                if (instance != null) {
+                    instance.dump(pw);
+                } else {
+                    pw.println("AppOpenEventIndexerUserInstance is not created for " + userHandle);
+                }
+            }
+        } catch (RuntimeException e) {
+            Slog.wtf(
+                    TAG,
+                    "AppOpenEventIndexerManagerService.dumpAppOpenEventIndexerForUser() failed ",
+                    e);
+        }
+    }
+
+    /** Schedules the periodic update job for all users we have an instance for. */
+    @Override
+    public void onUserUnlocking(@NonNull TargetUser user) {
+        synchronized (mAppOpenEventIndexersLocked) {
+            try {
+                AppOpenEventIndexerUserInstance instance =
+                        getOrCreateUserInstance(user.getUserHandle());
+                if (instance != null) {
+                    instance.schedulePeriodicUpdate();
+                }
+            } catch (RuntimeException e) {
+                Slog.wtf(TAG, "AppOpenEventIndexerManagerService.onUserUnlocking() failed", e);
+            }
+        }
+    }
+
+    /** Retrieves or creates the {@link AppOpenEventIndexerUserInstance} for the specified user. */
+    private AppOpenEventIndexerUserInstance getOrCreateUserInstance(
+            @NonNull UserHandle userHandle) {
+        synchronized (mAppOpenEventIndexersLocked) {
+            Objects.requireNonNull(userHandle);
+            AppOpenEventIndexerUserInstance instance = mAppOpenEventIndexersLocked.get(userHandle);
+
+            if (instance == null) {
+                if (LogUtil.INFO) {
+                    Log.i(TAG, "Creating AppOpenEventIndexerUserInstance for " + userHandle);
+                }
+                try {
+                    AppSearchEnvironment appSearchEnvironment =
+                            AppSearchEnvironmentFactory.getEnvironmentInstance();
+                    Context userContext =
+                            appSearchEnvironment.createContextAsUser(mContext, userHandle);
+                    File appSearchDir =
+                            appSearchEnvironment.getAppSearchDir(userContext, userHandle);
+                    File appOpenEventDir = new File(appSearchDir, "app-open-events");
+                    instance =
+                            AppOpenEventIndexerUserInstance.createInstance(
+                                    userContext, appOpenEventDir, mAppOpenEventIndexerConfig);
+                    mAppOpenEventIndexersLocked.put(userHandle, instance);
+                } catch (AppSearchException e) {
+                    Log.e(
+                            TAG,
+                            "Error while creating AppOpenEventIndexerUserInstance for "
+                                    + userHandle,
+                            e);
+                }
+            }
+            return instance;
+        }
+    }
+
+    class LocalService implements IndexerLocalService {
+        /** Runs an update for a user. */
+        @Override
+        public void doUpdateForUser(
+                @NonNull UserHandle userHandle, @Nullable CancellationSignal unused) {
+
+            Objects.requireNonNull(userHandle);
+            try {
+                synchronized (mAppOpenEventIndexersLocked) {
+                    AppOpenEventIndexerUserInstance instance = getOrCreateUserInstance(userHandle);
+                    if (instance != null) {
+                        if (mCallback != null) {
+                            instance.updateAsync(mCallback);
+                        } else {
+                            instance.updateAsync();
+                        }
+                    }
+                }
+            } catch (RuntimeException e) {
+                Slog.wtf(TAG, "AppOpenEventIndexerManagerService.doUpdateForUser() failed ", e);
+            }
+        }
+    }
+}
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerUserInstance.java b/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerUserInstance.java
new file mode 100644
index 00000000..86727316
--- /dev/null
+++ b/service/java/com/android/server/appsearch/appsindexer/AppOpenEventIndexerUserInstance.java
@@ -0,0 +1,290 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.appsindexer;
+
+import static com.android.server.appsearch.indexer.IndexerMaintenanceConfig.APP_OPEN_EVENT_INDEXER;
+
+import android.annotation.NonNull;
+import android.app.appsearch.AppSearchEnvironmentFactory;
+import android.app.appsearch.exceptions.AppSearchException;
+import android.content.Context;
+import android.util.Log;
+import android.util.Slog;
+
+import com.android.internal.annotations.VisibleForTesting;
+import com.android.server.appsearch.indexer.IndexerMaintenanceService;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.Objects;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * App Open Event Indexer for a single user.
+ *
+ * <p>It reads the updated opened apps from UsageStatsManager and syncs the changes into AppSearch
+ *
+ * <p>This class is thread safe.
+ *
+ * @hide
+ */
+public final class AppOpenEventIndexerUserInstance {
+
+    // Arbitrarily selected time to prevent indexer from running too frequently. It is scheduled to
+    // run once daily.
+    private static final long MIN_TIME_BETWEEN_UPDATES_MILLIS = 60 * 60 * 1000; // 1 hour
+
+    private static final String TAG = "AppSearchAppOpenEventIn";
+    private final AppOpenEventIndexerImpl mAppOpenEventIndexerImpl;
+    private final AppOpenEventIndexerSettings mAppOpenEventIndexerSettings;
+
+    // While IndexerSettings is not thread safe, it is only accessed through a single-threaded
+    // executor service. It will be read and updated before the next scheduled task accesses it.
+    private final File mDataDir;
+    private final Context mContext;
+
+    private final AppOpenEventIndexerConfig mAppOpenEventIndexerConfig;
+
+    /**
+     * Single threaded executor to make sure there is only one active sync per {@link
+     * BaseIndexerUserInstance}. Background tasks should be scheduled using {@link
+     * #executeOnSingleThreadedExecutor(Runnable)} which ensures that they are not executed if the
+     * executor is shutdown during {@link #shutdown()}.
+     *
+     * <p>Note that this executor is used as both work and callback executors which is fine because
+     * AppSearch should be able to handle exceptions thrown by them.
+     */
+    private final ExecutorService mSingleThreadedExecutor;
+
+    /**
+     * Constructs and initializes a {@link AppOpenEventIndexerUserInstance}.
+     *
+     * <p>Heavy operations such as connecting to AppSearch are performed asynchronously.
+     *
+     * @param appOpenEventIndexerDir directory for AppOpenEventIndexer.
+     */
+    @NonNull
+    public static AppOpenEventIndexerUserInstance createInstance(
+            @NonNull Context userContext,
+            @NonNull File appOpenEventIndexerDir,
+            @NonNull AppOpenEventIndexerConfig appOpenEventIndexerConfig)
+            throws AppSearchException {
+        Objects.requireNonNull(userContext);
+        Objects.requireNonNull(appOpenEventIndexerDir);
+        Objects.requireNonNull(appOpenEventIndexerConfig);
+
+        ExecutorService singleThreadedExecutor =
+                AppSearchEnvironmentFactory.getEnvironmentInstance().createSingleThreadExecutor();
+        return createInstance(
+                userContext,
+                appOpenEventIndexerDir,
+                appOpenEventIndexerConfig,
+                singleThreadedExecutor);
+    }
+
+    @VisibleForTesting
+    @NonNull
+    static AppOpenEventIndexerUserInstance createInstance(
+            @NonNull Context context,
+            @NonNull File appOpenEventIndexerDir,
+            @NonNull AppOpenEventIndexerConfig appOpenEventIndexerConfig,
+            @NonNull ExecutorService executorService)
+            throws AppSearchException {
+        Objects.requireNonNull(context);
+        Objects.requireNonNull(appOpenEventIndexerDir);
+        Objects.requireNonNull(appOpenEventIndexerConfig);
+        Objects.requireNonNull(executorService);
+        AppOpenEventIndexerImpl appOpenEventIndexerImpl = new AppOpenEventIndexerImpl(context);
+
+        AppOpenEventIndexerUserInstance indexer =
+                new AppOpenEventIndexerUserInstance(
+                        appOpenEventIndexerDir,
+                        executorService,
+                        context,
+                        appOpenEventIndexerImpl,
+                        new AppOpenEventIndexerSettings(appOpenEventIndexerDir),
+                        appOpenEventIndexerConfig);
+        indexer.loadSettingsAsync();
+
+        return indexer;
+    }
+
+    /**
+     * Constructs a {@link AppOpenEventIndexerUserInstance}.
+     *
+     * @param dataDir data directory for storing app open event indexer state.
+     * @param singleThreadedExecutor an {@link ExecutorService} with at most one thread to ensure
+     *     the thread safety of this class.
+     */
+    private AppOpenEventIndexerUserInstance(
+            @NonNull File dataDir,
+            @NonNull ExecutorService singleThreadedExecutor,
+            @NonNull Context context,
+            @NonNull AppOpenEventIndexerImpl appOpenEventIndexerImpl,
+            @NonNull AppOpenEventIndexerSettings appOpenEventIndexerSettings,
+            @NonNull AppOpenEventIndexerConfig appOpenEventIndexerConfig) {
+        mDataDir = Objects.requireNonNull(dataDir);
+        mSingleThreadedExecutor = Objects.requireNonNull(singleThreadedExecutor);
+        mContext = Objects.requireNonNull(context);
+        mAppOpenEventIndexerImpl = Objects.requireNonNull(appOpenEventIndexerImpl);
+        mAppOpenEventIndexerSettings = Objects.requireNonNull(appOpenEventIndexerSettings);
+        mAppOpenEventIndexerConfig = Objects.requireNonNull(appOpenEventIndexerConfig);
+    }
+
+    /** Shuts down the AppOpenEventIndexerUserInstance */
+    public void shutdown() throws InterruptedException {
+        mAppOpenEventIndexerImpl.close();
+        synchronized (mSingleThreadedExecutor) {
+            mSingleThreadedExecutor.shutdown();
+        }
+        boolean unused = mSingleThreadedExecutor.awaitTermination(30L, TimeUnit.SECONDS);
+    }
+
+    /** Dumps the internal state of this {@link AppOpenEventIndexerUserInstance}. */
+    public void dump(@NonNull PrintWriter pw) {
+        // Those timestamps are not protected by any lock since in AppOpenEventIndexerUserInstance
+        // we only have one thread to handle all the updates. It is possible we might run into
+        // race condition if there is an update running while those numbers are being printed.
+        // This is acceptable though for debug purpose, so still no lock here.
+        pw.println(
+                "last_update_timestamp_millis: "
+                        + mAppOpenEventIndexerSettings.getLastUpdateTimestampMillis());
+    }
+
+    /** Schedule an update on single threaded executor. */
+    public void updateAsync() {
+        executeOnSingleThreadedExecutor(
+                () -> {
+                    doUpdate();
+                    schedulePeriodicUpdate();
+                });
+    }
+
+    /**
+     * Schedule an update on a single-threaded executor.
+     *
+     * @param callback A callback to be invoked after the update is complete.
+     */
+    void updateAsync(@NonNull Runnable callback) {
+        executeOnSingleThreadedExecutor(
+                () -> {
+                    try {
+                        doUpdate();
+                        schedulePeriodicUpdate();
+                    } finally {
+                        callback.run();
+                    }
+                });
+    }
+
+    /** Loads the persisted data from disk asynchronously. */
+    private void loadSettingsAsync() {
+        executeOnSingleThreadedExecutor(
+                () -> {
+                    try {
+                        // If the directory already exists, this returns false. That is fine as it
+                        // might not be the first sync. If this returns true, that is fine as it is
+                        // the first run and we want to make a new directory.
+                        // TODO(b/357835538): Consider moving this to
+                        // IndexerSettings#ensureFileCreated.  Would need to migrate the same logic
+                        // in App and Contact indexers. No real blockers aside from launching it
+                        // behind a flag.
+                        mDataDir.mkdirs();
+                    } catch (SecurityException e) {
+                        Log.e(TAG, "Failed to create settings directory on disk.", e);
+                        return;
+                    }
+
+                    try {
+                        mAppOpenEventIndexerSettings.load();
+                    } catch (IOException e) {
+                        // Ignore file not found errors (bootstrap case)
+                        if (!(e instanceof FileNotFoundException)) {
+                            Log.e(TAG, "Failed to load settings from disk", e);
+                        }
+                    }
+                });
+    }
+
+    /**
+     * Executes the given command on {@link #mSingleThreadedExecutor} if it is still alive.
+     *
+     * <p>If the {@link #mSingleThreadedExecutor} has been shutdown, this method doesn't execute the
+     * given command, and returns silently. Specifically, it does not throw {@link
+     * java.util.concurrent.RejectedExecutionException}.
+     *
+     * @param command the runnable task
+     */
+    private void executeOnSingleThreadedExecutor(Runnable command) {
+        synchronized (mSingleThreadedExecutor) {
+            if (mSingleThreadedExecutor.isShutdown()) {
+                Log.w(TAG, "Executor is shutdown, not executing task");
+                return;
+            }
+            mSingleThreadedExecutor.execute(
+                    () -> {
+                        try {
+                            command.run();
+                        } catch (RuntimeException e) {
+                            Slog.wtf(TAG, "executeOnSingleThreadedExecutor failed", e);
+                        }
+                    });
+        }
+    }
+
+    /**
+     * Does the update by verifying if it's been run before, syncing the app open events to
+     * AppSearch and finally persisting the settings. If the update has been run within the last
+     * {@code MIN_TIME_BETWEEN_UPDATES_MILLIS} it will be a no-op.
+     */
+    @VisibleForTesting
+    void doUpdate() {
+        try {
+            long lastUpdateMillis = mAppOpenEventIndexerSettings.getLastUpdateTimestampMillis();
+            long currentTimeMillis = System.currentTimeMillis();
+
+            if (currentTimeMillis - lastUpdateMillis < MIN_TIME_BETWEEN_UPDATES_MILLIS) {
+                Log.w(TAG, "Skipping update because last update was too recent");
+                return;
+            }
+            mAppOpenEventIndexerImpl.doUpdate(mAppOpenEventIndexerSettings);
+            mAppOpenEventIndexerSettings.persist();
+        } catch (IOException e) {
+            Log.w(TAG, "Failed to save settings to disk", e);
+        } catch (AppSearchException e) {
+            Log.e(TAG, "Failed to sync app open events to AppSearch", e);
+        }
+    }
+
+    /**
+     * Schedules the next indexer update job. The {@link IndexerMaintenanceService} deduplicates
+     * this by checking the job info (which includes job ID). This ensures only 1 scheduled periodic
+     * task per indexer type per user.
+     */
+    public void schedulePeriodicUpdate() {
+        IndexerMaintenanceService.scheduleUpdateJob(
+                mContext,
+                mContext.getUser(),
+                APP_OPEN_EVENT_INDEXER,
+                /* periodic= */ true,
+                /* intervalMillis= */ mAppOpenEventIndexerConfig
+                        .getAppOpenEventMaintenanceUpdateIntervalMillis());
+    }
+}
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppSearchHelper.java b/service/java/com/android/server/appsearch/appsindexer/AppSearchHelper.java
index ed29c1ce..8be0f7c1 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppSearchHelper.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppSearchHelper.java
@@ -16,6 +16,10 @@
 
 package com.android.server.appsearch.appsindexer;
 
+import static android.app.appsearch.AppSearchResult.RESULT_INVALID_ARGUMENT;
+import static android.app.appsearch.AppSearchResult.RESULT_IO_ERROR;
+
+import android.annotation.CurrentTimeMillisLong;
 import android.annotation.NonNull;
 import android.annotation.WorkerThread;
 import android.app.appsearch.AppSearchBatchResult;
@@ -23,8 +27,6 @@ import android.app.appsearch.AppSearchEnvironmentFactory;
 import android.app.appsearch.AppSearchManager;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.AppSearchSchema;
-import android.app.appsearch.AppSearchSession;
-import android.app.appsearch.BatchResultCallback;
 import android.app.appsearch.GenericDocument;
 import android.app.appsearch.PackageIdentifier;
 import android.app.appsearch.PutDocumentsRequest;
@@ -41,10 +43,13 @@ import android.util.Log;
 
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionStaticMetadata;
+import com.android.server.appsearch.appsindexer.appsearchtypes.AppOpenEvent;
 import com.android.server.appsearch.appsindexer.appsearchtypes.MobileApplication;
 
 import java.io.Closeable;
+import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
@@ -77,10 +82,17 @@ public class AppSearchHelper implements Closeable {
     // Therefore each application needs its own schema. We put all these schema into a single
     // database by dynamically renaming the schema so that they have different names.
     public static final String APP_DATABASE = "apps-db";
+
+    // The app open event indexer needs to be in a separate database from the apps indexer because
+    // they will have schemas set at separate times by separate services.
+    public static final String APP_OPEN_EVENTS_DATABASE = "app-open-events-db";
+
     private static final int GET_APP_IDS_PAGE_SIZE = 1000;
     private final Context mContext;
     // Volatile, not final due to being swapped during some tests
-    private volatile SyncAppSearchSession mSyncAppSearchSession;
+    private volatile SyncAppSearchSession mSyncAppSearchAppsDbSession;
+    private volatile SyncAppSearchSession mSyncAppSearchAppOpenEventDbSession;
+
     private final SyncGlobalSearchSession mSyncGlobalSearchSession;
 
     /** Creates an {@link AppSearchHelper}. */
@@ -91,17 +103,25 @@ public class AppSearchHelper implements Closeable {
             throw new AndroidRuntimeException(
                     "Can't get AppSearchManager to initialize AppSearchHelper.");
         }
-        AppSearchManager.SearchContext searchContext =
+        AppSearchManager.SearchContext appsSearchContext =
                 new AppSearchManager.SearchContext.Builder(APP_DATABASE).build();
+        AppSearchManager.SearchContext appOpenEventsSearchContext =
+                new AppSearchManager.SearchContext.Builder(APP_OPEN_EVENTS_DATABASE).build();
         ExecutorService executor =
                 AppSearchEnvironmentFactory.getEnvironmentInstance().createSingleThreadExecutor();
-        mSyncAppSearchSession =
-                new SyncAppSearchSessionImpl(appSearchManager, searchContext, executor);
+
+        mSyncAppSearchAppsDbSession =
+                new SyncAppSearchSessionImpl(appSearchManager, appsSearchContext, executor);
+        mSyncAppSearchAppOpenEventDbSession =
+                new SyncAppSearchSessionImpl(
+                        appSearchManager, appOpenEventsSearchContext, executor);
+
         mSyncGlobalSearchSession = new SyncGlobalSearchSessionImpl(appSearchManager, executor);
     }
 
     /**
-     * Allows us to test various scenarios involving SyncAppSearchSession.
+     * Allows us to test various scenarios involving SyncAppSearchSession. Sets all sessions to the
+     * SyncAppSearchSession passed in for convenience only as it is only used for testing.
      *
      * <p>This method is not thread-safe, as it could be ran in the middle of a set schema, index,
      * or search operation. It should only be called from tests, and threading safety should be
@@ -110,10 +130,14 @@ public class AppSearchHelper implements Closeable {
     @VisibleForTesting
     /* package */ void setAppSearchSessionForTest(@NonNull SyncAppSearchSession session) {
         // Close the existing one
-        if (mSyncAppSearchSession != null) {
-            mSyncAppSearchSession.close();
+        if (mSyncAppSearchAppsDbSession != null) {
+            mSyncAppSearchAppsDbSession.close();
+        }
+        if (mSyncAppSearchAppOpenEventDbSession != null) {
+            mSyncAppSearchAppOpenEventDbSession.close();
         }
-        mSyncAppSearchSession = Objects.requireNonNull(session);
+        mSyncAppSearchAppsDbSession = Objects.requireNonNull(session);
+        mSyncAppSearchAppOpenEventDbSession = Objects.requireNonNull(session);
     }
 
     /**
@@ -171,9 +195,29 @@ public class AppSearchHelper implements Closeable {
         }
 
         // TODO(b/275592563): Log app removal in metrics
-        mSyncAppSearchSession.setSchema(schemaBuilder.build());
+        mSyncAppSearchAppsDbSession.setSchema(schemaBuilder.build());
     }
 
+    /**
+     * Sets the schema for AppOpenEvent. Unlike the apps indexer and apps functions, this schema is
+     * not per-package permissioned. It is a single schema that is shared by all packages, with
+     * PACKAGE_USAGE_STATS as the required permission to mimic the UsageStatsManager API.
+     */
+    @WorkerThread
+    public void setSchemaForAppOpenEvents() throws AppSearchException {
+        SetSchemaRequest.Builder schemaBuilder =
+                new SetSchemaRequest.Builder()
+                        .addRequiredPermissionsForSchemaTypeVisibility(
+                                AppOpenEvent.SCHEMA_TYPE,
+                                Collections.singleton(SetSchemaRequest.PACKAGE_USAGE_STATS))
+                        .setForceOverride(true)
+                        .addSchemas(AppOpenEvent.SCHEMA);
+
+        mSyncAppSearchAppOpenEventDbSession.setSchema(schemaBuilder.build());
+    }
+
+    // TODO(b/367410454): Remove this method once enable_apps_indexer_incremental_put flag is
+    //  rolled out
     /**
      * Indexes a collection of apps into AppSearch. This requires that the corresponding
      * MobileApplication and AppFunctionStaticMetadata schemas are already set by a previous call to
@@ -184,6 +228,8 @@ public class AppSearchHelper implements Closeable {
      * @param currentAppFunctions a list of AppFunctionStaticMetadata documents to be inserted. Each
      *     AppFunctionStaticMetadata should point to its corresponding MobileApplication.
      * @param indexedAppFunctions a list of indexed AppFunctionStaticMetadata documents
+     * @param appsUpdateStats stats object to update, necessary as we determine number of deleted
+     *     functions in this method.
      * @throws AppSearchException if indexing results in a {@link
      *     AppSearchResult#RESULT_OUT_OF_SPACE} result code. It will also throw this if the put call
      *     results in a system error as in {@link BatchResultCallback#onSystemError}. This may
@@ -199,10 +245,12 @@ public class AppSearchHelper implements Closeable {
     public AppSearchBatchResult<String, Void> indexApps(
             @NonNull List<MobileApplication> apps,
             @NonNull List<AppFunctionStaticMetadata> currentAppFunctions,
-            @NonNull List<GenericDocument> indexedAppFunctions)
+            @NonNull List<GenericDocument> indexedAppFunctions,
+            @NonNull AppsUpdateStats appsUpdateStats)
             throws AppSearchException {
         Objects.requireNonNull(apps);
         Objects.requireNonNull(currentAppFunctions);
+        Objects.requireNonNull(appsUpdateStats);
 
         // For packages that we are re-indexing, we need to collect a list of stale of function IDs.
         Set<String> packagesToReindex = new ArraySet<>();
@@ -234,7 +282,7 @@ public class AppSearchHelper implements Closeable {
                         .addGenericDocuments(currentAppFunctions)
                         .build();
 
-        AppSearchBatchResult<String, Void> result = mSyncAppSearchSession.put(request);
+        AppSearchBatchResult<String, Void> result = mSyncAppSearchAppsDbSession.put(request);
         if (!result.isSuccess()) {
             Map<String, AppSearchResult<Void>> failures = result.getFailures();
             for (AppSearchResult<Void> failure : failures.values()) {
@@ -248,8 +296,9 @@ public class AppSearchHelper implements Closeable {
             }
         }
 
+        appsUpdateStats.mApproximateNumberOfFunctionsRemoved = appFunctionIdsToRemove.size();
         // Then, delete all the stale documents.
-        mSyncAppSearchSession.remove(
+        mSyncAppSearchAppsDbSession.remove(
                 new RemoveByDocumentIdRequest.Builder(
                                 AppFunctionStaticMetadata.APP_FUNCTION_NAMESPACE)
                         .addIds(appFunctionIdsToRemove)
@@ -257,6 +306,170 @@ public class AppSearchHelper implements Closeable {
         return result;
     }
 
+    /**
+     * Indexes a collection of app open events into AppSearch. This requires that the AppOpenEvent
+     * schema is already set by a previous call to {@link setSchemaForAppOpenEvents}.
+     *
+     * @param appOpenEvents a list of {@link AppOpenEvent}s.
+     * @throws AppSearchException if indexing results in a {@link
+     *     AppSearchResult#RESULT_OUT_OF_SPACE} result code.
+     */
+    @WorkerThread
+    public AppSearchBatchResult<String, Void> indexAppOpenEvents(
+            @NonNull List<AppOpenEvent> appOpenEvents) throws AppSearchException {
+        Objects.requireNonNull(appOpenEvents);
+
+        PutDocumentsRequest request =
+                new PutDocumentsRequest.Builder().addGenericDocuments(appOpenEvents).build();
+
+        AppSearchBatchResult<String, Void> result =
+                mSyncAppSearchAppOpenEventDbSession.put(request);
+        if (!result.isSuccess()) {
+            Map<String, AppSearchResult<Void>> failures = result.getFailures();
+            for (AppSearchResult<Void> failure : failures.values()) {
+                // If it's out of space, stop indexing
+                if (failure.getResultCode() == AppSearchResult.RESULT_OUT_OF_SPACE) {
+                    throw new AppSearchException(
+                            failure.getResultCode(), failure.getErrorMessage());
+                } else {
+                    Log.e(TAG, "Ran into error while indexing apps: " + failure);
+                }
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Indexes a collection of apps and a collection of app functions into AppSearch. This requires
+     * that the corresponding {@link MobileApplication} and {@link AppFunctionStaticMetadata}
+     * schemas are already set by a previous call to {@link #setSchemasForPackages}. The call
+     * doesn't necessarily have to happen in the current sync.
+     *
+     * @param apps a list of {@link MobileApplication} documents to be inserted.
+     * @param currentAppFunctions a list of {@link AppFunctionStaticMetadata} documents to be
+     *     AppFunctionStaticMetadata should point to its corresponding MobileApplication.
+     * @throws AppSearchException if indexing results in a {@link
+     *     AppSearchResult#RESULT_OUT_OF_SPACE} result code. It will also throw this if the put call
+     *     results in a system error as in {@link BatchResultCallback#onSystemError}. This may
+     *     happen if the AppSearch service unexpectedly fails to initialize and can't be recovered,
+     *     for instance.
+     * @return an {@link AppSearchBatchResult} containing the results of the put operation. The keys
+     *     of the returned {@link AppSearchBatchResult} are the IDs of the input documents. The
+     *     values are {@code null} if they were successfully indexed, or a failed {@link
+     *     AppSearchResult} otherwise.
+     * @see AppSearchSession#put
+     */
+    @WorkerThread
+    public AppSearchBatchResult<String, Void> indexApps(
+            @NonNull List<MobileApplication> apps,
+            @NonNull List<AppFunctionStaticMetadata> currentAppFunctions)
+            throws AppSearchException {
+        Objects.requireNonNull(apps);
+        Objects.requireNonNull(currentAppFunctions);
+
+        // Insert all the documents. At this point, the proper schemas should've been set.
+        PutDocumentsRequest request =
+                new PutDocumentsRequest.Builder()
+                        .addGenericDocuments(apps)
+                        .addGenericDocuments(currentAppFunctions)
+                        .build();
+
+        AppSearchBatchResult<String, Void> result = mSyncAppSearchAppsDbSession.put(request);
+        if (!result.isSuccess()) {
+            Map<String, AppSearchResult<Void>> failures = result.getFailures();
+            for (AppSearchResult<Void> failure : failures.values()) {
+                // If it's out of space, stop indexing
+                if (failure.getResultCode() == AppSearchResult.RESULT_OUT_OF_SPACE) {
+                    throw new AppSearchException(
+                            failure.getResultCode(), failure.getErrorMessage());
+                } else {
+                    Log.e(TAG, "Ran into error while indexing apps: " + failure);
+                }
+            }
+        }
+        return result;
+    }
+
+    /** Uses remove by id to remove app functions from AppSearch */
+    @WorkerThread
+    public AppSearchBatchResult<String, Void> removeAppFunctionsById(
+            @NonNull Collection<String> appFunctionIds) throws AppSearchException {
+        Objects.requireNonNull(appFunctionIds);
+        return mSyncAppSearchAppsDbSession.remove(
+                new RemoveByDocumentIdRequest.Builder(
+                                AppFunctionStaticMetadata.APP_FUNCTION_NAMESPACE)
+                        .addIds(appFunctionIds)
+                        .build());
+    }
+
+    /**
+     * Returns a mapping of packages to a mapping of function ids to {@link
+     * AppFunctionStaticMetadata} objects. This is useful for determining what has changed during an
+     * update.
+     *
+     * @param appPackageIds a set of package ids for which to retrieve functions from AppSearch.
+     */
+    @NonNull
+    @WorkerThread
+    public Map<String, Map<String, AppFunctionStaticMetadata>> getAppFunctionsFromAppSearch(
+            List<String> appPackageIds) throws AppSearchException {
+        SearchSpec.Builder allAppFunctionsSpec =
+                new SearchSpec.Builder()
+                        .addFilterNamespaces(AppFunctionStaticMetadata.APP_FUNCTION_NAMESPACE)
+                        .setResultCountPerPage(GET_APP_IDS_PAGE_SIZE);
+
+        for (int i = 0; i < appPackageIds.size(); i++) {
+            String appPackageId = appPackageIds.get(i);
+            allAppFunctionsSpec.addFilterSchemas(
+                    AppFunctionStaticMetadata.getSchemaNameForPackage(
+                        appPackageId, /** schemaType= */ null));
+        }
+
+        SyncSearchResults results =
+                mSyncAppSearchAppsDbSession.search("", allAppFunctionsSpec.build());
+
+        return collectAppFunctionDocumentsFromAllPages(results);
+    }
+
+    /**
+     * Iterates through result pages and returns a mapping of package names to a mapping of function
+     * ids to the corresponding app function currently indexed into AppSearch.
+     */
+    @NonNull
+    @WorkerThread
+    private Map<String, Map<String, AppFunctionStaticMetadata>>
+            collectAppFunctionDocumentsFromAllPages(@NonNull SyncSearchResults results) {
+        Map<String, Map<String, AppFunctionStaticMetadata>> appFunctionsMap = new ArrayMap<>();
+        // TODO(b/357551503): If possible, use pagination instead of building a map containing all
+        // function docs.
+        try {
+            List<SearchResult> resultList = results.getNextPage();
+            while (!resultList.isEmpty()) {
+                for (int i = 0; i < resultList.size(); i++) {
+                    GenericDocument genericDocument = resultList.get(i).getGenericDocument();
+                    String packageName =
+                            genericDocument.getPropertyString(
+                                    AppFunctionStaticMetadata.PROPERTY_PACKAGE_NAME);
+
+                    Map<String, AppFunctionStaticMetadata> functionsForPackage =
+                            appFunctionsMap.get(packageName);
+                    if (functionsForPackage == null) {
+                        functionsForPackage = new ArrayMap<>();
+                        appFunctionsMap.put(packageName, functionsForPackage);
+                    }
+                    functionsForPackage.put(
+                            genericDocument.getPropertyString(
+                                    AppFunctionStaticMetadata.PROPERTY_FUNCTION_ID),
+                            new AppFunctionStaticMetadata(genericDocument));
+                }
+                resultList = results.getNextPage();
+            }
+        } catch (AppSearchException e) {
+            Log.e(TAG, "Error while searching for all app documents", e);
+        }
+        return appFunctionsMap;
+    }
+
     /**
      * Searches AppSearch and returns a Map with the package ids and their last updated times. This
      * helps us determine which app documents need to be re-indexed.
@@ -276,8 +489,58 @@ public class AppSearchHelper implements Closeable {
                         .addFilterPackageNames(mContext.getPackageName())
                         .setResultCountPerPage(GET_APP_IDS_PAGE_SIZE)
                         .build();
-        SyncSearchResults results = mSyncGlobalSearchSession.search(/* query= */ "", allAppsSpec);
-        return collectUpdatedTimestampFromAllPages(results);
+        try (SyncSearchResults results =
+                mSyncGlobalSearchSession.search(/* query= */ "", allAppsSpec)) {
+            return collectUpdatedTimestampFromAllPages(results);
+        } catch (IOException e) {
+            throw new AppSearchException(RESULT_IO_ERROR, "Failed to close search results", e);
+        }
+    }
+
+    /**
+     * Searches AppSearch and returns the AppOpenEvent with the next app open event timestamp
+     * (larger time in epoch) after the provided timestamp threshold.
+     *
+     * @param timestampThresholdMillis the timestamp to filter the app open events by. The returned
+     *     timestamp will be after this timestamp.
+     * @return the first AppOpenEvent whose timestamp occurs after the provided timestamp.
+     * @throws AppSearchException if no results are found for the given timestamp threshold.
+     */
+    @NonNull
+    @WorkerThread
+    public AppOpenEvent getSubsequentAppOpenEventAfterThreshold(
+            @CurrentTimeMillisLong long timestampThresholdMillis) throws AppSearchException {
+
+        // Creation timestamp is set to event timestamp, so sorting in ascending order of creation
+        // timestamp gives us
+        // the first event after the threshold.
+        SearchSpec latestAppOpenEventsSpec =
+                new SearchSpec.Builder()
+                        .addFilterNamespaces(AppOpenEvent.APP_OPEN_EVENT_NAMESPACE)
+                        .setOrder(SearchSpec.ORDER_ASCENDING)
+                        .setListFilterQueryLanguageEnabled(true)
+                        .setNumericSearchEnabled(true)
+                        .setResultCountPerPage(1)
+                        .setRankingStrategy(SearchSpec.RANKING_STRATEGY_CREATION_TIMESTAMP)
+                        .build();
+
+        try (SyncSearchResults results =
+                mSyncAppSearchAppOpenEventDbSession.search(
+                        /* query= */ "appOpenTimestampMillis > " + timestampThresholdMillis,
+                        latestAppOpenEventsSpec)) {
+
+            List<SearchResult> page = results.getNextPage();
+
+            if (page.isEmpty()) {
+                throw new AppSearchException(
+                        RESULT_INVALID_ARGUMENT,
+                        "No app open events were found for the given timestamp threshold.");
+            }
+            return new AppOpenEvent(page.get(0).getGenericDocument());
+
+        } catch (IOException e) {
+            throw new AppSearchException(RESULT_IO_ERROR, "Failed to close search results", e);
+        }
     }
 
     /**
@@ -318,6 +581,8 @@ public class AppSearchHelper implements Closeable {
 
     // TODO(b/357551503): Refactor/combine these two methods with the above to simplify code.
 
+    // TODO(b/367410454): Remove this method once enable_apps_indexer_incremental_put flag is
+    //  rolled out
     /**
      * Searches AppSearch and returns a list of app function GenericDocuments.
      *
@@ -337,9 +602,9 @@ public class AppSearchHelper implements Closeable {
                         .addFilterPackageNames(mContext.getPackageName())
                         .setResultCountPerPage(GET_APP_IDS_PAGE_SIZE)
                         .build();
-        SyncSearchResults results = mSyncGlobalSearchSession.search(/* query= */ "", allAppsSpec);
-        // TODO(b/357551503): Use pagination instead of building a list of all docs.
-        try {
+        try (SyncSearchResults results =
+                mSyncGlobalSearchSession.search(/* query= */ "", allAppsSpec)) {
+            // TODO(b/357551503): Use pagination instead of building a list of all docs.
             List<SearchResult> resultList = results.getNextPage();
             while (!resultList.isEmpty()) {
                 for (int i = 0; i < resultList.size(); i++) {
@@ -347,12 +612,16 @@ public class AppSearchHelper implements Closeable {
                 }
                 resultList = results.getNextPage();
             }
+        } catch (IOException e) {
+            throw new AppSearchException(RESULT_IO_ERROR, "Failed to close search results", e);
         } catch (AppSearchException e) {
             Log.e(TAG, "Error while searching for all app documents", e);
         }
         return appFunctions;
     }
 
+    // TODO(b/367410454): Remove this method once enable_apps_indexer_incremental_put flag is
+    //  rolled out
     /**
      * Iterates through result pages and returns a set of package name corresponding to the packages
      * that have app functions currently indexed into AppSearch.
@@ -389,7 +658,8 @@ public class AppSearchHelper implements Closeable {
     /** Closes the AppSearch sessions. */
     @Override
     public void close() {
-        mSyncAppSearchSession.close();
+        mSyncAppSearchAppsDbSession.close();
+        mSyncAppSearchAppOpenEventDbSession.close();
         mSyncGlobalSearchSession.close();
     }
 }
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppsIndexerConfig.java b/service/java/com/android/server/appsearch/appsindexer/AppsIndexerConfig.java
index efb3e72c..5737a3d6 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppsIndexerConfig.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppsIndexerConfig.java
@@ -29,9 +29,16 @@ public interface AppsIndexerConfig {
     boolean DEFAULT_APPS_INDEXER_ENABLED = true;
 
     long DEFAULT_APPS_UPDATE_INTERVAL_MILLIS = TimeUnit.DAYS.toMillis(30); // 30 days.
+
     /** The default maximum number of app functions per package that the app indexer will index. */
     int DEFAULT_MAX_APP_FUNCTIONS_PER_PACKAGE = 500;
 
+    /**
+     * The default maximum number of app function schemas per package that the app indexer will
+     * index.
+     */
+    int DEFAULT_MAX_ALLOWED_APP_FUNCTION_SCHEMAS_PER_PACKAGE = 5;
+
     /** Returns whether Apps Indexer is enabled. */
     boolean isAppsIndexerEnabled();
 
@@ -40,5 +47,7 @@ public interface AppsIndexerConfig {
 
     /** Returns the max number of app functions the app indexer will index per package. */
     int getMaxAppFunctionsPerPackage();
-}
 
+    /** Returns the max number of app function schemas the app indexer will index per package. */
+    int getMaxAllowedAppFunctionSchemasPerPackage();
+}
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppsIndexerImpl.java b/service/java/com/android/server/appsearch/appsindexer/AppsIndexerImpl.java
index b8e87419..128785b6 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppsIndexerImpl.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppsIndexerImpl.java
@@ -64,6 +64,293 @@ public final class AppsIndexerImpl implements Closeable {
         mAppsIndexerConfig = Objects.requireNonNull(appsIndexerConfig);
     }
 
+    /**
+     * Checks PackageManager and AppSearch to sync the Apps Index in AppSearch.
+     *
+     * <p>It deletes removed apps, inserts newly-added ones, and updates existing ones in the App
+     * corpus in AppSearch.
+     *
+     * @param settings contains update timestamps that help the indexer determine which apps were
+     *     updated.
+     * @param appsUpdateStats contains stats about the apps indexer update. This method will
+     *     populate the fields of this {@link AppsUpdateStats} structure.
+     */
+    @VisibleForTesting
+    @WorkerThread
+    public void doUpdateIncrementalPut(
+            @NonNull AppsIndexerSettings settings, @NonNull AppsUpdateStats appsUpdateStats)
+            throws AppSearchException {
+        // TODO(b/357551503): Add metrics for app function indexing
+        Objects.requireNonNull(settings);
+        Objects.requireNonNull(appsUpdateStats);
+        long currentTimeMillis = System.currentTimeMillis();
+
+        // Search AppSearch for MobileApplication objects to get a "current" list of indexed apps.
+        long beforeGetTimestamp = SystemClock.elapsedRealtime();
+        Map<String, Long> appUpdatedTimestamps = mAppSearchHelper.getAppsFromAppSearch();
+
+        appsUpdateStats.mAppSearchGetLatencyMillis =
+                SystemClock.elapsedRealtime() - beforeGetTimestamp;
+
+        long beforePackageManagerTimestamp = SystemClock.elapsedRealtime();
+        PackageManager packageManager = mContext.getPackageManager();
+        Map<PackageInfo, ResolveInfos> packagesToIndex =
+                AppsUtil.getPackagesToIndex(packageManager);
+        appsUpdateStats.mPackageManagerLatencyMillis =
+                SystemClock.elapsedRealtime() - beforePackageManagerTimestamp;
+
+        List<AppFunctionStaticMetadata> functionsToAddOrUpdate = new ArrayList<>();
+        // To remove, we only need the id
+        Set<String> functionIdsToRemove = new ArraySet<>();
+
+        long mostRecentAppUpdatedTimestampMillis = settings.getLastAppUpdateTimestampMillis();
+
+        // This boolean will be turned on if an app was added, an app was removed, all app
+        // functions were removed from an app, or app functions were added to an app that
+        // didn't have them previously. In all cases, we need to call setSchema to keep
+        // AppSearch in sync with PackageManager.
+        boolean addedOrRemovedFlag = false;
+
+        Set<String> packagesToIndexIdSet = new ArraySet<>();
+
+        // Prepare a list of newly added and updated packages. Added packages will have all
+        // their app functions added to AppSearch, without checking what's in AppSearch. Updated
+        // packages will require an additional call to AppSearch to see if we need to
+        // add/update/remove individual app function documents. We don't do this for added apps as
+        // we can just assume we need to add all of them. This saves a call to AppSearch. For both
+        // added and updated packages, we parse xml. We don't check what functions are in AppSearch
+        // for removed packages, as we can just remove the entire MobileApplication +
+        // AppFunctionStaticMetadata schemas, which will in turn remove the documents.
+        Map<PackageInfo, ResolveInfos> packagesToBeAddedOrUpdated = new ArrayMap<>();
+        List<String> updatedPackageIds = new ArrayList<>();
+
+        // First loop, determine the status of apps
+        for (Map.Entry<PackageInfo, ResolveInfos> packageEntry : packagesToIndex.entrySet()) {
+            PackageInfo packageInfo = packageEntry.getKey();
+            packagesToIndexIdSet.add(packageInfo.packageName);
+
+            // Update the most recent timestamp as we iterate
+            if (packageInfo.lastUpdateTime > mostRecentAppUpdatedTimestampMillis) {
+                mostRecentAppUpdatedTimestampMillis = packageInfo.lastUpdateTime;
+            }
+
+            Long storedAppUpdateTime = appUpdatedTimestamps.get(packageInfo.packageName);
+
+            if (storedAppUpdateTime == null) {
+                // New app.
+                addedOrRemovedFlag = true;
+                appsUpdateStats.mNumberOfAppsAdded++;
+                packagesToBeAddedOrUpdated.put(packageInfo, packageEntry.getValue());
+            } else if (packageInfo.lastUpdateTime > storedAppUpdateTime) {
+                // Package updated. Add this to the list of updated apps so we can check what
+                // functions are indexed in AppSearch
+                appsUpdateStats.mNumberOfAppsUpdated++;
+                updatedPackageIds.add(packageInfo.packageName);
+                packagesToBeAddedOrUpdated.put(packageInfo, packagesToIndex.get(packageInfo));
+            } else {
+                // Not updated.
+                appsUpdateStats.mNumberOfAppsUnchanged++;
+            }
+        }
+
+        // Now check for removed apps
+        for (String appPackageId : appUpdatedTimestamps.keySet()) {
+            if (!packagesToIndexIdSet.contains(appPackageId)) {
+                // App was removed, remove all it's functions. This is simple because removing the
+                // schema will remove all the functions. Do not add the app to the list of schemas
+                // to set.
+                appsUpdateStats.mNumberOfAppsRemoved++;
+                addedOrRemovedFlag = true;
+            }
+        }
+
+        // Parse and build all necessary AppFunctionStaticMetadata from PackageManager.
+        Map<String, Map<String, AppFunctionStaticMetadata>>
+                currentAppFunctionsForAddedUpdatedPackages =
+                        AppsUtil.buildAppFunctionStaticMetadataIntoMap(
+                                packageManager,
+                                packagesToBeAddedOrUpdated,
+                                /* indexerPackageName= */ mContext.getPackageName(),
+                                mAppsIndexerConfig.getMaxAppFunctionsPerPackage());
+
+        // Get all currently indexed AppFunctionStaticMetadata docs for the necessary packages.
+        Map<String, Map<String, AppFunctionStaticMetadata>> appFunctionsFromAppSearch =
+                mAppSearchHelper.getAppFunctionsFromAppSearch(updatedPackageIds);
+
+        for (Map.Entry<String, Map<String, AppFunctionStaticMetadata>> packageEntry :
+                currentAppFunctionsForAddedUpdatedPackages.entrySet()) {
+            String packageName = packageEntry.getKey();
+            Map<String, AppFunctionStaticMetadata> currentAppFunctionsPerApp =
+                    packageEntry.getValue();
+
+            // This might be null, in the case of functions newly added to a package
+            Map<String, AppFunctionStaticMetadata> appSearchAppFunctionsPerApp =
+                    appFunctionsFromAppSearch.get(packageName);
+
+            if (appSearchAppFunctionsPerApp == null && !currentAppFunctionsPerApp.isEmpty()) {
+                // Functions added to an app that didn't have them
+                functionsToAddOrUpdate.addAll(currentAppFunctionsPerApp.values());
+                addedOrRemovedFlag = true;
+            }
+
+            if (appSearchAppFunctionsPerApp != null) {
+                if (currentAppFunctionsPerApp.isEmpty()) {
+                    // All functions removed from an app that had them
+                    addedOrRemovedFlag = true;
+                } else {
+                    // App updated that had packages, we should check
+                    comparePackageFunctions(
+                            currentAppFunctionsPerApp,
+                            appSearchAppFunctionsPerApp,
+                            functionsToAddOrUpdate,
+                            functionIdsToRemove);
+                }
+            }
+        }
+
+        try {
+            if (addedOrRemovedFlag) {
+                // This boolean will be turned on if we need to call setSchema to keep AppSearch in
+                // sync with PackageManager.
+                List<PackageIdentifier> packageIdentifiers = new ArrayList<>();
+                List<PackageIdentifier> packageIdentifiersWithAppFunctions = new ArrayList<>();
+
+                for (Map.Entry<PackageInfo, ResolveInfos> entry : packagesToIndex.entrySet()) {
+                    // We get certificates here as getting the certificates during the previous for
+                    // loop would be wasteful if we end up not needing to call set schema
+                    PackageInfo packageInfo = entry.getKey();
+                    byte[] certificate = AppsUtil.getCertificate(packageInfo);
+                    if (certificate == null) {
+                        Log.e(TAG, "Certificate not found for package: " + packageInfo.packageName);
+                        continue;
+                    }
+                    PackageIdentifier packageIdentifier =
+                            new PackageIdentifier(packageInfo.packageName, certificate);
+                    packageIdentifiers.add(packageIdentifier);
+                    if (entry.getValue().getAppFunctionServiceInfo() != null) {
+                        packageIdentifiersWithAppFunctions.add(packageIdentifier);
+                    }
+                }
+                // The certificate is necessary along with the package name as it is used in
+                // visibility settings.
+                long beforeSetSchemaTimestamp = SystemClock.elapsedRealtime();
+                mAppSearchHelper.setSchemasForPackages(
+                        packageIdentifiers, packageIdentifiersWithAppFunctions);
+                appsUpdateStats.mAppSearchSetSchemaLatencyMillis =
+                        SystemClock.elapsedRealtime() - beforeSetSchemaTimestamp;
+            }
+
+            if (!packagesToBeAddedOrUpdated.isEmpty() || !functionsToAddOrUpdate.isEmpty()) {
+                long beforePutTimestamp = SystemClock.elapsedRealtime();
+                List<MobileApplication> mobileApplications =
+                        AppsUtil.buildAppsFromPackageInfos(
+                                packageManager, packagesToBeAddedOrUpdated);
+
+                AppSearchBatchResult<String, Void> result =
+                        mAppSearchHelper.indexApps(mobileApplications, functionsToAddOrUpdate);
+                if (result.isSuccess()) {
+                    appsUpdateStats.mUpdateStatusCodes.add(AppSearchResult.RESULT_OK);
+                } else {
+                    Collection<AppSearchResult<Void>> values = result.getAll().values();
+
+                    for (AppSearchResult<Void> putResult : values) {
+                        appsUpdateStats.mUpdateStatusCodes.add(putResult.getResultCode());
+                    }
+                }
+
+                appsUpdateStats.mAppSearchPutLatencyMillis =
+                        SystemClock.elapsedRealtime() - beforePutTimestamp;
+            }
+
+            if (!functionIdsToRemove.isEmpty()) {
+                AppSearchBatchResult<String, Void> result =
+                        mAppSearchHelper.removeAppFunctionsById(functionIdsToRemove);
+                if (result.isSuccess()) {
+                    appsUpdateStats.mUpdateStatusCodes.add(AppSearchResult.RESULT_OK);
+                }
+            }
+
+            settings.setLastAppUpdateTimestampMillis(mostRecentAppUpdatedTimestampMillis);
+            settings.setLastUpdateTimestampMillis(currentTimeMillis);
+
+            appsUpdateStats.mLastAppUpdateTimestampMillis = mostRecentAppUpdatedTimestampMillis;
+        } catch (AppSearchException e) {
+            // Reset the last update time stamp and app update timestamp so we can try again later.
+            settings.reset();
+            appsUpdateStats.mUpdateStatusCodes.clear();
+            appsUpdateStats.mUpdateStatusCodes.add(e.getResultCode());
+            throw e;
+        }
+    }
+
+    /**
+     * Compares the app functions in PackageManager vs those in AppSearch, and updates
+     * functionsToAddOrUpdate and functionIdsToRemove accordingly.
+     *
+     * @param currentAppFunctionsPerApp the mapping of function ids to documents corresponding to
+     *     what is in the apps metadata.
+     * @param appSearchAppFunctionsPerApp the mapping of function ids to documents corresponding to
+     *     what is in AppSearch
+     * @param functionsToAddOrUpdate the List of {@link GenericDocument} that will be sent to a put
+     *     call to AppSearch
+     * @param functionIdsToRemove the set of ids that will be sent to a remove call in AppSearch
+     */
+    private void comparePackageFunctions(
+            @NonNull Map<String, AppFunctionStaticMetadata> currentAppFunctionsPerApp,
+            @NonNull Map<String, AppFunctionStaticMetadata> appSearchAppFunctionsPerApp,
+            @NonNull List<AppFunctionStaticMetadata> functionsToAddOrUpdate,
+            @NonNull Set<String> functionIdsToRemove) {
+        Objects.requireNonNull(currentAppFunctionsPerApp);
+        Objects.requireNonNull(appSearchAppFunctionsPerApp);
+        Objects.requireNonNull(functionsToAddOrUpdate);
+        Objects.requireNonNull(functionIdsToRemove);
+
+        for (Map.Entry<String, AppFunctionStaticMetadata> currentFunctionEntry :
+                currentAppFunctionsPerApp.entrySet()) {
+            String functionId = currentFunctionEntry.getKey();
+            AppFunctionStaticMetadata currentFunction = currentFunctionEntry.getValue();
+            AppFunctionStaticMetadata appSearchFunction =
+                    appSearchAppFunctionsPerApp.get(functionId);
+            // appSearchFunction == null means it's a new function, function inequality means
+            // updated function. Both mean we need to call put with this function.
+            if (appSearchFunction == null
+                    || !areFunctionsEqual(appSearchFunction, currentFunction)) {
+                functionsToAddOrUpdate.add(currentFunction);
+            }
+        }
+
+        for (Map.Entry<String, AppFunctionStaticMetadata> appSearchFunctionEntry :
+                appSearchAppFunctionsPerApp.entrySet()) {
+            if (!currentAppFunctionsPerApp.containsKey(appSearchFunctionEntry.getKey())) {
+                functionIdsToRemove.add(appSearchFunctionEntry.getValue().getId());
+            }
+        }
+    }
+
+    /**
+     * Checks if two AppFunctionMetaData documents are equal. It isn't enough to call equals. We
+     * also need to ignore creation timestamp and parent types. These are set in AppSearch, but
+     * aren't set for the "about to be indexed" docs
+     *
+     * @return true if the documents are equal, false otherwise.
+     */
+    private boolean areFunctionsEqual(
+            @NonNull GenericDocument appSearchFunction, @NonNull GenericDocument currentFunction) {
+        Objects.requireNonNull(appSearchFunction);
+        Objects.requireNonNull(currentFunction);
+        appSearchFunction =
+                new GenericDocument.Builder<>(appSearchFunction)
+                        .setCreationTimestampMillis(0)
+                        // GenericDocument#PARENT_TYPES_SYNTHETIC_PROPERTY is hidden
+                        .clearProperty("$$__AppSearch__parentTypes")
+                        .build();
+        currentFunction =
+                new GenericDocument.Builder<>(currentFunction)
+                        .setCreationTimestampMillis(0)
+                        .build();
+        return appSearchFunction.equals(currentFunction);
+    }
+
     /**
      * Checks PackageManager and AppSearch to sync the Apps Index in AppSearch.
      *
@@ -191,7 +478,14 @@ public final class AppsIndexerImpl implements Closeable {
 
                 AppSearchBatchResult<String, Void> result =
                         mAppSearchHelper.indexApps(
-                                mobileApplications, appFunctions, appSearchAppFunctions);
+                                mobileApplications,
+                                appFunctions,
+                                appSearchAppFunctions,
+                                appsUpdateStats);
+                // Here we log all of these functions as "updated". However, some of these may be
+                // added or unchanged.
+                // TODO(b/357551503): Log function counts more accurately
+                appsUpdateStats.mNumberOfFunctionsUpdated = appFunctions.size();
                 if (result.isSuccess()) {
                     appsUpdateStats.mUpdateStatusCodes.add(AppSearchResult.RESULT_OK);
                 } else {
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppsIndexerMaintenanceConfig.java b/service/java/com/android/server/appsearch/appsindexer/AppsIndexerMaintenanceConfig.java
index 6d727a99..30dba852 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppsIndexerMaintenanceConfig.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppsIndexerMaintenanceConfig.java
@@ -17,14 +17,11 @@ package com.android.server.appsearch.appsindexer;
 
 import android.annotation.NonNull;
 
-import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.appsearch.indexer.IndexerLocalService;
 import com.android.server.appsearch.indexer.IndexerMaintenanceConfig;
 
 /** Singleton class containing configuration for the apps indexer maintenance task. */
 public class AppsIndexerMaintenanceConfig implements IndexerMaintenanceConfig {
-    @VisibleForTesting
-    static final int MIN_APPS_INDEXER_JOB_ID = 16964307; // Contacts Indexer Max Job Id + 1
 
     public static final IndexerMaintenanceConfig INSTANCE = new AppsIndexerMaintenanceConfig();
 
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppsIndexerUserInstance.java b/service/java/com/android/server/appsearch/appsindexer/AppsIndexerUserInstance.java
index 4b9b977b..ec109af2 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppsIndexerUserInstance.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppsIndexerUserInstance.java
@@ -27,6 +27,7 @@ import android.os.SystemClock;
 import android.util.Log;
 import android.util.Slog;
 
+import com.android.appsearch.flags.Flags;
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.appsearch.indexer.IndexerMaintenanceService;
 import com.android.server.appsearch.stats.AppSearchStatsLog;
@@ -224,7 +225,13 @@ public final class AppsIndexerUserInstance {
             if (firstRun && mSettings.getLastUpdateTimestampMillis() != 0) {
                 return;
             }
-            mAppsIndexerImpl.doUpdate(mSettings, appsUpdateStats);
+            if (Flags.enableAppsIndexerIncrementalPut()) {
+                mAppsIndexerImpl.doUpdateIncrementalPut(mSettings, appsUpdateStats);
+            } else {
+                // TODO(b/367410454): Remove this method and related code paths once
+                //  enable_apps_indexer_incremental_put flag is rolled out.
+                mAppsIndexerImpl.doUpdate(mSettings, appsUpdateStats);
+            }
             mSettings.persist();
         } catch (IOException e) {
             Log.w(TAG, "Failed to save settings to disk", e);
@@ -320,6 +327,11 @@ public final class AppsIndexerUserInstance {
                 appsUpdateStats.mAppSearchSetSchemaLatencyMillis,
                 appsUpdateStats.mAppSearchPutLatencyMillis,
                 appsUpdateStats.mUpdateStartTimestampMillis,
-                appsUpdateStats.mLastAppUpdateTimestampMillis);
+                appsUpdateStats.mLastAppUpdateTimestampMillis,
+                appsUpdateStats.mNumberOfFunctionsAdded,
+                appsUpdateStats.mApproximateNumberOfFunctionsRemoved,
+                appsUpdateStats.mNumberOfFunctionsUpdated,
+                appsUpdateStats.mApproximateNumberOfFunctionsUnchanged,
+                appsUpdateStats.mAppSearchRemoveLatencyMillis);
     }
 }
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppsUpdateStats.java b/service/java/com/android/server/appsearch/appsindexer/AppsUpdateStats.java
index 661b0a0d..a22371c5 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppsUpdateStats.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppsUpdateStats.java
@@ -26,6 +26,7 @@ import java.lang.annotation.RetentionPolicy;
 import java.util.Set;
 
 public class AppsUpdateStats {
+
     @IntDef(
             value = {
                 UNKNOWN_UPDATE_TYPE,
@@ -60,6 +61,21 @@ public class AppsUpdateStats {
     long mUpdateStartTimestampMillis;
     long mLastAppUpdateTimestampMillis;
 
+    int mNumberOfFunctionsAdded;
+    // For apps that get deleted, we don't check what functions were indexed into AppSearch, and
+    // delete the entire database corresponding to the packages functions. We use a setSchema call
+    // with override set to true, so it's not clear how many functions were deleted from AppSearch
+    // for deleted packages.
+    int mApproximateNumberOfFunctionsRemoved;
+    // As of now, added and unchanged and updated functions are all logged as updated
+    // TODO(b/357551503): Log indexed function counts more accurately
+    int mNumberOfFunctionsUpdated;
+    // For apps that don't get updated, we don't check functions at all. So it's not clear how many
+    // functions have remained unchanged in packages that were unchanged.
+    int mApproximateNumberOfFunctionsUnchanged;
+
+    long mAppSearchRemoveLatencyMillis;
+
     /** Resets the Apps Indexer update stats. */
     public void clear() {
         mUpdateType = UNKNOWN_UPDATE_TYPE;
@@ -78,5 +94,12 @@ public class AppsUpdateStats {
 
         mLastAppUpdateTimestampMillis = 0;
         mUpdateStartTimestampMillis = 0;
+
+        mNumberOfFunctionsAdded = 0;
+        mApproximateNumberOfFunctionsRemoved = 0;
+        mApproximateNumberOfFunctionsUnchanged = 0;
+        mNumberOfFunctionsUpdated = 0;
+
+        mAppSearchRemoveLatencyMillis = 0;
     }
 }
diff --git a/service/java/com/android/server/appsearch/appsindexer/AppsUtil.java b/service/java/com/android/server/appsearch/appsindexer/AppsUtil.java
index 13de3ff7..7fd33742 100644
--- a/service/java/com/android/server/appsearch/appsindexer/AppsUtil.java
+++ b/service/java/com/android/server/appsearch/appsindexer/AppsUtil.java
@@ -35,9 +35,12 @@ import android.net.Uri;
 import android.text.TextUtils;
 import android.util.ArrayMap;
 import android.util.Log;
+
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionStaticMetadata;
+import com.android.server.appsearch.appsindexer.appsearchtypes.AppOpenEvent;
 import com.android.server.appsearch.appsindexer.appsearchtypes.MobileApplication;
+
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.util.ArrayList;
@@ -49,6 +52,10 @@ import java.util.Objects;
 public final class AppsUtil {
     public static final String TAG = "AppSearchAppsUtil";
 
+    // App Open events are user's activity, which is both privacy and recency sensitive. 14 days was
+    // chosen as a reasonable duration to maintain this type of user activity.
+    private static final long APP_OPEN_EVENT_TTL_MILLIS = 1000 * 60 * 60 * 24 * 14; // 14 days
+
     private AppsUtil() {}
 
     /** Gets the resource Uri given a resource id. */
@@ -213,6 +220,8 @@ public final class AppsUtil {
         return mobileApplications;
     }
 
+    // TODO(b/367410454): Remove this method once enable_apps_indexer_incremental_put flag is
+    //  rolled out
     /**
      * Uses {@link PackageManager} and a Map of {@link PackageInfo}s to {@link ResolveInfos}s to
      * build AppSearch {@link AppFunctionStaticMetadata} documents. Info from both are required to
@@ -234,6 +243,8 @@ public final class AppsUtil {
         return buildAppFunctionStaticMetadata(packageManager, packageInfos, parser);
     }
 
+    // TODO(b/367410454): Remove this method once enable_apps_indexer_incremental_put flag is
+    //  rolled out
     /**
      * Similar to the above {@link #buildAppFunctionStaticMetadata}, but allows the caller to
      * provide a custom parser. This is for testing purposes.
@@ -277,18 +288,90 @@ public final class AppsUtil {
     }
 
     /**
-     * Gets a map of package name to a list of app open timestamps within a specific time range.
+     * Uses {@link PackageManager} and a Map of {@link PackageInfo}s to {@link ResolveInfos}s to
+     * build AppSearch {@link AppFunctionStaticMetadata} documents. Info from both are required to
+     * build app documents.
+     *
+     * <p>App documents will be returned as a mapping of packages to a mapping of function ids to
+     * AppFunctionStaticMetadata documents. This is useful for determining what has changed during
+     * an update.
+     *
+     * @param packageInfos a mapping of {@link PackageInfo}s and their corresponding {@link
+     *     ResolveInfo} for the packages launch activity.
+     * @param indexerPackageName the name of the package performing the indexing. This should be the
+     *     same as the package running the apps indexer so that qualified ids are correctly created.
+     * @param maxAppFunctions the max number of app functions to be indexed per package.
+     * @return A mapping of packages to a mapping of function ids to AppFunctionStaticMetadata
+     *     documents
+     */
+    public static Map<String, Map<String, AppFunctionStaticMetadata>>
+            buildAppFunctionStaticMetadataIntoMap(
+                    @NonNull PackageManager packageManager,
+                    @NonNull Map<PackageInfo, ResolveInfos> packageInfos,
+                    @NonNull String indexerPackageName,
+                    int maxAppFunctions) {
+        AppFunctionStaticMetadataParser parser =
+                new AppFunctionStaticMetadataParserImpl(indexerPackageName, maxAppFunctions);
+        return buildAppFunctionStaticMetadataIntoMap(packageManager, packageInfos, parser);
+    }
+
+    /**
+     * Similar to the above {@link #buildAppFunctionStaticMetadata}, but allows the caller to
+     * provide a custom parser. This is for testing purposes.
+     */
+    @VisibleForTesting
+    static Map<String, Map<String, AppFunctionStaticMetadata>>
+            buildAppFunctionStaticMetadataIntoMap(
+                    @NonNull PackageManager packageManager,
+                    @NonNull Map<PackageInfo, ResolveInfos> packageInfos,
+                    @NonNull AppFunctionStaticMetadataParser parser) {
+        Objects.requireNonNull(packageManager);
+        Objects.requireNonNull(packageInfos);
+        Objects.requireNonNull(parser);
+        Map<String, Map<String, AppFunctionStaticMetadata>> appFunctions = new ArrayMap<>();
+        for (Map.Entry<PackageInfo, ResolveInfos> entry : packageInfos.entrySet()) {
+            PackageInfo packageInfo = entry.getKey();
+            ResolveInfo resolveInfo = entry.getValue().getAppFunctionServiceInfo();
+            if (resolveInfo == null) {
+                continue;
+            }
+
+            String assetFilePath;
+            try {
+                PackageManager.Property property =
+                        packageManager.getProperty(
+                                "android.app.appfunctions",
+                                new ComponentName(
+                                        resolveInfo.serviceInfo.packageName,
+                                        resolveInfo.serviceInfo.name));
+                assetFilePath = property.getString();
+            } catch (PackageManager.NameNotFoundException e) {
+                Log.w(TAG, "buildAppFunctionMetadataFromPackageInfo: Failed to get property", e);
+                continue;
+            }
+            if (assetFilePath != null) {
+                appFunctions.put(
+                        packageInfo.packageName,
+                        parser.parseIntoMap(
+                                packageManager, packageInfo.packageName, assetFilePath));
+            }
+        }
+        return appFunctions;
+    }
+
+    /**
+     * Gets a list of app open events (package name and timestamp) within a specific time range.
      *
      * @param usageStatsManager the {@link UsageStatsManager} to query for app open events.
      * @param startTime the start time in milliseconds since the epoch.
      * @param endTime the end time in milliseconds since the epoch.
-     * @return a map of package name to a list of app open timestamps.
+     * @return a list of {@link AppOpenEvent} representing the app open events.
      */
     @NonNull
-    public static Map<String, List<Long>> getAppOpenTimestamps(
+    public static List<AppOpenEvent> getAppOpenEvents(
             @NonNull UsageStatsManager usageStatsManager, long startTime, long endTime) {
 
-        Map<String, List<Long>> appOpenTimestamps = new ArrayMap<>();
+        List<AppOpenEvent> appOpenEvents = new ArrayList<>();
 
         UsageEvents usageEvents = usageStatsManager.queryEvents(startTime, endTime);
         while (usageEvents.hasNextEvent()) {
@@ -298,17 +381,14 @@ public final class AppsUtil {
             if (event.getEventType() == UsageEvents.Event.MOVE_TO_FOREGROUND
                     || event.getEventType() == UsageEvents.Event.ACTIVITY_RESUMED) {
                 String packageName = event.getPackageName();
+                long timestamp = event.getTimeStamp();
 
-                List<Long> timestamps = appOpenTimestamps.get(packageName);
-                if (timestamps == null) {
-                    timestamps = new ArrayList<>();
-                    appOpenTimestamps.put(packageName, timestamps);
-                }
-                timestamps.add(event.getTimeStamp());
+                AppOpenEvent appOpenEvent = AppOpenEvent.create(packageName, timestamp);
+                appOpenEvents.add(appOpenEvent);
             }
         }
 
-        return appOpenTimestamps;
+        return appOpenEvents;
     }
 
     /** Gets the SHA-256 certificate from a {@link PackageManager}, or null if it is not found */
diff --git a/service/java/com/android/server/appsearch/appsindexer/FrameworkAppOpenEventIndexerConfig.java b/service/java/com/android/server/appsearch/appsindexer/FrameworkAppOpenEventIndexerConfig.java
new file mode 100644
index 00000000..c0eb19e5
--- /dev/null
+++ b/service/java/com/android/server/appsearch/appsindexer/FrameworkAppOpenEventIndexerConfig.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.appsindexer;
+
+import android.provider.DeviceConfig;
+
+/**
+ * Implementation of {@link AppOpenEventIndexerConfig} using {@link DeviceConfig}.
+ *
+ * <p>It contains all the keys for flags related to App Open Event Indexer.
+ *
+ * <p>This class is thread-safe.
+ *
+ * @hide
+ */
+public class FrameworkAppOpenEventIndexerConfig implements AppOpenEventIndexerConfig {
+    static final String KEY_APP_OPEN_EVENT_INDEXER_ENABLED = "app_open_event_indexer_enabled";
+    static final String KEY_APP_OPEN_EVENT_UPDATE_INTERVAL_MILLIS =
+            "app_open_event_update_interval_millis";
+
+    @Override
+    public boolean isAppOpenEventIndexerEnabled() {
+        return DeviceConfig.getBoolean(
+                DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_APP_OPEN_EVENT_INDEXER_ENABLED,
+                DEFAULT_APP_OPEN_EVENT_INDEXER_ENABLED);
+    }
+
+    @Override
+    public long getAppOpenEventMaintenanceUpdateIntervalMillis() {
+        return DeviceConfig.getLong(
+                DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_APP_OPEN_EVENT_UPDATE_INTERVAL_MILLIS,
+                DEFAULT_APP_OPEN_EVENT_INDEXER_UPDATE_INTERVAL_MILLIS);
+    }
+}
diff --git a/service/java/com/android/server/appsearch/appsindexer/FrameworkAppsIndexerConfig.java b/service/java/com/android/server/appsearch/appsindexer/FrameworkAppsIndexerConfig.java
index d3c60c15..2a67a353 100644
--- a/service/java/com/android/server/appsearch/appsindexer/FrameworkAppsIndexerConfig.java
+++ b/service/java/com/android/server/appsearch/appsindexer/FrameworkAppsIndexerConfig.java
@@ -31,6 +31,8 @@ public class FrameworkAppsIndexerConfig implements AppsIndexerConfig {
     static final String KEY_APPS_INDEXER_ENABLED = "apps_indexer_enabled";
     static final String KEY_APPS_UPDATE_INTERVAL_MILLIS = "apps_update_interval_millis";
     static final String KEY_MAX_APP_FUNCTIONS_PER_PACKAGE = "max_app_functions_per_package";
+    static final String KEY_MAX_ALLOWED_APP_FUNCTION_SCHEMAS_PER_PACKAGE =
+            "max_allowed_app_function_schemas_per_package";
 
     @Override
     public boolean isAppsIndexerEnabled() {
@@ -55,5 +57,13 @@ public class FrameworkAppsIndexerConfig implements AppsIndexerConfig {
                 KEY_MAX_APP_FUNCTIONS_PER_PACKAGE,
                 DEFAULT_MAX_APP_FUNCTIONS_PER_PACKAGE);
     }
+
+    @Override
+    public int getMaxAllowedAppFunctionSchemasPerPackage() {
+        return DeviceConfig.getInt(
+                DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_MAX_ALLOWED_APP_FUNCTION_SCHEMAS_PER_PACKAGE,
+                DEFAULT_MAX_ALLOWED_APP_FUNCTION_SCHEMAS_PER_PACKAGE);
+    }
 }
 
diff --git a/service/java/com/android/server/appsearch/appsindexer/SyncSearchResults.java b/service/java/com/android/server/appsearch/appsindexer/SyncSearchResults.java
index dc74ca60..c2e56b75 100644
--- a/service/java/com/android/server/appsearch/appsindexer/SyncSearchResults.java
+++ b/service/java/com/android/server/appsearch/appsindexer/SyncSearchResults.java
@@ -21,6 +21,7 @@ import android.app.appsearch.SearchResult;
 import android.app.appsearch.SearchResults;
 import android.app.appsearch.exceptions.AppSearchException;
 
+import java.io.Closeable;
 import java.util.List;
 
 /**
@@ -29,7 +30,7 @@ import java.util.List;
  *
  * @see SearchResults
  */
-public interface SyncSearchResults {
+public interface SyncSearchResults extends Closeable {
     /**
      * Synchronously returns a list of {@link SearchResult}s.
      *
diff --git a/service/java/com/android/server/appsearch/appsindexer/SyncSearchResultsImpl.java b/service/java/com/android/server/appsearch/appsindexer/SyncSearchResultsImpl.java
index 84242ec2..30ccc657 100644
--- a/service/java/com/android/server/appsearch/appsindexer/SyncSearchResultsImpl.java
+++ b/service/java/com/android/server/appsearch/appsindexer/SyncSearchResultsImpl.java
@@ -21,6 +21,7 @@ import android.app.appsearch.SearchResult;
 import android.app.appsearch.SearchResults;
 import android.app.appsearch.exceptions.AppSearchException;
 
+import java.io.IOException;
 import java.util.List;
 import java.util.Objects;
 import java.util.concurrent.Executor;
@@ -40,4 +41,9 @@ public class SyncSearchResultsImpl extends SyncAppSearchBase implements SyncSear
         return executeAppSearchResultOperation(
                 resultHandler -> mSearchResults.getNextPage(mExecutor, resultHandler));
     }
+
+    @Override
+    public void close() throws IOException {
+        mSearchResults.close();
+    }
 }
diff --git a/service/java/com/android/server/appsearch/appsindexer/appsearchtypes/AppFunctionStaticMetadata.java b/service/java/com/android/server/appsearch/appsindexer/appsearchtypes/AppFunctionStaticMetadata.java
index 128a055f..9a7aa095 100644
--- a/service/java/com/android/server/appsearch/appsindexer/appsearchtypes/AppFunctionStaticMetadata.java
+++ b/service/java/com/android/server/appsearch/appsindexer/appsearchtypes/AppFunctionStaticMetadata.java
@@ -57,9 +57,17 @@ public class AppFunctionStaticMetadata extends GenericDocument {
     public static final AppSearchSchema PARENT_TYPE_APPSEARCH_SCHEMA =
             createAppFunctionSchemaForPackage(/* packageName= */ null);
 
-    /** Returns a per-app schema name, to store all functions for that package. */
-    public static String getSchemaNameForPackage(@NonNull String pkg) {
-        return SCHEMA_TYPE + "-" + Objects.requireNonNull(pkg);
+    /**
+     * Returns a per-app schema name.
+     *
+     * @param pkg the package name of the app that owns the schema.
+     * @param schemaType the type of the schema. If null, {@link #SCHEMA_TYPE} will be used.
+     * @return the schema name by concatenating the type and the package name.
+     */
+    public static String getSchemaNameForPackage(@NonNull String pkg, @Nullable String schemaType) {
+        return ((schemaType == null) ? SCHEMA_TYPE : schemaType)
+                + "-"
+                + Objects.requireNonNull(pkg);
     }
 
     /**
@@ -73,7 +81,9 @@ public class AppFunctionStaticMetadata extends GenericDocument {
     public static AppSearchSchema createAppFunctionSchemaForPackage(@Nullable String packageName) {
         AppSearchSchema.Builder builder =
                 new AppSearchSchema.Builder(
-                        (packageName == null) ? SCHEMA_TYPE : getSchemaNameForPackage(packageName));
+                        (packageName == null)
+                                ? SCHEMA_TYPE
+                                : getSchemaNameForPackage(packageName, /* schemaType= */ null));
         if (shouldSetParentType() && packageName != null) {
             // This is a child schema, setting the parent type.
             builder.addParentType(SCHEMA_TYPE);
@@ -253,7 +263,7 @@ public class AppFunctionStaticMetadata extends GenericDocument {
             super(
                     APP_FUNCTION_NAMESPACE,
                     Objects.requireNonNull(packageName) + "/" + Objects.requireNonNull(functionId),
-                    getSchemaNameForPackage(packageName));
+                    getSchemaNameForPackage(packageName, /* schemaType= */ null));
             setPropertyString(PROPERTY_FUNCTION_ID, functionId);
             setPropertyString(PROPERTY_PACKAGE_NAME, packageName);
 
diff --git a/service/java/com/android/server/appsearch/appsindexer/appsearchtypes/AppOpenEvent.java b/service/java/com/android/server/appsearch/appsindexer/appsearchtypes/AppOpenEvent.java
index 3c0b4117..471d5163 100644
--- a/service/java/com/android/server/appsearch/appsindexer/appsearchtypes/AppOpenEvent.java
+++ b/service/java/com/android/server/appsearch/appsindexer/appsearchtypes/AppOpenEvent.java
@@ -16,15 +16,14 @@
 
 package com.android.server.appsearch.appsindexer.appsearchtypes;
 
-import android.app.appsearch.annotation.CanIgnoreReturnValue;
 import android.annotation.CurrentTimeMillisLong;
 import android.annotation.NonNull;
-import android.annotation.Nullable;
 import android.app.appsearch.AppSearchSchema;
 import android.app.appsearch.GenericDocument;
-import android.net.Uri;
+import android.app.appsearch.util.DocumentIdUtil;
 
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.server.appsearch.appsindexer.AppSearchHelper;
 
 import java.util.Objects;
 
@@ -36,14 +35,15 @@ import java.util.Objects;
  */
 public class AppOpenEvent extends GenericDocument {
     // Properties
-    private static final String SCHEMA_TYPE = "builtin:AppOpenEvent";
+    public static final String SCHEMA_TYPE = "builtin:AppOpenEvent";
 
-    private static final String APP_OPEN_EVENT_NAMESPACE = "app-open-event";
+    public static final String ANDROID_PACKAGE_NAME = "android";
+    public static final String APP_OPEN_EVENT_NAMESPACE = "app-open-event";
 
-    private static final String APP_OPEN_EVENT_PROPERTY_PACKAGE_NAME = "packageName";
-    private static final String APP_OPEN_EVENT_PROPERTY_MOBILE_APPLICATION_QUALIFIED_ID =
+    public static final String APP_OPEN_EVENT_PROPERTY_PACKAGE_NAME = "packageName";
+    public static final String APP_OPEN_EVENT_PROPERTY_MOBILE_APPLICATION_QUALIFIED_ID =
             "mobileApplicationQualifiedId"; // Joins to MobileApplication
-    private static final String APP_OPEN_EVENT_PROPERTY_APP_OPEN_TIMESTAMP_MILLIS =
+    public static final String APP_OPEN_EVENT_PROPERTY_APP_OPEN_TIMESTAMP_MILLIS =
             "appOpenTimestampMillis";
 
     // Schema
@@ -81,7 +81,6 @@ public class AppOpenEvent extends GenericDocument {
                     .build();
 
     /** Constructs an {@link AppOpenEvent}. */
-    @VisibleForTesting
     public AppOpenEvent(@NonNull GenericDocument document) {
         super(document);
     }
@@ -111,56 +110,61 @@ public class AppOpenEvent extends GenericDocument {
         return getPropertyLong(APP_OPEN_EVENT_PROPERTY_APP_OPEN_TIMESTAMP_MILLIS);
     }
 
-    /** Builder for {@link AppOpenEvent}. */
-    public static final class Builder extends GenericDocument.Builder<Builder> {
-        public Builder(
-                @NonNull String packageName,
-                @CurrentTimeMillisLong long appOpenEventTimestampMillis) {
-            // Package name + timestamp is unique, since if an app was somehow opened twice at the
-            // same time, it would be considered the same event.
-            super(
-                    APP_OPEN_EVENT_NAMESPACE,
-                    /* id= */ packageName + appOpenEventTimestampMillis,
-                    SCHEMA_TYPE);
-            setPropertyString(APP_OPEN_EVENT_PROPERTY_PACKAGE_NAME, packageName);
-            setPropertyLong(
-                    APP_OPEN_EVENT_PROPERTY_APP_OPEN_TIMESTAMP_MILLIS, appOpenEventTimestampMillis);
-        }
-
-        /** Sets the app open event timestamp. */
-        @NonNull
-        @CanIgnoreReturnValue
-        public Builder setAppOpenEventTimestampMillis(
-                @CurrentTimeMillisLong long appOpenEventTimestampMillis) {
-            setPropertyLong(
-                    APP_OPEN_EVENT_PROPERTY_APP_OPEN_TIMESTAMP_MILLIS, appOpenEventTimestampMillis);
-            return this;
-        }
-
-        /** Sets the mobile application qualified id */
-        @NonNull
-        @CanIgnoreReturnValue
-        public Builder setMobileApplicationQualifiedId(
-                @NonNull String mobileApplicationQualifiedId) {
-            setPropertyString(
-                    APP_OPEN_EVENT_PROPERTY_MOBILE_APPLICATION_QUALIFIED_ID,
-                    Objects.requireNonNull(mobileApplicationQualifiedId));
-            return this;
-        }
-
-        /** Sets the package name. */
-        @NonNull
-        @CanIgnoreReturnValue
-        public Builder setPackageName(@NonNull String packageName) {
-            setPropertyString(
-                    APP_OPEN_EVENT_PROPERTY_PACKAGE_NAME, Objects.requireNonNull(packageName));
-            return this;
-        }
-
-        @NonNull
-        @CanIgnoreReturnValue
-        public AppOpenEvent build() {
-            return new AppOpenEvent(super.build());
-        }
+    /**
+     * Creates a new {@link AppOpenEvent} instance using the provided package name, timestamp, and
+     * context. This version of the method uses the package name and timestamp to generate a unique
+     * identifier for the app open event, and links it to the application using a qualified ID based
+     * on the context's package name.
+     *
+     * @param packageName The package name of the app being opened, e.g., "com.android.settings".
+     * @param appOpenEventTimestampMillis The timestamp when the app open event occurred, in
+     *     milliseconds.
+     * @param contextPackageName The name of the package that is indexing the app open event. ID.
+     * @return A new {@link AppOpenEvent} instance populated with the provided information.
+     */
+    @VisibleForTesting
+    public static AppOpenEvent create(
+            @NonNull String packageName,
+            @CurrentTimeMillisLong long appOpenEventTimestampMillis,
+            @NonNull String contextPackageName) {
+        Objects.requireNonNull(packageName);
+        Objects.requireNonNull(contextPackageName);
+
+        String id = packageName + appOpenEventTimestampMillis;
+        String qualifiedId =
+                DocumentIdUtil.createQualifiedId(
+                        contextPackageName,
+                        AppSearchHelper.APP_DATABASE,
+                        MobileApplication.APPS_NAMESPACE,
+                        packageName);
+
+        GenericDocument document =
+                new GenericDocument.Builder(APP_OPEN_EVENT_NAMESPACE, id, SCHEMA_TYPE)
+                        .setPropertyString(APP_OPEN_EVENT_PROPERTY_PACKAGE_NAME, packageName)
+                        .setPropertyLong(
+                                APP_OPEN_EVENT_PROPERTY_APP_OPEN_TIMESTAMP_MILLIS,
+                                appOpenEventTimestampMillis)
+                        .setPropertyString(
+                                APP_OPEN_EVENT_PROPERTY_MOBILE_APPLICATION_QUALIFIED_ID,
+                                qualifiedId)
+                        .build();
+
+        return new AppOpenEvent(document);
+    }
+
+    /**
+     * Creates a new {@link AppOpenEvent} instance using the provided package name and timestamp,
+     * with a default qualified ID based on the Android package name. This method does not require a
+     * context and uses the android package name for the qualified ID since this should be the
+     * standard usage.
+     *
+     * @param packageName The package name of the app being opened, e.g., "com.android.settings".
+     * @param appOpenEventTimestampMillis The timestamp when the app open event occurred, in
+     *     milliseconds.
+     * @return A new {@link AppOpenEvent} instance populated with the provided information.
+     */
+    public static AppOpenEvent create(
+            @NonNull String packageName, @CurrentTimeMillisLong long appOpenEventTimestampMillis) {
+        return create(packageName, appOpenEventTimestampMillis, ANDROID_PACKAGE_NAME);
     }
 }
diff --git a/service/java/com/android/server/appsearch/appsindexer/package-info.java b/service/java/com/android/server/appsearch/appsindexer/package-info.java
new file mode 100644
index 00000000..a80c504d
--- /dev/null
+++ b/service/java/com/android/server/appsearch/appsindexer/package-info.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.appsindexer;
+
+import android.app.appsearch.AppSearchSession;
+
+/**
+ * The package contains the implementation of the AppsIndexer used to index metadata about apps and
+ * app functions exposed by apps into AppSearch.
+ *
+ * <p>App function documents are indexed into AppSearch via {@link AppsIndexerImpl#doIncrementalUpdate} in a
+ * single {@link AppSearchHelper#APP_DATABASE} database. Within the database, each schema type is
+ * named dynamically to be unique to the app package name to control the schema visibility by the
+ * result of {@link android.content.pm.PackageManager#canPackageQuery}. This was preferred over
+ * defining one database per app because {@link AppSearchSession#setSchema} was a bottleneck for the
+ * inserting schemas into per app database.
+ */
diff --git a/service/java/com/android/server/appsearch/contactsindexer/ContactsIndexerMaintenanceConfig.java b/service/java/com/android/server/appsearch/contactsindexer/ContactsIndexerMaintenanceConfig.java
index 8484ae97..d26c2093 100644
--- a/service/java/com/android/server/appsearch/contactsindexer/ContactsIndexerMaintenanceConfig.java
+++ b/service/java/com/android/server/appsearch/contactsindexer/ContactsIndexerMaintenanceConfig.java
@@ -18,14 +18,11 @@ package com.android.server.appsearch.contactsindexer;
 
 import android.annotation.NonNull;
 
-import com.android.internal.annotations.VisibleForTesting;
 import com.android.server.appsearch.indexer.IndexerLocalService;
 import com.android.server.appsearch.indexer.IndexerMaintenanceConfig;
 
 /** Singleton class containing configuration for the contacts indexer maintenance task. */
 public class ContactsIndexerMaintenanceConfig implements IndexerMaintenanceConfig {
-    @VisibleForTesting
-    static final int MIN_CONTACTS_INDEXER_JOB_ID = 16942831; // corresponds to ag/16942831
 
     public static final IndexerMaintenanceConfig INSTANCE = new ContactsIndexerMaintenanceConfig();
 
diff --git a/service/java/com/android/server/appsearch/external/localstorage/AppSearchConfig.java b/service/java/com/android/server/appsearch/external/localstorage/AppSearchConfig.java
index 737749d8..19a756cd 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/AppSearchConfig.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/AppSearchConfig.java
@@ -28,6 +28,10 @@ public interface AppSearchConfig extends IcingOptionsConfig, LimitConfig {
      */
     boolean shouldStoreParentInfoAsSyntheticProperty();
 
-    /** Whether to include the list of parent types when returning a {@link GenericDocument}. */
+    /**
+     * Whether to include the list of parent types when returning a {@link GenericDocument} or a
+     * {@link android.app.appsearch.SearchResult} when {@link
+     * com.android.appsearch.flags.Flags#FLAG_ENABLE_SEARCH_RESULT_PARENT_TYPES} in on.
+     */
     boolean shouldRetrieveParentInfo();
 }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/AppSearchImpl.java b/service/java/com/android/server/appsearch/external/localstorage/AppSearchImpl.java
index 1d90b0a2..ec113455 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/AppSearchImpl.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/AppSearchImpl.java
@@ -30,6 +30,7 @@ import static com.android.server.appsearch.external.localstorage.util.PrefixUtil
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.WorkerThread;
+import android.app.appsearch.AppSearchBlobHandle;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.AppSearchSchema;
 import android.app.appsearch.GenericDocument;
@@ -50,13 +51,16 @@ import android.app.appsearch.exceptions.AppSearchException;
 import android.app.appsearch.observer.ObserverCallback;
 import android.app.appsearch.observer.ObserverSpec;
 import android.app.appsearch.util.LogUtil;
+import android.os.ParcelFileDescriptor;
 import android.os.SystemClock;
 import android.util.ArrayMap;
 import android.util.ArraySet;
 import android.util.Log;
 
+import com.android.appsearch.flags.Flags;
 import com.android.internal.annotations.GuardedBy;
 import com.android.internal.annotations.VisibleForTesting;
+import com.android.server.appsearch.external.localstorage.converter.BlobHandleToProtoConverter;
 import com.android.server.appsearch.external.localstorage.converter.GenericDocumentToProtoConverter;
 import com.android.server.appsearch.external.localstorage.converter.ResultCodeToProtoConverter;
 import com.android.server.appsearch.external.localstorage.converter.SchemaToProtoConverter;
@@ -78,6 +82,7 @@ import com.android.server.appsearch.external.localstorage.visibilitystore.Visibi
 import com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityUtil;
 
 import com.google.android.icing.IcingSearchEngine;
+import com.google.android.icing.proto.BlobProto;
 import com.google.android.icing.proto.DebugInfoProto;
 import com.google.android.icing.proto.DebugInfoResultProto;
 import com.google.android.icing.proto.DebugInfoVerbosity;
@@ -93,11 +98,13 @@ import com.google.android.icing.proto.GetSchemaResultProto;
 import com.google.android.icing.proto.IcingSearchEngineOptions;
 import com.google.android.icing.proto.InitializeResultProto;
 import com.google.android.icing.proto.LogSeverity;
+import com.google.android.icing.proto.NamespaceBlobStorageInfoProto;
 import com.google.android.icing.proto.NamespaceStorageInfoProto;
 import com.google.android.icing.proto.OptimizeResultProto;
 import com.google.android.icing.proto.PersistToDiskResultProto;
 import com.google.android.icing.proto.PersistType;
 import com.google.android.icing.proto.PropertyConfigProto;
+import com.google.android.icing.proto.PropertyProto;
 import com.google.android.icing.proto.PutResultProto;
 import com.google.android.icing.proto.ReportUsageResultProto;
 import com.google.android.icing.proto.ResetResultProto;
@@ -117,6 +124,7 @@ import com.google.android.icing.proto.UsageReport;
 
 import java.io.Closeable;
 import java.io.File;
+import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -192,15 +200,12 @@ public final class AppSearchImpl implements Closeable {
     @GuardedBy("mReadWriteLock")
     private final SchemaCache mSchemaCacheLocked = new SchemaCache();
 
-    // This map contains namespaces for all package-database prefixes. All values in the map are
-    // prefixed with the package-database prefix.
-    // TODO(b/172360376): Check if this can be replaced with an ArrayMap
     @GuardedBy("mReadWriteLock")
-    private final Map<String, Set<String>> mNamespaceMapLocked = new HashMap<>();
+    private final NamespaceCache mNamespaceCacheLocked = new NamespaceCache();
 
-    /** Maps package name to active document count. */
+    // Marked as volatile because a new instance may be assigned during resetLocked.
     @GuardedBy("mReadWriteLock")
-    private final Map<String, Integer> mDocumentCountMapLocked = new ArrayMap<>();
+    private volatile DocumentLimiter mDocumentLimiterLocked;
 
     // Maps packages to the set of valid nextPageTokens that the package can manipulate. A token
     // is unique and constant per query (i.e. the same token '123' is used to iterate through
@@ -228,7 +233,12 @@ public final class AppSearchImpl implements Closeable {
     @Nullable
     @VisibleForTesting
     @GuardedBy("mReadWriteLock")
-    final VisibilityStore mVisibilityStoreLocked;
+    final VisibilityStore mDocumentVisibilityStoreLocked;
+
+    @Nullable
+    @VisibleForTesting
+    @GuardedBy("mReadWriteLock")
+    final VisibilityStore mBlobVisibilityStoreLocked;
 
     @Nullable
     @GuardedBy("mReadWriteLock")
@@ -241,6 +251,8 @@ public final class AppSearchImpl implements Closeable {
     @GuardedBy("mReadWriteLock")
     private int mOptimizeIntervalCountLocked = 0;
 
+    @Nullable private final RevocableFileDescriptorStore mRevocableFileDescriptorStore;
+
     /** Whether this instance has been closed, and therefore unusable. */
     @GuardedBy("mReadWriteLock")
     private boolean mClosedLocked = false;
@@ -267,10 +279,16 @@ public final class AppSearchImpl implements Closeable {
             @NonNull AppSearchConfig config,
             @Nullable InitializeStats.Builder initStatsBuilder,
             @Nullable VisibilityChecker visibilityChecker,
+            @Nullable RevocableFileDescriptorStore revocableFileDescriptorStore,
             @NonNull OptimizeStrategy optimizeStrategy)
             throws AppSearchException {
         return new AppSearchImpl(
-                icingDir, config, initStatsBuilder, optimizeStrategy, visibilityChecker);
+                icingDir,
+                config,
+                initStatsBuilder,
+                visibilityChecker,
+                revocableFileDescriptorStore,
+                optimizeStrategy);
     }
 
     /**
@@ -280,13 +298,15 @@ public final class AppSearchImpl implements Closeable {
             @NonNull File icingDir,
             @NonNull AppSearchConfig config,
             @Nullable InitializeStats.Builder initStatsBuilder,
-            @NonNull OptimizeStrategy optimizeStrategy,
-            @Nullable VisibilityChecker visibilityChecker)
+            @Nullable VisibilityChecker visibilityChecker,
+            @Nullable RevocableFileDescriptorStore revocableFileDescriptorStore,
+            @NonNull OptimizeStrategy optimizeStrategy)
             throws AppSearchException {
         Objects.requireNonNull(icingDir);
         mConfig = Objects.requireNonNull(config);
         mOptimizeStrategy = Objects.requireNonNull(optimizeStrategy);
         mVisibilityCheckerLocked = visibilityChecker;
+        mRevocableFileDescriptorStore = revocableFileDescriptorStore;
 
         mReadWriteLock.writeLock().lock();
         try {
@@ -313,6 +333,14 @@ public final class AppSearchImpl implements Closeable {
                             .setUseNewQualifiedIdJoinIndex(mConfig.getUseNewQualifiedIdJoinIndex())
                             .setBuildPropertyExistenceMetadataHits(
                                     mConfig.getBuildPropertyExistenceMetadataHits())
+                            .setEnableBlobStore(Flags.enableBlobStore())
+                            .setOrphanBlobTimeToLiveMs(mConfig.getOrphanBlobTimeToLiveMs())
+                            .setEnableEmbeddingIndex(Flags.enableSchemaEmbeddingPropertyConfig())
+                            .setEnableEmbeddingQuantization(
+                                    Flags.enableSchemaEmbeddingQuantization())
+                            .setEnableScorableProperties(Flags.enableScorableProperty())
+                            .setEnableQualifiedIdJoinIndexV3AndDeletePropagateFrom(
+                                    Flags.enableDeletePropagationType())
                             .build();
             LogUtil.piiTrace(TAG, "Constructing IcingSearchEngine, request", options);
             mIcingSearchEngineLocked = new IcingSearchEngine(options);
@@ -383,18 +411,37 @@ public final class AppSearchImpl implements Closeable {
                 }
 
                 // Populate schema parent-to-children map
-                mSchemaCacheLocked.rebuildSchemaParentToChildrenMap();
+                mSchemaCacheLocked.rebuildCache();
 
                 // Populate namespace map
                 List<String> prefixedNamespaceList =
                         getAllNamespacesResultProto.getNamespacesList();
                 for (int i = 0; i < prefixedNamespaceList.size(); i++) {
                     String prefixedNamespace = prefixedNamespaceList.get(i);
-                    addToMap(mNamespaceMapLocked, getPrefix(prefixedNamespace), prefixedNamespace);
+                    mNamespaceCacheLocked.addToDocumentNamespaceMap(
+                            getPrefix(prefixedNamespace), prefixedNamespace);
+                }
+
+                // Populate blob namespace map
+                if (mRevocableFileDescriptorStore != null) {
+                    List<NamespaceBlobStorageInfoProto> namespaceBlobStorageInfoProto =
+                            storageInfoProto.getNamespaceBlobStorageInfoList();
+                    for (int i = 0; i < namespaceBlobStorageInfoProto.size(); i++) {
+                        String prefixedNamespace =
+                                namespaceBlobStorageInfoProto.get(i).getNamespace();
+                        mNamespaceCacheLocked.addToBlobNamespaceMap(
+                                getPrefix(prefixedNamespace), prefixedNamespace);
+                    }
                 }
 
                 // Populate document count map
-                rebuildDocumentCountMapLocked(storageInfoProto);
+                mDocumentLimiterLocked =
+                        new DocumentLimiter(
+                                mConfig.getDocumentCountLimitStartThreshold(),
+                                mConfig.getPerPackageDocumentCountLimit(),
+                                storageInfoProto
+                                        .getDocumentStorageInfo()
+                                        .getNamespaceStorageInfoList());
 
                 // logging prepare_schema_and_namespaces latency
                 if (initStatsBuilder != null) {
@@ -415,8 +462,16 @@ public final class AppSearchImpl implements Closeable {
                 resetLocked(initStatsBuilder);
             }
 
+            // AppSearchImpl core parameters are initialized and we should be able to build
+            // VisibilityStores based on that. We shouldn't wipe out everything if we only failed to
+            // build VisibilityStores.
             long prepareVisibilityStoreLatencyStartMillis = SystemClock.elapsedRealtime();
-            mVisibilityStoreLocked = new VisibilityStore(this);
+            mDocumentVisibilityStoreLocked = VisibilityStore.createDocumentVisibilityStore(this);
+            if (mRevocableFileDescriptorStore != null) {
+                mBlobVisibilityStoreLocked = VisibilityStore.createBlobVisibilityStore(this);
+            } else {
+                mBlobVisibilityStoreLocked = null;
+            }
             long prepareVisibilityStoreLatencyEndMillis = SystemClock.elapsedRealtime();
             if (initStatsBuilder != null) {
                 initStatsBuilder.setPrepareVisibilityStoreLatencyMillis(
@@ -453,8 +508,11 @@ public final class AppSearchImpl implements Closeable {
             LogUtil.piiTrace(TAG, "icingSearchEngine.close, request");
             mIcingSearchEngineLocked.close();
             LogUtil.piiTrace(TAG, "icingSearchEngine.close, response");
+            if (mRevocableFileDescriptorStore != null) {
+                mRevocableFileDescriptorStore.revokeAll();
+            }
             mClosedLocked = true;
-        } catch (AppSearchException e) {
+        } catch (AppSearchException | IOException e) {
             Log.w(TAG, "Error when closing AppSearchImpl.", e);
         } finally {
             mReadWriteLock.writeLock().unlock();
@@ -584,7 +642,7 @@ public final class AppSearchImpl implements Closeable {
                             packageName,
                             databaseName,
                             oldSchemaName,
-                            mVisibilityStoreLocked,
+                            mDocumentVisibilityStoreLocked,
                             mVisibilityCheckerLocked));
         }
         int getOldSchemaObserverLatencyMillis =
@@ -623,7 +681,7 @@ public final class AppSearchImpl implements Closeable {
                             packageName,
                             databaseName,
                             newSchemaName,
-                            mVisibilityStoreLocked,
+                            mDocumentVisibilityStoreLocked,
                             mVisibilityCheckerLocked));
         }
         long getNewSchemaObserverEndTimeMillis = SystemClock.elapsedRealtime();
@@ -810,42 +868,25 @@ public final class AppSearchImpl implements Closeable {
             mSchemaCacheLocked.removeFromSchemaMap(prefix, schemaType);
         }
 
-        mSchemaCacheLocked.rebuildSchemaParentToChildrenMapForPrefix(prefix);
+        mSchemaCacheLocked.rebuildCacheForPrefix(prefix);
 
         // Since the constructor of VisibilityStore will set schema. Avoid call visibility
         // store before we have already created it.
-        if (mVisibilityStoreLocked != null) {
+        if (mDocumentVisibilityStoreLocked != null) {
             // Add prefix to all visibility documents.
             // Find out which Visibility document is deleted or changed to all-default settings.
             // We need to remove them from Visibility Store.
             Set<String> deprecatedVisibilityDocuments =
                     new ArraySet<>(rewrittenSchemaResults.mRewrittenPrefixedTypes.keySet());
             List<InternalVisibilityConfig> prefixedVisibilityConfigs =
-                    new ArrayList<>(visibilityConfigs.size());
-            for (int i = 0; i < visibilityConfigs.size(); i++) {
-                InternalVisibilityConfig visibilityConfig = visibilityConfigs.get(i);
-                // The VisibilityConfig is controlled by the client and it's untrusted but we
-                // make it safe by appending a prefix.
-                // We must control the package-database prefix. Therefore even if the client
-                // fake the id, they can only mess their own app. That's totally allowed and
-                // they can do this via the public API too.
-                // TODO(b/275592563): Move prefixing into VisibilityConfig.createVisibilityDocument
-                //  and createVisibilityOverlay
-                String schemaType = visibilityConfig.getSchemaType();
-                String prefixedSchemaType = prefix + schemaType;
-                prefixedVisibilityConfigs.add(
-                        new InternalVisibilityConfig.Builder(visibilityConfig)
-                                .setSchemaType(prefixedSchemaType)
-                                .build());
-                // This schema has visibility settings. We should keep it from the removal list.
-                deprecatedVisibilityDocuments.remove(visibilityConfig.getSchemaType());
-            }
+                    rewriteVisibilityConfigs(
+                            prefix, visibilityConfigs, deprecatedVisibilityDocuments);
             // Now deprecatedVisibilityDocuments contains those existing schemas that has
             // all-default visibility settings, add deleted schemas. That's all we need to
             // remove.
             deprecatedVisibilityDocuments.addAll(rewrittenSchemaResults.mDeletedPrefixedTypes);
-            mVisibilityStoreLocked.removeVisibility(deprecatedVisibilityDocuments);
-            mVisibilityStoreLocked.setVisibility(prefixedVisibilityConfigs);
+            mDocumentVisibilityStoreLocked.removeVisibility(deprecatedVisibilityDocuments);
+            mDocumentVisibilityStoreLocked.setVisibility(prefixedVisibilityConfigs);
         }
         long saveVisibilitySettingEndTimeMillis = SystemClock.elapsedRealtime();
         if (setSchemaStatsBuilder != null) {
@@ -905,7 +946,7 @@ public final class AppSearchImpl implements Closeable {
                         callerAccess,
                         packageName,
                         prefixedSchemaType,
-                        mVisibilityStoreLocked,
+                        mDocumentVisibilityStoreLocked,
                         mVisibilityCheckerLocked)) {
                     // Caller doesn't have access to this type.
                     continue;
@@ -922,10 +963,10 @@ public final class AppSearchImpl implements Closeable {
 
                 // Populate visibility info. Since the constructor of VisibilityStore will get
                 // schema. Avoid call visibility store before we have already created it.
-                if (mVisibilityStoreLocked != null) {
+                if (mDocumentVisibilityStoreLocked != null) {
                     String typeName = typeConfig.getSchemaType().substring(typePrefix.length());
                     InternalVisibilityConfig visibilityConfig =
-                            mVisibilityStoreLocked.getVisibility(prefixedSchemaType);
+                            mDocumentVisibilityStoreLocked.getVisibility(prefixedSchemaType);
                     if (visibilityConfig != null) {
                         if (visibilityConfig.isNotDisplayedBySystem()) {
                             responseBuilder.addSchemaTypeNotDisplayedBySystem(typeName);
@@ -1058,9 +1099,8 @@ public final class AppSearchImpl implements Closeable {
             DocumentProto finalDocument = documentBuilder.build();
 
             // Check limits
-            int newDocumentCount =
-                    enforceLimitConfigLocked(
-                            packageName, finalDocument.getUri(), finalDocument.getSerializedSize());
+            enforceLimitConfigLocked(
+                    packageName, finalDocument.getUri(), finalDocument.getSerializedSize());
 
             // Insert document
             LogUtil.piiTrace(TAG, "putDocument, request", finalDocument.getUri(), finalDocument);
@@ -1087,8 +1127,23 @@ public final class AppSearchImpl implements Closeable {
             checkSuccess(putResultProto.getStatus());
 
             // Only update caches if the document is successfully put to Icing.
-            addToMap(mNamespaceMapLocked, prefix, finalDocument.getNamespace());
-            mDocumentCountMapLocked.put(packageName, newDocumentCount);
+
+            mNamespaceCacheLocked.addToDocumentNamespaceMap(prefix, finalDocument.getNamespace());
+            if (!Flags.enableDocumentLimiterReplaceTracking()
+                    || !putResultProto.getWasReplacement()) {
+                // If the document was a replacement, then there is no need to report it because the
+                // number of documents has not changed. We only need to report "true" additions to
+                // the DocumentLimiter.
+                // Although a replacement document will consume a document id, the limit is only
+                // intended to apply to "living" documents. It is the responsibility of AppSearch's
+                // optimization task to reclaim space when needed.
+                mDocumentLimiterLocked.reportDocumentAdded(
+                        packageName,
+                        () ->
+                                getRawStorageInfoProto()
+                                        .getDocumentStorageInfo()
+                                        .getNamespaceStorageInfoList());
+            }
 
             // Prepare notifications
             if (sendChangeNotifications) {
@@ -1098,7 +1153,7 @@ public final class AppSearchImpl implements Closeable {
                         document.getNamespace(),
                         document.getSchemaType(),
                         document.getId(),
-                        mVisibilityStoreLocked,
+                        mDocumentVisibilityStoreLocked,
                         mVisibilityCheckerLocked);
             }
         } finally {
@@ -1113,16 +1168,270 @@ public final class AppSearchImpl implements Closeable {
         }
     }
 
+    /**
+     * Gets the {@link ParcelFileDescriptor} for write purpose of the given {@link
+     * AppSearchBlobHandle}.
+     *
+     * @param packageName The package name that owns this blob.
+     * @param databaseName The databaseName this blob resides in.
+     * @param handle The {@link AppSearchBlobHandle} represent the blob.
+     */
+    @NonNull
+    public ParcelFileDescriptor openWriteBlob(
+            @NonNull String packageName,
+            @NonNull String databaseName,
+            @NonNull AppSearchBlobHandle handle)
+            throws AppSearchException, IOException {
+        if (mRevocableFileDescriptorStore == null) {
+            throw new UnsupportedOperationException(
+                    "BLOB_STORAGE is not available on this AppSearch implementation.");
+        }
+        mReadWriteLock.writeLock().lock();
+        try {
+            throwIfClosedLocked();
+            verifyCallingBlobHandle(packageName, databaseName, handle);
+            mRevocableFileDescriptorStore.checkBlobStoreLimit(packageName);
+            PropertyProto.BlobHandleProto blobHandleProto =
+                    BlobHandleToProtoConverter.toBlobHandleProto(handle);
+            BlobProto result = mIcingSearchEngineLocked.openWriteBlob(blobHandleProto);
+
+            checkSuccess(result.getStatus());
+            ParcelFileDescriptor pfd = ParcelFileDescriptor.adoptFd(result.getFileDescriptor());
+
+            mNamespaceCacheLocked.addToBlobNamespaceMap(
+                    createPrefix(packageName, databaseName), blobHandleProto.getNamespace());
+
+            return mRevocableFileDescriptorStore.wrapToRevocableFileDescriptor(
+                    handle.getPackageName(), pfd);
+        } finally {
+            mReadWriteLock.writeLock().unlock();
+        }
+    }
+
+    /**
+     * Remove and delete the blob file of given {@link AppSearchBlobHandle} from AppSearch storage.
+     *
+     * <p>This method will delete pending blob or committed blobs. Remove blobs that have reference
+     * documents linked to it will make those reference document has nothing to read.
+     *
+     * @param packageName The package name that owns this blob.
+     * @param databaseName The databaseName this blob resides in.
+     * @param handle The {@link AppSearchBlobHandle} represent the blob.
+     */
+    public void removeBlob(
+            @NonNull String packageName,
+            @NonNull String databaseName,
+            @NonNull AppSearchBlobHandle handle)
+            throws AppSearchException, IOException {
+        if (mRevocableFileDescriptorStore == null) {
+            throw new UnsupportedOperationException(
+                    "BLOB_STORAGE is not available on this AppSearch implementation.");
+        }
+        mReadWriteLock.writeLock().lock();
+        try {
+            throwIfClosedLocked();
+            verifyCallingBlobHandle(packageName, databaseName, handle);
+
+            BlobProto result =
+                    mIcingSearchEngineLocked.removeBlob(
+                            BlobHandleToProtoConverter.toBlobHandleProto(handle));
+
+            checkSuccess(result.getStatus());
+        } finally {
+            mReadWriteLock.writeLock().unlock();
+        }
+    }
+
+    /**
+     * Commits and seals the blob represented by the given {@link AppSearchBlobHandle}.
+     *
+     * <p>After this call, the blob is readable via {@link #openReadBlob}. And any rewrite is not
+     * allowed.
+     *
+     * @param packageName The package name that owns this blob.
+     * @param databaseName The databaseName this blob resides in.
+     * @param handle The {@link AppSearchBlobHandle} represent the blob.
+     */
+    public void commitBlob(
+            @NonNull String packageName,
+            @NonNull String databaseName,
+            @NonNull AppSearchBlobHandle handle)
+            throws AppSearchException {
+        if (mRevocableFileDescriptorStore == null) {
+            throw new UnsupportedOperationException(
+                    "BLOB_STORAGE is not available on this AppSearch implementation.");
+        }
+        mReadWriteLock.writeLock().lock();
+        try {
+            throwIfClosedLocked();
+            verifyCallingBlobHandle(packageName, databaseName, handle);
+            BlobProto result =
+                    mIcingSearchEngineLocked.commitBlob(
+                            BlobHandleToProtoConverter.toBlobHandleProto(handle));
+
+            checkSuccess(result.getStatus());
+        } finally {
+            mReadWriteLock.writeLock().unlock();
+        }
+    }
+
+    /**
+     * Gets the {@link ParcelFileDescriptor} for read only purpose of the given {@link
+     * AppSearchBlobHandle}.
+     *
+     * <p>The target must be committed via {@link #commitBlob};
+     *
+     * @param packageName The package name that owns this blob.
+     * @param databaseName The databaseName this blob resides in.
+     * @param handle The {@link AppSearchBlobHandle} represent the blob.
+     */
+    @NonNull
+    public ParcelFileDescriptor openReadBlob(
+            @NonNull String packageName,
+            @NonNull String databaseName,
+            @NonNull AppSearchBlobHandle handle)
+            throws AppSearchException, IOException {
+        if (mRevocableFileDescriptorStore == null) {
+            throw new UnsupportedOperationException(
+                    "BLOB_STORAGE is not available on this AppSearch implementation.");
+        }
+
+        mReadWriteLock.readLock().lock();
+        try {
+            throwIfClosedLocked();
+            verifyCallingBlobHandle(packageName, databaseName, handle);
+            mRevocableFileDescriptorStore.checkBlobStoreLimit(packageName);
+            BlobProto result =
+                    mIcingSearchEngineLocked.openReadBlob(
+                            BlobHandleToProtoConverter.toBlobHandleProto(handle));
+
+            checkSuccess(result.getStatus());
+
+            ParcelFileDescriptor pfd = ParcelFileDescriptor.fromFd(result.getFileDescriptor());
+            return mRevocableFileDescriptorStore.wrapToRevocableFileDescriptor(packageName, pfd);
+        } finally {
+            mReadWriteLock.readLock().unlock();
+        }
+    }
+
+    /**
+     * Gets the {@link ParcelFileDescriptor} for read only purpose of the given {@link
+     * AppSearchBlobHandle}.
+     *
+     * <p>The target must be committed via {@link #commitBlob};
+     *
+     * @param handle The {@link AppSearchBlobHandle} represent the blob.
+     */
+    @NonNull
+    public ParcelFileDescriptor globalOpenReadBlob(
+            @NonNull AppSearchBlobHandle handle, @NonNull CallerAccess access)
+            throws AppSearchException, IOException {
+        if (mRevocableFileDescriptorStore == null) {
+            throw new UnsupportedOperationException(
+                    "BLOB_STORAGE is not available on this AppSearch implementation.");
+        }
+
+        mReadWriteLock.readLock().lock();
+        try {
+            throwIfClosedLocked();
+            mRevocableFileDescriptorStore.checkBlobStoreLimit(access.getCallingPackageName());
+            String prefixedNamespace =
+                    createPrefix(handle.getPackageName(), handle.getDatabaseName())
+                            + handle.getNamespace();
+            PropertyProto.BlobHandleProto blobHandleProto =
+                    BlobHandleToProtoConverter.toBlobHandleProto(handle);
+            // We are using namespace to check blob's visibility.
+            if (!VisibilityUtil.isSchemaSearchableByCaller(
+                    access,
+                    handle.getPackageName(),
+                    prefixedNamespace,
+                    mBlobVisibilityStoreLocked,
+                    mVisibilityCheckerLocked)) {
+                // Caller doesn't have access to this namespace.
+                throw new AppSearchException(
+                        AppSearchResult.RESULT_NOT_FOUND,
+                        "Cannot find the blob for handle: "
+                                + blobHandleProto.getDigest().toStringUtf8());
+            }
+
+            BlobProto result = mIcingSearchEngineLocked.openReadBlob(blobHandleProto);
+
+            checkSuccess(result.getStatus());
+
+            ParcelFileDescriptor pfd = ParcelFileDescriptor.fromFd(result.getFileDescriptor());
+            return mRevocableFileDescriptorStore.wrapToRevocableFileDescriptor(
+                    access.getCallingPackageName(), pfd);
+        } finally {
+            mReadWriteLock.readLock().unlock();
+        }
+    }
+
+    /**
+     * Updates the visibility configuration for a specified namespace within a blob storage.
+     *
+     * <p>This method configures the visibility blob namespaces in the given specific database.
+     *
+     * <p>After applying the new visibility configurations, the method identifies and removes any
+     * existing visibility settings that do not included in the new visibility configurations from
+     * the visibility store.
+     *
+     * @param packageName The package name that owns these blobs.
+     * @param databaseName The databaseName these blobs resides in.
+     * @param visibilityConfigs a list of {@link InternalVisibilityConfig} objects representing the
+     *     visibility configurations to be set for the specified namespace.
+     * @throws AppSearchException if an error occurs while updating the visibility configurations.
+     *     This could happen if the database is closed or in an invalid state.
+     */
+    public void setBlobNamespaceVisibility(
+            @NonNull String packageName,
+            @NonNull String databaseName,
+            @NonNull List<InternalVisibilityConfig> visibilityConfigs)
+            throws AppSearchException {
+        mReadWriteLock.writeLock().lock();
+        try {
+            throwIfClosedLocked();
+            if (mBlobVisibilityStoreLocked != null) {
+                String prefix = PrefixUtil.createPrefix(packageName, databaseName);
+                Set<String> removedVisibilityConfigs =
+                        mNamespaceCacheLocked.getPrefixedBlobNamespaces(prefix);
+                if (removedVisibilityConfigs == null) {
+                    removedVisibilityConfigs = new ArraySet<>();
+                } else {
+                    // wrap it to allow rewriteVisibilityConfigs modify it.
+                    removedVisibilityConfigs = new ArraySet<>(removedVisibilityConfigs);
+                }
+                List<InternalVisibilityConfig> prefixedVisibilityConfigs =
+                        rewriteVisibilityConfigs(
+                                prefix, visibilityConfigs, removedVisibilityConfigs);
+                for (int i = 0; i < prefixedVisibilityConfigs.size(); i++) {
+                    // We are using schema type to represent blob's namespace in
+                    // InternalVisibilityConfig.
+                    mNamespaceCacheLocked.addToBlobNamespaceMap(
+                            prefix, prefixedVisibilityConfigs.get(i).getSchemaType());
+                }
+                // Now removedVisibilityConfigs contains those existing schemas that has
+                // all-default visibility settings, add deleted schemas. That's all we need to
+                // remove.
+                mBlobVisibilityStoreLocked.setVisibility(prefixedVisibilityConfigs);
+                mBlobVisibilityStoreLocked.removeVisibility(removedVisibilityConfigs);
+            } else {
+                throw new UnsupportedOperationException(
+                        "BLOB_STORAGE is not available on this AppSearch implementation.");
+            }
+        } finally {
+            mReadWriteLock.writeLock().unlock();
+        }
+    }
+
     /**
      * Checks that a new document can be added to the given packageName with the given serialized
      * size without violating our {@link LimitConfig}.
      *
-     * @return the new count of documents for the given package, including the new document.
      * @throws AppSearchException with a code of {@link AppSearchResult#RESULT_OUT_OF_SPACE} if the
      *     limits are violated by the new document.
      */
     @GuardedBy("mReadWriteLock")
-    private int enforceLimitConfigLocked(String packageName, String newDocUri, int newDocSize)
+    private void enforceLimitConfigLocked(String packageName, String newDocUri, int newDocSize)
             throws AppSearchException {
         // Limits check: size of document
         if (newDocSize > mConfig.getMaxDocumentSizeBytes()) {
@@ -1140,42 +1449,12 @@ public final class AppSearchImpl implements Closeable {
                             + " bytes");
         }
 
-        // Limits check: number of documents
-        Integer oldDocumentCount = mDocumentCountMapLocked.get(packageName);
-        int newDocumentCount;
-        if (oldDocumentCount == null) {
-            newDocumentCount = 1;
-        } else {
-            newDocumentCount = oldDocumentCount + 1;
-        }
-        if (newDocumentCount > mConfig.getMaxDocumentCount()) {
-            // Our management of mDocumentCountMapLocked doesn't account for document
-            // replacements, so our counter might have overcounted if the app has replaced docs.
-            // Rebuild the counter from StorageInfo in case this is so.
-            // TODO(b/170371356):  If Icing lib exposes something in the result which says
-            //  whether the document was a replacement, we could subtract 1 again after the put
-            //  to keep the count accurate. That would allow us to remove this code.
-            rebuildDocumentCountMapLocked(getRawStorageInfoProto());
-            oldDocumentCount = mDocumentCountMapLocked.get(packageName);
-            if (oldDocumentCount == null) {
-                newDocumentCount = 1;
-            } else {
-                newDocumentCount = oldDocumentCount + 1;
-            }
-        }
-        if (newDocumentCount > mConfig.getMaxDocumentCount()) {
-            // Now we really can't fit it in, even accounting for replacements.
-            throw new AppSearchException(
-                    AppSearchResult.RESULT_OUT_OF_SPACE,
-                    "Package \""
-                            + packageName
-                            + "\" exceeded limit of "
-                            + mConfig.getMaxDocumentCount()
-                            + " documents. Some documents "
-                            + "must be removed to index additional ones.");
-        }
-
-        return newDocumentCount;
+        mDocumentLimiterLocked.enforceDocumentCountLimit(
+                packageName,
+                () ->
+                        getRawStorageInfoProto()
+                                .getDocumentStorageInfo()
+                                .getNamespaceStorageInfoList());
     }
 
     /**
@@ -1221,7 +1500,7 @@ public final class AppSearchImpl implements Closeable {
                         callerAccess,
                         packageName,
                         documentProto.getSchema(),
-                        mVisibilityStoreLocked,
+                        mDocumentVisibilityStoreLocked,
                         mVisibilityCheckerLocked)) {
                     throw new AppSearchException(AppSearchResult.RESULT_NOT_FOUND);
                 }
@@ -1236,10 +1515,8 @@ public final class AppSearchImpl implements Closeable {
             DocumentProto.Builder documentBuilder = documentProto.toBuilder();
             removePrefixesFromDocument(documentBuilder);
             String prefix = createPrefix(packageName, databaseName);
-            Map<String, SchemaTypeConfigProto> schemaTypeMap =
-                    mSchemaCacheLocked.getSchemaMapForPrefix(prefix);
             return GenericDocumentToProtoConverter.toGenericDocument(
-                    documentBuilder.build(), prefix, schemaTypeMap, mConfig);
+                    documentBuilder.build(), prefix, mSchemaCacheLocked, mConfig);
         } finally {
             mReadWriteLock.readLock().unlock();
         }
@@ -1280,10 +1557,8 @@ public final class AppSearchImpl implements Closeable {
             // The schema type map cannot be null at this point. It could only be null if no
             // schema had ever been set for that prefix. Given we have retrieved a document from
             // the index, we know a schema had to have been set.
-            Map<String, SchemaTypeConfigProto> schemaTypeMap =
-                    mSchemaCacheLocked.getSchemaMapForPrefix(prefix);
             return GenericDocumentToProtoConverter.toGenericDocument(
-                    documentBuilder.build(), prefix, schemaTypeMap, mConfig);
+                    documentBuilder.build(), prefix, mSchemaCacheLocked, mConfig);
         } finally {
             mReadWriteLock.readLock().unlock();
         }
@@ -1402,7 +1677,7 @@ public final class AppSearchImpl implements Closeable {
                             queryExpression,
                             searchSpec,
                             Collections.singleton(prefix),
-                            mNamespaceMapLocked,
+                            mNamespaceCacheLocked,
                             mSchemaCacheLocked,
                             mConfig);
             if (searchSpecToProtoConverter.hasNothingToSearch()) {
@@ -1473,8 +1748,8 @@ public final class AppSearchImpl implements Closeable {
             // SearchSpec has package filters and there is no JoinSpec, or if both outer and
             // nested SearchSpecs have package filters. If outer SearchSpec has no package
             // filters or the nested SearchSpec has no package filters, then we pass the key set of
-            // mNamespaceMapLocked to the SearchSpecToProtoConverter, signifying that there is a
-            // SearchSpec that wants to query every visible package.
+            // documentNamespace map of mNamespaceCachedLocked to the SearchSpecToProtoConverter,
+            // signifying that there is a SearchSpec that wants to query every visible package.
             Set<String> packageFilters = new ArraySet<>();
             if (!searchSpec.getFilterPackageNames().isEmpty()) {
                 JoinSpec joinSpec = searchSpec.getJoinSpec();
@@ -1491,11 +1766,11 @@ public final class AppSearchImpl implements Closeable {
             if (packageFilters.isEmpty()) {
                 // Client didn't restrict their search over packages. Try to query over all
                 // packages/prefixes
-                prefixFilters = mNamespaceMapLocked.keySet();
+                prefixFilters = mNamespaceCacheLocked.getAllDocumentPrefixes();
             } else {
                 // Client did restrict their search over packages. Only include the prefixes that
                 // belong to the specified packages.
-                for (String prefix : mNamespaceMapLocked.keySet()) {
+                for (String prefix : mNamespaceCacheLocked.getAllDocumentPrefixes()) {
                     String packageName = getPackageName(prefix);
                     if (packageFilters.contains(packageName)) {
                         prefixFilters.add(prefix);
@@ -1507,12 +1782,12 @@ public final class AppSearchImpl implements Closeable {
                             queryExpression,
                             searchSpec,
                             prefixFilters,
-                            mNamespaceMapLocked,
+                            mNamespaceCacheLocked,
                             mSchemaCacheLocked,
                             mConfig);
             // Remove those inaccessible schemas.
             searchSpecToProtoConverter.removeInaccessibleSchemaFilter(
-                    callerAccess, mVisibilityStoreLocked, mVisibilityCheckerLocked);
+                    callerAccess, mDocumentVisibilityStoreLocked, mVisibilityCheckerLocked);
             if (searchSpecToProtoConverter.hasNothingToSearch()) {
                 // there is nothing to search over given their search filters, so we can return an
                 // empty SearchResult and skip sending request to Icing.
@@ -1549,7 +1824,7 @@ public final class AppSearchImpl implements Closeable {
         SearchSpecProto finalSearchSpec = searchSpecToProtoConverter.toSearchSpecProto();
         ResultSpecProto finalResultSpec =
                 searchSpecToProtoConverter.toResultSpecProto(
-                        mNamespaceMapLocked, mSchemaCacheLocked);
+                        mNamespaceCacheLocked, mSchemaCacheLocked);
         ScoringSpecProto scoringSpec = searchSpecToProtoConverter.toScoringSpecProto();
         if (sStatsBuilder != null) {
             sStatsBuilder.setRewriteSearchSpecLatencyMillis(
@@ -1648,7 +1923,7 @@ public final class AppSearchImpl implements Closeable {
                             suggestionQueryExpression,
                             searchSuggestionSpec,
                             Collections.singleton(prefix),
-                            mNamespaceMapLocked,
+                            mNamespaceCacheLocked,
                             mSchemaCacheLocked);
 
             if (searchSuggestionSpecToProtoConverter.hasNothingToSearch()) {
@@ -1926,7 +2201,8 @@ public final class AppSearchImpl implements Closeable {
             checkSuccess(deleteResultProto.getStatus());
 
             // Update derived maps
-            updateDocumentCountAfterRemovalLocked(packageName, /* numDocumentsDeleted= */ 1);
+            mDocumentLimiterLocked.reportDocumentsRemoved(
+                    packageName, /* numDocumentsDeleted= */ 1);
 
             // Prepare notifications
             if (schemaType != null) {
@@ -1936,7 +2212,7 @@ public final class AppSearchImpl implements Closeable {
                         namespace,
                         schemaType,
                         documentId,
-                        mVisibilityStoreLocked,
+                        mDocumentVisibilityStoreLocked,
                         mVisibilityCheckerLocked);
             }
         } finally {
@@ -1989,7 +2265,7 @@ public final class AppSearchImpl implements Closeable {
             }
 
             String prefix = createPrefix(packageName, databaseName);
-            if (!mNamespaceMapLocked.containsKey(prefix)) {
+            if (!mNamespaceCacheLocked.getAllDocumentPrefixes().contains(prefix)) {
                 // The target database is empty so we can return early and skip sending request to
                 // Icing.
                 return;
@@ -2000,7 +2276,7 @@ public final class AppSearchImpl implements Closeable {
                             queryExpression,
                             searchSpec,
                             Collections.singleton(prefix),
-                            mNamespaceMapLocked,
+                            mNamespaceCacheLocked,
                             mSchemaCacheLocked,
                             mConfig);
             if (searchSpecToProtoConverter.hasNothingToSearch()) {
@@ -2078,7 +2354,7 @@ public final class AppSearchImpl implements Closeable {
         // Update derived maps
         int numDocumentsDeleted =
                 deleteResultProto.getDeleteByQueryStats().getNumDocumentsDeleted();
-        updateDocumentCountAfterRemovalLocked(packageName, numDocumentsDeleted);
+        mDocumentLimiterLocked.reportDocumentsRemoved(packageName, numDocumentsDeleted);
 
         if (prefixedObservedSchemas != null && !prefixedObservedSchemas.isEmpty()) {
             dispatchChangeNotificationsAfterRemoveByQueryLocked(
@@ -2086,22 +2362,6 @@ public final class AppSearchImpl implements Closeable {
         }
     }
 
-    @GuardedBy("mReadWriteLock")
-    private void updateDocumentCountAfterRemovalLocked(
-            @NonNull String packageName, int numDocumentsDeleted) {
-        if (numDocumentsDeleted > 0) {
-            Integer oldDocumentCount = mDocumentCountMapLocked.get(packageName);
-            // This should always be true: how can we delete documents for a package without
-            // having seen that package during init? This is just a safeguard.
-            if (oldDocumentCount != null) {
-                // This should always be >0; how can we remove more documents than we've indexed?
-                // This is just a safeguard.
-                int newDocumentCount = Math.max(oldDocumentCount - numDocumentsDeleted, 0);
-                mDocumentCountMapLocked.put(packageName, newDocumentCount);
-            }
-        }
-    }
-
     @GuardedBy("mReadWriteLock")
     private void dispatchChangeNotificationsAfterRemoveByQueryLocked(
             @NonNull String packageName,
@@ -2125,7 +2385,7 @@ public final class AppSearchImpl implements Closeable {
                         namespace,
                         schemaType,
                         uri,
-                        mVisibilityStoreLocked,
+                        mDocumentVisibilityStoreLocked,
                         mVisibilityCheckerLocked);
             }
         }
@@ -2139,27 +2399,33 @@ public final class AppSearchImpl implements Closeable {
         try {
             throwIfClosedLocked();
 
-            Map<String, Set<String>> packageToDatabases = getPackageToDatabases();
-            Set<String> databases = packageToDatabases.get(packageName);
-            if (databases == null) {
-                // Package doesn't exist, no storage info to report
-                return new StorageInfo.Builder().build();
-            }
-
-            // Accumulate all the namespaces we're interested in.
-            Set<String> wantedPrefixedNamespaces = new ArraySet<>();
-            for (String database : databases) {
-                Set<String> prefixedNamespaces =
-                        mNamespaceMapLocked.get(createPrefix(packageName, database));
-                if (prefixedNamespaces != null) {
-                    wantedPrefixedNamespaces.addAll(prefixedNamespaces);
+            StorageInfo.Builder storageInfoBuilder = new StorageInfo.Builder();
+            if (Flags.enableBlobStore()) {
+                StorageInfoProto storageInfoProto = getRawStorageInfoProto();
+                // read blob storage info and set to storageInfoBuilder
+                getBlobStorageInfoForPrefix(storageInfoProto, packageName, storageInfoBuilder);
+                // read document storage info and set to storageInfoBuilder
+                Set<String> wantedPrefixedDocumentNamespaces =
+                        mNamespaceCacheLocked.getAllPrefixedDocumentNamespaceForPackage(
+                                packageName);
+                if (!wantedPrefixedDocumentNamespaces.isEmpty()) {
+                    getDocumentStorageInfoForNamespaces(
+                            storageInfoProto, wantedPrefixedDocumentNamespaces, storageInfoBuilder);
+                }
+            } else {
+                // blob flag off, only read document storage info and set to storageInfoBuilder if
+                // the database exists.
+                Set<String> wantedPrefixedDocumentNamespaces =
+                        mNamespaceCacheLocked.getAllPrefixedDocumentNamespaceForPackage(
+                                packageName);
+                if (!wantedPrefixedDocumentNamespaces.isEmpty()) {
+                    getDocumentStorageInfoForNamespaces(
+                            getRawStorageInfoProto(),
+                            wantedPrefixedDocumentNamespaces,
+                            storageInfoBuilder);
                 }
             }
-            if (wantedPrefixedNamespaces.isEmpty()) {
-                return new StorageInfo.Builder().build();
-            }
-
-            return getStorageInfoForNamespaces(getRawStorageInfoProto(), wantedPrefixedNamespaces);
+            return storageInfoBuilder.build();
         } finally {
             mReadWriteLock.readLock().unlock();
         }
@@ -2173,24 +2439,45 @@ public final class AppSearchImpl implements Closeable {
         try {
             throwIfClosedLocked();
 
-            Map<String, Set<String>> packageToDatabases = getPackageToDatabases();
-            Set<String> databases = packageToDatabases.get(packageName);
-            if (databases == null) {
-                // Package doesn't exist, no storage info to report
-                return new StorageInfo.Builder().build();
-            }
-            if (!databases.contains(databaseName)) {
-                // Database doesn't exist, no storage info to report
-                return new StorageInfo.Builder().build();
-            }
+            StorageInfo.Builder storageInfoBuilder = new StorageInfo.Builder();
+            String prefix = createPrefix(packageName, databaseName);
+            if (Flags.enableBlobStore()) {
+                // read blob storage info and set to storageInfoBuilder
+                StorageInfoProto storageInfoProto = getRawStorageInfoProto();
+                getBlobStorageInfoForPrefix(storageInfoProto, prefix, storageInfoBuilder);
+                // read document storage info and set to storageInfoBuilder
+                Set<String> wantedPrefixedDocumentNamespaces =
+                        mNamespaceCacheLocked.getPrefixedDocumentNamespaces(prefix);
+                if (wantedPrefixedDocumentNamespaces == null
+                        || wantedPrefixedDocumentNamespaces.isEmpty()) {
+                    return storageInfoBuilder.build();
+                }
+                getDocumentStorageInfoForNamespaces(
+                        storageInfoProto, wantedPrefixedDocumentNamespaces, storageInfoBuilder);
+            } else {
+                Map<String, Set<String>> packageToDatabases = getPackageToDatabases();
+                Set<String> databases = packageToDatabases.get(packageName);
+                if (databases == null) {
+                    // Package doesn't exist, no storage info to report
+                    return storageInfoBuilder.build();
+                }
+                if (!databases.contains(databaseName)) {
+                    // Database doesn't exist, no storage info to report
+                    return storageInfoBuilder.build();
+                }
 
-            Set<String> wantedPrefixedNamespaces =
-                    mNamespaceMapLocked.get(createPrefix(packageName, databaseName));
-            if (wantedPrefixedNamespaces == null || wantedPrefixedNamespaces.isEmpty()) {
-                return new StorageInfo.Builder().build();
+                Set<String> wantedPrefixedDocumentNamespaces =
+                        mNamespaceCacheLocked.getPrefixedDocumentNamespaces(prefix);
+                if (wantedPrefixedDocumentNamespaces == null
+                        || wantedPrefixedDocumentNamespaces.isEmpty()) {
+                    return storageInfoBuilder.build();
+                }
+                getDocumentStorageInfoForNamespaces(
+                        getRawStorageInfoProto(),
+                        wantedPrefixedDocumentNamespaces,
+                        storageInfoBuilder);
             }
-
-            return getStorageInfoForNamespaces(getRawStorageInfoProto(), wantedPrefixedNamespaces);
+            return storageInfoBuilder.build();
         } finally {
             mReadWriteLock.readLock().unlock();
         }
@@ -2222,12 +2509,20 @@ public final class AppSearchImpl implements Closeable {
     /**
      * Extracts and returns {@link StorageInfo} from {@link StorageInfoProto} based on prefixed
      * namespaces.
+     *
+     * @param storageInfoProto The source {@link StorageInfoProto} containing storage information to
+     *     be analyzed.
+     * @param prefixedNamespaces A set of prefixed namespaces that the storage information will be
+     *     filtered against. Only namespaces in this set will be included in the analysis.
+     * @param storageInfoBuilder The {@link StorageInfo.Builder} used to and build the resulting
+     *     {@link StorageInfo}. This builder will be modified with calculated values.
      */
-    @NonNull
-    private static StorageInfo getStorageInfoForNamespaces(
-            @NonNull StorageInfoProto storageInfoProto, @NonNull Set<String> prefixedNamespaces) {
+    private static void getDocumentStorageInfoForNamespaces(
+            @NonNull StorageInfoProto storageInfoProto,
+            @NonNull Set<String> prefixedNamespaces,
+            @NonNull StorageInfo.Builder storageInfoBuilder) {
         if (!storageInfoProto.hasDocumentStorageInfo()) {
-            return new StorageInfo.Builder().build();
+            return;
         }
 
         long totalStorageSize = storageInfoProto.getTotalStorageSize();
@@ -2238,7 +2533,7 @@ public final class AppSearchImpl implements Closeable {
 
         if (totalStorageSize == 0 || totalDocuments == 0) {
             // Maybe we can exit early and also avoid a divide by 0 error.
-            return new StorageInfo.Builder().build();
+            return;
         }
 
         // Accumulate stats across the package's namespaces.
@@ -2264,11 +2559,42 @@ public final class AppSearchImpl implements Closeable {
         // that while the total storage takes into account schema, index, etc. in addition to
         // documents, we'll only calculate the percentage based on number of documents a
         // client has.
-        return new StorageInfo.Builder()
+        storageInfoBuilder
                 .setSizeBytes((long) (namespaceDocuments * 1.0 / totalDocuments * totalStorageSize))
                 .setAliveDocumentsCount(aliveDocuments)
-                .setAliveNamespacesCount(aliveNamespaces)
-                .build();
+                .setAliveNamespacesCount(aliveNamespaces);
+    }
+
+    /**
+     * Extracts and returns blob storage information from {@link StorageInfoProto} based on a
+     * namespace prefix.
+     *
+     * @param storageInfoProto The source {@link StorageInfoProto} containing blob storage
+     *     information to be analyzed.
+     * @param prefix The prefix to match namespaces against. Only blob storage for namespaces
+     *     starting with this prefix will be included.
+     * @param storageInfoBuilder The {@link StorageInfo.Builder} used to and build the resulting
+     *     {@link StorageInfo}. This builder will be modified with calculated values.
+     */
+    private static void getBlobStorageInfoForPrefix(
+            @NonNull StorageInfoProto storageInfoProto,
+            @NonNull String prefix,
+            @NonNull StorageInfo.Builder storageInfoBuilder) {
+        if (storageInfoProto.getNamespaceBlobStorageInfoCount() == 0) {
+            return;
+        }
+        List<NamespaceBlobStorageInfoProto> blobStorageInfoProtos =
+                storageInfoProto.getNamespaceBlobStorageInfoList();
+        long blobSizeBytes = 0;
+        int blobCount = 0;
+        for (int i = 0; i < blobStorageInfoProtos.size(); i++) {
+            NamespaceBlobStorageInfoProto blobStorageInfoProto = blobStorageInfoProtos.get(i);
+            if (blobStorageInfoProto.getNamespace().startsWith(prefix)) {
+                blobSizeBytes += blobStorageInfoProto.getBlobSize();
+                blobCount += blobStorageInfoProto.getNumBlobs();
+            }
+        }
+        storageInfoBuilder.setBlobCount(blobCount).setBlobSizeBytes(blobSizeBytes);
     }
 
     /**
@@ -2342,7 +2668,8 @@ public final class AppSearchImpl implements Closeable {
      * @param packageName The name of package to be removed.
      * @throws AppSearchException if we cannot remove the data.
      */
-    public void clearPackageData(@NonNull String packageName) throws AppSearchException {
+    public void clearPackageData(@NonNull String packageName)
+            throws AppSearchException, IOException {
         mReadWriteLock.writeLock().lock();
         try {
             throwIfClosedLocked();
@@ -2359,6 +2686,9 @@ public final class AppSearchImpl implements Closeable {
                 existingPackages.remove(packageName);
                 prunePackageData(existingPackages);
             }
+            if (mRevocableFileDescriptorStore != null) {
+                mRevocableFileDescriptorStore.revokeForPackage(packageName);
+            }
         } finally {
             mReadWriteLock.writeLock().unlock();
         }
@@ -2417,18 +2747,18 @@ public final class AppSearchImpl implements Closeable {
                 String packageName = entry.getKey();
                 Set<String> databaseNames = entry.getValue();
                 if (!installedPackages.contains(packageName) && databaseNames != null) {
-                    mDocumentCountMapLocked.remove(packageName);
+                    mDocumentLimiterLocked.reportPackageRemoved(packageName);
                     synchronized (mNextPageTokensLocked) {
                         mNextPageTokensLocked.remove(packageName);
                     }
                     for (String databaseName : databaseNames) {
                         String removedPrefix = createPrefix(packageName, databaseName);
                         Set<String> removedSchemas = mSchemaCacheLocked.removePrefix(removedPrefix);
-                        if (mVisibilityStoreLocked != null) {
-                            mVisibilityStoreLocked.removeVisibility(removedSchemas);
+                        if (mDocumentVisibilityStoreLocked != null) {
+                            mDocumentVisibilityStoreLocked.removeVisibility(removedSchemas);
                         }
 
-                        mNamespaceMapLocked.remove(removedPrefix);
+                        mNamespaceCacheLocked.removeDocumentNamespaces(removedPrefix);
                     }
                 }
             }
@@ -2456,8 +2786,16 @@ public final class AppSearchImpl implements Closeable {
                 resetResultProto);
         mOptimizeIntervalCountLocked = 0;
         mSchemaCacheLocked.clear();
-        mNamespaceMapLocked.clear();
-        mDocumentCountMapLocked.clear();
+        mNamespaceCacheLocked.clear();
+
+        // We just reset the index. So there is no need to retrieve the actual storage info. We know
+        // that there are no actual namespaces.
+        List<NamespaceStorageInfoProto> emptyNamespaceInfos = Collections.emptyList();
+        mDocumentLimiterLocked =
+                new DocumentLimiter(
+                        mConfig.getDocumentCountLimitStartThreshold(),
+                        mConfig.getPerPackageDocumentCountLimit(),
+                        emptyNamespaceInfos);
         synchronized (mNextPageTokensLocked) {
             mNextPageTokensLocked.clear();
         }
@@ -2470,26 +2808,6 @@ public final class AppSearchImpl implements Closeable {
         checkSuccess(resetResultProto.getStatus());
     }
 
-    @GuardedBy("mReadWriteLock")
-    private void rebuildDocumentCountMapLocked(@NonNull StorageInfoProto storageInfoProto) {
-        mDocumentCountMapLocked.clear();
-        List<NamespaceStorageInfoProto> namespaceStorageInfoProtoList =
-                storageInfoProto.getDocumentStorageInfo().getNamespaceStorageInfoList();
-        for (int i = 0; i < namespaceStorageInfoProtoList.size(); i++) {
-            NamespaceStorageInfoProto namespaceStorageInfoProto =
-                    namespaceStorageInfoProtoList.get(i);
-            String packageName = getPackageName(namespaceStorageInfoProto.getNamespace());
-            Integer oldCount = mDocumentCountMapLocked.get(packageName);
-            int newCount;
-            if (oldCount == null) {
-                newCount = namespaceStorageInfoProto.getNumAliveDocuments();
-            } else {
-                newCount = oldCount + namespaceStorageInfoProto.getNumAliveDocuments();
-            }
-            mDocumentCountMapLocked.put(packageName, newCount);
-        }
-    }
-
     /** Wrapper around schema changes */
     @VisibleForTesting
     static class RewrittenSchemaResults {
@@ -2578,6 +2896,44 @@ public final class AppSearchImpl implements Closeable {
         return rewrittenSchemaResults;
     }
 
+    /**
+     * Rewrite the {@link InternalVisibilityConfig} to add given prefix in the schemaType of the
+     * given List of {@link InternalVisibilityConfig}
+     *
+     * @param prefix The full prefix to prepend to the visibilityConfigs.
+     * @param visibilityConfigs The visibility configs that need to add prefix
+     * @param removedVisibilityConfigs The removed configs that is not included in the given
+     *     visibilityConfigs.
+     * @return The List of {@link InternalVisibilityConfig} that contains prefixed in its schema
+     *     types.
+     */
+    private List<InternalVisibilityConfig> rewriteVisibilityConfigs(
+            @NonNull String prefix,
+            @NonNull List<InternalVisibilityConfig> visibilityConfigs,
+            @NonNull Set<String> removedVisibilityConfigs) {
+        List<InternalVisibilityConfig> prefixedVisibilityConfigs =
+                new ArrayList<>(visibilityConfigs.size());
+        for (int i = 0; i < visibilityConfigs.size(); i++) {
+            InternalVisibilityConfig visibilityConfig = visibilityConfigs.get(i);
+            // The VisibilityConfig is controlled by the client and it's untrusted but we
+            // make it safe by appending a prefix.
+            // We must control the package-database prefix. Therefore even if the client
+            // fake the id, they can only mess their own app. That's totally allowed and
+            // they can do this via the public API too.
+            // TODO(b/275592563): Move prefixing into VisibilityConfig
+            //  .createVisibilityDocument and createVisibilityOverlay
+            String namespace = visibilityConfig.getSchemaType();
+            String prefixedNamespace = prefix + namespace;
+            prefixedVisibilityConfigs.add(
+                    new InternalVisibilityConfig.Builder(visibilityConfig)
+                            .setSchemaType(prefixedNamespace)
+                            .build());
+            // This schema has visibility settings. We should keep it from the removal list.
+            removedVisibilityConfigs.remove(prefixedNamespace);
+        }
+        return prefixedVisibilityConfigs;
+    }
+
     @VisibleForTesting
     @GuardedBy("mReadWriteLock")
     SchemaProto getSchemaProtoLocked() throws AppSearchException {
@@ -2694,16 +3050,6 @@ public final class AppSearchImpl implements Closeable {
         mObserverManager.dispatchAndClearPendingNotifications();
     }
 
-    private static void addToMap(
-            Map<String, Set<String>> map, String prefix, String prefixedValue) {
-        Set<String> values = map.get(prefix);
-        if (values == null) {
-            values = new ArraySet<>();
-            map.put(prefix, values);
-        }
-        values.add(prefixedValue);
-    }
-
     /**
      * Checks the given status code and throws an {@link AppSearchException} if code is an error.
      *
@@ -2874,6 +3220,21 @@ public final class AppSearchImpl implements Closeable {
         }
     }
 
+    /**
+     * Returns all prefixed blob namespaces saved in AppSearch.
+     *
+     * <p>This method is inefficient to call repeatedly.
+     */
+    @NonNull
+    public List<String> getAllPrefixedBlobNamespaces() {
+        mReadWriteLock.readLock().lock();
+        try {
+            return mNamespaceCacheLocked.getAllPrefixedBlobNamespaces();
+        } finally {
+            mReadWriteLock.readLock().unlock();
+        }
+    }
+
     /**
      * Converts an erroneous status code from the Icing status enums to the AppSearchResult enums.
      *
@@ -2887,4 +3248,27 @@ public final class AppSearchImpl implements Closeable {
     private static int statusProtoToResultCode(@NonNull StatusProto statusProto) {
         return ResultCodeToProtoConverter.toResultCode(statusProto.getCode());
     }
+
+    private static void verifyCallingBlobHandle(
+            @NonNull String callingPackageName,
+            @NonNull String callingDatabaseName,
+            @NonNull AppSearchBlobHandle blobHandle)
+            throws AppSearchException {
+        if (!blobHandle.getPackageName().equals(callingPackageName)) {
+            throw new AppSearchException(
+                    AppSearchResult.RESULT_INVALID_ARGUMENT,
+                    "Blob package doesn't match calling package, calling package: "
+                            + callingPackageName
+                            + ", blob package: "
+                            + blobHandle.getPackageName());
+        }
+        if (!blobHandle.getDatabaseName().equals(callingDatabaseName)) {
+            throw new AppSearchException(
+                    AppSearchResult.RESULT_INVALID_ARGUMENT,
+                    "Blob database doesn't match calling database, calling database: "
+                            + callingDatabaseName
+                            + ", blob database: "
+                            + blobHandle.getDatabaseName());
+        }
+    }
 }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/DocumentLimiter.java b/service/java/com/android/server/appsearch/external/localstorage/DocumentLimiter.java
new file mode 100644
index 00000000..81f27f50
--- /dev/null
+++ b/service/java/com/android/server/appsearch/external/localstorage/DocumentLimiter.java
@@ -0,0 +1,215 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.external.localstorage;
+
+import static com.android.server.appsearch.external.localstorage.util.PrefixUtil.getPackageName;
+
+import android.annotation.NonNull;
+import android.app.appsearch.AppSearchResult;
+import android.app.appsearch.exceptions.AppSearchException;
+import android.util.ArrayMap;
+
+import com.android.appsearch.flags.Flags;
+import com.android.server.appsearch.external.localstorage.util.MapUtil;
+
+import com.google.android.icing.proto.NamespaceStorageInfoProto;
+
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.concurrent.Callable;
+
+/**
+ * A class that encapsulates per-package document count tracking and limit enforcement.
+ *
+ * <p>This class is configured with a {@link #mDocumentLimitStartThreshold}. While the total number
+ * of documents in the system is below that threshold, all packages will be allowed to put as many
+ * documents into the index as they wish. Once the total number of documents exceed {@link
+ * #mDocumentLimitStartThreshold}, then each package will be limited to no more than {@link
+ * #mPerPackageDocumentCountLimit} documents.
+ *
+ * <p>This class is not thread safe.
+ *
+ * @hide
+ */
+public class DocumentLimiter {
+    private final int mDocumentLimitStartThreshold;
+    private final int mPerPackageDocumentCountLimit;
+    private int mTotalDocumentCount;
+    private final Map<String, Integer> mDocumentCountMap;
+
+    /**
+     * @param documentLimitStartThreshold the total number of documents in the system at which the
+     *     limiter should begin applying the perPackageDocumentCountLimit limit.
+     * @param perPackageDocumentCountLimit the maximum number of documents that each package is
+     *     allowed to have once the total number of documents in the system exceeds
+     *     documentLimitStartThreshold.
+     * @param namespaceStorageInfoProtoList a list of NamespaceStorageInfoProtos that reflects the
+     *     state of the index when this DocumentLimiter was created.
+     */
+    public DocumentLimiter(
+            int documentLimitStartThreshold,
+            int perPackageDocumentCountLimit,
+            @NonNull List<NamespaceStorageInfoProto> namespaceStorageInfoProtoList) {
+        mDocumentLimitStartThreshold = documentLimitStartThreshold;
+        mPerPackageDocumentCountLimit = perPackageDocumentCountLimit;
+        mTotalDocumentCount = 0;
+        mDocumentCountMap = new ArrayMap<>(namespaceStorageInfoProtoList.size());
+        buildDocumentCountMap(Objects.requireNonNull(namespaceStorageInfoProtoList));
+    }
+
+    /**
+     * Checks whether the package identified by packageName should be allowed to add another
+     * document.
+     *
+     * @param packageName the name of the package attempting to add the document
+     * @param namespaceStorageInfoProducer a callable that returns an up-to-date list of
+     *     NamespaceStorageInfoProtos.
+     * @throws AppSearchException if the document limit is in force (because the total number of
+     *     documents in the system exceeds {@link #mDocumentLimitStartThreshold}) and the package
+     *     identified by packageName has already added more documents than {@link
+     *     #mPerPackageDocumentCountLimit}.
+     */
+    public void enforceDocumentCountLimit(
+            @NonNull String packageName,
+            @NonNull Callable<List<NamespaceStorageInfoProto>> namespaceStorageInfoProducer)
+            throws AppSearchException {
+        Objects.requireNonNull(packageName);
+        if (mTotalDocumentCount < mDocumentLimitStartThreshold) {
+            return;
+        }
+        Integer newDocumentCount = MapUtil.getOrDefault(mDocumentCountMap, packageName, 0) + 1;
+        if (!Flags.enableDocumentLimiterReplaceTracking()
+                && newDocumentCount > mPerPackageDocumentCountLimit) {
+            // Our management of mDocumentCountMap doesn't account for document
+            // replacements, so our counter might have overcounted if the app has replaced docs.
+            // Rebuild the counter from StorageInfo in case this is so.
+            refreshDocumentCount(namespaceStorageInfoProducer);
+            newDocumentCount = MapUtil.getOrDefault(mDocumentCountMap, packageName, 0) + 1;
+        }
+        if (newDocumentCount > mPerPackageDocumentCountLimit) {
+            // Now we really can't fit it in, even accounting for replacements.
+            throw new AppSearchException(
+                    AppSearchResult.RESULT_OUT_OF_SPACE,
+                    "Package \""
+                            + packageName
+                            + "\" exceeded limit of "
+                            + mPerPackageDocumentCountLimit
+                            + " documents. Some documents "
+                            + "must be removed to index additional ones.");
+        }
+    }
+
+    /**
+     * Informs the DocumentLimiter that another document has been added for the package identified
+     * by package.
+     *
+     * @param packageName the name of the package that owns the added document.
+     */
+    public void reportDocumentAdded(
+            @NonNull String packageName,
+            @NonNull Callable<List<NamespaceStorageInfoProto>> namespaceStorageInfoProducer)
+            throws AppSearchException {
+        Objects.requireNonNull(packageName);
+        ++mTotalDocumentCount;
+        Integer newDocumentCount = MapUtil.getOrDefault(mDocumentCountMap, packageName, 0) + 1;
+        mDocumentCountMap.put(packageName, newDocumentCount);
+        if (!Flags.enableDocumentLimiterReplaceTracking()
+                && mTotalDocumentCount == mDocumentLimitStartThreshold) {
+            // We just hit the document limit start threshold. If
+            // Flags.enableDocumentLimiterReplaceTracking is false, then it's possible that we're
+            // over-counting documents. So we refresh the document count to make sure that we have
+            // the right count.
+            refreshDocumentCount(namespaceStorageInfoProducer);
+        }
+    }
+
+    /**
+     * Informs the DocumentLimiter that numDocumentsDeleted documents, owned by the package
+     * identified by packageName, have been deleted.
+     *
+     * @param packageName the name of the package that owns the deleted documents.
+     * @param numDocumentsDeleted the number of documents that were deleted.
+     */
+    public void reportDocumentsRemoved(@NonNull String packageName, int numDocumentsDeleted) {
+        Objects.requireNonNull(packageName);
+        if (numDocumentsDeleted <= 0) {
+            return;
+        }
+        mTotalDocumentCount -= numDocumentsDeleted;
+        Integer oldDocumentCount = mDocumentCountMap.get(packageName);
+        // This should always be true: how can we delete documents for a package without
+        // having seen that package during init? This is just a safeguard.
+        if (oldDocumentCount != null) {
+            if (numDocumentsDeleted >= oldDocumentCount) {
+                mDocumentCountMap.remove(packageName);
+            } else {
+                mDocumentCountMap.put(packageName, oldDocumentCount - numDocumentsDeleted);
+            }
+        }
+    }
+
+    /**
+     * Informs the DocumentLimiter that the package identified by packageName has been removed from
+     * the system entirely.
+     *
+     * @param packageName the name of the package that was removed.
+     */
+    public void reportPackageRemoved(@NonNull String packageName) {
+        Objects.requireNonNull(packageName);
+        Integer oldDocumentCount = mDocumentCountMap.remove(packageName);
+        if (oldDocumentCount != null) {
+            // This should always be true: how can we remove a package without having seen that
+            // package during init? This is just a safeguard.
+            mTotalDocumentCount -= oldDocumentCount;
+        }
+    }
+
+    private void refreshDocumentCount(
+            @NonNull Callable<List<NamespaceStorageInfoProto>> namespaceStorageInfoProducer)
+            throws AppSearchException {
+        try {
+            List<NamespaceStorageInfoProto> namespaceStorageInfos =
+                    namespaceStorageInfoProducer.call();
+            buildDocumentCountMap(namespaceStorageInfos);
+        } catch (AppSearchException e) {
+            throw e;
+        } catch (Exception e) {
+            // This should never happen.
+            throw new AppSearchException(
+                    AppSearchResult.RESULT_UNKNOWN_ERROR,
+                    "Encountered unexpected exception when retrieving namespace storage info.",
+                    e);
+        }
+    }
+
+    private void buildDocumentCountMap(
+            @NonNull List<NamespaceStorageInfoProto> namespaceStorageInfoProtoList) {
+        mDocumentCountMap.clear();
+        mTotalDocumentCount = 0;
+        for (int i = 0; i < namespaceStorageInfoProtoList.size(); i++) {
+            NamespaceStorageInfoProto namespaceStorageInfoProto =
+                    namespaceStorageInfoProtoList.get(i);
+            mTotalDocumentCount += namespaceStorageInfoProto.getNumAliveDocuments();
+            String packageName = getPackageName(namespaceStorageInfoProto.getNamespace());
+            Integer newCount =
+                    MapUtil.getOrDefault(mDocumentCountMap, packageName, 0)
+                            + namespaceStorageInfoProto.getNumAliveDocuments();
+            mDocumentCountMap.put(packageName, newCount);
+        }
+    }
+}
diff --git a/service/java/com/android/server/appsearch/external/localstorage/IcingOptionsConfig.java b/service/java/com/android/server/appsearch/external/localstorage/IcingOptionsConfig.java
index f05bc43d..0508caba 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/IcingOptionsConfig.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/IcingOptionsConfig.java
@@ -72,6 +72,8 @@ public interface IcingOptionsConfig {
 
     boolean DEFAULT_BUILD_PROPERTY_EXISTENCE_METADATA_HITS = false;
 
+    long DEFAULT_ORPHAN_BLOB_TIME_TO_LIVE_MS = 7 * 24 * 60 * 60 * 1000L; // 1 week.
+
     /**
      * The maximum allowable token length. All tokens in excess of this size will be truncated to
      * max_token_length before being indexed.
@@ -220,4 +222,12 @@ public interface IcingOptionsConfig {
      * support the hasProperty function in advanced query.
      */
     boolean getBuildPropertyExistenceMetadataHits();
+
+    /**
+     * Config for {@link com.google.android.icing.proto.IcingSearchEngineOptions}.
+     *
+     * <p>The maximum time in millisecond for a orphan blob to get recycled and deleted if there is
+     * no reference document linked to it.
+     */
+    long getOrphanBlobTimeToLiveMs();
 }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/LimitConfig.java b/service/java/com/android/server/appsearch/external/localstorage/LimitConfig.java
index 6c5846ea..4509cffc 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/LimitConfig.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/LimitConfig.java
@@ -48,12 +48,19 @@ public interface LimitConfig {
      *
      * <ol>
      *   <li>Protect icing lib's docid space from being overwhelmed by a single app. The overall
-     *       docid limit is currently 2^20 (~1 million)
+     *       docid limit is currently 2^22 (~4 million)
      *   <li>Prevent apps from using a very large amount of data on the system by storing too many
      *       documents.
      * </ol>
      */
-    int getMaxDocumentCount();
+    int getPerPackageDocumentCountLimit();
+
+    /**
+     * The number of total documents in the index at which AppSearch should start rationing docid
+     * space by limiting packages to add {@link #getPerPackageDocumentCountLimit()} documents to the
+     * index.
+     */
+    int getDocumentCountLimitStartThreshold();
 
     /**
      * The maximum number of suggestion results a single app is allowed to search.
@@ -64,4 +71,10 @@ public interface LimitConfig {
      * being overwhelmed by a single app.
      */
     int getMaxSuggestionCount();
+
+    /**
+     * Returns the maximum number of {@link android.os.ParcelFileDescriptor} that a single app could
+     * open for read and write blob from AppSearch.
+     */
+    int getMaxOpenBlobCount();
 }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/NamespaceCache.java b/service/java/com/android/server/appsearch/external/localstorage/NamespaceCache.java
new file mode 100644
index 00000000..cdc0d421
--- /dev/null
+++ b/service/java/com/android/server/appsearch/external/localstorage/NamespaceCache.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.external.localstorage;
+
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.util.ArrayMap;
+import android.util.ArraySet;
+
+import com.android.internal.annotations.VisibleForTesting;
+import com.android.server.appsearch.external.localstorage.util.PrefixUtil;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Caches and manages namespace information for AppSearch.
+ *
+ * <p>This class is NOT thread safety.
+ *
+ * @hide
+ */
+public class NamespaceCache {
+
+    // This map contains namespaces for all package-database prefixes. All values in the map are
+    // prefixed with the package-database prefix.
+    private final Map<String, Set<String>> mDocumentNamespaceMap = new ArrayMap<>();
+
+    // This map contains blob namespaces for all package-database prefixes. All values in the map
+    // are prefixed with the package-database prefix.
+    private final Map<String, Set<String>> mBlobNamespaceMap = new ArrayMap<>();
+
+    public NamespaceCache() {}
+
+    @VisibleForTesting
+    public NamespaceCache(@NonNull Map<String, Set<String>> documentNamespaceMap) {
+        mDocumentNamespaceMap.putAll(documentNamespaceMap);
+    }
+
+    /** Gets all prefixed document namespaces of the given package. */
+    @NonNull
+    public Set<String> getAllPrefixedDocumentNamespaceForPackage(@NonNull String packageName) {
+        Set<String> wantedPrefixedNamespaces = new ArraySet<>();
+
+        // Accumulate all the namespaces we're interested in.
+        for (String prefix : mDocumentNamespaceMap.keySet()) {
+            if (PrefixUtil.getPackageName(prefix).equals(packageName)) {
+                wantedPrefixedNamespaces.addAll(mDocumentNamespaceMap.get(prefix));
+            }
+        }
+        return wantedPrefixedNamespaces;
+    }
+
+    /** Gets prefixed document namespaces of the given prefix. */
+    @Nullable
+    public Set<String> getPrefixedDocumentNamespaces(@NonNull String prefix) {
+        return mDocumentNamespaceMap.get(prefix);
+    }
+
+    /** Gets prefixed blob namespaces of the given prefix. */
+    @Nullable
+    public Set<String> getPrefixedBlobNamespaces(@NonNull String prefix) {
+        return mBlobNamespaceMap.get(prefix);
+    }
+
+    /** Gets all prefixes that contains documents in AppSearch. */
+    @NonNull
+    public Set<String> getAllDocumentPrefixes() {
+        return mDocumentNamespaceMap.keySet();
+    }
+
+    /** Gets all prefixed blob namespaces in AppSearch. */
+    @NonNull
+    public List<String> getAllPrefixedBlobNamespaces() {
+        List<String> prefixedBlobNamespaces = new ArrayList<>();
+        for (Set<String> value : mBlobNamespaceMap.values()) {
+            prefixedBlobNamespaces.addAll(value);
+        }
+        return prefixedBlobNamespaces;
+    }
+
+    /** Removes prefixed document namespaces under the given prefix. */
+    @Nullable
+    public Set<String> removeDocumentNamespaces(@NonNull String prefix) {
+        return mDocumentNamespaceMap.remove(prefix);
+    }
+
+    /** Add the given prefixed namespace to document namespace map. */
+    public void addToDocumentNamespaceMap(
+            @NonNull String prefix, @NonNull String prefixedNamespace) {
+        addToMap(mDocumentNamespaceMap, prefix, prefixedNamespace);
+    }
+
+    /** Add the given prefixed namespace to blob namespace map. */
+    public void addToBlobNamespaceMap(@NonNull String prefix, @NonNull String prefixedNamespace) {
+        addToMap(mBlobNamespaceMap, prefix, prefixedNamespace);
+    }
+
+    /** Clears all data in the cache. */
+    public void clear() {
+        mDocumentNamespaceMap.clear();
+        mBlobNamespaceMap.clear();
+    }
+
+    private static void addToMap(
+            Map<String, Set<String>> map, String prefix, String prefixedValue) {
+        Set<String> values = map.get(prefix);
+        if (values == null) {
+            values = new ArraySet<>();
+            map.put(prefix, values);
+        }
+        values.add(prefixedValue);
+    }
+}
diff --git a/service/java/com/android/server/appsearch/external/localstorage/RevocableFileDescriptorStore.java b/service/java/com/android/server/appsearch/external/localstorage/RevocableFileDescriptorStore.java
new file mode 100644
index 00000000..6958690b
--- /dev/null
+++ b/service/java/com/android/server/appsearch/external/localstorage/RevocableFileDescriptorStore.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.external.localstorage;
+
+import android.annotation.NonNull;
+import android.app.appsearch.exceptions.AppSearchException;
+import android.os.ParcelFileDescriptor;
+
+import java.io.IOException;
+
+/**
+ * Interface for revocable file descriptors storage.
+ *
+ * <p>This store allows wrapping {@link ParcelFileDescriptor} instances into revocable file
+ * descriptors, enabling the ability to close and revoke it's access to the file even if the {@link
+ * ParcelFileDescriptor} has been sent to the client side.
+ *
+ * <p>Implementations of this interface can provide controlled access to resources by associating
+ * each file descriptor with a package and allowing them to be individually revoked by package or
+ * revoked all at once.
+ *
+ * @hide
+ */
+public interface RevocableFileDescriptorStore {
+
+    /**
+     * Wraps the provided ParcelFileDescriptor into a revocable file descriptor. This allows for
+     * controlled access to the file descriptor, making it revocable by the store.
+     *
+     * @param packageName The package name requesting the revocable file descriptor.
+     * @param parcelFileDescriptor The original ParcelFileDescriptor to be wrapped.
+     * @return A ParcelFileDescriptor that can be revoked by the store.
+     */
+    @NonNull
+    ParcelFileDescriptor wrapToRevocableFileDescriptor(
+            @NonNull String packageName, @NonNull ParcelFileDescriptor parcelFileDescriptor)
+            throws IOException;
+
+    /**
+     * Revokes all revocable file descriptors previously issued by the store. After calling this
+     * method, any access to these file descriptors will fail.
+     *
+     * @throws IOException If an I/O error occurs while revoking file descriptors.
+     */
+    void revokeAll() throws IOException;
+
+    /**
+     * Revokes all revocable file descriptors for a specified package. Only file descriptors
+     * associated with the given package name will be revoked.
+     *
+     * @param packageName The package name whose file descriptors should be revoked.
+     * @throws IOException If an I/O error occurs while revoking file descriptors.
+     */
+    void revokeForPackage(@NonNull String packageName) throws IOException;
+
+    /** Checks if the specified package has reached its blob storage limit. */
+    void checkBlobStoreLimit(@NonNull String packageName) throws AppSearchException;
+}
diff --git a/service/java/com/android/server/appsearch/external/localstorage/SchemaCache.java b/service/java/com/android/server/appsearch/external/localstorage/SchemaCache.java
index ae242ea4..98ef5952 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/SchemaCache.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/SchemaCache.java
@@ -17,9 +17,14 @@
 package com.android.server.appsearch.external.localstorage;
 
 import android.annotation.NonNull;
+import android.app.appsearch.exceptions.AppSearchException;
 import android.util.ArrayMap;
 import android.util.ArraySet;
 
+import com.android.appsearch.flags.Flags;
+import com.android.internal.annotations.VisibleForTesting;
+import com.android.server.appsearch.external.localstorage.util.PrefixUtil;
+
 import com.google.android.icing.proto.SchemaTypeConfigProto;
 
 import java.util.ArrayDeque;
@@ -52,11 +57,23 @@ public class SchemaCache {
     private final Map<String, Map<String, List<String>>> mSchemaParentToChildrenMap =
             new ArrayMap<>();
 
+    /**
+     * A map that contains schema types and all parent schema types for all package-database
+     * prefixes. It maps each package-database prefix to an inner-map. The inner-map maps each
+     * prefixed schema type to its respective list of unprefixed parent schema types including
+     * transitive parents. It's guaranteed that child types always appear before parent types in the
+     * list.
+     */
+    private final Map<String, Map<String, List<String>>>
+            mSchemaChildToTransitiveUnprefixedParentsMap = new ArrayMap<>();
+
     public SchemaCache() {}
 
-    public SchemaCache(@NonNull Map<String, Map<String, SchemaTypeConfigProto>> schemaMap) {
+    @VisibleForTesting
+    public SchemaCache(@NonNull Map<String, Map<String, SchemaTypeConfigProto>> schemaMap)
+            throws AppSearchException {
         mSchemaMap.putAll(Objects.requireNonNull(schemaMap));
-        rebuildSchemaParentToChildrenMap();
+        rebuildCache();
     }
 
     /** Returns the schema map for the given prefix. */
@@ -125,17 +142,46 @@ public class SchemaCache {
     }
 
     /**
-     * Rebuilds the schema parent-to-children map for the given prefix, based on the current schema
-     * map.
+     * Returns the unprefixed parent schema types, including transitive parents, for the given
+     * prefixed schema type, based on the schema child-to-parents map held in the cache. It's
+     * guaranteed that child types always appear before parent types in the list.
+     */
+    @NonNull
+    public List<String> getTransitiveUnprefixedParentSchemaTypes(
+            @NonNull String prefix, @NonNull String prefixedSchemaType) throws AppSearchException {
+        Objects.requireNonNull(prefix);
+        Objects.requireNonNull(prefixedSchemaType);
+
+        // If the flag is on, retrieve the parent types from the cache as it is available.
+        // Otherwise, recalculate the parent types.
+        if (Flags.enableSearchResultParentTypes()) {
+            Map<String, List<String>> unprefixedChildToParentsMap =
+                    mSchemaChildToTransitiveUnprefixedParentsMap.get(prefix);
+            if (unprefixedChildToParentsMap == null) {
+                return Collections.emptyList();
+            }
+            List<String> parents = unprefixedChildToParentsMap.get(prefixedSchemaType);
+            return parents == null ? Collections.emptyList() : parents;
+        } else {
+            return calculateTransitiveUnprefixedParentSchemaTypes(
+                    prefixedSchemaType, getSchemaMapForPrefix(prefix));
+        }
+    }
+
+    /**
+     * Rebuilds the schema parent-to-children and child-to-parents maps for the given prefix, based
+     * on the current schema map.
      *
-     * <p>The schema parent-to-children map is required to be updated when {@link #addToSchemaMap}
-     * or {@link #removeFromSchemaMap} has been called. Otherwise, the results from {@link
-     * #getSchemaTypesWithDescendants} would be stale.
+     * <p>The schema parent-to-children and child-to-parents maps must be updated when {@link
+     * #addToSchemaMap} or {@link #removeFromSchemaMap} has been called. Otherwise, the results from
+     * {@link #getSchemaTypesWithDescendants} and {@link #getTransitiveUnprefixedParentSchemaTypes}
+     * would be stale.
      */
-    public void rebuildSchemaParentToChildrenMapForPrefix(@NonNull String prefix) {
+    public void rebuildCacheForPrefix(@NonNull String prefix) throws AppSearchException {
         Objects.requireNonNull(prefix);
 
         mSchemaParentToChildrenMap.remove(prefix);
+        mSchemaChildToTransitiveUnprefixedParentsMap.remove(prefix);
         Map<String, SchemaTypeConfigProto> prefixedSchemaMap = mSchemaMap.get(prefix);
         if (prefixedSchemaMap == null) {
             return;
@@ -154,33 +200,55 @@ public class SchemaCache {
                 children.add(childSchemaConfig.getSchemaType());
             }
         }
-
         // Record the map for the current prefix.
         if (!parentToChildrenMap.isEmpty()) {
             mSchemaParentToChildrenMap.put(prefix, parentToChildrenMap);
         }
+
+        // If the flag is on, build the child-to-parent maps as caches. Otherwise, this
+        // information will have to be recalculated when needed.
+        if (Flags.enableSearchResultParentTypes()) {
+            // Build the child-to-parents maps for the current prefix.
+            Map<String, List<String>> childToTransitiveUnprefixedParentsMap = new ArrayMap<>();
+            for (SchemaTypeConfigProto childSchemaConfig : prefixedSchemaMap.values()) {
+                if (childSchemaConfig.getParentTypesCount() > 0) {
+                    childToTransitiveUnprefixedParentsMap.put(
+                            childSchemaConfig.getSchemaType(),
+                            calculateTransitiveUnprefixedParentSchemaTypes(
+                                    childSchemaConfig.getSchemaType(), prefixedSchemaMap));
+                }
+            }
+            // Record the map for the current prefix.
+            if (!childToTransitiveUnprefixedParentsMap.isEmpty()) {
+                mSchemaChildToTransitiveUnprefixedParentsMap.put(
+                        prefix, childToTransitiveUnprefixedParentsMap);
+            }
+        }
     }
 
     /**
-     * Rebuilds the schema parent-to-children map based on the current schema map.
+     * Rebuilds the schema parent-to-children and child-to-parents maps based on the current schema
+     * map.
      *
-     * <p>The schema parent-to-children map is required to be updated when {@link #addToSchemaMap}
-     * or {@link #removeFromSchemaMap} has been called. Otherwise, the results from {@link
-     * #getSchemaTypesWithDescendants} would be stale.
+     * <p>The schema parent-to-children and child-to-parents maps must be updated when {@link
+     * #addToSchemaMap} or {@link #removeFromSchemaMap} has been called. Otherwise, the results from
+     * {@link #getSchemaTypesWithDescendants} and {@link #getTransitiveUnprefixedParentSchemaTypes}
+     * would be stale.
      */
-    public void rebuildSchemaParentToChildrenMap() {
+    public void rebuildCache() throws AppSearchException {
         mSchemaParentToChildrenMap.clear();
+        mSchemaChildToTransitiveUnprefixedParentsMap.clear();
         for (String prefix : mSchemaMap.keySet()) {
-            rebuildSchemaParentToChildrenMapForPrefix(prefix);
+            rebuildCacheForPrefix(prefix);
         }
     }
 
     /**
      * Adds a schema to the schema map.
      *
-     * <p>Note that this method will invalidate the schema parent-to-children map in the cache, and
-     * either {@link #rebuildSchemaParentToChildrenMap} or {@link
-     * #rebuildSchemaParentToChildrenMapForPrefix} is required to be called to update the cache.
+     * <p>Note that this method will invalidate the schema parent-to-children and child-to-parents
+     * maps in the cache, and either {@link #rebuildCache} or {@link #rebuildCacheForPrefix} is
+     * required to be called to update the cache.
      */
     public void addToSchemaMap(
             @NonNull String prefix, @NonNull SchemaTypeConfigProto schemaTypeConfigProto) {
@@ -198,9 +266,9 @@ public class SchemaCache {
     /**
      * Removes a schema from the schema map.
      *
-     * <p>Note that this method will invalidate the schema parent-to-children map in the cache, and
-     * either {@link #rebuildSchemaParentToChildrenMap} or {@link
-     * #rebuildSchemaParentToChildrenMapForPrefix} is required to be called to update the cache.
+     * <p>Note that this method will invalidate the schema parent-to-children and child-to-parents
+     * maps in the cache, and either {@link #rebuildCache} or {@link #rebuildCacheForPrefix} is
+     * required to be called to update the cache.
      */
     public void removeFromSchemaMap(@NonNull String prefix, @NonNull String schemaType) {
         Objects.requireNonNull(prefix);
@@ -213,8 +281,8 @@ public class SchemaCache {
     }
 
     /**
-     * Removes the entry of the given prefix from both the schema map and the schema
-     * parent-to-children map, and returns the set of removed prefixed schema type.
+     * Removes the entry of the given prefix from the schema map, the schema parent-to-children map
+     * and the child-to-parents map, and returns the set of removed prefixed schema type.
      */
     @NonNull
     public Set<String> removePrefix(@NonNull String prefix) {
@@ -223,6 +291,7 @@ public class SchemaCache {
         Map<String, SchemaTypeConfigProto> removedSchemas =
                 Objects.requireNonNull(mSchemaMap.remove(prefix));
         mSchemaParentToChildrenMap.remove(prefix);
+        mSchemaChildToTransitiveUnprefixedParentsMap.remove(prefix);
         return removedSchemas.keySet();
     }
 
@@ -230,5 +299,69 @@ public class SchemaCache {
     public void clear() {
         mSchemaMap.clear();
         mSchemaParentToChildrenMap.clear();
+        mSchemaChildToTransitiveUnprefixedParentsMap.clear();
+    }
+
+    /**
+     * Get the list of unprefixed transitive parent type names of {@code prefixedSchemaType}.
+     *
+     * <p>It's guaranteed that child types always appear before parent types in the list.
+     */
+    @NonNull
+    private List<String> calculateTransitiveUnprefixedParentSchemaTypes(
+            @NonNull String prefixedSchemaType,
+            @NonNull Map<String, SchemaTypeConfigProto> prefixedSchemaMap)
+            throws AppSearchException {
+        // Please note that neither DFS nor BFS order is guaranteed to always put child types
+        // before parent types (due to the diamond problem), so a topological sorting algorithm
+        // is required.
+        Map<String, Integer> inDegreeMap = new ArrayMap<>();
+        collectParentTypeInDegrees(
+                prefixedSchemaType,
+                prefixedSchemaMap,
+                /* visited= */ new ArraySet<>(),
+                inDegreeMap);
+
+        List<String> result = new ArrayList<>();
+        Queue<String> queue = new ArrayDeque<>();
+        // prefixedSchemaType is the only type that has zero in-degree at this point.
+        queue.add(prefixedSchemaType);
+        while (!queue.isEmpty()) {
+            SchemaTypeConfigProto currentSchema =
+                    Objects.requireNonNull(prefixedSchemaMap.get(queue.poll()));
+            for (int i = 0; i < currentSchema.getParentTypesCount(); ++i) {
+                String prefixedParentType = currentSchema.getParentTypes(i);
+                int parentInDegree =
+                        Objects.requireNonNull(inDegreeMap.get(prefixedParentType)) - 1;
+                inDegreeMap.put(prefixedParentType, parentInDegree);
+                if (parentInDegree == 0) {
+                    result.add(PrefixUtil.removePrefix(prefixedParentType));
+                    queue.add(prefixedParentType);
+                }
+            }
+        }
+        return result;
+    }
+
+    private void collectParentTypeInDegrees(
+            @NonNull String prefixedSchemaType,
+            @NonNull Map<String, SchemaTypeConfigProto> schemaTypeMap,
+            @NonNull Set<String> visited,
+            @NonNull Map<String, Integer> inDegreeMap) {
+        if (visited.contains(prefixedSchemaType)) {
+            return;
+        }
+        visited.add(prefixedSchemaType);
+        SchemaTypeConfigProto schema =
+                Objects.requireNonNull(schemaTypeMap.get(prefixedSchemaType));
+        for (int i = 0; i < schema.getParentTypesCount(); ++i) {
+            String prefixedParentType = schema.getParentTypes(i);
+            Integer parentInDegree = inDegreeMap.get(prefixedParentType);
+            if (parentInDegree == null) {
+                parentInDegree = 0;
+            }
+            inDegreeMap.put(prefixedParentType, parentInDegree + 1);
+            collectParentTypeInDegrees(prefixedParentType, schemaTypeMap, visited, inDegreeMap);
+        }
     }
 }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/converter/BlobHandleToProtoConverter.java b/service/java/com/android/server/appsearch/external/localstorage/converter/BlobHandleToProtoConverter.java
new file mode 100644
index 00000000..bbd3bb29
--- /dev/null
+++ b/service/java/com/android/server/appsearch/external/localstorage/converter/BlobHandleToProtoConverter.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.external.localstorage.converter;
+
+import android.annotation.NonNull;
+import android.app.appsearch.AppSearchBlobHandle;
+import android.app.appsearch.exceptions.AppSearchException;
+
+import com.android.server.appsearch.external.localstorage.util.PrefixUtil;
+
+import com.google.android.icing.proto.PropertyProto;
+import com.google.protobuf.ByteString;
+
+/**
+ * Translates a {@link android.app.blob.BlobHandle} into {@link PropertyProto.BlobHandleProto}.
+ *
+ * @hide
+ */
+public final class BlobHandleToProtoConverter {
+    private BlobHandleToProtoConverter() {}
+
+    /** Converters a {@link AppSearchBlobHandle} into {@link PropertyProto.BlobHandleProto}. */
+    @NonNull
+    public static PropertyProto.BlobHandleProto toBlobHandleProto(
+            @NonNull AppSearchBlobHandle blobHandle) {
+        return PropertyProto.BlobHandleProto.newBuilder()
+                .setNamespace(
+                        PrefixUtil.createPrefix(
+                                        blobHandle.getPackageName(), blobHandle.getDatabaseName())
+                                + blobHandle.getNamespace())
+                .setDigest(ByteString.copyFrom(blobHandle.getSha256Digest()))
+                .build();
+    }
+
+    /** Converters a {@link PropertyProto.BlobHandleProto} into {@link AppSearchBlobHandle}. */
+    @NonNull
+    public static AppSearchBlobHandle toAppSearchBlobHandle(
+            @NonNull PropertyProto.BlobHandleProto proto) throws AppSearchException {
+        String prefix = PrefixUtil.getPrefix(proto.getNamespace());
+        return AppSearchBlobHandle.createWithSha256(
+                proto.getDigest().toByteArray(),
+                PrefixUtil.getPackageName(prefix),
+                PrefixUtil.getDatabaseName(prefix),
+                PrefixUtil.removePrefix(proto.getNamespace()));
+    }
+}
diff --git a/service/java/com/android/server/appsearch/external/localstorage/converter/GenericDocumentToProtoConverter.java b/service/java/com/android/server/appsearch/external/localstorage/converter/GenericDocumentToProtoConverter.java
index 4cc5a18a..518008d4 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/converter/GenericDocumentToProtoConverter.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/converter/GenericDocumentToProtoConverter.java
@@ -17,15 +17,15 @@
 package com.android.server.appsearch.external.localstorage.converter;
 
 import android.annotation.NonNull;
+import android.app.appsearch.AppSearchBlobHandle;
 import android.app.appsearch.AppSearchSchema;
 import android.app.appsearch.EmbeddingVector;
 import android.app.appsearch.GenericDocument;
 import android.app.appsearch.exceptions.AppSearchException;
-import android.util.ArrayMap;
-import android.util.ArraySet;
 
+import com.android.appsearch.flags.Flags;
 import com.android.server.appsearch.external.localstorage.AppSearchConfig;
-import com.android.server.appsearch.external.localstorage.util.PrefixUtil;
+import com.android.server.appsearch.external.localstorage.SchemaCache;
 
 import com.google.android.icing.proto.DocumentProto;
 import com.google.android.icing.proto.DocumentProtoOrBuilder;
@@ -33,14 +33,11 @@ import com.google.android.icing.proto.PropertyProto;
 import com.google.android.icing.proto.SchemaTypeConfigProto;
 import com.google.protobuf.ByteString;
 
-import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
-import java.util.Queue;
-import java.util.Set;
 
 /**
  * Translates a {@link GenericDocument} into a {@link DocumentProto}.
@@ -113,6 +110,12 @@ public final class GenericDocumentToProtoConverter {
                 for (int j = 0; j < embeddingValues.length; j++) {
                     propertyProto.addVectorValues(embeddingVectorToVectorProto(embeddingValues[j]));
                 }
+            } else if (property instanceof AppSearchBlobHandle[]) {
+                AppSearchBlobHandle[] blobHandleValues = (AppSearchBlobHandle[]) property;
+                for (int j = 0; j < blobHandleValues.length; j++) {
+                    propertyProto.addBlobHandleValues(
+                            BlobHandleToProtoConverter.toBlobHandleProto(blobHandleValues[j]));
+                }
             } else if (property == null) {
                 throw new IllegalStateException(
                         String.format("Property \"%s\" doesn't have any value!", name));
@@ -138,18 +141,23 @@ public final class GenericDocumentToProtoConverter {
      * @param proto the document to convert to a {@link GenericDocument} instance. The document
      *     proto should have its package + database prefix stripped from its fields.
      * @param prefix the package + database prefix used searching the {@code schemaTypeMap}.
-     * @param schemaTypeMap map of prefixed schema type to {@link SchemaTypeConfigProto}, used for
-     *     looking up the default empty value to set for a document property that has all empty
-     *     values.
+     * @param schemaCache The SchemaCache instance held in AppSearch.
      */
     @NonNull
+    @SuppressWarnings("deprecation")
     public static GenericDocument toGenericDocument(
             @NonNull DocumentProtoOrBuilder proto,
             @NonNull String prefix,
-            @NonNull Map<String, SchemaTypeConfigProto> schemaTypeMap,
+            @NonNull SchemaCache schemaCache,
             @NonNull AppSearchConfig config)
             throws AppSearchException {
         Objects.requireNonNull(proto);
+        Objects.requireNonNull(prefix);
+        Objects.requireNonNull(schemaCache);
+        Objects.requireNonNull(config);
+        Map<String, SchemaTypeConfigProto> schemaTypeMap =
+                schemaCache.getSchemaMapForPrefix(prefix);
+
         GenericDocument.Builder<?> documentBuilder =
                 new GenericDocument.Builder<>(
                                 proto.getNamespace(), proto.getUri(), proto.getSchema())
@@ -157,9 +165,10 @@ public final class GenericDocumentToProtoConverter {
                         .setTtlMillis(proto.getTtlMs())
                         .setCreationTimestampMillis(proto.getCreationTimestampMs());
         String prefixedSchemaType = prefix + proto.getSchema();
-        if (config.shouldRetrieveParentInfo()) {
+        if (config.shouldRetrieveParentInfo() && !Flags.enableSearchResultParentTypes()) {
             List<String> parentSchemaTypes =
-                    getUnprefixedParentSchemaTypes(prefixedSchemaType, schemaTypeMap);
+                    schemaCache.getTransitiveUnprefixedParentSchemaTypes(
+                            prefix, prefixedSchemaType);
             if (!parentSchemaTypes.isEmpty()) {
                 if (config.shouldStoreParentInfoAsSyntheticProperty()) {
                     documentBuilder.setPropertyString(
@@ -209,7 +218,7 @@ public final class GenericDocumentToProtoConverter {
                 for (int j = 0; j < values.length; j++) {
                     values[j] =
                             toGenericDocument(
-                                    property.getDocumentValues(j), prefix, schemaTypeMap, config);
+                                    property.getDocumentValues(j), prefix, schemaCache, config);
                 }
                 documentBuilder.setPropertyDocument(name, values);
             } else if (property.getVectorValuesCount() > 0) {
@@ -218,6 +227,15 @@ public final class GenericDocumentToProtoConverter {
                     values[j] = vectorProtoToEmbeddingVector(property.getVectorValues(j));
                 }
                 documentBuilder.setPropertyEmbedding(name, values);
+            } else if (property.getBlobHandleValuesCount() > 0) {
+                AppSearchBlobHandle[] values =
+                        new AppSearchBlobHandle[property.getBlobHandleValuesCount()];
+                for (int j = 0; j < values.length; j++) {
+                    values[j] =
+                            BlobHandleToProtoConverter.toAppSearchBlobHandle(
+                                    property.getBlobHandleValues(j));
+                }
+                documentBuilder.setPropertyBlobHandle(name, values);
             } else {
                 // TODO(b/184966497): Optimize by caching PropertyConfigProto
                 SchemaTypeConfigProto schema =
@@ -255,68 +273,6 @@ public final class GenericDocumentToProtoConverter {
         return builder.build();
     }
 
-    /**
-     * Get the list of unprefixed parent type names of {@code prefixedSchemaType}.
-     *
-     * <p>It's guaranteed that child types always appear before parent types in the list.
-     */
-    // TODO(b/290389974): Consider caching the result based prefixedSchemaType, and reset the
-    //  cache whenever a new setSchema is called.
-    @NonNull
-    private static List<String> getUnprefixedParentSchemaTypes(
-            @NonNull String prefixedSchemaType,
-            @NonNull Map<String, SchemaTypeConfigProto> schemaTypeMap)
-            throws AppSearchException {
-        // Please note that neither DFS nor BFS order is guaranteed to always put child types
-        // before parent types (due to the diamond problem), so a topological sorting algorithm
-        // is required.
-        Map<String, Integer> inDegreeMap = new ArrayMap<>();
-        collectParentTypeInDegrees(
-                prefixedSchemaType, schemaTypeMap, /* visited= */ new ArraySet<>(), inDegreeMap);
-
-        List<String> result = new ArrayList<>();
-        Queue<String> queue = new ArrayDeque<>();
-        // prefixedSchemaType is the only type that has zero in-degree at this point.
-        queue.add(prefixedSchemaType);
-        while (!queue.isEmpty()) {
-            SchemaTypeConfigProto currentSchema =
-                    Objects.requireNonNull(schemaTypeMap.get(queue.poll()));
-            for (int i = 0; i < currentSchema.getParentTypesCount(); ++i) {
-                String prefixedParentType = currentSchema.getParentTypes(i);
-                int parentInDegree =
-                        Objects.requireNonNull(inDegreeMap.get(prefixedParentType)) - 1;
-                inDegreeMap.put(prefixedParentType, parentInDegree);
-                if (parentInDegree == 0) {
-                    result.add(PrefixUtil.removePrefix(prefixedParentType));
-                    queue.add(prefixedParentType);
-                }
-            }
-        }
-        return result;
-    }
-
-    private static void collectParentTypeInDegrees(
-            @NonNull String prefixedSchemaType,
-            @NonNull Map<String, SchemaTypeConfigProto> schemaTypeMap,
-            @NonNull Set<String> visited,
-            @NonNull Map<String, Integer> inDegreeMap) {
-        if (visited.contains(prefixedSchemaType)) {
-            return;
-        }
-        visited.add(prefixedSchemaType);
-        SchemaTypeConfigProto schema =
-                Objects.requireNonNull(schemaTypeMap.get(prefixedSchemaType));
-        for (int i = 0; i < schema.getParentTypesCount(); ++i) {
-            String prefixedParentType = schema.getParentTypes(i);
-            Integer parentInDegree = inDegreeMap.get(prefixedParentType);
-            if (parentInDegree == null) {
-                parentInDegree = 0;
-            }
-            inDegreeMap.put(prefixedParentType, parentInDegree + 1);
-            collectParentTypeInDegrees(prefixedParentType, schemaTypeMap, visited, inDegreeMap);
-        }
-    }
-
     private static void setEmptyProperty(
             @NonNull String propertyName,
             @NonNull GenericDocument.Builder<?> documentBuilder,
diff --git a/service/java/com/android/server/appsearch/external/localstorage/converter/SchemaToProtoConverter.java b/service/java/com/android/server/appsearch/external/localstorage/converter/SchemaToProtoConverter.java
index 73d39fff..566d734e 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/converter/SchemaToProtoConverter.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/converter/SchemaToProtoConverter.java
@@ -96,6 +96,8 @@ public final class SchemaToProtoConverter {
         if (property instanceof AppSearchSchema.StringPropertyConfig) {
             AppSearchSchema.StringPropertyConfig stringProperty =
                     (AppSearchSchema.StringPropertyConfig) property;
+            // No need to check against delete propagation type vs joinable value type here, because
+            // the builder has already enforced the restriction.
 
             // Set JoinableConfig only if it is joinable (i.e. joinableValueType is not NONE).
             if (stringProperty.getJoinableValueType()
@@ -105,10 +107,12 @@ public final class SchemaToProtoConverter {
                                 .setValueType(
                                         convertJoinableValueTypeToProto(
                                                 stringProperty.getJoinableValueType()))
+                                .setDeletePropagationType(
+                                        convertDeletePropagationTypeToProto(
+                                                stringProperty.getDeletePropagationType()))
                                 .build();
                 builder.setJoinableConfig(joinableConfig);
             }
-
             StringIndexingConfig stringIndexingConfig =
                     StringIndexingConfig.newBuilder()
                             .setTermMatchType(
@@ -117,7 +121,6 @@ public final class SchemaToProtoConverter {
                                     convertTokenizerTypeToProto(stringProperty.getTokenizerType()))
                             .build();
             builder.setStringIndexingConfig(stringIndexingConfig);
-
         } else if (property instanceof AppSearchSchema.DocumentPropertyConfig) {
             AppSearchSchema.DocumentPropertyConfig documentProperty =
                     (AppSearchSchema.DocumentPropertyConfig) property;
@@ -142,6 +145,7 @@ public final class SchemaToProtoConverter {
                                 .build();
                 builder.setIntegerIndexingConfig(integerIndexingConfig);
             }
+            builder.setScorableType(toScorableTypeCode(longProperty.isScoringEnabled()));
         } else if (property instanceof AppSearchSchema.EmbeddingPropertyConfig) {
             AppSearchSchema.EmbeddingPropertyConfig embeddingProperty =
                     (AppSearchSchema.EmbeddingPropertyConfig) property;
@@ -155,9 +159,20 @@ public final class SchemaToProtoConverter {
                                 .setEmbeddingIndexingType(
                                         convertEmbeddingIndexingTypeToProto(
                                                 embeddingProperty.getIndexingType()))
+                                .setQuantizationType(
+                                        convertEmbeddingQuantizationTypeToProto(
+                                                embeddingProperty.getQuantizationType()))
                                 .build();
                 builder.setEmbeddingIndexingConfig(embeddingIndexingConfig);
             }
+        } else if (property instanceof AppSearchSchema.DoublePropertyConfig) {
+            AppSearchSchema.DoublePropertyConfig doubleProperty =
+                    (AppSearchSchema.DoublePropertyConfig) property;
+            builder.setScorableType(toScorableTypeCode(doubleProperty.isScoringEnabled()));
+        } else if (property instanceof AppSearchSchema.BooleanPropertyConfig) {
+            AppSearchSchema.BooleanPropertyConfig booleanProperty =
+                    (AppSearchSchema.BooleanPropertyConfig) property;
+            builder.setScorableType(toScorableTypeCode(booleanProperty.isScoringEnabled()));
         }
         return builder.build();
     }
@@ -197,11 +212,17 @@ public final class SchemaToProtoConverter {
                 return new AppSearchSchema.DoublePropertyConfig.Builder(proto.getPropertyName())
                         .setDescription(proto.getDescription())
                         .setCardinality(proto.getCardinality().getNumber())
+                        .setScoringEnabled(
+                                proto.getScorableType()
+                                        == PropertyConfigProto.ScorableType.Code.ENABLED)
                         .build();
             case BOOLEAN:
                 return new AppSearchSchema.BooleanPropertyConfig.Builder(proto.getPropertyName())
                         .setDescription(proto.getDescription())
                         .setCardinality(proto.getCardinality().getNumber())
+                        .setScoringEnabled(
+                                proto.getScorableType()
+                                        == PropertyConfigProto.ScorableType.Code.ENABLED)
                         .build();
             case BYTES:
                 return new AppSearchSchema.BytesPropertyConfig.Builder(proto.getPropertyName())
@@ -212,6 +233,11 @@ public final class SchemaToProtoConverter {
                 return toDocumentPropertyConfig(proto);
             case VECTOR:
                 return toEmbeddingPropertyConfig(proto);
+            case BLOB_HANDLE:
+                return new AppSearchSchema.BlobHandlePropertyConfig.Builder(proto.getPropertyName())
+                        .setDescription(proto.getDescription())
+                        .setCardinality(proto.getCardinality().getNumber())
+                        .build();
             default:
                 throw new IllegalArgumentException(
                         "Invalid dataType code: " + proto.getDataType().getNumber());
@@ -228,6 +254,9 @@ public final class SchemaToProtoConverter {
                         .setJoinableValueType(
                                 convertJoinableValueTypeFromProto(
                                         proto.getJoinableConfig().getValueType()))
+                        .setDeletePropagationType(
+                                convertDeletePropagationTypeFromProto(
+                                        proto.getJoinableConfig().getDeletePropagationType()))
                         .setTokenizerType(
                                 proto.getStringIndexingConfig().getTokenizerType().getNumber());
 
@@ -259,8 +288,10 @@ public final class SchemaToProtoConverter {
         AppSearchSchema.LongPropertyConfig.Builder builder =
                 new AppSearchSchema.LongPropertyConfig.Builder(proto.getPropertyName())
                         .setDescription(proto.getDescription())
-                        .setCardinality(proto.getCardinality().getNumber());
-
+                        .setCardinality(proto.getCardinality().getNumber())
+                        .setScoringEnabled(
+                                proto.getScorableType()
+                                        == PropertyConfigProto.ScorableType.Code.ENABLED);
         // Set indexingType
         IntegerIndexingConfig.NumericMatchType.Code numericMatchTypeProto =
                 proto.getIntegerIndexingConfig().getNumericMatchType();
@@ -274,6 +305,7 @@ public final class SchemaToProtoConverter {
             @NonNull PropertyConfigProto proto) {
         AppSearchSchema.EmbeddingPropertyConfig.Builder builder =
                 new AppSearchSchema.EmbeddingPropertyConfig.Builder(proto.getPropertyName())
+                        .setDescription(proto.getDescription())
                         .setCardinality(proto.getCardinality().getNumber());
 
         // Set indexingType
@@ -281,6 +313,14 @@ public final class SchemaToProtoConverter {
                 proto.getEmbeddingIndexingConfig().getEmbeddingIndexingType();
         builder.setIndexingType(convertEmbeddingIndexingTypeFromProto(embeddingIndexingType));
 
+        // Set quantizationType
+        if (embeddingIndexingType != EmbeddingIndexingConfig.EmbeddingIndexingType.Code.UNKNOWN) {
+            EmbeddingIndexingConfig.QuantizationType.Code embeddingQuantizationType =
+                    proto.getEmbeddingIndexingConfig().getQuantizationType();
+            builder.setQuantizationType(
+                    convertEmbeddingQuantizationTypeTypeFromProto(embeddingQuantizationType));
+        }
+
         return builder.build();
     }
 
@@ -313,6 +353,35 @@ public final class SchemaToProtoConverter {
         return AppSearchSchema.StringPropertyConfig.JOINABLE_VALUE_TYPE_NONE;
     }
 
+    @NonNull
+    private static JoinableConfig.DeletePropagationType.Code convertDeletePropagationTypeToProto(
+            @AppSearchSchema.StringPropertyConfig.DeletePropagationType int deletePropagationType) {
+        switch (deletePropagationType) {
+            case AppSearchSchema.StringPropertyConfig.DELETE_PROPAGATION_TYPE_NONE:
+                return JoinableConfig.DeletePropagationType.Code.NONE;
+            case AppSearchSchema.StringPropertyConfig.DELETE_PROPAGATION_TYPE_PROPAGATE_FROM:
+                return JoinableConfig.DeletePropagationType.Code.PROPAGATE_FROM;
+            default:
+                throw new IllegalArgumentException(
+                        "Invalid deletePropagationType: " + deletePropagationType);
+        }
+    }
+
+    @AppSearchSchema.StringPropertyConfig.DeletePropagationType
+    private static int convertDeletePropagationTypeFromProto(
+            @NonNull JoinableConfig.DeletePropagationType.Code deletePropagationType) {
+        switch (deletePropagationType) {
+            case NONE:
+                return AppSearchSchema.StringPropertyConfig.DELETE_PROPAGATION_TYPE_NONE;
+            case PROPAGATE_FROM:
+                return AppSearchSchema.StringPropertyConfig.DELETE_PROPAGATION_TYPE_PROPAGATE_FROM;
+        }
+        // Avoid crashing in the 'read' path; we should try to interpret the schema to the
+        // extent possible.
+        Log.w(TAG, "Invalid deletePropagationType: " + deletePropagationType.getNumber());
+        return AppSearchSchema.StringPropertyConfig.DELETE_PROPAGATION_TYPE_NONE;
+    }
+
     @NonNull
     private static TermMatchType.Code convertTermMatchTypeToProto(
             @AppSearchSchema.StringPropertyConfig.IndexingType int indexingType) {
@@ -414,4 +483,44 @@ public final class SchemaToProtoConverter {
                 return AppSearchSchema.EmbeddingPropertyConfig.INDEXING_TYPE_NONE;
         }
     }
+
+    @NonNull
+    private static EmbeddingIndexingConfig.QuantizationType.Code
+            convertEmbeddingQuantizationTypeToProto(
+                    @AppSearchSchema.EmbeddingPropertyConfig.QuantizationType
+                            int quantizationType) {
+        switch (quantizationType) {
+            case AppSearchSchema.EmbeddingPropertyConfig.QUANTIZATION_TYPE_NONE:
+                return EmbeddingIndexingConfig.QuantizationType.Code.NONE;
+            case AppSearchSchema.EmbeddingPropertyConfig.QUANTIZATION_TYPE_8_BIT:
+                return EmbeddingIndexingConfig.QuantizationType.Code.QUANTIZE_8_BIT;
+            default:
+                throw new IllegalArgumentException("Invalid quantizationType: " + quantizationType);
+        }
+    }
+
+    @AppSearchSchema.EmbeddingPropertyConfig.QuantizationType
+    private static int convertEmbeddingQuantizationTypeTypeFromProto(
+            @NonNull EmbeddingIndexingConfig.QuantizationType.Code quantizationType) {
+        switch (quantizationType) {
+            case NONE:
+                return AppSearchSchema.EmbeddingPropertyConfig.QUANTIZATION_TYPE_NONE;
+            case QUANTIZE_8_BIT:
+                return AppSearchSchema.EmbeddingPropertyConfig.QUANTIZATION_TYPE_8_BIT;
+            default:
+                // Avoid crashing in the 'read' path; we should try to interpret the document to the
+                // extent possible.
+                Log.w(TAG, "Invalid quantizationType: " + quantizationType.getNumber());
+                return AppSearchSchema.EmbeddingPropertyConfig.QUANTIZATION_TYPE_NONE;
+        }
+    }
+
+    private static PropertyConfigProto.ScorableType.Code toScorableTypeCode(
+            boolean isScoringEnabled) {
+        if (isScoringEnabled) {
+            return PropertyConfigProto.ScorableType.Code.ENABLED;
+        } else {
+            return PropertyConfigProto.ScorableType.Code.DISABLED;
+        }
+    }
 }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/converter/SearchResultToProtoConverter.java b/service/java/com/android/server/appsearch/external/localstorage/converter/SearchResultToProtoConverter.java
index 53bf2c32..e15b5955 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/converter/SearchResultToProtoConverter.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/converter/SearchResultToProtoConverter.java
@@ -26,12 +26,15 @@ import android.app.appsearch.GenericDocument;
 import android.app.appsearch.SearchResult;
 import android.app.appsearch.SearchResultPage;
 import android.app.appsearch.exceptions.AppSearchException;
+import android.util.ArrayMap;
 
+import com.android.appsearch.flags.Flags;
 import com.android.server.appsearch.external.localstorage.AppSearchConfig;
 import com.android.server.appsearch.external.localstorage.SchemaCache;
 
 import com.google.android.icing.proto.DocumentProto;
-import com.google.android.icing.proto.SchemaTypeConfigProto;
+import com.google.android.icing.proto.DocumentProtoOrBuilder;
+import com.google.android.icing.proto.PropertyProto;
 import com.google.android.icing.proto.SearchResultProto;
 import com.google.android.icing.proto.SnippetMatchProto;
 import com.google.android.icing.proto.SnippetProto;
@@ -87,11 +90,9 @@ public class SearchResultToProtoConverter {
 
         DocumentProto.Builder documentBuilder = proto.getDocument().toBuilder();
         String prefix = removePrefixesFromDocument(documentBuilder);
-        Map<String, SchemaTypeConfigProto> schemaTypeMap =
-                schemaCache.getSchemaMapForPrefix(prefix);
         GenericDocument document =
                 GenericDocumentToProtoConverter.toGenericDocument(
-                        documentBuilder, prefix, schemaTypeMap, config);
+                        documentBuilder, prefix, schemaCache, config);
         SearchResult.Builder builder =
                 new SearchResult.Builder(getPackageName(prefix), getDatabaseName(prefix))
                         .setGenericDocument(document)
@@ -121,9 +122,38 @@ public class SearchResultToProtoConverter {
             builder.addJoinedResult(
                     toUnprefixedSearchResult(joinedResultProto, schemaCache, config));
         }
+        if (config.shouldRetrieveParentInfo() && Flags.enableSearchResultParentTypes()) {
+            Map<String, List<String>> parentTypeMap = new ArrayMap<>();
+            collectParentTypeMap(documentBuilder, prefix, schemaCache, parentTypeMap);
+            builder.setParentTypeMap(parentTypeMap);
+        }
         return builder.build();
     }
 
+    private static void collectParentTypeMap(
+            @NonNull DocumentProtoOrBuilder proto,
+            @NonNull String prefix,
+            @NonNull SchemaCache schemaCache,
+            @NonNull Map<String, List<String>> parentTypeMap)
+            throws AppSearchException {
+        if (!parentTypeMap.containsKey(proto.getSchema())) {
+            List<String> parentSchemaTypes =
+                    schemaCache.getTransitiveUnprefixedParentSchemaTypes(
+                            prefix, prefix + proto.getSchema());
+            if (!parentSchemaTypes.isEmpty()) {
+                parentTypeMap.put(proto.getSchema(), parentSchemaTypes);
+            }
+        }
+        // Handling nested documents
+        for (int i = 0; i < proto.getPropertiesCount(); i++) {
+            PropertyProto property = proto.getProperties(i);
+            for (int j = 0; j < property.getDocumentValuesCount(); j++) {
+                collectParentTypeMap(
+                        property.getDocumentValues(j), prefix, schemaCache, parentTypeMap);
+            }
+        }
+    }
+
     private static SearchResult.MatchInfo toMatchInfo(
             @NonNull SnippetMatchProto snippetMatchProto, @NonNull String propertyPath) {
         int exactMatchPosition = snippetMatchProto.getExactMatchUtf16Position();
diff --git a/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverter.java b/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverter.java
index 531ab721..a30d31fa 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverter.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverter.java
@@ -34,6 +34,7 @@ import android.util.ArraySet;
 import android.util.Log;
 
 import com.android.server.appsearch.external.localstorage.IcingOptionsConfig;
+import com.android.server.appsearch.external.localstorage.NamespaceCache;
 import com.android.server.appsearch.external.localstorage.SchemaCache;
 import com.android.server.appsearch.external.localstorage.visibilitystore.CallerAccess;
 import com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityChecker;
@@ -41,9 +42,12 @@ import com.android.server.appsearch.external.localstorage.visibilitystore.Visibi
 import com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityUtil;
 
 import com.google.android.icing.proto.JoinSpecProto;
+import com.google.android.icing.proto.NamespaceDocumentUriGroup;
 import com.google.android.icing.proto.PropertyWeight;
 import com.google.android.icing.proto.ResultSpecProto;
+import com.google.android.icing.proto.SchemaTypeAliasMapProto;
 import com.google.android.icing.proto.SchemaTypeConfigProto;
+import com.google.android.icing.proto.ScoringFeatureType;
 import com.google.android.icing.proto.ScoringSpecProto;
 import com.google.android.icing.proto.SearchSpecProto;
 import com.google.android.icing.proto.TermMatchType;
@@ -88,11 +92,8 @@ public final class SearchSpecToProtoConverter {
      */
     private final Set<String> mTargetPrefixedSchemaFilters;
 
-    /**
-     * The cached Map of {@code <Prefix, Set<PrefixedNamespace>>} stores all prefixed namespace
-     * filters which are stored in AppSearch. This is a field so that we can generate nested protos.
-     */
-    private final Map<String, Set<String>> mNamespaceMap;
+    /** The NamespaceCache instance held in AppSearch. */
+    private final NamespaceCache mNamespaceCache;
 
     /** The SchemaCache instance held in AppSearch. */
     private final SchemaCache mSchemaCache;
@@ -114,21 +115,20 @@ public final class SearchSpecToProtoConverter {
      * @param allAllowedPrefixes Superset of database prefixes which the {@link SearchSpec} and all
      *     nested SearchSpecs are allowed to access. An empty set means no database prefixes are
      *     allowed, so nothing will be searched.
-     * @param namespaceMap The cached Map of {@code <Prefix, Set<PrefixedNamespace>>} stores all
-     *     prefixed namespace filters which are stored in AppSearch.
+     * @param namespaceCache The NamespaceCache instance held in AppSearch.
      * @param schemaCache The SchemaCache instance held in AppSearch.
      */
     public SearchSpecToProtoConverter(
             @NonNull String queryExpression,
             @NonNull SearchSpec searchSpec,
             @NonNull Set<String> allAllowedPrefixes,
-            @NonNull Map<String, Set<String>> namespaceMap,
+            @NonNull NamespaceCache namespaceCache,
             @NonNull SchemaCache schemaCache,
             @NonNull IcingOptionsConfig icingOptionsConfig) {
         mQueryExpression = Objects.requireNonNull(queryExpression);
         mSearchSpec = Objects.requireNonNull(searchSpec);
         mAllAllowedPrefixes = Objects.requireNonNull(allAllowedPrefixes);
-        mNamespaceMap = Objects.requireNonNull(namespaceMap);
+        mNamespaceCache = Objects.requireNonNull(namespaceCache);
         mSchemaCache = Objects.requireNonNull(schemaCache);
         mIcingOptionsConfig = Objects.requireNonNull(icingOptionsConfig);
 
@@ -157,7 +157,7 @@ public final class SearchSpecToProtoConverter {
         mTargetPrefixedNamespaceFilters =
                 SearchSpecToProtoConverterUtil.generateTargetNamespaceFilters(
                         mCurrentSearchSpecPrefixFilters,
-                        namespaceMap,
+                        namespaceCache,
                         searchSpec.getFilterNamespaces());
 
         // If the target namespace filter is empty, the user has nothing to search for. We can skip
@@ -182,7 +182,7 @@ public final class SearchSpecToProtoConverter {
                         joinSpec.getNestedQuery(),
                         joinSpec.getNestedSearchSpec(),
                         mAllAllowedPrefixes,
-                        namespaceMap,
+                        namespaceCache,
                         schemaCache,
                         mIcingOptionsConfig);
     }
@@ -319,6 +319,18 @@ public final class SearchSpecToProtoConverter {
             }
         }
 
+        // Convert document id filters.
+        List<String> filterDocumentIds = mSearchSpec.getFilterDocumentIds();
+        if (!filterDocumentIds.isEmpty()) {
+            for (String targetPrefixedNamespaceFilter : mTargetPrefixedNamespaceFilters) {
+                protoBuilder.addDocumentUriFilters(
+                        NamespaceDocumentUriGroup.newBuilder()
+                                .setNamespace(targetPrefixedNamespaceFilter)
+                                .addAllDocumentUris(filterDocumentIds)
+                                .build());
+            }
+        }
+
         @SearchSpec.TermMatch int termMatchCode = mSearchSpec.getTermMatch();
         TermMatchType.Code termMatchCodeProto = TermMatchType.Code.forNumber(termMatchCode);
         if (termMatchCodeProto == null || termMatchCodeProto.equals(TermMatchType.Code.UNKNOWN)) {
@@ -342,7 +354,8 @@ public final class SearchSpecToProtoConverter {
             JoinSpecProto.NestedSpecProto nestedSpec =
                     JoinSpecProto.NestedSpecProto.newBuilder()
                             .setResultSpec(
-                                    mNestedConverter.toResultSpecProto(mNamespaceMap, mSchemaCache))
+                                    mNestedConverter.toResultSpecProto(
+                                            mNamespaceCache, mSchemaCache))
                             .setScoringSpec(mNestedConverter.toScoringSpecProto())
                             .setSearchSpec(mNestedConverter.toSearchSpecProto())
                             .build();
@@ -371,8 +384,10 @@ public final class SearchSpecToProtoConverter {
                             + "associated metadata has not yet been turned on.");
         }
 
-        // Set enabled features
-        protoBuilder.addAllEnabledFeatures(toIcingSearchFeatures(mSearchSpec.getEnabledFeatures()));
+        // Set enabled search features.
+        protoBuilder.addAllEnabledFeatures(
+                toIcingSearchFeatures(
+                        extractEnabledSearchFeatures(mSearchSpec.getEnabledFeatures())));
 
         return protoBuilder.build();
     }
@@ -407,13 +422,12 @@ public final class SearchSpecToProtoConverter {
     /**
      * Extracts {@link ResultSpecProto} information from a {@link SearchSpec}.
      *
-     * @param namespaceMap The cached Map of {@code <Prefix, Set<PrefixedNamespace>>} stores all
-     *     existing prefixed namespace.
+     * @param namespaceCache The NamespaceCache instance held in AppSearch.
      * @param schemaCache The SchemaCache instance held in AppSearch.
      */
     @NonNull
     public ResultSpecProto toResultSpecProto(
-            @NonNull Map<String, Set<String>> namespaceMap, @NonNull SchemaCache schemaCache) {
+            @NonNull NamespaceCache namespaceCache, @NonNull SchemaCache schemaCache) {
         ResultSpecProto.Builder resultSpecBuilder =
                 ResultSpecProto.newBuilder()
                         .setNumPerPage(mSearchSpec.getResultCountPerPage())
@@ -440,7 +454,7 @@ public final class SearchSpecToProtoConverter {
                 addPerPackageResultGroupings(
                         mCurrentSearchSpecPrefixFilters,
                         mSearchSpec.getResultGroupingLimit(),
-                        namespaceMap,
+                        namespaceCache,
                         resultSpecBuilder);
                 resultGroupingType = ResultSpecProto.ResultGroupingType.NAMESPACE;
                 break;
@@ -448,7 +462,7 @@ public final class SearchSpecToProtoConverter {
                 addPerNamespaceResultGroupings(
                         mCurrentSearchSpecPrefixFilters,
                         mSearchSpec.getResultGroupingLimit(),
-                        namespaceMap,
+                        namespaceCache,
                         resultSpecBuilder);
                 resultGroupingType = ResultSpecProto.ResultGroupingType.NAMESPACE;
                 break;
@@ -464,7 +478,7 @@ public final class SearchSpecToProtoConverter {
                 addPerPackagePerNamespaceResultGroupings(
                         mCurrentSearchSpecPrefixFilters,
                         mSearchSpec.getResultGroupingLimit(),
-                        namespaceMap,
+                        namespaceCache,
                         resultSpecBuilder);
                 resultGroupingType = ResultSpecProto.ResultGroupingType.NAMESPACE;
                 break;
@@ -480,7 +494,7 @@ public final class SearchSpecToProtoConverter {
                 addPerNamespaceAndSchemaResultGrouping(
                         mCurrentSearchSpecPrefixFilters,
                         mSearchSpec.getResultGroupingLimit(),
-                        namespaceMap,
+                        namespaceCache,
                         schemaCache,
                         resultSpecBuilder);
                 resultGroupingType = ResultSpecProto.ResultGroupingType.NAMESPACE_AND_SCHEMA_TYPE;
@@ -491,7 +505,7 @@ public final class SearchSpecToProtoConverter {
                 addPerPackagePerNamespacePerSchemaResultGrouping(
                         mCurrentSearchSpecPrefixFilters,
                         mSearchSpec.getResultGroupingLimit(),
-                        namespaceMap,
+                        namespaceCache,
                         schemaCache,
                         resultSpecBuilder);
                 resultGroupingType = ResultSpecProto.ResultGroupingType.NAMESPACE_AND_SCHEMA_TYPE;
@@ -548,6 +562,22 @@ public final class SearchSpecToProtoConverter {
         protoBuilder.addAllAdditionalAdvancedScoringExpressions(
                 mSearchSpec.getInformationalRankingExpressions());
 
+        // TODO(b/380924970): create extractEnabledScoringFeatures() for populating scorable
+        // features
+        if (mSearchSpec.isScorablePropertyRankingEnabled()) {
+            protoBuilder.addScoringFeatureTypesEnabled(
+                    ScoringFeatureType.SCORABLE_PROPERTY_RANKING);
+            Map<String, Set<String>> schemaToPrefixedSchemasMap =
+                    createSchemaToPrefixedSchemasMap(mTargetPrefixedSchemaFilters);
+            for (Map.Entry<String, Set<String>> entry : schemaToPrefixedSchemasMap.entrySet()) {
+                SchemaTypeAliasMapProto.Builder schemaTypeAliasMapProto =
+                        SchemaTypeAliasMapProto.newBuilder();
+                schemaTypeAliasMapProto.setAliasSchemaType(entry.getKey());
+                schemaTypeAliasMapProto.addAllSchemaTypes(entry.getValue());
+                protoBuilder.addSchemaTypeAliasMapProtos(schemaTypeAliasMapProto);
+            }
+        }
+
         return protoBuilder.build();
     }
 
@@ -593,6 +623,9 @@ public final class SearchSpecToProtoConverter {
             String appSearchFeature = appSearchFeatures.get(i);
             if (appSearchFeature.equals(FeatureConstants.LIST_FILTER_HAS_PROPERTY_FUNCTION)) {
                 result.add("HAS_PROPERTY_FUNCTION");
+            } else if (appSearchFeature.equals(
+                    FeatureConstants.LIST_FILTER_MATCH_SCORE_EXPRESSION_FUNCTION)) {
+                result.add("MATCH_SCORE_EXPRESSION_FUNCTION");
             } else {
                 result.add(appSearchFeature);
             }
@@ -606,13 +639,13 @@ public final class SearchSpecToProtoConverter {
      * databases, they should still be grouped together.
      *
      * @param prefixes Prefixes that we should prepend to all our filters.
-     * @param namespaceMap The namespace map contains all prefixed existing namespaces.
+     * @param namespaceCache The NamespaceCache instance held in AppSearch.
      */
     private static Map<String, List<String>> getNamespaceToPrefixedNamespaces(
-            @NonNull Set<String> prefixes, @NonNull Map<String, Set<String>> namespaceMap) {
+            @NonNull Set<String> prefixes, @NonNull NamespaceCache namespaceCache) {
         Map<String, List<String>> namespaceToPrefixedNamespaces = new ArrayMap<>();
         for (String prefix : prefixes) {
-            Set<String> prefixedNamespaces = namespaceMap.get(prefix);
+            Set<String> prefixedNamespaces = namespaceCache.getPrefixedDocumentNamespaces(prefix);
             if (prefixedNamespaces == null) {
                 continue;
             }
@@ -643,13 +676,13 @@ public final class SearchSpecToProtoConverter {
      * namespace, then those should be grouped together.
      *
      * @param prefixes Prefixes that we should prepend to all our filters.
-     * @param namespaceMap The namespace map contains all prefixed existing namespaces.
+     * @param namespaceCache The NamespaceCache instance held in AppSearch.
      */
     private static Map<String, List<String>> getPackageAndNamespaceToPrefixedNamespaces(
-            @NonNull Set<String> prefixes, @NonNull Map<String, Set<String>> namespaceMap) {
+            @NonNull Set<String> prefixes, @NonNull NamespaceCache namespaceCache) {
         Map<String, List<String>> packageAndNamespaceToNamespaces = new ArrayMap<>();
         for (String prefix : prefixes) {
-            Set<String> prefixedNamespaces = namespaceMap.get(prefix);
+            Set<String> prefixedNamespaces = namespaceCache.getPrefixedDocumentNamespaces(prefix);
             if (prefixedNamespaces == null) {
                 continue;
             }
@@ -714,6 +747,35 @@ public final class SearchSpecToProtoConverter {
         return schemaToPrefixedSchemas;
     }
 
+    /**
+     * Returns a map of schema to a set of prefixedSchemas, grouped by ending schema string.
+     *
+     * <p>For example, an input of { "package1$database1/gmail", "package1$database2/gmail",
+     * "package1$database1/person", "package1$database2/person"} will return an output of: {
+     * "gmail": {"package1$database1/gmail", "package1$database2/gmail"}, "person":
+     * {"package1$database1/person", "package1$database2/person"}, }
+     */
+    private Map<String, Set<String>> createSchemaToPrefixedSchemasMap(Set<String> prefixedSchemas) {
+        Map<String, Set<String>> schemasToPrefixedSchemas = new ArrayMap<>();
+        for (String prefixedSchema : prefixedSchemas) {
+            String schema;
+            try {
+                schema = removePrefix(prefixedSchema);
+            } catch (AppSearchException e) {
+                // This should never happen. Skip this schema if it does.
+                Log.e(TAG, "Prefixed schema " + prefixedSchema + " is malformed.");
+                continue;
+            }
+            Set<String> prefixedSchemaSet = schemasToPrefixedSchemas.get(schema);
+            if (prefixedSchemaSet == null) {
+                prefixedSchemaSet = new ArraySet<>();
+                schemasToPrefixedSchemas.put(schema, prefixedSchemaSet);
+            }
+            prefixedSchemaSet.add(prefixedSchema);
+        }
+        return schemasToPrefixedSchemas;
+    }
+
     /**
      * Returns a map for package+schema to prefixedSchemas. This is NOT necessarily the same as the
      * list of schemas. If one package has multiple databases, each with the same schema, then those
@@ -759,16 +821,16 @@ public final class SearchSpecToProtoConverter {
      *
      * @param prefixes Prefixes that we should prepend to all our filters
      * @param maxNumResults The maximum number of results for each grouping to support.
-     * @param namespaceMap The namespace map contains all prefixed existing namespaces.
+     * @param namespaceCache The NamespaceCache instance held in AppSearch.
      * @param resultSpecBuilder ResultSpecs as specified by client
      */
     private static void addPerPackagePerNamespaceResultGroupings(
             @NonNull Set<String> prefixes,
             int maxNumResults,
-            @NonNull Map<String, Set<String>> namespaceMap,
+            @NonNull NamespaceCache namespaceCache,
             @NonNull ResultSpecProto.Builder resultSpecBuilder) {
         Map<String, List<String>> packageAndNamespaceToNamespaces =
-                getPackageAndNamespaceToPrefixedNamespaces(prefixes, namespaceMap);
+                getPackageAndNamespaceToPrefixedNamespaces(prefixes, namespaceCache);
 
         for (List<String> prefixedNamespaces : packageAndNamespaceToNamespaces.values()) {
             List<ResultSpecProto.ResultGrouping.Entry> entries =
@@ -823,18 +885,18 @@ public final class SearchSpecToProtoConverter {
      *
      * @param prefixes Prefixes that we should prepend to all our filters.
      * @param maxNumResults The maximum number of results for each grouping to support.
-     * @param namespaceMap The namespace map contains all prefixed existing namespaces.
+     * @param namespaceCache The NamespaceCache instance held in AppSearch.
      * @param schemaCache The SchemaCache instance held in AppSearch.
      * @param resultSpecBuilder ResultSpec as specified by client.
      */
     private static void addPerPackagePerNamespacePerSchemaResultGrouping(
             @NonNull Set<String> prefixes,
             int maxNumResults,
-            @NonNull Map<String, Set<String>> namespaceMap,
+            @NonNull NamespaceCache namespaceCache,
             @NonNull SchemaCache schemaCache,
             @NonNull ResultSpecProto.Builder resultSpecBuilder) {
         Map<String, List<String>> packageAndNamespaceToNamespaces =
-                getPackageAndNamespaceToPrefixedNamespaces(prefixes, namespaceMap);
+                getPackageAndNamespaceToPrefixedNamespaces(prefixes, namespaceCache);
         Map<String, List<String>> packageAndSchemaToSchemas =
                 getPackageAndSchemaToPrefixedSchemas(prefixes, schemaCache);
 
@@ -872,18 +934,18 @@ public final class SearchSpecToProtoConverter {
      *
      * @param prefixes Prefixes that we should prepend to all our filters
      * @param maxNumResults The maximum number of results for each grouping to support.
-     * @param namespaceMap The namespace map contains all prefixed existing namespaces.
+     * @param namespaceCache The NamespaceCache instance held in AppSearch.
      * @param resultSpecBuilder ResultSpecs as specified by client
      */
     private static void addPerPackageResultGroupings(
             @NonNull Set<String> prefixes,
             int maxNumResults,
-            @NonNull Map<String, Set<String>> namespaceMap,
+            @NonNull NamespaceCache namespaceCache,
             @NonNull ResultSpecProto.Builder resultSpecBuilder) {
         // Build up a map of package to namespaces.
         Map<String, List<String>> packageToNamespacesMap = new ArrayMap<>();
         for (String prefix : prefixes) {
-            Set<String> prefixedNamespaces = namespaceMap.get(prefix);
+            Set<String> prefixedNamespaces = namespaceCache.getPrefixedDocumentNamespaces(prefix);
             if (prefixedNamespaces == null) {
                 continue;
             }
@@ -917,16 +979,16 @@ public final class SearchSpecToProtoConverter {
      *
      * @param prefixes Prefixes that we should prepend to all our filters
      * @param maxNumResults The maximum number of results for each grouping to support.
-     * @param namespaceMap The namespace map contains all prefixed existing namespaces.
+     * @param namespaceCache The NamespaceCache instance held in AppSearch.
      * @param resultSpecBuilder ResultSpecs as specified by client
      */
     private static void addPerNamespaceResultGroupings(
             @NonNull Set<String> prefixes,
             int maxNumResults,
-            @NonNull Map<String, Set<String>> namespaceMap,
+            @NonNull NamespaceCache namespaceCache,
             @NonNull ResultSpecProto.Builder resultSpecBuilder) {
         Map<String, List<String>> namespaceToPrefixedNamespaces =
-                getNamespaceToPrefixedNamespaces(prefixes, namespaceMap);
+                getNamespaceToPrefixedNamespaces(prefixes, namespaceCache);
 
         for (List<String> prefixedNamespaces : namespaceToPrefixedNamespaces.values()) {
             List<ResultSpecProto.ResultGrouping.Entry> entries =
@@ -981,18 +1043,18 @@ public final class SearchSpecToProtoConverter {
      *
      * @param prefixes Prefixes that we should prepend to all our filters.
      * @param maxNumResults The maximum number of results for each grouping to support.
-     * @param namespaceMap The namespace map contains all prefixed existing namespaces.
+     * @param namespaceCache The NamespaceCache instance held in AppSearch.
      * @param schemaCache The SchemaCache instance held in AppSearch.
      * @param resultSpecBuilder ResultSpec as specified by client.
      */
     private static void addPerNamespaceAndSchemaResultGrouping(
             @NonNull Set<String> prefixes,
             int maxNumResults,
-            @NonNull Map<String, Set<String>> namespaceMap,
+            @NonNull NamespaceCache namespaceCache,
             @NonNull SchemaCache schemaCache,
             @NonNull ResultSpecProto.Builder resultSpecBuilder) {
         Map<String, List<String>> namespaceToPrefixedNamespaces =
-                getNamespaceToPrefixedNamespaces(prefixes, namespaceMap);
+                getNamespaceToPrefixedNamespaces(prefixes, namespaceCache);
         Map<String, List<String>> schemaToPrefixedSchemas =
                 getSchemaToPrefixedSchemas(prefixes, schemaCache);
 
@@ -1073,4 +1135,24 @@ public final class SearchSpecToProtoConverter {
             }
         }
     }
+
+    List<String> extractEnabledSearchFeatures(List<String> allEnabledFeatures) {
+        List<String> searchFeatures = new ArrayList<>();
+        for (int i = 0; i < allEnabledFeatures.size(); ++i) {
+            String feature = allEnabledFeatures.get(i);
+            if (FeatureConstants.SCORABLE_FEATURE_SET.contains(feature)) {
+                // The `allEnabledFeatures` set contains both scorable features and search features.
+                // Here, we extract the search related features and populate them to
+                // `SearchSpecProto`. The scoring related features are later populated to the
+                // `ScoringSpecProto` individually in `toScoringSpecProto()`.
+                // - This is because in Icing, the search expression and scoring expression are
+                //   parsed separately, and the enforcement of these enabled features are separate.
+                //   Icing needs the two different proto messages to distinguish between
+                //   features in the search expression and features in the scoring expression.
+                continue;
+            }
+            searchFeatures.add(feature);
+        }
+        return searchFeatures;
+    }
 }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverterUtil.java b/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverterUtil.java
index 80af25da..f9be7b88 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverterUtil.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverterUtil.java
@@ -19,6 +19,7 @@ package com.android.server.appsearch.external.localstorage.converter;
 import android.annotation.NonNull;
 import android.util.ArraySet;
 
+import com.android.server.appsearch.external.localstorage.NamespaceCache;
 import com.android.server.appsearch.external.localstorage.SchemaCache;
 
 import com.google.android.icing.proto.SchemaTypeConfigProto;
@@ -41,21 +42,21 @@ public class SearchSpecToProtoConverterUtil {
      * intersection set with those prefixed namespace candidates that are stored in AppSearch.
      *
      * @param prefixes Set of database prefix which the caller want to access.
-     * @param namespaceMap The cached Map of {@code <Prefix, Set<PrefixedNamespace>>} stores all
-     *     prefixed namespace filters which are stored in AppSearch.
+     * @param namespaceCache The NamespaceCache instance held in AppSearch.
      * @param inputNamespaceFilters The set contains all desired but un-prefixed namespace filters
      *     of user. If the inputNamespaceFilters is empty, all existing prefixedCandidates will be
      *     added to the prefixedTargetFilters.
      */
     static Set<String> generateTargetNamespaceFilters(
             @NonNull Set<String> prefixes,
-            @NonNull Map<String, Set<String>> namespaceMap,
+            @NonNull NamespaceCache namespaceCache,
             @NonNull List<String> inputNamespaceFilters) {
         // Convert namespace filters to prefixed namespace filters
         Set<String> targetPrefixedNamespaceFilters = new ArraySet<>();
         for (String prefix : prefixes) {
             // Step1: find all prefixed namespace candidates that are stored in AppSearch.
-            Set<String> prefixedNamespaceCandidates = namespaceMap.get(prefix);
+            Set<String> prefixedNamespaceCandidates =
+                    namespaceCache.getPrefixedDocumentNamespaces(prefix);
             if (prefixedNamespaceCandidates == null) {
                 // This is should never happen. All prefixes should be verified before reach
                 // here.
diff --git a/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSuggestionSpecToProtoConverter.java b/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSuggestionSpecToProtoConverter.java
index bddabb44..84892db5 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSuggestionSpecToProtoConverter.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/converter/SearchSuggestionSpecToProtoConverter.java
@@ -19,6 +19,7 @@ package com.android.server.appsearch.external.localstorage.converter;
 import android.annotation.NonNull;
 import android.app.appsearch.SearchSuggestionSpec;
 
+import com.android.server.appsearch.external.localstorage.NamespaceCache;
 import com.android.server.appsearch.external.localstorage.SchemaCache;
 
 import com.google.android.icing.proto.NamespaceDocumentUriGroup;
@@ -66,22 +67,21 @@ public final class SearchSuggestionSpecToProtoConverter {
      * @param suggestionQueryExpression The non-empty query expression used to be completed.
      * @param searchSuggestionSpec The spec we need to convert from.
      * @param prefixes Set of database prefix which the caller want to access.
-     * @param namespaceMap The cached Map of {@code <Prefix, Set<PrefixedNamespace>>} stores all
-     *     prefixed namespace filters which are stored in AppSearch.
+     * @param namespaceCache The NamespaceCache instance held in AppSearch.
      */
     public SearchSuggestionSpecToProtoConverter(
             @NonNull String suggestionQueryExpression,
             @NonNull SearchSuggestionSpec searchSuggestionSpec,
             @NonNull Set<String> prefixes,
-            @NonNull Map<String, Set<String>> namespaceMap,
+            @NonNull NamespaceCache namespaceCache,
             @NonNull SchemaCache schemaCache) {
         mSuggestionQueryExpression = Objects.requireNonNull(suggestionQueryExpression);
         mSearchSuggestionSpec = Objects.requireNonNull(searchSuggestionSpec);
         mPrefixes = Objects.requireNonNull(prefixes);
-        Objects.requireNonNull(namespaceMap);
+        Objects.requireNonNull(namespaceCache);
         mTargetPrefixedNamespaceFilters =
                 SearchSpecToProtoConverterUtil.generateTargetNamespaceFilters(
-                        prefixes, namespaceMap, searchSuggestionSpec.getFilterNamespaces());
+                        prefixes, namespaceCache, searchSuggestionSpec.getFilterNamespaces());
         mTargetPrefixedSchemaFilters =
                 SearchSpecToProtoConverterUtil.generateTargetSchemaFilters(
                         prefixes, schemaCache, searchSuggestionSpec.getFilterSchemas());
diff --git a/service/java/com/android/server/appsearch/external/localstorage/stats/CallStats.java b/service/java/com/android/server/appsearch/external/localstorage/stats/CallStats.java
index 30a482c9..c010d5ab 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/stats/CallStats.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/stats/CallStats.java
@@ -78,7 +78,13 @@ public class CallStats {
                 CALL_TYPE_REGISTER_OBSERVER_CALLBACK,
                 CALL_TYPE_UNREGISTER_OBSERVER_CALLBACK,
                 CALL_TYPE_GLOBAL_GET_NEXT_PAGE,
-                CALL_TYPE_EXECUTE_APP_FUNCTION
+                CALL_TYPE_EXECUTE_APP_FUNCTION,
+                CALL_TYPE_OPEN_WRITE_BLOB,
+                CALL_TYPE_COMMIT_BLOB,
+                CALL_TYPE_OPEN_READ_BLOB,
+                CALL_TYPE_GLOBAL_OPEN_READ_BLOB,
+                CALL_TYPE_REMOVE_BLOB,
+                CALL_TYPE_SET_BLOB_VISIBILITY
             })
     @Retention(RetentionPolicy.SOURCE)
     public @interface CallType {}
@@ -115,6 +121,12 @@ public class CallStats {
     public static final int CALL_TYPE_UNREGISTER_OBSERVER_CALLBACK = 29;
     public static final int CALL_TYPE_GLOBAL_GET_NEXT_PAGE = 30;
     public static final int CALL_TYPE_EXECUTE_APP_FUNCTION = 31;
+    public static final int CALL_TYPE_OPEN_WRITE_BLOB = 32;
+    public static final int CALL_TYPE_COMMIT_BLOB = 33;
+    public static final int CALL_TYPE_OPEN_READ_BLOB = 34;
+    public static final int CALL_TYPE_GLOBAL_OPEN_READ_BLOB = 35;
+    public static final int CALL_TYPE_REMOVE_BLOB = 36;
+    public static final int CALL_TYPE_SET_BLOB_VISIBILITY = 37;
 
     // These strings are for the subset of call types that correspond to an AppSearchManager API
     private static final String CALL_TYPE_STRING_INITIALIZE = "initialize";
@@ -147,6 +159,12 @@ public class CallStats {
             "globalUnregisterObserverCallback";
     private static final String CALL_TYPE_STRING_GLOBAL_GET_NEXT_PAGE = "globalGetNextPage";
     private static final String CALL_TYPE_STRING_EXECUTE_APP_FUNCTION = "executeAppFunction";
+    private static final String CALL_TYPE_STRING_OPEN_WRITE_BLOB = "openWriteBlob";
+    private static final String CALL_TYPE_STRING_COMMIT_BLOB = "commitBlob";
+    private static final String CALL_TYPE_STRING_OPEN_READ_BLOB = "openReadBlob";
+    private static final String CALL_TYPE_STRING_GLOBAL_OPEN_READ_BLOB = "globalOpenReadBlob";
+    private static final String CALL_TYPE_STRING_REMOVE_BLOB = "removeBlob";
+    private static final String CALL_TYPE_STRING_SET_BLOB_VISIBILITY = "setBlobVisibility";
 
     @Nullable private final String mPackageName;
     @Nullable private final String mDatabase;
@@ -399,6 +417,18 @@ public class CallStats {
                 return CALL_TYPE_GLOBAL_GET_NEXT_PAGE;
             case CALL_TYPE_STRING_EXECUTE_APP_FUNCTION:
                 return CALL_TYPE_EXECUTE_APP_FUNCTION;
+            case CALL_TYPE_STRING_OPEN_WRITE_BLOB:
+                return CALL_TYPE_OPEN_WRITE_BLOB;
+            case CALL_TYPE_STRING_COMMIT_BLOB:
+                return CALL_TYPE_COMMIT_BLOB;
+            case CALL_TYPE_STRING_OPEN_READ_BLOB:
+                return CALL_TYPE_OPEN_READ_BLOB;
+            case CALL_TYPE_STRING_GLOBAL_OPEN_READ_BLOB:
+                return CALL_TYPE_GLOBAL_OPEN_READ_BLOB;
+            case CALL_TYPE_STRING_REMOVE_BLOB:
+                return CALL_TYPE_REMOVE_BLOB;
+            case CALL_TYPE_STRING_SET_BLOB_VISIBILITY:
+                return CALL_TYPE_SET_BLOB_VISIBILITY;
             default:
                 return CALL_TYPE_UNKNOWN;
         }
@@ -434,6 +464,12 @@ public class CallStats {
                         CALL_TYPE_REGISTER_OBSERVER_CALLBACK,
                         CALL_TYPE_UNREGISTER_OBSERVER_CALLBACK,
                         CALL_TYPE_GLOBAL_GET_NEXT_PAGE,
-                        CALL_TYPE_EXECUTE_APP_FUNCTION));
+                        CALL_TYPE_EXECUTE_APP_FUNCTION,
+                        CALL_TYPE_OPEN_WRITE_BLOB,
+                        CALL_TYPE_COMMIT_BLOB,
+                        CALL_TYPE_OPEN_READ_BLOB,
+                        CALL_TYPE_GLOBAL_OPEN_READ_BLOB,
+                        CALL_TYPE_REMOVE_BLOB,
+                        CALL_TYPE_SET_BLOB_VISIBILITY));
     }
 }
diff --git a/service/java/com/android/server/appsearch/external/localstorage/util/MapUtil.java b/service/java/com/android/server/appsearch/external/localstorage/util/MapUtil.java
new file mode 100644
index 00000000..e524673c
--- /dev/null
+++ b/service/java/com/android/server/appsearch/external/localstorage/util/MapUtil.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.external.localstorage.util;
+
+import android.annotation.NonNull;
+
+import java.util.Map;
+
+/**
+ * A utility class to avoid the clutter of checking whether or not {@link Map#getOrDefault} is
+ * available.
+ *
+ * @hide
+ */
+public final class MapUtil {
+    private MapUtil() {}
+
+    /**
+     * @return the value in map for key, or defaultValue if key is not present in map.
+     */
+    public static <K, V> V getOrDefault(@NonNull Map<K, V> map, K key, V defaultValue) {
+        V value = map.get(key);
+        return (value != null) ? value : defaultValue;
+    }
+}
diff --git a/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStore.java b/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStore.java
index 8b8b1b5f..496b00ba 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStore.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStore.java
@@ -70,8 +70,11 @@ public class VisibilityStore {
      */
     public static final String VISIBILITY_PACKAGE_NAME = "VS#Pkg";
 
-    public static final String VISIBILITY_DATABASE_NAME = "VS#Db";
-    public static final String ANDROID_V_OVERLAY_DATABASE_NAME = "VS#AndroidVDb";
+    public static final String DOCUMENT_VISIBILITY_DATABASE_NAME = "VS#Db";
+    public static final String DOCUMENT_ANDROID_V_OVERLAY_DATABASE_NAME = "VS#AndroidVDb";
+
+    public static final String BLOB_VISIBILITY_DATABASE_NAME = "VSBlob#Db";
+    public static final String BLOB_ANDROID_V_OVERLAY_DATABASE_NAME = "VSBlob#AndroidVDb";
 
     /**
      * Map of PrefixedSchemaType to InternalVisibilityConfig stores visibility information for each
@@ -80,14 +83,67 @@ public class VisibilityStore {
     private final Map<String, InternalVisibilityConfig> mVisibilityConfigMap = new ArrayMap<>();
 
     private final AppSearchImpl mAppSearchImpl;
+    private final String mDatabaseName;
+    private final String mAndroidVOverlayDatabaseName;
+
+    /** Create a {@link VisibilityStore} instance to store document visibility settings. */
+    @NonNull
+    public static VisibilityStore createDocumentVisibilityStore(
+            @NonNull AppSearchImpl appSearchImpl) throws AppSearchException {
+        List<String> cachedSchemaTypes = appSearchImpl.getAllPrefixedSchemaTypes();
+        return new VisibilityStore(
+                appSearchImpl,
+                DOCUMENT_VISIBILITY_DATABASE_NAME,
+                DOCUMENT_ANDROID_V_OVERLAY_DATABASE_NAME,
+                cachedSchemaTypes);
+    }
 
-    public VisibilityStore(@NonNull AppSearchImpl appSearchImpl) throws AppSearchException {
+    /** Create a {@link VisibilityStore} instance to store blob visibility settings. */
+    @NonNull
+    public static VisibilityStore createBlobVisibilityStore(@NonNull AppSearchImpl appSearchImpl)
+            throws AppSearchException {
+        List<String> cachedBlobNamespaces = appSearchImpl.getAllPrefixedBlobNamespaces();
+        return new VisibilityStore(
+                appSearchImpl,
+                BLOB_VISIBILITY_DATABASE_NAME,
+                BLOB_ANDROID_V_OVERLAY_DATABASE_NAME,
+                cachedBlobNamespaces);
+    }
+
+    /**
+     * Create a {@link VisibilityStore} instance to store visibility settings for given database.
+     *
+     * <p>We have 2 types of {@link VisibilityStore}, will base on the given database names to
+     * create the specific {@link VisibilityStore}.
+     *
+     * <p>To create a {@link VisibilityStore} to store document visibility settings, use {@link
+     * #DOCUMENT_VISIBILITY_DATABASE_NAME} and {@link #DOCUMENT_ANDROID_V_OVERLAY_DATABASE_NAME}.
+     *
+     * <p>To create a {@link VisibilityStore} to store blob visibility settings, use {@link
+     * #BLOB_VISIBILITY_DATABASE_NAME} and {@link #BLOB_ANDROID_V_OVERLAY_DATABASE_NAME}.
+     *
+     * @param appSearchImpl The {@link AppSearchImpl} instance to use to store visibility settings.
+     * @param databaseName The database name to store visibility settings.
+     * @param androidVOverlayDatabaseName The database name to store Android V overlay visibility
+     *     settings.
+     * @param allVisibilityDocumentIds The list of all visibility document ids stored in the given
+     *     database.
+     * @throws AppSearchException On internal error.
+     */
+    private VisibilityStore(
+            @NonNull AppSearchImpl appSearchImpl,
+            @NonNull String databaseName,
+            @NonNull String androidVOverlayDatabaseName,
+            @NonNull List<String> allVisibilityDocumentIds)
+            throws AppSearchException {
         mAppSearchImpl = Objects.requireNonNull(appSearchImpl);
+        mDatabaseName = Objects.requireNonNull(databaseName);
+        mAndroidVOverlayDatabaseName = Objects.requireNonNull(androidVOverlayDatabaseName);
 
         GetSchemaResponse getSchemaResponse =
                 mAppSearchImpl.getSchema(
                         VISIBILITY_PACKAGE_NAME,
-                        VISIBILITY_DATABASE_NAME,
+                        mDatabaseName,
                         new CallerAccess(/* callingPackageName= */ VISIBILITY_PACKAGE_NAME));
         List<VisibilityDocumentV1> visibilityDocumentsV1s = null;
         switch (getSchemaResponse.getVersion()) {
@@ -118,7 +174,7 @@ public class VisibilityStore {
                 // Check the version for visibility overlay database.
                 migrateVisibilityOverlayDatabase();
                 // Now we have the latest schema, load visibility config map.
-                loadVisibilityConfigMap();
+                loadVisibilityConfigMap(allVisibilityDocumentIds);
                 break;
             default:
                 // We must did something wrong.
@@ -149,7 +205,7 @@ public class VisibilityStore {
                     mVisibilityConfigMap.get(prefixedVisibilityConfig.getSchemaType());
             mAppSearchImpl.putDocument(
                     VISIBILITY_PACKAGE_NAME,
-                    VISIBILITY_DATABASE_NAME,
+                    mDatabaseName,
                     VisibilityToDocumentConverter.createVisibilityDocument(
                             prefixedVisibilityConfig),
                     /* sendChangeNotifications= */ false,
@@ -161,7 +217,7 @@ public class VisibilityStore {
             if (androidVOverlay != null) {
                 mAppSearchImpl.putDocument(
                         VISIBILITY_PACKAGE_NAME,
-                        ANDROID_V_OVERLAY_DATABASE_NAME,
+                        mAndroidVOverlayDatabaseName,
                         androidVOverlay,
                         /* sendChangeNotifications= */ false,
                         /* logger= */ null);
@@ -173,7 +229,7 @@ public class VisibilityStore {
                 try {
                     mAppSearchImpl.remove(
                             VISIBILITY_PACKAGE_NAME,
-                            ANDROID_V_OVERLAY_DATABASE_NAME,
+                            mAndroidVOverlayDatabaseName,
                             VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE,
                             prefixedVisibilityConfig.getSchemaType(),
                             /* removeStatsBuilder= */ null);
@@ -206,7 +262,7 @@ public class VisibilityStore {
                 try {
                     mAppSearchImpl.remove(
                             VISIBILITY_PACKAGE_NAME,
-                            VISIBILITY_DATABASE_NAME,
+                            mDatabaseName,
                             VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
                             prefixedSchemaType,
                             /* removeStatsBuilder= */ null);
@@ -227,7 +283,7 @@ public class VisibilityStore {
                 try {
                     mAppSearchImpl.remove(
                             VISIBILITY_PACKAGE_NAME,
-                            ANDROID_V_OVERLAY_DATABASE_NAME,
+                            mAndroidVOverlayDatabaseName,
                             VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE,
                             prefixedSchemaType,
                             /* removeStatsBuilder= */ null);
@@ -258,15 +314,20 @@ public class VisibilityStore {
     /**
      * Loads all stored latest {@link InternalVisibilityConfig} from Icing, and put them into {@link
      * #mVisibilityConfigMap}.
+     *
+     * @param allVisibilityDocumentIds all of document ids that we should have visibility settings
+     *     stored in this database. The Id should be either prefixedSchemaType for document
+     *     visibility settings or prefixedBlobNamespace for blob visibility settings.
      */
     @RequiresNonNull("mAppSearchImpl")
-    private void loadVisibilityConfigMap(@UnderInitialization VisibilityStore this)
+    private void loadVisibilityConfigMap(
+            @UnderInitialization VisibilityStore this,
+            @NonNull List<String> allVisibilityDocumentIds)
             throws AppSearchException {
         // Populate visibility settings set
-        List<String> cachedSchemaTypes = mAppSearchImpl.getAllPrefixedSchemaTypes();
-        for (int i = 0; i < cachedSchemaTypes.size(); i++) {
-            String prefixedSchemaType = cachedSchemaTypes.get(i);
-            String packageName = PrefixUtil.getPackageName(prefixedSchemaType);
+        for (int i = 0; i < allVisibilityDocumentIds.size(); i++) {
+            String visibilityDocumentId = allVisibilityDocumentIds.get(i);
+            String packageName = PrefixUtil.getPackageName(visibilityDocumentId);
             if (packageName.equals(VISIBILITY_PACKAGE_NAME)) {
                 continue; // Our own package. Skip.
             }
@@ -278,9 +339,9 @@ public class VisibilityStore {
                 visibilityDocument =
                         mAppSearchImpl.getDocument(
                                 VISIBILITY_PACKAGE_NAME,
-                                VISIBILITY_DATABASE_NAME,
+                                mDatabaseName,
                                 VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
-                                /* id= */ prefixedSchemaType,
+                                /* id= */ visibilityDocumentId,
                                 /* typePropertyPaths= */ Collections.emptyMap());
             } catch (AppSearchException e) {
                 if (e.getResultCode() == RESULT_NOT_FOUND) {
@@ -296,9 +357,9 @@ public class VisibilityStore {
                 visibilityAndroidVOverlay =
                         mAppSearchImpl.getDocument(
                                 VISIBILITY_PACKAGE_NAME,
-                                ANDROID_V_OVERLAY_DATABASE_NAME,
+                                mAndroidVOverlayDatabaseName,
                                 VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE,
-                                /* id= */ prefixedSchemaType,
+                                /* id= */ visibilityDocumentId,
                                 /* typePropertyPaths= */ Collections.emptyMap());
             } catch (AppSearchException e) {
                 if (e.getResultCode() != RESULT_NOT_FOUND) {
@@ -310,7 +371,7 @@ public class VisibilityStore {
             }
 
             mVisibilityConfigMap.put(
-                    prefixedSchemaType,
+                    visibilityDocumentId,
                     VisibilityToDocumentConverter.createInternalVisibilityConfig(
                             visibilityDocument, visibilityAndroidVOverlay));
         }
@@ -327,7 +388,7 @@ public class VisibilityStore {
         InternalSetSchemaResponse internalSetSchemaResponse =
                 mAppSearchImpl.setSchema(
                         VISIBILITY_PACKAGE_NAME,
-                        VISIBILITY_DATABASE_NAME,
+                        mDatabaseName,
                         Arrays.asList(
                                 VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_SCHEMA,
                                 VisibilityPermissionConfig.SCHEMA),
@@ -345,7 +406,7 @@ public class VisibilityStore {
         InternalSetSchemaResponse internalSetAndroidVOverlaySchemaResponse =
                 mAppSearchImpl.setSchema(
                         VISIBILITY_PACKAGE_NAME,
-                        ANDROID_V_OVERLAY_DATABASE_NAME,
+                        mAndroidVOverlayDatabaseName,
                         Collections.singletonList(
                                 VisibilityToDocumentConverter.ANDROID_V_OVERLAY_SCHEMA),
                         /* visibilityConfigs= */ Collections.emptyList(),
@@ -365,7 +426,7 @@ public class VisibilityStore {
             mVisibilityConfigMap.put(migratedConfig.getSchemaType(), migratedConfig);
             mAppSearchImpl.putDocument(
                     VISIBILITY_PACKAGE_NAME,
-                    VISIBILITY_DATABASE_NAME,
+                    mDatabaseName,
                     VisibilityToDocumentConverter.createVisibilityDocument(migratedConfig),
                     /* sendChangeNotifications= */ false,
                     /* logger= */ null);
@@ -373,7 +434,7 @@ public class VisibilityStore {
     }
 
     /**
-     * Check and migrate visibility schemas in {@link #ANDROID_V_OVERLAY_DATABASE_NAME} to {@link
+     * Check and migrate visibility schemas in {@link #mAndroidVOverlayDatabaseName} to {@link
      * VisibilityToDocumentConverter#ANDROID_V_OVERLAY_SCHEMA_VERSION_LATEST}.
      */
     @RequiresNonNull("mAppSearchImpl")
@@ -382,7 +443,7 @@ public class VisibilityStore {
         GetSchemaResponse getSchemaResponse =
                 mAppSearchImpl.getSchema(
                         VISIBILITY_PACKAGE_NAME,
-                        ANDROID_V_OVERLAY_DATABASE_NAME,
+                        mAndroidVOverlayDatabaseName,
                         new CallerAccess(/* callingPackageName= */ VISIBILITY_PACKAGE_NAME));
         switch (getSchemaResponse.getVersion()) {
             case VisibilityToDocumentConverter.OVERLAY_SCHEMA_VERSION_PUBLIC_ACL_VISIBLE_TO_CONFIG:
@@ -392,7 +453,7 @@ public class VisibilityStore {
                 InternalSetSchemaResponse internalSetSchemaResponse =
                         mAppSearchImpl.setSchema(
                                 VISIBILITY_PACKAGE_NAME,
-                                ANDROID_V_OVERLAY_DATABASE_NAME,
+                                mAndroidVOverlayDatabaseName,
                                 Collections.singletonList(
                                         VisibilityToDocumentConverter.ANDROID_V_OVERLAY_SCHEMA),
                                 /* visibilityConfigs= */ Collections.emptyList(),
@@ -419,9 +480,7 @@ public class VisibilityStore {
         }
     }
 
-    /**
-     * Verify the existing visibility schema, set the latest visibilility schema if it's missing.
-     */
+    /** Verify the existing visibility schema, set the latest visibility schema if it's missing. */
     @RequiresNonNull("mAppSearchImpl")
     private void verifyOrSetLatestVisibilitySchema(
             @UnderInitialization VisibilityStore this, @NonNull GetSchemaResponse getSchemaResponse)
@@ -445,7 +504,7 @@ public class VisibilityStore {
             InternalSetSchemaResponse internalSetSchemaResponse =
                     mAppSearchImpl.setSchema(
                             VISIBILITY_PACKAGE_NAME,
-                            VISIBILITY_DATABASE_NAME,
+                            mDatabaseName,
                             Arrays.asList(
                                     VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_SCHEMA,
                                     VisibilityPermissionConfig.SCHEMA),
@@ -466,7 +525,7 @@ public class VisibilityStore {
             InternalSetSchemaResponse internalSetSchemaResponse =
                     mAppSearchImpl.setSchema(
                             VISIBILITY_PACKAGE_NAME,
-                            VISIBILITY_DATABASE_NAME,
+                            mDatabaseName,
                             Arrays.asList(
                                     VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_SCHEMA,
                                     VisibilityPermissionConfig.SCHEMA),
@@ -507,7 +566,7 @@ public class VisibilityStore {
             InternalSetSchemaResponse internalSetSchemaResponse =
                     mAppSearchImpl.setSchema(
                             VISIBILITY_PACKAGE_NAME,
-                            ANDROID_V_OVERLAY_DATABASE_NAME,
+                            mAndroidVOverlayDatabaseName,
                             Collections.singletonList(
                                     VisibilityToDocumentConverter.ANDROID_V_OVERLAY_SCHEMA),
                             /* visibilityConfigs= */ Collections.emptyList(),
diff --git a/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV0.java b/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV0.java
index 30a88d43..f3536f6f 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV0.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV0.java
@@ -147,7 +147,7 @@ public class VisibilityStoreMigrationHelperFromV0 {
                     deprecatedDocuments.add(
                             appSearchImpl.getDocument(
                                     VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                                    VisibilityStore.VISIBILITY_DATABASE_NAME,
+                                    VisibilityStore.DOCUMENT_VISIBILITY_DATABASE_NAME,
                                     VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
                                     getDeprecatedVisibilityDocumentId(packageName, databaseName),
                                     /* typePropertyPaths= */ Collections.emptyMap()));
diff --git a/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV1.java b/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV1.java
index ec87a95e..c43acb7f 100644
--- a/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV1.java
+++ b/service/java/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV1.java
@@ -65,7 +65,7 @@ public class VisibilityStoreMigrationHelperFromV1 {
                         new VisibilityDocumentV1(
                                 appSearchImpl.getDocument(
                                         VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                                        VisibilityStore.VISIBILITY_DATABASE_NAME,
+                                        VisibilityStore.DOCUMENT_VISIBILITY_DATABASE_NAME,
                                         VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
                                         allPrefixedSchemaTypes.get(i),
                                         /* typePropertyPaths= */ Collections.emptyMap())));
diff --git a/service/java/com/android/server/appsearch/indexer/IndexerMaintenanceConfig.java b/service/java/com/android/server/appsearch/indexer/IndexerMaintenanceConfig.java
index 8a710686..7f049219 100644
--- a/service/java/com/android/server/appsearch/indexer/IndexerMaintenanceConfig.java
+++ b/service/java/com/android/server/appsearch/indexer/IndexerMaintenanceConfig.java
@@ -20,6 +20,7 @@ import android.annotation.IntDef;
 import android.annotation.NonNull;
 
 import com.android.server.LocalManagerRegistry;
+import com.android.server.appsearch.appsindexer.AppOpenEventIndexerMaintenanceConfig;
 import com.android.server.appsearch.appsindexer.AppsIndexerMaintenanceConfig;
 import com.android.server.appsearch.contactsindexer.ContactsIndexerMaintenanceConfig;
 
@@ -30,11 +31,19 @@ import java.lang.annotation.RetentionPolicy;
 public interface IndexerMaintenanceConfig {
     int APPS_INDEXER = 0;
     int CONTACTS_INDEXER = 1;
+    int APP_OPEN_EVENT_INDEXER = 2;
+
+    int MIN_CONTACTS_INDEXER_JOB_ID = 16942831; // corresponds to ag/16942831
+
+    int MIN_APPS_INDEXER_JOB_ID = 16964307; // Contacts Indexer Max Job Id + 1
+
+    int MIN_APP_OPEN_EVENT_INDEXER_JOB_ID = 16985783; // Apps Indexer Max Job Id + 1
 
     @IntDef(
             value = {
                 APPS_INDEXER,
                 CONTACTS_INDEXER,
+                APP_OPEN_EVENT_INDEXER,
             })
     @Retention(RetentionPolicy.SOURCE)
     @interface IndexerType {}
@@ -46,6 +55,8 @@ public interface IndexerMaintenanceConfig {
             return AppsIndexerMaintenanceConfig.INSTANCE;
         } else if (indexerType == CONTACTS_INDEXER) {
             return ContactsIndexerMaintenanceConfig.INSTANCE;
+        } else if (indexerType == APP_OPEN_EVENT_INDEXER) {
+            return AppOpenEventIndexerMaintenanceConfig.INSTANCE;
         } else {
             throw new IllegalArgumentException(
                     "Attempted to get config for invalid indexer type: " + indexerType);
diff --git a/service/java/com/android/server/appsearch/indexer/IndexerMaintenanceService.java b/service/java/com/android/server/appsearch/indexer/IndexerMaintenanceService.java
index e68334a5..d7c85f9e 100644
--- a/service/java/com/android/server/appsearch/indexer/IndexerMaintenanceService.java
+++ b/service/java/com/android/server/appsearch/indexer/IndexerMaintenanceService.java
@@ -48,9 +48,13 @@ import java.util.concurrent.TimeUnit;
 
 /** Dispatches maintenance tasks for various indexers. */
 public class IndexerMaintenanceService extends JobService {
-    private static final String TAG = "AppSearchIndexerMaintena";
-    private static final String EXTRA_USER_ID = "user_id";
-    private static final String INDEXER_TYPE = "indexer_type";
+    private static final String TAG = "AppSearchIndexerMainten";
+
+    @VisibleForTesting
+    public static final String EXTRA_USER_ID = "user_id";
+
+    @VisibleForTesting
+    public static final String INDEXER_TYPE = "indexer_type";
 
     /**
      * A mapping of userHandle-to-CancellationSignal. Since we schedule a separate job for each
@@ -202,14 +206,15 @@ public class IndexerMaintenanceService extends JobService {
                 return false;
             }
 
-            @IndexerType
-            int indexerType = params.getExtras().getInt(INDEXER_TYPE, /* defaultValue= */ -1);
-            if (indexerType == -1) {
-                return false;
-            }
-
             if (LogUtil.DEBUG) {
-                Log.v(TAG, "Update job started for user " + userId);
+                // If the job parameters is missing INDEXER_TYPE, then this job was scheduled on
+                // a previous version before INDEXER_TYPE was introduced, and therefore the job
+                // must be for contacts indexer.
+                @IndexerType int indexerType = params.getExtras().getInt(
+                        INDEXER_TYPE, /* defaultValue= */
+                        IndexerMaintenanceConfig.CONTACTS_INDEXER);
+                Log.v(TAG, "Update job started for user " + userId + " and indexer type "
+                        + indexerType);
             }
 
             UserHandle userHandle = UserHandle.getUserHandleForUid(userId);
@@ -257,10 +262,11 @@ public class IndexerMaintenanceService extends JobService {
             Objects.requireNonNull(userHandle);
             Objects.requireNonNull(signal);
 
-            @IndexerType int indexerType = params.getExtras().getInt(INDEXER_TYPE, -1);
-            if (indexerType == -1) {
-                return false;
-            }
+            // If the job parameters is missing INDEXER_TYPE, then this job was scheduled on a
+            // previous version before INDEXER_TYPE was introduced, and therefore the job must be
+            // for contacts indexer.
+            @IndexerType int indexerType = params.getExtras().getInt(INDEXER_TYPE,
+                    IndexerMaintenanceConfig.CONTACTS_INDEXER);
             Class<? extends IndexerLocalService> indexerLocalService =
                     IndexerMaintenanceConfig.getConfigForIndexer(indexerType).getLocalService();
             IndexerLocalService service = LocalManagerRegistry.getManager(indexerLocalService);
diff --git a/service/java/com/android/server/appsearch/stats/PlatformLogger.java b/service/java/com/android/server/appsearch/stats/PlatformLogger.java
index 9d1d65d5..0c7f2bb4 100644
--- a/service/java/com/android/server/appsearch/stats/PlatformLogger.java
+++ b/service/java/com/android/server/appsearch/stats/PlatformLogger.java
@@ -19,7 +19,6 @@ package com.android.server.appsearch.stats;
 import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
-import android.app.appsearch.exceptions.AppSearchException;
 import android.app.appsearch.stats.SchemaMigrationStats;
 import android.content.Context;
 import android.os.Build;
@@ -45,16 +44,15 @@ import com.android.server.appsearch.external.localstorage.stats.SearchStats;
 import com.android.server.appsearch.external.localstorage.stats.SetSchemaStats;
 import com.android.server.appsearch.util.ApiCallRecord;
 import com.android.server.appsearch.util.PackageUtil;
+import com.android.server.appsearch.util.StatsUtil;
 
 import java.io.UnsupportedEncodingException;
-import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
-import java.util.Random;
 
 /**
  * Logger Implementation for pushed atoms.
@@ -72,7 +70,6 @@ public final class PlatformLogger implements InternalAppSearchLogger {
     // Manager holding the configuration flags
     private final ServiceAppSearchConfig mConfig;
 
-    private final Random mRng = new Random();
     private final Object mLock = new Object();
 
     /**
@@ -283,7 +280,7 @@ public final class PlatformLogger implements InternalAppSearchLogger {
             // will be 10*12 + 10*3 = 150 for that device's reported value.
             final int numReportedCalls = 1;
 
-            int hashCodeForDatabase = calculateHashCodeMd5(database);
+            int hashCodeForDatabase = StatsUtil.calculateHashCodeMd5(database);
             AppSearchStatsLog.write(
                     AppSearchStatsLog.APP_SEARCH_CALL_STATS_REPORTED,
                     extraStats.mSamplingInterval,
@@ -317,7 +314,7 @@ public final class PlatformLogger implements InternalAppSearchLogger {
                 createExtraStatsLocked(stats.getPackageName(), CallStats.CALL_TYPE_SET_SCHEMA);
         String database = stats.getDatabase();
         try {
-            int hashCodeForDatabase = calculateHashCodeMd5(database);
+            int hashCodeForDatabase = StatsUtil.calculateHashCodeMd5(database);
             // ignore close exception
             AppSearchStatsLog.write(
                     AppSearchStatsLog.APP_SEARCH_SET_SCHEMA_STATS_REPORTED,
@@ -367,7 +364,7 @@ public final class PlatformLogger implements InternalAppSearchLogger {
                         stats.getPackageName(), CallStats.CALL_TYPE_SCHEMA_MIGRATION);
         String database = stats.getDatabase();
         try {
-            int hashCodeForDatabase = calculateHashCodeMd5(database);
+            int hashCodeForDatabase = StatsUtil.calculateHashCodeMd5(database);
             // ignore close exception
             AppSearchStatsLog.write(
                     AppSearchStatsLog.APP_SEARCH_SET_SCHEMA_STATS_REPORTED,
@@ -404,7 +401,7 @@ public final class PlatformLogger implements InternalAppSearchLogger {
                 createExtraStatsLocked(stats.getPackageName(), CallStats.CALL_TYPE_PUT_DOCUMENT);
         String database = stats.getDatabase();
         try {
-            int hashCodeForDatabase = calculateHashCodeMd5(database);
+            int hashCodeForDatabase = StatsUtil.calculateHashCodeMd5(database);
             AppSearchStatsLog.write(
                     AppSearchStatsLog.APP_SEARCH_PUT_DOCUMENT_STATS_REPORTED,
                     extraStats.mSamplingInterval,
@@ -442,8 +439,9 @@ public final class PlatformLogger implements InternalAppSearchLogger {
                 createExtraStatsLocked(stats.getPackageName(), CallStats.CALL_TYPE_SEARCH);
         String database = stats.getDatabase();
         try {
-            int hashCodeForDatabase = calculateHashCodeMd5(database);
-            int hashCodeForSearchSourceLogTag = calculateHashCodeMd5(stats.getSearchSourceLogTag());
+            int hashCodeForDatabase = StatsUtil.calculateHashCodeMd5(database);
+            int hashCodeForSearchSourceLogTag =
+                    StatsUtil.calculateHashCodeMd5(stats.getSearchSourceLogTag());
             AppSearchStatsLog.write(
                     AppSearchStatsLog.APP_SEARCH_QUERY_STATS_REPORTED,
                     extraStats.mSamplingInterval,
@@ -594,7 +592,7 @@ public final class PlatformLogger implements InternalAppSearchLogger {
 
         int hashCodeForDatabase;
         try {
-            hashCodeForDatabase = calculateHashCodeMd5(database);
+            hashCodeForDatabase = StatsUtil.calculateHashCodeMd5(database);
         } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
             // Something is wrong while calculating the hash code for database. Assign the hash
             // value with 0xFFFFFFFF, and log the error message.
@@ -669,37 +667,6 @@ public final class PlatformLogger implements InternalAppSearchLogger {
         trimExcessStatsQueueLocked();
     }
 
-    /**
-     * Calculate the hash code as an integer by returning the last four bytes of its MD5.
-     *
-     * @param str a string
-     * @return hash code as an integer. returns -1 if str is null.
-     * @throws AppSearchException if either algorithm or encoding does not exist.
-     */
-    @VisibleForTesting
-    @NonNull
-    static int calculateHashCodeMd5(@Nullable String str)
-            throws NoSuchAlgorithmException, UnsupportedEncodingException {
-        if (str == null) {
-            return -1;
-        }
-
-        MessageDigest md = MessageDigest.getInstance("MD5");
-        md.update(str.getBytes(/* charsetName= */ "UTF-8"));
-        byte[] digest = md.digest();
-
-        // Since MD5 generates 16 bytes digest, we don't need to check the length here to see
-        // if it is smaller than sizeof(int)(4).
-        //
-        // We generate the same value as BigInteger(digest).intValue().
-        // BigInteger takes bytes[] and treat it as big endian. And its intValue() would get the
-        // lower 4 bytes. So here we take the last 4 bytes and treat them as big endian.
-        return (digest[12] & 0xFF) << 24
-                | (digest[13] & 0xFF) << 16
-                | (digest[14] & 0xFF) << 8
-                | (digest[15] & 0xFF);
-    }
-
     /**
      * Creates {@link ExtraStats} to hold additional information generated for logging.
      *
@@ -745,7 +712,7 @@ public final class PlatformLogger implements InternalAppSearchLogger {
     boolean shouldLogForTypeLocked(@CallStats.CallType int callType) {
         int samplingInterval = getSamplingIntervalFromConfig(callType);
         // Sampling
-        if (!shouldSample(samplingInterval)) {
+        if (!StatsUtil.shouldSample(samplingInterval)) {
             return false;
         }
 
@@ -763,20 +730,6 @@ public final class PlatformLogger implements InternalAppSearchLogger {
         return true;
     }
 
-    /**
-     * Checks if the stats should be "sampled"
-     *
-     * @param samplingInterval sampling interval
-     * @return if the stats should be sampled
-     */
-    private boolean shouldSample(int samplingInterval) {
-        if (samplingInterval <= 0) {
-            return false;
-        }
-
-        return mRng.nextInt((int) samplingInterval) == 0;
-    }
-
     /**
      * Finds the UID of the {@code packageName}. Returns {@link Process#INVALID_UID} if unable to
      * find the UID.
@@ -832,6 +785,9 @@ public final class PlatformLogger implements InternalAppSearchLogger {
             case CallStats.CALL_TYPE_REGISTER_OBSERVER_CALLBACK:
             case CallStats.CALL_TYPE_UNREGISTER_OBSERVER_CALLBACK:
             case CallStats.CALL_TYPE_GLOBAL_GET_NEXT_PAGE:
+            case CallStats.CALL_TYPE_OPEN_WRITE_BLOB:
+            case CallStats.CALL_TYPE_COMMIT_BLOB:
+            case CallStats.CALL_TYPE_OPEN_READ_BLOB:
                 // TODO(b/173532925) Some of them above will have dedicated sampling ratio config
             default:
                 return mConfig.getCachedSamplingIntervalDefault();
diff --git a/service/java/com/android/server/appsearch/util/ServiceImplHelper.java b/service/java/com/android/server/appsearch/util/ServiceImplHelper.java
index 68eea811..a708b7c0 100644
--- a/service/java/com/android/server/appsearch/util/ServiceImplHelper.java
+++ b/service/java/com/android/server/appsearch/util/ServiceImplHelper.java
@@ -27,6 +27,7 @@ import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.aidl.AppSearchAttributionSource;
 import android.app.appsearch.aidl.AppSearchBatchResultParcel;
 import android.app.appsearch.aidl.AppSearchResultParcel;
+import android.app.appsearch.aidl.AppSearchResultParcelV2;
 import android.app.appsearch.aidl.IAppSearchBatchResultCallback;
 import android.app.appsearch.aidl.IAppSearchResultCallback;
 import android.app.appsearch.annotation.CanIgnoreReturnValue;
@@ -368,6 +369,16 @@ public class ServiceImplHelper {
         }
     }
 
+    /** Invokes the {@link IAppSearchResultCallback} with the result parcel. */
+    public static void invokeCallbackOnResult(
+            IAppSearchResultCallback callback, AppSearchResultParcelV2<?> resultParcel) {
+        try {
+            callback.onResultV2(resultParcel);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Unable to send result to the callback", e);
+        }
+    }
+
     /** Invokes the {@link IAppSearchResultCallback} with the result parcel. */
     public static void invokeCallbackOnResult(
             IAppSearchResultCallback callback, AppSearchResultParcel<?> resultParcel) {
@@ -378,6 +389,7 @@ public class ServiceImplHelper {
         }
     }
 
+
     /** Invokes the {@link IAppSearchBatchResultCallback} with the result. */
     public static void invokeCallbackOnResult(
             IAppSearchBatchResultCallback callback, AppSearchBatchResultParcel<?> resultParcel) {
diff --git a/service/java/com/android/server/appsearch/util/StatsUtil.java b/service/java/com/android/server/appsearch/util/StatsUtil.java
new file mode 100644
index 00000000..f3bb1461
--- /dev/null
+++ b/service/java/com/android/server/appsearch/util/StatsUtil.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.util;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+
+import android.annotation.Nullable;
+
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Random;
+
+/**
+ * This utility class to provide helper functions for AppSearch logging.
+ *
+ * @hide
+ */
+public class StatsUtil {
+
+    private static final Random sRng = new Random();
+
+    /**
+     * Calculate the hash code as an integer by returning the last four bytes of its MD5.
+     *
+     * @param str a string to hash.
+     * @return hash code as an integer. returns -1 if str is null.
+     * @throws AppSearchException if either algorithm or encoding does not exist.
+     */
+    public static int calculateHashCodeMd5(@Nullable String str)
+            throws NoSuchAlgorithmException, UnsupportedEncodingException {
+        if (str == null) {
+            return -1;
+        }
+
+        MessageDigest md = MessageDigest.getInstance("MD5");
+        md.update(str.getBytes(/* charsetName= */ UTF_8));
+        byte[] digest = md.digest();
+
+        // Since MD5 generates 16 bytes digest, we don't need to check the length here to see
+        // if it is smaller than sizeof(int)(4).
+        //
+        // We generate the same value as BigInteger(digest).intValue().
+        // BigInteger takes bytes[] and treat it as big endian. And its intValue() would get the
+        // lower 4 bytes. So here we take the last 4 bytes and treat them as big endian.
+        return (digest[12] & 0xFF) << 24
+                | (digest[13] & 0xFF) << 16
+                | (digest[14] & 0xFF) << 8
+                | (digest[15] & 0xFF);
+    }
+
+    /**
+     * Checks if the stats should be sampled for logging based on the provided sampling interval.
+     *
+     * <p>The probability of sampling is 1/samplingInterval. For example:
+     *
+     * <ul>
+     *   <li>If the samplingInterval is 1, all stats will be sampled (100% sampling).
+     *   <li>If the samplingInterval is 10, 1 in 10 stats will be sampled (10% sampling).
+     * </ul>
+     *
+     * @param samplingInterval the interval used to calculate the sampling probability.
+     * @return true if the stats should be sampled, false otherwise.
+     */
+    public static boolean shouldSample(int samplingInterval) {
+        if (samplingInterval <= 0) {
+            return false;
+        }
+
+        return sRng.nextInt((int) samplingInterval) == 0;
+    }
+
+    private StatsUtil() {}
+}
diff --git a/service/java/com/android/server/appsearch/visibilitystore/VisibilityCheckerImpl.java b/service/java/com/android/server/appsearch/visibilitystore/VisibilityCheckerImpl.java
index 3e944900..87189d47 100644
--- a/service/java/com/android/server/appsearch/visibilitystore/VisibilityCheckerImpl.java
+++ b/service/java/com/android/server/appsearch/visibilitystore/VisibilityCheckerImpl.java
@@ -17,6 +17,7 @@ package com.android.server.appsearch.visibilitystore;
 
 import static android.Manifest.permission.EXECUTE_APP_FUNCTIONS;
 import static android.Manifest.permission.EXECUTE_APP_FUNCTIONS_TRUSTED;
+import static android.Manifest.permission.PACKAGE_USAGE_STATS;
 import static android.Manifest.permission.READ_ASSISTANT_APP_SEARCH_DATA;
 import static android.Manifest.permission.READ_CALENDAR;
 import static android.Manifest.permission.READ_CONTACTS;
@@ -323,6 +324,7 @@ public class VisibilityCheckerImpl implements VisibilityChecker {
                 case SetSchemaRequest.READ_ASSISTANT_APP_SEARCH_DATA:
                 case SetSchemaRequest.EXECUTE_APP_FUNCTIONS:
                 case SetSchemaRequest.EXECUTE_APP_FUNCTIONS_TRUSTED:
+                case SetSchemaRequest.PACKAGE_USAGE_STATS:
                     if (!doesCallerHavePermissionForDataDelivery(
                             requiredPermission, callerAttributionSource)) {
                         // The calling package doesn't have this required permission, return false.
@@ -392,6 +394,9 @@ public class VisibilityCheckerImpl implements VisibilityChecker {
             case SetSchemaRequest.EXECUTE_APP_FUNCTIONS_TRUSTED:
                 permission = EXECUTE_APP_FUNCTIONS_TRUSTED;
                 break;
+            case SetSchemaRequest.PACKAGE_USAGE_STATS:
+                permission = PACKAGE_USAGE_STATS;
+                break;
             default:
                 return false;
         }
diff --git a/synced_jetpack_sha.txt b/synced_jetpack_sha.txt
index ead1ecfc..f9d186e1 100644
--- a/synced_jetpack_sha.txt
+++ b/synced_jetpack_sha.txt
@@ -1 +1 @@
-7eae2382f01dc1565625aab36a5263541d6a0831
+a9beed7533d5b55322d64520113280e832ff33b6
diff --git a/testing/appsindexertests/AndroidManifest.xml b/testing/appsindexertests/AndroidManifest.xml
index cb0ec9ac..f3d51c36 100644
--- a/testing/appsindexertests/AndroidManifest.xml
+++ b/testing/appsindexertests/AndroidManifest.xml
@@ -22,6 +22,14 @@
     <application android:label="AppsIndexerTests"
                  android:debuggable="true">
         <uses-library android:name="android.test.runner"/>
+        <activity
+            android:name="com.android.server.appsearch.appsindexer.MainActivity"
+            android:exported="true">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
         <service android:name="com.android.server.appsearch.appsindexer.IndexerMaintenanceService"
                  android:permission="android.permission.BIND_JOB_SERVICE">
         </service>
diff --git a/testing/appsindexertests/AndroidTest.xml b/testing/appsindexertests/AndroidTest.xml
index 8f9f9e87..536c4843 100644
--- a/testing/appsindexertests/AndroidTest.xml
+++ b/testing/appsindexertests/AndroidTest.xml
@@ -29,9 +29,9 @@
     <test class="com.android.tradefed.testtype.AndroidJUnitTest">
         <option name="package" value="com.android.appsearch.appsindexertests"/>
         <option name="exclude-annotation"
-            value="com.android.bedstead.harrier.annotations.RequireRunOnWorkProfile" />
+            value="com.android.bedstead.enterprise.annotations.RequireRunOnWorkProfile" />
         <option name="exclude-annotation"
-            value="com.android.bedstead.harrier.annotations.RequireRunOnSecondaryUser" />
+            value="com.android.bedstead.multiuser.annotations.RequireRunOnSecondaryUser" />
         <option name="hidden-api-checks" value="false" />
     </test>
 
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppFunctionSchemaParserTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppFunctionSchemaParserTest.java
new file mode 100644
index 00000000..8ce59fd4
--- /dev/null
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppFunctionSchemaParserTest.java
@@ -0,0 +1,237 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.server.appsearch.appsindexer;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.mockito.Mockito.when;
+
+import android.app.appsearch.AppSearchSchema;
+import android.app.appsearch.AppSearchSchema.PropertyConfig;
+import android.app.appsearch.AppSearchSchema.StringPropertyConfig;
+import android.app.appsearch.AppSearchSchema.LongPropertyConfig;
+import android.app.appsearch.AppSearchSchema.BooleanPropertyConfig;
+import android.content.pm.PackageManager;
+import android.content.res.AssetManager;
+import android.content.res.Resources;
+
+import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionStaticMetadata;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.junit.MockitoJUnitRunner;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.List;
+import java.util.Map;
+
+@RunWith(MockitoJUnitRunner.class)
+public class AppFunctionSchemaParserTest {
+    private static final String TEST_PACKAGE_NAME = "com.example.app";
+    private static final String TEST_XML_ASSET_FILE_PATH = "appfn_schema.xsd";
+    private static final int MAX_ALLOWED_NESTING = 2;
+
+    @Mock private PackageManager mPackageManager;
+    @Mock private Resources mResources;
+    @Mock private AssetManager mAssetManager;
+
+    private AppFunctionSchemaParser mParser;
+
+    @Before
+    public void setUp() throws Exception {
+        mParser = new AppFunctionSchemaParser(MAX_ALLOWED_NESTING);
+
+        when(mPackageManager.getResourcesForApplication(TEST_PACKAGE_NAME)).thenReturn(mResources);
+        when(mResources.getAssets()).thenReturn(mAssetManager);
+    }
+
+    @Test
+    public void parse_singleType_withNoAttributes() throws Exception {
+        String xsd =
+                "<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">"
+                        + "    <xs:documentType name=\"AppFunctionStaticMetadata\">"
+                        + "        <xs:element name=\"name\" type=\"xs:string\" />"
+                        + "        <xs:element name=\"age\" type=\"xs:int\" />"
+                        + "        <xs:element name=\"isActive\" type=\"xs:boolean\" />"
+                        + "    </xs:documentType>"
+                        + "</xs:schema>";
+        setXmlInput(xsd);
+
+        Map<String, AppSearchSchema> schemas =
+                mParser.parseAndCreateSchemas(
+                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH);
+
+        assertThat(schemas).hasSize(1);
+        assertThat(schemas.get("AppFunctionStaticMetadata-com.example.app"))
+                .isEqualTo(
+                        new AppSearchSchema.Builder("AppFunctionStaticMetadata-com.example.app")
+                                .addProperty(new StringPropertyConfig.Builder("name").build())
+                                .addProperty(new LongPropertyConfig.Builder("age").build())
+                                .addProperty(new BooleanPropertyConfig.Builder("isActive").build())
+                                .build());
+    }
+
+    @Test
+    public void parse_singleType_withAttributes() throws Exception {
+        String xsd =
+                "<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">"
+                        + "    <xs:documentType name=\"AppFunctionStaticMetadata\">"
+                        + "        <xs:element name=\"name\" type=\"xs:string\" indexingType=\""
+                        + StringPropertyConfig.INDEXING_TYPE_EXACT_TERMS
+                        + "\" tokenizerType=\""
+                        + StringPropertyConfig.TOKENIZER_TYPE_VERBATIM
+                        + "\" joinableValueType=\""
+                        + StringPropertyConfig.JOINABLE_VALUE_TYPE_QUALIFIED_ID
+                        + "\" />"
+                        + "        <xs:element name=\"age\" type=\"xs:int\" indexingType=\""
+                        + LongPropertyConfig.INDEXING_TYPE_RANGE
+                        + "\" />"
+                        + "        <xs:element name=\"isActive\" type=\"xs:boolean\" cardinality=\""
+                        + PropertyConfig.CARDINALITY_REQUIRED
+                        + "\" />"
+                        + "    </xs:documentType>"
+                        + "</xs:schema>";
+        setXmlInput(xsd);
+
+        Map<String, AppSearchSchema> schemas =
+                mParser.parseAndCreateSchemas(
+                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH);
+
+        assertThat(schemas).hasSize(1);
+        assertThat(schemas.get("AppFunctionStaticMetadata-com.example.app"))
+                .isEqualTo(
+                        new AppSearchSchema.Builder("AppFunctionStaticMetadata-com.example.app")
+                                .addProperty(
+                                        new StringPropertyConfig.Builder("name")
+                                                .setIndexingType(
+                                                        StringPropertyConfig
+                                                                .INDEXING_TYPE_EXACT_TERMS)
+                                                .setTokenizerType(
+                                                        StringPropertyConfig
+                                                                .TOKENIZER_TYPE_VERBATIM)
+                                                .setJoinableValueType(
+                                                        StringPropertyConfig
+                                                                .JOINABLE_VALUE_TYPE_QUALIFIED_ID)
+                                                .build())
+                                .addProperty(
+                                        new LongPropertyConfig.Builder("age")
+                                                .setIndexingType(
+                                                        LongPropertyConfig.INDEXING_TYPE_RANGE)
+                                                .build())
+                                .addProperty(
+                                        new BooleanPropertyConfig.Builder("isActive")
+                                                .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
+                                                .build())
+                                .build());
+    }
+
+    @Test
+    public void parse_multipleNestedTypes() throws Exception {
+        String xsd =
+                "<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">"
+                        + "    <xs:documentType name=\"AppFunctionStaticMetadata\">"
+                        + "        <xs:element name=\"inner\" type=\"appfn:InnerType\" />"
+                        + "    </xs:documentType>"
+                        + "    <xs:documentType name=\"InnerType\">"
+                        + "        <xs:element name=\"value\" type=\"xs:string\" />"
+                        + "    </xs:documentType>"
+                        + "</xs:schema>";
+        setXmlInput(xsd);
+
+        Map<String, AppSearchSchema> schemas =
+                mParser.parseAndCreateSchemas(
+                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH);
+
+        assertThat(schemas).hasSize(2);
+        assertThat(schemas.get("InnerType-com.example.app"))
+                .isEqualTo(
+                        new AppSearchSchema.Builder("InnerType-com.example.app")
+                                .addProperty(new StringPropertyConfig.Builder("value").build())
+                                .build());
+        assertThat(schemas.get("AppFunctionStaticMetadata-com.example.app"))
+                .isEqualTo(
+                        new AppSearchSchema.Builder("AppFunctionStaticMetadata-com.example.app")
+                                .addProperty(
+                                        new AppSearchSchema.DocumentPropertyConfig.Builder(
+                                                        "inner", "InnerType-com.example.app")
+                                                .setShouldIndexNestedProperties(true)
+                                                .build())
+                                .build());
+    }
+
+    @Test
+    public void parse_exceedMaxAllowedDocumentTypes() throws Exception {
+        String xsd =
+                "<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">"
+                        + "    <xs:documentType name=\"OuterType\">"
+                        + "        <xs:element name=\"inner\" type=\"appfn:InnerType\" />"
+                        + "    </xs:documentType>"
+                        + "    <xs:documentType name=\"InnerType\">"
+                        + "        <xs:element name=\"inner2\" type=\"appfn:Inner2Type\" />"
+                        + "    </xs:documentType>"
+                        + "    <xs:documentType name=\"Inner2Type\">"
+                        + "        <xs:element name=\"value\" type=\"xs:string\" />"
+                        + "    </xs:documentType>"
+                        + "</xs:schema>";
+        setXmlInput(xsd);
+
+        Map<String, AppSearchSchema> schemas =
+                mParser.parseAndCreateSchemas(
+                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH);
+        assertThat(schemas).isEmpty();
+    }
+
+    @Test
+    public void parse_unsupportedType_returnsEmptyMap() throws Exception {
+        String xsd =
+                "<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">"
+                        + "    <xs:documentType name=\"AppFunctionStaticMetadata\">"
+                        + "        <xs:element name=\"name\" type=\"xs:unsupportedType\" />"
+                        + "    </xs:documentType>"
+                        + "</xs:schema>";
+        setXmlInput(xsd);
+
+        Map<String, AppSearchSchema> schemas =
+                mParser.parseAndCreateSchemas(
+                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH);
+        assertThat(schemas).isEmpty();
+    }
+
+    @Test
+    public void parse_missingAppFunctionStaticMetadataType_returnsEmptyMap() throws Exception {
+        String xsd =
+                "<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\">"
+                        + "    <xs:documentType name=\"TestType\">"
+                        + "        <xs:element name=\"name\" type=\"xs:unsupportedType\" />"
+                        + "    </xs:documentType>"
+                        + "</xs:schema>";
+        setXmlInput(xsd);
+
+        Map<String, AppSearchSchema> schemas =
+                mParser.parseAndCreateSchemas(
+                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH);
+        assertThat(schemas).isEmpty();
+    }
+
+    private void setXmlInput(String xml) throws IOException {
+        InputStream inputStream = new ByteArrayInputStream(xml.getBytes());
+        when(mAssetManager.open(TEST_XML_ASSET_FILE_PATH)).thenReturn(inputStream);
+    }
+}
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppFunctionStaticMetadataParserImplTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppFunctionStaticMetadataParserImplTest.java
index 8d2162ba..05d8b5be 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppFunctionStaticMetadataParserImplTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppFunctionStaticMetadataParserImplTest.java
@@ -19,6 +19,8 @@ import static com.google.common.truth.Truth.assertThat;
 
 import static org.mockito.Mockito.when;
 
+import android.app.appsearch.AppSearchSchema;
+import android.app.appsearch.GenericDocument;
 import android.content.pm.PackageManager;
 import android.content.res.AssetManager;
 import android.content.res.Resources;
@@ -34,7 +36,9 @@ import org.mockito.junit.MockitoJUnitRunner;
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.util.Arrays;
 import java.util.List;
+import java.util.Map;
 
 @RunWith(MockitoJUnitRunner.class)
 public class AppFunctionStaticMetadataParserImplTest {
@@ -42,6 +46,33 @@ public class AppFunctionStaticMetadataParserImplTest {
     private static final String TEST_PACKAGE_NAME = "com.example.app";
     private static final String TEST_INDEXER_PACKAGE_NAME = "com.android.test.indexer";
     private static final String TEST_XML_ASSET_FILE_PATH = "app_functions.xml";
+    private static final Map<String, AppSearchSchema> TEST_SCHEMAS =
+            Map.of(
+                    "AppFunctionStaticMetadata-com.example.app",
+                    new AppSearchSchema.Builder("AppFunctionStaticMetadata-com.example.app")
+                            .addProperty(
+                                    new AppSearchSchema.StringPropertyConfig.Builder("functionId")
+                                            .build())
+                            .addProperty(
+                                    new AppSearchSchema.BooleanPropertyConfig.Builder(
+                                                    "enabledByDefault")
+                                            .build())
+                            .addProperty(
+                                    new AppSearchSchema.LongPropertyConfig.Builder("schemaVersion")
+                                            .build())
+                            .addProperty(
+                                    new AppSearchSchema.DocumentPropertyConfig.Builder(
+                                                    "appFunctionParameterMetadata",
+                                                    "AppFunctionParameterMetadata-com.example.app")
+                                            .build())
+                            .build(),
+                    "AppFunctionParameterMetadata-com.example.app",
+                    new AppSearchSchema.Builder("AppFunctionParameterMetadata-com.example.app")
+                            .addProperty(
+                                    new AppSearchSchema.StringPropertyConfig.Builder(
+                                                    "parameterName")
+                                            .build())
+                            .build());
 
     @Mock private PackageManager mPackageManager;
     @Mock private Resources mResources;
@@ -190,4 +221,184 @@ public class AppFunctionStaticMetadataParserImplTest {
         assertThat(appFunctions.get(0).getFunctionId()).isEqualTo("com.example#send_message1");
         assertThat(appFunctions.get(1).getFunctionId()).isEqualTo("com.example#send_message2");
     }
+
+    @Test
+    public void parseIntoMapForGivenSchemas_singleAppFunctionWithPrimitiveProperties()
+            throws Exception {
+        setXmlInput(
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<appfunctions>\n"
+                        + "  <AppFunctionStaticMetadata>\n"
+                        + "    <functionId>com.example.utils#print</functionId>\n"
+                        + "    <enabledByDefault>true</enabledByDefault>\n"
+                        + "    <schemaVersion>10</schemaVersion>\n"
+                        + "  </AppFunctionStaticMetadata>\n"
+                        + "</appfunctions>");
+
+        Map<String, AppFunctionStaticMetadata> appFunctions =
+                mParser.parseIntoMapForGivenSchemas(
+                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
+
+        assertThat(appFunctions).hasSize(1);
+        assertThat(appFunctions).containsKey("com.example.utils#print");
+        AppFunctionStaticMetadata actualAppFunction = appFunctions.get("com.example.utils#print");
+        assertThat(actualAppFunction.getNamespace()).isEqualTo("app_functions");
+        assertThat(actualAppFunction.getId())
+                .isEqualTo("com.example.app/AppFunctionStaticMetadata");
+        assertThat(actualAppFunction.getSchemaType())
+                .isEqualTo("AppFunctionStaticMetadata-com.example.app");
+        assertThat(actualAppFunction.getPropertyString("functionId"))
+                .isEqualTo("com.example.utils#print");
+        assertThat(actualAppFunction.getPropertyBoolean("enabledByDefault")).isEqualTo(true);
+        assertThat(actualAppFunction.getPropertyLong("schemaVersion")).isEqualTo(10);
+    }
+
+    @Test
+    public void parseIntoMapForGivenSchemas_multipleAppFunctions() throws Exception {
+        setXmlInput(
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<appfunctions>\n"
+                        + "  <AppFunctionStaticMetadata>\n"
+                        + "    <functionId>com.example.utils#print1</functionId>\n"
+                        + "    <enabledByDefault>true</enabledByDefault>\n"
+                        + "    <schemaVersion>10</schemaVersion>\n"
+                        + "  </AppFunctionStaticMetadata>\n"
+                        + "  <AppFunctionStaticMetadata>\n"
+                        + "    <functionId>com.example.utils#print2</functionId>\n"
+                        + "    <enabledByDefault>true</enabledByDefault>\n"
+                        + "    <schemaVersion>10</schemaVersion>\n"
+                        + "  </AppFunctionStaticMetadata>\n"
+                        + "</appfunctions>");
+
+        Map<String, AppFunctionStaticMetadata> appFunctions =
+                mParser.parseIntoMapForGivenSchemas(
+                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
+
+        assertThat(appFunctions).hasSize(2);
+        assertThat(appFunctions).containsKey("com.example.utils#print1");
+        assertThat(appFunctions).containsKey("com.example.utils#print2");
+    }
+
+    @Test
+    public void parseIntoMapForGivenSchemas_malformedXml_returnsEmptyMap() throws Exception {
+        setXmlInput(
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<appfunctions>\n"
+                        + "  <AppFunctionStaticMetadata>\n"
+                        + "    <functionId>com.example.utils#print</functionId>\n"
+                        + "    <enabledByDefault>true</enabledByDefault>\n"
+                        + "    <schemaVersion>10</schemaVersion>\n"
+                        + "  </AppFunctionStaticMetadata>\n"
+                        + "  <AppFunctionStaticMetadata>\n"
+                        + "    <functionId>com.example.utils#print2</functionId>\n"
+                        + "    <enabledByDefault>true</enabledByDefault>\n"
+                        + "    <schemaVersion>10</schemaVersion>\n"
+                        + "</appfunctions>");
+
+        Map<String, AppFunctionStaticMetadata> appFunctions =
+                mParser.parseIntoMapForGivenSchemas(
+                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
+
+        assertThat(appFunctions).isEmpty();
+    }
+
+    @Test
+    public void parseIntoMapForGivenSchemas_exceedMaxNumAppFunctions_parsesOnlyMaxNumAppFunctions()
+            throws Exception {
+        setXmlInput(
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<appfunctions>\n"
+                        + "  <AppFunctionStaticMetadata>\n"
+                        + "    <functionId>com.example.utils#print1</functionId>\n"
+                        + "    <enabledByDefault>true</enabledByDefault>\n"
+                        + "    <schemaVersion>10</schemaVersion>\n"
+                        + "  </AppFunctionStaticMetadata>\n"
+                        + "  <AppFunctionStaticMetadata>\n"
+                        + "    <functionId>com.example.utils#print2</functionId>\n"
+                        + "    <enabledByDefault>true</enabledByDefault>\n"
+                        + "    <schemaVersion>10</schemaVersion>\n"
+                        + "  </AppFunctionStaticMetadata>\n"
+                        + "  <AppFunctionStaticMetadata>\n"
+                        + "    <functionId>com.example.utils#print3</functionId>\n"
+                        + "    <enabledByDefault>true</enabledByDefault>\n"
+                        + "    <schemaVersion>10</schemaVersion>\n"
+                        + "  </AppFunctionStaticMetadata>\n"
+                        + "</appfunctions>");
+
+        Map<String, AppFunctionStaticMetadata> appFunctions =
+                mParser.parseIntoMapForGivenSchemas(
+                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
+
+        assertThat(appFunctions).hasSize(2);
+        assertThat(appFunctions).containsKey("com.example.utils#print1");
+        assertThat(appFunctions).containsKey("com.example.utils#print2");
+    }
+
+    @Test
+    public void parseIntoMapForGivenSchemas_singleAppFunctionWithDocumentProperties()
+            throws Exception {
+        setXmlInput(
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<appfunctions>\n"
+                        + "  <AppFunctionStaticMetadata>\n"
+                        + "    <functionId>com.example.utils#print</functionId>\n"
+                        + "    <appFunctionParameterMetadata>\n"
+                        + "      <parameterName>test</parameterName>\n"
+                        + "    </appFunctionParameterMetadata>\n"
+                        + "  </AppFunctionStaticMetadata>\n"
+                        + "</appfunctions>");
+
+        Map<String, AppFunctionStaticMetadata> appFunctions =
+                mParser.parseIntoMapForGivenSchemas(
+                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
+
+        assertThat(appFunctions).hasSize(1);
+        assertThat(appFunctions).containsKey("com.example.utils#print");
+        AppFunctionStaticMetadata actualAppFunction = appFunctions.get("com.example.utils#print");
+        assertThat(actualAppFunction.getPropertyString("functionId"))
+                .isEqualTo("com.example.utils#print");
+        assertThat(
+                        actualAppFunction.getPropertyString(
+                                "appFunctionParameterMetadata.parameterName"))
+                .isEqualTo("test");
+    }
+
+    @Test
+    public void parseIntoMapForGivenSchemas_singleAppFunctionWithRepeatedProperties()
+            throws Exception {
+        setXmlInput(
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<appfunctions>\n"
+                        + "  <AppFunctionStaticMetadata>\n"
+                        + "    <functionId>com.example.utils#print</functionId>\n"
+                        + "    <appFunctionParameterMetadata>\n"
+                        + "      <parameterName>test1</parameterName>\n"
+                        + "      <parameterName>test2</parameterName>\n"
+                        + "    </appFunctionParameterMetadata>\n"
+                        + "    <appFunctionParameterMetadata>\n"
+                        + "      <parameterName>test3</parameterName>\n"
+                        + "    </appFunctionParameterMetadata>\n"
+                        + "  </AppFunctionStaticMetadata>\n"
+                        + "</appfunctions>");
+
+        Map<String, AppFunctionStaticMetadata> appFunctions =
+                mParser.parseIntoMapForGivenSchemas(
+                        mPackageManager, TEST_PACKAGE_NAME, TEST_XML_ASSET_FILE_PATH, TEST_SCHEMAS);
+
+        assertThat(appFunctions).hasSize(1);
+        assertThat(appFunctions).containsKey("com.example.utils#print");
+        AppFunctionStaticMetadata actualAppFunction = appFunctions.get("com.example.utils#print");
+        assertThat(actualAppFunction.getPropertyString("functionId"))
+                .isEqualTo("com.example.utils#print");
+        assertThat(
+                        Arrays.asList(
+                                actualAppFunction.getPropertyStringArray(
+                                        "appFunctionParameterMetadata[0].parameterName")))
+                .containsExactly("test1", "test2");
+        assertThat(
+                        Arrays.asList(
+                                actualAppFunction.getPropertyStringArray(
+                                        "appFunctionParameterMetadata[1].parameterName")))
+                .containsExactly("test3");
+    }
 }
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerImplTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerImplTest.java
new file mode 100644
index 00000000..3f98ed79
--- /dev/null
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerImplTest.java
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.appsindexer;
+
+import static com.android.server.appsearch.appsindexer.TestUtils.createIndividualUsageEvent;
+import static com.android.server.appsearch.appsindexer.TestUtils.removeFakeAppOpenEventDocuments;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertThrows;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.Mockito.when;
+
+import android.app.appsearch.exceptions.AppSearchException;
+import android.app.usage.UsageEvents;
+import android.app.usage.UsageStatsManager;
+import android.content.Context;
+import android.content.ContextWrapper;
+
+import androidx.test.core.app.ApplicationProvider;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+import org.mockito.Mockito;
+
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+public class AppOpenEventIndexerImplTest {
+    private AppSearchHelper mAppSearchHelper;
+    private final ExecutorService mSingleThreadedExecutor = Executors.newSingleThreadExecutor();
+    private Context mContext;
+    @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();
+
+    @Before
+    public void setUp() throws Exception {
+        mContext = ApplicationProvider.getApplicationContext();
+        mAppSearchHelper = new AppSearchHelper(mContext);
+        removeFakeAppOpenEventDocuments(mContext, mSingleThreadedExecutor);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        mAppSearchHelper.close();
+    }
+
+    @Test
+    public void testAppOpenEventIndexerImpl_updateAppsThrowsError_shouldContinueOnError()
+            throws Exception {
+        long currentTimeMillis = System.currentTimeMillis();
+        AppOpenEventIndexerSettings settings =
+                new AppOpenEventIndexerSettings(temporaryFolder.newFolder("tmp"));
+        settings.setLastUpdateTimestampMillis(currentTimeMillis + 100L);
+
+        UsageStatsManager usm = Mockito.mock(UsageStatsManager.class);
+        when(usm.queryEvents(anyLong(), anyLong()))
+                .thenThrow(new RuntimeException("AppSearchException"));
+
+        Context context =
+                new ContextWrapper(mContext) {
+                    @Override
+                    public Object getSystemService(String name) {
+                        if (name.equals(Context.USAGE_STATS_SERVICE)) {
+                            return usm;
+                        }
+                        return super.getSystemService(name);
+                    }
+                };
+
+        AppOpenEventIndexerImpl appOpenEventIndexerImpl = new AppOpenEventIndexerImpl(context);
+        assertThrows(Exception.class, () -> appOpenEventIndexerImpl.doUpdate(settings));
+        // Indexing did not succeed, so we should not be able to get any app open events
+        assertThrows(
+                AppSearchException.class,
+                () ->
+                        mAppSearchHelper.getSubsequentAppOpenEventAfterThreshold(
+                                currentTimeMillis + 100L));
+
+        // Settings unchanged on failed indexing
+        assertThat(settings.getLastUpdateTimestampMillis()).isEqualTo(currentTimeMillis + 100L);
+    }
+
+    @Test
+    public void testAppOpenEventIndexerImpl_updateApps_worksEndToEnd() throws Exception {
+        long currentTimeMillis = System.currentTimeMillis();
+        AppOpenEventIndexerSettings settings =
+                new AppOpenEventIndexerSettings(temporaryFolder.newFolder("tmp"));
+        settings.setLastUpdateTimestampMillis(currentTimeMillis);
+        UsageStatsManager usm = Mockito.mock(UsageStatsManager.class);
+
+        UsageEvents.Event[] events =
+                new UsageEvents.Event[] {
+                    createIndividualUsageEvent(
+                            UsageEvents.Event.MOVE_TO_FOREGROUND,
+                            currentTimeMillis + 1L,
+                            "com.example.package"),
+                };
+
+        UsageEvents mockUsageEvents = TestUtils.createUsageEvents(events);
+
+        when(usm.queryEvents(anyLong(), anyLong())).thenReturn(mockUsageEvents);
+
+        Context context =
+                new ContextWrapper(mContext) {
+                    @Override
+                    public Object getSystemService(String name) {
+                        if (name.equals(Context.USAGE_STATS_SERVICE)) {
+                            return usm;
+                        }
+                        return super.getSystemService(name);
+                    }
+                };
+
+        AppOpenEventIndexerImpl appOpenEventIndexerImpl = new AppOpenEventIndexerImpl(context);
+        appOpenEventIndexerImpl.doUpdate(settings);
+
+        assertThat(
+                        mAppSearchHelper
+                                .getSubsequentAppOpenEventAfterThreshold(currentTimeMillis)
+                                .getId())
+                .isEqualTo("com.example.package" + (currentTimeMillis + 1L));
+
+        // Settings updated on successful indexing
+        assertThat(settings.getLastUpdateTimestampMillis()).isGreaterThan(currentTimeMillis);
+    }
+}
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerMaintenanceTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerMaintenanceTest.java
new file mode 100644
index 00000000..304e7aae
--- /dev/null
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerMaintenanceTest.java
@@ -0,0 +1,371 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.appsindexer;
+
+import static android.Manifest.permission.RECEIVE_BOOT_COMPLETED;
+
+import static com.android.server.appsearch.appsindexer.AppOpenEventIndexerMaintenanceConfig.MIN_APP_OPEN_EVENT_INDEXER_JOB_ID;
+import static com.android.server.appsearch.indexer.IndexerMaintenanceConfig.APP_OPEN_EVENT_INDEXER;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyBoolean;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.doNothing;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyZeroInteractions;
+import static org.mockito.Mockito.when;
+
+import android.annotation.UserIdInt;
+import android.app.UiAutomation;
+import android.app.job.JobInfo;
+import android.app.job.JobParameters;
+import android.app.job.JobScheduler;
+import android.content.Context;
+import android.content.ContextWrapper;
+import android.content.pm.UserInfo;
+import android.os.CancellationSignal;
+import android.os.PersistableBundle;
+import android.os.UserHandle;
+
+import androidx.annotation.Nullable;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.platform.app.InstrumentationRegistry;
+
+import com.android.dx.mockito.inline.extended.ExtendedMockito;
+import com.android.server.LocalManagerRegistry;
+import com.android.server.SystemService;
+import com.android.server.appsearch.indexer.IndexerMaintenanceService;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+import org.mockito.MockitoSession;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+public class AppOpenEventIndexerMaintenanceTest {
+    private static final int DEFAULT_USER_ID = 0;
+    private static final UserHandle DEFAULT_USER_HANDLE = new UserHandle(DEFAULT_USER_ID);
+
+    private Context mContext = ApplicationProvider.getApplicationContext();
+    private Context mContextWrapper;
+    private IndexerMaintenanceService mAppOpenEventIndexerMaintenanceService;
+    private MockitoSession mSession;
+    @Mock private JobScheduler mMockJobScheduler;
+    private JobParameters mParams;
+    private PersistableBundle mExtras;
+
+    @Before
+    public void setUp() {
+        MockitoAnnotations.initMocks(this);
+        mContextWrapper =
+                new ContextWrapper(mContext) {
+                    @Override
+                    @Nullable
+                    public Object getSystemService(String name) {
+                        if (Context.JOB_SCHEDULER_SERVICE.equals(name)) {
+                            return mMockJobScheduler;
+                        }
+                        return getSystemService(name);
+                    }
+                };
+        mAppOpenEventIndexerMaintenanceService = spy(new IndexerMaintenanceService());
+        doNothing().when(mAppOpenEventIndexerMaintenanceService).jobFinished(any(), anyBoolean());
+        mSession =
+                ExtendedMockito.mockitoSession()
+                        .mockStatic(LocalManagerRegistry.class)
+                        .startMocking();
+        mExtras = new PersistableBundle();
+        mExtras.putInt("indexer_type", APP_OPEN_EVENT_INDEXER);
+        mParams = Mockito.mock(JobParameters.class);
+    }
+
+    @After
+    public void tearDown() {
+        mSession.finishMocking();
+        mAppOpenEventIndexerMaintenanceService.destroy();
+    }
+
+    @Test
+    public void testScheduleUpdateJob_oneOff_isNotPeriodic() {
+        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
+        try {
+            uiAutomation.adoptShellPermissionIdentity(RECEIVE_BOOT_COMPLETED);
+            IndexerMaintenanceService.scheduleUpdateJob(
+                    mContext,
+                    DEFAULT_USER_HANDLE,
+                    APP_OPEN_EVENT_INDEXER,
+                    /* periodic= */ false,
+                    /* intervalMillis= */ -1);
+        } finally {
+            uiAutomation.dropShellPermissionIdentity();
+        }
+        JobInfo jobInfo = getPendingUpdateJob(DEFAULT_USER_ID);
+        assertThat(jobInfo).isNotNull();
+        assertThat(jobInfo.isRequireBatteryNotLow()).isTrue();
+        assertThat(jobInfo.isRequireDeviceIdle()).isTrue();
+        assertThat(jobInfo.isPersisted()).isTrue();
+        assertThat(jobInfo.isPeriodic()).isFalse();
+    }
+
+    @Test
+    public void testScheduleUpdateJob_periodic_isPeriodic() {
+        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
+        try {
+            uiAutomation.adoptShellPermissionIdentity(RECEIVE_BOOT_COMPLETED);
+            IndexerMaintenanceService.scheduleUpdateJob(
+                    mContext,
+                    /* userId= */ DEFAULT_USER_HANDLE,
+                    /* indexerType= */ APP_OPEN_EVENT_INDEXER,
+                    /* periodic= */ true,
+                    /* intervalMillis= */ TimeUnit.DAYS.toMillis(7));
+        } finally {
+            uiAutomation.dropShellPermissionIdentity();
+        }
+        JobInfo jobInfo = getPendingUpdateJob(DEFAULT_USER_ID);
+        assertThat(jobInfo).isNotNull();
+        assertThat(jobInfo.isRequireBatteryNotLow()).isTrue();
+        assertThat(jobInfo.isRequireDeviceIdle()).isTrue();
+        assertThat(jobInfo.isPersisted()).isTrue();
+        assertThat(jobInfo.isPeriodic()).isTrue();
+        assertThat(jobInfo.getIntervalMillis()).isEqualTo(TimeUnit.DAYS.toMillis(7));
+        assertThat(jobInfo.getFlexMillis()).isEqualTo(TimeUnit.DAYS.toMillis(7) / 2);
+    }
+
+    @Test
+    public void testScheduleUpdateJob_oneOffThenPeriodic_isRescheduled() {
+        IndexerMaintenanceService.scheduleUpdateJob(
+                mContextWrapper,
+                DEFAULT_USER_HANDLE,
+                /* indexerType= */ APP_OPEN_EVENT_INDEXER,
+                /* periodic= */ false,
+                /* intervalMillis= */ -1);
+        ArgumentCaptor<JobInfo> firstJobInfoCaptor = ArgumentCaptor.forClass(JobInfo.class);
+        verify(mMockJobScheduler).schedule(firstJobInfoCaptor.capture());
+        JobInfo firstJobInfo = firstJobInfoCaptor.getValue();
+
+        when(mMockJobScheduler.getPendingJob(eq(MIN_APP_OPEN_EVENT_INDEXER_JOB_ID)))
+                .thenReturn(firstJobInfo);
+        IndexerMaintenanceService.scheduleUpdateJob(
+                mContextWrapper,
+                DEFAULT_USER_HANDLE,
+                /* indexerType= */ APP_OPEN_EVENT_INDEXER,
+                /* periodic= */ true,
+                /* intervalMillis= */ TimeUnit.DAYS.toMillis(7));
+        ArgumentCaptor<JobInfo> argumentCaptor = ArgumentCaptor.forClass(JobInfo.class);
+        verify(mMockJobScheduler, times(2)).schedule(argumentCaptor.capture());
+        List<JobInfo> jobInfos = argumentCaptor.getAllValues();
+        JobInfo jobInfo = jobInfos.get(1);
+        assertThat(jobInfo.isRequireBatteryNotLow()).isTrue();
+        assertThat(jobInfo.isRequireDeviceIdle()).isTrue();
+        assertThat(jobInfo.isPersisted()).isTrue();
+        assertThat(jobInfo.isPeriodic()).isTrue();
+        assertThat(jobInfo.getIntervalMillis()).isEqualTo(TimeUnit.DAYS.toMillis(7));
+    }
+
+    @Test
+    public void testScheduleUpdateJob_differentParams_isRescheduled() {
+        IndexerMaintenanceService.scheduleUpdateJob(
+                mContextWrapper,
+                DEFAULT_USER_HANDLE,
+                /* indexerType= */ APP_OPEN_EVENT_INDEXER,
+                /* periodic= */ true,
+                /* intervalMillis= */ TimeUnit.DAYS.toMillis(7));
+        ArgumentCaptor<JobInfo> firstJobInfoCaptor = ArgumentCaptor.forClass(JobInfo.class);
+        verify(mMockJobScheduler).schedule(firstJobInfoCaptor.capture());
+        JobInfo firstJobInfo = firstJobInfoCaptor.getValue();
+
+        when(mMockJobScheduler.getPendingJob(eq(MIN_APP_OPEN_EVENT_INDEXER_JOB_ID)))
+                .thenReturn(firstJobInfo);
+        IndexerMaintenanceService.scheduleUpdateJob(
+                mContextWrapper,
+                DEFAULT_USER_HANDLE,
+                /* indexerType= */ APP_OPEN_EVENT_INDEXER,
+                /* periodic= */ true,
+                /* intervalMillis= */ TimeUnit.DAYS.toMillis(30));
+        ArgumentCaptor<JobInfo> argumentCaptor = ArgumentCaptor.forClass(JobInfo.class);
+        // Mockito.verify() counts the number of occurrences from the beginning of the test.
+        // This verify() uses times(2) to also account for the call to JobScheduler.schedule() above
+        // where the first JobInfo is captured.
+        verify(mMockJobScheduler, times(2)).schedule(argumentCaptor.capture());
+        List<JobInfo> jobInfos = argumentCaptor.getAllValues();
+        JobInfo jobInfo = jobInfos.get(1);
+        assertThat(jobInfo.isRequireBatteryNotLow()).isTrue();
+        assertThat(jobInfo.isRequireDeviceIdle()).isTrue();
+        assertThat(jobInfo.isPersisted()).isTrue();
+        assertThat(jobInfo.isPeriodic()).isTrue();
+        assertThat(jobInfo.getIntervalMillis()).isEqualTo(TimeUnit.DAYS.toMillis(30));
+    }
+
+    @Test
+    public void testScheduleUpdateJob_sameParams_isNotRescheduled() {
+        IndexerMaintenanceService.scheduleUpdateJob(
+                mContextWrapper,
+                DEFAULT_USER_HANDLE,
+                /* indexerType= */ APP_OPEN_EVENT_INDEXER,
+                /* periodic= */ true,
+                /* intervalMillis= */ TimeUnit.DAYS.toMillis(7));
+        ArgumentCaptor<JobInfo> argumentCaptor = ArgumentCaptor.forClass(JobInfo.class);
+        verify(mMockJobScheduler).schedule(argumentCaptor.capture());
+        JobInfo firstJobInfo = argumentCaptor.getValue();
+
+        when(mMockJobScheduler.getPendingJob(eq(MIN_APP_OPEN_EVENT_INDEXER_JOB_ID)))
+                .thenReturn(firstJobInfo);
+        IndexerMaintenanceService.scheduleUpdateJob(
+                mContextWrapper,
+                DEFAULT_USER_HANDLE,
+                /* indexerType= */ APP_OPEN_EVENT_INDEXER,
+                /* periodic= */ true,
+                /* intervalMillis= */ TimeUnit.DAYS.toMillis(7));
+        // Mockito.verify() counts the number of occurrences from the beginning of the test.
+        // This verify() uses the default count of 1 (equivalent to times(1)) to account for the
+        // call to JobScheduler.schedule() above where the first JobInfo is captured.
+        verify(mMockJobScheduler).schedule(any(JobInfo.class));
+    }
+
+    @Test
+    public void testDoUpdateForUser_withInitializedLocalService_isSuccessful() {
+        when(mParams.getExtras()).thenReturn(mExtras);
+        ExtendedMockito.doReturn(Mockito.mock(AppOpenEventIndexerManagerService.LocalService.class))
+                .when(
+                        () ->
+                                LocalManagerRegistry.getManager(
+                                        AppOpenEventIndexerManagerService.LocalService.class));
+        boolean updateSucceeded =
+                mAppOpenEventIndexerMaintenanceService.doUpdateForUser(
+                        mContextWrapper, mParams, DEFAULT_USER_HANDLE, new CancellationSignal());
+        assertThat(updateSucceeded).isTrue();
+    }
+
+    @Test
+    public void testDoUpdateForUser_withUninitializedLocalService_failsGracefully() {
+        when(mParams.getExtras()).thenReturn(mExtras);
+        ExtendedMockito.doReturn(null)
+                .when(
+                        () ->
+                                LocalManagerRegistry.getManager(
+                                        AppOpenEventIndexerManagerService.LocalService.class));
+        boolean updateSucceeded =
+                mAppOpenEventIndexerMaintenanceService.doUpdateForUser(
+                        mContextWrapper, mParams, DEFAULT_USER_HANDLE, new CancellationSignal());
+        assertThat(updateSucceeded).isFalse();
+    }
+
+    @Test
+    public void testDoUpdateForUser_onEncounteringException_failsGracefully() {
+        when(mParams.getExtras()).thenReturn(mExtras);
+        AppOpenEventIndexerManagerService.LocalService mockService =
+                Mockito.mock(AppOpenEventIndexerManagerService.LocalService.class);
+        doThrow(RuntimeException.class)
+                .when(mockService)
+                .doUpdateForUser((UserHandle) any(), (CancellationSignal) any());
+        ExtendedMockito.doReturn(mockService)
+                .when(
+                        () ->
+                                LocalManagerRegistry.getManager(
+                                        AppOpenEventIndexerManagerService.LocalService.class));
+
+        boolean updateSucceeded =
+                mAppOpenEventIndexerMaintenanceService.doUpdateForUser(
+                        mContextWrapper, mParams, DEFAULT_USER_HANDLE, new CancellationSignal());
+
+        assertThat(updateSucceeded).isFalse();
+    }
+
+    @Test
+    public void testDoUpdateForUser_cancelsBackgroundJob_whenIndexerDisabled() {
+        when(mParams.getExtras()).thenReturn(mExtras);
+        ExtendedMockito.doReturn(null)
+                .when(
+                        () ->
+                                LocalManagerRegistry.getManager(
+                                        AppOpenEventIndexerManagerService.LocalService.class));
+
+        mAppOpenEventIndexerMaintenanceService.doUpdateForUser(
+                mContextWrapper, mParams, DEFAULT_USER_HANDLE, new CancellationSignal());
+
+        verify(mMockJobScheduler).cancel(MIN_APP_OPEN_EVENT_INDEXER_JOB_ID);
+    }
+
+    @Test
+    public void testDoUpdateForUser_doesNotCancelBackgroundJob_whenIndexerEnabled() {
+        when(mParams.getExtras()).thenReturn(mExtras);
+        ExtendedMockito.doReturn(Mockito.mock(AppOpenEventIndexerManagerService.LocalService.class))
+                .when(
+                        () ->
+                                LocalManagerRegistry.getManager(
+                                        AppOpenEventIndexerManagerService.LocalService.class));
+
+        mAppOpenEventIndexerMaintenanceService.doUpdateForUser(
+                mContextWrapper, mParams, DEFAULT_USER_HANDLE, new CancellationSignal());
+
+        verifyZeroInteractions(mMockJobScheduler);
+    }
+
+    @Test
+    public void testCancelPendingUpdateJob_succeeds() throws IOException {
+        UserInfo userInfo = new UserInfo(DEFAULT_USER_ID, /* name= */ "default", /* flags= */ 0);
+        SystemService.TargetUser user = new SystemService.TargetUser(userInfo);
+        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
+        try {
+            uiAutomation.adoptShellPermissionIdentity(RECEIVE_BOOT_COMPLETED);
+            IndexerMaintenanceService.scheduleUpdateJob(
+                    mContext,
+                    DEFAULT_USER_HANDLE,
+                    /* indexerType= */ APP_OPEN_EVENT_INDEXER,
+                    /* periodic= */ true,
+                    /* intervalMillis= */ TimeUnit.DAYS.toMillis(7));
+        } finally {
+            uiAutomation.dropShellPermissionIdentity();
+        }
+        JobInfo jobInfo = getPendingUpdateJob(DEFAULT_USER_ID);
+        assertThat(jobInfo).isNotNull();
+
+        IndexerMaintenanceService.cancelUpdateJobIfScheduled(
+                mContext, user.getUserHandle(), APP_OPEN_EVENT_INDEXER);
+
+        jobInfo = getPendingUpdateJob(DEFAULT_USER_ID);
+        assertThat(jobInfo).isNull();
+    }
+
+    @Test
+    public void test_onStartJob_handlesExceptionGracefully() {
+        mAppOpenEventIndexerMaintenanceService.onStartJob(mParams);
+    }
+
+    @Test
+    public void test_onStopJob_handlesExceptionGracefully() {
+        mAppOpenEventIndexerMaintenanceService.onStopJob(mParams);
+    }
+
+    @Nullable
+    private JobInfo getPendingUpdateJob(@UserIdInt int userId) {
+        int jobId = MIN_APP_OPEN_EVENT_INDEXER_JOB_ID + userId;
+        return mContext.getSystemService(JobScheduler.class).getPendingJob(jobId);
+    }
+}
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerRealDocumentsTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerRealDocumentsTest.java
new file mode 100644
index 00000000..418fce52
--- /dev/null
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerRealDocumentsTest.java
@@ -0,0 +1,181 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.server.appsearch.appsindexer;
+
+import static android.Manifest.permission.OBSERVE_APP_USAGE;
+import static android.Manifest.permission.PACKAGE_USAGE_STATS;
+
+import static com.android.server.appsearch.appsindexer.TestUtils.createFakeAppOpenEventsIndexerSession;
+import static com.android.server.appsearch.appsindexer.TestUtils.removeFakeAppOpenEventDocuments;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.app.UiAutomation;
+import android.app.appsearch.AppSearchEnvironmentFactory;
+import android.app.appsearch.AppSearchManager;
+import android.app.appsearch.AppSearchSessionShim;
+import android.app.appsearch.SearchResult;
+import android.app.appsearch.SearchSpec;
+import android.app.appsearch.SetSchemaRequest;
+import android.app.usage.UsageStatsManager;
+import android.content.Context;
+import android.content.ContextWrapper;
+import android.content.Intent;
+import android.content.pm.UserInfo;
+import android.os.CancellationSignal;
+import android.os.UserHandle;
+
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.platform.app.InstrumentationRegistry;
+
+import com.android.server.SystemService;
+import com.android.server.appsearch.appsindexer.appsearchtypes.AppOpenEvent;
+
+import junit.framework.Assert;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Integration tests for the AppOpenEventIndexer service to verify indexing and retrieval of app
+ * open events from the AppSearch service in a near-prod environment.
+ *
+ * <p>This test class performs the following:
+ *
+ * <ul>
+ *   <li>Sets up the testing environment with necessary permissions and mock AppSearch sessions.
+ *   <li>Opens an app to trigger the indexing of an app open event, performs search operations, and
+ *       verifies the indexing of recent app open events.
+ * </ul>
+ */
+public class AppOpenEventIndexerRealDocumentsTest {
+
+    protected Context mContext;
+    protected UserInfo mUserInfo;
+    protected UserHandle mUserHandle;
+    protected Context mUserContext;
+    protected UiAutomation mUiAutomation;
+
+    @Before
+    public void setUp() throws Exception {
+        mContext = new ContextWrapper(ApplicationProvider.getApplicationContext());
+        mUserInfo =
+                new UserInfo(
+                        mContext.getUser().getIdentifier(), /* name= */ "default", /* flags= */ 0);
+        mUserHandle = new SystemService.TargetUser(mUserInfo).getUserHandle();
+        mUserContext =
+                AppSearchEnvironmentFactory.getEnvironmentInstance()
+                        .createContextAsUser(mContext, mUserHandle);
+        AppOpenEventIndexerSettings appOpenEventIndexerSettings =
+                new AppOpenEventIndexerSettings(
+                        AppSearchEnvironmentFactory.getEnvironmentInstance()
+                                .getAppSearchDir(mUserContext, mUserHandle));
+        appOpenEventIndexerSettings.setLastUpdateTimestampMillis(System.currentTimeMillis());
+        removeFakeAppOpenEventDocuments(mContext, Executors.newSingleThreadExecutor());
+
+        mUiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
+        mUiAutomation.adoptShellPermissionIdentity(PACKAGE_USAGE_STATS, OBSERVE_APP_USAGE);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        try (AppSearchSessionShim db =
+                createFakeAppOpenEventsIndexerSession(
+                        ApplicationProvider.getApplicationContext(),
+                        Executors.newSingleThreadExecutor())) {
+            removeFakeAppOpenEventDocuments(mContext, Executors.newSingleThreadExecutor());
+            db.setSchemaAsync(new SetSchemaRequest.Builder().setForceOverride(true).build()).get();
+        } finally {
+            mUiAutomation.dropShellPermissionIdentity();
+        }
+    }
+
+    @Test
+    public void testRealDocuments_check() throws Exception {
+        Intent launchIntent =
+                mContext.getPackageManager().getLaunchIntentForPackage(mContext.getPackageName());
+        Assert.assertNotNull(launchIntent);
+        launchIntent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
+        mContext.startActivity(launchIntent);
+
+        UsageStatsManager usageStatsManager = mContext.getSystemService(UsageStatsManager.class);
+
+        CountDownLatch latch = new CountDownLatch(1);
+        AppOpenEventIndexerManagerService appOpenEventIndexerManagerService =
+                new AppOpenEventIndexerManagerService(
+                        mContext, new TestAppOpenEventIndexerConfig(), latch::countDown);
+        appOpenEventIndexerManagerService.mLocalService.doUpdateForUser(
+                new SystemService.TargetUser(mUserInfo).getUserHandle(), new CancellationSignal());
+        assertThat(latch.await(10, TimeUnit.SECONDS)).isEqualTo(true);
+
+        // Search for most recently opened app open event
+        SearchSpec searchSpec =
+                new SearchSpec.Builder()
+                        .addFilterNamespaces(AppOpenEvent.APP_OPEN_EVENT_NAMESPACE)
+                        .setOrder(SearchSpec.ORDER_DESCENDING)
+                        .setRankingStrategy(SearchSpec.RANKING_STRATEGY_CREATION_TIMESTAMP)
+                        .build();
+        AppSearchManager manager =
+                ApplicationProvider.getApplicationContext()
+                        .getSystemService(AppSearchManager.class);
+        Executor executor =
+                AppSearchEnvironmentFactory.getEnvironmentInstance().createSingleThreadExecutor();
+        SyncGlobalSearchSession globalSearchSession =
+                new SyncGlobalSearchSessionImpl(manager, executor);
+        SyncSearchResults searchResults = globalSearchSession.search("", searchSpec);
+        List<SearchResult> results = searchResults.getNextPage();
+
+        for (int i = 0; i < results.size(); i++) {
+            assertThat(results.get(i).getGenericDocument().getSchemaType())
+                    .startsWith(AppOpenEvent.SCHEMA_TYPE);
+        }
+
+        long currentTimeMillis = System.currentTimeMillis();
+        boolean hasMatchingResult = false;
+
+        // Validate that a very recent app open event is for the package we opened. It appears
+        // the emulator has other app open events on the query events API that aren't from the test,
+        // so ignore those.
+        for (SearchResult result : results) {
+            String packageName =
+                    result.getGenericDocument()
+                            .getPropertyString(AppOpenEvent.APP_OPEN_EVENT_PROPERTY_PACKAGE_NAME);
+
+            Long timestampMillis =
+                    result.getGenericDocument()
+                            .getPropertyLong(
+                                    AppOpenEvent.APP_OPEN_EVENT_PROPERTY_APP_OPEN_TIMESTAMP_MILLIS);
+
+            if (packageName != null
+                    && timestampMillis != null
+                    && mContext.getPackageName().equals(packageName)
+                    && (currentTimeMillis - timestampMillis) <= TimeUnit.SECONDS.toMillis(30)) {
+                hasMatchingResult = true;
+                break;
+            }
+        }
+
+        // Assert that the matching result exists
+        assertThat(hasMatchingResult).isTrue();
+    }
+}
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerUserInstanceTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerUserInstanceTest.java
new file mode 100644
index 00000000..2379c633
--- /dev/null
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppOpenEventIndexerUserInstanceTest.java
@@ -0,0 +1,222 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.appsindexer;
+
+import static com.android.server.appsearch.appsindexer.TestUtils.createIndividualUsageEvent;
+import static com.android.server.appsearch.appsindexer.TestUtils.createUsageEvents;
+import static com.android.server.appsearch.appsindexer.TestUtils.setupMockUsageStatsManager;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertThrows;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import android.annotation.Nullable;
+import android.app.appsearch.exceptions.AppSearchException;
+import android.app.job.JobInfo;
+import android.app.job.JobScheduler;
+import android.app.usage.UsageEvents;
+import android.app.usage.UsageEvents.Event;
+import android.app.usage.UsageStatsManager;
+import android.content.Context;
+import android.content.ContextWrapper;
+
+import androidx.test.core.app.ApplicationProvider;
+
+import com.android.server.appsearch.appsindexer.appsearchtypes.AppOpenEvent;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+import org.mockito.ArgumentCaptor;
+
+import java.io.File;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+public class AppOpenEventIndexerUserInstanceTest {
+    private TestContext mContext;
+    private final UsageStatsManager mMockUsageStatsManager = mock(UsageStatsManager.class);
+
+    @Rule public TemporaryFolder mTemporaryFolder = new TemporaryFolder();
+
+    private ExecutorService mSingleThreadedExecutor;
+    private File mAppsDir;
+    private AppOpenEventIndexerUserInstance mInstance;
+    private AppOpenEventIndexerConfig mAppOpenEventIndexerConfig =
+            new TestAppOpenEventIndexerConfig();
+
+    class TestContext extends ContextWrapper {
+        @Nullable JobScheduler mJobScheduler;
+
+        TestContext(Context base) {
+            super(base);
+        }
+
+        public void setJobScheduler(@Nullable JobScheduler jobScheduler) {
+            mJobScheduler = jobScheduler;
+        }
+
+        @Override
+        public Object getSystemService(String name) {
+            if (name.equals(Context.USAGE_STATS_SERVICE)) {
+                return mMockUsageStatsManager;
+            }
+            if (mJobScheduler != null && Context.JOB_SCHEDULER_SERVICE.equals(name)) {
+                return mJobScheduler;
+            }
+            return super.getSystemService(name);
+        }
+    }
+
+    @Before
+    public void setUp() throws Exception {
+        Context context = ApplicationProvider.getApplicationContext();
+
+        mContext = new TestContext(context);
+
+        mSingleThreadedExecutor = Executors.newSingleThreadExecutor();
+
+        // Setup the file path to the persisted data
+        mAppsDir = new File(mTemporaryFolder.newFolder(), "app-open-events");
+        mInstance =
+                AppOpenEventIndexerUserInstance.createInstance(
+                        mContext, mAppsDir, mAppOpenEventIndexerConfig, mSingleThreadedExecutor);
+        TestUtils.removeFakeAppOpenEventDocuments(mContext, mSingleThreadedExecutor);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+        mSingleThreadedExecutor.shutdown();
+        mInstance.shutdown();
+    }
+
+    @Test
+    public void testFirstRun_schedulesUpdate() throws Exception {
+        long currentTimeMillis = System.currentTimeMillis();
+
+        mInstance =
+                AppOpenEventIndexerUserInstance.createInstance(
+                        mContext, mAppsDir, mAppOpenEventIndexerConfig, mSingleThreadedExecutor);
+
+        Event event =
+                createIndividualUsageEvent(
+                        UsageEvents.Event.MOVE_TO_FOREGROUND,
+                        currentTimeMillis + 1000L,
+                        "com.fake.package");
+        UsageEvents events = createUsageEvents(event);
+        CountDownLatch latch = new CountDownLatch(1);
+        setupMockUsageStatsManager(mMockUsageStatsManager, events);
+
+        mInstance.updateAsync(latch::countDown);
+        assertThat(latch.await(1, TimeUnit.SECONDS)).isTrue();
+
+        AppSearchHelper appSearchHelper = new AppSearchHelper(mContext);
+        AppOpenEvent appOpenEvent =
+                appSearchHelper.getSubsequentAppOpenEventAfterThreshold(currentTimeMillis + 100);
+        assertThat(appOpenEvent.getId())
+                .isEqualTo("com.fake.package" + (currentTimeMillis + 1000L));
+    }
+
+    @Test
+    public void testSecondRun_noOpOnSecondUpdate() throws Exception {
+        long currentTimeMillis = System.currentTimeMillis();
+        mInstance =
+                AppOpenEventIndexerUserInstance.createInstance(
+                        mContext, mAppsDir, mAppOpenEventIndexerConfig, mSingleThreadedExecutor);
+
+        Event event =
+                createIndividualUsageEvent(
+                        UsageEvents.Event.MOVE_TO_FOREGROUND,
+                        currentTimeMillis + 1000L,
+                        "com.fake.package");
+
+        UsageEvents events = createUsageEvents(event);
+        CountDownLatch latch1 = new CountDownLatch(1);
+        CountDownLatch latch2 = new CountDownLatch(1);
+
+        setupMockUsageStatsManager(mMockUsageStatsManager, events);
+
+        mInstance.updateAsync(latch1::countDown);
+        assertThat(latch1.await(1, TimeUnit.SECONDS)).isTrue();
+
+        AppSearchHelper appSearchHelper = new AppSearchHelper(mContext);
+        AppOpenEvent appOpenEvent =
+                appSearchHelper.getSubsequentAppOpenEventAfterThreshold(currentTimeMillis + 100);
+        assertThat(appOpenEvent.getId())
+                .isEqualTo("com.fake.package" + (currentTimeMillis + 1000L));
+
+        mInstance.updateAsync(latch2::countDown);
+        assertThat(latch2.await(1, TimeUnit.SECONDS)).isTrue();
+
+        event =
+                createIndividualUsageEvent(
+                        UsageEvents.Event.MOVE_TO_FOREGROUND,
+                        currentTimeMillis + 2000L,
+                        "com.fake.package");
+
+        events = createUsageEvents(event);
+        setupMockUsageStatsManager(mMockUsageStatsManager, events);
+
+        assertThrows(
+                AppSearchException.class,
+                () ->
+                        appSearchHelper.getSubsequentAppOpenEventAfterThreshold(
+                                currentTimeMillis + 1500L));
+        AppOpenEvent appOpenEvent2 =
+                appSearchHelper.getSubsequentAppOpenEventAfterThreshold(currentTimeMillis + 100L);
+        assertThat(appOpenEvent2.getId())
+                .isEqualTo("com.fake.package" + (currentTimeMillis + 1000L)); // Unchanged
+    }
+
+    @Test
+    public void testStart_initialRun_schedulesUpdateJob() throws Exception {
+        long currentTimeMillis = System.currentTimeMillis();
+        JobScheduler mockJobScheduler = mock(JobScheduler.class);
+        mContext.setJobScheduler(mockJobScheduler);
+
+        mInstance =
+                AppOpenEventIndexerUserInstance.createInstance(
+                        mContext, mAppsDir, mAppOpenEventIndexerConfig, mSingleThreadedExecutor);
+
+        Event event =
+                createIndividualUsageEvent(
+                        UsageEvents.Event.MOVE_TO_FOREGROUND,
+                        currentTimeMillis + 1000L,
+                        "com.fake.package");
+        UsageEvents events = createUsageEvents(event);
+        setupMockUsageStatsManager(mMockUsageStatsManager, events);
+
+        CountDownLatch latch = new CountDownLatch(1);
+        mInstance.updateAsync(latch::countDown);
+
+        assertThat(latch.await(1, TimeUnit.SECONDS)).isTrue();
+
+        ArgumentCaptor<JobInfo> jobInfoArgumentCaptor = ArgumentCaptor.forClass(JobInfo.class);
+        verify(mockJobScheduler).schedule(jobInfoArgumentCaptor.capture());
+        JobInfo updateJob = jobInfoArgumentCaptor.getValue();
+        assertThat(updateJob.isRequireBatteryNotLow()).isTrue();
+        assertThat(updateJob.isRequireDeviceIdle()).isTrue();
+        assertThat(updateJob.isPersisted()).isTrue();
+        assertThat(updateJob.isPeriodic()).isTrue();
+    }
+}
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppSearchHelperTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppSearchHelperTest.java
index 16a043b2..9a268111 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppSearchHelperTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppSearchHelperTest.java
@@ -16,34 +16,45 @@
 
 package com.android.server.appsearch.appsindexer;
 
+import static com.android.server.appsearch.appsindexer.TestUtils.COMPATIBLE_APP_OPEN_EVENT_SCHEMA;
 import static com.android.server.appsearch.appsindexer.TestUtils.COMPATIBLE_APP_SCHEMA;
 import static com.android.server.appsearch.appsindexer.TestUtils.FAKE_PACKAGE_PREFIX;
 import static com.android.server.appsearch.appsindexer.TestUtils.FAKE_SIGNATURE;
+import static com.android.server.appsearch.appsindexer.TestUtils.INCOMPATIBLE_APP_OPEN_EVENT_SCHEMA;
 import static com.android.server.appsearch.appsindexer.TestUtils.INCOMPATIBLE_APP_SCHEMA;
 import static com.android.server.appsearch.appsindexer.TestUtils.createFakeAppFunction;
 import static com.android.server.appsearch.appsindexer.TestUtils.createFakeAppIndexerSession;
+import static com.android.server.appsearch.appsindexer.TestUtils.createFakeAppOpenEvent;
+import static com.android.server.appsearch.appsindexer.TestUtils.createFakeAppOpenEventsIndexerSession;
 import static com.android.server.appsearch.appsindexer.TestUtils.createFakeMobileApplication;
 import static com.android.server.appsearch.appsindexer.TestUtils.createMobileApplications;
 import static com.android.server.appsearch.appsindexer.TestUtils.createMockPackageIdentifier;
 import static com.android.server.appsearch.appsindexer.TestUtils.createMockPackageIdentifiers;
+import static com.android.server.appsearch.appsindexer.TestUtils.removeFakeAppOpenEventDocuments;
 import static com.android.server.appsearch.appsindexer.TestUtils.removeFakePackageDocuments;
 import static com.android.server.appsearch.appsindexer.TestUtils.searchAppSearchForApps;
+import static com.android.server.appsearch.appsindexer.appsearchtypes.AppOpenEvent.APP_OPEN_EVENT_PROPERTY_MOBILE_APPLICATION_QUALIFIED_ID;
+import static com.android.server.appsearch.appsindexer.appsearchtypes.AppOpenEvent.APP_OPEN_EVENT_PROPERTY_PACKAGE_NAME;
 
 import static com.google.common.truth.Truth.assertThat;
 
 import static org.junit.Assert.assertThrows;
+import static org.junit.Assume.assumeTrue;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.when;
 
 import android.app.appsearch.AppSearchBatchResult;
+import android.app.appsearch.AppSearchManager;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.AppSearchSchema;
 import android.app.appsearch.AppSearchSessionShim;
 import android.app.appsearch.GenericDocument;
 import android.app.appsearch.GetSchemaResponse;
+import android.app.appsearch.JoinSpec;
 import android.app.appsearch.PackageIdentifier;
 import android.app.appsearch.PutDocumentsRequest;
 import android.app.appsearch.SearchResult;
+import android.app.appsearch.SearchSpec;
 import android.app.appsearch.SetSchemaRequest;
 import android.app.appsearch.exceptions.AppSearchException;
 import android.content.Context;
@@ -51,6 +62,7 @@ import android.content.Context;
 import androidx.test.core.app.ApplicationProvider;
 
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionStaticMetadata;
+import com.android.server.appsearch.appsindexer.appsearchtypes.AppOpenEvent;
 import com.android.server.appsearch.appsindexer.appsearchtypes.MobileApplication;
 
 import com.google.common.collect.ImmutableList;
@@ -84,6 +96,7 @@ public class AppSearchHelperTest {
     @After
     public void tearDown() throws Exception {
         removeFakePackageDocuments(mContext, mSingleThreadedExecutor);
+        removeFakeAppOpenEventDocuments(mContext, mSingleThreadedExecutor);
         mAppSearchHelper.close();
     }
 
@@ -93,7 +106,8 @@ public class AppSearchHelperTest {
         mAppSearchHelper.indexApps(
                 createMobileApplications(1),
                 /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of());
+                /* existingAppFunctions= */ ImmutableList.of(),
+                /* appsUpdateStats= */ new AppsUpdateStats());
 
         AppSearchSessionShim session =
                 createFakeAppIndexerSession(mContext, mSingleThreadedExecutor);
@@ -120,14 +134,19 @@ public class AppSearchHelperTest {
         mAppSearchHelper.indexApps(
                 createMobileApplications(1),
                 /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of());
+                /* existingAppFunctions= */ ImmutableList.of(),
+                /* appsUpdateStats= */
+                /* appsUpdateStats= */ new AppsUpdateStats());
 
         AppSearchSessionShim session =
                 createFakeAppIndexerSession(mContext, mSingleThreadedExecutor);
         GetSchemaResponse response = session.getSchemaAsync().get();
 
-        assertThat(response.getSchemas().stream().map(AppSearchSchema::getSchemaType).toList())
-                .doesNotContain(AppFunctionStaticMetadata.SCHEMA_TYPE);
+        List<String> schemaTypes = new ArrayList<>();
+        for (AppSearchSchema schema : response.getSchemas()) {
+            schemaTypes.add(schema.getSchemaType());
+        }
+        assertThat(schemaTypes).doesNotContain(AppFunctionStaticMetadata.SCHEMA_TYPE);
     }
 
     @Test
@@ -137,7 +156,8 @@ public class AppSearchHelperTest {
         mAppSearchHelper.indexApps(
                 createMobileApplications(600),
                 /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of());
+                /* existingAppFunctions= */ ImmutableList.of(),
+                /* appsUpdateStats= */ new AppsUpdateStats());
         Map<String, Long> appsearchIds = mAppSearchHelper.getAppsFromAppSearch();
         assertThat(appsearchIds.size()).isEqualTo(600);
         List<SearchResult> real = searchAppSearchForApps(600 + 1);
@@ -164,7 +184,8 @@ public class AppSearchHelperTest {
         appSearchHelper.indexApps(
                 ImmutableList.of(createFakeMobileApplication(variant)),
                 /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of());
+                /* existingAppFunctions= */ ImmutableList.of(),
+                /* appsUpdateStats= */ new AppsUpdateStats());
 
         assertThat(appSearchHelper).isNotNull();
         List<SearchResult> results = searchAppSearchForApps(1 + 1);
@@ -173,7 +194,34 @@ public class AppSearchHelperTest {
     }
 
     @Test
-    public void testIndexApps_incompatibleSchemaChange() throws Exception {
+    public void testIndexAppOpenEvents_compatibleSchemaChange() throws Exception {
+        SetSchemaRequest setSchemaRequest =
+                new SetSchemaRequest.Builder()
+                        .addSchemas(COMPATIBLE_APP_OPEN_EVENT_SCHEMA)
+                        .setForceOverride(true)
+                        .build();
+
+        long currentTimeMillis = System.currentTimeMillis();
+
+        AppSearchSessionShim session =
+                createFakeAppOpenEventsIndexerSession(mContext, mSingleThreadedExecutor);
+        session.setSchemaAsync(setSchemaRequest).get();
+
+        AppSearchHelper appSearchHelper = new AppSearchHelper(mContext);
+        appSearchHelper.setSchemaForAppOpenEvents();
+        AppOpenEvent fakeAppOpenEvent = createFakeAppOpenEvent(currentTimeMillis);
+        appSearchHelper.indexAppOpenEvents(ImmutableList.of(fakeAppOpenEvent));
+
+        assertThat(appSearchHelper).isNotNull();
+        AppOpenEvent appOpenEvent =
+                appSearchHelper.getSubsequentAppOpenEventAfterThreshold(currentTimeMillis - 100L);
+        assertThat(appOpenEvent.getPackageName()).isEqualTo(fakeAppOpenEvent.getPackageName());
+        assertThat(appOpenEvent.getAppOpenEventTimestampMillis())
+                .isEqualTo(fakeAppOpenEvent.getAppOpenEventTimestampMillis());
+    }
+
+    @Test
+    public void testIndexApps_incompatibleSchemaChange_canBeIndexedOver() throws Exception {
         AppSearchSessionShim session =
                 createFakeAppIndexerSession(mContext, mSingleThreadedExecutor);
 
@@ -189,12 +237,83 @@ public class AppSearchHelperTest {
         mAppSearchHelper.indexApps(
                 createMobileApplications(50),
                 /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of());
+                /* existingAppFunctions= */ ImmutableList.of(),
+                /* appsUpdateStats= */ new AppsUpdateStats());
 
         List<SearchResult> real = searchAppSearchForApps(50 + 1);
         assertThat(real).hasSize(50);
     }
 
+    @Test
+    public void testIndexApps_incompatibleSchemaChange_wipesOutDatabase() throws Exception {
+        AppSearchSessionShim session =
+                createFakeAppIndexerSession(mContext, mSingleThreadedExecutor);
+
+        // Set incompatible schemas that would be removed
+        SetSchemaRequest setSchemaRequest =
+                new SetSchemaRequest.Builder()
+                        .addSchemas(INCOMPATIBLE_APP_SCHEMA)
+                        .setForceOverride(true)
+                        .build();
+        session.setSchemaAsync(setSchemaRequest).get();
+
+        mAppSearchHelper.setSchemasForPackages(createMockPackageIdentifiers(50), new ArrayList<>());
+        List<SearchResult> real = searchAppSearchForApps(50 + 1);
+        assertThat(real).hasSize(0);
+    }
+
+    @Test
+    public void testIndexAppOpenEvents_incompatibleSchemaChange_canBeIndexedOver()
+            throws Exception {
+        SetSchemaRequest setSchemaRequest =
+                new SetSchemaRequest.Builder()
+                        .addSchemas(INCOMPATIBLE_APP_OPEN_EVENT_SCHEMA)
+                        .setForceOverride(true)
+                        .build();
+
+        long currentTimeMillis = System.currentTimeMillis();
+
+        AppSearchSessionShim session =
+                createFakeAppOpenEventsIndexerSession(mContext, mSingleThreadedExecutor);
+        // Set incompatible schemas that would be removed
+        session.setSchemaAsync(setSchemaRequest).get();
+
+        AppSearchHelper appSearchHelper = new AppSearchHelper(mContext);
+        appSearchHelper.setSchemaForAppOpenEvents();
+        AppOpenEvent fakeAppOpenEvent = createFakeAppOpenEvent(currentTimeMillis);
+        appSearchHelper.indexAppOpenEvents(
+                ImmutableList.of(createFakeAppOpenEvent(currentTimeMillis)));
+
+        assertThat(appSearchHelper).isNotNull();
+        AppOpenEvent appOpenEvent =
+                appSearchHelper.getSubsequentAppOpenEventAfterThreshold(currentTimeMillis - 100L);
+        assertThat(appOpenEvent.getPackageName()).isEqualTo(fakeAppOpenEvent.getPackageName());
+        assertThat(appOpenEvent.getAppOpenEventTimestampMillis())
+                .isEqualTo(fakeAppOpenEvent.getAppOpenEventTimestampMillis());
+    }
+
+    @Test
+    public void testIndexAppOpenEvents_incompatibleSchemaChange_wipesOutDatabase()
+            throws Exception {
+        SetSchemaRequest setSchemaRequest =
+                new SetSchemaRequest.Builder()
+                        .addSchemas(INCOMPATIBLE_APP_OPEN_EVENT_SCHEMA)
+                        .setForceOverride(true)
+                        .build();
+
+        AppSearchSessionShim session =
+                createFakeAppOpenEventsIndexerSession(mContext, mSingleThreadedExecutor);
+        // Set incompatible schemas that would be removed
+        session.setSchemaAsync(setSchemaRequest).get();
+
+        AppSearchHelper appSearchHelper = new AppSearchHelper(mContext);
+        appSearchHelper.setSchemaForAppOpenEvents();
+        assertThat(appSearchHelper).isNotNull();
+        assertThrows(
+                AppSearchException.class,
+                () -> appSearchHelper.getSubsequentAppOpenEventAfterThreshold(100L));
+    }
+
     @Test
     public void testIndexApps_outOfSpace_shouldNotCompleteNormally() throws Exception {
         // set up AppSearchSession#put to invoke the callback with a RESULT_OUT_OF_SPACE failure
@@ -216,7 +335,8 @@ public class AppSearchHelperTest {
                         mocked.indexApps(
                                 ImmutableList.of(createFakeMobileApplication(0)),
                                 /* appFunctions= */ ImmutableList.of(),
-                                /* existingAppFunctions= */ ImmutableList.of()));
+                                /* existingAppFunctions= */ ImmutableList.of(),
+                                /* appsUpdateStats= */ new AppsUpdateStats()));
     }
 
     @Test
@@ -226,7 +346,8 @@ public class AppSearchHelperTest {
         mAppSearchHelper.indexApps(
                 createMobileApplications(100),
                 /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of());
+                /* existingAppFunctions= */ ImmutableList.of(),
+                /* appsUpdateStats= */ new AppsUpdateStats());
 
         mAppSearchHelper.setSchemasForPackages(createMockPackageIdentifiers(50), new ArrayList<>());
 
@@ -251,7 +372,8 @@ public class AppSearchHelperTest {
         mAppSearchHelper.indexApps(
                 ImmutableList.of(app0, app1),
                 /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of());
+                /* existingAppFunctions= */ ImmutableList.of(),
+                /* appsUpdateStats= */ new AppsUpdateStats());
         Map<String, Long> timestampMapping = mAppSearchHelper.getAppsFromAppSearch();
         assertThat(timestampMapping)
                 .containsExactly("com.fake.package0", 0L, "com.fake.package1", 1L);
@@ -260,7 +382,8 @@ public class AppSearchHelperTest {
         mAppSearchHelper.indexApps(
                 ImmutableList.of(app0, app1),
                 /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of());
+                /* existingAppFunctions= */ ImmutableList.of(),
+                /* appsUpdateStats= */ new AppsUpdateStats());
 
         // Should still be two
         timestampMapping = mAppSearchHelper.getAppsFromAppSearch();
@@ -277,7 +400,8 @@ public class AppSearchHelperTest {
         mAppSearchHelper.indexApps(
                 ImmutableList.of(app0, app1),
                 /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of());
+                /* existingAppFunctions= */ ImmutableList.of(),
+                /* appsUpdateStats= */ new AppsUpdateStats());
         Map<String, Long> timestampMapping = mAppSearchHelper.getAppsFromAppSearch();
         assertThat(timestampMapping)
                 .containsExactly("com.fake.package0", 0L, "com.fake.package1", 1L);
@@ -296,7 +420,8 @@ public class AppSearchHelperTest {
         mAppSearchHelper.indexApps(
                 ImmutableList.of(app1),
                 /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of());
+                /* existingAppFunctions= */ ImmutableList.of(),
+                /* appsUpdateStats= */ new AppsUpdateStats());
         timestampMapping = mAppSearchHelper.getAppsFromAppSearch();
         assertThat(timestampMapping)
                 .containsExactly("com.fake.package0", 0L, "com.fake.package1", 300L);
@@ -311,7 +436,8 @@ public class AppSearchHelperTest {
         mAppSearchHelper.indexApps(
                 ImmutableList.of(app0, app1),
                 /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of());
+                /* existingAppFunctions= */ ImmutableList.of(),
+                /* appsUpdateStats= */ new AppsUpdateStats());
         assertThat(mAppSearchHelper.getAppsFromAppSearch()).hasSize(2);
 
         MobileApplication app2 = createFakeMobileApplication(2);
@@ -320,7 +446,8 @@ public class AppSearchHelperTest {
         mAppSearchHelper.indexApps(
                 ImmutableList.of(app0, app1, app2),
                 /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of());
+                /* existingAppFunctions= */ ImmutableList.of(),
+                /* appsUpdateStats= */ new AppsUpdateStats());
 
         // Should be three
         Map<String, Long> timestampMapping = mAppSearchHelper.getAppsFromAppSearch();
@@ -341,7 +468,8 @@ public class AppSearchHelperTest {
         mAppSearchHelper.indexApps(
                 ImmutableList.of(app0, app1),
                 /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of());
+                /* existingAppFunctions= */ ImmutableList.of(),
+                /* appsUpdateStats= */ new AppsUpdateStats());
         assertThat(mAppSearchHelper.getAppFunctionsFromAppSearch()).isEmpty();
 
         // Now app0 has an app function.
@@ -351,7 +479,8 @@ public class AppSearchHelperTest {
         mAppSearchHelper.indexApps(
                 ImmutableList.of(app0, app1),
                 /* appFunctions= */ ImmutableList.of(app0Function0),
-                /* existingAppFunctions= */ ImmutableList.of(app0Function0));
+                /* existingAppFunctions= */ ImmutableList.of(app0Function0),
+                /* appsUpdateStats= */ new AppsUpdateStats());
 
         assertThat(mAppSearchHelper.getAppFunctionsFromAppSearch().get(0).getId())
                 .isEqualTo("com.fake.package0/function_id0");
@@ -359,6 +488,8 @@ public class AppSearchHelperTest {
 
     @Test
     public void test_newAppFunction_parentSchemaIsInserted() throws Exception {
+        assumeTrue(AppFunctionStaticMetadata.shouldSetParentType());
+
         // Set up 1 MobileApplications with an app function.
         MobileApplication app0 = createFakeMobileApplication(0);
         mAppSearchHelper.setSchemasForPackages(
@@ -367,13 +498,17 @@ public class AppSearchHelperTest {
         mAppSearchHelper.indexApps(
                 ImmutableList.of(app0),
                 /* appFunctions= */ ImmutableList.of(app0Function0),
-                /* existingAppFunctions= */ ImmutableList.of());
+                /* existingAppFunctions= */ ImmutableList.of(),
+                /* appsUpdateStats= */ new AppsUpdateStats());
 
         AppSearchSessionShim session =
                 createFakeAppIndexerSession(mContext, mSingleThreadedExecutor);
         GetSchemaResponse response = session.getSchemaAsync().get();
-        assertThat(response.getSchemas().stream().map(AppSearchSchema::getSchemaType).toList())
-                .contains(AppFunctionStaticMetadata.SCHEMA_TYPE);
+        List<String> schemaTypes = new ArrayList<>();
+        for (AppSearchSchema schema : response.getSchemas()) {
+            schemaTypes.add(schema.getSchemaType());
+        }
+        assertThat(schemaTypes).contains(AppFunctionStaticMetadata.SCHEMA_TYPE);
     }
 
     @Test
@@ -390,7 +525,8 @@ public class AppSearchHelperTest {
         mAppSearchHelper.indexApps(
                 ImmutableList.of(app0, app1),
                 /* appFunctions= */ ImmutableList.of(app0Function0, app0Function1),
-                /* existingAppFunctions= */ ImmutableList.of());
+                /* existingAppFunctions= */ ImmutableList.of(),
+                /* appsUpdateStats= */ new AppsUpdateStats());
         List<GenericDocument> appFunctionsInAppSearch =
                 mAppSearchHelper.getAppFunctionsFromAppSearch();
         assertThat(appFunctionsInAppSearch).hasSize(2);
@@ -407,7 +543,8 @@ public class AppSearchHelperTest {
         mAppSearchHelper.indexApps(
                 ImmutableList.of(app0, app1),
                 /* appFunctions= */ ImmutableList.of(app0Function0),
-                /* existingAppFunctions= */ ImmutableList.of(app0Function0, app0Function1));
+                /* existingAppFunctions= */ ImmutableList.of(app0Function0, app0Function1),
+                /* appsUpdateStats= */ new AppsUpdateStats());
         // app0 still have one app function. so app0 is being indexed.
         assertThat(mAppSearchHelper.getAppFunctionsFromAppSearch().get(0).getId())
                 .isEqualTo("com.fake.package0/function_id0");
@@ -418,8 +555,134 @@ public class AppSearchHelperTest {
         mAppSearchHelper.indexApps(
                 ImmutableList.of(app0, app1),
                 /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of(app0Function0));
+                /* existingAppFunctions= */ ImmutableList.of(app0Function0),
+                /* appsUpdateStats= */ new AppsUpdateStats());
         // App0 is no longer indexed for app functions cause it no longer has any of them.
         assertThat(mAppSearchHelper.getAppFunctionsFromAppSearch()).isEmpty();
     }
+
+    @Test
+    public void testIndexAppOpenEvents_incrementalUpdateSupported() throws Exception {
+        long currentTimeMillis = System.currentTimeMillis();
+        AppOpenEvent event1 = createFakeAppOpenEvent(currentTimeMillis + 100L);
+        mAppSearchHelper.setSchemaForAppOpenEvents();
+        mAppSearchHelper.indexAppOpenEvents(ImmutableList.of(event1));
+
+        AppOpenEvent event2 = createFakeAppOpenEvent(currentTimeMillis + 200L);
+        mAppSearchHelper.setSchemaForAppOpenEvents();
+        mAppSearchHelper.indexAppOpenEvents(ImmutableList.of(event2));
+
+        assertThat(
+                        mAppSearchHelper
+                                .getSubsequentAppOpenEventAfterThreshold(currentTimeMillis)
+                                .getId())
+                .isEqualTo(event1.getId());
+        assertThat(
+                        mAppSearchHelper
+                                .getSubsequentAppOpenEventAfterThreshold(currentTimeMillis + 150L)
+                                .getId())
+                .isEqualTo(event2.getId());
+    }
+
+    @Test
+    public void testIndexAppOpenEvents_doesNotInterfereWithAppSchemaSet() throws Exception {
+        long currentTimeMillis = System.currentTimeMillis();
+        mAppSearchHelper.setSchemaForAppOpenEvents();
+        AppOpenEvent event1 = createFakeAppOpenEvent(currentTimeMillis + 100L);
+        mAppSearchHelper.setSchemasForPackages(createMockPackageIdentifiers(1), new ArrayList<>());
+
+        mAppSearchHelper.indexAppOpenEvents(ImmutableList.of(event1));
+        assertThat(
+                        mAppSearchHelper
+                                .getSubsequentAppOpenEventAfterThreshold(currentTimeMillis)
+                                .getId())
+                .isEqualTo(event1.getId());
+    }
+
+    @Test
+    public void testIndexAppOpenEvents_multipleAppOpenEventsStored() throws Exception {
+        long currentTimeMillis = System.currentTimeMillis();
+        AppOpenEvent event1 = createFakeAppOpenEvent(currentTimeMillis + 100L);
+        AppOpenEvent event2 = createFakeAppOpenEvent(currentTimeMillis + 200L);
+
+        mAppSearchHelper.setSchemaForAppOpenEvents();
+        assertThrows(
+                AppSearchException.class,
+                () -> mAppSearchHelper.getSubsequentAppOpenEventAfterThreshold(currentTimeMillis));
+
+        mAppSearchHelper.indexAppOpenEvents(ImmutableList.of(event1, event2));
+        assertThat(
+                        mAppSearchHelper
+                                .getSubsequentAppOpenEventAfterThreshold(currentTimeMillis)
+                                .getId())
+                .isEqualTo(event1.getId());
+        assertThat(
+                        mAppSearchHelper
+                                .getSubsequentAppOpenEventAfterThreshold(currentTimeMillis + 150L)
+                                .getId())
+                .isEqualTo(event2.getId());
+        assertThrows(
+                AppSearchException.class,
+                () ->
+                        mAppSearchHelper.getSubsequentAppOpenEventAfterThreshold(
+                                currentTimeMillis + 300L));
+    }
+
+    @Test
+    public void testAppOpenEventJoinsToMobileApplication() throws Exception {
+        mAppSearchHelper.setSchemasForPackages(createMockPackageIdentifiers(1), new ArrayList<>());
+        List<MobileApplication> apps = createMobileApplications(1);
+        mAppSearchHelper.indexApps(
+                apps,
+                /* appFunctions= */ ImmutableList.of(),
+                /* existingAppFunctions= */ ImmutableList.of(),
+                /* appsUpdateStats= */ new AppsUpdateStats());
+
+        long currentTimeMillis = System.currentTimeMillis();
+        AppOpenEvent event1 =
+                AppOpenEvent.create(
+                        apps.get(0).getPackageName(), currentTimeMillis, mContext.getPackageName());
+        mAppSearchHelper.setSchemaForAppOpenEvents();
+        mAppSearchHelper.indexAppOpenEvents(ImmutableList.of(event1));
+
+        SearchSpec nestedSearchSpec =
+                new SearchSpec.Builder()
+                        .addFilterSchemas(AppOpenEvent.SCHEMA_TYPE)
+                        .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
+                        .build();
+
+        JoinSpec joinSpec =
+                new JoinSpec.Builder(
+                                AppOpenEvent
+                                        .APP_OPEN_EVENT_PROPERTY_MOBILE_APPLICATION_QUALIFIED_ID)
+                        .setNestedSearch("", nestedSearchSpec)
+                        .build();
+
+        SearchSpec searchSpec =
+                new SearchSpec.Builder()
+                        .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
+                        .addFilterNamespaces(MobileApplication.APPS_NAMESPACE)
+                        .setResultCountPerPage(1000)
+                        .setJoinSpec(joinSpec)
+                        .build();
+
+        try (SyncGlobalSearchSession globalSession =
+                new SyncGlobalSearchSessionImpl(
+                        mContext.getSystemService(AppSearchManager.class),
+                        mSingleThreadedExecutor)) {
+
+            SyncSearchResults searchResults = globalSession.search("", searchSpec);
+            List<SearchResult> joinedResults =
+                    searchResults.getNextPage().get(0).getJoinedResults();
+
+            GenericDocument appOpenEventDocument = joinedResults.get(0).getGenericDocument();
+
+            assertThat(appOpenEventDocument.getPropertyString(APP_OPEN_EVENT_PROPERTY_PACKAGE_NAME))
+                    .isEqualTo(apps.get(0).getPackageName());
+            assertThat(
+                            appOpenEventDocument.getPropertyString(
+                                    APP_OPEN_EVENT_PROPERTY_MOBILE_APPLICATION_QUALIFIED_ID))
+                    .isEqualTo(event1.getMobileApplicationQualifiedId());
+        }
+    }
 }
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerImplTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerImplTest.java
index 63ef8079..5b48c70c 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerImplTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerImplTest.java
@@ -16,7 +16,10 @@
 
 package com.android.server.appsearch.appsindexer;
 
+import static com.android.server.appsearch.appsindexer.TestUtils.createFakeAppFunctionResolveInfo;
+import static com.android.server.appsearch.appsindexer.TestUtils.createFakeLaunchResolveInfo;
 import static com.android.server.appsearch.appsindexer.TestUtils.createFakeMobileApplication;
+import static com.android.server.appsearch.appsindexer.TestUtils.createFakePackageInfo;
 import static com.android.server.appsearch.appsindexer.TestUtils.createFakePackageInfos;
 import static com.android.server.appsearch.appsindexer.TestUtils.createFakeResolveInfos;
 import static com.android.server.appsearch.appsindexer.TestUtils.createMockPackageIdentifiers;
@@ -25,17 +28,24 @@ import static com.android.server.appsearch.appsindexer.TestUtils.setupMockPackag
 
 import static com.google.common.truth.Truth.assertThat;
 
+import static junit.framework.Assert.assertEquals;
+
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.when;
 
+import android.app.appsearch.GenericDocument;
+import android.content.ComponentName;
 import android.content.Context;
 import android.content.ContextWrapper;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.content.pm.ResolveInfo;
+import android.content.res.AssetManager;
+import android.content.res.Resources;
 
 import androidx.test.core.app.ApplicationProvider;
 
+import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionStaticMetadata;
 import com.android.server.appsearch.appsindexer.appsearchtypes.MobileApplication;
 
 import com.google.common.collect.ImmutableList;
@@ -46,7 +56,9 @@ import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 import org.mockito.Mockito;
+import org.mockito.MockitoSession;
 
+import java.io.ByteArrayInputStream;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
@@ -59,6 +71,7 @@ public class AppsIndexerImplTest {
     @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();
     private final ExecutorService mSingleThreadedExecutor = Executors.newSingleThreadExecutor();
     private final AppsIndexerConfig mAppsIndexerConfig = new TestAppsIndexerConfig();
+    private MockitoSession mMockitoSession;
 
     @Before
     public void setUp() throws Exception {
@@ -70,6 +83,9 @@ public class AppsIndexerImplTest {
     public void tearDown() throws Exception {
         removeFakePackageDocuments(mContext, mSingleThreadedExecutor);
         mAppSearchHelper.close();
+        if (mMockitoSession != null) {
+            mMockitoSession.finishMocking();
+        }
     }
 
     @Test
@@ -82,7 +98,8 @@ public class AppsIndexerImplTest {
         mAppSearchHelper.indexApps(
                 ImmutableList.of(app1, app2),
                 /* appFunctions= */ ImmutableList.of(),
-                /* existingAppFunctions= */ ImmutableList.of());
+                /* existingAppFunctions= */ ImmutableList.of(),
+                new AppsUpdateStats());
         Map<String, Long> appTimestampMap = mAppSearchHelper.getAppsFromAppSearch();
 
         List<String> packageIds = new ArrayList<>(appTimestampMap.keySet());
@@ -205,4 +222,286 @@ public class AppsIndexerImplTest {
                     .containsExactly("com.fake.package1", "com.fake.package2", "com.fake.package3");
         }
     }
+
+    @Test
+    public void testAppsIndexerImpl_statsSet_functionsIndexed() throws Exception {
+        // Simulate the first update: no changes, just adding initial apps
+        PackageManager pm1 = Mockito.mock(PackageManager.class);
+        List<PackageInfo> fakePackages = new ArrayList<>();
+        List<ResolveInfo> fakeActivities = new ArrayList<>();
+        List<ResolveInfo> fakeAppFunctionServices = new ArrayList<>();
+
+        for (int i = 0; i < 5; i++) {
+            fakePackages.add(createFakePackageInfo(i));
+            fakeActivities.add(createFakeLaunchResolveInfo(i));
+            fakeAppFunctionServices.add(createFakeAppFunctionResolveInfo(i));
+        }
+
+        when(pm1.getProperty(any(String.class), any(ComponentName.class)))
+                .thenReturn(new PackageManager.Property("", "", "", ""));
+        AssetManager assetManager = Mockito.mock(AssetManager.class);
+
+        // Three functions initially. One will be deleted, another updated, the third left alone,
+        // then a fourth added.
+        String xml =
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<version>1</version>\n"
+                        + "<appfunctions>\n"
+                        + "  <appfunction>\n"
+                        + "    <function_id>com.example.utils#print</function_id>\n"
+                        + "  </appfunction>\n"
+                        + "  <appfunction>\n"
+                        + "    <function_id>com.example.utils#search</function_id>\n"
+                        + "  </appfunction>\n"
+                        + "  <appfunction>\n"
+                        + "    <function_id>com.example.utils#pay</function_id>\n"
+                        + "  </appfunction>\n"
+                        + "</appfunctions>";
+
+        when(assetManager.open(any(String.class)))
+                .thenReturn(
+                        new ByteArrayInputStream(xml.getBytes()),
+                        new ByteArrayInputStream(xml.getBytes()),
+                        new ByteArrayInputStream(xml.getBytes()),
+                        new ByteArrayInputStream(xml.getBytes()),
+                        new ByteArrayInputStream(xml.getBytes()));
+
+        Resources resources = Mockito.mock(Resources.class);
+        when(resources.getAssets()).thenReturn(assetManager);
+        when(pm1.getResourcesForApplication(any(String.class))).thenReturn(resources);
+        setupMockPackageManager(pm1, fakePackages, fakeActivities, fakeAppFunctionServices);
+
+        Context context1 =
+                new ContextWrapper(mContext) {
+                    @Override
+                    public PackageManager getPackageManager() {
+                        return pm1;
+                    }
+                };
+
+        List<String> packages = new ArrayList<>();
+        packages.add("com.fake.package0");
+        packages.add("com.fake.package1");
+        packages.add("com.fake.package2");
+        packages.add("com.fake.package3");
+        packages.add("com.fake.package4");
+
+        List<String> expectedFunctionIds = new ArrayList<>();
+        for (int i = 0; i < packages.size(); i++) {
+            expectedFunctionIds.add(packages.get(i) + "/com.example.utils#pay");
+            expectedFunctionIds.add(packages.get(i) + "/com.example.utils#search");
+            expectedFunctionIds.add(packages.get(i) + "/com.example.utils#print");
+        }
+
+        // Perform the first update
+        try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context1, mAppsIndexerConfig)) {
+            AppsUpdateStats stats1 = new AppsUpdateStats();
+            appsIndexerImpl.doUpdate(
+                    new AppsIndexerSettings(temporaryFolder.newFolder("temp1")), stats1);
+
+            // Check the stats object after the first update
+            assertThat(stats1.mNumberOfAppsAdded).isEqualTo(5);
+            assertThat(stats1.mNumberOfAppsRemoved).isEqualTo(0); // No apps deleted
+            assertThat(stats1.mNumberOfAppsUnchanged).isEqualTo(0); // No apps unchanged
+            assertThat(stats1.mNumberOfAppsUpdated).isEqualTo(0); // No apps updated
+
+            // Currently we are logging added and updated and unchanged all as updated
+            assertThat(stats1.mNumberOfFunctionsUpdated).isEqualTo(15); // One app updated
+            assertThat(stats1.mNumberOfFunctionsAdded).isEqualTo(0);
+            assertThat(stats1.mApproximateNumberOfFunctionsRemoved).isEqualTo(0);
+            assertThat(stats1.mApproximateNumberOfFunctionsUnchanged).isEqualTo(0);
+
+            List<GenericDocument> indexedFunctions =
+                    mAppSearchHelper.getAppFunctionsFromAppSearch();
+            List<String> indexedFunctionIds = new ArrayList<>();
+            for (int i = 0; i < indexedFunctions.size(); i++) {
+                indexedFunctionIds.add(indexedFunctions.get(i).getId());
+            }
+            // Verify the state of the indexed apps after the first update
+            assertThat(indexedFunctionIds).containsExactlyElementsIn(expectedFunctionIds);
+        }
+
+        // Simulate an update
+        for (int i = 0; i < 5; i++) {
+            fakePackages.get(i).lastUpdateTime = 1000;
+        }
+
+        expectedFunctionIds = new ArrayList<>();
+        for (int i = 0; i < packages.size(); i++) {
+            expectedFunctionIds.add(packages.get(i) + "/com.example.utils#pay");
+            expectedFunctionIds.add(packages.get(i) + "/com.example.utils#search");
+            expectedFunctionIds.add(packages.get(i) + "/com.example.utils#scan_doc");
+        }
+
+        // Remove print, update search (with category), don't change pay, add scan doc
+        String xml2 =
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<version>1</version>\n"
+                        + "<appfunctions>\n"
+                        + "  <appfunction>\n"
+                        + "    <function_id>com.example.utils#search</function_id>\n"
+                        + "    <schema_category>utils</schema_category>\n"
+                        + "  </appfunction>\n"
+                        + "  <appfunction>\n"
+                        + "    <function_id>com.example.utils#pay</function_id>\n"
+                        + "  </appfunction>\n"
+                        + "  <appfunction>\n"
+                        + "    <function_id>com.example.utils#scan_doc</function_id>\n"
+                        + "  </appfunction>\n"
+                        + "</appfunctions>";
+
+        // This is flaky, out of order
+        when(assetManager.open(any(String.class)))
+                .thenReturn(
+                        new ByteArrayInputStream(xml2.getBytes()),
+                        new ByteArrayInputStream(xml2.getBytes()),
+                        new ByteArrayInputStream(xml2.getBytes()),
+                        new ByteArrayInputStream(xml2.getBytes()),
+                        new ByteArrayInputStream(xml2.getBytes()));
+
+        // xml + xmlUpdatedFunction both seem to be treated as updates
+        // or it's no functions + two functions
+
+        try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context1, mAppsIndexerConfig)) {
+            AppsUpdateStats stats1 = new AppsUpdateStats();
+            appsIndexerImpl.doUpdate(
+                    new AppsIndexerSettings(temporaryFolder.newFolder("temp2")), stats1);
+
+            // Check the stats object after the first update
+            assertThat(stats1.mNumberOfAppsAdded).isEqualTo(0);
+            assertThat(stats1.mNumberOfAppsRemoved).isEqualTo(0);
+            assertThat(stats1.mNumberOfAppsUnchanged).isEqualTo(0);
+            assertThat(stats1.mNumberOfAppsUpdated).isEqualTo(5);
+
+            // Currently we are logging added and updated and unchanged all as updated
+            assertThat(stats1.mNumberOfFunctionsUpdated).isEqualTo(15);
+            assertThat(stats1.mApproximateNumberOfFunctionsRemoved).isEqualTo(5);
+            assertThat(stats1.mNumberOfFunctionsAdded).isEqualTo(0);
+            assertThat(stats1.mApproximateNumberOfFunctionsUnchanged).isEqualTo(0);
+
+            List<GenericDocument> indexedFunctions =
+                    mAppSearchHelper.getAppFunctionsFromAppSearch();
+            List<String> indexedFunctionIds = new ArrayList<>();
+            for (int i = 0; i < indexedFunctions.size(); i++) {
+                indexedFunctionIds.add(indexedFunctions.get(i).getId());
+            }
+            // Verify the state of the indexed apps after the first update
+            assertThat(indexedFunctionIds).containsExactlyElementsIn(expectedFunctionIds);
+        }
+    }
+
+    // This does not have the @RequiresFlagEnabled annotation as it directly calls the "incremental
+    // update" path.
+    @Test
+    public void testAppsIndexerImpl_incrementalPut_doesNotPutAllDocs() throws Exception {
+        // Index a package with 1 function, modify the function document timestamp, re-index the app
+        // with an additional function, ensure the modification to the original document hasn't
+        // changed.
+
+        // Simulate the first update: no changes, just adding initial apps
+        PackageManager pm1 = Mockito.mock(PackageManager.class);
+        List<PackageInfo> fakePackages = ImmutableList.of(createFakePackageInfo(0));
+        List<ResolveInfo> fakeActivities = ImmutableList.of(createFakeLaunchResolveInfo(0));
+        List<ResolveInfo> fakeAppFunctionServices =
+                ImmutableList.of(createFakeAppFunctionResolveInfo(0));
+
+        when(pm1.getProperty(any(String.class), any(ComponentName.class)))
+                .thenReturn(new PackageManager.Property("", "", "", ""));
+        AssetManager assetManager = Mockito.mock(AssetManager.class);
+
+        // One functions initially
+        String xml =
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<version>1</version>\n"
+                        + "<appfunctions>\n"
+                        + "  <appfunction>\n"
+                        + "    <function_id>com.example.utils#print</function_id>\n"
+                        + "  </appfunction>\n"
+                        + "</appfunctions>";
+
+        when(assetManager.open(any(String.class)))
+                .thenReturn(new ByteArrayInputStream(xml.getBytes()));
+
+        Resources resources = Mockito.mock(Resources.class);
+        when(resources.getAssets()).thenReturn(assetManager);
+        when(pm1.getResourcesForApplication(any(String.class))).thenReturn(resources);
+        setupMockPackageManager(pm1, fakePackages, fakeActivities, fakeAppFunctionServices);
+
+        Context context1 =
+                new ContextWrapper(mContext) {
+                    @Override
+                    public PackageManager getPackageManager() {
+                        return pm1;
+                    }
+                };
+
+        List<String> packages = ImmutableList.of("com.fake.package0");
+
+        // Perform the first update
+        try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context1, mAppsIndexerConfig)) {
+            AppsUpdateStats stats1 = new AppsUpdateStats();
+            appsIndexerImpl.doUpdateIncrementalPut(
+                    new AppsIndexerSettings(temporaryFolder.newFolder("temp1")), stats1);
+
+            // Check the stats object after the first update
+            assertThat(stats1.mNumberOfAppsAdded).isEqualTo(1);
+            assertThat(stats1.mNumberOfAppsRemoved).isEqualTo(0);
+            assertThat(stats1.mNumberOfAppsUnchanged).isEqualTo(0);
+            assertThat(stats1.mNumberOfAppsUpdated).isEqualTo(0);
+
+            // Verify the state of the indexed apps after the first update
+            assertThat(mAppSearchHelper.getAppFunctionsFromAppSearch(packages).keySet())
+                    .containsExactlyElementsIn(packages);
+        }
+
+        // Manually modify the AppSearch function document timestamp
+        Map<String, Map<String, AppFunctionStaticMetadata>> indexedFunctions =
+                mAppSearchHelper.getAppFunctionsFromAppSearch(packages);
+        GenericDocument original =
+                indexedFunctions.get("com.fake.package0").get("com.example.utils#print");
+        long firstPutTimestamp = original.getCreationTimestampMillis();
+
+        // Simulate an update
+        fakePackages.get(0).lastUpdateTime = 1000;
+
+        // Add a function without modifying the first
+        String xml2 =
+                "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n"
+                        + "<version>1</version>\n"
+                        + "<appfunctions>\n"
+                        + "  <appfunction>\n"
+                        + "    <function_id>com.example.utils#print</function_id>\n"
+                        + "  </appfunction>\n"
+                        + "  <appfunction>\n"
+                        + "    <function_id>com.example.utils#search</function_id>\n"
+                        + "    <schema_category>utils</schema_category>\n"
+                        + "  </appfunction>\n"
+                        + "</appfunctions>";
+
+        when(assetManager.open(any(String.class)))
+                .thenReturn(new ByteArrayInputStream(xml2.getBytes()));
+
+        try (AppsIndexerImpl appsIndexerImpl = new AppsIndexerImpl(context1, mAppsIndexerConfig)) {
+            AppsUpdateStats stats1 = new AppsUpdateStats();
+            appsIndexerImpl.doUpdateIncrementalPut(
+                    new AppsIndexerSettings(temporaryFolder.newFolder("temp2")), stats1);
+
+            // Check the stats object after the first update
+            assertThat(stats1.mNumberOfAppsAdded).isEqualTo(0);
+            assertThat(stats1.mNumberOfAppsRemoved).isEqualTo(0);
+            assertThat(stats1.mNumberOfAppsUnchanged).isEqualTo(0);
+            assertThat(stats1.mNumberOfAppsUpdated).isEqualTo(1);
+
+            assertThat(mAppSearchHelper.getAppFunctionsFromAppSearch(packages).keySet())
+                    .containsExactlyElementsIn(packages);
+        }
+        indexedFunctions = mAppSearchHelper.getAppFunctionsFromAppSearch(packages);
+        GenericDocument unchangedFunctions =
+                indexedFunctions.get("com.fake.package0").get("com.example.utils#print");
+        GenericDocument addedFunction =
+                indexedFunctions.get("com.fake.package0").get("com.example.utils#search");
+
+        assertEquals(unchangedFunctions.getCreationTimestampMillis(), firstPutTimestamp);
+        assertThat(addedFunction.getCreationTimestampMillis()).isGreaterThan(firstPutTimestamp);
+    }
 }
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerUserInstanceTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerUserInstanceTest.java
index f191c659..350fbaf2 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerUserInstanceTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsIndexerUserInstanceTest.java
@@ -18,6 +18,7 @@ package com.android.server.appsearch.appsindexer;
 
 import static com.android.server.appsearch.appsindexer.TestUtils.createFakePackageInfos;
 import static com.android.server.appsearch.appsindexer.TestUtils.createFakeResolveInfos;
+import static com.android.server.appsearch.appsindexer.TestUtils.removeFakePackageDocuments;
 import static com.android.server.appsearch.appsindexer.TestUtils.setupMockPackageManager;
 
 import static com.google.common.truth.Truth.assertThat;
@@ -103,7 +104,7 @@ public class AppsIndexerUserInstanceTest extends AppsIndexerTestBase {
     @After
     @Override
     public void tearDown() throws Exception {
-        TestUtils.removeFakePackageDocuments(mTestContext, Executors.newSingleThreadExecutor());
+        removeFakePackageDocuments(mTestContext, Executors.newSingleThreadExecutor());
         mSingleThreadedExecutor.shutdownNow();
         mInstance.shutdown();
         super.tearDown();
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsUtilTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsUtilTest.java
index 34eca74c..3e305af2 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsUtilTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/AppsUtilTest.java
@@ -44,6 +44,7 @@ import android.util.ArrayMap;
 import androidx.test.core.app.ApplicationProvider;
 
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionStaticMetadata;
+import com.android.server.appsearch.appsindexer.appsearchtypes.AppOpenEvent;
 import com.android.server.appsearch.appsindexer.appsearchtypes.MobileApplication;
 
 import com.google.common.collect.ImmutableList;
@@ -135,14 +136,16 @@ public class AppsUtilTest {
         UsageEvents mockUsageEvents = createUsageEvents(events);
         when(mockUsageStatsManager.queryEvents(anyLong(), anyLong())).thenReturn(mockUsageEvents);
 
-        Map<String, List<Long>> appOpenTimestamps =
-                AppsUtil.getAppOpenTimestamps(
+        List<AppOpenEvent> appOpenTimestamps =
+                AppsUtil.getAppOpenEvents(
                         mockUsageStatsManager, 0, Calendar.getInstance().getTimeInMillis());
 
-        assertThat(appOpenTimestamps)
+        assertThat(appOpenTimestamps).hasSize(3);
+        assertThat(appOpenTimestamps.stream().map(AppOpenEvent::getId))
                 .containsExactly(
-                        "com.example.package", List.of(1000L, 2000L),
-                        "com.example.package2", List.of(3000L));
+                        "com.example.package1000",
+                        "com.example.package2000",
+                        "com.example.package23000");
     }
 
     @Test
diff --git a/framework/java/android/app/appsearch/aidl/IAppFunctionService.aidl b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/MainActivity.java
similarity index 54%
rename from framework/java/android/app/appsearch/aidl/IAppFunctionService.aidl
rename to testing/appsindexertests/src/com/android/server/appsearch/appsindexer/MainActivity.java
index 9c0e14a8..acb3c6c3 100644
--- a/framework/java/android/app/appsearch/aidl/IAppFunctionService.aidl
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/MainActivity.java
@@ -14,23 +14,20 @@
  * limitations under the License.
  */
 
-package android.app.appsearch.aidl;
+package com.android.server.appsearch.appsindexer;
 
+import android.app.Activity;
 import android.os.Bundle;
-import android.app.appsearch.aidl.IAppSearchResultCallback;
-import android.app.appsearch.functions.ExecuteAppFunctionRequest;
+import android.widget.TextView;
 
+public class MainActivity extends Activity {
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
 
- /** {@hide} */
-oneway interface IAppFunctionService {
-    /**
-     * Called by the system to execute a specific app function.
-     *
-     * @param request  the function execution request.
-     * @param callback a callback to report back the result.
-     */
-    void executeAppFunction(
-        in ExecuteAppFunctionRequest request,
-        in IAppSearchResultCallback callback
-    );
-}
\ No newline at end of file
+        TextView label = new TextView(this);
+        label.setText("I am MainActivity!");
+
+        setContentView(label);
+    }
+}
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestAppOpenEventIndexerConfig.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestAppOpenEventIndexerConfig.java
new file mode 100644
index 00000000..eb0eab28
--- /dev/null
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestAppOpenEventIndexerConfig.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.appsindexer;
+
+public class TestAppOpenEventIndexerConfig implements AppOpenEventIndexerConfig {
+    @Override
+    public boolean isAppOpenEventIndexerEnabled() {
+        return true;
+    }
+
+    @Override
+    public long getAppOpenEventMaintenanceUpdateIntervalMillis() {
+        return 24 * 60 * 60 * 1000L; // 1 day
+    }
+}
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestAppsIndexerConfig.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestAppsIndexerConfig.java
index e8f1ab3d..ea1356e8 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestAppsIndexerConfig.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestAppsIndexerConfig.java
@@ -31,4 +31,9 @@ public class TestAppsIndexerConfig implements AppsIndexerConfig {
     public int getMaxAppFunctionsPerPackage() {
         return 500;
     }
+
+    @Override
+    public int getMaxAllowedAppFunctionSchemasPerPackage() {
+        return 5;
+    }
 }
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestUtils.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestUtils.java
index fb1993d8..abbb2f3e 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestUtils.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/TestUtils.java
@@ -16,13 +16,13 @@
 
 package com.android.server.appsearch.appsindexer;
 
-import static com.android.server.appsearch.appsindexer.appsearchtypes.MobileApplication.SCHEMA_TYPE;
-
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyLong;
 import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.when;
 
+import android.annotation.CurrentTimeMillisLong;
 import android.annotation.NonNull;
 import android.app.appsearch.AppSearchManager;
 import android.app.appsearch.AppSearchSchema;
@@ -37,6 +37,7 @@ import android.app.appsearch.SetSchemaResponse;
 import android.app.appsearch.testutil.AppSearchSessionShimImpl;
 import android.app.appsearch.testutil.GlobalSearchSessionShimImpl;
 import android.app.usage.UsageEvents;
+import android.app.usage.UsageStatsManager;
 import android.content.Context;
 import android.content.pm.ActivityInfo;
 import android.content.pm.ApplicationInfo;
@@ -49,6 +50,7 @@ import android.content.pm.SigningInfo;
 import android.content.res.Resources;
 
 import com.android.server.appsearch.appsindexer.appsearchtypes.AppFunctionStaticMetadata;
+import com.android.server.appsearch.appsindexer.appsearchtypes.AppOpenEvent;
 import com.android.server.appsearch.appsindexer.appsearchtypes.MobileApplication;
 
 import org.mockito.Mockito;
@@ -69,7 +71,25 @@ class TestUtils {
     // Represents a schema compatible with MobileApplication. This is used to test compatible schema
     // upgrades. It is compatible as changing to MobileApplication just adds properties.
     public static final AppSearchSchema COMPATIBLE_APP_SCHEMA =
-            new AppSearchSchema.Builder(SCHEMA_TYPE)
+            new AppSearchSchema.Builder(MobileApplication.SCHEMA_TYPE)
+                    .addProperty(
+                            new AppSearchSchema.StringPropertyConfig.Builder(
+                                            MobileApplication.APP_PROPERTY_PACKAGE_NAME)
+                                    .setCardinality(
+                                            AppSearchSchema.PropertyConfig.CARDINALITY_OPTIONAL)
+                                    .setIndexingType(
+                                            AppSearchSchema.StringPropertyConfig
+                                                    .INDEXING_TYPE_PREFIXES)
+                                    .setTokenizerType(
+                                            AppSearchSchema.StringPropertyConfig
+                                                    .TOKENIZER_TYPE_VERBATIM)
+                                    .build())
+                    .build();
+
+    // Represents a schema compatible with AppOpenEvent. This is used to test compatible schema
+    // upgrades. It is compatible as changing to AppOpenEvent just adds properties.
+    public static final AppSearchSchema COMPATIBLE_APP_OPEN_EVENT_SCHEMA =
+            new AppSearchSchema.Builder(AppOpenEvent.SCHEMA_TYPE)
                     .addProperty(
                             new AppSearchSchema.StringPropertyConfig.Builder(
                                             MobileApplication.APP_PROPERTY_PACKAGE_NAME)
@@ -88,7 +108,7 @@ class TestUtils {
     // schema upgrades. It is incompatible as changing to MobileApplication removes the
     // "NotPackageName" field.
     public static final AppSearchSchema INCOMPATIBLE_APP_SCHEMA =
-            new AppSearchSchema.Builder(SCHEMA_TYPE)
+            new AppSearchSchema.Builder(MobileApplication.SCHEMA_TYPE)
                     .addProperty(
                             new AppSearchSchema.StringPropertyConfig.Builder("NotPackageName")
                                     .setCardinality(
@@ -102,6 +122,25 @@ class TestUtils {
                                     .build())
                     .build();
 
+    // Represents a schema incompatible with AppOpenEvent. This is used to test incompatible schema
+    // upgrades. It is incompatible as changing to AppOpenEvent will remove the "NotPackageName"
+    // field.
+    public static final AppSearchSchema INCOMPATIBLE_APP_OPEN_EVENT_SCHEMA =
+            new AppSearchSchema.Builder(AppOpenEvent.SCHEMA_TYPE)
+                    .addProperty(
+                            new AppSearchSchema.StringPropertyConfig.Builder(
+                                            "NotPackageName") // Different field name
+                                    .setCardinality(
+                                            AppSearchSchema.PropertyConfig.CARDINALITY_OPTIONAL)
+                                    .setIndexingType(
+                                            AppSearchSchema.StringPropertyConfig
+                                                    .INDEXING_TYPE_PREFIXES)
+                                    .setTokenizerType(
+                                            AppSearchSchema.StringPropertyConfig
+                                                    .TOKENIZER_TYPE_VERBATIM)
+                                    .build())
+                    .build();
+
     /**
      * Creates a fake {@link PackageInfo} object.
      *
@@ -221,6 +260,17 @@ class TestUtils {
         when(pm.queryIntentServices(any(), eq(0))).then(i -> appFunctionServices);
     }
 
+    /**
+     * Sets up a mock {@link UsageStatsManager} to return the given {@link UsageEvents} when
+     * queryEvents is called.
+     */
+    public static void setupMockUsageStatsManager(
+            @NonNull UsageStatsManager usm, @NonNull UsageEvents usageEvents) throws Exception {
+        Objects.requireNonNull(usm);
+        Objects.requireNonNull(usageEvents);
+        when(usm.queryEvents(anyLong(), anyLong())).thenReturn(usageEvents);
+    }
+
     /** Wipes out the apps database. */
     public static void removeFakePackageDocuments(
             @NonNull Context context, @NonNull ExecutorService executorService)
@@ -240,6 +290,26 @@ class TestUtils {
                         .get();
     }
 
+    /** Wipes out the app open events database. */
+    public static void removeFakeAppOpenEventDocuments(
+            @NonNull Context context, @NonNull ExecutorService executorService)
+            throws ExecutionException, InterruptedException {
+        Objects.requireNonNull(context);
+        Objects.requireNonNull(executorService);
+
+        AppSearchSessionShim db =
+                AppSearchSessionShimImpl.createSearchSessionAsync(
+                                context,
+                                new AppSearchManager.SearchContext.Builder("app-open-events-db")
+                                        .build(),
+                                executorService)
+                        .get();
+
+        SetSchemaResponse unused =
+                db.setSchemaAsync(new SetSchemaRequest.Builder().setForceOverride(true).build())
+                        .get();
+    }
+
     /**
      * Search for documents indexed by the Apps Indexer. The database, namespace, and schematype are
      * all configured.
@@ -288,6 +358,23 @@ class TestUtils {
                 .get();
     }
 
+    /**
+     * Creates an {@link AppSearchSessionShim} for the same database the app open eventss indexer
+     * interacts with for mock events.
+     */
+    @NonNull
+    public static AppSearchSessionShim createFakeAppOpenEventsIndexerSession(
+            @NonNull Context context, @NonNull ExecutorService executorService)
+            throws ExecutionException, InterruptedException {
+        Objects.requireNonNull(context);
+        Objects.requireNonNull(executorService);
+        return AppSearchSessionShimImpl.createSearchSessionAsync(
+                        context,
+                        new AppSearchManager.SearchContext.Builder("app-open-events-db").build(),
+                        executorService)
+                .get();
+    }
+
     /**
      * Generates a mock {@link MobileApplication} corresponding to the same package created by
      * {@link #createFakePackageInfo} with the same variant.
@@ -306,6 +393,17 @@ class TestUtils {
                 .build();
     }
 
+    /**
+     * Generates a mock {@link AppOpenEvent} document.
+     *
+     * @param timestamp the timestamp of the AppOpenEvent document.
+     * @return a {@link AppOpenEvent} document with the given timestamp.
+     */
+    @NonNull
+    public static AppOpenEvent createFakeAppOpenEvent(@CurrentTimeMillisLong long timestamp) {
+        return AppOpenEvent.create(FAKE_PACKAGE_PREFIX, timestamp);
+    }
+
     /**
      * Generates multiple mock {@link MobileApplication} objects.
      *
@@ -368,6 +466,22 @@ class TestUtils {
         return new UsageEvents(Arrays.asList(events), new String[] {});
     }
 
+    /**
+     * Creates a mock {@link UsageEvents} object.
+     *
+     * @param numEvents the number of events to add to the UsageEvents object.
+     * @return a {@link UsageEvents} object with the given events.
+     */
+    public static UsageEvents createManyUsageEvents(int numEvents) {
+        List<UsageEvents.Event> events = new ArrayList<>();
+        for (int i = 0; i < numEvents; i++) {
+            events.add(
+                    createIndividualUsageEvent(
+                            UsageEvents.Event.ACTIVITY_RESUMED, i, "com.fake.package" + i));
+        }
+        return new UsageEvents(events, new String[] {});
+    }
+
     /**
      * Creates a mock {@link UsageEvents.Event} object.
      *
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/appsearchtypes/AppFunctionStaticMetadataTest.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/appsearchtypes/AppFunctionStaticMetadataTest.java
index fbe8519c..b4a75a9a 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/appsearchtypes/AppFunctionStaticMetadataTest.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/appsearchtypes/AppFunctionStaticMetadataTest.java
@@ -60,7 +60,9 @@ public class AppFunctionStaticMetadataTest {
     @Test
     public void testSchemaName() {
         String packageName = "com.example.message";
-        String schemaName = AppFunctionStaticMetadata.getSchemaNameForPackage(packageName);
+        String schemaName =
+                AppFunctionStaticMetadata.getSchemaNameForPackage(
+                        packageName, /** schemaType= */ null);
         assertThat(schemaName).isEqualTo("AppFunctionStaticMetadata-com.example.message");
     }
 
diff --git a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/appsearchtypes/AppsIndexerSchemaTests.java b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/appsearchtypes/AppsIndexerSchemaTests.java
index 8e0d610f..2ae16d9e 100644
--- a/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/appsearchtypes/AppsIndexerSchemaTests.java
+++ b/testing/appsindexertests/src/com/android/server/appsearch/appsindexer/appsearchtypes/AppsIndexerSchemaTests.java
@@ -54,14 +54,11 @@ public class AppsIndexerSchemaTests {
     @Test
     public void testAppOpenEvent() {
         String packageName = "com.android.apps.food";
-        String mobileApplicationQualifiedId = "appsearch$internal/db#food";
+        String mobileApplicationQualifiedId = "android$apps-db/apps#com.android.apps.food";
         long appOpenEventTimestampMillis = System.currentTimeMillis();
 
         AppOpenEvent appOpenEvent =
-                new AppOpenEvent.Builder(packageName, appOpenEventTimestampMillis)
-                        .setPackageName(packageName)
-                        .setMobileApplicationQualifiedId(mobileApplicationQualifiedId)
-                        .build();
+                AppOpenEvent.create(packageName, appOpenEventTimestampMillis);
 
         assertThat(appOpenEvent.getPackageName()).isEqualTo(packageName);
         assertThat(appOpenEvent.getMobileApplicationQualifiedId())
diff --git a/testing/contactsindexertests/Android.bp b/testing/contactsindexertests/Android.bp
index 5bf8304f..0e41f31f 100644
--- a/testing/contactsindexertests/Android.bp
+++ b/testing/contactsindexertests/Android.bp
@@ -26,6 +26,7 @@ android_test {
         "Harrier",
         "Nene",
         "TestApp",
+        "bedstead-enterprise",
         "androidx.test.ext.junit",
         "androidx.test.rules",
         "appsearch_flags_java_lib",
diff --git a/testing/contactsindexertests/AndroidTest.xml b/testing/contactsindexertests/AndroidTest.xml
index 65c1b058..778f5ecd 100644
--- a/testing/contactsindexertests/AndroidTest.xml
+++ b/testing/contactsindexertests/AndroidTest.xml
@@ -30,9 +30,9 @@
     <test class="com.android.tradefed.testtype.AndroidJUnitTest">
         <option name="package" value="com.android.appsearch.contactsindexertests"/>
         <option name="exclude-annotation"
-            value="com.android.bedstead.harrier.annotations.RequireRunOnWorkProfile" />
+            value="com.android.bedstead.enterprise.annotations.RequireRunOnWorkProfile" />
         <option name="exclude-annotation"
-            value="com.android.bedstead.harrier.annotations.RequireRunOnSecondaryUser" />
+            value="com.android.bedstead.multiuser.annotations.RequireRunOnSecondaryUser" />
         <option name="hidden-api-checks" value="false" />
     </test>
 
diff --git a/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/ContactsIndexerMaintenanceTest.java b/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/ContactsIndexerMaintenanceTest.java
index 4b57b517..f329276d 100644
--- a/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/ContactsIndexerMaintenanceTest.java
+++ b/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/ContactsIndexerMaintenanceTest.java
@@ -29,6 +29,7 @@ import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.doNothing;
 import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.timeout;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyZeroInteractions;
@@ -64,7 +65,6 @@ import org.mockito.Mockito;
 import org.mockito.MockitoAnnotations;
 import org.mockito.MockitoSession;
 
-import java.io.IOException;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 
@@ -72,7 +72,7 @@ public class ContactsIndexerMaintenanceTest {
     private static final int DEFAULT_USER_ID = 0;
     private static final UserHandle DEFAULT_USER_HANDLE = new UserHandle(0);
 
-    private Context mContext = ApplicationProvider.getApplicationContext();
+    private Context mContext;
     private Context mContextWrapper;
     private IndexerMaintenanceService mIndexerMaintenanceService;
     private MockitoSession session;
@@ -83,6 +83,7 @@ public class ContactsIndexerMaintenanceTest {
     @Before
     public void setUp() {
         MockitoAnnotations.initMocks(this);
+        mContext = ApplicationProvider.getApplicationContext();
         mContextWrapper = new ContextWrapper(mContext) {
             @Override
             @Nullable
@@ -99,7 +100,6 @@ public class ContactsIndexerMaintenanceTest {
                 mockStatic(LocalManagerRegistry.class).
                 startMocking();
         mExtras = new PersistableBundle();
-        mExtras.putInt("indexer_type", CONTACTS_INDEXER);
         mParams = Mockito.mock(JobParameters.class);
     }
 
@@ -246,20 +246,54 @@ public class ContactsIndexerMaintenanceTest {
     }
 
     @Test
-    public void testDoFullUpdateForUser_withInitializedLocalService_isSuccessful() {
+    public void testDoUpdateForUser_withInitializedLocalService_isSuccessful() {
         when(mParams.getExtras()).thenReturn(mExtras);
-        ExtendedMockito.doReturn(Mockito.mock(ContactsIndexerManagerService.LocalService.class))
-                .when(() -> LocalManagerRegistry.getManager(
-                        ContactsIndexerManagerService.LocalService.class));
+        mExtras.putInt(IndexerMaintenanceService.INDEXER_TYPE, CONTACTS_INDEXER);
+        ContactsIndexerManagerService.LocalService mockService = Mockito.mock(
+                ContactsIndexerManagerService.LocalService.class);
+        ExtendedMockito.doReturn(mockService).when(() -> LocalManagerRegistry.getManager(
+                ContactsIndexerManagerService.LocalService.class));
+        CancellationSignal signal = new CancellationSignal();
         boolean updateSucceeded =
                 mIndexerMaintenanceService.doUpdateForUser(
-                        mContextWrapper, mParams, DEFAULT_USER_HANDLE, new CancellationSignal());
+                        mContextWrapper, mParams, DEFAULT_USER_HANDLE, signal);
         assertThat(updateSucceeded).isTrue();
+        verify(mockService).doUpdateForUser(DEFAULT_USER_HANDLE, signal);
+    }
+
+    @Test
+    public void testDoUpdateForUser_withInitializedLocalService_withoutIndexerType_isSuccessful() {
+        when(mParams.getExtras()).thenReturn(mExtras);
+        ContactsIndexerManagerService.LocalService mockService = Mockito.mock(
+                ContactsIndexerManagerService.LocalService.class);
+        ExtendedMockito.doReturn(mockService).when(() -> LocalManagerRegistry.getManager(
+                ContactsIndexerManagerService.LocalService.class));
+        CancellationSignal signal = new CancellationSignal();
+        boolean updateSucceeded =
+                mIndexerMaintenanceService.doUpdateForUser(
+                        mContextWrapper, mParams, DEFAULT_USER_HANDLE, signal);
+        assertThat(updateSucceeded).isTrue();
+        verify(mockService).doUpdateForUser(DEFAULT_USER_HANDLE, signal);
+    }
+
+    @Test
+    public void testOnStartJob_withInitializedLocalService_withoutIndexerType_isSuccessful() {
+        when(mParams.getExtras()).thenReturn(mExtras);
+        mExtras.putInt(IndexerMaintenanceService.EXTRA_USER_ID, 0);
+        ContactsIndexerManagerService.LocalService mockService = Mockito.mock(
+                ContactsIndexerManagerService.LocalService.class);
+        ExtendedMockito.doReturn(mockService).when(() -> LocalManagerRegistry.getManager(
+                ContactsIndexerManagerService.LocalService.class));
+        assertThat(mIndexerMaintenanceService.onStartJob(mParams)).isTrue();
+        verify(mIndexerMaintenanceService, timeout(10000)).doUpdateForUser(any(), any(), any(),
+                any());
+        verify(mockService, timeout(10000)).doUpdateForUser(any(), any());
     }
 
     @Test
-    public void testDoFullUpdateForUser_withUninitializedLocalService_failsGracefully() {
+    public void testDoUpdateForUser_withUninitializedLocalService_failsGracefully() {
         when(mParams.getExtras()).thenReturn(mExtras);
+        mExtras.putInt(IndexerMaintenanceService.INDEXER_TYPE, CONTACTS_INDEXER);
         ExtendedMockito.doReturn(null)
                 .when(() -> LocalManagerRegistry.getManager(
                         ContactsIndexerManagerService.LocalService.class));
@@ -270,8 +304,9 @@ public class ContactsIndexerMaintenanceTest {
     }
 
     @Test
-    public void testDoFullUpdateForUser_onEncounteringException_failsGracefully() {
+    public void testDoUpdateForUser_onEncounteringException_failsGracefully() {
         when(mParams.getExtras()).thenReturn(mExtras);
+        mExtras.putInt(IndexerMaintenanceService.INDEXER_TYPE, CONTACTS_INDEXER);
         ContactsIndexerManagerService.LocalService mockService = Mockito.mock(
                 ContactsIndexerManagerService.LocalService.class);
         doThrow(RuntimeException.class).when(mockService).doUpdateForUser(any(), any());
@@ -287,8 +322,9 @@ public class ContactsIndexerMaintenanceTest {
     }
 
     @Test
-    public void testDoFullUpdateForUser_cancelsBackgroundJob_whenCiDisabled() {
+    public void testDoUpdateForUser_cancelsBackgroundJob_whenCiDisabled() {
         when(mParams.getExtras()).thenReturn(mExtras);
+        mExtras.putInt(IndexerMaintenanceService.INDEXER_TYPE, CONTACTS_INDEXER);
         ExtendedMockito.doReturn(null)
                 .when(() -> LocalManagerRegistry.getManager(
                         ContactsIndexerManagerService.LocalService.class));
@@ -300,8 +336,9 @@ public class ContactsIndexerMaintenanceTest {
     }
 
     @Test
-    public void testDoFullUpdateForUser_doesNotCancelBackgroundJob_whenCiEnabled() {
+    public void testDoUpdateForUser_doesNotCancelBackgroundJob_whenCiEnabled() {
         when(mParams.getExtras()).thenReturn(mExtras);
+        mExtras.putInt(IndexerMaintenanceService.INDEXER_TYPE, CONTACTS_INDEXER);
         ExtendedMockito.doReturn(Mockito.mock(ContactsIndexerManagerService.LocalService.class))
                 .when(() -> LocalManagerRegistry.getManager(
                         ContactsIndexerManagerService.LocalService.class));
@@ -313,7 +350,7 @@ public class ContactsIndexerMaintenanceTest {
     }
 
     @Test
-    public void testCancelPendingFullUpdateJob_succeeds() throws IOException {
+    public void testCancelPendingFullUpdateJob_succeeds() {
         UserInfo userInfo = new UserInfo(DEFAULT_USER_ID, /*name=*/ "default", /*flags=*/ 0);
         SystemService.TargetUser user = new SystemService.TargetUser(userInfo);
         UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
@@ -340,12 +377,12 @@ public class ContactsIndexerMaintenanceTest {
 
     @Test
     public void test_onStartJob_handlesExceptionGracefully() {
-        mIndexerMaintenanceService.onStartJob(mParams);
+        mIndexerMaintenanceService.onStartJob(null);
     }
 
     @Test
     public void test_onStopJob_handlesExceptionGracefully() {
-        mIndexerMaintenanceService.onStopJob(mParams);
+        mIndexerMaintenanceService.onStopJob(null);
     }
 
     @Nullable
diff --git a/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/EnterpriseContactsTest.java b/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/EnterpriseContactsTest.java
index 1a327313..8435d7f6 100644
--- a/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/EnterpriseContactsTest.java
+++ b/testing/contactsindexertests/src/com/android/server/appsearch/contactsindexer/EnterpriseContactsTest.java
@@ -19,6 +19,8 @@ package com.android.server.appsearch.contactsindexer;
 import static android.app.appsearch.testutil.AppSearchTestUtils.checkIsBatchResultSuccess;
 import static android.app.appsearch.testutil.AppSearchTestUtils.convertSearchResultsToDocuments;
 
+import static com.android.bedstead.enterprise.EnterpriseDeviceStateExtensionsKt.profileOwner;
+import static com.android.bedstead.enterprise.EnterpriseDeviceStateExtensionsKt.workProfile;
 import static com.android.bedstead.harrier.UserType.WORK_PROFILE;
 import static com.android.bedstead.permissions.CommonPermissions.INTERACT_ACROSS_USERS_FULL;
 import static com.android.bedstead.permissions.CommonPermissions.WRITE_CONTACTS;
@@ -145,11 +147,11 @@ public class EnterpriseContactsTest {
         // Install the test package for the work profile, otherwise the test will fail while
         // performing any operations with the enterprise profile context.
         TestApis.packages().find(ApplicationProvider.getApplicationContext().getPackageName())
-                .installExisting(sDeviceState.workProfile());
+                .installExisting(workProfile(sDeviceState));
 
         // This is a context for the testing package under the work profile; it's not actually
         // possible to get a context for the "android" package in this way
-        mContext = TestApis.context().androidContextAsUser(sDeviceState.workProfile());
+        mContext = TestApis.context().androidContextAsUser(workProfile(sDeviceState));
 
         // Set up AppSearch contacts in the managed profile
         mAppSearchHelper = AppSearchHelper.createAppSearchHelper(mContext, mSingleThreadedExecutor);
@@ -407,7 +409,7 @@ public class EnterpriseContactsTest {
         // Allowlist blocks all packages by default; blocklist allows all packages by default
         PackagePolicy allowlist = new PackagePolicy(PackagePolicy.PACKAGE_POLICY_ALLOWLIST);
         PackagePolicy blocklist = new PackagePolicy(PackagePolicy.PACKAGE_POLICY_BLOCKLIST);
-        try (RemoteDpc remoteDpc = sDeviceState.profileOwner(WORK_PROFILE)) {
+        try (RemoteDpc remoteDpc = profileOwner(sDeviceState, WORK_PROFILE)) {
             remoteDpc.devicePolicyManager().setManagedProfileCallerIdAccessPolicy(allowlist);
             remoteDpc.devicePolicyManager().setManagedProfileContactsAccessPolicy(blocklist);
 
@@ -433,7 +435,7 @@ public class EnterpriseContactsTest {
     public void testEnterpriseContacts_canNotAccessWithoutContactsAccess() throws Exception {
         // Allowlist blocks all packages by default
         PackagePolicy allowlist = new PackagePolicy(PackagePolicy.PACKAGE_POLICY_ALLOWLIST);
-        try (RemoteDpc remoteDpc = sDeviceState.profileOwner(WORK_PROFILE)) {
+        try (RemoteDpc remoteDpc = profileOwner(sDeviceState, WORK_PROFILE)) {
             remoteDpc.devicePolicyManager().setManagedProfileContactsAccessPolicy(allowlist);
 
             // Verify we can't get the Person schema
@@ -460,7 +462,7 @@ public class EnterpriseContactsTest {
         // Allowlist blocks all packages by default; blocklist allows all packages by default
         PackagePolicy allowlist = new PackagePolicy(PackagePolicy.PACKAGE_POLICY_ALLOWLIST);
         PackagePolicy blocklist = new PackagePolicy(PackagePolicy.PACKAGE_POLICY_BLOCKLIST);
-        try (RemoteDpc remoteDpc = sDeviceState.profileOwner(WORK_PROFILE)) {
+        try (RemoteDpc remoteDpc = profileOwner(sDeviceState, WORK_PROFILE)) {
             remoteDpc.devicePolicyManager().setManagedProfileCallerIdAccessPolicy(blocklist);
             remoteDpc.devicePolicyManager().setManagedProfileContactsAccessPolicy(allowlist);
 
@@ -649,27 +651,50 @@ public class EnterpriseContactsTest {
     private String getCorpLookupUri(long contactId) {
         ContentResolver resolver = ApplicationProvider.getApplicationContext().getContentResolver();
         long enterpriseId = ENTERPRISE_CONTACT_ID_BASE + contactId;
-        String[] projection = new String[] { ContactsContract.Data.LOOKUP_KEY };
+        String[] projection =
+                new String[]{ContactsContract.Contacts._ID, ContactsContract.Data.LOOKUP_KEY};
         String selection = ContactsContract.Contacts._ID + " = " + contactId;
         try (Cursor cursor = resolver.query(ContactsContract.Contacts.ENTERPRISE_CONTENT_URI,
                 projection, selection, /*selectionArgs=*/ null, /*sortOrder=*/ null)) {
             assertThat(cursor).isNotNull();
-            assertThat(cursor.moveToNext()).isTrue();
+            int contactIdIndex = cursor.getColumnIndex(ContactsContract.Data._ID);
+            int lookupKeyIndex = cursor.getColumnIndex(ContactsContract.Data.LOOKUP_KEY);
+            // Querying the enterprise contact uri by contact id can potentially return a matching
+            // main profile contact and an enterprise profile contact but the enterprise profile
+            // contact will have an enterprise id
+            while (cursor.moveToNext()) {
+                if (cursor.getLong(contactIdIndex) == enterpriseId) {
+                    break;
+                }
+            }
+            assertThat(cursor.isAfterLast()).isFalse();
             return ContactsContract.Contacts.getLookupUri(enterpriseId,
-                    cursor.getString(0)).toString();
+                    cursor.getString(lookupKeyIndex)).toString();
         }
     }
 
     /** Returns the corp image uri of the given contact through enterprise contacts CP2. */
     private String getCorpImageUri(long contactId) {
         ContentResolver resolver = ApplicationProvider.getApplicationContext().getContentResolver();
-        String[] projection = new String[] { ContactsContract.Data.PHOTO_THUMBNAIL_URI };
+        long enterpriseId = ENTERPRISE_CONTACT_ID_BASE + contactId;
+        String[] projection = new String[]{ContactsContract.Contacts._ID,
+                ContactsContract.Data.PHOTO_THUMBNAIL_URI};
         String selection = ContactsContract.Contacts._ID + " = " + contactId;
         try (Cursor cursor = resolver.query(ContactsContract.Contacts.ENTERPRISE_CONTENT_URI,
                 projection, selection, /*selectionArgs=*/ null, /*sortOrder=*/ null)) {
             assertThat(cursor).isNotNull();
-            assertThat(cursor.moveToNext()).isTrue();
-            return cursor.getString(0);
+            int contactIdIndex = cursor.getColumnIndex(ContactsContract.Data._ID);
+            int photoUriIndex = cursor.getColumnIndex(ContactsContract.Data.PHOTO_THUMBNAIL_URI);
+            // Querying the enterprise contact uri by contact id can potentially return a matching
+            // main profile contact and an enterprise profile contact but the enterprise profile
+            // contact will have an enterprise id
+            while (cursor.moveToNext()) {
+                if (cursor.getLong(contactIdIndex) == enterpriseId) {
+                    break;
+                }
+            }
+            assertThat(cursor.isAfterLast()).isFalse();
+            return cursor.getString(photoUriIndex);
         }
     }
 }
diff --git a/testing/coretests/src/android/app/appsearch/AppSearchSessionInternalTest.java b/testing/coretests/src/android/app/appsearch/AppSearchSessionInternalTest.java
index 1cf25f7d..f97930af 100644
--- a/testing/coretests/src/android/app/appsearch/AppSearchSessionInternalTest.java
+++ b/testing/coretests/src/android/app/appsearch/AppSearchSessionInternalTest.java
@@ -20,18 +20,17 @@ import static android.app.appsearch.testutil.AppSearchTestUtils.convertSearchRes
 
 import static com.google.common.truth.Truth.assertThat;
 
+import static org.junit.Assume.assumeFalse;
 import static org.junit.Assume.assumeTrue;
 
 import android.app.appsearch.AppSearchSchema.PropertyConfig;
 import android.app.appsearch.AppSearchSchema.StringPropertyConfig;
-import android.app.appsearch.testutil.AppSearchEmail;
 import android.app.appsearch.testutil.AppSearchSessionShimImpl;
 import android.content.Context;
 
 import androidx.annotation.NonNull;
 import androidx.test.core.app.ApplicationProvider;
 
-import com.google.common.collect.ImmutableList;
 import com.google.common.util.concurrent.ListenableFuture;
 
 import org.junit.Test;
@@ -59,123 +58,21 @@ public class AppSearchSessionInternalTest extends AppSearchSessionInternalTestBa
                 context, new AppSearchManager.SearchContext.Builder(dbName).build(), executor);
     }
 
-    // TODO(b/290389974) Remove this override once GenericDocument#getParentTypes is unhidden.
+    // TODO(b/371610934): Remove this test once GenericDocument#setParentTypes is removed.
     @Override
     @Test
-    public void testQuery_typeFilterWithPolymorphism() throws Exception {
+    @SuppressWarnings("deprecation")
+    public void testQuery_genericDocumentWrapsParentTypeForPolymorphism() throws Exception {
         assumeTrue(mDb1.getFeatures().isFeatureSupported(Features.SCHEMA_ADD_PARENT_TYPE));
+        // When SearchResult does not wrap parent information, GenericDocument should do.
+        assumeFalse(mDb1.getFeatures().isFeatureSupported(Features.SEARCH_RESULT_PARENT_TYPES));
 
         // Schema registration
         AppSearchSchema personSchema =
                 new AppSearchSchema.Builder("Person")
                         .addProperty(
                                 new StringPropertyConfig.Builder("name")
-                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .build())
-                        .build();
-        AppSearchSchema artistSchema =
-                new AppSearchSchema.Builder("Artist")
-                        .addParentType("Person")
-                        .addProperty(
-                                new StringPropertyConfig.Builder("name")
-                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .build())
-                        .build();
-        mDb1.setSchemaAsync(
-                        new SetSchemaRequest.Builder()
-                                .addSchemas(personSchema)
-                                .addSchemas(artistSchema)
-                                .addSchemas(AppSearchEmail.SCHEMA)
-                                .build())
-                .get();
-
-        // Index some documents
-        GenericDocument personDoc =
-                new GenericDocument.Builder<>("namespace", "id1", "Person")
-                        .setPropertyString("name", "Foo")
-                        .build();
-        GenericDocument artistDoc =
-                new GenericDocument.Builder<>("namespace", "id2", "Artist")
-                        .setPropertyString("name", "Foo")
-                        .build();
-        AppSearchEmail emailDoc =
-                new AppSearchEmail.Builder("namespace", "id3")
-                        .setFrom("from@example.com")
-                        .setTo("to1@example.com", "to2@example.com")
-                        .setSubject("testPut example")
-                        .setBody("Foo")
-                        .build();
-        checkIsBatchResultSuccess(
-                mDb1.putAsync(
-                        new PutDocumentsRequest.Builder()
-                                .addGenericDocuments(personDoc, artistDoc, emailDoc)
-                                .build()));
-        GenericDocument artistDocWithParent =
-                artistDoc.toBuilder()
-                        .setPropertyString(PARENT_TYPES_SYNTHETIC_PROPERTY, "Person")
-                        .build();
-
-        // Query for the documents
-        SearchResultsShim searchResults =
-                mDb1.search(
-                        "Foo",
-                        new SearchSpec.Builder()
-                                .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
-                                .build());
-        List<GenericDocument> documents = convertSearchResultsToDocuments(searchResults);
-        assertThat(documents).hasSize(3);
-        assertThat(documents).containsExactly(personDoc, artistDocWithParent, emailDoc);
-
-        // Query with a filter for the "Person" type should also include the "Artist" type.
-        searchResults =
-                mDb1.search(
-                        "Foo",
-                        new SearchSpec.Builder()
-                                .addFilterSchemas("Person")
-                                .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
-                                .build());
-        documents = convertSearchResultsToDocuments(searchResults);
-        assertThat(documents).hasSize(2);
-        assertThat(documents).containsExactly(personDoc, artistDocWithParent);
-
-        // Query with a filters for the "Artist" type should not include the "Person" type.
-        searchResults =
-                mDb1.search(
-                        "Foo",
-                        new SearchSpec.Builder()
-                                .addFilterSchemas("Artist")
-                                .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
-                                .build());
-        documents = convertSearchResultsToDocuments(searchResults);
-        assertThat(documents).hasSize(1);
-        assertThat(documents).containsExactly(artistDocWithParent);
-    }
-
-    // TODO(b/290389974) Remove this override once GenericDocument#getParentTypes is unhidden.
-    @Override
-    @Test
-    public void testQuery_projectionWithPolymorphism() throws Exception {
-        assumeTrue(mDb1.getFeatures().isFeatureSupported(Features.SCHEMA_ADD_PARENT_TYPE));
-
-        // Schema registration
-        AppSearchSchema personSchema =
-                new AppSearchSchema.Builder("Person")
-                        .addProperty(
-                                new StringPropertyConfig.Builder("name")
-                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .build())
-                        .addProperty(
-                                new StringPropertyConfig.Builder("emailAddress")
-                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
                                         .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
                                         .setIndexingType(
                                                 StringPropertyConfig.INDEXING_TYPE_PREFIXES)
@@ -186,103 +83,22 @@ public class AppSearchSessionInternalTest extends AppSearchSessionInternalTestBa
                         .addParentType("Person")
                         .addProperty(
                                 new StringPropertyConfig.Builder("name")
-                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .build())
-                        .addProperty(
-                                new StringPropertyConfig.Builder("emailAddress")
-                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
                                         .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
                                         .setIndexingType(
                                                 StringPropertyConfig.INDEXING_TYPE_PREFIXES)
                                         .build())
                         .addProperty(
                                 new StringPropertyConfig.Builder("company")
-                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .build())
-                        .build();
-        mDb1.setSchemaAsync(
-                        new SetSchemaRequest.Builder()
-                                .addSchemas(personSchema)
-                                .addSchemas(artistSchema)
-                                .build())
-                .get();
-
-        // Index two documents
-        GenericDocument personDoc =
-                new GenericDocument.Builder<>("namespace", "id1", "Person")
-                        .setCreationTimestampMillis(1000)
-                        .setPropertyString("name", "Foo Person")
-                        .setPropertyString("emailAddress", "person@gmail.com")
-                        .build();
-        GenericDocument artistDoc =
-                new GenericDocument.Builder<>("namespace", "id2", "Artist")
-                        .setCreationTimestampMillis(1000)
-                        .setPropertyString("name", "Foo Artist")
-                        .setPropertyString("emailAddress", "artist@gmail.com")
-                        .setPropertyString("company", "Company")
-                        .build();
-        checkIsBatchResultSuccess(
-                mDb1.putAsync(
-                        new PutDocumentsRequest.Builder()
-                                .addGenericDocuments(personDoc, artistDoc)
-                                .build()));
-
-        // Query with type property paths {"Person", ["name"]}, {"Artist", ["emailAddress"]}
-        // This will be expanded to paths {"Person", ["name"]}, {"Artist", ["name", "emailAddress"]}
-        // via polymorphism.
-        SearchResultsShim searchResults =
-                mDb1.search(
-                        "Foo",
-                        new SearchSpec.Builder()
-                                .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
-                                .addProjection("Person", ImmutableList.of("name"))
-                                .addProjection("Artist", ImmutableList.of("emailAddress"))
-                                .build());
-        List<GenericDocument> documents = convertSearchResultsToDocuments(searchResults);
-
-        // The person document should have been returned with only the "name" property. The artist
-        // document should have been returned with all of its properties.
-        GenericDocument expectedPerson =
-                new GenericDocument.Builder<>("namespace", "id1", "Person")
-                        .setCreationTimestampMillis(1000)
-                        .setPropertyString("name", "Foo Person")
-                        .build();
-        GenericDocument expectedArtist =
-                new GenericDocument.Builder<>("namespace", "id2", "Artist")
-                        .setCreationTimestampMillis(1000)
-                        .setPropertyString("name", "Foo Artist")
-                        .setPropertyString("emailAddress", "artist@gmail.com")
-                        .setPropertyString(PARENT_TYPES_SYNTHETIC_PROPERTY, "Person")
-                        .build();
-        assertThat(documents).containsExactly(expectedPerson, expectedArtist);
-    }
-
-    // TODO(b/290389974) Remove this override once GenericDocument#getParentTypes is unhidden.
-    @Override
-    @Test
-    public void testQuery_indexBasedOnParentTypePolymorphism() throws Exception {
-        assumeTrue(mDb1.getFeatures().isFeatureSupported(Features.SCHEMA_ADD_PARENT_TYPE));
-
-        // Schema registration
-        AppSearchSchema personSchema =
-                new AppSearchSchema.Builder("Person")
-                        .addProperty(
-                                new StringPropertyConfig.Builder("name")
                                         .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
                                         .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
                                         .setIndexingType(
                                                 StringPropertyConfig.INDEXING_TYPE_PREFIXES)
                                         .build())
                         .build();
-        AppSearchSchema artistSchema =
-                new AppSearchSchema.Builder("Artist")
-                        .addParentType("Person")
+        AppSearchSchema musicianSchema =
+                new AppSearchSchema.Builder("Musician")
+                        .addParentType("Artist")
                         .addProperty(
                                 new StringPropertyConfig.Builder("name")
                                         .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
@@ -302,8 +118,8 @@ public class AppSearchSessionInternalTest extends AppSearchSessionInternalTestBa
                 new AppSearchSchema.Builder("Message")
                         .addProperty(
                                 new AppSearchSchema.DocumentPropertyConfig.Builder(
-                                                "sender", "Person")
-                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
+                                                "receivers", "Person")
+                                        .setCardinality(PropertyConfig.CARDINALITY_REPEATED)
                                         .setShouldIndexNestedProperties(true)
                                         .build())
                         .build();
@@ -311,447 +127,67 @@ public class AppSearchSessionInternalTest extends AppSearchSessionInternalTestBa
                         new SetSchemaRequest.Builder()
                                 .addSchemas(personSchema)
                                 .addSchemas(artistSchema)
+                                .addSchemas(musicianSchema)
                                 .addSchemas(messageSchema)
                                 .build())
                 .get();
 
-        // Index some an artistDoc and a messageDoc
-        GenericDocument artistDoc =
-                new GenericDocument.Builder<>("namespace", "id1", "Artist")
-                        .setPropertyString("name", "Foo")
-                        .setPropertyString("company", "Bar")
-                        .build();
-        GenericDocument messageDoc =
-                new GenericDocument.Builder<>("namespace", "id2", "Message")
-                        // sender is defined as a Person, which accepts an A"rtist because Artist <:
-                        // Person.
-                        // However, indexing will be based on what's defined in Person, so the
-                        // "company"
-                        // property in artistDoc cannot be used to search this messageDoc.
-                        .setPropertyDocument("sender", artistDoc)
-                        .build();
-        checkIsBatchResultSuccess(
-                mDb1.putAsync(
-                        new PutDocumentsRequest.Builder()
-                                .addGenericDocuments(artistDoc, messageDoc)
-                                .build()));
-        GenericDocument expectedArtistDoc =
-                artistDoc.toBuilder()
-                        .setPropertyString(PARENT_TYPES_SYNTHETIC_PROPERTY, "Person")
-                        .build();
-        GenericDocument expectedMessageDoc =
-                messageDoc.toBuilder().setPropertyDocument("sender", expectedArtistDoc).build();
-
-        // Query for the documents
-        SearchResultsShim searchResults =
-                mDb1.search(
-                        "Foo",
-                        new SearchSpec.Builder()
-                                .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
-                                .build());
-        List<GenericDocument> documents = convertSearchResultsToDocuments(searchResults);
-        assertThat(documents).hasSize(2);
-        assertThat(documents).containsExactly(expectedArtistDoc, expectedMessageDoc);
-
-        // The "company" property in artistDoc cannot be used to search messageDoc.
-        searchResults =
-                mDb1.search(
-                        "Bar",
-                        new SearchSpec.Builder()
-                                .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
-                                .build());
-        documents = convertSearchResultsToDocuments(searchResults);
-        assertThat(documents).hasSize(1);
-        assertThat(documents).containsExactly(expectedArtistDoc);
-    }
-
-    // TODO(b/290389974) Remove this override once GenericDocument#getParentTypes is unhidden.
-    @Override
-    @Test
-    public void testQuery_parentTypeListIsTopologicalOrder() throws Exception {
-        assumeTrue(mDb1.getFeatures().isFeatureSupported(Features.SCHEMA_ADD_PARENT_TYPE));
-
-        // Create the following subtype relation graph, where
-        // 1. A's direct parents are B and C.
-        // 2. B's direct parent is D.
-        // 3. C's direct parent is B and D.
-        // DFS order from A: [A, B, D, C]. Not acceptable because B and D appear before C.
-        // BFS order from A: [A, B, C, D]. Not acceptable because B appears before C.
-        // Topological order (all subtypes appear before supertypes) from A: [A, C, B, D].
-        AppSearchSchema schemaA =
-                new AppSearchSchema.Builder("A").addParentType("B").addParentType("C").build();
-        AppSearchSchema schemaB = new AppSearchSchema.Builder("B").addParentType("D").build();
-        AppSearchSchema schemaC =
-                new AppSearchSchema.Builder("C").addParentType("B").addParentType("D").build();
-        AppSearchSchema schemaD = new AppSearchSchema.Builder("D").build();
-        mDb1.setSchemaAsync(
-                        new SetSchemaRequest.Builder()
-                                .addSchemas(schemaA)
-                                .addSchemas(schemaB)
-                                .addSchemas(schemaC)
-                                .addSchemas(schemaD)
-                                .build())
-                .get();
-
-        // Index some documents
-        GenericDocument docA = new GenericDocument.Builder<>("namespace", "id1", "A").build();
-        GenericDocument docB = new GenericDocument.Builder<>("namespace", "id2", "B").build();
-        GenericDocument docC = new GenericDocument.Builder<>("namespace", "id3", "C").build();
-        GenericDocument docD = new GenericDocument.Builder<>("namespace", "id4", "D").build();
-        checkIsBatchResultSuccess(
-                mDb1.putAsync(
-                        new PutDocumentsRequest.Builder()
-                                .addGenericDocuments(docA, docB, docC, docD)
-                                .build()));
-
-        GenericDocument expectedDocA =
-                docA.toBuilder()
-                        .setPropertyString(PARENT_TYPES_SYNTHETIC_PROPERTY, "C", "B", "D")
-                        .build();
-        GenericDocument expectedDocB =
-                docB.toBuilder()
-                        .setPropertyString(PARENT_TYPES_SYNTHETIC_PROPERTY, "D")
-                        .build();
-        GenericDocument expectedDocC =
-                docC.toBuilder()
-                        .setPropertyString(PARENT_TYPES_SYNTHETIC_PROPERTY, "B", "D")
-                        .build();
-        // Query for the documents
-        SearchResultsShim searchResults = mDb1.search("", new SearchSpec.Builder().build());
-        List<GenericDocument> documents = convertSearchResultsToDocuments(searchResults);
-        assertThat(documents).hasSize(4);
-        assertThat(documents).containsExactly(expectedDocA, expectedDocB, expectedDocC, docD);
-    }
-
-    // TODO(b/290389974) Remove this override once GenericDocument#getParentTypes is unhidden.
-    @Override
-    @Test
-    public void testQuery_wildcardProjection_polymorphism() throws Exception {
-        assumeTrue(mDb1.getFeatures().isFeatureSupported(Features.SCHEMA_ADD_PARENT_TYPE));
-        AppSearchSchema messageSchema =
-                new AppSearchSchema.Builder("Message")
-                        .addProperty(
-                                new StringPropertyConfig.Builder("sender")
-                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .build())
-                        .addProperty(
-                                new StringPropertyConfig.Builder("content")
-                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .build())
-                        .build();
-        AppSearchSchema textSchema =
-                new AppSearchSchema.Builder("Text")
-                        .addParentType("Message")
-                        .addProperty(
-                                new StringPropertyConfig.Builder("sender")
-                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .build())
-                        .addProperty(
-                                new StringPropertyConfig.Builder("content")
-                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .build())
-                        .build();
-        AppSearchSchema emailSchema =
-                new AppSearchSchema.Builder("Email")
-                        .addParentType("Message")
-                        .addProperty(
-                                new StringPropertyConfig.Builder("sender")
-                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .build())
-                        .addProperty(
-                                new StringPropertyConfig.Builder("content")
-                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .build())
-                        .build();
-
-        // Schema registration
-        mDb1.setSchemaAsync(
-                        new SetSchemaRequest.Builder()
-                                .addSchemas(messageSchema, textSchema, emailSchema)
-                                .build())
-                .get();
-
-        // Index two child documents
-        GenericDocument text =
-                new GenericDocument.Builder<>("namespace", "id1", "Text")
-                        .setCreationTimestampMillis(1000)
-                        .setPropertyString("sender", "Some sender")
-                        .setPropertyString("content", "Some note")
-                        .build();
-        GenericDocument email =
-                new GenericDocument.Builder<>("namespace", "id2", "Email")
-                        .setCreationTimestampMillis(1000)
-                        .setPropertyString("sender", "Some sender")
-                        .setPropertyString("content", "Some note")
-                        .build();
-        checkIsBatchResultSuccess(
-                mDb1.putAsync(
-                        new PutDocumentsRequest.Builder()
-                                .addGenericDocuments(email, text)
-                                .build()));
-
-        SearchResultsShim searchResults =
-                mDb1.search(
-                        "Some",
-                        new SearchSpec.Builder()
-                                .addFilterSchemas("Message")
-                                .addProjection(
-                                        SearchSpec.SCHEMA_TYPE_WILDCARD, ImmutableList.of("sender"))
-                                .addFilterProperties(
-                                        SearchSpec.SCHEMA_TYPE_WILDCARD,
-                                        ImmutableList.of("content"))
-                                .build());
-        List<GenericDocument> documents = convertSearchResultsToDocuments(searchResults);
-
-        // We specified the parent document in the filter schemas, but only indexed child documents.
-        // As we also specified a wildcard schema type projection, it should apply to the child docs
-        // The content property must not appear. Also emailNoContent should not appear as we are
-        // filter on the content property
-        GenericDocument expectedText =
-                new GenericDocument.Builder<>("namespace", "id1", "Text")
+        // Index documents
+        GenericDocument personDoc =
+                new GenericDocument.Builder<>("namespace", "id1", "Person")
                         .setCreationTimestampMillis(1000)
-                        .setPropertyString(PARENT_TYPES_SYNTHETIC_PROPERTY, "Message")
-                        .setPropertyString("sender", "Some sender")
+                        .setPropertyString("name", "person")
                         .build();
-        GenericDocument expectedEmail =
-                new GenericDocument.Builder<>("namespace", "id2", "Email")
+        GenericDocument artistDoc =
+                new GenericDocument.Builder<>("namespace", "id2", "Artist")
                         .setCreationTimestampMillis(1000)
-                        .setPropertyString(PARENT_TYPES_SYNTHETIC_PROPERTY, "Message")
-                        .setPropertyString("sender", "Some sender")
-                        .build();
-        assertThat(documents).containsExactly(expectedText, expectedEmail);
-    }
-
-    // TODO(b/290389974) Remove this override once GenericDocument#getParentTypes is unhidden.
-    @Override
-    @Test
-    public void testQuery_wildcardFilterSchema_polymorphism() throws Exception {
-        assumeTrue(mDb1.getFeatures().isFeatureSupported(Features.SCHEMA_ADD_PARENT_TYPE));
-        AppSearchSchema messageSchema =
-                new AppSearchSchema.Builder("Message")
-                        .addProperty(
-                                new StringPropertyConfig.Builder("content")
-                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .build())
-                        .build();
-        AppSearchSchema textSchema =
-                new AppSearchSchema.Builder("Text")
-                        .addParentType("Message")
-                        .addProperty(
-                                new StringPropertyConfig.Builder("content")
-                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .build())
-                        .addProperty(
-                                new StringPropertyConfig.Builder("carrier")
-                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .build())
-                        .build();
-        AppSearchSchema emailSchema =
-                new AppSearchSchema.Builder("Email")
-                        .addParentType("Message")
-                        .addProperty(
-                                new StringPropertyConfig.Builder("content")
-                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .build())
-                        .addProperty(
-                                new StringPropertyConfig.Builder("attachment")
-                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .build())
+                        .setPropertyString("name", "artist")
+                        .setPropertyString("company", "foo")
                         .build();
-
-        // Schema registration
-        mDb1.setSchemaAsync(
-                        new SetSchemaRequest.Builder()
-                                .addSchemas(messageSchema, textSchema, emailSchema)
-                                .build())
-                .get();
-
-        // Index two child documents
-        GenericDocument text =
-                new GenericDocument.Builder<>("namespace", "id1", "Text")
+        GenericDocument musicianDoc =
+                new GenericDocument.Builder<>("namespace", "id3", "Musician")
                         .setCreationTimestampMillis(1000)
-                        .setPropertyString("content", "Some note")
-                        .setPropertyString("carrier", "Network Inc")
+                        .setPropertyString("name", "musician")
+                        .setPropertyString("company", "foo")
                         .build();
-        GenericDocument email =
-                new GenericDocument.Builder<>("namespace", "id2", "Email")
+        GenericDocument messageDoc =
+                new GenericDocument.Builder<>("namespace", "id4", "Message")
                         .setCreationTimestampMillis(1000)
-                        .setPropertyString("content", "Some note")
-                        .setPropertyString("attachment", "Network report")
+                        .setPropertyDocument("receivers", artistDoc, musicianDoc)
                         .build();
-
         checkIsBatchResultSuccess(
                 mDb1.putAsync(
                         new PutDocumentsRequest.Builder()
-                                .addGenericDocuments(email, text)
+                                .addGenericDocuments(personDoc, artistDoc, musicianDoc, messageDoc)
                                 .build()));
-
-        // Both email and text would match for "Network", but only text should match as it is in the
-        // right property
-        SearchResultsShim searchResults =
-                mDb1.search(
-                        "Network",
-                        new SearchSpec.Builder()
-                                .addFilterSchemas("Message")
-                                .addFilterProperties(
-                                        SearchSpec.SCHEMA_TYPE_WILDCARD,
-                                        ImmutableList.of("carrier"))
-                                .build());
-        List<GenericDocument> documents = convertSearchResultsToDocuments(searchResults);
-
-        // We specified the parent document in the filter schemas, but only indexed child documents.
-        // As we also specified a wildcard schema type projection, it should apply to the child docs
-        // The content property must not appear. Also emailNoContent should not appear as we are
-        // filter on the content property
-        GenericDocument expectedText =
-                new GenericDocument.Builder<>("namespace", "id1", "Text")
-                        .setCreationTimestampMillis(1000)
-                        .setPropertyString(PARENT_TYPES_SYNTHETIC_PROPERTY, "Message")
-                        .setPropertyString("content", "Some note")
-                        .setPropertyString("carrier", "Network Inc")
-                        .build();
-        assertThat(documents).containsExactly(expectedText);
-    }
-
-    // TODO(b/290389974) Remove this override once GenericDocument#getParentTypes is unhidden.
-    @Override
-    @Test
-    public void testQuery_projectionWithPolymorphismAndSchemaFilter() throws Exception {
-        assumeTrue(mDb1.getFeatures().isFeatureSupported(Features.SCHEMA_ADD_PARENT_TYPE));
-
-        // Schema registration
-        AppSearchSchema personSchema =
-                new AppSearchSchema.Builder("Person")
-                        .addProperty(
-                                new StringPropertyConfig.Builder("name")
-                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .build())
-                        .addProperty(
-                                new StringPropertyConfig.Builder("emailAddress")
-                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .build())
-                        .build();
-        AppSearchSchema artistSchema =
-                new AppSearchSchema.Builder("Artist")
-                        .addParentType("Person")
-                        .addProperty(
-                                new StringPropertyConfig.Builder("name")
-                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .build())
-                        .addProperty(
-                                new StringPropertyConfig.Builder("emailAddress")
-                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .build())
-                        .addProperty(
-                                new StringPropertyConfig.Builder("company")
-                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .build())
+        GenericDocument artistDocWithParent =
+                new GenericDocument.Builder<>(artistDoc)
+                        .setPropertyString(PARENT_TYPES_SYNTHETIC_PROPERTY, "Person")
                         .build();
-        mDb1.setSchemaAsync(
-                        new SetSchemaRequest.Builder()
-                                .addSchemas(personSchema)
-                                .addSchemas(artistSchema)
-                                .build())
-                .get();
-
-        // Index two documents
-        GenericDocument personDoc =
-                new GenericDocument.Builder<>("namespace", "id1", "Person")
-                        .setCreationTimestampMillis(1000)
-                        .setPropertyString("name", "Foo Person")
-                        .setPropertyString("emailAddress", "person@gmail.com")
+        GenericDocument musicianDocWithParent =
+                new GenericDocument.Builder<>(musicianDoc)
+                        .setPropertyString(PARENT_TYPES_SYNTHETIC_PROPERTY, "Artist", "Person")
                         .build();
-        GenericDocument artistDoc =
-                new GenericDocument.Builder<>("namespace", "id2", "Artist")
+        GenericDocument messageDocWithParent =
+                new GenericDocument.Builder<>("namespace", "id4", "Message")
                         .setCreationTimestampMillis(1000)
-                        .setPropertyString("name", "Foo Artist")
-                        .setPropertyString("emailAddress", "artist@gmail.com")
-                        .setPropertyString("company", "Company")
+                        .setPropertyDocument(
+                                "receivers", artistDocWithParent, musicianDocWithParent)
                         .build();
-        checkIsBatchResultSuccess(
-                mDb1.putAsync(
-                        new PutDocumentsRequest.Builder()
-                                .addGenericDocuments(personDoc, artistDoc)
-                                .build()));
 
-        // Query with type property paths {"Person", ["name"]} and {"Artist", ["emailAddress"]}, and
-        // a schema filter for the "Person".
-        // This will be expanded to paths {"Person", ["name"]} and
-        // {"Artist", ["name", "emailAddress"]}, and filters for both "Person" and "Artist" via
-        // polymorphism.
+        // Query to get all the documents
         SearchResultsShim searchResults =
                 mDb1.search(
-                        "Foo",
+                        "",
                         new SearchSpec.Builder()
                                 .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
-                                .addFilterSchemas("Person")
-                                .addProjection("Person", ImmutableList.of("name"))
-                                .addProjection("Artist", ImmutableList.of("emailAddress"))
                                 .build());
         List<GenericDocument> documents = convertSearchResultsToDocuments(searchResults);
-
-        // The person document should have been returned with only the "name" property. The artist
-        // document should have been returned with all of its properties.
-        GenericDocument expectedPerson =
-                new GenericDocument.Builder<>("namespace", "id1", "Person")
-                        .setCreationTimestampMillis(1000)
-                        .setPropertyString("name", "Foo Person")
-                        .build();
-        GenericDocument expectedArtist =
-                new GenericDocument.Builder<>("namespace", "id2", "Artist")
-                        .setPropertyString(PARENT_TYPES_SYNTHETIC_PROPERTY, "Person")
-                        .setCreationTimestampMillis(1000)
-                        .setPropertyString("name", "Foo Artist")
-                        .setPropertyString("emailAddress", "artist@gmail.com")
-                        .build();
-        assertThat(documents).containsExactly(expectedPerson, expectedArtist);
+        assertThat(documents)
+                .containsExactly(
+                        personDoc,
+                        artistDocWithParent,
+                        musicianDocWithParent,
+                        messageDocWithParent);
     }
 }
diff --git a/testing/coretests/src/android/app/appsearch/external/app/AppSearchBlobHandleInternalTest.java b/testing/coretests/src/android/app/appsearch/external/app/AppSearchBlobHandleInternalTest.java
deleted file mode 100644
index faa16375..00000000
--- a/testing/coretests/src/android/app/appsearch/external/app/AppSearchBlobHandleInternalTest.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.app.appsearch;
-
-import static android.app.appsearch.testutil.AppSearchTestUtils.calculateDigest;
-import static android.app.appsearch.testutil.AppSearchTestUtils.generateRandomBytes;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import static org.junit.Assert.assertThrows;
-
-import org.junit.Test;
-
-// TODO(b/273591938) move this to cts test once it's public.
-public class AppSearchBlobHandleInternalTest {
-
-    @Test
-    public void testCreateBlobHandle() throws Exception {
-        byte[] data = generateRandomBytes(10); // 10 Bytes
-        byte[] digest = calculateDigest(data);
-        AppSearchBlobHandle blobHandle = AppSearchBlobHandle.createWithSha256(digest, "label123");
-        assertThat(blobHandle.getLabel()).isEqualTo("label123");
-        assertThat(blobHandle.getSha256Digest()).isEqualTo(digest);
-    }
-
-    @Test
-    public void testBlobHandleIdentical() throws Exception {
-        byte[] data1 = {(byte) 1};
-        byte[] data2 = {(byte) 2};
-        byte[] digest1 = calculateDigest(data1);
-        byte[] digest2 = calculateDigest(data2);
-        AppSearchBlobHandle blobHandle1 = AppSearchBlobHandle.createWithSha256(digest1, "label123");
-        AppSearchBlobHandle blobHandle2 = AppSearchBlobHandle.createWithSha256(digest1, "label123");
-        AppSearchBlobHandle blobHandle3 = AppSearchBlobHandle.createWithSha256(digest1, "321lebal");
-        AppSearchBlobHandle blobHandle4 = AppSearchBlobHandle.createWithSha256(digest2, "label123");
-        assertThat(blobHandle1).isEqualTo(blobHandle2);
-        assertThat(blobHandle1).isNotEqualTo(blobHandle3);
-        assertThat(blobHandle1).isNotEqualTo(blobHandle4);
-        assertThat(blobHandle3).isNotEqualTo(blobHandle4);
-        assertThat(blobHandle1.hashCode()).isEqualTo(blobHandle2.hashCode());
-        assertThat(blobHandle1.hashCode()).isNotEqualTo(blobHandle3.hashCode());
-        assertThat(blobHandle1.hashCode()).isNotEqualTo(blobHandle4.hashCode());
-        assertThat(blobHandle3.hashCode()).isNotEqualTo(blobHandle4.hashCode());
-    }
-
-    @Test
-    public void testCreateBlobHandle_invalidDigest() throws Exception {
-        IllegalArgumentException exception =
-                assertThrows(
-                        IllegalArgumentException.class,
-                        () -> AppSearchBlobHandle.createWithSha256(new byte[10], "label123"));
-        assertThat(exception).hasMessageThat().contains("The digest is not a SHA-256 digest");
-    }
-
-    @Test
-    public void testCreateBlobHandle_emptyLabel() throws Exception {
-        byte[] data = {(byte) 1};
-        byte[] digest = calculateDigest(data);
-        AppSearchBlobHandle blobHandle1 = AppSearchBlobHandle.createWithSha256(digest);
-        AppSearchBlobHandle blobHandle2 =
-                AppSearchBlobHandle.createWithSha256(digest, /* label= */ "");
-        assertThat(blobHandle1).isEqualTo(blobHandle2);
-        assertThat(blobHandle1.hashCode()).isEqualTo(blobHandle2.hashCode());
-    }
-}
diff --git a/testing/coretests/src/android/app/appsearch/external/app/AppSearchSessionInternalTestBase.java b/testing/coretests/src/android/app/appsearch/external/app/AppSearchSessionInternalTestBase.java
index 5c5b635e..90bb6ea1 100644
--- a/testing/coretests/src/android/app/appsearch/external/app/AppSearchSessionInternalTestBase.java
+++ b/testing/coretests/src/android/app/appsearch/external/app/AppSearchSessionInternalTestBase.java
@@ -21,12 +21,12 @@ import static android.app.appsearch.testutil.AppSearchTestUtils.convertSearchRes
 
 import static com.google.common.truth.Truth.assertThat;
 
+import static org.junit.Assume.assumeFalse;
 import static org.junit.Assume.assumeTrue;
 
 import android.annotation.NonNull;
 import android.app.appsearch.AppSearchSchema.PropertyConfig;
 import android.app.appsearch.AppSearchSchema.StringPropertyConfig;
-import android.app.appsearch.testutil.AppSearchEmail;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.util.concurrent.ListenableFuture;
@@ -35,8 +35,6 @@ import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Set;
@@ -109,223 +107,20 @@ public abstract class AppSearchSessionInternalTestBase {
         assertThat(actual).containsExactlyElementsIn(request.getSchemas());
     }
 
+    // TODO(b/371610934): Remove this test once GenericDocument#setParentTypes is removed.
     @Test
-    public void testQuery_typeFilterWithPolymorphism() throws Exception {
+    @SuppressWarnings("deprecation")
+    public void testQuery_genericDocumentWrapsParentTypeForPolymorphism() throws Exception {
         assumeTrue(mDb1.getFeatures().isFeatureSupported(Features.SCHEMA_ADD_PARENT_TYPE));
+        // When SearchResult does not wrap parent information, GenericDocument should do.
+        assumeFalse(mDb1.getFeatures().isFeatureSupported(Features.SEARCH_RESULT_PARENT_TYPES));
 
         // Schema registration
         AppSearchSchema personSchema =
                 new AppSearchSchema.Builder("Person")
                         .addProperty(
                                 new StringPropertyConfig.Builder("name")
-                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .build())
-                        .build();
-        AppSearchSchema artistSchema =
-                new AppSearchSchema.Builder("Artist")
-                        .addParentType("Person")
-                        .addProperty(
-                                new StringPropertyConfig.Builder("name")
-                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .build())
-                        .build();
-        mDb1.setSchemaAsync(
-                        new SetSchemaRequest.Builder()
-                                .addSchemas(personSchema)
-                                .addSchemas(artistSchema)
-                                .addSchemas(AppSearchEmail.SCHEMA)
-                                .build())
-                .get();
-
-        // Index some documents
-        GenericDocument personDoc =
-                new GenericDocument.Builder<>("namespace", "id1", "Person")
-                        .setPropertyString("name", "Foo")
-                        .build();
-        GenericDocument artistDoc =
-                new GenericDocument.Builder<>("namespace", "id2", "Artist")
-                        .setPropertyString("name", "Foo")
-                        .build();
-        AppSearchEmail emailDoc =
-                new AppSearchEmail.Builder("namespace", "id3")
-                        .setFrom("from@example.com")
-                        .setTo("to1@example.com", "to2@example.com")
-                        .setSubject("testPut example")
-                        .setBody("Foo")
-                        .build();
-        checkIsBatchResultSuccess(
-                mDb1.putAsync(
-                        new PutDocumentsRequest.Builder()
-                                .addGenericDocuments(personDoc, artistDoc, emailDoc)
-                                .build()));
-        GenericDocument artistDocWithParent =
-                new GenericDocument.Builder<>(artistDoc)
-                        .setParentTypes(Collections.singletonList("Person"))
-                        .build();
-
-        // Query for the documents
-        SearchResultsShim searchResults =
-                mDb1.search(
-                        "Foo",
-                        new SearchSpec.Builder()
-                                .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
-                                .build());
-        List<GenericDocument> documents = convertSearchResultsToDocuments(searchResults);
-        assertThat(documents).hasSize(3);
-        assertThat(documents).containsExactly(personDoc, artistDocWithParent, emailDoc);
-
-        // Query with a filter for the "Person" type should also include the "Artist" type.
-        searchResults =
-                mDb1.search(
-                        "Foo",
-                        new SearchSpec.Builder()
-                                .addFilterSchemas("Person")
-                                .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
-                                .build());
-        documents = convertSearchResultsToDocuments(searchResults);
-        assertThat(documents).hasSize(2);
-        assertThat(documents).containsExactly(personDoc, artistDocWithParent);
-
-        // Query with a filters for the "Artist" type should not include the "Person" type.
-        searchResults =
-                mDb1.search(
-                        "Foo",
-                        new SearchSpec.Builder()
-                                .addFilterSchemas("Artist")
-                                .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
-                                .build());
-        documents = convertSearchResultsToDocuments(searchResults);
-        assertThat(documents).hasSize(1);
-        assertThat(documents).containsExactly(artistDocWithParent);
-    }
-
-    @Test
-    public void testQuery_projectionWithPolymorphism() throws Exception {
-        assumeTrue(mDb1.getFeatures().isFeatureSupported(Features.SCHEMA_ADD_PARENT_TYPE));
-
-        // Schema registration
-        AppSearchSchema personSchema =
-                new AppSearchSchema.Builder("Person")
-                        .addProperty(
-                                new StringPropertyConfig.Builder("name")
-                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .build())
-                        .addProperty(
-                                new StringPropertyConfig.Builder("emailAddress")
-                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .build())
-                        .build();
-        AppSearchSchema artistSchema =
-                new AppSearchSchema.Builder("Artist")
-                        .addParentType("Person")
-                        .addProperty(
-                                new StringPropertyConfig.Builder("name")
-                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .build())
-                        .addProperty(
-                                new StringPropertyConfig.Builder("emailAddress")
-                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .build())
-                        .addProperty(
-                                new StringPropertyConfig.Builder("company")
-                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .build())
-                        .build();
-        mDb1.setSchemaAsync(
-                        new SetSchemaRequest.Builder()
-                                .addSchemas(personSchema)
-                                .addSchemas(artistSchema)
-                                .build())
-                .get();
-
-        // Index two documents
-        GenericDocument personDoc =
-                new GenericDocument.Builder<>("namespace", "id1", "Person")
-                        .setCreationTimestampMillis(1000)
-                        .setPropertyString("name", "Foo Person")
-                        .setPropertyString("emailAddress", "person@gmail.com")
-                        .build();
-        GenericDocument artistDoc =
-                new GenericDocument.Builder<>("namespace", "id2", "Artist")
-                        .setCreationTimestampMillis(1000)
-                        .setPropertyString("name", "Foo Artist")
-                        .setPropertyString("emailAddress", "artist@gmail.com")
-                        .setPropertyString("company", "Company")
-                        .build();
-        checkIsBatchResultSuccess(
-                mDb1.putAsync(
-                        new PutDocumentsRequest.Builder()
-                                .addGenericDocuments(personDoc, artistDoc)
-                                .build()));
-
-        // Query with type property paths {"Person", ["name"]}, {"Artist", ["emailAddress"]}
-        // This will be expanded to paths {"Person", ["name"]}, {"Artist", ["name", "emailAddress"]}
-        // via polymorphism.
-        SearchResultsShim searchResults =
-                mDb1.search(
-                        "Foo",
-                        new SearchSpec.Builder()
-                                .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
-                                .addProjection("Person", ImmutableList.of("name"))
-                                .addProjection("Artist", ImmutableList.of("emailAddress"))
-                                .build());
-        List<GenericDocument> documents = convertSearchResultsToDocuments(searchResults);
-
-        // The person document should have been returned with only the "name" property. The artist
-        // document should have been returned with all of its properties.
-        GenericDocument expectedPerson =
-                new GenericDocument.Builder<>("namespace", "id1", "Person")
-                        .setCreationTimestampMillis(1000)
-                        .setPropertyString("name", "Foo Person")
-                        .build();
-        GenericDocument expectedArtist =
-                new GenericDocument.Builder<>("namespace", "id2", "Artist")
-                        .setParentTypes(Collections.singletonList("Person"))
-                        .setCreationTimestampMillis(1000)
-                        .setPropertyString("name", "Foo Artist")
-                        .setPropertyString("emailAddress", "artist@gmail.com")
-                        .build();
-        assertThat(documents).containsExactly(expectedPerson, expectedArtist);
-    }
-
-    @Test
-    public void testQuery_projectionWithPolymorphismAndSchemaFilter() throws Exception {
-        assumeTrue(mDb1.getFeatures().isFeatureSupported(Features.SCHEMA_ADD_PARENT_TYPE));
-
-        // Schema registration
-        AppSearchSchema personSchema =
-                new AppSearchSchema.Builder("Person")
-                        .addProperty(
-                                new StringPropertyConfig.Builder("name")
-                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .build())
-                        .addProperty(
-                                new StringPropertyConfig.Builder("emailAddress")
-                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
                                         .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
                                         .setIndexingType(
                                                 StringPropertyConfig.INDEXING_TYPE_PREFIXES)
@@ -336,104 +131,22 @@ public abstract class AppSearchSessionInternalTestBase {
                         .addParentType("Person")
                         .addProperty(
                                 new StringPropertyConfig.Builder("name")
-                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .build())
-                        .addProperty(
-                                new StringPropertyConfig.Builder("emailAddress")
-                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
                                         .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
                                         .setIndexingType(
                                                 StringPropertyConfig.INDEXING_TYPE_PREFIXES)
                                         .build())
                         .addProperty(
                                 new StringPropertyConfig.Builder("company")
-                                        .setCardinality(PropertyConfig.CARDINALITY_OPTIONAL)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .build())
-                        .build();
-        mDb1.setSchemaAsync(
-                        new SetSchemaRequest.Builder()
-                                .addSchemas(personSchema)
-                                .addSchemas(artistSchema)
-                                .build())
-                .get();
-
-        // Index two documents
-        GenericDocument personDoc =
-                new GenericDocument.Builder<>("namespace", "id1", "Person")
-                        .setCreationTimestampMillis(1000)
-                        .setPropertyString("name", "Foo Person")
-                        .setPropertyString("emailAddress", "person@gmail.com")
-                        .build();
-        GenericDocument artistDoc =
-                new GenericDocument.Builder<>("namespace", "id2", "Artist")
-                        .setCreationTimestampMillis(1000)
-                        .setPropertyString("name", "Foo Artist")
-                        .setPropertyString("emailAddress", "artist@gmail.com")
-                        .setPropertyString("company", "Company")
-                        .build();
-        checkIsBatchResultSuccess(
-                mDb1.putAsync(
-                        new PutDocumentsRequest.Builder()
-                                .addGenericDocuments(personDoc, artistDoc)
-                                .build()));
-
-        // Query with type property paths {"Person", ["name"]} and {"Artist", ["emailAddress"]}, and
-        // a schema filter for the "Person".
-        // This will be expanded to paths {"Person", ["name"]} and
-        // {"Artist", ["name", "emailAddress"]}, and filters for both "Person" and "Artist" via
-        // polymorphism.
-        SearchResultsShim searchResults =
-                mDb1.search(
-                        "Foo",
-                        new SearchSpec.Builder()
-                                .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
-                                .addFilterSchemas("Person")
-                                .addProjection("Person", ImmutableList.of("name"))
-                                .addProjection("Artist", ImmutableList.of("emailAddress"))
-                                .build());
-        List<GenericDocument> documents = convertSearchResultsToDocuments(searchResults);
-
-        // The person document should have been returned with only the "name" property. The artist
-        // document should have been returned with all of its properties.
-        GenericDocument expectedPerson =
-                new GenericDocument.Builder<>("namespace", "id1", "Person")
-                        .setCreationTimestampMillis(1000)
-                        .setPropertyString("name", "Foo Person")
-                        .build();
-        GenericDocument expectedArtist =
-                new GenericDocument.Builder<>("namespace", "id2", "Artist")
-                        .setParentTypes(Collections.singletonList("Person"))
-                        .setCreationTimestampMillis(1000)
-                        .setPropertyString("name", "Foo Artist")
-                        .setPropertyString("emailAddress", "artist@gmail.com")
-                        .build();
-        assertThat(documents).containsExactly(expectedPerson, expectedArtist);
-    }
-
-    @Test
-    public void testQuery_indexBasedOnParentTypePolymorphism() throws Exception {
-        assumeTrue(mDb1.getFeatures().isFeatureSupported(Features.SCHEMA_ADD_PARENT_TYPE));
-
-        // Schema registration
-        AppSearchSchema personSchema =
-                new AppSearchSchema.Builder("Person")
-                        .addProperty(
-                                new StringPropertyConfig.Builder("name")
                                         .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
                                         .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
                                         .setIndexingType(
                                                 StringPropertyConfig.INDEXING_TYPE_PREFIXES)
                                         .build())
                         .build();
-        AppSearchSchema artistSchema =
-                new AppSearchSchema.Builder("Artist")
-                        .addParentType("Person")
+        AppSearchSchema musicianSchema =
+                new AppSearchSchema.Builder("Musician")
+                        .addParentType("Artist")
                         .addProperty(
                                 new StringPropertyConfig.Builder("name")
                                         .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
@@ -453,8 +166,8 @@ public abstract class AppSearchSessionInternalTestBase {
                 new AppSearchSchema.Builder("Message")
                         .addProperty(
                                 new AppSearchSchema.DocumentPropertyConfig.Builder(
-                                                "sender", "Person")
-                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
+                                                "receivers", "Person")
+                                        .setCardinality(PropertyConfig.CARDINALITY_REPEATED)
                                         .setShouldIndexNestedProperties(true)
                                         .build())
                         .build();
@@ -462,335 +175,67 @@ public abstract class AppSearchSessionInternalTestBase {
                         new SetSchemaRequest.Builder()
                                 .addSchemas(personSchema)
                                 .addSchemas(artistSchema)
+                                .addSchemas(musicianSchema)
                                 .addSchemas(messageSchema)
                                 .build())
                 .get();
 
-        // Index some an artistDoc and a messageDoc
-        GenericDocument artistDoc =
-                new GenericDocument.Builder<>("namespace", "id1", "Artist")
-                        .setPropertyString("name", "Foo")
-                        .setPropertyString("company", "Bar")
-                        .build();
-        GenericDocument messageDoc =
-                new GenericDocument.Builder<>("namespace", "id2", "Message")
-                        // sender is defined as a Person, which accepts an Artist because Artist <:
-                        // Person.
-                        // However, indexing will be based on what's defined in Person, so the
-                        // "company"
-                        // property in artistDoc cannot be used to search this messageDoc.
-                        .setPropertyDocument("sender", artistDoc)
-                        .build();
-        checkIsBatchResultSuccess(
-                mDb1.putAsync(
-                        new PutDocumentsRequest.Builder()
-                                .addGenericDocuments(artistDoc, messageDoc)
-                                .build()));
-        GenericDocument expectedArtistDoc =
-                new GenericDocument.Builder<>(artistDoc)
-                        .setParentTypes(Collections.singletonList("Person"))
-                        .build();
-        GenericDocument expectedMessageDoc =
-                new GenericDocument.Builder<>(messageDoc)
-                        .setPropertyDocument("sender", expectedArtistDoc)
-                        .build();
-
-        // Query for the documents
-        SearchResultsShim searchResults =
-                mDb1.search(
-                        "Foo",
-                        new SearchSpec.Builder()
-                                .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
-                                .build());
-        List<GenericDocument> documents = convertSearchResultsToDocuments(searchResults);
-        assertThat(documents).hasSize(2);
-        assertThat(documents).containsExactly(expectedArtistDoc, expectedMessageDoc);
-
-        // The "company" property in artistDoc cannot be used to search messageDoc.
-        searchResults =
-                mDb1.search(
-                        "Bar",
-                        new SearchSpec.Builder()
-                                .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
-                                .build());
-        documents = convertSearchResultsToDocuments(searchResults);
-        assertThat(documents).hasSize(1);
-        assertThat(documents).containsExactly(expectedArtistDoc);
-    }
-
-    @Test
-    public void testQuery_parentTypeListIsTopologicalOrder() throws Exception {
-        assumeTrue(mDb1.getFeatures().isFeatureSupported(Features.SCHEMA_ADD_PARENT_TYPE));
-        // Create the following subtype relation graph, where
-        // 1. A's direct parents are B and C.
-        // 2. B's direct parent is D.
-        // 3. C's direct parent is B and D.
-        // DFS order from A: [A, B, D, C]. Not acceptable because B and D appear before C.
-        // BFS order from A: [A, B, C, D]. Not acceptable because B appears before C.
-        // Topological order (all subtypes appear before supertypes) from A: [A, C, B, D].
-        AppSearchSchema schemaA =
-                new AppSearchSchema.Builder("A").addParentType("B").addParentType("C").build();
-        AppSearchSchema schemaB = new AppSearchSchema.Builder("B").addParentType("D").build();
-        AppSearchSchema schemaC =
-                new AppSearchSchema.Builder("C").addParentType("B").addParentType("D").build();
-        AppSearchSchema schemaD = new AppSearchSchema.Builder("D").build();
-        mDb1.setSchemaAsync(
-                        new SetSchemaRequest.Builder()
-                                .addSchemas(schemaA)
-                                .addSchemas(schemaB)
-                                .addSchemas(schemaC)
-                                .addSchemas(schemaD)
-                                .build())
-                .get();
-
-        // Index some documents
-        GenericDocument docA = new GenericDocument.Builder<>("namespace", "id1", "A").build();
-        GenericDocument docB = new GenericDocument.Builder<>("namespace", "id2", "B").build();
-        GenericDocument docC = new GenericDocument.Builder<>("namespace", "id3", "C").build();
-        GenericDocument docD = new GenericDocument.Builder<>("namespace", "id4", "D").build();
-        checkIsBatchResultSuccess(
-                mDb1.putAsync(
-                        new PutDocumentsRequest.Builder()
-                                .addGenericDocuments(docA, docB, docC, docD)
-                                .build()));
-
-        GenericDocument expectedDocA =
-                new GenericDocument.Builder<>(docA)
-                        .setParentTypes(new ArrayList<>(Arrays.asList("C", "B", "D")))
-                        .build();
-        GenericDocument expectedDocB =
-                new GenericDocument.Builder<>(docB)
-                        .setParentTypes(Collections.singletonList("D"))
-                        .build();
-        GenericDocument expectedDocC =
-                new GenericDocument.Builder<>(docC)
-                        .setParentTypes(new ArrayList<>(Arrays.asList("B", "D")))
-                        .build();
-        // Query for the documents
-        SearchResultsShim searchResults = mDb1.search("", new SearchSpec.Builder().build());
-        List<GenericDocument> documents = convertSearchResultsToDocuments(searchResults);
-        assertThat(documents).hasSize(4);
-        assertThat(documents).containsExactly(expectedDocA, expectedDocB, expectedDocC, docD);
-    }
-
-    // TODO(b/336277840): Move this if setParentTypes becomes public
-    @Test
-    public void testQuery_wildcardProjection_polymorphism() throws Exception {
-        assumeTrue(mDb1.getFeatures().isFeatureSupported(Features.SCHEMA_ADD_PARENT_TYPE));
-        AppSearchSchema messageSchema =
-                new AppSearchSchema.Builder("Message")
-                        .addProperty(
-                                new StringPropertyConfig.Builder("sender")
-                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .build())
-                        .addProperty(
-                                new StringPropertyConfig.Builder("content")
-                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .build())
-                        .build();
-        AppSearchSchema textSchema =
-                new AppSearchSchema.Builder("Text")
-                        .addParentType("Message")
-                        .addProperty(
-                                new StringPropertyConfig.Builder("sender")
-                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .build())
-                        .addProperty(
-                                new StringPropertyConfig.Builder("content")
-                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .build())
+        // Index documents
+        GenericDocument personDoc =
+                new GenericDocument.Builder<>("namespace", "id1", "Person")
+                        .setCreationTimestampMillis(1000)
+                        .setPropertyString("name", "person")
                         .build();
-        AppSearchSchema emailSchema =
-                new AppSearchSchema.Builder("Email")
-                        .addParentType("Message")
-                        .addProperty(
-                                new StringPropertyConfig.Builder("sender")
-                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .build())
-                        .addProperty(
-                                new StringPropertyConfig.Builder("content")
-                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .build())
+        GenericDocument artistDoc =
+                new GenericDocument.Builder<>("namespace", "id2", "Artist")
+                        .setCreationTimestampMillis(1000)
+                        .setPropertyString("name", "artist")
+                        .setPropertyString("company", "foo")
                         .build();
-
-        // Schema registration
-        mDb1.setSchemaAsync(
-                        new SetSchemaRequest.Builder()
-                                .addSchemas(messageSchema, textSchema, emailSchema)
-                                .build())
-                .get();
-
-        // Index two child documents
-        GenericDocument text =
-                new GenericDocument.Builder<>("namespace", "id1", "Text")
+        GenericDocument musicianDoc =
+                new GenericDocument.Builder<>("namespace", "id3", "Musician")
                         .setCreationTimestampMillis(1000)
-                        .setPropertyString("sender", "Some sender")
-                        .setPropertyString("content", "Some note")
+                        .setPropertyString("name", "musician")
+                        .setPropertyString("company", "foo")
                         .build();
-        GenericDocument email =
-                new GenericDocument.Builder<>("namespace", "id2", "Email")
+        GenericDocument messageDoc =
+                new GenericDocument.Builder<>("namespace", "id4", "Message")
                         .setCreationTimestampMillis(1000)
-                        .setPropertyString("sender", "Some sender")
-                        .setPropertyString("content", "Some note")
+                        .setPropertyDocument("receivers", artistDoc, musicianDoc)
                         .build();
         checkIsBatchResultSuccess(
                 mDb1.putAsync(
                         new PutDocumentsRequest.Builder()
-                                .addGenericDocuments(email, text)
+                                .addGenericDocuments(personDoc, artistDoc, musicianDoc, messageDoc)
                                 .build()));
-
-        SearchResultsShim searchResults =
-                mDb1.search(
-                        "Some",
-                        new SearchSpec.Builder()
-                                .addFilterSchemas("Message")
-                                .addProjection(
-                                        SearchSpec.SCHEMA_TYPE_WILDCARD, ImmutableList.of("sender"))
-                                .addFilterProperties(
-                                        SearchSpec.SCHEMA_TYPE_WILDCARD,
-                                        ImmutableList.of("content"))
-                                .build());
-        List<GenericDocument> documents = convertSearchResultsToDocuments(searchResults);
-
-        // We specified the parent document in the filter schemas, but only indexed child documents.
-        // As we also specified a wildcard schema type projection, it should apply to the child docs
-        // The content property must not appear. Also emailNoContent should not appear as we are
-        // filter on the content property
-        GenericDocument expectedText =
-                new GenericDocument.Builder<>("namespace", "id1", "Text")
-                        .setParentTypes(Collections.singletonList("Message"))
-                        .setCreationTimestampMillis(1000)
-                        .setPropertyString("sender", "Some sender")
-                        .build();
-        GenericDocument expectedEmail =
-                new GenericDocument.Builder<>("namespace", "id2", "Email")
-                        .setParentTypes(Collections.singletonList("Message"))
-                        .setCreationTimestampMillis(1000)
-                        .setPropertyString("sender", "Some sender")
-                        .build();
-        assertThat(documents).containsExactly(expectedText, expectedEmail);
-    }
-
-    // TODO(b/336277840): Move this if setParentTypes becomes public
-    @Test
-    public void testQuery_wildcardFilterSchema_polymorphism() throws Exception {
-        assumeTrue(mDb1.getFeatures().isFeatureSupported(Features.SCHEMA_ADD_PARENT_TYPE));
-        AppSearchSchema messageSchema =
-                new AppSearchSchema.Builder("Message")
-                        .addProperty(
-                                new StringPropertyConfig.Builder("content")
-                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .build())
-                        .build();
-        AppSearchSchema textSchema =
-                new AppSearchSchema.Builder("Text")
-                        .addParentType("Message")
-                        .addProperty(
-                                new StringPropertyConfig.Builder("content")
-                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .build())
-                        .addProperty(
-                                new StringPropertyConfig.Builder("carrier")
-                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .build())
-                        .build();
-        AppSearchSchema emailSchema =
-                new AppSearchSchema.Builder("Email")
-                        .addParentType("Message")
-                        .addProperty(
-                                new StringPropertyConfig.Builder("content")
-                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .build())
-                        .addProperty(
-                                new StringPropertyConfig.Builder("attachment")
-                                        .setCardinality(PropertyConfig.CARDINALITY_REQUIRED)
-                                        .setIndexingType(
-                                                StringPropertyConfig.INDEXING_TYPE_PREFIXES)
-                                        .setTokenizerType(StringPropertyConfig.TOKENIZER_TYPE_PLAIN)
-                                        .build())
+        GenericDocument artistDocWithParent =
+                new GenericDocument.Builder<>(artistDoc)
+                        .setParentTypes(Collections.singletonList("Person"))
                         .build();
-
-        // Schema registration
-        mDb1.setSchemaAsync(
-                        new SetSchemaRequest.Builder()
-                                .addSchemas(messageSchema, textSchema, emailSchema)
-                                .build())
-                .get();
-
-        // Index two child documents
-        GenericDocument text =
-                new GenericDocument.Builder<>("namespace", "id1", "Text")
-                        .setCreationTimestampMillis(1000)
-                        .setPropertyString("content", "Some note")
-                        .setPropertyString("carrier", "Network Inc")
+        GenericDocument musicianDocWithParent =
+                new GenericDocument.Builder<>(musicianDoc)
+                        .setParentTypes(ImmutableList.of("Artist", "Person"))
                         .build();
-        GenericDocument email =
-                new GenericDocument.Builder<>("namespace", "id2", "Email")
+        GenericDocument messageDocWithParent =
+                new GenericDocument.Builder<>("namespace", "id4", "Message")
                         .setCreationTimestampMillis(1000)
-                        .setPropertyString("content", "Some note")
-                        .setPropertyString("attachment", "Network report")
+                        .setPropertyDocument(
+                                "receivers", artistDocWithParent, musicianDocWithParent)
                         .build();
 
-        checkIsBatchResultSuccess(
-                mDb1.putAsync(
-                        new PutDocumentsRequest.Builder()
-                                .addGenericDocuments(email, text)
-                                .build()));
-
-        // Both email and text would match for "Network", but only text should match as it is in the
-        // right property
+        // Query to get all the documents
         SearchResultsShim searchResults =
                 mDb1.search(
-                        "Network",
+                        "",
                         new SearchSpec.Builder()
-                                .addFilterSchemas("Message")
-                                .addFilterProperties(
-                                        SearchSpec.SCHEMA_TYPE_WILDCARD,
-                                        ImmutableList.of("carrier"))
+                                .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
                                 .build());
         List<GenericDocument> documents = convertSearchResultsToDocuments(searchResults);
-
-        // We specified the parent document in the filter schemas, but only indexed child documents.
-        // As we also specified a wildcard schema type projection, it should apply to the child docs
-        // The content property must not appear. Also emailNoContent should not appear as we are
-        // filter on the content property
-        GenericDocument expectedText =
-                new GenericDocument.Builder<>("namespace", "id1", "Text")
-                        .setParentTypes(Collections.singletonList("Message"))
-                        .setCreationTimestampMillis(1000)
-                        .setPropertyString("content", "Some note")
-                        .setPropertyString("carrier", "Network Inc")
-                        .build();
-        assertThat(documents).containsExactly(expectedText);
+        assertThat(documents)
+                .containsExactly(
+                        personDoc,
+                        artistDocWithParent,
+                        musicianDocWithParent,
+                        messageDocWithParent);
     }
 }
diff --git a/testing/coretests/src/android/app/appsearch/external/app/GenericDocumentInternalTest.java b/testing/coretests/src/android/app/appsearch/external/app/GenericDocumentInternalTest.java
index a5c49d75..9e45a49e 100644
--- a/testing/coretests/src/android/app/appsearch/external/app/GenericDocumentInternalTest.java
+++ b/testing/coretests/src/android/app/appsearch/external/app/GenericDocumentInternalTest.java
@@ -70,6 +70,7 @@ public class GenericDocumentInternalTest {
     }
 
     @Test
+    @SuppressWarnings("deprecation")
     public void testRecreateFromParcelWithParentTypes() {
         GenericDocument inDoc =
                 new GenericDocument.Builder<>("namespace", "id1", "schema1")
@@ -113,6 +114,7 @@ public class GenericDocumentInternalTest {
     }
 
     @Test
+    @SuppressWarnings("deprecation")
     public void testGenericDocumentBuilderDoesNotMutateOriginal() {
         GenericDocument oldDoc =
                 new GenericDocument.Builder<>("namespace", "id1", "schema1")
diff --git a/testing/coretests/src/android/app/appsearch/external/app/SearchResultInternalTest.java b/testing/coretests/src/android/app/appsearch/external/app/SearchResultInternalTest.java
index 75fdedd4..bf3239a2 100644
--- a/testing/coretests/src/android/app/appsearch/external/app/SearchResultInternalTest.java
+++ b/testing/coretests/src/android/app/appsearch/external/app/SearchResultInternalTest.java
@@ -20,6 +20,9 @@ import static com.google.common.truth.Truth.assertThat;
 
 import org.junit.Test;
 
+import java.util.List;
+import java.util.Map;
+
 public class SearchResultInternalTest {
     @Test
     public void testSearchResultBuilderCopyConstructor() {
@@ -80,6 +83,23 @@ public class SearchResultInternalTest {
                 .isEqualTo(searchResult.getInformationalRankingSignals());
     }
 
+    @Test
+    public void testSearchResultBuilderCopyConstructor_parentType() {
+        GenericDocument document =
+                new GenericDocument.Builder<>("namespace", "id", "schemaType1").build();
+        SearchResult searchResult =
+                new SearchResult.Builder("package", "database")
+                        .setGenericDocument(document)
+                        .setParentTypeMap(
+                                Map.of(
+                                        "schemaType1", List.of("parent1", "parent2"),
+                                        "schemaType2", List.of("parent3", "parent4")))
+                        .build();
+        SearchResult searchResultCopy = new SearchResult.Builder(searchResult).build();
+        assertThat(searchResultCopy.getParentTypeMap())
+                .containsExactlyEntriesIn(searchResult.getParentTypeMap());
+    }
+
     @Test
     public void testSearchResultBuilder_clearJoinedResults() {
         GenericDocument document =
diff --git a/testing/coretests/src/android/app/appsearch/external/app/SearchSpecInternalTest.java b/testing/coretests/src/android/app/appsearch/external/app/SearchSpecInternalTest.java
index 380dff8d..4487057f 100644
--- a/testing/coretests/src/android/app/appsearch/external/app/SearchSpecInternalTest.java
+++ b/testing/coretests/src/android/app/appsearch/external/app/SearchSpecInternalTest.java
@@ -18,6 +18,10 @@ package android.app.appsearch;
 
 import static com.google.common.truth.Truth.assertThat;
 
+import android.platform.test.annotations.RequiresFlagsEnabled;
+
+import com.android.appsearch.flags.Flags;
+
 import com.google.common.collect.ImmutableMap;
 
 import org.junit.Test;
@@ -44,6 +48,7 @@ public class SearchSpecInternalTest {
                         .setNumericSearchEnabled(true)
                         .setVerbatimSearchEnabled(true)
                         .setListFilterQueryLanguageEnabled(true)
+                        .setScorablePropertyRankingEnabled(true)
                         .build();
 
         assertThat(searchSpec.getTermMatch()).isEqualTo(SearchSpec.TERM_MATCH_PREFIX);
@@ -59,9 +64,10 @@ public class SearchSpecInternalTest {
                 .isEqualTo(SearchSpec.RANKING_STRATEGY_DOCUMENT_SCORE);
         assertThat(searchSpec.getEnabledFeatures())
                 .containsExactly(
-                        Features.NUMERIC_SEARCH,
-                        Features.VERBATIM_SEARCH,
-                        Features.LIST_FILTER_QUERY_LANGUAGE);
+                        Features.NUMERIC_SEARCH, Features.VERBATIM_SEARCH,
+                        Features.LIST_FILTER_QUERY_LANGUAGE,
+                                Features.SCHEMA_SCORABLE_PROPERTY_CONFIG);
+        assertThat(searchSpec.isScorablePropertyRankingEnabled()).isTrue();
     }
 
     @Test
@@ -87,6 +93,7 @@ public class SearchSpecInternalTest {
                         .setListFilterQueryLanguageEnabled(true)
                         .setResultGrouping(SearchSpec.GROUPING_TYPE_PER_PACKAGE, 10)
                         .setSearchSourceLogTag("searchSourceLogTag")
+                        .setScorablePropertyRankingEnabled(true)
                         .build();
 
         SearchSpec searchSpecCopy = new SearchSpec.Builder(searchSpec).build();
@@ -119,6 +126,7 @@ public class SearchSpecInternalTest {
                 .isEqualTo(searchSpec.getAdvancedRankingExpression());
         assertThat(searchSpecCopy.getSearchSourceLogTag())
                 .isEqualTo(searchSpec.getSearchSourceLogTag());
+        assertThat(searchSpecCopy.isScorablePropertyRankingEnabled()).isTrue();
     }
 
     @Test
@@ -179,6 +187,27 @@ public class SearchSpecInternalTest {
                                 Features.LIST_FILTER_HAS_PROPERTY_FUNCTION);
     }
 
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_LIST_FILTER_MATCH_SCORE_EXPRESSION_FUNCTION)
+    public void testGetBundle_matchScoreExpression() {
+        SearchSpec searchSpec =
+                new SearchSpec.Builder()
+                        .setNumericSearchEnabled(true)
+                        .setVerbatimSearchEnabled(true)
+                        .setListFilterQueryLanguageEnabled(true)
+                        .setListFilterHasPropertyFunctionEnabled(true)
+                        .setListFilterMatchScoreExpressionFunctionEnabled(true)
+                        .build();
+
+        assertThat(searchSpec.getEnabledFeatures())
+                .containsExactly(
+                        Features.NUMERIC_SEARCH,
+                        Features.VERBATIM_SEARCH,
+                        Features.LIST_FILTER_QUERY_LANGUAGE,
+                        Features.LIST_FILTER_HAS_PROPERTY_FUNCTION,
+                        Features.LIST_FILTER_MATCH_SCORE_EXPRESSION_FUNCTION);
+    }
+
     @Test
     public void testBuildMultipleSearchSpecs() {
         SearchSpec.Builder builder = new SearchSpec.Builder();
diff --git a/testing/coretests/src/android/app/appsearch/external/app/aidl/AppSearchBatchResultParcelV2Test.java b/testing/coretests/src/android/app/appsearch/external/app/aidl/AppSearchBatchResultParcelV2Test.java
new file mode 100644
index 00000000..1c554549
--- /dev/null
+++ b/testing/coretests/src/android/app/appsearch/external/app/aidl/AppSearchBatchResultParcelV2Test.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch.aidl;
+
+import static android.app.appsearch.testutil.AppSearchTestUtils.calculateDigest;
+import static android.app.appsearch.testutil.AppSearchTestUtils.generateRandomBytes;
+import static android.os.ParcelFileDescriptor.MODE_WRITE_ONLY;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.app.appsearch.AppSearchBatchResult;
+import android.app.appsearch.AppSearchBlobHandle;
+import android.app.appsearch.AppSearchResult;
+import android.os.ParcelFileDescriptor;
+
+import org.junit.Test;
+
+import java.io.File;
+
+public class AppSearchBatchResultParcelV2Test {
+
+    @Test
+    public void testFromBlobHandleToPfd() throws Exception {
+        File file = File.createTempFile(/* prefix= */ "appsearch", /* suffix= */ null);
+        ParcelFileDescriptor pfd = ParcelFileDescriptor.open(file, MODE_WRITE_ONLY);
+        AppSearchResult<ParcelFileDescriptor> successResult =
+                AppSearchResult.newSuccessfulResult(pfd);
+        AppSearchResult<ParcelFileDescriptor> failureResult =
+                AppSearchResult.newFailedResult(AppSearchResult.RESULT_NOT_FOUND, "not found");
+        byte[] data1 = generateRandomBytes(10); // 10 Bytes
+        byte[] digest1 = calculateDigest(data1);
+        byte[] data2 = generateRandomBytes(10); // 10 Bytes
+        byte[] digest2 = calculateDigest(data2);
+        AppSearchBlobHandle blobHandle1 =
+                AppSearchBlobHandle.createWithSha256(digest1, "package1", "db1", "ns");
+        AppSearchBlobHandle blobHandle2 =
+                AppSearchBlobHandle.createWithSha256(digest2, "package1", "db1", "ns");
+        AppSearchBatchResult<AppSearchBlobHandle, ParcelFileDescriptor> result =
+                new AppSearchBatchResult.Builder<AppSearchBlobHandle, ParcelFileDescriptor>()
+                        .setResult(blobHandle1, successResult)
+                        .setResult(blobHandle2, failureResult)
+                        .build();
+        AppSearchBatchResultParcelV2<AppSearchBlobHandle, ParcelFileDescriptor> resultParcel =
+                AppSearchBatchResultParcelV2.fromBlobHandleToPfd(result);
+
+        AppSearchBatchResult<AppSearchBlobHandle, ParcelFileDescriptor> outResult =
+                resultParcel.getResult();
+
+        assertThat(outResult.getSuccesses()).containsExactly(blobHandle1, pfd);
+        assertThat(outResult.getFailures()).containsExactly(blobHandle2, failureResult);
+    }
+
+    @Test
+    public void testFromBlobHandleToVoid() throws Exception {
+        byte[] data1 = generateRandomBytes(10); // 10 Bytes
+        byte[] digest1 = calculateDigest(data1);
+        byte[] data2 = generateRandomBytes(10); // 10 Bytes
+        byte[] digest2 = calculateDigest(data2);
+        AppSearchBlobHandle blobHandle1 =
+                AppSearchBlobHandle.createWithSha256(digest1, "package1", "db1", "ns");
+        AppSearchBlobHandle blobHandle2 =
+                AppSearchBlobHandle.createWithSha256(digest2, "package1", "db1", "ns");
+        AppSearchResult<Void> successResult = AppSearchResult.newSuccessfulResult(null);
+        AppSearchResult<Void> failureResult =
+                AppSearchResult.newFailedResult(AppSearchResult.RESULT_NOT_FOUND, "not found");
+        AppSearchBatchResult<AppSearchBlobHandle, Void> result =
+                new AppSearchBatchResult.Builder<AppSearchBlobHandle, Void>()
+                        .setResult(blobHandle1, successResult)
+                        .setResult(blobHandle2, failureResult)
+                        .build();
+        AppSearchBatchResultParcelV2<AppSearchBlobHandle, Void> resultParcel =
+                AppSearchBatchResultParcelV2.fromBlobHandleToVoid(result);
+
+        AppSearchBatchResult<AppSearchBlobHandle, Void> outResult = resultParcel.getResult();
+
+        assertThat(outResult.getSuccesses()).containsExactly(blobHandle1, null);
+        assertThat(outResult.getFailures()).containsExactly(blobHandle2, failureResult);
+    }
+}
diff --git a/testing/coretests/src/android/app/appsearch/external/flags/FlagsTest.java b/testing/coretests/src/android/app/appsearch/external/flags/FlagsTest.java
index 4be2b278..b0853349 100644
--- a/testing/coretests/src/android/app/appsearch/external/flags/FlagsTest.java
+++ b/testing/coretests/src/android/app/appsearch/external/flags/FlagsTest.java
@@ -18,8 +18,6 @@ package android.app.appsearch.flags;
 
 import static com.google.common.truth.Truth.assertThat;
 
-import com.android.appsearch.flags.Flags;
-
 import org.junit.Test;
 
 public class FlagsTest {
@@ -35,6 +33,14 @@ public class FlagsTest {
                 .isEqualTo("com.android.appsearch.flags.enable_list_filter_has_property_function");
     }
 
+    @Test
+    public void testFlagValue_enableListFilterMatchScoreExpressionFunction() {
+        assertThat(Flags.FLAG_ENABLE_LIST_FILTER_MATCH_SCORE_EXPRESSION_FUNCTION)
+                .isEqualTo(
+                        "com.android.appsearch"
+                                + ".flags.enable_list_filter_match_score_expression_function");
+    }
+
     @Test
     public void testFlagValue_enableGroupingTypePerSchema() {
         assertThat(Flags.FLAG_ENABLE_GROUPING_TYPE_PER_SCHEMA)
@@ -115,6 +121,12 @@ public class FlagsTest {
                 .isEqualTo("com.android.appsearch.flags.enable_schema_embedding_property_config");
     }
 
+    @Test
+    public void testFlagValue_enableSchemaEmbeddingQuantization() {
+        assertThat(Flags.FLAG_ENABLE_SCHEMA_EMBEDDING_QUANTIZATION)
+                .isEqualTo("com.android.appsearch.flags.enable_schema_embedding_quantization");
+    }
+
     @Test
     public void testFlagValue_enableSearchSpecSearchStringParameters() {
         assertThat(Flags.FLAG_ENABLE_SEARCH_SPEC_SEARCH_STRING_PARAMETERS)
@@ -145,4 +157,35 @@ public class FlagsTest {
         assertThat(Flags.FLAG_ENABLE_ENTERPRISE_EMPTY_BATCH_RESULT_FIX)
                 .isEqualTo("com.android.appsearch.flags.enable_enterprise_empty_batch_result_fix");
     }
+
+    @Test
+    public void testFlagValue_enableAbstractSyntaxTree() {
+        assertThat(Flags.FLAG_ENABLE_ABSTRACT_SYNTAX_TREES)
+                .isEqualTo("com.android.appsearch.flags" + ".enable_abstract_syntax_trees");
+    }
+
+    @Test
+    public void testFlagValue_enableAdditionalBuilderCopyConstructors() {
+        assertThat(Flags.FLAG_ENABLE_ADDITIONAL_BUILDER_COPY_CONSTRUCTORS)
+                .isEqualTo(
+                        "com.android.appsearch.flags.enable_additional_builder_copy_constructors");
+    }
+
+    @Test
+    public void testFlagValue_enableSearchSpecFilterDocumentIds() {
+        assertThat(Flags.FLAG_ENABLE_SEARCH_SPEC_FILTER_DOCUMENT_IDS)
+                .isEqualTo("com.android.appsearch.flags.enable_search_spec_filter_document_ids");
+    }
+
+    @Test
+    public void testFlagValue_enableScorableSchemaProperty() {
+        assertThat(Flags.FLAG_ENABLE_SCORABLE_PROPERTY)
+                .isEqualTo("com.android.appsearch.flags.enable_scorable_property");
+    }
+
+    @Test
+    public void testFlagValue_enableSearchResultParentTypes() {
+        assertThat(Flags.FLAG_ENABLE_SEARCH_RESULT_PARENT_TYPES)
+                .isEqualTo("com.android.appsearch.flags.enable_search_result_parent_types");
+    }
 }
diff --git a/testing/coretests/src/android/app/appsearch/external/safeparcel/GenericDocumentParcelTest.java b/testing/coretests/src/android/app/appsearch/external/safeparcel/GenericDocumentParcelTest.java
index a1ee7123..e15d7bba 100644
--- a/testing/coretests/src/android/app/appsearch/external/safeparcel/GenericDocumentParcelTest.java
+++ b/testing/coretests/src/android/app/appsearch/external/safeparcel/GenericDocumentParcelTest.java
@@ -16,14 +16,24 @@
 
 package android.app.appsearch.safeparcel;
 
+import static android.app.appsearch.testutil.AppSearchTestUtils.calculateDigest;
+import static android.app.appsearch.testutil.AppSearchTestUtils.generateRandomBytes;
+
 import static com.google.common.truth.Truth.assertThat;
 
 import static org.junit.Assert.assertThrows;
 
+import android.app.appsearch.AppSearchBlobHandle;
 import android.app.appsearch.EmbeddingVector;
+import android.app.appsearch.testutil.AppSearchTestUtils;
 import android.os.Parcel;
+import android.platform.test.annotations.RequiresFlagsEnabled;
+
+import com.android.appsearch.flags.Flags;
 
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.RuleChain;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -32,6 +42,9 @@ import java.util.Map;
 
 /** Tests for {@link android.app.appsearch.GenericDocument} related SafeParcels. */
 public class GenericDocumentParcelTest {
+
+    @Rule public final RuleChain mRuleChain = AppSearchTestUtils.createCommonTestRules();
+
     @Test
     public void testPropertyParcel_onePropertySet_success() {
         String[] stringValues = {"a", "b"};
@@ -88,6 +101,24 @@ public class GenericDocumentParcelTest {
                 .isEqualTo(Arrays.copyOf(docValues, docValues.length));
     }
 
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testPropertyParcel_blobHandleSet_success() throws Exception {
+        byte[] data1 = generateRandomBytes(10); // 10 Bytes
+        byte[] digest1 = calculateDigest(data1);
+        byte[] data2 = generateRandomBytes(10); // 10 Bytes
+        byte[] digest2 = calculateDigest(data2);
+        AppSearchBlobHandle blob1 =
+                AppSearchBlobHandle.createWithSha256(digest1, "package1", "db1", "ns");
+        AppSearchBlobHandle blob2 =
+                AppSearchBlobHandle.createWithSha256(digest2, "package1", "db1", "ns");
+        AppSearchBlobHandle[] blobHandles = {blob1, blob2};
+
+        PropertyParcel parcel =
+                new PropertyParcel.Builder("name").setBlobHandleValues(blobHandles).build();
+        assertThat(parcel.getBlobHandleValues()).asList().containsExactly(blob1, blob2).inOrder();
+    }
+
     @Test
     public void testPropertyParcel_moreThanOnePropertySet_exceptionThrown() {
         String[] stringValues = {"a", "b"};
diff --git a/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchManagerServiceTest.java b/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchManagerServiceTest.java
index 9cdfe05b..1f8f4cb6 100644
--- a/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchManagerServiceTest.java
+++ b/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchManagerServiceTest.java
@@ -35,7 +35,6 @@ import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.anyString;
-import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.clearInvocations;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.mock;
@@ -69,15 +68,14 @@ import android.app.appsearch.SearchSuggestionSpec;
 import android.app.appsearch.aidl.AppSearchAttributionSource;
 import android.app.appsearch.aidl.AppSearchBatchResultParcel;
 import android.app.appsearch.aidl.AppSearchResultParcel;
+import android.app.appsearch.aidl.AppSearchResultParcelV2;
 import android.app.appsearch.aidl.DocumentsParcel;
-import android.app.appsearch.aidl.ExecuteAppFunctionAidlRequest;
 import android.app.appsearch.aidl.GetDocumentsAidlRequest;
 import android.app.appsearch.aidl.GetNamespacesAidlRequest;
 import android.app.appsearch.aidl.GetNextPageAidlRequest;
 import android.app.appsearch.aidl.GetSchemaAidlRequest;
 import android.app.appsearch.aidl.GetStorageInfoAidlRequest;
 import android.app.appsearch.aidl.GlobalSearchAidlRequest;
-import android.app.appsearch.aidl.IAppFunctionService;
 import android.app.appsearch.aidl.IAppSearchBatchResultCallback;
 import android.app.appsearch.aidl.IAppSearchManager;
 import android.app.appsearch.aidl.IAppSearchObserverProxy;
@@ -96,9 +94,6 @@ import android.app.appsearch.aidl.SearchSuggestionAidlRequest;
 import android.app.appsearch.aidl.SetSchemaAidlRequest;
 import android.app.appsearch.aidl.UnregisterObserverCallbackAidlRequest;
 import android.app.appsearch.aidl.WriteSearchResultsToFileAidlRequest;
-import android.app.appsearch.functions.ExecuteAppFunctionRequest;
-import android.app.appsearch.functions.ExecuteAppFunctionResponse;
-import android.app.appsearch.functions.ServiceCallHelper;
 import android.app.appsearch.observer.ObserverSpec;
 import android.app.appsearch.safeparcel.GenericDocumentParcel;
 import android.app.appsearch.stats.SchemaMigrationStats;
@@ -110,8 +105,6 @@ import android.content.ContextWrapper;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.pm.PackageManager;
-import android.content.pm.ResolveInfo;
-import android.content.pm.ServiceInfo;
 import android.os.Handler;
 import android.os.ParcelFileDescriptor;
 import android.os.RemoteException;
@@ -144,10 +137,10 @@ import com.android.server.appsearch.external.localstorage.usagereporting.ClickAc
 import com.android.server.appsearch.external.localstorage.usagereporting.SearchActionGenericDocument;
 import com.android.server.usage.StorageStatsManagerLocal;
 
-import com.google.common.util.concurrent.SettableFuture;
-
 import libcore.io.IoBridge;
 
+import com.google.common.util.concurrent.SettableFuture;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -160,9 +153,7 @@ import java.io.FileDescriptor;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
-import java.util.Objects;
 import java.util.concurrent.ExecutionException;
-import java.util.function.Consumer;
 
 public class AppSearchManagerServiceTest {
     private static final String DATABASE_NAME = "databaseName";
@@ -195,7 +186,6 @@ public class AppSearchManagerServiceTest {
     private IAppSearchManager.Stub mAppSearchManagerServiceStub;
     private AppSearchUserInstance mUserInstance;
     private InternalAppSearchLogger mLogger;
-    private TestableServiceCallHelper mServiceCallHelper;
 
     private int mCallingPid;
 
@@ -259,8 +249,6 @@ public class AppSearchManagerServiceTest {
                     }
                 });
 
-        setUpEnvironmentForAppFunction();
-        mServiceCallHelper = new TestableServiceCallHelper();
 
         // In AppSearchManagerService, ServiceAppSearchConfig is a singleton. During tearDown for
         // TestableDeviceConfig, the propertyChangedListeners are removed. Therefore we have to set
@@ -279,8 +267,8 @@ public class AppSearchManagerServiceTest {
         mUserInstance.setLoggerForTest(mLogger);
 
         // Start the service
-        mAppSearchManagerService = new AppSearchManagerService(mContext,
-                new AppSearchModule.Lifecycle(mContext), mServiceCallHelper);
+        mAppSearchManagerService =
+                new AppSearchManagerService(mContext, new AppSearchModule.Lifecycle(mContext));
         mAppSearchManagerService.onStart();
         mAppSearchManagerServiceStub = mMockServiceManager.mStubCaptor.getValue();
         assertThat(mAppSearchManagerServiceStub).isNotNull();
@@ -924,7 +912,7 @@ public class AppSearchManagerServiceTest {
                         + "localSearchSuggestion,globalReportUsage,localReportUsage,"
                         + "localRemoveByDocumentId,localRemoveBySearch,localGetStorageInfo,flush,"
                         + "globalRegisterObserverCallback,globalUnregisterObserverCallback,"
-                        + "initialize,executeAppFunction";
+                        + "initialize";
         DeviceConfig.setProperty(DeviceConfig.NAMESPACE_APPSEARCH,
                 KEY_DENYLIST, denylistString, false);
         // We expect all local calls (pkg+db) and global calls (pkg only) to be denied since the
@@ -943,7 +931,7 @@ public class AppSearchManagerServiceTest {
                         + "localSearchSuggestion,globalReportUsage,localReportUsage,"
                         + "localRemoveByDocumentId,localRemoveBySearch,localGetStorageInfo,flush,"
                         + "globalRegisterObserverCallback,globalUnregisterObserverCallback,"
-                        + "initialize,executeAppFunction";
+                        + "initialize";
         DeviceConfig.setProperty(DeviceConfig.NAMESPACE_APPSEARCH,
                 KEY_DENYLIST, denylistString, false);
         // We expect none of the local calls (pkg+db) and global calls (pkg only) to be denied since
@@ -963,7 +951,7 @@ public class AppSearchManagerServiceTest {
                         + "localSearchSuggestion,globalReportUsage,localReportUsage,"
                         + "localRemoveByDocumentId,localRemoveBySearch,localGetStorageInfo,flush,"
                         + "globalRegisterObserverCallback,globalUnregisterObserverCallback,"
-                        + "initialize,executeAppFunction";
+                        + "initialize";
         DeviceConfig.setProperty(DeviceConfig.NAMESPACE_APPSEARCH,
                 KEY_DENYLIST, denylistString, false);
         // We expect only the local calls (pkg+db) to be denied since the denylist specifies a
@@ -993,7 +981,7 @@ public class AppSearchManagerServiceTest {
                         + "localSearchSuggestion,globalReportUsage,localReportUsage,"
                         + "localRemoveByDocumentId,localRemoveBySearch,localGetStorageInfo,flush,"
                         + "globalRegisterObserverCallback,globalUnregisterObserverCallback,"
-                        + "initialize,executeAppFunction";
+                        + "initialize";
         DeviceConfig.setProperty(DeviceConfig.NAMESPACE_APPSEARCH,
                 KEY_DENYLIST, denylistString, false);
         verifyLocalCallsResults(AppSearchResult.RESULT_OK);
@@ -1010,7 +998,7 @@ public class AppSearchManagerServiceTest {
                         + "localPutDocumentsFromFile,localSearchSuggestion,globalReportUsage,"
                         + "localReportUsage,localRemoveByDocumentId,localRemoveBySearch,"
                         + "localGetStorageInfo,flush,globalRegisterObserverCallback,"
-                        + "globalUnregisterObserverCallback,initialize,executeAppFunction";
+                        + "globalUnregisterObserverCallback,initialize";
         DeviceConfig.setProperty(DeviceConfig.NAMESPACE_APPSEARCH,
                 KEY_DENYLIST, denylistString, false);
 
@@ -1061,7 +1049,7 @@ public class AppSearchManagerServiceTest {
                         + "localSearchSuggestion,globalReportUsage,localReportUsage,"
                         + "localRemoveByDocumentId,localRemoveBySearch,localGetStorageInfo,flush,"
                         + "globalRegisterObserverCallback,globalUnregisterObserverCallback,"
-                        + "initialize,executeAppFunction";
+                        + "initialize";
         DeviceConfig.setProperty(DeviceConfig.NAMESPACE_APPSEARCH,
                 KEY_DENYLIST, denylistString, false);
         verifyLocalCallsResults(AppSearchResult.RESULT_OK);
@@ -1101,7 +1089,6 @@ public class AppSearchManagerServiceTest {
         verifyRegisterObserverCallbackResult(AppSearchResult.RESULT_OK);
         verifyUnregisterObserverCallbackResult(AppSearchResult.RESULT_OK);
         verifyInitializeResult(AppSearchResult.RESULT_OK);
-        verifyExecuteAppFunctionCallbackResult(AppSearchResult.RESULT_OK);
     }
 
     @Test
@@ -1114,7 +1101,8 @@ public class AppSearchManagerServiceTest {
                 KEY_RATE_LIMIT_TASK_QUEUE_PER_PACKAGE_CAPACITY_PERCENTAGE,
                 Float.toString(0.8f),
                 false);
-        DeviceConfig.setProperty(DeviceConfig.NAMESPACE_APPSEARCH,
+        DeviceConfig.setProperty(
+                DeviceConfig.NAMESPACE_APPSEARCH,
                 KEY_RATE_LIMIT_API_COSTS,
                 "localSetSchema:5;globalGetSchema:5;localGetSchema:5;localGetNamespaces:5;"
                         + "localPutDocuments:5;globalGetDocuments:5;localGetDocuments:5;"
@@ -1122,8 +1110,7 @@ public class AppSearchManagerServiceTest {
                         + "invalidateNextPageToken:5;localWriteSearchResultsToFile:5;"
                         + "localPutDocumentsFromFile:5;localSearchSuggestion:5;"
                         + "globalReportUsage:5;localReportUsage:5;localRemoveByDocumentId:5;"
-                        + "localRemoveBySearch:5;localGetStorageInfo:5;flush:5;"
-                        + "executeAppFunction:5",
+                        + "localRemoveBySearch:5;localGetStorageInfo:5;flush:5;",
                 false);
 
         verifySetSchemaResult(RESULT_RATE_LIMITED);
@@ -1138,7 +1125,6 @@ public class AppSearchManagerServiceTest {
         verifyInvalidateNextPageTokenResult(RESULT_RATE_LIMITED);
         verifyGlobalReportUsageResult(RESULT_RATE_LIMITED);
         verifyPersistToDiskResult(RESULT_RATE_LIMITED);
-        verifyExecuteAppFunctionCallbackResult(RESULT_RATE_LIMITED);
 
         // initialize, registerObserver and unregisterObserver do not have rate limit.
     }
@@ -1198,7 +1184,6 @@ public class AppSearchManagerServiceTest {
         verifyRegisterObserverCallbackResult(AppSearchResult.RESULT_OK);
         verifyUnregisterObserverCallbackResult(AppSearchResult.RESULT_OK);
         verifyInitializeResult(AppSearchResult.RESULT_OK);
-        verifyExecuteAppFunctionCallbackResult(AppSearchResult.RESULT_OK);
     }
 
     @Test
@@ -1249,7 +1234,6 @@ public class AppSearchManagerServiceTest {
         verifyRegisterObserverCallbackResult(AppSearchResult.RESULT_OK);
         verifyUnregisterObserverCallbackResult(AppSearchResult.RESULT_OK);
         verifyInitializeResult(AppSearchResult.RESULT_OK);
-        verifyExecuteAppFunctionCallbackResult(AppSearchResult.RESULT_OK);
 
         // All calls should be fine after switching rate limiting to off
         DeviceConfig.setProperty(DeviceConfig.NAMESPACE_APPSEARCH,
@@ -1293,7 +1277,6 @@ public class AppSearchManagerServiceTest {
         verifyRegisterObserverCallbackResult(AppSearchResult.RESULT_OK);
         verifyUnregisterObserverCallbackResult(AppSearchResult.RESULT_OK);
         verifyInitializeResult(AppSearchResult.RESULT_OK);
-        verifyExecuteAppFunctionCallbackResult(AppSearchResult.RESULT_OK);
     }
 
     @Test
@@ -1525,78 +1508,6 @@ public class AppSearchManagerServiceTest {
         verify(mLogger, timeout(1000).times(0)).logStats(any(CallStats.class));
     }
 
-    @Test
-    public void executeAppFunction_success() throws Exception {
-        verifyExecuteAppFunctionCallbackResult(AppSearchResult.RESULT_OK);
-    }
-
-    @Test
-    public void executeAppFunction_callerNoPermission() throws Exception {
-        doReturn(List.of())
-                .when(mRoleManager).getRoleHoldersAsUser(
-                        AppSearchManagerService.SYSTEM_UI_INTELLIGENCE, mUserHandle);
-
-        verifyExecuteAppFunctionCallbackResult(AppSearchResult.RESULT_SECURITY_ERROR);
-    }
-
-    @Test
-    public void executeAppFunction_cannotResolveService() throws Exception {
-        PackageManager spyPackageManager = mContext.getPackageManager();
-        doReturn(null).when(spyPackageManager).resolveService(any(Intent.class), eq(0));
-
-        verifyExecuteAppFunctionCallbackResult(AppSearchResult.RESULT_NOT_FOUND);
-    }
-
-    @Test
-    public void executeAppFunction_bindServiceReturnsFalse() throws Exception {
-        mServiceCallHelper.setBindServiceResult(false);
-        mServiceCallHelper.setOnRunServiceCallListener((callback) -> {});
-
-        verifyExecuteAppFunctionCallbackResult(AppSearchResult.RESULT_INTERNAL_ERROR);
-    }
-
-    @Test
-    public void executeAppFunction_failedToConnectService() throws Exception {
-        mServiceCallHelper.setOnRunServiceCallListener(
-                ServiceCallHelper.RunServiceCallCallback::onFailedToConnect);
-
-        verifyExecuteAppFunctionCallbackResult(AppSearchResult.RESULT_INTERNAL_ERROR);
-    }
-
-    @Test
-    public void executeAppFunction_serviceConnectionTimeout() throws Exception {
-        mServiceCallHelper.setOnRunServiceCallListener(
-                ServiceCallHelper.RunServiceCallCallback::onTimedOut);
-
-        verifyExecuteAppFunctionCallbackResult(AppSearchResult.RESULT_TIMED_OUT);
-    }
-
-    @Test
-    public void executeAppFunction_executeAppFunctionReturnsFailure() throws Exception {
-        mServiceCallHelper.setOnRunServiceCallListener(
-                (callback) -> callback.onServiceConnected(new TestableAppFunctionService(
-                        AppSearchResult.newFailedResult(AppSearchResult.RESULT_INVALID_ARGUMENT,
-                                "errorMessage")), () -> {
-                }));
-
-        verifyExecuteAppFunctionCallbackResult(AppSearchResult.RESULT_INVALID_ARGUMENT);
-    }
-
-    @Test
-    public void executeAppFunction_hasDeviceOwner_fail() throws Exception {
-        doReturn(true).when(mDevicePolicyManager).isDeviceManaged();
-
-        verifyExecuteAppFunctionCallbackResult(AppSearchResult.RESULT_SECURITY_ERROR);
-    }
-
-    @Test
-    public void executeAppFunction_fromManagedProfile_fail() throws Exception {
-        UserManager spyUserManager = mContext.getSystemService(UserManager.class);
-        doReturn(true).when(spyUserManager).isManagedProfile(mUserHandle.getIdentifier());
-
-        verifyExecuteAppFunctionCallbackResult(AppSearchResult.RESULT_SECURITY_ERROR);
-    }
-
     private void verifyLocalCallsResults(int resultCode) throws Exception {
         // These APIs are local calls since they specify a database. If the API specifies a target
         // package, then the target package matches the calling package
@@ -1630,7 +1541,6 @@ public class AppSearchManagerServiceTest {
         verifyRegisterObserverCallbackResult(resultCode);
         verifyUnregisterObserverCallbackResult(resultCode);
         verifyInitializeResult(resultCode);
-        verifyExecuteAppFunctionCallbackResult(resultCode);
     }
 
     private void verifySetSchemaResult(int resultCode) throws Exception {
@@ -1933,23 +1843,6 @@ public class AppSearchManagerServiceTest {
                 resultParcel.getResult());
     }
 
-    private void verifyExecuteAppFunctionCallbackResult(int resultCode) throws Exception {
-        TestResultCallback callback = new TestResultCallback();
-        mAppSearchManagerServiceStub.executeAppFunction(
-                new ExecuteAppFunctionAidlRequest(
-                        new ExecuteAppFunctionRequest.Builder(
-                                FOO_PACKAGE_NAME, "function"
-                        ).build(),
-                        AppSearchAttributionSource.createAttributionSource(mContext,
-                                mCallingPid),
-                        mUserHandle,
-                        BINDER_CALL_START_TIME
-                ),
-                callback
-        );
-
-        verifyCallResult(resultCode, CallStats.CALL_TYPE_EXECUTE_APP_FUNCTION, callback.get());
-    }
 
     private void verifyUnregisterObserverCallbackResult(int resultCode) throws Exception {
         AppSearchResultParcel<Void> resultParcel =
@@ -2037,29 +1930,6 @@ public class AppSearchManagerServiceTest {
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
     }
 
-    private void setUpEnvironmentForAppFunction() {
-        doReturn(Arrays.asList(mContext.getPackageName()))
-                .when(mRoleManager).getRoleHoldersAsUser(
-                        AppSearchManagerService.SYSTEM_UI_INTELLIGENCE, mUserHandle);
-
-        // FOO_PACKAGE implemented an AppFunctionService.
-        ServiceInfo serviceInfo = new ServiceInfo();
-        serviceInfo.packageName = FOO_PACKAGE_NAME;
-        serviceInfo.name = ".MyAppFunctionService";
-        // TODO(b/359911502): Commenting out this permission since the BIND_APP_FUNCTION_SERVICE
-        //   permission is deleted from app search. Th whole app function functionality should be
-        //   removed along with the tests here once the new app function manager is submitted.
-        //   serviceInfo.permission = AppFunctionManager.PERMISSION_BIND_APP_FUNCTION_SERVICE;
-        ResolveInfo resolveInfo = new ResolveInfo();
-        resolveInfo.serviceInfo = serviceInfo;
-        PackageManager spyPackageManager = mContext.getPackageManager();
-        doReturn(resolveInfo).when(spyPackageManager).resolveService(any(Intent.class), eq(0));
-
-        doReturn(false).when(mDevicePolicyManager).isDeviceManaged();
-        UserManager spyUserManager = mContext.getSystemService(UserManager.class);
-        doReturn(false).when(spyUserManager).isManagedProfile(mUserHandle.getIdentifier());
-    }
-
     private static class MockServiceManager implements StaticMockFixture {
         ArgumentCaptor<IAppSearchManager.Stub> mStubCaptor = ArgumentCaptor.forClass(
                 IAppSearchManager.Stub.class);
@@ -2094,6 +1964,11 @@ public class AppSearchManagerServiceTest {
             future.set(appSearchResultParcel.getResult());
         }
 
+        @Override
+        public void onResultV2(AppSearchResultParcelV2 appSearchResultParcel) {
+            future.set(appSearchResultParcel.getResult());
+        }
+
         public AppSearchResult<?> get() throws InterruptedException, ExecutionException {
             return future.get();
         }
@@ -2126,70 +2001,4 @@ public class AppSearchManagerServiceTest {
             return batchFuture.get();
         }
     }
-
-    /**
-     * Testable helper for {@link ServiceCallHelper}, defaults to the happy case, i.e. successful
-     * service connection and
-     * {@link android.app.appsearch.functions.AppFunctionService#onExecuteFunction} always
-     * returns a successful result. Includes methods to customize connection behavior.
-     */
-    private static class TestableServiceCallHelper implements
-            ServiceCallHelper<IAppFunctionService> {
-        private Consumer<RunServiceCallCallback<IAppFunctionService>> mOnRunServiceCallListener =
-                (callback) -> callback.onServiceConnected(new TestableAppFunctionService(
-                        AppSearchResult.newSuccessfulResult(
-                                new ExecuteAppFunctionResponse.Builder().build())), () -> {
-                });
-        private boolean mBindServiceResult = true;
-
-        /**
-         * Replaces the default service connection behavior. Use this in tests to simulate
-         * different connection results (e.g., failures).
-         */
-        public void setOnRunServiceCallListener(
-                @NonNull Consumer<RunServiceCallCallback<IAppFunctionService>> listener) {
-            mOnRunServiceCallListener = Objects.requireNonNull(listener);
-        }
-
-        /** Sets the result of {@link #runServiceCall} (defaults to {@code true}). */
-        public void setBindServiceResult(boolean bindResult) {
-            mBindServiceResult = bindResult;
-        }
-
-        @Override
-        public boolean runServiceCall(@NonNull Intent intent, int bindFlags,
-                long timeoutInMillis, @NonNull UserHandle userHandle,
-                @NonNull RunServiceCallCallback<IAppFunctionService> callback) {
-            mOnRunServiceCallListener.accept(callback);
-            return mBindServiceResult;
-        }
-    }
-
-    /**
-     * A testable implementation of {@link IAppFunctionService.Stub} for you to customize the
-     * result of {@link #executeAppFunction}.
-     */
-    private static class TestableAppFunctionService extends IAppFunctionService.Stub {
-        private final AppSearchResult<ExecuteAppFunctionResponse> mResult;
-
-        /**
-         * @param result the result to return in {@link #executeAppFunction}.
-         */
-        public TestableAppFunctionService(
-                @NonNull AppSearchResult<ExecuteAppFunctionResponse> result) {
-            mResult = Objects.requireNonNull(result);
-        }
-
-        @Override
-        public void executeAppFunction(
-                ExecuteAppFunctionRequest executeAppFunctionRequest,
-                IAppSearchResultCallback callback) throws RemoteException {
-            if (mResult.isSuccess()) {
-                callback.onResult(AppSearchResultParcel.fromExecuteAppFunctionResponse(
-                        mResult.getResultValue()));
-            } else {
-                callback.onResult(AppSearchResultParcel.fromFailedResult(mResult));
-            }
-        }
-    }
 }
diff --git a/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchModuleTest.java b/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchModuleTest.java
index 1fab22d1..d696b43e 100644
--- a/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchModuleTest.java
+++ b/testing/mockingservicestests/src/com/android/server/appsearch/AppSearchModuleTest.java
@@ -16,6 +16,9 @@
 
 package com.android.server.appsearch;
 
+import static android.provider.DeviceConfig.NAMESPACE_APPSEARCH;
+
+import static com.android.server.appsearch.appsindexer.AppOpenEventIndexerConfig.DEFAULT_APP_OPEN_EVENT_INDEXER_ENABLED;
 import static com.android.server.appsearch.appsindexer.AppsIndexerConfig.DEFAULT_APPS_INDEXER_ENABLED;
 import static com.android.server.appsearch.contactsindexer.ContactsIndexerConfig.DEFAULT_CONTACTS_INDEXER_ENABLED;
 
@@ -25,6 +28,7 @@ import static org.junit.Assert.assertNull;
 import static org.mockito.Mockito.doNothing;
 import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 
 import android.annotation.NonNull;
@@ -41,11 +45,15 @@ import com.android.appsearch.flags.Flags;
 import com.android.dx.mockito.inline.extended.ExtendedMockito;
 import com.android.server.SystemService.TargetUser;
 import com.android.server.appsearch.AppSearchModule.Lifecycle;
+import com.android.server.appsearch.appsindexer.AppOpenEventIndexerConfig;
+import com.android.server.appsearch.appsindexer.AppOpenEventIndexerManagerService;
 import com.android.server.appsearch.appsindexer.AppsIndexerConfig;
 import com.android.server.appsearch.appsindexer.AppsIndexerManagerService;
 import com.android.server.appsearch.contactsindexer.ContactsIndexerConfig;
 import com.android.server.appsearch.contactsindexer.ContactsIndexerManagerService;
 
+import com.google.common.annotations.VisibleForTesting;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -55,9 +63,14 @@ import org.mockito.quality.Strictness;
 
 @RequiresFlagsEnabled(Flags.FLAG_APPS_INDEXER_ENABLED)
 public class AppSearchModuleTest {
-    private static final String NAMESPACE_APPSEARCH = "appsearch";
-    private static final String KEY_CONTACTS_INDEXER_ENABLED = "contacts_indexer_enabled";
-    private static final String KEY_APPS_INDEXER_ENABLED = "apps_indexer_enabled";
+    @VisibleForTesting
+    public static final String KEY_CONTACTS_INDEXER_ENABLED = "contacts_indexer_enabled";
+
+    @VisibleForTesting public static final String KEY_APPS_INDEXER_ENABLED = "apps_indexer_enabled";
+
+    @VisibleForTesting
+    public static final String KEY_APP_OPEN_EVENT_INDEXER_ENABLED =
+            "app_open_event_indexer_enabled";
 
     @Rule
     public final CheckFlagsRule mCheckFlagsRule = DeviceFlagsValueProvider.createCheckFlagsRule();
@@ -66,12 +79,16 @@ public class AppSearchModuleTest {
             mock(ContactsIndexerManagerService.class);
     private final AppsIndexerManagerService mAppsIndexerService =
             mock(AppsIndexerManagerService.class);
+    private final AppOpenEventIndexerManagerService mAppOpenEventIndexerService =
+            mock(AppOpenEventIndexerManagerService.class);
     private final AppSearchManagerService mAppSearchService = mock(AppSearchManagerService.class);
 
     private TargetUser mUser;
     private Lifecycle mLifecycle;
     private MockitoSession mMockitoSession;
 
+    private Context mContext;
+
     @Before
     public void setUp() {
         mMockitoSession =
@@ -79,35 +96,43 @@ public class AppSearchModuleTest {
                         .mockStatic(DeviceConfig.class)
                         .strictness(Strictness.LENIENT)
                         .startMocking();
-        Context context = ApplicationProvider.getApplicationContext();
-        UserInfo userInfo = new UserInfo(context.getUserId(), "default", 0);
+        mContext = ApplicationProvider.getApplicationContext();
+        UserInfo userInfo = new UserInfo(mContext.getUserId(), "default", 0);
         mUser = new TargetUser(userInfo);
 
         mLifecycle =
-                new Lifecycle(context) {
+                new Lifecycle(mContext) {
                     @NonNull
                     @Override
                     AppsIndexerManagerService createAppsIndexerManagerService(
-                            @NonNull Context context, @NonNull AppsIndexerConfig config) {
+                            @NonNull Context mContext, @NonNull AppsIndexerConfig config) {
                         return mAppsIndexerService;
                     }
 
                     @NonNull
                     @Override
                     ContactsIndexerManagerService createContactsIndexerManagerService(
-                            @NonNull Context context, @NonNull ContactsIndexerConfig config) {
+                            @NonNull Context mContext, @NonNull ContactsIndexerConfig config) {
                         return mContactsIndexerService;
                     }
 
                     @NonNull
                     @Override
                     AppSearchManagerService createAppSearchManagerService(
-                            @NonNull Context context, @NonNull Lifecycle lifecycle) {
+                            @NonNull Context mContext, @NonNull Lifecycle lifecycle) {
                         return mAppSearchService;
                     }
+
+                    @NonNull
+                    @Override
+                    AppOpenEventIndexerManagerService createAppOpenEventIndexerManagerService(
+                            @NonNull Context mContext, @NonNull AppOpenEventIndexerConfig config) {
+                        return mAppOpenEventIndexerService;
+                    }
                 };
 
-        // Enable contacts indexer and apps indexer by default. Some tests will turn them off
+        // Enable contacts + apps + app open event indexers by default. Some tests will turn them
+        // off
         ExtendedMockito.doReturn(true)
                 .when(
                         () ->
@@ -122,6 +147,13 @@ public class AppSearchModuleTest {
                                         NAMESPACE_APPSEARCH,
                                         KEY_APPS_INDEXER_ENABLED,
                                         DEFAULT_APPS_INDEXER_ENABLED));
+        ExtendedMockito.doReturn(true)
+                .when(
+                        () ->
+                                DeviceConfig.getBoolean(
+                                        NAMESPACE_APPSEARCH,
+                                        KEY_APP_OPEN_EVENT_INDEXER_ENABLED,
+                                        DEFAULT_APP_OPEN_EVENT_INDEXER_ENABLED));
     }
 
     @After
@@ -130,7 +162,26 @@ public class AppSearchModuleTest {
     }
 
     @Test
-    public void testBothIndexersEnabled() {
+    @RequiresFlagsEnabled(Flags.FLAG_APP_OPEN_EVENT_INDEXER_ENABLED)
+    public void testAllIndexersEnabled_withAppOpenEventIndexer() {
+        mLifecycle.onStart();
+        assertThat(mLifecycle.mAppsIndexerManagerService).isNotNull();
+        assertThat(mLifecycle.mContactsIndexerManagerService).isNotNull();
+        assertThat(mLifecycle.mAppOpenEventIndexerManagerService).isNotNull();
+
+        mLifecycle.onUserUnlocking(mUser);
+        verify(mContactsIndexerService).onUserUnlocking(mUser);
+        verify(mAppsIndexerService).onUserUnlocking(mUser);
+        verify(mAppOpenEventIndexerService).onStart();
+
+        mLifecycle.onUserStopping(mUser);
+        verify(mContactsIndexerService).onUserStopping(mUser);
+        verify(mAppsIndexerService).onUserStopping(mUser);
+        verify(mAppOpenEventIndexerService).onUserStopping(mUser);
+    }
+
+    @Test
+    public void testContactsAndAppsIndexersEnabled() {
         mLifecycle.onStart();
         assertThat(mLifecycle.mAppsIndexerManagerService).isNotNull();
         assertThat(mLifecycle.mContactsIndexerManagerService).isNotNull();
@@ -188,6 +239,30 @@ public class AppSearchModuleTest {
         assertNull(mLifecycle.mAppsIndexerManagerService);
     }
 
+    @Test
+    public void testAppOpenEventIndexerDisabled() {
+        ExtendedMockito.doReturn(false)
+                .when(
+                        () ->
+                                DeviceConfig.getBoolean(
+                                        NAMESPACE_APPSEARCH,
+                                        KEY_APP_OPEN_EVENT_INDEXER_ENABLED,
+                                        DEFAULT_APP_OPEN_EVENT_INDEXER_ENABLED));
+
+        mLifecycle.onStart();
+        assertNull(mLifecycle.mAppOpenEventIndexerManagerService);
+
+        mLifecycle.onUserUnlocking(mUser);
+        verify(mContactsIndexerService).onUserUnlocking(mUser);
+        verify(mAppOpenEventIndexerService, never()).onStart();
+        assertNull(mLifecycle.mAppOpenEventIndexerManagerService);
+
+        mLifecycle.onUserStopping(mUser);
+        verify(mContactsIndexerService).onUserStopping(mUser);
+        verify(mAppOpenEventIndexerService, never()).onUserStopping(mUser);
+        assertNull(mLifecycle.mAppOpenEventIndexerManagerService);
+    }
+
     @Test
     public void testServicesSetToNullWhenDisabled() {
         ExtendedMockito.doReturn(false)
@@ -204,18 +279,28 @@ public class AppSearchModuleTest {
                                         NAMESPACE_APPSEARCH,
                                         KEY_APPS_INDEXER_ENABLED,
                                         DEFAULT_APPS_INDEXER_ENABLED));
+        ExtendedMockito.doReturn(false)
+                .when(
+                        () ->
+                                DeviceConfig.getBoolean(
+                                        NAMESPACE_APPSEARCH,
+                                        KEY_APP_OPEN_EVENT_INDEXER_ENABLED,
+                                        DEFAULT_APP_OPEN_EVENT_INDEXER_ENABLED));
 
         mLifecycle.onStart();
         assertNull(mLifecycle.mContactsIndexerManagerService);
         assertNull(mLifecycle.mAppsIndexerManagerService);
+        assertNull(mLifecycle.mAppOpenEventIndexerManagerService);
 
         mLifecycle.onUserUnlocking(mUser);
         assertNull(mLifecycle.mContactsIndexerManagerService);
         assertNull(mLifecycle.mAppsIndexerManagerService);
+        assertNull(mLifecycle.mAppOpenEventIndexerManagerService);
 
         mLifecycle.onUserStopping(mUser);
         assertNull(mLifecycle.mContactsIndexerManagerService);
         assertNull(mLifecycle.mAppsIndexerManagerService);
+        assertNull(mLifecycle.mAppOpenEventIndexerManagerService);
     }
 
     @Test
diff --git a/testing/mockingservicestests/src/com/android/server/appsearch/ServiceAppSearchConfigTest.java b/testing/mockingservicestests/src/com/android/server/appsearch/ServiceAppSearchConfigTest.java
index fdd91a5d..1f19ba25 100644
--- a/testing/mockingservicestests/src/com/android/server/appsearch/ServiceAppSearchConfigTest.java
+++ b/testing/mockingservicestests/src/com/android/server/appsearch/ServiceAppSearchConfigTest.java
@@ -34,11 +34,14 @@ import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_I
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_ICING_USE_PERSISTENT_HASHMAP;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_ICING_USE_PRE_MAPPING_WITH_FILE_BACKED_VECTOR;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_ICING_USE_READ_ONLY_SEARCH;
-import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_LIMIT_CONFIG_MAX_DOCUMENT_COUNT;
+import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_LIMIT_CONFIG_DOCUMENT_COUNT_LIMIT_START_THRESHOLD;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_LIMIT_CONFIG_MAX_DOCUMENT_SIZE_BYTES;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_LIMIT_CONFIG_MAX_SUGGESTION_COUNT;
+import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_LIMIT_CONFIG_PER_PACKAGE_DOCUMENT_COUNT_LIMIT;
+import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_MAX_OPEN_BLOB_COUNT;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_MIN_TIME_INTERVAL_BETWEEN_SAMPLES_MILLIS;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_MIN_TIME_OPTIMIZE_THRESHOLD_MILLIS;
+import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_ORPHAN_BLOB_TIME_TO_LIVE_MS;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_RATE_LIMIT_API_COSTS;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_RATE_LIMIT_ENABLED;
 import static com.android.server.appsearch.FrameworkServiceAppSearchConfig.KEY_RATE_LIMIT_TASK_QUEUE_PER_PACKAGE_CAPACITY_PERCENTAGE;
@@ -58,17 +61,20 @@ import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_DOC_CO
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_FULLY_PERSIST_JOB_INTERVAL;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_ICING_CONFIG_USE_READ_ONLY_SEARCH;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_INTEGER_INDEX_BUCKET_SPLIT_THRESHOLD;
-import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_LIMIT_CONFIG_MAX_DOCUMENT_COUNT;
+import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_LIMIT_CONFIG_DOCUMENT_COUNT_LIMIT_START_THRESHOLD;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_LIMIT_CONFIG_MAX_DOCUMENT_SIZE_BYTES;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_LIMIT_CONFIG_MAX_SUGGESTION_COUNT;
+import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_LIMIT_CONFIG_PER_PACKAGE_DOCUMENT_COUNT_LIMIT;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_LITE_INDEX_SORT_AT_INDEXING;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_LITE_INDEX_SORT_SIZE;
+import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_MAX_OPEN_BLOB_COUNT;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_MIN_TIME_INTERVAL_BETWEEN_SAMPLES_MILLIS;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_RATE_LIMIT_ENABLED;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_RATE_LIMIT_TASK_QUEUE_PER_PACKAGE_CAPACITY_PERCENTAGE;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_RATE_LIMIT_TASK_QUEUE_TOTAL_CAPACITY;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_SAMPLING_INTERVAL;
 import static com.android.server.appsearch.ServiceAppSearchConfig.DEFAULT_TIME_OPTIMIZE_THRESHOLD_MILLIS;
+import static com.android.server.appsearch.external.localstorage.IcingOptionsConfig.DEFAULT_ORPHAN_BLOB_TIME_TO_LIVE_MS;
 import static com.android.server.appsearch.external.localstorage.IcingOptionsConfig.DEFAULT_USE_NEW_QUALIFIED_ID_JOIN_INDEX;
 
 import static com.google.common.truth.Truth.assertThat;
@@ -112,8 +118,10 @@ public class ServiceAppSearchConfigTest {
                 DEFAULT_SAMPLING_INTERVAL);
         assertThat(appSearchConfig.getMaxDocumentSizeBytes()).isEqualTo(
                 DEFAULT_LIMIT_CONFIG_MAX_DOCUMENT_SIZE_BYTES);
-        assertThat(appSearchConfig.getMaxDocumentCount()).isEqualTo(
-                DEFAULT_LIMIT_CONFIG_MAX_DOCUMENT_COUNT);
+        assertThat(appSearchConfig.getPerPackageDocumentCountLimit())
+                .isEqualTo(DEFAULT_LIMIT_CONFIG_PER_PACKAGE_DOCUMENT_COUNT_LIMIT);
+        assertThat(appSearchConfig.getDocumentCountLimitStartThreshold())
+                .isEqualTo(DEFAULT_LIMIT_CONFIG_DOCUMENT_COUNT_LIMIT_START_THRESHOLD);
         assertThat(appSearchConfig.getMaxSuggestionCount()).isEqualTo(
                 DEFAULT_LIMIT_CONFIG_MAX_SUGGESTION_COUNT);
         assertThat(appSearchConfig.getCachedBytesOptimizeThreshold()).isEqualTo(
@@ -169,6 +177,9 @@ public class ServiceAppSearchConfigTest {
                 .isEqualTo(DEFAULT_USE_NEW_QUALIFIED_ID_JOIN_INDEX);
         assertThat(appSearchConfig.getCachedFullyPersistJobIntervalMillis())
                 .isEqualTo(DEFAULT_FULLY_PERSIST_JOB_INTERVAL);
+        assertThat(appSearchConfig.getMaxOpenBlobCount()).isEqualTo(DEFAULT_MAX_OPEN_BLOB_COUNT);
+        assertThat(appSearchConfig.getOrphanBlobTimeToLiveMs())
+                .isEqualTo(DEFAULT_ORPHAN_BLOB_TIME_TO_LIVE_MS);
     }
 
     @Test
@@ -472,28 +483,42 @@ public class ServiceAppSearchConfigTest {
                 KEY_LIMIT_CONFIG_MAX_DOCUMENT_SIZE_BYTES,
                 Integer.toString(2001),
                 /*makeDefault=*/ false);
-        DeviceConfig.setProperty(DeviceConfig.NAMESPACE_APPSEARCH,
-                KEY_LIMIT_CONFIG_MAX_DOCUMENT_COUNT,
+        DeviceConfig.setProperty(
+                DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_LIMIT_CONFIG_PER_PACKAGE_DOCUMENT_COUNT_LIMIT,
                 Integer.toString(2002),
-                /*makeDefault=*/ false);
+                /* makeDefault= */ false);
+        DeviceConfig.setProperty(
+                DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_LIMIT_CONFIG_DOCUMENT_COUNT_LIMIT_START_THRESHOLD,
+                Integer.toString(2003),
+                /* makeDefault= */ false);
 
         ServiceAppSearchConfig appSearchConfig =
                 FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
         assertThat(appSearchConfig.getMaxDocumentSizeBytes()).isEqualTo(2001);
-        assertThat(appSearchConfig.getMaxDocumentCount()).isEqualTo(2002);
+        assertThat(appSearchConfig.getPerPackageDocumentCountLimit()).isEqualTo(2002);
+        assertThat(appSearchConfig.getDocumentCountLimitStartThreshold()).isEqualTo(2003);
 
         // Override
         DeviceConfig.setProperty(DeviceConfig.NAMESPACE_APPSEARCH,
                 KEY_LIMIT_CONFIG_MAX_DOCUMENT_SIZE_BYTES,
                 Integer.toString(1775),
                 /*makeDefault=*/ false);
-        DeviceConfig.setProperty(DeviceConfig.NAMESPACE_APPSEARCH,
-                KEY_LIMIT_CONFIG_MAX_DOCUMENT_COUNT,
+        DeviceConfig.setProperty(
+                DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_LIMIT_CONFIG_PER_PACKAGE_DOCUMENT_COUNT_LIMIT,
                 Integer.toString(1776),
-                /*makeDefault=*/ false);
+                /* makeDefault= */ false);
+        DeviceConfig.setProperty(
+                DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_LIMIT_CONFIG_DOCUMENT_COUNT_LIMIT_START_THRESHOLD,
+                Integer.toString(1777),
+                /* makeDefault= */ false);
 
         assertThat(appSearchConfig.getMaxDocumentSizeBytes()).isEqualTo(1775);
-        assertThat(appSearchConfig.getMaxDocumentCount()).isEqualTo(1776);
+        assertThat(appSearchConfig.getPerPackageDocumentCountLimit()).isEqualTo(1776);
+        assertThat(appSearchConfig.getDocumentCountLimitStartThreshold()).isEqualTo(1777);
     }
 
     @Test
@@ -886,6 +911,39 @@ public class ServiceAppSearchConfigTest {
         assertThat(appSearchConfig.getCachedFullyPersistJobIntervalMillis()).isEqualTo(1777);
     }
 
+    @Test
+    public void testCustomizedValueOverride_blobStore() {
+        DeviceConfig.setProperty(
+                DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_MAX_OPEN_BLOB_COUNT,
+                Integer.toString(2003),
+                /* makeDefault= */ false);
+        DeviceConfig.setProperty(
+                DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_ORPHAN_BLOB_TIME_TO_LIVE_MS,
+                Integer.toString(2004),
+                /* makeDefault= */ false);
+
+        ServiceAppSearchConfig appSearchConfig =
+                FrameworkServiceAppSearchConfig.create(DIRECT_EXECUTOR);
+        assertThat(appSearchConfig.getMaxOpenBlobCount()).isEqualTo(2003);
+        assertThat(appSearchConfig.getOrphanBlobTimeToLiveMs()).isEqualTo(2004);
+
+        // Override
+        DeviceConfig.setProperty(
+                DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_MAX_OPEN_BLOB_COUNT,
+                Integer.toString(1777),
+                /* makeDefault= */ false);
+        DeviceConfig.setProperty(
+                DeviceConfig.NAMESPACE_APPSEARCH,
+                KEY_ORPHAN_BLOB_TIME_TO_LIVE_MS,
+                Integer.toString(1778),
+                /* makeDefault= */ false);
+
+        assertThat(appSearchConfig.getMaxOpenBlobCount()).isEqualTo(1777);
+        assertThat(appSearchConfig.getOrphanBlobTimeToLiveMs()).isEqualTo(1778);
+    }
 
     @Test
     public void testNotUsable_afterClose() {
@@ -921,9 +979,14 @@ public class ServiceAppSearchConfigTest {
         Assert.assertThrows("Trying to use a closed AppSearchConfig instance.",
                 IllegalStateException.class,
                 () -> appSearchConfig.getMaxDocumentSizeBytes());
-        Assert.assertThrows("Trying to use a closed AppSearchConfig instance.",
+        Assert.assertThrows(
+                "Trying to use a closed AppSearchConfig instance.",
+                IllegalStateException.class,
+                () -> appSearchConfig.getPerPackageDocumentCountLimit());
+        Assert.assertThrows(
+                "Trying to use a closed AppSearchConfig instance.",
                 IllegalStateException.class,
-                () -> appSearchConfig.getMaxDocumentCount());
+                () -> appSearchConfig.getDocumentCountLimitStartThreshold());
         Assert.assertThrows("Trying to use a closed AppSearchConfig instance.",
                 IllegalStateException.class,
                 () -> appSearchConfig.getMaxSuggestionCount());
@@ -990,5 +1053,13 @@ public class ServiceAppSearchConfigTest {
         Assert.assertThrows("Trying to use a closed AppSearchConfig instance.",
                 IllegalStateException.class,
                 () -> appSearchConfig.getCachedFullyPersistJobIntervalMillis());
+        Assert.assertThrows(
+                "Trying to use a closed AppSearchConfig instance.",
+                IllegalStateException.class,
+                () -> appSearchConfig.getMaxOpenBlobCount());
+        Assert.assertThrows(
+                "Trying to use a closed AppSearchConfig instance.",
+                IllegalStateException.class,
+                () -> appSearchConfig.getOrphanBlobTimeToLiveMs());
     }
 }
diff --git a/testing/safeparceltests/src/android/app/appsearch/safeparcel/TestSafeParcelableV5.java b/testing/safeparceltests/src/android/app/appsearch/safeparcel/TestSafeParcelableV5.java
new file mode 100644
index 00000000..20cef26d
--- /dev/null
+++ b/testing/safeparceltests/src/android/app/appsearch/safeparcel/TestSafeParcelableV5.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app.appsearch.safeparcel;
+
+import android.os.Parcel;
+
+@SafeParcelable.Class(creator = "TestSafeParcelableV5Creator")
+public class TestSafeParcelableV5<T, U> extends AbstractSafeParcelable {
+
+    @SuppressWarnings("rawtypes")
+    public static final Creator<TestSafeParcelableV5> CREATOR = new TestSafeParcelableV5Creator();
+
+    @Field(id = 1)
+    public String publicString;
+
+    @Constructor
+    public TestSafeParcelableV5(@Param(id = 1) String publicString) {
+        this.publicString = publicString;
+    }
+
+    @Override
+    public void writeToParcel(Parcel out, int flags) {
+        TestSafeParcelableV5Creator.writeToParcel(this, out, flags);
+    }
+}
diff --git a/testing/servicestests/Android.bp b/testing/servicestests/Android.bp
index 083ff4a3..83b3d087 100644
--- a/testing/servicestests/Android.bp
+++ b/testing/servicestests/Android.bp
@@ -13,6 +13,7 @@
 // limitations under the License.
 
 package {
+    default_team: "trendy_team_appsearch",
     default_applicable_licenses: ["Android-Apache-2.0"],
 }
 
@@ -24,6 +25,7 @@ android_test {
         "android.app.appfunctions.flags-aconfig-java",
         "androidx.test.ext.junit",
         "androidx.test.rules",
+        "appsearch_flags_java_lib",
         "compatibility-device-util-axt",
         "flag-junit",
         "framework-appsearch.impl",
diff --git a/testing/servicestests/src/com/android/server/appsearch/AdbDumpUtilTest.java b/testing/servicestests/src/com/android/server/appsearch/AdbDumpUtilTest.java
index a6c30d0d..6c2ef764 100644
--- a/testing/servicestests/src/com/android/server/appsearch/AdbDumpUtilTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/AdbDumpUtilTest.java
@@ -21,6 +21,7 @@ import static com.google.common.truth.Truth.assertThat;
 import android.app.appsearch.AppSearchSchema;
 import android.app.appsearch.GenericDocument;
 import android.app.appsearch.testutil.FakeAppSearchConfig;
+
 import com.android.server.appsearch.external.localstorage.AppSearchImpl;
 import com.android.server.appsearch.icing.proto.DebugInfoProto;
 import com.android.server.appsearch.icing.proto.DebugInfoVerbosity;
@@ -32,12 +33,14 @@ import com.android.server.appsearch.icing.proto.SchemaDebugInfoProto;
 import com.android.server.appsearch.icing.proto.SchemaProto;
 import com.android.server.appsearch.icing.proto.SchemaTypeConfigProto;
 import com.android.server.appsearch.util.AdbDumpUtil;
-import java.util.Collections;
-import java.util.List;
+
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 
+import java.util.Collections;
+import java.util.List;
+
 public class AdbDumpUtilTest {
     @Rule
     public TemporaryFolder mTemporaryFolder = new TemporaryFolder();
@@ -125,10 +128,14 @@ public class AdbDumpUtilTest {
 
     @Test
     public void testDesensitizeRealDebugInfo() throws Exception {
-        AppSearchImpl appSearchImpl = AppSearchImpl.create(mTemporaryFolder.newFolder(),
-                new FakeAppSearchConfig(),
-                /*initStatsBuilder=*/ null, /*visibilityChecker=*/ null,
-                optimizeInfo -> true);
+        AppSearchImpl appSearchImpl =
+                AppSearchImpl.create(
+                        mTemporaryFolder.newFolder(),
+                        new FakeAppSearchConfig(),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        optimizeInfo -> true);
         List<AppSearchSchema> schemas = Collections.singletonList(new AppSearchSchema.Builder(
                 PERSON_TYPE).addProperty(new AppSearchSchema.StringPropertyConfig.Builder(
                 "name").setIndexingType(
diff --git a/testing/servicestests/src/com/android/server/appsearch/DenylistTest.java b/testing/servicestests/src/com/android/server/appsearch/DenylistTest.java
index 7c0e2dfc..40b35cc0 100644
--- a/testing/servicestests/src/com/android/server/appsearch/DenylistTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/DenylistTest.java
@@ -39,16 +39,19 @@ public class DenylistTest {
 
     @Test
     public void testDenyAllApis() {
-        Denylist denylist = Denylist.create(
-                "pkg=foo&apis=localSetSchema,globalGetSchema,localGetSchema,"
-                        + "localGetNamespaces,localPutDocuments,globalGetDocuments,"
-                        + "localGetDocuments,globalSearch,localSearch,globalGetNextPage,"
-                        + "localGetNextPage,invalidateNextPageToken,"
-                        + "localWriteSearchResultsToFile,localPutDocumentsFromFile,"
-                        + "localSearchSuggestion,globalReportUsage,localReportUsage,"
-                        + "localRemoveByDocumentId,localRemoveBySearch,localGetStorageInfo,flush,"
-                        + "globalRegisterObserverCallback,globalUnregisterObserverCallback,"
-                        + "initialize,executeAppFunction");
+        Denylist denylist =
+                Denylist.create(
+                        "pkg=foo&apis=localSetSchema,globalGetSchema,localGetSchema,"
+                            + "localGetNamespaces,localPutDocuments,globalGetDocuments,"
+                            + "localGetDocuments,globalSearch,localSearch,globalGetNextPage,"
+                            + "localGetNextPage,invalidateNextPageToken,"
+                            + "localWriteSearchResultsToFile,localPutDocumentsFromFile,"
+                            + "localSearchSuggestion,globalReportUsage,localReportUsage,"
+                            + "localRemoveByDocumentId,localRemoveBySearch,localGetStorageInfo,"
+                            + "flush,globalRegisterObserverCallback,"
+                            + "globalUnregisterObserverCallback,initialize,executeAppFunction,"
+                            + "openWriteBlob,commitBlob,openReadBlob,removeBlob,globalOpenReadBlob,"
+                            + "setBlobVisibility");
         for (Integer apiType : CallStats.getAllApiCallTypes()) {
             assertThat(denylist.checkDeniedPackageDatabase("foo", "bar", apiType)).isTrue();
             assertThat(denylist.checkDeniedPackageDatabase("bar", "foo", apiType)).isFalse();
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/AppSearchImplTest.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/AppSearchImplTest.java
index 1e8d2f5a..ce300c53 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/AppSearchImplTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/AppSearchImplTest.java
@@ -17,13 +17,19 @@
 package com.android.server.appsearch.external.localstorage;
 
 import static android.app.appsearch.AppSearchResult.RESULT_INVALID_ARGUMENT;
+import static android.app.appsearch.AppSearchResult.RESULT_NOT_FOUND;
+import static android.app.appsearch.AppSearchResult.RESULT_OUT_OF_SPACE;
+import static android.app.appsearch.testutil.AppSearchTestUtils.calculateDigest;
 import static android.app.appsearch.testutil.AppSearchTestUtils.createMockVisibilityChecker;
+import static android.app.appsearch.testutil.AppSearchTestUtils.generateRandomBytes;
 
 import static com.android.server.appsearch.external.localstorage.util.PrefixUtil.addPrefixToDocument;
 import static com.android.server.appsearch.external.localstorage.util.PrefixUtil.createPrefix;
 import static com.android.server.appsearch.external.localstorage.util.PrefixUtil.removePrefixesFromDocument;
-import static com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityStore.ANDROID_V_OVERLAY_DATABASE_NAME;
-import static com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityStore.VISIBILITY_DATABASE_NAME;
+import static com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityStore.BLOB_ANDROID_V_OVERLAY_DATABASE_NAME;
+import static com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityStore.BLOB_VISIBILITY_DATABASE_NAME;
+import static com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityStore.DOCUMENT_ANDROID_V_OVERLAY_DATABASE_NAME;
+import static com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityStore.DOCUMENT_VISIBILITY_DATABASE_NAME;
 import static com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityStore.VISIBILITY_PACKAGE_NAME;
 
 import static com.google.common.truth.Truth.assertThat;
@@ -31,14 +37,17 @@ import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
 
 import android.annotation.NonNull;
+import android.app.appsearch.AppSearchBlobHandle;
 import android.app.appsearch.AppSearchResult;
 import android.app.appsearch.AppSearchSchema;
+import android.app.appsearch.Features;
 import android.app.appsearch.GenericDocument;
 import android.app.appsearch.GetSchemaResponse;
 import android.app.appsearch.InternalSetSchemaResponse;
 import android.app.appsearch.InternalVisibilityConfig;
 import android.app.appsearch.JoinSpec;
 import android.app.appsearch.PackageIdentifier;
+import android.app.appsearch.SchemaVisibilityConfig;
 import android.app.appsearch.SearchResult;
 import android.app.appsearch.SearchResultPage;
 import android.app.appsearch.SearchSpec;
@@ -50,14 +59,19 @@ import android.app.appsearch.exceptions.AppSearchException;
 import android.app.appsearch.observer.DocumentChangeInfo;
 import android.app.appsearch.observer.ObserverSpec;
 import android.app.appsearch.observer.SchemaChangeInfo;
+import android.app.appsearch.testutil.AppSearchTestUtils;
 import android.app.appsearch.testutil.TestObserverCallback;
 import android.content.Context;
+import android.os.ParcelFileDescriptor;
+import android.platform.test.annotations.RequiresFlagsDisabled;
+import android.platform.test.annotations.RequiresFlagsEnabled;
 import android.util.ArrayMap;
 import android.util.ArraySet;
 
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.filters.FlakyTest;
 
+import com.android.appsearch.flags.Flags;
 import com.android.server.appsearch.appsearch.proto.AndroidVOverlayProto;
 import com.android.server.appsearch.appsearch.proto.PackageIdentifierProto;
 import com.android.server.appsearch.appsearch.proto.VisibilityConfigProto;
@@ -94,9 +108,13 @@ import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.RuleChain;
 import org.junit.rules.TemporaryFolder;
 
 import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -110,6 +128,8 @@ public class AppSearchImplTest {
      */
     private static final OptimizeStrategy ALWAYS_OPTIMIZE = optimizeInfo -> true;
 
+    @Rule public final RuleChain mRuleChain = AppSearchTestUtils.createCommonTestRules();
+
     @Rule public TemporaryFolder mTemporaryFolder = new TemporaryFolder();
     private File mAppSearchDir;
 
@@ -119,6 +139,9 @@ public class AppSearchImplTest {
     private final CallerAccess mSelfCallerAccess = new CallerAccess(mContext.getPackageName());
 
     private AppSearchImpl mAppSearchImpl;
+    private AppSearchConfig mUnlimitedConfig =
+            new AppSearchConfigImpl(
+                    new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig());
 
     @Before
     public void setUp() throws Exception {
@@ -126,10 +149,10 @@ public class AppSearchImplTest {
         mAppSearchImpl =
                 AppSearchImpl.create(
                         mAppSearchDir,
-                        new AppSearchConfigImpl(
-                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        mUnlimitedConfig,
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
     }
 
@@ -599,6 +622,7 @@ public class AppSearchImplTest {
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
                         initStatsBuilder,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Check recovery state
@@ -845,6 +869,7 @@ public class AppSearchImplTest {
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         mockVisibilityChecker,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Insert package1 schema
@@ -1026,6 +1051,7 @@ public class AppSearchImplTest {
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         mockVisibilityChecker,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         AppSearchSchema.StringPropertyConfig personField =
@@ -2520,267 +2546,1714 @@ public class AppSearchImplTest {
     }
 
     @Test
-    public void testClearPackageData() throws AppSearchException {
-        List<SchemaTypeConfigProto> existingSchemas =
-                mAppSearchImpl.getSchemaProtoLocked().getTypesList();
-        Map<String, Set<String>> existingDatabases = mAppSearchImpl.getPackageToDatabases();
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testWriteAndReadBlob() throws Exception {
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        ALWAYS_OPTIMIZE);
+        byte[] data = generateRandomBytes(20 * 1024); // 20 KiB
+        byte[] digest = calculateDigest(data);
+        AppSearchBlobHandle handle =
+                AppSearchBlobHandle.createWithSha256(digest, "package", "db1", "ns");
+        try (ParcelFileDescriptor writePfd =
+                        mAppSearchImpl.openWriteBlob("package", "db1", handle);
+                OutputStream outputStream =
+                        new ParcelFileDescriptor.AutoCloseOutputStream(writePfd)) {
+            outputStream.write(data);
+            outputStream.flush();
+        }
 
-        // Insert package schema
-        List<AppSearchSchema> schema =
-                ImmutableList.of(new AppSearchSchema.Builder("schema").build());
+        // commit the change and read the blob.
+        mAppSearchImpl.commitBlob("package", "db1", handle);
+        byte[] readBytes = new byte[20 * 1024];
+        try (ParcelFileDescriptor readPfd = mAppSearchImpl.openReadBlob("package", "db1", handle);
+                InputStream inputStream = new ParcelFileDescriptor.AutoCloseInputStream(readPfd)) {
+            inputStream.read(readBytes);
+        }
+        assertThat(readBytes).isEqualTo(data);
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testRemovePendingBlob() throws Exception {
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        ALWAYS_OPTIMIZE);
+        byte[] data = generateRandomBytes(20 * 1024); // 20 KiB
+        byte[] digest = calculateDigest(data);
+        AppSearchBlobHandle handle =
+                AppSearchBlobHandle.createWithSha256(digest, "package", "db1", "ns");
+        try (ParcelFileDescriptor writePfd =
+                        mAppSearchImpl.openWriteBlob("package", "db1", handle);
+                OutputStream outputStream =
+                        new ParcelFileDescriptor.AutoCloseOutputStream(writePfd)) {
+            outputStream.write(data);
+            outputStream.flush();
+        }
+
+        mAppSearchImpl.commitBlob("package", "db1", handle);
+
+        // Remove the committed blob
+        mAppSearchImpl.removeBlob("package", "db1", handle);
+
+        // Read will get NOT_FOUND
+        AppSearchException e =
+                assertThrows(
+                        AppSearchException.class,
+                        () -> mAppSearchImpl.openReadBlob("package", "db1", handle));
+        assertThat(e.getResultCode()).isEqualTo(RESULT_NOT_FOUND);
+        assertThat(e.getMessage()).contains("Cannot find the blob for handle");
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testRemoveCommittedBlob() throws Exception {
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        ALWAYS_OPTIMIZE);
+        byte[] data = generateRandomBytes(20 * 1024); // 20 KiB
+        byte[] digest = calculateDigest(data);
+        AppSearchBlobHandle handle =
+                AppSearchBlobHandle.createWithSha256(digest, "package", "db1", "ns");
+        try (ParcelFileDescriptor writePfd =
+                        mAppSearchImpl.openWriteBlob("package", "db1", handle);
+                OutputStream outputStream =
+                        new ParcelFileDescriptor.AutoCloseOutputStream(writePfd)) {
+            outputStream.write(data);
+            outputStream.flush();
+        }
+
+        // Remove the blob
+        mAppSearchImpl.removeBlob("package", "db1", handle);
+
+        // Commit will get NOT_FOUND
+        AppSearchException e =
+                assertThrows(
+                        AppSearchException.class,
+                        () -> mAppSearchImpl.commitBlob("package", "db1", handle));
+        assertThat(e.getResultCode()).isEqualTo(RESULT_NOT_FOUND);
+        assertThat(e.getMessage()).contains("Cannot find the blob for handle");
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testRemoveAndReWriteBlob() throws Exception {
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        ALWAYS_OPTIMIZE);
+        byte[] data = generateRandomBytes(20 * 1024); // 20 KiB
+        byte[] wrongData = generateRandomBytes(10 * 1024); // 10 KiB
+        byte[] digest = calculateDigest(data);
+        AppSearchBlobHandle handle =
+                AppSearchBlobHandle.createWithSha256(digest, "package", "db1", "ns");
+        try (ParcelFileDescriptor writePfd =
+                        mAppSearchImpl.openWriteBlob("package", "db1", handle);
+                OutputStream outputStream =
+                        new ParcelFileDescriptor.AutoCloseOutputStream(writePfd)) {
+            // write wrong data
+            outputStream.write(wrongData);
+            outputStream.flush();
+        }
+
+        // Remove the blob
+        mAppSearchImpl.removeBlob("package", "db1", handle);
+
+        // reopen and rewrite
+        try (ParcelFileDescriptor writePfd =
+                        mAppSearchImpl.openWriteBlob("package", "db1", handle);
+                OutputStream outputStream =
+                        new ParcelFileDescriptor.AutoCloseOutputStream(writePfd)) {
+            outputStream.write(data);
+            outputStream.flush();
+        }
+
+        // commit the change and read the blob.
+        mAppSearchImpl.commitBlob("package", "db1", handle);
+        byte[] readBytes = new byte[20 * 1024];
+        try (ParcelFileDescriptor readPfd = mAppSearchImpl.openReadBlob("package", "db1", handle);
+                InputStream inputStream = new ParcelFileDescriptor.AutoCloseInputStream(readPfd)) {
+            inputStream.read(readBytes);
+        }
+        assertThat(readBytes).isEqualTo(data);
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testOpenReadForWrite_notAllowed() throws Exception {
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        ALWAYS_OPTIMIZE);
+        byte[] data = generateRandomBytes(20); // 20 Bytes
+        byte[] digest = calculateDigest(data);
+        AppSearchBlobHandle handle =
+                AppSearchBlobHandle.createWithSha256(digest, "package", "db1", "ns");
+        try (ParcelFileDescriptor writePfd =
+                        mAppSearchImpl.openWriteBlob("package", "db1", handle);
+                OutputStream outputStream =
+                        new ParcelFileDescriptor.AutoCloseOutputStream(writePfd)) {
+            outputStream.write(data);
+            outputStream.flush();
+        }
+
+        // commit the change and read the blob.
+        mAppSearchImpl.commitBlob("package", "db1", handle);
+
+        // Open output stream on read-only pfd.
+        assertThrows(
+                IOException.class,
+                () -> {
+                    try (ParcelFileDescriptor readPfd =
+                                    mAppSearchImpl.openReadBlob("package", "db1", handle);
+                            OutputStream outputStream =
+                                    new ParcelFileDescriptor.AutoCloseOutputStream(readPfd)) {
+                        outputStream.write(data);
+                    }
+                });
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testOpenWriteForRead_allowed() throws Exception {
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        ALWAYS_OPTIMIZE);
+        byte[] data = generateRandomBytes(20); // 20 Bytes
+        byte[] digest = calculateDigest(data);
+        AppSearchBlobHandle handle =
+                AppSearchBlobHandle.createWithSha256(digest, "package", "db1", "ns");
+        // openWriteBlob returns read and write fd.
+        try (ParcelFileDescriptor writePfd =
+                        mAppSearchImpl.openWriteBlob("package", "db1", handle);
+                InputStream inputStream = new ParcelFileDescriptor.AutoCloseInputStream(writePfd)) {
+            inputStream.read(new byte[10]);
+        }
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testOptimizeBlob() throws Exception {
+        // Create a new AppSearchImpl with lower orphan blob time to live.
+        mAppSearchImpl.close();
+        File tempFolder = mTemporaryFolder.newFolder();
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        tempFolder,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(),
+                                new LocalStorageIcingOptionsConfig() {
+                                    @Override
+                                    public long getOrphanBlobTimeToLiveMs() {
+                                        // 0 will make it non-expire
+                                        return 1L;
+                                    }
+                                }),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        ALWAYS_OPTIMIZE);
+
+        // Write the blob and commit it.
+        byte[] data = generateRandomBytes(20); // 20 Bytes
+        byte[] digest = calculateDigest(data);
+        AppSearchBlobHandle handle =
+                AppSearchBlobHandle.createWithSha256(digest, "package", "db1", "namespace");
+        ParcelFileDescriptor writePfd = mAppSearchImpl.openWriteBlob("package", "db1", handle);
+        try (OutputStream outputStream = new ParcelFileDescriptor.AutoCloseOutputStream(writePfd)) {
+            outputStream.write(data);
+            outputStream.flush();
+        }
+        writePfd.close();
+        mAppSearchImpl.commitBlob("package", "db1", handle);
+
+        mAppSearchImpl.persistToDisk(PersistType.Code.FULL);
+
+        // Optimize remove the expired orphan blob.
+        mAppSearchImpl.optimize(/* builder= */ null);
+        AppSearchException e =
+                assertThrows(
+                        AppSearchException.class,
+                        () -> {
+                            mAppSearchImpl.openReadBlob("package", "db1", handle);
+                        });
+        assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_NOT_FOUND);
+        assertThat(e.getMessage()).contains("Cannot find the blob for handle");
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testOptimizeBlobWithDocument() throws Exception {
+        // Create a new AppSearchImpl with lower orphan blob time to live.
+        mAppSearchImpl.close();
+        File tempFolder = mTemporaryFolder.newFolder();
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        tempFolder,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(),
+                                new LocalStorageIcingOptionsConfig() {
+                                    @Override
+                                    public long getOrphanBlobTimeToLiveMs() {
+                                        // 0 will make it non-expire
+                                        return 1L;
+                                    }
+                                }),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        ALWAYS_OPTIMIZE);
+
+        // Write the blob and commit it.
+        byte[] data = generateRandomBytes(20); // 20 Bytes
+        byte[] digest = calculateDigest(data);
+        AppSearchBlobHandle handle =
+                AppSearchBlobHandle.createWithSha256(digest, "package", "db1", "namespace");
+        ParcelFileDescriptor writePfd = mAppSearchImpl.openWriteBlob("package", "db1", handle);
+        try (OutputStream outputStream = new ParcelFileDescriptor.AutoCloseOutputStream(writePfd)) {
+            outputStream.write(data);
+            outputStream.flush();
+        }
+        writePfd.close();
+        mAppSearchImpl.commitBlob("package", "db1", handle);
+
+        // Put a document link that blob handle.
+        AppSearchSchema schema =
+                new AppSearchSchema.Builder("Type")
+                        .addProperty(
+                                new AppSearchSchema.BlobHandlePropertyConfig.Builder("blob")
+                                        .setCardinality(
+                                                AppSearchSchema.PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .build())
+                        .build();
         InternalSetSchemaResponse internalSetSchemaResponse =
                 mAppSearchImpl.setSchema(
                         "package",
-                        "database",
-                        schema,
+                        "db1",
+                        ImmutableList.of(schema),
                         /* visibilityConfigs= */ Collections.emptyList(),
-                        /* forceOverride= */ false,
+                        /* forceOverride= */ true,
                         /* version= */ 0,
                         /* setSchemaStatsBuilder= */ null);
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
-
-        // Insert package document
         GenericDocument document =
-                new GenericDocument.Builder<>("namespace", "id", "schema").build();
+                new GenericDocument.Builder<>("namespace", "id", "Type")
+                        .setPropertyBlobHandle("blob", handle)
+                        .build();
         mAppSearchImpl.putDocument(
                 "package",
-                "database",
+                "db1",
                 document,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
 
-        // Verify the document is indexed.
-        SearchSpec searchSpec =
-                new SearchSpec.Builder().setTermMatch(TermMatchType.Code.PREFIX_VALUE).build();
-        SearchResultPage searchResultPage =
-                mAppSearchImpl.query(
-                        "package",
-                        "database",
-                        /* queryExpression= */ "",
-                        searchSpec,
-                        /* logger= */ null);
-        assertThat(searchResultPage.getResults()).hasSize(1);
-        assertThat(searchResultPage.getResults().get(0).getGenericDocument()).isEqualTo(document);
+        mAppSearchImpl.persistToDisk(PersistType.Code.FULL);
 
-        // Remove the package
-        mAppSearchImpl.clearPackageData("package");
+        // Optimize won't remove the blob since it has reference document.
+        mAppSearchImpl.optimize(/* builder= */ null);
+        byte[] readBytes = new byte[20];
+        try (ParcelFileDescriptor readPfd = mAppSearchImpl.openReadBlob("package", "db1", handle);
+                InputStream inputStream = new ParcelFileDescriptor.AutoCloseInputStream(readPfd)) {
+            inputStream.read(readBytes);
+        }
+        assertThat(readBytes).isEqualTo(data);
 
-        // Verify the document is cleared.
-        searchResultPage =
-                mAppSearchImpl.query(
-                        "package2",
-                        "database2",
-                        /* queryExpression= */ "",
-                        searchSpec,
-                        /* logger= */ null);
-        assertThat(searchResultPage.getResults()).isEmpty();
+        mAppSearchImpl.remove("package", "db1", "namespace", "id", /* statsBuilder= */ null);
 
-        // Verify the schema is cleared.
-        assertThat(mAppSearchImpl.getSchemaProtoLocked().getTypesList())
-                .containsExactlyElementsIn(existingSchemas);
-        assertThat(mAppSearchImpl.getPackageToDatabases())
-                .containsExactlyEntriesIn(existingDatabases);
+        // The blob is orphan now and optimize will remove it.
+        mAppSearchImpl.optimize(/* builder= */ null);
+        AppSearchException e =
+                assertThrows(
+                        AppSearchException.class,
+                        () -> {
+                            mAppSearchImpl.openReadBlob("package", "db1", handle);
+                        });
+        assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_NOT_FOUND);
+        assertThat(e.getMessage()).contains("Cannot find the blob for handle");
     }
 
     @Test
-    public void testPrunePackageData() throws AppSearchException {
-        List<SchemaTypeConfigProto> existingSchemas =
-                mAppSearchImpl.getSchemaProtoLocked().getTypesList();
-        Map<String, Set<String>> existingDatabases = mAppSearchImpl.getPackageToDatabases();
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testRevokeFileDescriptor() throws Exception {
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        ALWAYS_OPTIMIZE);
+        byte[] data = generateRandomBytes(20 * 1024); // 20 KiB
+        byte[] digest = calculateDigest(data);
+        AppSearchBlobHandle handle =
+                AppSearchBlobHandle.createWithSha256(digest, "package", "db1", "ns");
+        try (ParcelFileDescriptor writePfd =
+                mAppSearchImpl.openWriteBlob("package", "db1", handle)) {
+            // Clear package data and all file descriptor to that package will be revoked.
+            mAppSearchImpl.clearPackageData("package");
+
+            assertThrows(
+                    IOException.class,
+                    () -> {
+                        try (OutputStream outputStream =
+                                new ParcelFileDescriptor.AutoCloseOutputStream(writePfd)) {
+                            outputStream.write(data);
+                        }
+                    });
+        }
 
-        Set<String> existingPackages = new ArraySet<>(existingSchemas.size());
-        for (int i = 0; i < existingSchemas.size(); i++) {
-            existingPackages.add(PrefixUtil.getPackageName(existingSchemas.get(i).getSchemaType()));
+        // reopen file descriptor could work.
+        try (ParcelFileDescriptor writePfd2 =
+                mAppSearchImpl.openWriteBlob("package", "db1", handle)) {
+            try (OutputStream outputStream =
+                    new ParcelFileDescriptor.AutoCloseOutputStream(writePfd2)) {
+                outputStream.write(data);
+            }
+            // close the AppSearchImpl will revoke all sent fds.
+            mAppSearchImpl.close();
+            assertThrows(
+                    IOException.class,
+                    () -> {
+                        try (OutputStream outputStream =
+                                new ParcelFileDescriptor.AutoCloseOutputStream(writePfd2)) {
+                            outputStream.write(data);
+                        }
+                    });
         }
+    }
 
-        // Create VisibilityConfig
-        InternalVisibilityConfig visibilityConfig =
-                new InternalVisibilityConfig.Builder("schema")
-                        .setNotDisplayedBySystem(true)
-                        .addVisibleToPackage(new PackageIdentifier("pkgBar", new byte[32]))
-                        .build();
+    // Verify the blob handle won't sent request to Icing. So no need to enable
+    // FLAG_ENABLE_BLOB_STORE.
+    @Test
+    public void testInvalidBlobHandle() throws Exception {
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        ALWAYS_OPTIMIZE);
+        byte[] data = generateRandomBytes(20 * 1024); // 20 KiB
+        byte[] digest = calculateDigest(data);
+        AppSearchBlobHandle handle =
+                AppSearchBlobHandle.createWithSha256(digest, "package", "db1", "ns");
 
-        // Insert schema for package A and B.
-        List<AppSearchSchema> schema =
-                ImmutableList.of(new AppSearchSchema.Builder("schema").build());
-        InternalSetSchemaResponse internalSetSchemaResponse =
-                mAppSearchImpl.setSchema(
-                        "packageA",
-                        "database",
-                        schema,
-                        /* visibilityConfigs= */ ImmutableList.of(visibilityConfig),
-                        /* forceOverride= */ false,
-                        /* version= */ 0,
-                        /* setSchemaStatsBuilder= */ null);
-        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
-        internalSetSchemaResponse =
-                mAppSearchImpl.setSchema(
-                        "packageB",
-                        "database",
-                        schema,
-                        /* visibilityConfigs= */ ImmutableList.of(visibilityConfig),
-                        /* forceOverride= */ false,
-                        /* version= */ 0,
-                        /* setSchemaStatsBuilder= */ null);
-        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+        AppSearchException e =
+                assertThrows(
+                        AppSearchException.class,
+                        () -> mAppSearchImpl.openWriteBlob("wrongPackageName", "db1", handle));
+        assertThat(e.getResultCode()).isEqualTo(RESULT_INVALID_ARGUMENT);
+        assertThat(e.getMessage())
+                .contains(
+                        "Blob package doesn't match calling package, "
+                                + "calling package: wrongPackageName, blob package: package");
 
-        // Verify these two packages are stored in AppSearch.
-        SchemaProto expectedProto =
-                SchemaProto.newBuilder()
-                        .addTypes(
-                                SchemaTypeConfigProto.newBuilder()
-                                        .setSchemaType("packageA$database/schema")
-                                        .setDescription("")
-                                        .setVersion(0))
-                        .addTypes(
-                                SchemaTypeConfigProto.newBuilder()
-                                        .setSchemaType("packageB$database/schema")
-                                        .setDescription("")
-                                        .setVersion(0))
+        e =
+                assertThrows(
+                        AppSearchException.class,
+                        () -> mAppSearchImpl.openWriteBlob("package", "wrongDb", handle));
+        assertThat(e.getResultCode()).isEqualTo(RESULT_INVALID_ARGUMENT);
+        assertThat(e.getMessage())
+                .contains(
+                        "Blob database doesn't match calling database, "
+                                + "calling database: wrongDb, blob database: db1");
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testSetBlobVisibility() throws Exception {
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        ALWAYS_OPTIMIZE);
+
+        SchemaVisibilityConfig visibleToConfig =
+                new SchemaVisibilityConfig.Builder()
+                        .addAllowedPackage(new PackageIdentifier("pkgBar", new byte[32]))
+                        .addRequiredPermissions(ImmutableSet.of(1, 2))
+                        .setPubliclyVisibleTargetPackage(
+                                new PackageIdentifier("pkgFoo", new byte[32]))
+                        .build();
+        InternalVisibilityConfig config =
+                new InternalVisibilityConfig.Builder("namespace")
+                        .setNotDisplayedBySystem(false)
+                        .addVisibleToConfig(visibleToConfig)
                         .build();
-        List<SchemaTypeConfigProto> expectedTypes = new ArrayList<>();
-        expectedTypes.addAll(existingSchemas);
-        expectedTypes.addAll(expectedProto.getTypesList());
-        assertThat(mAppSearchImpl.getSchemaProtoLocked().getTypesList())
-                .containsExactlyElementsIn(expectedTypes);
 
-        // Verify these two visibility documents are stored in AppSearch.
-        InternalVisibilityConfig expectedVisibilityConfigA =
-                new InternalVisibilityConfig.Builder("packageA$database/schema")
-                        .setNotDisplayedBySystem(true)
-                        .addVisibleToPackage(new PackageIdentifier("pkgBar", new byte[32]))
+        String prefix = PrefixUtil.createPrefix("package", "db1");
+        mAppSearchImpl.setBlobNamespaceVisibility("package", "db1", ImmutableList.of(config));
+
+        // Expect the config will be added prefix.
+        InternalVisibilityConfig expectedConfig =
+                new InternalVisibilityConfig.Builder(prefix + "namespace")
+                        .setNotDisplayedBySystem(false)
+                        .addVisibleToConfig(visibleToConfig)
                         .build();
-        InternalVisibilityConfig expectedVisibilityConfigB =
-                new InternalVisibilityConfig.Builder("packageB$database/schema")
-                        .setNotDisplayedBySystem(true)
-                        .addVisibleToPackage(new PackageIdentifier("pkgBar", new byte[32]))
+        assertThat(mAppSearchImpl.mBlobVisibilityStoreLocked.getVisibility(prefix + "namespace"))
+                .isEqualTo(expectedConfig);
+
+        // Verify the InternalVisibilityConfig is saved to AppSearchImpl.
+        GenericDocument visibilityDocument =
+                mAppSearchImpl.getDocument(
+                        VISIBILITY_PACKAGE_NAME,
+                        BLOB_VISIBILITY_DATABASE_NAME,
+                        VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
+                        /* id= */ prefix + "namespace",
+                        /* typePropertyPaths= */ Collections.emptyMap());
+        GenericDocument overLayVisibilityDocument =
+                mAppSearchImpl.getDocument(
+                        VISIBILITY_PACKAGE_NAME,
+                        BLOB_ANDROID_V_OVERLAY_DATABASE_NAME,
+                        VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE,
+                        /* id= */ prefix + "namespace",
+                        /* typePropertyPaths= */ Collections.emptyMap());
+
+        InternalVisibilityConfig outputConfig =
+                VisibilityToDocumentConverter.createInternalVisibilityConfig(
+                        visibilityDocument, overLayVisibilityDocument);
+
+        assertThat(outputConfig).isEqualTo(expectedConfig);
+    }
+
+    @Test
+    @RequiresFlagsDisabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testSetBlobVisibility_notSupported() throws Exception {
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        ALWAYS_OPTIMIZE);
+
+        SchemaVisibilityConfig visibleToConfig =
+                new SchemaVisibilityConfig.Builder()
+                        .addAllowedPackage(new PackageIdentifier("pkgBar", new byte[32]))
+                        .addRequiredPermissions(ImmutableSet.of(1, 2))
+                        .setPubliclyVisibleTargetPackage(
+                                new PackageIdentifier("pkgFoo", new byte[32]))
                         .build();
-        assertThat(mAppSearchImpl.mVisibilityStoreLocked.getVisibility("packageA$database/schema"))
-                .isEqualTo(expectedVisibilityConfigA);
-        assertThat(mAppSearchImpl.mVisibilityStoreLocked.getVisibility("packageB$database/schema"))
-                .isEqualTo(expectedVisibilityConfigB);
+        InternalVisibilityConfig config =
+                new InternalVisibilityConfig.Builder("namespace")
+                        .setNotDisplayedBySystem(false)
+                        .addVisibleToConfig(visibleToConfig)
+                        .build();
+
+        UnsupportedOperationException exception =
+                assertThrows(
+                        UnsupportedOperationException.class,
+                        () ->
+                                mAppSearchImpl.setBlobNamespaceVisibility(
+                                        "package", "db1", ImmutableList.of(config)));
+        assertThat(exception)
+                .hasMessageThat()
+                .contains(
+                        Features.BLOB_STORAGE
+                                + " is not available on this AppSearch implementation.");
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testRemoveBlobVisibility() throws Exception {
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        ALWAYS_OPTIMIZE);
+
+        SchemaVisibilityConfig visibleToConfig1 =
+                new SchemaVisibilityConfig.Builder()
+                        .addAllowedPackage(new PackageIdentifier("pkgBar1", new byte[32]))
+                        .addRequiredPermissions(ImmutableSet.of(1, 2))
+                        .setPubliclyVisibleTargetPackage(
+                                new PackageIdentifier("pkgFoo1", new byte[32]))
+                        .build();
+        InternalVisibilityConfig config1 =
+                new InternalVisibilityConfig.Builder("namespace1")
+                        .setNotDisplayedBySystem(false)
+                        .addVisibleToConfig(visibleToConfig1)
+                        .build();
+        SchemaVisibilityConfig visibleToConfig2 =
+                new SchemaVisibilityConfig.Builder()
+                        .addAllowedPackage(new PackageIdentifier("pkgBar2", new byte[32]))
+                        .addRequiredPermissions(ImmutableSet.of(3, 4))
+                        .setPubliclyVisibleTargetPackage(
+                                new PackageIdentifier("pkgFoo2", new byte[32]))
+                        .build();
+        InternalVisibilityConfig config2 =
+                new InternalVisibilityConfig.Builder("namespace2")
+                        .setNotDisplayedBySystem(false)
+                        .addVisibleToConfig(visibleToConfig2)
+                        .build();
+
+        String prefix = PrefixUtil.createPrefix("package", "db1");
+        mAppSearchImpl.setBlobNamespaceVisibility(
+                "package", "db1", ImmutableList.of(config1, config2));
+
+        // Expect the config will be added prefix.
+        InternalVisibilityConfig expectedConfig1 =
+                new InternalVisibilityConfig.Builder(prefix + "namespace1")
+                        .setNotDisplayedBySystem(false)
+                        .addVisibleToConfig(visibleToConfig1)
+                        .build();
+        assertThat(mAppSearchImpl.mBlobVisibilityStoreLocked.getVisibility(prefix + "namespace1"))
+                .isEqualTo(expectedConfig1);
+
+        InternalVisibilityConfig expectedConfig2 =
+                new InternalVisibilityConfig.Builder(prefix + "namespace2")
+                        .setNotDisplayedBySystem(false)
+                        .addVisibleToConfig(visibleToConfig2)
+                        .build();
+        assertThat(mAppSearchImpl.mBlobVisibilityStoreLocked.getVisibility(prefix + "namespace2"))
+                .isEqualTo(expectedConfig2);
+
+        // Verify the InternalVisibilityConfig is saved to AppSearchImpl.
+        GenericDocument visibilityDocument1 =
+                mAppSearchImpl.getDocument(
+                        VISIBILITY_PACKAGE_NAME,
+                        BLOB_VISIBILITY_DATABASE_NAME,
+                        VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
+                        /* id= */ prefix + "namespace1",
+                        /* typePropertyPaths= */ Collections.emptyMap());
+        GenericDocument overLayVisibilityDocument1 =
+                mAppSearchImpl.getDocument(
+                        VISIBILITY_PACKAGE_NAME,
+                        BLOB_ANDROID_V_OVERLAY_DATABASE_NAME,
+                        VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE,
+                        /* id= */ prefix + "namespace1",
+                        /* typePropertyPaths= */ Collections.emptyMap());
+        InternalVisibilityConfig outputConfig1 =
+                VisibilityToDocumentConverter.createInternalVisibilityConfig(
+                        visibilityDocument1, overLayVisibilityDocument1);
+        assertThat(outputConfig1).isEqualTo(expectedConfig1);
+
+        GenericDocument visibilityDocument2 =
+                mAppSearchImpl.getDocument(
+                        VISIBILITY_PACKAGE_NAME,
+                        BLOB_VISIBILITY_DATABASE_NAME,
+                        VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
+                        /* id= */ prefix + "namespace2",
+                        /* typePropertyPaths= */ Collections.emptyMap());
+        GenericDocument overLayVisibilityDocument2 =
+                mAppSearchImpl.getDocument(
+                        VISIBILITY_PACKAGE_NAME,
+                        BLOB_ANDROID_V_OVERLAY_DATABASE_NAME,
+                        VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE,
+                        /* id= */ prefix + "namespace2",
+                        /* typePropertyPaths= */ Collections.emptyMap());
+        InternalVisibilityConfig outputConfig2 =
+                VisibilityToDocumentConverter.createInternalVisibilityConfig(
+                        visibilityDocument2, overLayVisibilityDocument2);
+        assertThat(outputConfig2).isEqualTo(expectedConfig2);
+
+        // remove config1 by only set config2 to db
+        mAppSearchImpl.setBlobNamespaceVisibility(
+                "package", "db1", /* visibilityConfigs= */ ImmutableList.of(config2));
+
+        // Check config 1 is removed from VisibilityStore
+        assertThat(mAppSearchImpl.mBlobVisibilityStoreLocked.getVisibility(prefix + "namespace1"))
+                .isNull();
+        AppSearchException e =
+                assertThrows(
+                        AppSearchException.class,
+                        () ->
+                                mAppSearchImpl.getDocument(
+                                        VISIBILITY_PACKAGE_NAME,
+                                        BLOB_VISIBILITY_DATABASE_NAME,
+                                        VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
+                                        /* id= */ prefix + "namespace1",
+                                        /* typePropertyPaths= */ Collections.emptyMap()));
+        assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_NOT_FOUND);
+        assertThat(e.getMessage())
+                .isEqualTo("Document (VS#Pkg$VSBlob#Db/, package$db1/namespace1) not found.");
+        e =
+                assertThrows(
+                        AppSearchException.class,
+                        () ->
+                                mAppSearchImpl.getDocument(
+                                        VISIBILITY_PACKAGE_NAME,
+                                        BLOB_ANDROID_V_OVERLAY_DATABASE_NAME,
+                                        VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE,
+                                        /* id= */ prefix + "namespace1",
+                                        /* typePropertyPaths= */ Collections.emptyMap()));
+        assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_NOT_FOUND);
+        assertThat(e.getMessage())
+                .isEqualTo(
+                        "Document (VS#Pkg$VSBlob#AndroidVDb/androidVOverlay, "
+                                + "package$db1/namespace1) not found.");
+
+        // Config2 remains.
+        assertThat(mAppSearchImpl.mBlobVisibilityStoreLocked.getVisibility(prefix + "namespace2"))
+                .isEqualTo(expectedConfig2);
+        visibilityDocument2 =
+                mAppSearchImpl.getDocument(
+                        VISIBILITY_PACKAGE_NAME,
+                        BLOB_VISIBILITY_DATABASE_NAME,
+                        VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
+                        /* id= */ prefix + "namespace2",
+                        /* typePropertyPaths= */ Collections.emptyMap());
+        overLayVisibilityDocument2 =
+                mAppSearchImpl.getDocument(
+                        VISIBILITY_PACKAGE_NAME,
+                        BLOB_ANDROID_V_OVERLAY_DATABASE_NAME,
+                        VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE,
+                        /* id= */ prefix + "namespace2",
+                        /* typePropertyPaths= */ Collections.emptyMap());
+        outputConfig2 =
+                VisibilityToDocumentConverter.createInternalVisibilityConfig(
+                        visibilityDocument2, overLayVisibilityDocument2);
+
+        assertThat(outputConfig2).isEqualTo(expectedConfig2);
+    }
+
+    @Test
+    @RequiresFlagsDisabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testGlobalReadBlob_notSupported() throws Exception {
+        String visiblePrefix = PrefixUtil.createPrefix("package", "db1");
+        VisibilityChecker mockVisibilityChecker =
+                createMockVisibilityChecker(ImmutableSet.of(visiblePrefix + "visibleNamespace"));
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        mockVisibilityChecker,
+                        /* revocableFileDescriptorStore= */ null,
+                        ALWAYS_OPTIMIZE);
+
+        byte[] data = generateRandomBytes(20 * 1024); // 20 KiB
+        byte[] digest = calculateDigest(data);
+        AppSearchBlobHandle handle =
+                AppSearchBlobHandle.createWithSha256(digest, "package", "db1", "ns");
+        // nonVisibleHandle is not visible to the caller.
+        UnsupportedOperationException exception =
+                assertThrows(
+                        UnsupportedOperationException.class,
+                        () -> mAppSearchImpl.globalOpenReadBlob(handle, mSelfCallerAccess));
+        assertThat(exception)
+                .hasMessageThat()
+                .contains(
+                        Features.BLOB_STORAGE
+                                + " is not available on this AppSearch implementation.");
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testGlobalReadBlob() throws Exception {
+        String visiblePrefix = PrefixUtil.createPrefix("package", "db1");
+        VisibilityChecker mockVisibilityChecker =
+                createMockVisibilityChecker(ImmutableSet.of(visiblePrefix + "visibleNamespace"));
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        mockVisibilityChecker,
+                        new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        ALWAYS_OPTIMIZE);
+
+        // Set mock visibility setting.
+        InternalVisibilityConfig config =
+                new InternalVisibilityConfig.Builder("visibleNamespace").build();
+        mAppSearchImpl.setBlobNamespaceVisibility("package", "db1", ImmutableList.of(config));
+
+        byte[] data = generateRandomBytes(20 * 1024); // 20 KiB
+        byte[] digest = calculateDigest(data);
+        AppSearchBlobHandle visibleHandle =
+                AppSearchBlobHandle.createWithSha256(digest, "package", "db1", "visibleNamespace");
+        try (ParcelFileDescriptor writePfd =
+                        mAppSearchImpl.openWriteBlob("package", "db1", visibleHandle);
+                OutputStream outputStream =
+                        new ParcelFileDescriptor.AutoCloseOutputStream(writePfd)) {
+            outputStream.write(data);
+            outputStream.flush();
+        }
+        mAppSearchImpl.commitBlob("package", "db1", visibleHandle);
+
+        AppSearchBlobHandle nonVisibleHandle =
+                AppSearchBlobHandle.createWithSha256(
+                        digest, "package", "db1", "nonVisibleNamespace");
+        try (ParcelFileDescriptor writePfd =
+                        mAppSearchImpl.openWriteBlob("package", "db1", nonVisibleHandle);
+                OutputStream outputStream =
+                        new ParcelFileDescriptor.AutoCloseOutputStream(writePfd)) {
+            outputStream.write(data);
+            outputStream.flush();
+        }
+        mAppSearchImpl.commitBlob("package", "db1", nonVisibleHandle);
+
+        // visibleHandle is visible to the caller.
+        byte[] readBytes = new byte[20 * 1024];
+        try (ParcelFileDescriptor readPfd =
+                        mAppSearchImpl.globalOpenReadBlob(visibleHandle, mSelfCallerAccess);
+                InputStream inputStream = new ParcelFileDescriptor.AutoCloseInputStream(readPfd)) {
+            inputStream.read(readBytes);
+        }
+        assertThat(readBytes).isEqualTo(data);
+
+        // nonVisibleHandle is not visible to the caller.
+        AppSearchException e =
+                assertThrows(
+                        AppSearchException.class,
+                        () ->
+                                mAppSearchImpl.globalOpenReadBlob(
+                                        nonVisibleHandle, mSelfCallerAccess));
+        assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_NOT_FOUND);
+        assertThat(e.getMessage()).contains("Cannot find the blob for handle");
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testGlobalReadBlob_sameErrorMessage() throws Exception {
+        String visiblePrefix = PrefixUtil.createPrefix("package", "db1");
+        VisibilityChecker mockVisibilityChecker =
+                createMockVisibilityChecker(ImmutableSet.of(visiblePrefix + "visibleNamespace"));
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        mockVisibilityChecker,
+                        new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        ALWAYS_OPTIMIZE);
+
+        // Set mock visibility setting.
+        InternalVisibilityConfig config =
+                new InternalVisibilityConfig.Builder("visibleNamespace").build();
+        mAppSearchImpl.setBlobNamespaceVisibility("package", "db1", ImmutableList.of(config));
+
+        byte[] data = generateRandomBytes(20 * 1024); // 20 KiB
+        byte[] digest = calculateDigest(data);
+        AppSearchBlobHandle visibleHandle =
+                AppSearchBlobHandle.createWithSha256(digest, "package", "db1", "visibleNamespace");
+        try (ParcelFileDescriptor writePfd =
+                        mAppSearchImpl.openWriteBlob("package", "db1", visibleHandle);
+                OutputStream outputStream =
+                        new ParcelFileDescriptor.AutoCloseOutputStream(writePfd)) {
+            outputStream.write(data);
+            outputStream.flush();
+        }
+        mAppSearchImpl.commitBlob("package", "db1", visibleHandle);
+
+        AppSearchBlobHandle nonVisibleHandle =
+                AppSearchBlobHandle.createWithSha256(
+                        digest, "package", "db1", "nonVisibleNamespace");
+        try (ParcelFileDescriptor writePfd =
+                        mAppSearchImpl.openWriteBlob("package", "db1", nonVisibleHandle);
+                OutputStream outputStream =
+                        new ParcelFileDescriptor.AutoCloseOutputStream(writePfd)) {
+            outputStream.write(data);
+            outputStream.flush();
+        }
+        mAppSearchImpl.commitBlob("package", "db1", nonVisibleHandle);
+
+        // visibleHandle is visible to the caller.
+        byte[] readBytes = new byte[20 * 1024];
+        try (ParcelFileDescriptor readPfd =
+                        mAppSearchImpl.globalOpenReadBlob(visibleHandle, mSelfCallerAccess);
+                InputStream inputStream = new ParcelFileDescriptor.AutoCloseInputStream(readPfd)) {
+            inputStream.read(readBytes);
+        }
+        assertThat(readBytes).isEqualTo(data);
+
+        // nonVisibleHandle is not visible to the caller.
+        AppSearchException exception1 =
+                assertThrows(
+                        AppSearchException.class,
+                        () ->
+                                mAppSearchImpl.globalOpenReadBlob(
+                                        nonVisibleHandle, mSelfCallerAccess));
+        assertThat(exception1.getResultCode()).isEqualTo(AppSearchResult.RESULT_NOT_FOUND);
+        assertThat(exception1.getMessage()).contains("Cannot find the blob for handle:");
+        assertThat(exception1.getCause()).isNull();
+
+        // Remove visibleHandle and verify the error code and message should be same between not
+        // found and inaccessible.
+        mAppSearchImpl.removeBlob("package", "db1", visibleHandle);
+        AppSearchException exception2 =
+                assertThrows(
+                        AppSearchException.class,
+                        () -> mAppSearchImpl.globalOpenReadBlob(visibleHandle, mSelfCallerAccess));
+        assertThat(exception2.getCause()).isNull();
+        assertThat(exception2.getResultCode()).isEqualTo(exception1.getResultCode());
+        assertThat(exception2.getMessage()).isEqualTo(exception1.getMessage());
+    }
+
+    @Test
+    public void testClearPackageData() throws Exception {
+        List<SchemaTypeConfigProto> existingSchemas =
+                mAppSearchImpl.getSchemaProtoLocked().getTypesList();
+        Map<String, Set<String>> existingDatabases = mAppSearchImpl.getPackageToDatabases();
+
+        // Insert package schema
+        List<AppSearchSchema> schema =
+                ImmutableList.of(new AppSearchSchema.Builder("schema").build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package",
+                        "database",
+                        schema,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+
+        // Insert package document
+        GenericDocument document =
+                new GenericDocument.Builder<>("namespace", "id", "schema").build();
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
+                document,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+
+        // Verify the document is indexed.
+        SearchSpec searchSpec =
+                new SearchSpec.Builder().setTermMatch(TermMatchType.Code.PREFIX_VALUE).build();
+        SearchResultPage searchResultPage =
+                mAppSearchImpl.query(
+                        "package",
+                        "database",
+                        /* queryExpression= */ "",
+                        searchSpec,
+                        /* logger= */ null);
+        assertThat(searchResultPage.getResults()).hasSize(1);
+        assertThat(searchResultPage.getResults().get(0).getGenericDocument()).isEqualTo(document);
+
+        // Remove the package
+        mAppSearchImpl.clearPackageData("package");
+
+        // Verify the document is cleared.
+        searchResultPage =
+                mAppSearchImpl.query(
+                        "package2",
+                        "database2",
+                        /* queryExpression= */ "",
+                        searchSpec,
+                        /* logger= */ null);
+        assertThat(searchResultPage.getResults()).isEmpty();
+
+        // Verify the schema is cleared.
+        assertThat(mAppSearchImpl.getSchemaProtoLocked().getTypesList())
+                .containsExactlyElementsIn(existingSchemas);
+        assertThat(mAppSearchImpl.getPackageToDatabases())
+                .containsExactlyEntriesIn(existingDatabases);
+    }
+
+    @Test
+    public void testPrunePackageData() throws AppSearchException {
+        List<SchemaTypeConfigProto> existingSchemas =
+                mAppSearchImpl.getSchemaProtoLocked().getTypesList();
+        Map<String, Set<String>> existingDatabases = mAppSearchImpl.getPackageToDatabases();
+
+        Set<String> existingPackages = new ArraySet<>(existingSchemas.size());
+        for (int i = 0; i < existingSchemas.size(); i++) {
+            existingPackages.add(PrefixUtil.getPackageName(existingSchemas.get(i).getSchemaType()));
+        }
+
+        // Create VisibilityConfig
+        InternalVisibilityConfig visibilityConfig =
+                new InternalVisibilityConfig.Builder("schema")
+                        .setNotDisplayedBySystem(true)
+                        .addVisibleToPackage(new PackageIdentifier("pkgBar", new byte[32]))
+                        .build();
+
+        // Insert schema for package A and B.
+        List<AppSearchSchema> schema =
+                ImmutableList.of(new AppSearchSchema.Builder("schema").build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "packageA",
+                        "database",
+                        schema,
+                        /* visibilityConfigs= */ ImmutableList.of(visibilityConfig),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+        internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "packageB",
+                        "database",
+                        schema,
+                        /* visibilityConfigs= */ ImmutableList.of(visibilityConfig),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+
+        // Verify these two packages are stored in AppSearch.
+        SchemaProto expectedProto =
+                SchemaProto.newBuilder()
+                        .addTypes(
+                                SchemaTypeConfigProto.newBuilder()
+                                        .setSchemaType("packageA$database/schema")
+                                        .setDescription("")
+                                        .setVersion(0))
+                        .addTypes(
+                                SchemaTypeConfigProto.newBuilder()
+                                        .setSchemaType("packageB$database/schema")
+                                        .setDescription("")
+                                        .setVersion(0))
+                        .build();
+        List<SchemaTypeConfigProto> expectedTypes = new ArrayList<>();
+        expectedTypes.addAll(existingSchemas);
+        expectedTypes.addAll(expectedProto.getTypesList());
+        assertThat(mAppSearchImpl.getSchemaProtoLocked().getTypesList())
+                .containsExactlyElementsIn(expectedTypes);
+
+        // Verify these two visibility documents are stored in AppSearch.
+        InternalVisibilityConfig expectedVisibilityConfigA =
+                new InternalVisibilityConfig.Builder("packageA$database/schema")
+                        .setNotDisplayedBySystem(true)
+                        .addVisibleToPackage(new PackageIdentifier("pkgBar", new byte[32]))
+                        .build();
+        InternalVisibilityConfig expectedVisibilityConfigB =
+                new InternalVisibilityConfig.Builder("packageB$database/schema")
+                        .setNotDisplayedBySystem(true)
+                        .addVisibleToPackage(new PackageIdentifier("pkgBar", new byte[32]))
+                        .build();
+        assertThat(
+                        mAppSearchImpl.mDocumentVisibilityStoreLocked.getVisibility(
+                                "packageA$database/schema"))
+                .isEqualTo(expectedVisibilityConfigA);
+        assertThat(
+                        mAppSearchImpl.mDocumentVisibilityStoreLocked.getVisibility(
+                                "packageB$database/schema"))
+                .isEqualTo(expectedVisibilityConfigB);
+
+        // Prune packages
+        mAppSearchImpl.prunePackageData(existingPackages);
+
+        // Verify the schema is same as beginning.
+        assertThat(mAppSearchImpl.getSchemaProtoLocked().getTypesList())
+                .containsExactlyElementsIn(existingSchemas);
+        assertThat(mAppSearchImpl.getPackageToDatabases())
+                .containsExactlyEntriesIn(existingDatabases);
+
+        // Verify the VisibilitySetting is removed.
+        assertThat(
+                        mAppSearchImpl.mDocumentVisibilityStoreLocked.getVisibility(
+                                "packageA$database/schema"))
+                .isNull();
+        assertThat(
+                        mAppSearchImpl.mDocumentVisibilityStoreLocked.getVisibility(
+                                "packageB$database/schema"))
+                .isNull();
+    }
+
+    @Test
+    public void testGetPackageToDatabases() throws Exception {
+        Map<String, Set<String>> existingMapping = mAppSearchImpl.getPackageToDatabases();
+        Map<String, Set<String>> expectedMapping = new ArrayMap<>();
+        expectedMapping.putAll(existingMapping);
+
+        // Has database1
+        expectedMapping.put("package1", ImmutableSet.of("database1"));
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package1",
+                        "database1",
+                        Collections.singletonList(new AppSearchSchema.Builder("schema").build()),
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+        assertThat(mAppSearchImpl.getPackageToDatabases())
+                .containsExactlyEntriesIn(expectedMapping);
+
+        // Has both databases
+        expectedMapping.put("package1", ImmutableSet.of("database1", "database2"));
+        internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package1",
+                        "database2",
+                        Collections.singletonList(new AppSearchSchema.Builder("schema").build()),
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+        assertThat(mAppSearchImpl.getPackageToDatabases())
+                .containsExactlyEntriesIn(expectedMapping);
+
+        // Has both packages
+        expectedMapping.put("package2", ImmutableSet.of("database1"));
+        internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package2",
+                        "database1",
+                        Collections.singletonList(new AppSearchSchema.Builder("schema").build()),
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+        assertThat(mAppSearchImpl.getPackageToDatabases())
+                .containsExactlyEntriesIn(expectedMapping);
+    }
+
+    @Test
+    @RequiresFlagsDisabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testGetAllPrefixedSchemaTypes() throws Exception {
+        // Insert schema
+        List<AppSearchSchema> schemas1 =
+                Collections.singletonList(new AppSearchSchema.Builder("type1").build());
+        List<AppSearchSchema> schemas2 =
+                Collections.singletonList(new AppSearchSchema.Builder("type2").build());
+        List<AppSearchSchema> schemas3 =
+                Collections.singletonList(new AppSearchSchema.Builder("type3").build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package1",
+                        "database1",
+                        schemas1,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+        internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package1",
+                        "database2",
+                        schemas2,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+        internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package2",
+                        "database1",
+                        schemas3,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+        assertThat(mAppSearchImpl.getAllPrefixedSchemaTypes())
+                .containsExactly(
+                        "package1$database1/type1",
+                        "package1$database2/type2",
+                        "package2$database1/type3",
+                        "VS#Pkg$VS#Db/VisibilityType", // plus the stored Visibility schema
+                        "VS#Pkg$VS#Db/VisibilityPermissionType",
+                        "VS#Pkg$VS#AndroidVDb/AndroidVOverlayType");
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testGetAllPrefixedSchemaTypes_enableBlobStore() throws Exception {
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        ALWAYS_OPTIMIZE);
+        // Insert schema
+        List<AppSearchSchema> schemas1 =
+                Collections.singletonList(new AppSearchSchema.Builder("type1").build());
+        List<AppSearchSchema> schemas2 =
+                Collections.singletonList(new AppSearchSchema.Builder("type2").build());
+        List<AppSearchSchema> schemas3 =
+                Collections.singletonList(new AppSearchSchema.Builder("type3").build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package1",
+                        "database1",
+                        schemas1,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+        internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package1",
+                        "database2",
+                        schemas2,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+        internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package2",
+                        "database1",
+                        schemas3,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+        assertThat(mAppSearchImpl.getAllPrefixedSchemaTypes())
+                .containsExactly(
+                        "package1$database1/type1",
+                        "package1$database2/type2",
+                        "package2$database1/type3",
+                        "VS#Pkg$VS#Db/VisibilityType", // plus the stored Visibility schema
+                        "VS#Pkg$VS#Db/VisibilityPermissionType",
+                        "VS#Pkg$VS#AndroidVDb/AndroidVOverlayType",
+                        "VS#Pkg$VSBlob#Db/VisibilityType",
+                        "VS#Pkg$VSBlob#Db/VisibilityPermissionType",
+                        "VS#Pkg$VSBlob#AndroidVDb/AndroidVOverlayType");
+    }
+
+    @FlakyTest(bugId = 204186664)
+    @Test
+    public void testReportUsage() throws Exception {
+        // Insert schema
+        List<AppSearchSchema> schemas =
+                Collections.singletonList(new AppSearchSchema.Builder("type").build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package",
+                        "database",
+                        schemas,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+
+        // Insert two docs
+        GenericDocument document1 =
+                new GenericDocument.Builder<>("namespace", "id1", "type").build();
+        GenericDocument document2 =
+                new GenericDocument.Builder<>("namespace", "id2", "type").build();
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
+                document1,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
+                document2,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+
+        // Report some usages. id1 has 2 app and 1 system usage, id2 has 1 app and 2 system usage.
+        mAppSearchImpl.reportUsage(
+                "package",
+                "database",
+                "namespace",
+                "id1",
+                /* usageTimestampMillis= */ 10,
+                /* systemUsage= */ false);
+        mAppSearchImpl.reportUsage(
+                "package",
+                "database",
+                "namespace",
+                "id1",
+                /* usageTimestampMillis= */ 20,
+                /* systemUsage= */ false);
+        mAppSearchImpl.reportUsage(
+                "package",
+                "database",
+                "namespace",
+                "id1",
+                /* usageTimestampMillis= */ 1000,
+                /* systemUsage= */ true);
+
+        mAppSearchImpl.reportUsage(
+                "package",
+                "database",
+                "namespace",
+                "id2",
+                /* usageTimestampMillis= */ 100,
+                /* systemUsage= */ false);
+        mAppSearchImpl.reportUsage(
+                "package",
+                "database",
+                "namespace",
+                "id2",
+                /* usageTimestampMillis= */ 200,
+                /* systemUsage= */ true);
+        mAppSearchImpl.reportUsage(
+                "package",
+                "database",
+                "namespace",
+                "id2",
+                /* usageTimestampMillis= */ 150,
+                /* systemUsage= */ true);
+
+        // Sort by app usage count: id1 should win
+        List<SearchResult> page =
+                mAppSearchImpl
+                        .query(
+                                "package",
+                                "database",
+                                "",
+                                new SearchSpec.Builder()
+                                        .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
+                                        .setRankingStrategy(SearchSpec.RANKING_STRATEGY_USAGE_COUNT)
+                                        .build(),
+                                /* logger= */ null)
+                        .getResults();
+        assertThat(page).hasSize(2);
+        assertThat(page.get(0).getGenericDocument().getId()).isEqualTo("id1");
+        assertThat(page.get(1).getGenericDocument().getId()).isEqualTo("id2");
+
+        // Sort by app usage timestamp: id2 should win
+        page =
+                mAppSearchImpl
+                        .query(
+                                "package",
+                                "database",
+                                "",
+                                new SearchSpec.Builder()
+                                        .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
+                                        .setRankingStrategy(
+                                                SearchSpec
+                                                        .RANKING_STRATEGY_USAGE_LAST_USED_TIMESTAMP)
+                                        .build(),
+                                /* logger= */ null)
+                        .getResults();
+        assertThat(page).hasSize(2);
+        assertThat(page.get(0).getGenericDocument().getId()).isEqualTo("id2");
+        assertThat(page.get(1).getGenericDocument().getId()).isEqualTo("id1");
+
+        // Sort by system usage count: id2 should win
+        page =
+                mAppSearchImpl
+                        .query(
+                                "package",
+                                "database",
+                                "",
+                                new SearchSpec.Builder()
+                                        .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
+                                        .setRankingStrategy(
+                                                SearchSpec.RANKING_STRATEGY_SYSTEM_USAGE_COUNT)
+                                        .build(),
+                                /* logger= */ null)
+                        .getResults();
+        assertThat(page).hasSize(2);
+        assertThat(page.get(0).getGenericDocument().getId()).isEqualTo("id2");
+        assertThat(page.get(1).getGenericDocument().getId()).isEqualTo("id1");
+
+        // Sort by system usage timestamp: id1 should win
+        page =
+                mAppSearchImpl
+                        .query(
+                                "package",
+                                "database",
+                                "",
+                                new SearchSpec.Builder()
+                                        .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
+                                        .setRankingStrategy(
+                                                SearchSpec
+                                                        .RANKING_STRATEGY_SYSTEM_USAGE_LAST_USED_TIMESTAMP)
+                                        .build(),
+                                /* logger= */ null)
+                        .getResults();
+        assertThat(page).hasSize(2);
+        assertThat(page.get(0).getGenericDocument().getId()).isEqualTo("id1");
+        assertThat(page.get(1).getGenericDocument().getId()).isEqualTo("id2");
+    }
 
-        // Prune packages
-        mAppSearchImpl.prunePackageData(existingPackages);
+    @Test
+    public void testGetStorageInfoForPackage_nonexistentPackage() throws Exception {
+        // "package2" doesn't exist yet, so it shouldn't have any storage size
+        StorageInfo storageInfo = mAppSearchImpl.getStorageInfoForPackage("nonexistent.package");
+        assertThat(storageInfo.getSizeBytes()).isEqualTo(0);
+        assertThat(storageInfo.getAliveDocumentsCount()).isEqualTo(0);
+        assertThat(storageInfo.getAliveNamespacesCount()).isEqualTo(0);
+    }
 
-        // Verify the schema is same as beginning.
-        assertThat(mAppSearchImpl.getSchemaProtoLocked().getTypesList())
-                .containsExactlyElementsIn(existingSchemas);
-        assertThat(mAppSearchImpl.getPackageToDatabases())
-                .containsExactlyEntriesIn(existingDatabases);
+    @Test
+    public void testGetStorageInfoForPackage_withoutDocument() throws Exception {
+        // Insert schema for "package1"
+        List<AppSearchSchema> schemas =
+                Collections.singletonList(new AppSearchSchema.Builder("type").build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package1",
+                        "database",
+                        schemas,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
 
-        // Verify the VisibilitySetting is removed.
-        assertThat(mAppSearchImpl.mVisibilityStoreLocked.getVisibility("packageA$database/schema"))
-                .isNull();
-        assertThat(mAppSearchImpl.mVisibilityStoreLocked.getVisibility("packageB$database/schema"))
-                .isNull();
+        // Since "package1" doesn't have a document, it get any space attributed to it.
+        StorageInfo storageInfo = mAppSearchImpl.getStorageInfoForPackage("package1");
+        assertThat(storageInfo.getSizeBytes()).isEqualTo(0);
+        assertThat(storageInfo.getAliveDocumentsCount()).isEqualTo(0);
+        assertThat(storageInfo.getAliveNamespacesCount()).isEqualTo(0);
     }
 
     @Test
-    public void testGetPackageToDatabases() throws Exception {
-        Map<String, Set<String>> existingMapping = mAppSearchImpl.getPackageToDatabases();
-        Map<String, Set<String>> expectedMapping = new ArrayMap<>();
-        expectedMapping.putAll(existingMapping);
+    public void testGetStorageInfoForPackage_proportionalToDocuments() throws Exception {
+        List<AppSearchSchema> schemas =
+                Collections.singletonList(new AppSearchSchema.Builder("type").build());
 
-        // Has database1
-        expectedMapping.put("package1", ImmutableSet.of("database1"));
+        // Insert schema for "package1"
         InternalSetSchemaResponse internalSetSchemaResponse =
                 mAppSearchImpl.setSchema(
                         "package1",
-                        "database1",
-                        Collections.singletonList(new AppSearchSchema.Builder("schema").build()),
+                        "database",
+                        schemas,
                         /* visibilityConfigs= */ Collections.emptyList(),
                         /* forceOverride= */ false,
                         /* version= */ 0,
                         /* setSchemaStatsBuilder= */ null);
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
-        assertThat(mAppSearchImpl.getPackageToDatabases())
-                .containsExactlyEntriesIn(expectedMapping);
 
-        // Has both databases
-        expectedMapping.put("package1", ImmutableSet.of("database1", "database2"));
+        // Insert document for "package1"
+        GenericDocument document =
+                new GenericDocument.Builder<>("namespace", "id1", "type").build();
+        mAppSearchImpl.putDocument(
+                "package1",
+                "database",
+                document,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+
+        // Insert schema for "package2"
         internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package2",
+                        "database",
+                        schemas,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+
+        // Insert two documents for "package2"
+        document = new GenericDocument.Builder<>("namespace", "id1", "type").build();
+        mAppSearchImpl.putDocument(
+                "package2",
+                "database",
+                document,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+        document = new GenericDocument.Builder<>("namespace", "id2", "type").build();
+        mAppSearchImpl.putDocument(
+                "package2",
+                "database",
+                document,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+
+        StorageInfo storageInfo = mAppSearchImpl.getStorageInfoForPackage("package1");
+        long size1 = storageInfo.getSizeBytes();
+        assertThat(size1).isGreaterThan(0);
+        assertThat(storageInfo.getAliveDocumentsCount()).isEqualTo(1);
+        assertThat(storageInfo.getAliveNamespacesCount()).isEqualTo(1);
+
+        storageInfo = mAppSearchImpl.getStorageInfoForPackage("package2");
+        long size2 = storageInfo.getSizeBytes();
+        assertThat(size2).isGreaterThan(0);
+        assertThat(storageInfo.getAliveDocumentsCount()).isEqualTo(2);
+        assertThat(storageInfo.getAliveNamespacesCount()).isEqualTo(1);
+
+        // Size is proportional to number of documents. Since "package2" has twice as many
+        // documents as "package1", its size is twice as much too.
+        assertThat(size2).isAtLeast(2 * size1);
+    }
+
+    @Test
+    public void testGetStorageInfoForDatabase_nonexistentPackage() throws Exception {
+        // "package2" doesn't exist yet, so it shouldn't have any storage size
+        StorageInfo storageInfo =
+                mAppSearchImpl.getStorageInfoForDatabase(
+                        "nonexistent.package", "nonexistentDatabase");
+        assertThat(storageInfo.getSizeBytes()).isEqualTo(0);
+        assertThat(storageInfo.getAliveDocumentsCount()).isEqualTo(0);
+        assertThat(storageInfo.getAliveNamespacesCount()).isEqualTo(0);
+    }
+
+    @Test
+    public void testGetStorageInfoForDatabase_nonexistentDatabase() throws Exception {
+        // Insert schema for "package1"
+        List<AppSearchSchema> schemas =
+                Collections.singletonList(new AppSearchSchema.Builder("type").build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
                 mAppSearchImpl.setSchema(
                         "package1",
-                        "database2",
-                        Collections.singletonList(new AppSearchSchema.Builder("schema").build()),
+                        "database",
+                        schemas,
                         /* visibilityConfigs= */ Collections.emptyList(),
                         /* forceOverride= */ false,
                         /* version= */ 0,
                         /* setSchemaStatsBuilder= */ null);
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
-        assertThat(mAppSearchImpl.getPackageToDatabases())
-                .containsExactlyEntriesIn(expectedMapping);
 
-        // Has both packages
-        expectedMapping.put("package2", ImmutableSet.of("database1"));
-        internalSetSchemaResponse =
+        // "package2" doesn't exist yet, so it shouldn't have any storage size
+        StorageInfo storageInfo =
+                mAppSearchImpl.getStorageInfoForDatabase("package1", "nonexistentDatabase");
+        assertThat(storageInfo.getSizeBytes()).isEqualTo(0);
+        assertThat(storageInfo.getAliveDocumentsCount()).isEqualTo(0);
+        assertThat(storageInfo.getAliveNamespacesCount()).isEqualTo(0);
+    }
+
+    @Test
+    public void testGetStorageInfoForDatabase_withoutDocument() throws Exception {
+        // Insert schema for "package1"
+        List<AppSearchSchema> schemas =
+                Collections.singletonList(new AppSearchSchema.Builder("type").build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
                 mAppSearchImpl.setSchema(
-                        "package2",
+                        "package1",
                         "database1",
-                        Collections.singletonList(new AppSearchSchema.Builder("schema").build()),
+                        schemas,
                         /* visibilityConfigs= */ Collections.emptyList(),
                         /* forceOverride= */ false,
                         /* version= */ 0,
                         /* setSchemaStatsBuilder= */ null);
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
-        assertThat(mAppSearchImpl.getPackageToDatabases())
-                .containsExactlyEntriesIn(expectedMapping);
+
+        // Since "package1", "database1" doesn't have a document, it get any space attributed to it.
+        StorageInfo storageInfo = mAppSearchImpl.getStorageInfoForDatabase("package1", "database1");
+        assertThat(storageInfo.getSizeBytes()).isEqualTo(0);
+        assertThat(storageInfo.getAliveDocumentsCount()).isEqualTo(0);
+        assertThat(storageInfo.getAliveNamespacesCount()).isEqualTo(0);
+    }
+
+    @Test
+    public void testGetStorageInfoForDatabase_proportionalToDocuments() throws Exception {
+        // Insert schema for "package1", "database1" and "database2"
+        List<AppSearchSchema> schemas =
+                Collections.singletonList(new AppSearchSchema.Builder("type").build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package1",
+                        "database1",
+                        schemas,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+        internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package1",
+                        "database2",
+                        schemas,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+
+        // Add a document for "package1", "database1"
+        GenericDocument document =
+                new GenericDocument.Builder<>("namespace1", "id1", "type").build();
+        mAppSearchImpl.putDocument(
+                "package1",
+                "database1",
+                document,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+
+        // Add two documents for "package1", "database2"
+        document = new GenericDocument.Builder<>("namespace1", "id1", "type").build();
+        mAppSearchImpl.putDocument(
+                "package1",
+                "database2",
+                document,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+        document = new GenericDocument.Builder<>("namespace1", "id2", "type").build();
+        mAppSearchImpl.putDocument(
+                "package1",
+                "database2",
+                document,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+
+        StorageInfo storageInfo = mAppSearchImpl.getStorageInfoForDatabase("package1", "database1");
+        long size1 = storageInfo.getSizeBytes();
+        assertThat(size1).isGreaterThan(0);
+        assertThat(storageInfo.getAliveDocumentsCount()).isEqualTo(1);
+        assertThat(storageInfo.getAliveNamespacesCount()).isEqualTo(1);
+
+        storageInfo = mAppSearchImpl.getStorageInfoForDatabase("package1", "database2");
+        long size2 = storageInfo.getSizeBytes();
+        assertThat(size2).isGreaterThan(0);
+        assertThat(storageInfo.getAliveDocumentsCount()).isEqualTo(2);
+        assertThat(storageInfo.getAliveNamespacesCount()).isEqualTo(1);
+
+        // Size is proportional to number of documents. Since "database2" has twice as many
+        // documents as "database1", its size is twice as much too.
+        assertThat(size2).isAtLeast(2 * size1);
+    }
+
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testGetStorageInfoForPackage_withBlob() throws Exception {
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        ALWAYS_OPTIMIZE);
+
+        byte[] data1 = generateRandomBytes(5 * 1024); // 5 KiB
+        byte[] digest1 = calculateDigest(data1);
+        AppSearchBlobHandle handle1 =
+                AppSearchBlobHandle.createWithSha256(digest1, "package1", "db1", "ns");
+        ParcelFileDescriptor writePfd1 = mAppSearchImpl.openWriteBlob("package1", "db1", handle1);
+        try (OutputStream outputStream =
+                new ParcelFileDescriptor.AutoCloseOutputStream(writePfd1)) {
+            outputStream.write(data1);
+            outputStream.flush();
+        }
+
+        byte[] data2 = generateRandomBytes(10 * 1024); // 10 KiB
+        byte[] digest2 = calculateDigest(data2);
+        AppSearchBlobHandle handle2 =
+                AppSearchBlobHandle.createWithSha256(digest2, "package1", "db1", "ns");
+        ParcelFileDescriptor writePfd2 = mAppSearchImpl.openWriteBlob("package1", "db1", handle2);
+        try (OutputStream outputStream =
+                new ParcelFileDescriptor.AutoCloseOutputStream(writePfd2)) {
+            outputStream.write(data2);
+            outputStream.flush();
+        }
+
+        byte[] data3 = generateRandomBytes(20 * 1024); // 20 KiB
+        byte[] digest3 = calculateDigest(data3);
+        AppSearchBlobHandle handle3 =
+                AppSearchBlobHandle.createWithSha256(digest3, "package2", "db1", "ns");
+        ParcelFileDescriptor writePfd3 = mAppSearchImpl.openWriteBlob("package2", "db1", handle3);
+        try (OutputStream outputStream =
+                new ParcelFileDescriptor.AutoCloseOutputStream(writePfd3)) {
+            outputStream.write(data3);
+            outputStream.flush();
+        }
+
+        StorageInfo storageInfo1 = mAppSearchImpl.getStorageInfoForPackage("package1");
+        assertThat(storageInfo1.getBlobSizeBytes()).isEqualTo(15 * 1024);
+        assertThat(storageInfo1.getBlobCount()).isEqualTo(2);
+        StorageInfo storageInfo2 = mAppSearchImpl.getStorageInfoForPackage("package2");
+        assertThat(storageInfo2.getBlobSizeBytes()).isEqualTo(20 * 1024);
+        assertThat(storageInfo2.getBlobCount()).isEqualTo(1);
     }
 
     @Test
-    public void testGetAllPrefixedSchemaTypes() throws Exception {
-        // Insert schema
-        List<AppSearchSchema> schemas1 =
-                Collections.singletonList(new AppSearchSchema.Builder("type1").build());
-        List<AppSearchSchema> schemas2 =
-                Collections.singletonList(new AppSearchSchema.Builder("type2").build());
-        List<AppSearchSchema> schemas3 =
-                Collections.singletonList(new AppSearchSchema.Builder("type3").build());
-        InternalSetSchemaResponse internalSetSchemaResponse =
-                mAppSearchImpl.setSchema(
-                        "package1",
-                        "database1",
-                        schemas1,
-                        /* visibilityConfigs= */ Collections.emptyList(),
-                        /* forceOverride= */ false,
-                        /* version= */ 0,
-                        /* setSchemaStatsBuilder= */ null);
-        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
-        internalSetSchemaResponse =
-                mAppSearchImpl.setSchema(
-                        "package1",
-                        "database2",
-                        schemas2,
-                        /* visibilityConfigs= */ Collections.emptyList(),
-                        /* forceOverride= */ false,
-                        /* version= */ 0,
-                        /* setSchemaStatsBuilder= */ null);
-        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
-        internalSetSchemaResponse =
-                mAppSearchImpl.setSchema(
-                        "package2",
-                        "database1",
-                        schemas3,
-                        /* visibilityConfigs= */ Collections.emptyList(),
-                        /* forceOverride= */ false,
-                        /* version= */ 0,
-                        /* setSchemaStatsBuilder= */ null);
-        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
-        assertThat(mAppSearchImpl.getAllPrefixedSchemaTypes())
-                .containsExactly(
-                        "package1$database1/type1",
-                        "package1$database2/type2",
-                        "package2$database1/type3",
-                        "VS#Pkg$VS#Db/VisibilityType", // plus the stored Visibility schema
-                        "VS#Pkg$VS#Db/VisibilityPermissionType",
-                        "VS#Pkg$VS#AndroidVDb/AndroidVOverlayType");
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testGetStorageInfoForDatabase_withBlob() throws Exception {
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        ALWAYS_OPTIMIZE);
+        byte[] data1 = generateRandomBytes(5 * 1024); // 5 KiB
+        byte[] digest1 = calculateDigest(data1);
+        AppSearchBlobHandle handle1 =
+                AppSearchBlobHandle.createWithSha256(digest1, "package", "db1", "ns");
+        ParcelFileDescriptor writePfd1 = mAppSearchImpl.openWriteBlob("package", "db1", handle1);
+        try (OutputStream outputStream =
+                new ParcelFileDescriptor.AutoCloseOutputStream(writePfd1)) {
+            outputStream.write(data1);
+            outputStream.flush();
+        }
+
+        byte[] data2 = generateRandomBytes(10 * 1024); // 10 KiB
+        byte[] digest2 = calculateDigest(data2);
+        AppSearchBlobHandle handle2 =
+                AppSearchBlobHandle.createWithSha256(digest2, "package", "db1", "ns");
+        ParcelFileDescriptor writePfd2 = mAppSearchImpl.openWriteBlob("package", "db1", handle2);
+        try (OutputStream outputStream =
+                new ParcelFileDescriptor.AutoCloseOutputStream(writePfd2)) {
+            outputStream.write(data2);
+            outputStream.flush();
+        }
+
+        byte[] data3 = generateRandomBytes(20 * 1024); // 20 KiB
+        byte[] digest3 = calculateDigest(data3);
+        AppSearchBlobHandle handle3 =
+                AppSearchBlobHandle.createWithSha256(digest3, "package", "db2", "ns");
+        ParcelFileDescriptor writePfd3 = mAppSearchImpl.openWriteBlob("package", "db2", handle3);
+        try (OutputStream outputStream =
+                new ParcelFileDescriptor.AutoCloseOutputStream(writePfd3)) {
+            outputStream.write(data3);
+            outputStream.flush();
+        }
+
+        StorageInfo storageInfo1 = mAppSearchImpl.getStorageInfoForDatabase("package", "db1");
+        assertThat(storageInfo1.getBlobSizeBytes()).isEqualTo(15 * 1024);
+        assertThat(storageInfo1.getBlobCount()).isEqualTo(2);
+        StorageInfo storageInfo2 = mAppSearchImpl.getStorageInfoForDatabase("package", "db2");
+        assertThat(storageInfo2.getBlobSizeBytes()).isEqualTo(20 * 1024);
+        assertThat(storageInfo2.getBlobCount()).isEqualTo(1);
     }
 
-    @FlakyTest(bugId = 204186664)
     @Test
-    public void testReportUsage() throws Exception {
-        // Insert schema
+    public void testThrowsExceptionIfClosed() throws Exception {
+        // Initial check that we could do something at first.
         List<AppSearchSchema> schemas =
                 Collections.singletonList(new AppSearchSchema.Builder("type").build());
         InternalSetSchemaResponse internalSetSchemaResponse =
@@ -2794,184 +4267,125 @@ public class AppSearchImplTest {
                         /* setSchemaStatsBuilder= */ null);
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
 
-        // Insert two docs
-        GenericDocument document1 =
-                new GenericDocument.Builder<>("namespace", "id1", "type").build();
-        GenericDocument document2 =
-                new GenericDocument.Builder<>("namespace", "id2", "type").build();
-        mAppSearchImpl.putDocument(
-                "package",
-                "database",
-                document1,
-                /* sendChangeNotifications= */ false,
-                /* logger= */ null);
-        mAppSearchImpl.putDocument(
-                "package",
-                "database",
-                document2,
-                /* sendChangeNotifications= */ false,
-                /* logger= */ null);
+        mAppSearchImpl.close();
 
-        // Report some usages. id1 has 2 app and 1 system usage, id2 has 1 app and 2 system usage.
-        mAppSearchImpl.reportUsage(
-                "package",
-                "database",
-                "namespace",
-                "id1",
-                /* usageTimestampMillis= */ 10,
-                /* systemUsage= */ false);
-        mAppSearchImpl.reportUsage(
-                "package",
-                "database",
-                "namespace",
-                "id1",
-                /* usageTimestampMillis= */ 20,
-                /* systemUsage= */ false);
-        mAppSearchImpl.reportUsage(
-                "package",
-                "database",
-                "namespace",
-                "id1",
-                /* usageTimestampMillis= */ 1000,
-                /* systemUsage= */ true);
+        // Check all our public APIs
+        assertThrows(
+                IllegalStateException.class,
+                () ->
+                        mAppSearchImpl.setSchema(
+                                "package",
+                                "database",
+                                schemas,
+                                /* visibilityConfigs= */ Collections.emptyList(),
+                                /* forceOverride= */ false,
+                                /* version= */ 0,
+                                /* setSchemaStatsBuilder= */ null));
 
-        mAppSearchImpl.reportUsage(
-                "package",
-                "database",
-                "namespace",
-                "id2",
-                /* usageTimestampMillis= */ 100,
-                /* systemUsage= */ false);
-        mAppSearchImpl.reportUsage(
-                "package",
-                "database",
-                "namespace",
-                "id2",
-                /* usageTimestampMillis= */ 200,
-                /* systemUsage= */ true);
-        mAppSearchImpl.reportUsage(
-                "package",
-                "database",
-                "namespace",
-                "id2",
-                /* usageTimestampMillis= */ 150,
-                /* systemUsage= */ true);
+        assertThrows(
+                IllegalStateException.class,
+                () ->
+                        mAppSearchImpl.getSchema(
+                                /* packageName= */ "package",
+                                /* databaseName= */ "database",
+                                /* callerAccess= */ mSelfCallerAccess));
 
-        // Sort by app usage count: id1 should win
-        List<SearchResult> page =
-                mAppSearchImpl
-                        .query(
+        assertThrows(
+                IllegalStateException.class,
+                () ->
+                        mAppSearchImpl.putDocument(
                                 "package",
                                 "database",
-                                "",
-                                new SearchSpec.Builder()
-                                        .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
-                                        .setRankingStrategy(SearchSpec.RANKING_STRATEGY_USAGE_COUNT)
-                                        .build(),
-                                /* logger= */ null)
-                        .getResults();
-        assertThat(page).hasSize(2);
-        assertThat(page.get(0).getGenericDocument().getId()).isEqualTo("id1");
-        assertThat(page.get(1).getGenericDocument().getId()).isEqualTo("id2");
+                                new GenericDocument.Builder<>("namespace", "id", "type").build(),
+                                /* sendChangeNotifications= */ false,
+                                /* logger= */ null));
 
-        // Sort by app usage timestamp: id2 should win
-        page =
-                mAppSearchImpl
-                        .query(
+        assertThrows(
+                IllegalStateException.class,
+                () ->
+                        mAppSearchImpl.getDocument(
+                                "package", "database", "namespace", "id", Collections.emptyMap()));
+
+        assertThrows(
+                IllegalStateException.class,
+                () ->
+                        mAppSearchImpl.query(
                                 "package",
                                 "database",
-                                "",
-                                new SearchSpec.Builder()
-                                        .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
-                                        .setRankingStrategy(
-                                                SearchSpec
-                                                        .RANKING_STRATEGY_USAGE_LAST_USED_TIMESTAMP)
-                                        .build(),
-                                /* logger= */ null)
-                        .getResults();
-        assertThat(page).hasSize(2);
-        assertThat(page.get(0).getGenericDocument().getId()).isEqualTo("id2");
-        assertThat(page.get(1).getGenericDocument().getId()).isEqualTo("id1");
+                                "query",
+                                new SearchSpec.Builder().build(),
+                                /* logger= */ null));
 
-        // Sort by system usage count: id2 should win
-        page =
-                mAppSearchImpl
-                        .query(
+        assertThrows(
+                IllegalStateException.class,
+                () ->
+                        mAppSearchImpl.globalQuery(
+                                "query",
+                                new SearchSpec.Builder().build(),
+                                mSelfCallerAccess,
+                                /* logger= */ null));
+
+        assertThrows(
+                IllegalStateException.class,
+                () ->
+                        mAppSearchImpl.getNextPage(
+                                "package", /* nextPageToken= */ 1L, /* statsBuilder= */ null));
+
+        assertThrows(
+                IllegalStateException.class,
+                () -> mAppSearchImpl.invalidateNextPageToken("package", /* nextPageToken= */ 1L));
+
+        assertThrows(
+                IllegalStateException.class,
+                () ->
+                        mAppSearchImpl.reportUsage(
                                 "package",
                                 "database",
-                                "",
-                                new SearchSpec.Builder()
-                                        .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
-                                        .setRankingStrategy(
-                                                SearchSpec.RANKING_STRATEGY_SYSTEM_USAGE_COUNT)
-                                        .build(),
-                                /* logger= */ null)
-                        .getResults();
-        assertThat(page).hasSize(2);
-        assertThat(page.get(0).getGenericDocument().getId()).isEqualTo("id2");
-        assertThat(page.get(1).getGenericDocument().getId()).isEqualTo("id1");
+                                "namespace",
+                                "id",
+                                /* usageTimestampMillis= */ 1000L,
+                                /* systemUsage= */ false));
+
+        assertThrows(
+                IllegalStateException.class,
+                () ->
+                        mAppSearchImpl.remove(
+                                "package",
+                                "database",
+                                "namespace",
+                                "id",
+                                /* removeStatsBuilder= */ null));
 
-        // Sort by system usage timestamp: id1 should win
-        page =
-                mAppSearchImpl
-                        .query(
+        assertThrows(
+                IllegalStateException.class,
+                () ->
+                        mAppSearchImpl.removeByQuery(
                                 "package",
                                 "database",
-                                "",
-                                new SearchSpec.Builder()
-                                        .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
-                                        .setRankingStrategy(
-                                                SearchSpec
-                                                        .RANKING_STRATEGY_SYSTEM_USAGE_LAST_USED_TIMESTAMP)
-                                        .build(),
-                                /* logger= */ null)
-                        .getResults();
-        assertThat(page).hasSize(2);
-        assertThat(page.get(0).getGenericDocument().getId()).isEqualTo("id1");
-        assertThat(page.get(1).getGenericDocument().getId()).isEqualTo("id2");
-    }
+                                "query",
+                                new SearchSpec.Builder().build(),
+                                /* removeStatsBuilder= */ null));
 
-    @Test
-    public void testGetStorageInfoForPackage_nonexistentPackage() throws Exception {
-        // "package2" doesn't exist yet, so it shouldn't have any storage size
-        StorageInfo storageInfo = mAppSearchImpl.getStorageInfoForPackage("nonexistent.package");
-        assertThat(storageInfo.getSizeBytes()).isEqualTo(0);
-        assertThat(storageInfo.getAliveDocumentsCount()).isEqualTo(0);
-        assertThat(storageInfo.getAliveNamespacesCount()).isEqualTo(0);
-    }
+        assertThrows(
+                IllegalStateException.class,
+                () -> mAppSearchImpl.getStorageInfoForPackage("package"));
 
-    @Test
-    public void testGetStorageInfoForPackage_withoutDocument() throws Exception {
-        // Insert schema for "package1"
-        List<AppSearchSchema> schemas =
-                Collections.singletonList(new AppSearchSchema.Builder("type").build());
-        InternalSetSchemaResponse internalSetSchemaResponse =
-                mAppSearchImpl.setSchema(
-                        "package1",
-                        "database",
-                        schemas,
-                        /* visibilityConfigs= */ Collections.emptyList(),
-                        /* forceOverride= */ false,
-                        /* version= */ 0,
-                        /* setSchemaStatsBuilder= */ null);
-        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+        assertThrows(
+                IllegalStateException.class,
+                () -> mAppSearchImpl.getStorageInfoForDatabase("package", "database"));
 
-        // Since "package1" doesn't have a document, it get any space attributed to it.
-        StorageInfo storageInfo = mAppSearchImpl.getStorageInfoForPackage("package1");
-        assertThat(storageInfo.getSizeBytes()).isEqualTo(0);
-        assertThat(storageInfo.getAliveDocumentsCount()).isEqualTo(0);
-        assertThat(storageInfo.getAliveNamespacesCount()).isEqualTo(0);
+        assertThrows(
+                IllegalStateException.class,
+                () -> mAppSearchImpl.persistToDisk(PersistType.Code.FULL));
     }
 
     @Test
-    public void testGetStorageInfoForPackage_proportionalToDocuments() throws Exception {
+    public void testPutPersistsWithLiteFlush() throws Exception {
         List<AppSearchSchema> schemas =
                 Collections.singletonList(new AppSearchSchema.Builder("type").build());
-
-        // Insert schema for "package1"
         InternalSetSchemaResponse internalSetSchemaResponse =
                 mAppSearchImpl.setSchema(
-                        "package1",
+                        "package",
                         "database",
                         schemas,
                         /* visibilityConfigs= */ Collections.emptyList(),
@@ -2980,20 +4394,46 @@ public class AppSearchImplTest {
                         /* setSchemaStatsBuilder= */ null);
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
 
-        // Insert document for "package1"
+        // Add a document and persist it.
         GenericDocument document =
-                new GenericDocument.Builder<>("namespace", "id1", "type").build();
+                new GenericDocument.Builder<>("namespace1", "id1", "type").build();
         mAppSearchImpl.putDocument(
-                "package1",
+                "package",
                 "database",
                 document,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
+        mAppSearchImpl.persistToDisk(PersistType.Code.LITE);
 
-        // Insert schema for "package2"
-        internalSetSchemaResponse =
+        GenericDocument getResult =
+                mAppSearchImpl.getDocument(
+                        "package", "database", "namespace1", "id1", Collections.emptyMap());
+        assertThat(getResult).isEqualTo(document);
+
+        // That document should be visible even from another instance.
+        AppSearchImpl appSearchImpl2 =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        ALWAYS_OPTIMIZE);
+        getResult =
+                appSearchImpl2.getDocument(
+                        "package", "database", "namespace1", "id1", Collections.emptyMap());
+        assertThat(getResult).isEqualTo(document);
+        appSearchImpl2.close();
+    }
+
+    @Test
+    public void testDeletePersistsWithLiteFlush() throws Exception {
+        List<AppSearchSchema> schemas =
+                Collections.singletonList(new AppSearchSchema.Builder("type").build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
                 mAppSearchImpl.setSchema(
-                        "package2",
+                        "package",
                         "database",
                         schemas,
                         /* visibilityConfigs= */ Collections.emptyList(),
@@ -3002,116 +4442,85 @@ public class AppSearchImplTest {
                         /* setSchemaStatsBuilder= */ null);
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
 
-        // Insert two documents for "package2"
-        document = new GenericDocument.Builder<>("namespace", "id1", "type").build();
+        // Add two documents and persist them.
+        GenericDocument document1 =
+                new GenericDocument.Builder<>("namespace1", "id1", "type").build();
         mAppSearchImpl.putDocument(
-                "package2",
+                "package",
                 "database",
-                document,
+                document1,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
-        document = new GenericDocument.Builder<>("namespace", "id2", "type").build();
+        GenericDocument document2 =
+                new GenericDocument.Builder<>("namespace1", "id2", "type").build();
         mAppSearchImpl.putDocument(
-                "package2",
+                "package",
                 "database",
-                document,
+                document2,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
+        mAppSearchImpl.persistToDisk(PersistType.Code.LITE);
 
-        StorageInfo storageInfo = mAppSearchImpl.getStorageInfoForPackage("package1");
-        long size1 = storageInfo.getSizeBytes();
-        assertThat(size1).isGreaterThan(0);
-        assertThat(storageInfo.getAliveDocumentsCount()).isEqualTo(1);
-        assertThat(storageInfo.getAliveNamespacesCount()).isEqualTo(1);
-
-        storageInfo = mAppSearchImpl.getStorageInfoForPackage("package2");
-        long size2 = storageInfo.getSizeBytes();
-        assertThat(size2).isGreaterThan(0);
-        assertThat(storageInfo.getAliveDocumentsCount()).isEqualTo(2);
-        assertThat(storageInfo.getAliveNamespacesCount()).isEqualTo(1);
-
-        // Size is proportional to number of documents. Since "package2" has twice as many
-        // documents as "package1", its size is twice as much too.
-        assertThat(size2).isAtLeast(2 * size1);
-    }
-
-    @Test
-    public void testGetStorageInfoForDatabase_nonexistentPackage() throws Exception {
-        // "package2" doesn't exist yet, so it shouldn't have any storage size
-        StorageInfo storageInfo =
-                mAppSearchImpl.getStorageInfoForDatabase(
-                        "nonexistent.package", "nonexistentDatabase");
-        assertThat(storageInfo.getSizeBytes()).isEqualTo(0);
-        assertThat(storageInfo.getAliveDocumentsCount()).isEqualTo(0);
-        assertThat(storageInfo.getAliveNamespacesCount()).isEqualTo(0);
-    }
-
-    @Test
-    public void testGetStorageInfoForDatabase_nonexistentDatabase() throws Exception {
-        // Insert schema for "package1"
-        List<AppSearchSchema> schemas =
-                Collections.singletonList(new AppSearchSchema.Builder("type").build());
-        InternalSetSchemaResponse internalSetSchemaResponse =
-                mAppSearchImpl.setSchema(
-                        "package1",
-                        "database",
-                        schemas,
-                        /* visibilityConfigs= */ Collections.emptyList(),
-                        /* forceOverride= */ false,
-                        /* version= */ 0,
-                        /* setSchemaStatsBuilder= */ null);
-        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
-
-        // "package2" doesn't exist yet, so it shouldn't have any storage size
-        StorageInfo storageInfo =
-                mAppSearchImpl.getStorageInfoForDatabase("package1", "nonexistentDatabase");
-        assertThat(storageInfo.getSizeBytes()).isEqualTo(0);
-        assertThat(storageInfo.getAliveDocumentsCount()).isEqualTo(0);
-        assertThat(storageInfo.getAliveNamespacesCount()).isEqualTo(0);
-    }
+        GenericDocument getResult =
+                mAppSearchImpl.getDocument(
+                        "package", "database", "namespace1", "id1", Collections.emptyMap());
+        assertThat(getResult).isEqualTo(document1);
+        getResult =
+                mAppSearchImpl.getDocument(
+                        "package", "database", "namespace1", "id2", Collections.emptyMap());
+        assertThat(getResult).isEqualTo(document2);
 
-    @Test
-    public void testGetStorageInfoForDatabase_withoutDocument() throws Exception {
-        // Insert schema for "package1"
-        List<AppSearchSchema> schemas =
-                Collections.singletonList(new AppSearchSchema.Builder("type").build());
-        InternalSetSchemaResponse internalSetSchemaResponse =
-                mAppSearchImpl.setSchema(
-                        "package1",
-                        "database1",
-                        schemas,
-                        /* visibilityConfigs= */ Collections.emptyList(),
-                        /* forceOverride= */ false,
-                        /* version= */ 0,
-                        /* setSchemaStatsBuilder= */ null);
-        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+        // Delete the first document
+        mAppSearchImpl.remove("package", "database", "namespace1", "id1", /* statsBuilder= */ null);
+        mAppSearchImpl.persistToDisk(PersistType.Code.LITE);
+        assertThrows(
+                AppSearchException.class,
+                () ->
+                        mAppSearchImpl.getDocument(
+                                "package",
+                                "database",
+                                "namespace1",
+                                "id1",
+                                Collections.emptyMap()));
+        getResult =
+                mAppSearchImpl.getDocument(
+                        "package", "database", "namespace1", "id2", Collections.emptyMap());
+        assertThat(getResult).isEqualTo(document2);
 
-        // Since "package1", "database1" doesn't have a document, it get any space attributed to it.
-        StorageInfo storageInfo = mAppSearchImpl.getStorageInfoForDatabase("package1", "database1");
-        assertThat(storageInfo.getSizeBytes()).isEqualTo(0);
-        assertThat(storageInfo.getAliveDocumentsCount()).isEqualTo(0);
-        assertThat(storageInfo.getAliveNamespacesCount()).isEqualTo(0);
+        // Only the second document should be retrievable from another instance.
+        AppSearchImpl appSearchImpl2 =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        ALWAYS_OPTIMIZE);
+        assertThrows(
+                AppSearchException.class,
+                () ->
+                        appSearchImpl2.getDocument(
+                                "package",
+                                "database",
+                                "namespace1",
+                                "id1",
+                                Collections.emptyMap()));
+        getResult =
+                appSearchImpl2.getDocument(
+                        "package", "database", "namespace1", "id2", Collections.emptyMap());
+        assertThat(getResult).isEqualTo(document2);
+        appSearchImpl2.close();
     }
 
     @Test
-    public void testGetStorageInfoForDatabase_proportionalToDocuments() throws Exception {
-        // Insert schema for "package1", "database1" and "database2"
+    public void testDeleteByQueryPersistsWithLiteFlush() throws Exception {
         List<AppSearchSchema> schemas =
-                Collections.singletonList(new AppSearchSchema.Builder("type").build());
-        InternalSetSchemaResponse internalSetSchemaResponse =
-                mAppSearchImpl.setSchema(
-                        "package1",
-                        "database1",
-                        schemas,
-                        /* visibilityConfigs= */ Collections.emptyList(),
-                        /* forceOverride= */ false,
-                        /* version= */ 0,
-                        /* setSchemaStatsBuilder= */ null);
-        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
-        internalSetSchemaResponse =
+                Collections.singletonList(new AppSearchSchema.Builder("type").build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
                 mAppSearchImpl.setSchema(
-                        "package1",
-                        "database2",
+                        "package",
+                        "database",
                         schemas,
                         /* visibilityConfigs= */ Collections.emptyList(),
                         /* forceOverride= */ false,
@@ -3119,52 +4528,88 @@ public class AppSearchImplTest {
                         /* setSchemaStatsBuilder= */ null);
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
 
-        // Add a document for "package1", "database1"
-        GenericDocument document =
+        // Add two documents and persist them.
+        GenericDocument document1 =
                 new GenericDocument.Builder<>("namespace1", "id1", "type").build();
         mAppSearchImpl.putDocument(
-                "package1",
-                "database1",
-                document,
-                /* sendChangeNotifications= */ false,
-                /* logger= */ null);
-
-        // Add two documents for "package1", "database2"
-        document = new GenericDocument.Builder<>("namespace1", "id1", "type").build();
-        mAppSearchImpl.putDocument(
-                "package1",
-                "database2",
-                document,
+                "package",
+                "database",
+                document1,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
-        document = new GenericDocument.Builder<>("namespace1", "id2", "type").build();
+        GenericDocument document2 =
+                new GenericDocument.Builder<>("namespace2", "id2", "type").build();
         mAppSearchImpl.putDocument(
-                "package1",
-                "database2",
-                document,
+                "package",
+                "database",
+                document2,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
+        mAppSearchImpl.persistToDisk(PersistType.Code.LITE);
 
-        StorageInfo storageInfo = mAppSearchImpl.getStorageInfoForDatabase("package1", "database1");
-        long size1 = storageInfo.getSizeBytes();
-        assertThat(size1).isGreaterThan(0);
-        assertThat(storageInfo.getAliveDocumentsCount()).isEqualTo(1);
-        assertThat(storageInfo.getAliveNamespacesCount()).isEqualTo(1);
+        GenericDocument getResult =
+                mAppSearchImpl.getDocument(
+                        "package", "database", "namespace1", "id1", Collections.emptyMap());
+        assertThat(getResult).isEqualTo(document1);
+        getResult =
+                mAppSearchImpl.getDocument(
+                        "package", "database", "namespace2", "id2", Collections.emptyMap());
+        assertThat(getResult).isEqualTo(document2);
 
-        storageInfo = mAppSearchImpl.getStorageInfoForDatabase("package1", "database2");
-        long size2 = storageInfo.getSizeBytes();
-        assertThat(size2).isGreaterThan(0);
-        assertThat(storageInfo.getAliveDocumentsCount()).isEqualTo(2);
-        assertThat(storageInfo.getAliveNamespacesCount()).isEqualTo(1);
+        // Delete the first document
+        mAppSearchImpl.removeByQuery(
+                "package",
+                "database",
+                "",
+                new SearchSpec.Builder()
+                        .addFilterNamespaces("namespace1")
+                        .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
+                        .build(),
+                /* statsBuilder= */ null);
+        mAppSearchImpl.persistToDisk(PersistType.Code.LITE);
+        assertThrows(
+                AppSearchException.class,
+                () ->
+                        mAppSearchImpl.getDocument(
+                                "package",
+                                "database",
+                                "namespace1",
+                                "id1",
+                                Collections.emptyMap()));
+        getResult =
+                mAppSearchImpl.getDocument(
+                        "package", "database", "namespace2", "id2", Collections.emptyMap());
+        assertThat(getResult).isEqualTo(document2);
 
-        // Size is proportional to number of documents. Since "database2" has twice as many
-        // documents as "database1", its size is twice as much too.
-        assertThat(size2).isAtLeast(2 * size1);
+        // Only the second document should be retrievable from another instance.
+        AppSearchImpl appSearchImpl2 =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        ALWAYS_OPTIMIZE);
+        assertThrows(
+                AppSearchException.class,
+                () ->
+                        appSearchImpl2.getDocument(
+                                "package",
+                                "database",
+                                "namespace1",
+                                "id1",
+                                Collections.emptyMap()));
+        getResult =
+                appSearchImpl2.getDocument(
+                        "package", "database", "namespace2", "id2", Collections.emptyMap());
+        assertThat(getResult).isEqualTo(document2);
+        appSearchImpl2.close();
     }
 
     @Test
-    public void testThrowsExceptionIfClosed() throws Exception {
-        // Initial check that we could do something at first.
+    @RequiresFlagsDisabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testGetIcingSearchEngineStorageInfo() throws Exception {
         List<AppSearchSchema> schemas =
                 Collections.singletonList(new AppSearchSchema.Builder("type").build());
         InternalSetSchemaResponse internalSetSchemaResponse =
@@ -3178,120 +4623,46 @@ public class AppSearchImplTest {
                         /* setSchemaStatsBuilder= */ null);
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
 
-        mAppSearchImpl.close();
-
-        // Check all our public APIs
-        assertThrows(
-                IllegalStateException.class,
-                () ->
-                        mAppSearchImpl.setSchema(
-                                "package",
-                                "database",
-                                schemas,
-                                /* visibilityConfigs= */ Collections.emptyList(),
-                                /* forceOverride= */ false,
-                                /* version= */ 0,
-                                /* setSchemaStatsBuilder= */ null));
-
-        assertThrows(
-                IllegalStateException.class,
-                () ->
-                        mAppSearchImpl.getSchema(
-                                /* packageName= */ "package",
-                                /* databaseName= */ "database",
-                                /* callerAccess= */ mSelfCallerAccess));
-
-        assertThrows(
-                IllegalStateException.class,
-                () ->
-                        mAppSearchImpl.putDocument(
-                                "package",
-                                "database",
-                                new GenericDocument.Builder<>("namespace", "id", "type").build(),
-                                /* sendChangeNotifications= */ false,
-                                /* logger= */ null));
-
-        assertThrows(
-                IllegalStateException.class,
-                () ->
-                        mAppSearchImpl.getDocument(
-                                "package", "database", "namespace", "id", Collections.emptyMap()));
-
-        assertThrows(
-                IllegalStateException.class,
-                () ->
-                        mAppSearchImpl.query(
-                                "package",
-                                "database",
-                                "query",
-                                new SearchSpec.Builder().build(),
-                                /* logger= */ null));
-
-        assertThrows(
-                IllegalStateException.class,
-                () ->
-                        mAppSearchImpl.globalQuery(
-                                "query",
-                                new SearchSpec.Builder().build(),
-                                mSelfCallerAccess,
-                                /* logger= */ null));
-
-        assertThrows(
-                IllegalStateException.class,
-                () ->
-                        mAppSearchImpl.getNextPage(
-                                "package", /* nextPageToken= */ 1L, /* statsBuilder= */ null));
-
-        assertThrows(
-                IllegalStateException.class,
-                () -> mAppSearchImpl.invalidateNextPageToken("package", /* nextPageToken= */ 1L));
-
-        assertThrows(
-                IllegalStateException.class,
-                () ->
-                        mAppSearchImpl.reportUsage(
-                                "package",
-                                "database",
-                                "namespace",
-                                "id",
-                                /* usageTimestampMillis= */ 1000L,
-                                /* systemUsage= */ false));
-
-        assertThrows(
-                IllegalStateException.class,
-                () ->
-                        mAppSearchImpl.remove(
-                                "package",
-                                "database",
-                                "namespace",
-                                "id",
-                                /* removeStatsBuilder= */ null));
-
-        assertThrows(
-                IllegalStateException.class,
-                () ->
-                        mAppSearchImpl.removeByQuery(
-                                "package",
-                                "database",
-                                "query",
-                                new SearchSpec.Builder().build(),
-                                /* removeStatsBuilder= */ null));
-
-        assertThrows(
-                IllegalStateException.class,
-                () -> mAppSearchImpl.getStorageInfoForPackage("package"));
+        // Add two documents
+        GenericDocument document1 =
+                new GenericDocument.Builder<>("namespace1", "id1", "type").build();
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
+                document1,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+        GenericDocument document2 =
+                new GenericDocument.Builder<>("namespace1", "id2", "type").build();
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
+                document2,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
 
-        assertThrows(
-                IllegalStateException.class,
-                () -> mAppSearchImpl.getStorageInfoForDatabase("package", "database"));
+        StorageInfoProto storageInfo = mAppSearchImpl.getRawStorageInfoProto();
 
-        assertThrows(
-                IllegalStateException.class,
-                () -> mAppSearchImpl.persistToDisk(PersistType.Code.FULL));
+        // Simple checks to verify if we can get correct StorageInfoProto from IcingSearchEngine
+        // No need to cover all the fields
+        assertThat(storageInfo.getTotalStorageSize()).isGreaterThan(0);
+        assertThat(storageInfo.getDocumentStorageInfo().getNumAliveDocuments()).isEqualTo(2);
+        assertThat(storageInfo.getSchemaStoreStorageInfo().getNumSchemaTypes())
+                .isEqualTo(4); // +2 for VisibilitySchema, +1 for VisibilityOverlay
     }
 
     @Test
-    public void testPutPersistsWithLiteFlush() throws Exception {
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testGetIcingSearchEngineStorageInfo_enableBlobStore() throws Exception {
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mAppSearchDir,
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
+                        ALWAYS_OPTIMIZE);
         List<AppSearchSchema> schemas =
                 Collections.singletonList(new AppSearchSchema.Builder("type").build());
         InternalSetSchemaResponse internalSetSchemaResponse =
@@ -3305,40 +4676,37 @@ public class AppSearchImplTest {
                         /* setSchemaStatsBuilder= */ null);
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
 
-        // Add a document and persist it.
-        GenericDocument document =
+        // Add two documents
+        GenericDocument document1 =
                 new GenericDocument.Builder<>("namespace1", "id1", "type").build();
         mAppSearchImpl.putDocument(
                 "package",
                 "database",
-                document,
+                document1,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+        GenericDocument document2 =
+                new GenericDocument.Builder<>("namespace1", "id2", "type").build();
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
+                document2,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
-        mAppSearchImpl.persistToDisk(PersistType.Code.LITE);
 
-        GenericDocument getResult =
-                mAppSearchImpl.getDocument(
-                        "package", "database", "namespace1", "id1", Collections.emptyMap());
-        assertThat(getResult).isEqualTo(document);
+        StorageInfoProto storageInfo = mAppSearchImpl.getRawStorageInfoProto();
 
-        // That document should be visible even from another instance.
-        AppSearchImpl appSearchImpl2 =
-                AppSearchImpl.create(
-                        mAppSearchDir,
-                        new AppSearchConfigImpl(
-                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
-                        /* initStatsBuilder= */ null,
-                        /* visibilityChecker= */ null,
-                        ALWAYS_OPTIMIZE);
-        getResult =
-                appSearchImpl2.getDocument(
-                        "package", "database", "namespace1", "id1", Collections.emptyMap());
-        assertThat(getResult).isEqualTo(document);
-        appSearchImpl2.close();
+        // Simple checks to verify if we can get correct StorageInfoProto from IcingSearchEngine
+        // No need to cover all the fields
+        assertThat(storageInfo.getTotalStorageSize()).isGreaterThan(0);
+        assertThat(storageInfo.getDocumentStorageInfo().getNumAliveDocuments()).isEqualTo(2);
+        // +2 (document and blob db) * (2 for VisibilitySchema +1 for VisibilityOverlay)
+        assertThat(storageInfo.getSchemaStoreStorageInfo().getNumSchemaTypes()).isEqualTo(7);
     }
 
     @Test
-    public void testDeletePersistsWithLiteFlush() throws Exception {
+    @RequiresFlagsDisabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testGetIcingSearchEngineDebugInfo() throws Exception {
         List<AppSearchSchema> schemas =
                 Collections.singletonList(new AppSearchSchema.Builder("type").build());
         InternalSetSchemaResponse internalSetSchemaResponse =
@@ -3352,7 +4720,7 @@ public class AppSearchImplTest {
                         /* setSchemaStatsBuilder= */ null);
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
 
-        // Add two documents and persist them.
+        // Add two documents
         GenericDocument document1 =
                 new GenericDocument.Builder<>("namespace1", "id1", "type").build();
         mAppSearchImpl.putDocument(
@@ -3369,61 +4737,31 @@ public class AppSearchImplTest {
                 document2,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
-        mAppSearchImpl.persistToDisk(PersistType.Code.LITE);
 
-        GenericDocument getResult =
-                mAppSearchImpl.getDocument(
-                        "package", "database", "namespace1", "id1", Collections.emptyMap());
-        assertThat(getResult).isEqualTo(document1);
-        getResult =
-                mAppSearchImpl.getDocument(
-                        "package", "database", "namespace1", "id2", Collections.emptyMap());
-        assertThat(getResult).isEqualTo(document2);
+        DebugInfoProto debugInfo =
+                mAppSearchImpl.getRawDebugInfoProto(DebugInfoVerbosity.Code.DETAILED);
 
-        // Delete the first document
-        mAppSearchImpl.remove("package", "database", "namespace1", "id1", /* statsBuilder= */ null);
-        mAppSearchImpl.persistToDisk(PersistType.Code.LITE);
-        assertThrows(
-                AppSearchException.class,
-                () ->
-                        mAppSearchImpl.getDocument(
-                                "package",
-                                "database",
-                                "namespace1",
-                                "id1",
-                                Collections.emptyMap()));
-        getResult =
-                mAppSearchImpl.getDocument(
-                        "package", "database", "namespace1", "id2", Collections.emptyMap());
-        assertThat(getResult).isEqualTo(document2);
+        // Simple checks to verify if we can get correct DebugInfoProto from IcingSearchEngine
+        // No need to cover all the fields
+        assertThat(debugInfo.getDocumentInfo().getCorpusInfoList()).hasSize(1);
+        assertThat(debugInfo.getDocumentInfo().getDocumentStorageInfo().getNumAliveDocuments())
+                .isEqualTo(2);
+        assertThat(debugInfo.getSchemaInfo().getSchema().getTypesList())
+                .hasSize(4); // +2 for VisibilitySchema, +1 for VisibilityOverlay
+    }
 
-        // Only the second document should be retrievable from another instance.
-        AppSearchImpl appSearchImpl2 =
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testGetIcingSearchEngineDebugInfo_enableBlobStore() throws Exception {
+        mAppSearchImpl =
                 AppSearchImpl.create(
                         mAppSearchDir,
                         new AppSearchConfigImpl(
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        new JetpackRevocableFileDescriptorStore(mUnlimitedConfig),
                         ALWAYS_OPTIMIZE);
-        assertThrows(
-                AppSearchException.class,
-                () ->
-                        appSearchImpl2.getDocument(
-                                "package",
-                                "database",
-                                "namespace1",
-                                "id1",
-                                Collections.emptyMap()));
-        getResult =
-                appSearchImpl2.getDocument(
-                        "package", "database", "namespace1", "id2", Collections.emptyMap());
-        assertThat(getResult).isEqualTo(document2);
-        appSearchImpl2.close();
-    }
-
-    @Test
-    public void testDeleteByQueryPersistsWithLiteFlush() throws Exception {
         List<AppSearchSchema> schemas =
                 Collections.singletonList(new AppSearchSchema.Builder("type").build());
         InternalSetSchemaResponse internalSetSchemaResponse =
@@ -3437,7 +4775,7 @@ public class AppSearchImplTest {
                         /* setSchemaStatsBuilder= */ null);
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
 
-        // Add two documents and persist them.
+        // Add two documents
         GenericDocument document1 =
                 new GenericDocument.Builder<>("namespace1", "id1", "type").build();
         mAppSearchImpl.putDocument(
@@ -3447,76 +4785,67 @@ public class AppSearchImplTest {
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
         GenericDocument document2 =
-                new GenericDocument.Builder<>("namespace2", "id2", "type").build();
+                new GenericDocument.Builder<>("namespace1", "id2", "type").build();
         mAppSearchImpl.putDocument(
                 "package",
                 "database",
                 document2,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
-        mAppSearchImpl.persistToDisk(PersistType.Code.LITE);
 
-        GenericDocument getResult =
-                mAppSearchImpl.getDocument(
-                        "package", "database", "namespace1", "id1", Collections.emptyMap());
-        assertThat(getResult).isEqualTo(document1);
-        getResult =
-                mAppSearchImpl.getDocument(
-                        "package", "database", "namespace2", "id2", Collections.emptyMap());
-        assertThat(getResult).isEqualTo(document2);
+        DebugInfoProto debugInfo =
+                mAppSearchImpl.getRawDebugInfoProto(DebugInfoVerbosity.Code.DETAILED);
 
-        // Delete the first document
-        mAppSearchImpl.removeByQuery(
-                "package",
-                "database",
-                "",
-                new SearchSpec.Builder()
-                        .addFilterNamespaces("namespace1")
-                        .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
-                        .build(),
-                /* statsBuilder= */ null);
-        mAppSearchImpl.persistToDisk(PersistType.Code.LITE);
-        assertThrows(
-                AppSearchException.class,
-                () ->
-                        mAppSearchImpl.getDocument(
-                                "package",
-                                "database",
-                                "namespace1",
-                                "id1",
-                                Collections.emptyMap()));
-        getResult =
-                mAppSearchImpl.getDocument(
-                        "package", "database", "namespace2", "id2", Collections.emptyMap());
-        assertThat(getResult).isEqualTo(document2);
+        // Simple checks to verify if we can get correct DebugInfoProto from IcingSearchEngine
+        // No need to cover all the fields
+        assertThat(debugInfo.getDocumentInfo().getCorpusInfoList()).hasSize(1);
+        assertThat(debugInfo.getDocumentInfo().getDocumentStorageInfo().getNumAliveDocuments())
+                .isEqualTo(2);
+        // +2 (document and blob db) * (2 for VisibilitySchema +1 for VisibilityOverlay)
+        assertThat(debugInfo.getSchemaInfo().getSchema().getTypesList()).hasSize(7);
+    }
 
-        // Only the second document should be retrievable from another instance.
-        AppSearchImpl appSearchImpl2 =
+    @Test
+    public void testLimitConfig_DocumentSize() throws Exception {
+        // Create a new mAppSearchImpl with a lower limit
+        mAppSearchImpl.close();
+        mAppSearchImpl =
                 AppSearchImpl.create(
-                        mAppSearchDir,
+                        mTemporaryFolder.newFolder(),
                         new AppSearchConfigImpl(
-                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                                new LimitConfig() {
+                                    @Override
+                                    public int getMaxDocumentSizeBytes() {
+                                        return 80;
+                                    }
+
+                                    @Override
+                                    public int getPerPackageDocumentCountLimit() {
+                                        return 1;
+                                    }
+
+                                    @Override
+                                    public int getDocumentCountLimitStartThreshold() {
+                                        return 0;
+                                    }
+
+                                    @Override
+                                    public int getMaxSuggestionCount() {
+                                        return Integer.MAX_VALUE;
+                                    }
+
+                                    @Override
+                                    public int getMaxOpenBlobCount() {
+                                        return Integer.MAX_VALUE;
+                                    }
+                                },
+                                new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
-        assertThrows(
-                AppSearchException.class,
-                () ->
-                        appSearchImpl2.getDocument(
-                                "package",
-                                "database",
-                                "namespace1",
-                                "id1",
-                                Collections.emptyMap()));
-        getResult =
-                appSearchImpl2.getDocument(
-                        "package", "database", "namespace2", "id2", Collections.emptyMap());
-        assertThat(getResult).isEqualTo(document2);
-        appSearchImpl2.close();
-    }
 
-    @Test
-    public void testGetIcingSearchEngineStorageInfo() throws Exception {
+        // Insert schema
         List<AppSearchSchema> schemas =
                 Collections.singletonList(new AppSearchSchema.Builder("type").build());
         InternalSetSchemaResponse internalSetSchemaResponse =
@@ -3530,17 +4859,32 @@ public class AppSearchImplTest {
                         /* setSchemaStatsBuilder= */ null);
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
 
-        // Add two documents
-        GenericDocument document1 =
-                new GenericDocument.Builder<>("namespace1", "id1", "type").build();
-        mAppSearchImpl.putDocument(
-                "package",
-                "database",
-                document1,
-                /* sendChangeNotifications= */ false,
-                /* logger= */ null);
+        // Insert a document which is too large
+        GenericDocument document =
+                new GenericDocument.Builder<>(
+                                "this_namespace_is_long_to_make_the_doc_big", "id", "type")
+                        .build();
+        AppSearchException e =
+                assertThrows(
+                        AppSearchException.class,
+                        () ->
+                                mAppSearchImpl.putDocument(
+                                        "package",
+                                        "database",
+                                        document,
+                                        /* sendChangeNotifications= */ false,
+                                        /* logger= */ null));
+        assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_OUT_OF_SPACE);
+        assertThat(e)
+                .hasMessageThat()
+                .contains(
+                        "Document \"id\" for package \"package\" serialized to 99 bytes, which"
+                            + " exceeds limit of 80 bytes");
+
+        // Make sure this failure didn't increase our document count. We should still be able to
+        // index 1 document.
         GenericDocument document2 =
-                new GenericDocument.Builder<>("namespace1", "id2", "type").build();
+                new GenericDocument.Builder<>("namespace", "id2", "type").build();
         mAppSearchImpl.putDocument(
                 "package",
                 "database",
@@ -3548,18 +4892,67 @@ public class AppSearchImplTest {
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
 
-        StorageInfoProto storageInfo = mAppSearchImpl.getRawStorageInfoProto();
+        // Now we should get a failure
+        GenericDocument document3 =
+                new GenericDocument.Builder<>("namespace", "id3", "type").build();
+        e =
+                assertThrows(
+                        AppSearchException.class,
+                        () ->
+                                mAppSearchImpl.putDocument(
+                                        "package",
+                                        "database",
+                                        document3,
+                                        /* sendChangeNotifications= */ false,
+                                        /* logger= */ null));
+        assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_OUT_OF_SPACE);
+        assertThat(e)
+                .hasMessageThat()
+                .contains("Package \"package\" exceeded limit of 1 documents");
+    }
+
+    @Test
+    public void testLimitConfig_Init() throws Exception {
+        // Create a new mAppSearchImpl with a lower limit
+        mAppSearchImpl.close();
+        File tempFolder = mTemporaryFolder.newFolder();
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        tempFolder,
+                        new AppSearchConfigImpl(
+                                new LimitConfig() {
+                                    @Override
+                                    public int getMaxDocumentSizeBytes() {
+                                        return 80;
+                                    }
+
+                                    @Override
+                                    public int getPerPackageDocumentCountLimit() {
+                                        return 1;
+                                    }
+
+                                    @Override
+                                    public int getDocumentCountLimitStartThreshold() {
+                                        return 0;
+                                    }
 
-        // Simple checks to verify if we can get correct StorageInfoProto from IcingSearchEngine
-        // No need to cover all the fields
-        assertThat(storageInfo.getTotalStorageSize()).isGreaterThan(0);
-        assertThat(storageInfo.getDocumentStorageInfo().getNumAliveDocuments()).isEqualTo(2);
-        assertThat(storageInfo.getSchemaStoreStorageInfo().getNumSchemaTypes())
-                .isEqualTo(4); // +2 for VisibilitySchema, +1 for VisibilityOverlay
-    }
+                                    @Override
+                                    public int getMaxSuggestionCount() {
+                                        return Integer.MAX_VALUE;
+                                    }
 
-    @Test
-    public void testGetIcingSearchEngineDebugInfo() throws Exception {
+                                    @Override
+                                    public int getMaxOpenBlobCount() {
+                                        return Integer.MAX_VALUE;
+                                    }
+                                },
+                                new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        ALWAYS_OPTIMIZE);
+
+        // Insert schema
         List<AppSearchSchema> schemas =
                 Collections.singletonList(new AppSearchSchema.Builder("type").build());
         InternalSetSchemaResponse internalSetSchemaResponse =
@@ -3573,38 +4966,89 @@ public class AppSearchImplTest {
                         /* setSchemaStatsBuilder= */ null);
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
 
-        // Add two documents
-        GenericDocument document1 =
-                new GenericDocument.Builder<>("namespace1", "id1", "type").build();
+        // Index a document
         mAppSearchImpl.putDocument(
                 "package",
                 "database",
-                document1,
+                new GenericDocument.Builder<>("namespace", "id1", "type").build(),
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
+
+        // Now we should get a failure
         GenericDocument document2 =
-                new GenericDocument.Builder<>("namespace1", "id2", "type").build();
-        mAppSearchImpl.putDocument(
-                "package",
-                "database",
-                document2,
-                /* sendChangeNotifications= */ false,
-                /* logger= */ null);
+                new GenericDocument.Builder<>("namespace", "id2", "type").build();
+        AppSearchException e =
+                assertThrows(
+                        AppSearchException.class,
+                        () ->
+                                mAppSearchImpl.putDocument(
+                                        "package",
+                                        "database",
+                                        document2,
+                                        /* sendChangeNotifications= */ false,
+                                        /* logger= */ null));
+        assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_OUT_OF_SPACE);
+        assertThat(e)
+                .hasMessageThat()
+                .contains("Package \"package\" exceeded limit of 1 documents");
 
-        DebugInfoProto debugInfo =
-                mAppSearchImpl.getRawDebugInfoProto(DebugInfoVerbosity.Code.DETAILED);
+        // Close and reinitialize AppSearchImpl
+        mAppSearchImpl.close();
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        tempFolder,
+                        new AppSearchConfigImpl(
+                                new LimitConfig() {
+                                    @Override
+                                    public int getMaxDocumentSizeBytes() {
+                                        return 80;
+                                    }
 
-        // Simple checks to verify if we can get correct DebugInfoProto from IcingSearchEngine
-        // No need to cover all the fields
-        assertThat(debugInfo.getDocumentInfo().getCorpusInfoList()).hasSize(1);
-        assertThat(debugInfo.getDocumentInfo().getDocumentStorageInfo().getNumAliveDocuments())
-                .isEqualTo(2);
-        assertThat(debugInfo.getSchemaInfo().getSchema().getTypesList())
-                .hasSize(4); // +2 for VisibilitySchema, +1 for VisibilityOverlay
+                                    @Override
+                                    public int getPerPackageDocumentCountLimit() {
+                                        return 1;
+                                    }
+
+                                    @Override
+                                    public int getDocumentCountLimitStartThreshold() {
+                                        return 0;
+                                    }
+
+                                    @Override
+                                    public int getMaxSuggestionCount() {
+                                        return Integer.MAX_VALUE;
+                                    }
+
+                                    @Override
+                                    public int getMaxOpenBlobCount() {
+                                        return Integer.MAX_VALUE;
+                                    }
+                                },
+                                new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        ALWAYS_OPTIMIZE);
+
+        // Make sure the limit is maintained
+        e =
+                assertThrows(
+                        AppSearchException.class,
+                        () ->
+                                mAppSearchImpl.putDocument(
+                                        "package",
+                                        "database",
+                                        document2,
+                                        /* sendChangeNotifications= */ false,
+                                        /* logger= */ null));
+        assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_OUT_OF_SPACE);
+        assertThat(e)
+                .hasMessageThat()
+                .contains("Package \"package\" exceeded limit of 1 documents");
     }
 
     @Test
-    public void testLimitConfig_DocumentSize() throws Exception {
+    public void testLimitConfig_Remove() throws Exception {
         // Create a new mAppSearchImpl with a lower limit
         mAppSearchImpl.close();
         mAppSearchImpl =
@@ -3614,22 +5058,33 @@ public class AppSearchImplTest {
                                 new LimitConfig() {
                                     @Override
                                     public int getMaxDocumentSizeBytes() {
-                                        return 80;
+                                        return Integer.MAX_VALUE;
                                     }
 
                                     @Override
-                                    public int getMaxDocumentCount() {
-                                        return 1;
+                                    public int getPerPackageDocumentCountLimit() {
+                                        return 3;
+                                    }
+
+                                    @Override
+                                    public int getDocumentCountLimitStartThreshold() {
+                                        return 0;
                                     }
 
                                     @Override
                                     public int getMaxSuggestionCount() {
                                         return Integer.MAX_VALUE;
                                     }
+
+                                    @Override
+                                    public int getMaxOpenBlobCount() {
+                                        return Integer.MAX_VALUE;
+                                    }
                                 },
                                 new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Insert schema
@@ -3646,11 +5101,29 @@ public class AppSearchImplTest {
                         /* setSchemaStatsBuilder= */ null);
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
 
-        // Insert a document which is too large
-        GenericDocument document =
-                new GenericDocument.Builder<>(
-                                "this_namespace_is_long_to_make_the_doc_big", "id", "type")
-                        .build();
+        // Index 3 documents
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
+                new GenericDocument.Builder<>("namespace", "id1", "type").build(),
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
+                new GenericDocument.Builder<>("namespace", "id2", "type").build(),
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
+                new GenericDocument.Builder<>("namespace", "id3", "type").build(),
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+
+        // Now we should get a failure
+        GenericDocument document4 =
+                new GenericDocument.Builder<>("namespace", "id4", "type").build();
         AppSearchException e =
                 assertThrows(
                         AppSearchException.class,
@@ -3658,30 +5131,54 @@ public class AppSearchImplTest {
                                 mAppSearchImpl.putDocument(
                                         "package",
                                         "database",
-                                        document,
+                                        document4,
                                         /* sendChangeNotifications= */ false,
                                         /* logger= */ null));
         assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_OUT_OF_SPACE);
         assertThat(e)
                 .hasMessageThat()
-                .contains(
-                        "Document \"id\" for package \"package\" serialized to 99 bytes, which"
-                            + " exceeds limit of 80 bytes");
+                .contains("Package \"package\" exceeded limit of 3 documents");
 
-        // Make sure this failure didn't increase our document count. We should still be able to
-        // index 1 document.
-        GenericDocument document2 =
-                new GenericDocument.Builder<>("namespace", "id2", "type").build();
+        // Remove a document that doesn't exist
+        assertThrows(
+                AppSearchException.class,
+                () ->
+                        mAppSearchImpl.remove(
+                                "package",
+                                "database",
+                                "namespace",
+                                "id4",
+                                /* removeStatsBuilder= */ null));
+
+        // Should still fail
+        e =
+                assertThrows(
+                        AppSearchException.class,
+                        () ->
+                                mAppSearchImpl.putDocument(
+                                        "package",
+                                        "database",
+                                        document4,
+                                        /* sendChangeNotifications= */ false,
+                                        /* logger= */ null));
+        assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_OUT_OF_SPACE);
+        assertThat(e)
+                .hasMessageThat()
+                .contains("Package \"package\" exceeded limit of 3 documents");
+
+        // Remove a document that does exist
+        mAppSearchImpl.remove(
+                "package", "database", "namespace", "id2", /* removeStatsBuilder= */ null);
+
+        // Now doc4 should work
         mAppSearchImpl.putDocument(
                 "package",
                 "database",
-                document2,
+                document4,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
 
-        // Now we should get a failure
-        GenericDocument document3 =
-                new GenericDocument.Builder<>("namespace", "id3", "type").build();
+        // The next one should fail again
         e =
                 assertThrows(
                         AppSearchException.class,
@@ -3689,17 +5186,18 @@ public class AppSearchImplTest {
                                 mAppSearchImpl.putDocument(
                                         "package",
                                         "database",
-                                        document3,
+                                        new GenericDocument.Builder<>("namespace", "id5", "type")
+                                                .build(),
                                         /* sendChangeNotifications= */ false,
                                         /* logger= */ null));
         assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_OUT_OF_SPACE);
         assertThat(e)
                 .hasMessageThat()
-                .contains("Package \"package\" exceeded limit of 1 documents");
+                .contains("Package \"package\" exceeded limit of 3 documents");
     }
 
     @Test
-    public void testLimitConfig_Init() throws Exception {
+    public void testLimitConfig_DifferentPackages() throws Exception {
         // Create a new mAppSearchImpl with a lower limit
         mAppSearchImpl.close();
         File tempFolder = mTemporaryFolder.newFolder();
@@ -3710,22 +5208,33 @@ public class AppSearchImplTest {
                                 new LimitConfig() {
                                     @Override
                                     public int getMaxDocumentSizeBytes() {
-                                        return 80;
+                                        return Integer.MAX_VALUE;
                                     }
 
                                     @Override
-                                    public int getMaxDocumentCount() {
-                                        return 1;
+                                    public int getPerPackageDocumentCountLimit() {
+                                        return 2;
+                                    }
+
+                                    @Override
+                                    public int getDocumentCountLimitStartThreshold() {
+                                        return 0;
                                     }
 
                                     @Override
                                     public int getMaxSuggestionCount() {
                                         return Integer.MAX_VALUE;
                                     }
+
+                                    @Override
+                                    public int getMaxOpenBlobCount() {
+                                        return Integer.MAX_VALUE;
+                                    }
                                 },
                                 new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Insert schema
@@ -3733,8 +5242,38 @@ public class AppSearchImplTest {
                 Collections.singletonList(new AppSearchSchema.Builder("type").build());
         InternalSetSchemaResponse internalSetSchemaResponse =
                 mAppSearchImpl.setSchema(
-                        "package",
-                        "database",
+                        "package1",
+                        "database1",
+                        schemas,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+        internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package1",
+                        "database2",
+                        schemas,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+        internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package2",
+                        "database1",
+                        schemas,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+        internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package2",
+                        "database2",
                         schemas,
                         /* visibilityConfigs= */ Collections.emptyList(),
                         /* forceOverride= */ false,
@@ -3742,33 +5281,46 @@ public class AppSearchImplTest {
                         /* setSchemaStatsBuilder= */ null);
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
 
-        // Index a document
+        // Index documents in package1/database1
         mAppSearchImpl.putDocument(
-                "package",
-                "database",
+                "package1",
+                "database1",
                 new GenericDocument.Builder<>("namespace", "id1", "type").build(),
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
+        mAppSearchImpl.putDocument(
+                "package1",
+                "database2",
+                new GenericDocument.Builder<>("namespace", "id2", "type").build(),
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
 
-        // Now we should get a failure
-        GenericDocument document2 =
-                new GenericDocument.Builder<>("namespace", "id2", "type").build();
+        // Indexing a third doc into package1 should fail (here we use database3)
         AppSearchException e =
                 assertThrows(
                         AppSearchException.class,
                         () ->
                                 mAppSearchImpl.putDocument(
-                                        "package",
-                                        "database",
-                                        document2,
+                                        "package1",
+                                        "database3",
+                                        new GenericDocument.Builder<>("namespace", "id3", "type")
+                                                .build(),
                                         /* sendChangeNotifications= */ false,
                                         /* logger= */ null));
         assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_OUT_OF_SPACE);
         assertThat(e)
                 .hasMessageThat()
-                .contains("Package \"package\" exceeded limit of 1 documents");
+                .contains("Package \"package1\" exceeded limit of 2 documents");
 
-        // Close and reinitialize AppSearchImpl
+        // Indexing a doc into package2 should succeed
+        mAppSearchImpl.putDocument(
+                "package2",
+                "database1",
+                new GenericDocument.Builder<>("namespace", "id1", "type").build(),
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+
+        // Reinitialize to make sure packages are parsed correctly on init
         mAppSearchImpl.close();
         mAppSearchImpl =
                 AppSearchImpl.create(
@@ -3777,43 +5329,80 @@ public class AppSearchImplTest {
                                 new LimitConfig() {
                                     @Override
                                     public int getMaxDocumentSizeBytes() {
-                                        return 80;
+                                        return Integer.MAX_VALUE;
                                     }
 
                                     @Override
-                                    public int getMaxDocumentCount() {
-                                        return 1;
+                                    public int getPerPackageDocumentCountLimit() {
+                                        return 2;
+                                    }
+
+                                    @Override
+                                    public int getDocumentCountLimitStartThreshold() {
+                                        return 0;
                                     }
 
                                     @Override
                                     public int getMaxSuggestionCount() {
                                         return Integer.MAX_VALUE;
                                     }
+
+                                    @Override
+                                    public int getMaxOpenBlobCount() {
+                                        return Integer.MAX_VALUE;
+                                    }
                                 },
                                 new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
-        // Make sure the limit is maintained
+        // package1 should still be out of space
         e =
                 assertThrows(
                         AppSearchException.class,
                         () ->
                                 mAppSearchImpl.putDocument(
-                                        "package",
-                                        "database",
-                                        document2,
+                                        "package1",
+                                        "database4",
+                                        new GenericDocument.Builder<>("namespace", "id4", "type")
+                                                .build(),
                                         /* sendChangeNotifications= */ false,
                                         /* logger= */ null));
         assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_OUT_OF_SPACE);
         assertThat(e)
                 .hasMessageThat()
-                .contains("Package \"package\" exceeded limit of 1 documents");
+                .contains("Package \"package1\" exceeded limit of 2 documents");
+
+        // package2 has room for one more
+        mAppSearchImpl.putDocument(
+                "package2",
+                "database2",
+                new GenericDocument.Builder<>("namespace", "id2", "type").build(),
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+
+        // now package2 really is out of space
+        e =
+                assertThrows(
+                        AppSearchException.class,
+                        () ->
+                                mAppSearchImpl.putDocument(
+                                        "package2",
+                                        "database3",
+                                        new GenericDocument.Builder<>("namespace", "id3", "type")
+                                                .build(),
+                                        /* sendChangeNotifications= */ false,
+                                        /* logger= */ null));
+        assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_OUT_OF_SPACE);
+        assertThat(e)
+                .hasMessageThat()
+                .contains("Package \"package2\" exceeded limit of 2 documents");
     }
 
     @Test
-    public void testLimitConfig_Remove() throws Exception {
+    public void testLimitConfig_RemoveByQuery() throws Exception {
         // Create a new mAppSearchImpl with a lower limit
         mAppSearchImpl.close();
         mAppSearchImpl =
@@ -3827,23 +5416,45 @@ public class AppSearchImplTest {
                                     }
 
                                     @Override
-                                    public int getMaxDocumentCount() {
+                                    public int getPerPackageDocumentCountLimit() {
                                         return 3;
                                     }
 
+                                    @Override
+                                    public int getDocumentCountLimitStartThreshold() {
+                                        return 0;
+                                    }
+
                                     @Override
                                     public int getMaxSuggestionCount() {
                                         return Integer.MAX_VALUE;
                                     }
+
+                                    @Override
+                                    public int getMaxOpenBlobCount() {
+                                        return Integer.MAX_VALUE;
+                                    }
                                 },
                                 new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Insert schema
         List<AppSearchSchema> schemas =
-                Collections.singletonList(new AppSearchSchema.Builder("type").build());
+                Collections.singletonList(
+                        new AppSearchSchema.Builder("type")
+                                .addProperty(
+                                        new AppSearchSchema.StringPropertyConfig.Builder("body")
+                                                .setIndexingType(
+                                                        AppSearchSchema.StringPropertyConfig
+                                                                .INDEXING_TYPE_PREFIXES)
+                                                .setTokenizerType(
+                                                        AppSearchSchema.StringPropertyConfig
+                                                                .TOKENIZER_TYPE_PLAIN)
+                                                .build())
+                                .build());
         InternalSetSchemaResponse internalSetSchemaResponse =
                 mAppSearchImpl.setSchema(
                         "package",
@@ -3859,19 +5470,25 @@ public class AppSearchImplTest {
         mAppSearchImpl.putDocument(
                 "package",
                 "database",
-                new GenericDocument.Builder<>("namespace", "id1", "type").build(),
+                new GenericDocument.Builder<>("namespace", "id1", "type")
+                        .setPropertyString("body", "tablet")
+                        .build(),
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
         mAppSearchImpl.putDocument(
                 "package",
                 "database",
-                new GenericDocument.Builder<>("namespace", "id2", "type").build(),
+                new GenericDocument.Builder<>("namespace", "id2", "type")
+                        .setPropertyString("body", "tabby")
+                        .build(),
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
         mAppSearchImpl.putDocument(
                 "package",
                 "database",
-                new GenericDocument.Builder<>("namespace", "id3", "type").build(),
+                new GenericDocument.Builder<>("namespace", "id3", "type")
+                        .setPropertyString("body", "grabby")
+                        .build(),
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
 
@@ -3893,16 +5510,13 @@ public class AppSearchImplTest {
                 .hasMessageThat()
                 .contains("Package \"package\" exceeded limit of 3 documents");
 
-        // Remove a document that doesn't exist
-        assertThrows(
-                AppSearchException.class,
-                () ->
-                        mAppSearchImpl.remove(
-                                "package",
-                                "database",
-                                "namespace",
-                                "id4",
-                                /* removeStatsBuilder= */ null));
+        // Run removebyquery, deleting nothing
+        mAppSearchImpl.removeByQuery(
+                "package",
+                "database",
+                "nothing",
+                new SearchSpec.Builder().build(),
+                /* removeStatsBuilder= */ null);
 
         // Should still fail
         e =
@@ -3920,38 +5534,172 @@ public class AppSearchImplTest {
                 .hasMessageThat()
                 .contains("Package \"package\" exceeded limit of 3 documents");
 
-        // Remove a document that does exist
-        mAppSearchImpl.remove(
-                "package", "database", "namespace", "id2", /* removeStatsBuilder= */ null);
+        // Remove "tab*"
+        mAppSearchImpl.removeByQuery(
+                "package",
+                "database",
+                "tab",
+                new SearchSpec.Builder().build(),
+                /* removeStatsBuilder= */ null);
+
+        // Now doc4 and doc5 should work
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
+                document4,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
+                new GenericDocument.Builder<>("namespace", "id5", "type").build(),
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+
+        // We only deleted 2 docs so the next one should fail again
+        e =
+                assertThrows(
+                        AppSearchException.class,
+                        () ->
+                                mAppSearchImpl.putDocument(
+                                        "package",
+                                        "database",
+                                        new GenericDocument.Builder<>("namespace", "id6", "type")
+                                                .build(),
+                                        /* sendChangeNotifications= */ false,
+                                        /* logger= */ null));
+        assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_OUT_OF_SPACE);
+        assertThat(e)
+                .hasMessageThat()
+                .contains("Package \"package\" exceeded limit of 3 documents");
+    }
+
+    @Test
+    public void testRemoveByQuery_withJoinSpec_throwsException() {
+        Exception e =
+                assertThrows(
+                        IllegalArgumentException.class,
+                        () ->
+                                mAppSearchImpl.removeByQuery(
+                                        /* packageName= */ "",
+                                        /* databaseName= */ "",
+                                        /* queryExpression= */ "",
+                                        new SearchSpec.Builder()
+                                                .setJoinSpec(
+                                                        new JoinSpec.Builder("childProp").build())
+                                                .build(),
+                                        null));
+        assertThat(e.getMessage())
+                .isEqualTo("JoinSpec not allowed in removeByQuery, but JoinSpec was provided");
+    }
+
+    @Test
+    public void testLimitConfig_Replace() throws Exception {
+        // Create a new mAppSearchImpl with a lower limit
+        mAppSearchImpl.close();
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        mTemporaryFolder.newFolder(),
+                        new AppSearchConfigImpl(
+                                new LimitConfig() {
+                                    @Override
+                                    public int getMaxDocumentSizeBytes() {
+                                        return Integer.MAX_VALUE;
+                                    }
+
+                                    @Override
+                                    public int getPerPackageDocumentCountLimit() {
+                                        return 2;
+                                    }
+
+                                    @Override
+                                    public int getDocumentCountLimitStartThreshold() {
+                                        return 0;
+                                    }
+
+                                    @Override
+                                    public int getMaxSuggestionCount() {
+                                        return Integer.MAX_VALUE;
+                                    }
+
+                                    @Override
+                                    public int getMaxOpenBlobCount() {
+                                        return Integer.MAX_VALUE;
+                                    }
+                                },
+                                new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        ALWAYS_OPTIMIZE);
+
+        // Insert schema
+        List<AppSearchSchema> schemas =
+                Collections.singletonList(
+                        new AppSearchSchema.Builder("type")
+                                .addProperty(
+                                        new AppSearchSchema.StringPropertyConfig.Builder("body")
+                                                .build())
+                                .build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package",
+                        "database",
+                        schemas,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+
+        // Index a document
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
+                new GenericDocument.Builder<>("namespace", "id1", "type")
+                        .setPropertyString("body", "id1.orig")
+                        .build(),
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+        // Replace it with another doc
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
+                new GenericDocument.Builder<>("namespace", "id1", "type")
+                        .setPropertyString("body", "id1.new")
+                        .build(),
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
 
-        // Now doc4 should work
+        // Index id2. This should pass but only because we check for replacements.
         mAppSearchImpl.putDocument(
                 "package",
                 "database",
-                document4,
+                new GenericDocument.Builder<>("namespace", "id2", "type").build(),
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
 
-        // The next one should fail again
-        e =
+        // Now we should get a failure on id3
+        GenericDocument document3 =
+                new GenericDocument.Builder<>("namespace", "id3", "type").build();
+        AppSearchException e =
                 assertThrows(
                         AppSearchException.class,
                         () ->
                                 mAppSearchImpl.putDocument(
                                         "package",
                                         "database",
-                                        new GenericDocument.Builder<>("namespace", "id5", "type")
-                                                .build(),
+                                        document3,
                                         /* sendChangeNotifications= */ false,
                                         /* logger= */ null));
         assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_OUT_OF_SPACE);
         assertThat(e)
                 .hasMessageThat()
-                .contains("Package \"package\" exceeded limit of 3 documents");
+                .contains("Package \"package\" exceeded limit of 2 documents");
     }
 
     @Test
-    public void testLimitConfig_DifferentPackages() throws Exception {
+    public void testLimitConfig_ReplaceReinit() throws Exception {
         // Create a new mAppSearchImpl with a lower limit
         mAppSearchImpl.close();
         File tempFolder = mTemporaryFolder.newFolder();
@@ -3966,57 +5714,43 @@ public class AppSearchImplTest {
                                     }
 
                                     @Override
-                                    public int getMaxDocumentCount() {
+                                    public int getPerPackageDocumentCountLimit() {
                                         return 2;
                                     }
 
+                                    @Override
+                                    public int getDocumentCountLimitStartThreshold() {
+                                        return 0;
+                                    }
+
                                     @Override
                                     public int getMaxSuggestionCount() {
                                         return Integer.MAX_VALUE;
                                     }
+
+                                    @Override
+                                    public int getMaxOpenBlobCount() {
+                                        return Integer.MAX_VALUE;
+                                    }
                                 },
                                 new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Insert schema
         List<AppSearchSchema> schemas =
-                Collections.singletonList(new AppSearchSchema.Builder("type").build());
+                Collections.singletonList(
+                        new AppSearchSchema.Builder("type")
+                                .addProperty(
+                                        new AppSearchSchema.StringPropertyConfig.Builder("body")
+                                                .build())
+                                .build());
         InternalSetSchemaResponse internalSetSchemaResponse =
                 mAppSearchImpl.setSchema(
-                        "package1",
-                        "database1",
-                        schemas,
-                        /* visibilityConfigs= */ Collections.emptyList(),
-                        /* forceOverride= */ false,
-                        /* version= */ 0,
-                        /* setSchemaStatsBuilder= */ null);
-        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
-        internalSetSchemaResponse =
-                mAppSearchImpl.setSchema(
-                        "package1",
-                        "database2",
-                        schemas,
-                        /* visibilityConfigs= */ Collections.emptyList(),
-                        /* forceOverride= */ false,
-                        /* version= */ 0,
-                        /* setSchemaStatsBuilder= */ null);
-        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
-        internalSetSchemaResponse =
-                mAppSearchImpl.setSchema(
-                        "package2",
-                        "database1",
-                        schemas,
-                        /* visibilityConfigs= */ Collections.emptyList(),
-                        /* forceOverride= */ false,
-                        /* version= */ 0,
-                        /* setSchemaStatsBuilder= */ null);
-        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
-        internalSetSchemaResponse =
-                mAppSearchImpl.setSchema(
-                        "package2",
-                        "database2",
+                        "package",
+                        "database",
                         schemas,
                         /* visibilityConfigs= */ Collections.emptyList(),
                         /* forceOverride= */ false,
@@ -4024,47 +5758,94 @@ public class AppSearchImplTest {
                         /* setSchemaStatsBuilder= */ null);
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
 
-        // Index documents in package1/database1
+        // Index a document
         mAppSearchImpl.putDocument(
-                "package1",
-                "database1",
-                new GenericDocument.Builder<>("namespace", "id1", "type").build(),
+                "package",
+                "database",
+                new GenericDocument.Builder<>("namespace", "id1", "type")
+                        .setPropertyString("body", "id1.orig")
+                        .build(),
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
+        // Replace it with another doc
         mAppSearchImpl.putDocument(
-                "package1",
-                "database2",
+                "package",
+                "database",
+                new GenericDocument.Builder<>("namespace", "id1", "type")
+                        .setPropertyString("body", "id1.new")
+                        .build(),
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+
+        // Reinitialize to make sure replacements are correctly accounted for by init
+        mAppSearchImpl.close();
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        tempFolder,
+                        new AppSearchConfigImpl(
+                                new LimitConfig() {
+                                    @Override
+                                    public int getMaxDocumentSizeBytes() {
+                                        return Integer.MAX_VALUE;
+                                    }
+
+                                    @Override
+                                    public int getPerPackageDocumentCountLimit() {
+                                        return 2;
+                                    }
+
+                                    @Override
+                                    public int getDocumentCountLimitStartThreshold() {
+                                        return 0;
+                                    }
+
+                                    @Override
+                                    public int getMaxSuggestionCount() {
+                                        return Integer.MAX_VALUE;
+                                    }
+
+                                    @Override
+                                    public int getMaxOpenBlobCount() {
+                                        return Integer.MAX_VALUE;
+                                    }
+                                },
+                                new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        ALWAYS_OPTIMIZE);
+
+        // Index id2. This should pass but only because we check for replacements.
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
                 new GenericDocument.Builder<>("namespace", "id2", "type").build(),
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
 
-        // Indexing a third doc into package1 should fail (here we use database3)
+        // Now we should get a failure on id3
+        GenericDocument document3 =
+                new GenericDocument.Builder<>("namespace", "id3", "type").build();
         AppSearchException e =
                 assertThrows(
                         AppSearchException.class,
                         () ->
                                 mAppSearchImpl.putDocument(
-                                        "package1",
-                                        "database3",
-                                        new GenericDocument.Builder<>("namespace", "id3", "type")
-                                                .build(),
+                                        "package",
+                                        "database",
+                                        document3,
                                         /* sendChangeNotifications= */ false,
                                         /* logger= */ null));
         assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_OUT_OF_SPACE);
         assertThat(e)
                 .hasMessageThat()
-                .contains("Package \"package1\" exceeded limit of 2 documents");
-
-        // Indexing a doc into package2 should succeed
-        mAppSearchImpl.putDocument(
-                "package2",
-                "database1",
-                new GenericDocument.Builder<>("namespace", "id1", "type").build(),
-                /* sendChangeNotifications= */ false,
-                /* logger= */ null);
+                .contains("Package \"package\" exceeded limit of 2 documents");
+    }
 
-        // Reinitialize to make sure packages are parsed correctly on init
+    @Test
+    public void testLimitConfig_suggestion() throws Exception {
         mAppSearchImpl.close();
+        File tempFolder = mTemporaryFolder.newFolder();
         mAppSearchImpl =
                 AppSearchImpl.create(
                         tempFolder,
@@ -4076,70 +5857,130 @@ public class AppSearchImplTest {
                                     }
 
                                     @Override
-                                    public int getMaxDocumentCount() {
-                                        return 2;
+                                    public int getPerPackageDocumentCountLimit() {
+                                        return Integer.MAX_VALUE;
+                                    }
+
+                                    @Override
+                                    public int getDocumentCountLimitStartThreshold() {
+                                        return 0;
                                     }
 
                                     @Override
                                     public int getMaxSuggestionCount() {
+                                        return 2;
+                                    }
+
+                                    @Override
+                                    public int getMaxOpenBlobCount() {
                                         return Integer.MAX_VALUE;
                                     }
                                 },
                                 new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
-        // package1 should still be out of space
-        e =
+        AppSearchException e =
                 assertThrows(
                         AppSearchException.class,
                         () ->
-                                mAppSearchImpl.putDocument(
-                                        "package1",
-                                        "database4",
-                                        new GenericDocument.Builder<>("namespace", "id4", "type")
-                                                .build(),
-                                        /* sendChangeNotifications= */ false,
-                                        /* logger= */ null));
-        assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_OUT_OF_SPACE);
+                                mAppSearchImpl.searchSuggestion(
+                                        "package",
+                                        "database",
+                                        /* suggestionQueryExpression= */ "t",
+                                        new SearchSuggestionSpec.Builder(/* totalResultCount= */ 10)
+                                                .build()));
+        assertThat(e.getResultCode()).isEqualTo(RESULT_INVALID_ARGUMENT);
         assertThat(e)
                 .hasMessageThat()
-                .contains("Package \"package1\" exceeded limit of 2 documents");
+                .contains("Trying to get 10 suggestion results, which exceeds limit of 2");
+    }
 
-        // package2 has room for one more
+    @Test
+    public void testLimitConfig_belowLimitStartThreshold_limitHasNoEffect() throws Exception {
+        // Create a new mAppSearchImpl with a low limit, but a higher limit start threshold.
+        mAppSearchImpl.close();
+        File tempFolder = mTemporaryFolder.newFolder();
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        tempFolder,
+                        new AppSearchConfigImpl(
+                                new LimitConfig() {
+                                    @Override
+                                    public int getMaxDocumentSizeBytes() {
+                                        return Integer.MAX_VALUE;
+                                    }
+
+                                    @Override
+                                    public int getPerPackageDocumentCountLimit() {
+                                        return 1;
+                                    }
+
+                                    @Override
+                                    public int getDocumentCountLimitStartThreshold() {
+                                        return 3;
+                                    }
+
+                                    @Override
+                                    public int getMaxSuggestionCount() {
+                                        return Integer.MAX_VALUE;
+                                    }
+
+                                    @Override
+                                    public int getMaxOpenBlobCount() {
+                                        return Integer.MAX_VALUE;
+                                    }
+                                },
+                                new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        ALWAYS_OPTIMIZE);
+
+        // Insert schema
+        List<AppSearchSchema> schemas =
+                Collections.singletonList(new AppSearchSchema.Builder("type").build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package",
+                        "database",
+                        schemas,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+
+        // Index a document
         mAppSearchImpl.putDocument(
-                "package2",
-                "database2",
-                new GenericDocument.Builder<>("namespace", "id2", "type").build(),
+                "package",
+                "database",
+                new GenericDocument.Builder<>("namespace", "id1", "type").build(),
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+
+        // We should still be able to index another document even though we are over the
+        // getPerPackageDocumentCountLimit threshold.
+        GenericDocument document2 =
+                new GenericDocument.Builder<>("namespace", "id2", "type").build();
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
+                document2,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
-
-        // now package2 really is out of space
-        e =
-                assertThrows(
-                        AppSearchException.class,
-                        () ->
-                                mAppSearchImpl.putDocument(
-                                        "package2",
-                                        "database3",
-                                        new GenericDocument.Builder<>("namespace", "id3", "type")
-                                                .build(),
-                                        /* sendChangeNotifications= */ false,
-                                        /* logger= */ null));
-        assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_OUT_OF_SPACE);
-        assertThat(e)
-                .hasMessageThat()
-                .contains("Package \"package2\" exceeded limit of 2 documents");
     }
 
     @Test
-    public void testLimitConfig_RemoveByQuery() throws Exception {
-        // Create a new mAppSearchImpl with a lower limit
+    public void testLimitConfig_aboveLimitStartThreshold_limitTakesEffect() throws Exception {
+        // Create a new mAppSearchImpl with a low limit, but a higher limit start threshold.
         mAppSearchImpl.close();
+        File tempFolder = mTemporaryFolder.newFolder();
         mAppSearchImpl =
                 AppSearchImpl.create(
-                        mTemporaryFolder.newFolder(),
+                        tempFolder,
                         new AppSearchConfigImpl(
                                 new LimitConfig() {
                                     @Override
@@ -4148,7 +5989,12 @@ public class AppSearchImplTest {
                                     }
 
                                     @Override
-                                    public int getMaxDocumentCount() {
+                                    public int getPerPackageDocumentCountLimit() {
+                                        return 1;
+                                    }
+
+                                    @Override
+                                    public int getDocumentCountLimitStartThreshold() {
                                         return 3;
                                     }
 
@@ -4156,26 +6002,21 @@ public class AppSearchImplTest {
                                     public int getMaxSuggestionCount() {
                                         return Integer.MAX_VALUE;
                                     }
+
+                                    @Override
+                                    public int getMaxOpenBlobCount() {
+                                        return Integer.MAX_VALUE;
+                                    }
                                 },
                                 new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
-        // Insert schema
+        // Insert schemas for thress packages
         List<AppSearchSchema> schemas =
-                Collections.singletonList(
-                        new AppSearchSchema.Builder("type")
-                                .addProperty(
-                                        new AppSearchSchema.StringPropertyConfig.Builder("body")
-                                                .setIndexingType(
-                                                        AppSearchSchema.StringPropertyConfig
-                                                                .INDEXING_TYPE_PREFIXES)
-                                                .setTokenizerType(
-                                                        AppSearchSchema.StringPropertyConfig
-                                                                .TOKENIZER_TYPE_PLAIN)
-                                                .build())
-                                .build());
+                Collections.singletonList(new AppSearchSchema.Builder("type").build());
         InternalSetSchemaResponse internalSetSchemaResponse =
                 mAppSearchImpl.setSchema(
                         "package",
@@ -4186,34 +6027,58 @@ public class AppSearchImplTest {
                         /* version= */ 0,
                         /* setSchemaStatsBuilder= */ null);
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+        internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package2",
+                        "database",
+                        schemas,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+        internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package3",
+                        "database",
+                        schemas,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
 
-        // Index 3 documents
+        // Index a document
         mAppSearchImpl.putDocument(
                 "package",
                 "database",
-                new GenericDocument.Builder<>("namespace", "id1", "type")
-                        .setPropertyString("body", "tablet")
-                        .build(),
+                new GenericDocument.Builder<>("namespace", "id1", "type").build(),
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
+
+        // We should still be able to index another document even though we are over the
+        // getPerPackageDocumentCountLimit threshold.
+        GenericDocument document2 =
+                new GenericDocument.Builder<>("namespace", "id2", "type").build();
         mAppSearchImpl.putDocument(
                 "package",
                 "database",
-                new GenericDocument.Builder<>("namespace", "id2", "type")
-                        .setPropertyString("body", "tabby")
-                        .build(),
+                document2,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
+
+        // Index a document in another package. We will now be at the limit start threshold.
+        GenericDocument document3 =
+                new GenericDocument.Builder<>("namespace", "id3", "type").build();
         mAppSearchImpl.putDocument(
-                "package",
+                "package2",
                 "database",
-                new GenericDocument.Builder<>("namespace", "id3", "type")
-                        .setPropertyString("body", "grabby")
-                        .build(),
+                document3,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
 
-        // Now we should get a failure
+        // Both packages are at the maxPerPackageDocumentLimitCount and the limit is in force.
+        // Neither should be able to add another document.
         GenericDocument document4 =
                 new GenericDocument.Builder<>("namespace", "id4", "type").build();
         AppSearchException e =
@@ -4229,23 +6094,14 @@ public class AppSearchImplTest {
         assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_OUT_OF_SPACE);
         assertThat(e)
                 .hasMessageThat()
-                .contains("Package \"package\" exceeded limit of 3 documents");
-
-        // Run removebyquery, deleting nothing
-        mAppSearchImpl.removeByQuery(
-                "package",
-                "database",
-                "nothing",
-                new SearchSpec.Builder().build(),
-                /* removeStatsBuilder= */ null);
+                .contains("Package \"package\" exceeded limit of 1 documents");
 
-        // Should still fail
         e =
                 assertThrows(
                         AppSearchException.class,
                         () ->
                                 mAppSearchImpl.putDocument(
-                                        "package",
+                                        "package2",
                                         "database",
                                         document4,
                                         /* sendChangeNotifications= */ false,
@@ -4253,74 +6109,117 @@ public class AppSearchImplTest {
         assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_OUT_OF_SPACE);
         assertThat(e)
                 .hasMessageThat()
-                .contains("Package \"package\" exceeded limit of 3 documents");
+                .contains("Package \"package2\" exceeded limit of 1 documents");
 
-        // Remove "tab*"
-        mAppSearchImpl.removeByQuery(
-                "package",
+        // A new package should still be able to add a document however.
+        mAppSearchImpl.putDocument(
+                "package3",
                 "database",
-                "tab",
-                new SearchSpec.Builder().build(),
-                /* removeStatsBuilder= */ null);
+                document4,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+    }
 
-        // Now doc4 and doc5 should work
+    @Test
+    public void testLimitConfig_replacement_doesntTriggerLimitStartThreshold() throws Exception {
+        // Create a new mAppSearchImpl with a low limit, but a higher limit start threshold.
+        mAppSearchImpl.close();
+        File tempFolder = mTemporaryFolder.newFolder();
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        tempFolder,
+                        new AppSearchConfigImpl(
+                                new LimitConfig() {
+                                    @Override
+                                    public int getMaxDocumentSizeBytes() {
+                                        return Integer.MAX_VALUE;
+                                    }
+
+                                    @Override
+                                    public int getPerPackageDocumentCountLimit() {
+                                        return 1;
+                                    }
+
+                                    @Override
+                                    public int getDocumentCountLimitStartThreshold() {
+                                        return 3;
+                                    }
+
+                                    @Override
+                                    public int getMaxSuggestionCount() {
+                                        return Integer.MAX_VALUE;
+                                    }
+
+                                    @Override
+                                    public int getMaxOpenBlobCount() {
+                                        return Integer.MAX_VALUE;
+                                    }
+                                },
+                                new LocalStorageIcingOptionsConfig()),
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        ALWAYS_OPTIMIZE);
+
+        // Insert schema
+        List<AppSearchSchema> schemas =
+                Collections.singletonList(new AppSearchSchema.Builder("type").build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package",
+                        "database",
+                        schemas,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+
+        // Index two documents
         mAppSearchImpl.putDocument(
                 "package",
                 "database",
-                document4,
+                new GenericDocument.Builder<>("namespace", "id1", "type").build(),
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
+
+        GenericDocument document2 =
+                new GenericDocument.Builder<>("namespace", "id2", "type").build();
         mAppSearchImpl.putDocument(
                 "package",
                 "database",
-                new GenericDocument.Builder<>("namespace", "id5", "type").build(),
+                document2,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
 
-        // We only deleted 2 docs so the next one should fail again
-        e =
-                assertThrows(
-                        AppSearchException.class,
-                        () ->
-                                mAppSearchImpl.putDocument(
-                                        "package",
-                                        "database",
-                                        new GenericDocument.Builder<>("namespace", "id6", "type")
-                                                .build(),
-                                        /* sendChangeNotifications= */ false,
-                                        /* logger= */ null));
-        assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_OUT_OF_SPACE);
-        assertThat(e)
-                .hasMessageThat()
-                .contains("Package \"package\" exceeded limit of 3 documents");
-    }
+        // Now Index a replacement. This should not trigger the DocumentCountLimitStartThreshold
+        // because the total number of living documents should still be two.
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
+                document2,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
 
-    @Test
-    public void testRemoveByQuery_withJoinSpec_throwsException() {
-        Exception e =
-                assertThrows(
-                        IllegalArgumentException.class,
-                        () ->
-                                mAppSearchImpl.removeByQuery(
-                                        /* packageName= */ "",
-                                        /* databaseName= */ "",
-                                        /* queryExpression= */ "",
-                                        new SearchSpec.Builder()
-                                                .setJoinSpec(
-                                                        new JoinSpec.Builder("childProp").build())
-                                                .build(),
-                                        null));
-        assertThat(e.getMessage())
-                .isEqualTo("JoinSpec not allowed in removeByQuery, but JoinSpec was provided");
+        // We should be able to index one more document before triggering the limit.
+        GenericDocument document3 =
+                new GenericDocument.Builder<>("namespace", "id3", "type").build();
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
+                document3,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
     }
 
     @Test
-    public void testLimitConfig_Replace() throws Exception {
-        // Create a new mAppSearchImpl with a lower limit
+    public void testLimitConfig_remove_deactivatesDocumentCountLimit() throws Exception {
+        // Create a new mAppSearchImpl with a low limit, but a higher limit start threshold.
         mAppSearchImpl.close();
+        File tempFolder = mTemporaryFolder.newFolder();
         mAppSearchImpl =
                 AppSearchImpl.create(
-                        mTemporaryFolder.newFolder(),
+                        tempFolder,
                         new AppSearchConfigImpl(
                                 new LimitConfig() {
                                     @Override
@@ -4329,28 +6228,34 @@ public class AppSearchImplTest {
                                     }
 
                                     @Override
-                                    public int getMaxDocumentCount() {
-                                        return 2;
+                                    public int getPerPackageDocumentCountLimit() {
+                                        return 1;
+                                    }
+
+                                    @Override
+                                    public int getDocumentCountLimitStartThreshold() {
+                                        return 3;
                                     }
 
                                     @Override
                                     public int getMaxSuggestionCount() {
                                         return Integer.MAX_VALUE;
                                     }
+
+                                    @Override
+                                    public int getMaxOpenBlobCount() {
+                                        return Integer.MAX_VALUE;
+                                    }
                                 },
                                 new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Insert schema
         List<AppSearchSchema> schemas =
-                Collections.singletonList(
-                        new AppSearchSchema.Builder("type")
-                                .addProperty(
-                                        new AppSearchSchema.StringPropertyConfig.Builder("body")
-                                                .build())
-                                .build());
+                Collections.singletonList(new AppSearchSchema.Builder("type").build());
         InternalSetSchemaResponse internalSetSchemaResponse =
                 mAppSearchImpl.setSchema(
                         "package",
@@ -4361,37 +6266,58 @@ public class AppSearchImplTest {
                         /* version= */ 0,
                         /* setSchemaStatsBuilder= */ null);
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+        internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package2",
+                        "database",
+                        schemas,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
 
-        // Index a document
+        // Index three documents in "package" and one in "package2". This will mean four total
+        // documents in the system which will exceed the limit start threshold of three. The limit
+        // will be in force and neither package will be able to documents.
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
+                new GenericDocument.Builder<>("namespace", "id1", "type").build(),
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+
+        GenericDocument document2 =
+                new GenericDocument.Builder<>("namespace", "id2", "type").build();
         mAppSearchImpl.putDocument(
                 "package",
                 "database",
-                new GenericDocument.Builder<>("namespace", "id1", "type")
-                        .setPropertyString("body", "id1.orig")
-                        .build(),
+                document2,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
-        // Replace it with another doc
+
+        GenericDocument document3 =
+                new GenericDocument.Builder<>("namespace", "id3", "type").build();
         mAppSearchImpl.putDocument(
                 "package",
                 "database",
-                new GenericDocument.Builder<>("namespace", "id1", "type")
-                        .setPropertyString("body", "id1.new")
-                        .build(),
+                document3,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
 
-        // Index id2. This should pass but only because we check for replacements.
+        GenericDocument document4 =
+                new GenericDocument.Builder<>("namespace", "id4", "type").build();
         mAppSearchImpl.putDocument(
-                "package",
+                "package2",
                 "database",
-                new GenericDocument.Builder<>("namespace", "id2", "type").build(),
+                document4,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
 
-        // Now we should get a failure on id3
-        GenericDocument document3 =
-                new GenericDocument.Builder<>("namespace", "id3", "type").build();
+        // The limit is in force. We should be unable to index another document. Even after we
+        // delete one document, the system is still over the limit start threshold.
+        GenericDocument document5 =
+                new GenericDocument.Builder<>("namespace", "id5", "type").build();
         AppSearchException e =
                 assertThrows(
                         AppSearchException.class,
@@ -4399,18 +6325,46 @@ public class AppSearchImplTest {
                                 mAppSearchImpl.putDocument(
                                         "package",
                                         "database",
-                                        document3,
+                                        document5,
                                         /* sendChangeNotifications= */ false,
                                         /* logger= */ null));
         assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_OUT_OF_SPACE);
         assertThat(e)
                 .hasMessageThat()
-                .contains("Package \"package\" exceeded limit of 2 documents");
+                .contains("Package \"package\" exceeded limit of 1 documents");
+
+        mAppSearchImpl.remove(
+                "package", "database", "namespace", "id2", /* removeStatsBuilder= */ null);
+        e =
+                assertThrows(
+                        AppSearchException.class,
+                        () ->
+                                mAppSearchImpl.putDocument(
+                                        "package",
+                                        "database",
+                                        document5,
+                                        /* sendChangeNotifications= */ false,
+                                        /* logger= */ null));
+        assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_OUT_OF_SPACE);
+        assertThat(e)
+                .hasMessageThat()
+                .contains("Package \"package\" exceeded limit of 1 documents");
+
+        // Removing another document will bring the system below the limit start threshold. Now,
+        // adding another document can succeed.
+        mAppSearchImpl.remove(
+                "package", "database", "namespace", "id3", /* removeStatsBuilder= */ null);
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
+                document5,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
     }
 
     @Test
-    public void testLimitConfig_ReplaceReinit() throws Exception {
-        // Create a new mAppSearchImpl with a lower limit
+    public void testLimitConfig_removeByQuery_deactivatesDocumentCountLimit() throws Exception {
+        // Create a new mAppSearchImpl with a low limit, but a higher limit start threshold.
         mAppSearchImpl.close();
         File tempFolder = mTemporaryFolder.newFolder();
         mAppSearchImpl =
@@ -4424,28 +6378,55 @@ public class AppSearchImplTest {
                                     }
 
                                     @Override
-                                    public int getMaxDocumentCount() {
-                                        return 2;
+                                    public int getPerPackageDocumentCountLimit() {
+                                        return 1;
+                                    }
+
+                                    @Override
+                                    public int getDocumentCountLimitStartThreshold() {
+                                        return 3;
                                     }
 
                                     @Override
                                     public int getMaxSuggestionCount() {
                                         return Integer.MAX_VALUE;
                                     }
+
+                                    @Override
+                                    public int getMaxOpenBlobCount() {
+                                        return Integer.MAX_VALUE;
+                                    }
                                 },
                                 new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Insert schema
-        List<AppSearchSchema> schemas =
-                Collections.singletonList(
-                        new AppSearchSchema.Builder("type")
-                                .addProperty(
-                                        new AppSearchSchema.StringPropertyConfig.Builder("body")
-                                                .build())
-                                .build());
+        AppSearchSchema schema =
+                new AppSearchSchema.Builder("type")
+                        .addProperty(
+                                new AppSearchSchema.StringPropertyConfig.Builder("number")
+                                        .setIndexingType(
+                                                AppSearchSchema.StringPropertyConfig
+                                                        .INDEXING_TYPE_PREFIXES)
+                                        .setTokenizerType(
+                                                AppSearchSchema.StringPropertyConfig
+                                                        .TOKENIZER_TYPE_PLAIN)
+                                        .build())
+                        .addProperty(
+                                new AppSearchSchema.StringPropertyConfig.Builder("evenOdd")
+                                        .setIndexingType(
+                                                AppSearchSchema.StringPropertyConfig
+                                                        .INDEXING_TYPE_PREFIXES)
+                                        .setTokenizerType(
+                                                AppSearchSchema.StringPropertyConfig
+                                                        .TOKENIZER_TYPE_PLAIN)
+                                        .build())
+                        .build();
+        List<AppSearchSchema> schemas = Collections.singletonList(schema);
+
         InternalSetSchemaResponse internalSetSchemaResponse =
                 mAppSearchImpl.setSchema(
                         "package",
@@ -4456,64 +6437,74 @@ public class AppSearchImplTest {
                         /* version= */ 0,
                         /* setSchemaStatsBuilder= */ null);
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+        internalSetSchemaResponse =
+                mAppSearchImpl.setSchema(
+                        "package2",
+                        "database",
+                        schemas,
+                        /* visibilityConfigs= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
 
-        // Index a document
+        // Index three documents in "package" and one in "package2". This will mean four total
+        // documents in the system which will exceed the limit start threshold of three. The limit
+        // will be in force and neither package will be able to documents.
+        GenericDocument document1 =
+                new GenericDocument.Builder<>("namespace", "id1", "type")
+                        .setPropertyString("number", "first")
+                        .setPropertyString("evenOdd", "odd")
+                        .build();
         mAppSearchImpl.putDocument(
                 "package",
                 "database",
-                new GenericDocument.Builder<>("namespace", "id1", "type")
-                        .setPropertyString("body", "id1.orig")
-                        .build(),
+                document1,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
-        // Replace it with another doc
+
+        GenericDocument document2 =
+                new GenericDocument.Builder<>("namespace", "id2", "type")
+                        .setPropertyString("number", "second")
+                        .setPropertyString("evenOdd", "even")
+                        .build();
         mAppSearchImpl.putDocument(
                 "package",
                 "database",
-                new GenericDocument.Builder<>("namespace", "id1", "type")
-                        .setPropertyString("body", "id1.new")
-                        .build(),
+                document2,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
 
-        // Reinitialize to make sure replacements are correctly accounted for by init
-        mAppSearchImpl.close();
-        mAppSearchImpl =
-                AppSearchImpl.create(
-                        tempFolder,
-                        new AppSearchConfigImpl(
-                                new LimitConfig() {
-                                    @Override
-                                    public int getMaxDocumentSizeBytes() {
-                                        return Integer.MAX_VALUE;
-                                    }
-
-                                    @Override
-                                    public int getMaxDocumentCount() {
-                                        return 2;
-                                    }
-
-                                    @Override
-                                    public int getMaxSuggestionCount() {
-                                        return Integer.MAX_VALUE;
-                                    }
-                                },
-                                new LocalStorageIcingOptionsConfig()),
-                        /* initStatsBuilder= */ null,
-                        /* visibilityChecker= */ null,
-                        ALWAYS_OPTIMIZE);
-
-        // Index id2. This should pass but only because we check for replacements.
+        GenericDocument document3 =
+                new GenericDocument.Builder<>("namespace", "id3", "type")
+                        .setPropertyString("number", "third")
+                        .setPropertyString("evenOdd", "odd")
+                        .build();
         mAppSearchImpl.putDocument(
                 "package",
                 "database",
-                new GenericDocument.Builder<>("namespace", "id2", "type").build(),
+                document3,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
 
-        // Now we should get a failure on id3
-        GenericDocument document3 =
-                new GenericDocument.Builder<>("namespace", "id3", "type").build();
+        GenericDocument document4 =
+                new GenericDocument.Builder<>("namespace", "id4", "type")
+                        .setPropertyString("number", "fourth")
+                        .setPropertyString("evenOdd", "even")
+                        .build();
+        mAppSearchImpl.putDocument(
+                "package2",
+                "database",
+                document4,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
+
+        // The limit is in force. We should be unable to index another document.
+        GenericDocument document5 =
+                new GenericDocument.Builder<>("namespace", "id5", "type")
+                        .setPropertyString("number", "five")
+                        .setPropertyString("evenOdd", "odd")
+                        .build();
         AppSearchException e =
                 assertThrows(
                         AppSearchException.class,
@@ -4521,58 +6512,232 @@ public class AppSearchImplTest {
                                 mAppSearchImpl.putDocument(
                                         "package",
                                         "database",
-                                        document3,
+                                        document5,
                                         /* sendChangeNotifications= */ false,
                                         /* logger= */ null));
         assertThat(e.getResultCode()).isEqualTo(AppSearchResult.RESULT_OUT_OF_SPACE);
         assertThat(e)
                 .hasMessageThat()
-                .contains("Package \"package\" exceeded limit of 2 documents");
+                .contains("Package \"package\" exceeded limit of 1 documents");
+
+        // Remove two documents by query. Now we should be under the limit and be able to add
+        // another document.
+        mAppSearchImpl.removeByQuery(
+                "package",
+                "database",
+                "evenOdd:odd",
+                new SearchSpec.Builder().build(),
+                /* removeStatsBuilder= */ null);
+        mAppSearchImpl.putDocument(
+                "package",
+                "database",
+                document5,
+                /* sendChangeNotifications= */ false,
+                /* logger= */ null);
     }
 
     @Test
-    public void testLimitConfig_suggestion() throws Exception {
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testLimitConfig_activeWriteFds() throws Exception {
         mAppSearchImpl.close();
         File tempFolder = mTemporaryFolder.newFolder();
+        AppSearchConfig config =
+                new AppSearchConfigImpl(
+                        new LimitConfig() {
+                            @Override
+                            public int getMaxDocumentSizeBytes() {
+                                return Integer.MAX_VALUE;
+                            }
+
+                            @Override
+                            public int getPerPackageDocumentCountLimit() {
+                                return Integer.MAX_VALUE;
+                            }
+
+                            @Override
+                            public int getDocumentCountLimitStartThreshold() {
+                                return Integer.MAX_VALUE;
+                            }
+
+                            @Override
+                            public int getMaxSuggestionCount() {
+                                return Integer.MAX_VALUE;
+                            }
+
+                            @Override
+                            public int getMaxOpenBlobCount() {
+                                return 2;
+                            }
+                        },
+                        new LocalStorageIcingOptionsConfig());
         mAppSearchImpl =
                 AppSearchImpl.create(
                         tempFolder,
-                        new AppSearchConfigImpl(
-                                new LimitConfig() {
-                                    @Override
-                                    public int getMaxDocumentSizeBytes() {
-                                        return Integer.MAX_VALUE;
-                                    }
+                        config,
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        new JetpackRevocableFileDescriptorStore(config),
+                        ALWAYS_OPTIMIZE);
+        // We could open only 2 fds per package.
+        byte[] data1 = generateRandomBytes(20 * 1024); // 20 KiB
+        byte[] digest1 = calculateDigest(data1);
+        AppSearchBlobHandle handle1 =
+                AppSearchBlobHandle.createWithSha256(digest1, "package", "db1", "ns");
+        ParcelFileDescriptor writer1 = mAppSearchImpl.openWriteBlob("package", "db1", handle1);
+
+        byte[] data2 = generateRandomBytes(20 * 1024); // 20 KiB
+        byte[] digest2 = calculateDigest(data2);
+        AppSearchBlobHandle handle2 =
+                AppSearchBlobHandle.createWithSha256(digest2, "package", "db1", "ns");
+        ParcelFileDescriptor writer2 = mAppSearchImpl.openWriteBlob("package", "db1", handle2);
+
+        // Open 3rd fd will fail.
+        byte[] data3 = generateRandomBytes(20 * 1024); // 20 KiB
+        byte[] digest3 = calculateDigest(data3);
+        AppSearchBlobHandle handle3 =
+                AppSearchBlobHandle.createWithSha256(digest3, "package", "db1", "ns");
+        AppSearchException e =
+                assertThrows(
+                        AppSearchException.class,
+                        () -> mAppSearchImpl.openWriteBlob("package", "db1", handle3));
+        assertThat(e.getResultCode()).isEqualTo(RESULT_OUT_OF_SPACE);
+        assertThat(e)
+                .hasMessageThat()
+                .contains(
+                        "Package \"package\" exceeded limit of 2 opened file descriptors. "
+                                + "Some file descriptors must be closed to open additional ones.");
+    }
 
-                                    @Override
-                                    public int getMaxDocumentCount() {
-                                        return Integer.MAX_VALUE;
-                                    }
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testLimitConfig_activeReadFds() throws Exception {
+        mAppSearchImpl.close();
+        File tempFolder = mTemporaryFolder.newFolder();
+        AppSearchConfig config =
+                new AppSearchConfigImpl(
+                        new LimitConfig() {
+                            @Override
+                            public int getMaxDocumentSizeBytes() {
+                                return Integer.MAX_VALUE;
+                            }
 
-                                    @Override
-                                    public int getMaxSuggestionCount() {
-                                        return 2;
-                                    }
-                                },
-                                new LocalStorageIcingOptionsConfig()),
+                            @Override
+                            public int getPerPackageDocumentCountLimit() {
+                                return Integer.MAX_VALUE;
+                            }
+
+                            @Override
+                            public int getDocumentCountLimitStartThreshold() {
+                                return Integer.MAX_VALUE;
+                            }
+
+                            @Override
+                            public int getMaxSuggestionCount() {
+                                return Integer.MAX_VALUE;
+                            }
+
+                            @Override
+                            public int getMaxOpenBlobCount() {
+                                return 2;
+                            }
+                        },
+                        new LocalStorageIcingOptionsConfig());
+        mAppSearchImpl =
+                AppSearchImpl.create(
+                        tempFolder,
+                        config,
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        new JetpackRevocableFileDescriptorStore(config),
                         ALWAYS_OPTIMIZE);
 
+        // Write and commit one blob
+        byte[] data = generateRandomBytes(20 * 1024); // 20 KiB
+        byte[] digest = calculateDigest(data);
+        AppSearchBlobHandle handle =
+                AppSearchBlobHandle.createWithSha256(
+                        digest, mContext.getPackageName(), "db1", "ns");
+        try (ParcelFileDescriptor writePfd =
+                        mAppSearchImpl.openWriteBlob(mContext.getPackageName(), "db1", handle);
+                OutputStream outputStream =
+                        new ParcelFileDescriptor.AutoCloseOutputStream(writePfd)) {
+            outputStream.write(data);
+            outputStream.flush();
+        }
+        mAppSearchImpl.commitBlob(mContext.getPackageName(), "db1", handle);
+
+        ParcelFileDescriptor reader1 =
+                mAppSearchImpl.openReadBlob(mContext.getPackageName(), "db1", handle);
+        ParcelFileDescriptor reader2 =
+                mAppSearchImpl.openReadBlob(mContext.getPackageName(), "db1", handle);
+        // Open 3rd fd will fail.
         AppSearchException e =
                 assertThrows(
                         AppSearchException.class,
                         () ->
-                                mAppSearchImpl.searchSuggestion(
-                                        "package",
-                                        "database",
-                                        /* suggestionQueryExpression= */ "t",
-                                        new SearchSuggestionSpec.Builder(/* totalResultCount= */ 10)
-                                                .build()));
-        assertThat(e.getResultCode()).isEqualTo(RESULT_INVALID_ARGUMENT);
+                                mAppSearchImpl.openReadBlob(
+                                        mContext.getPackageName(), "db1", handle));
+        assertThat(e.getResultCode()).isEqualTo(RESULT_OUT_OF_SPACE);
         assertThat(e)
                 .hasMessageThat()
-                .contains("Trying to get 10 suggestion results, which exceeds limit of 2");
+                .contains(
+                        "Package \""
+                                + mContext.getPackageName()
+                                + "\" exceeded limit of 2 opened file descriptors. Some file"
+                                + " descriptors must be closed to open additional ones.");
+
+        // Close 1st fd and open 3rd fd will success
+        reader1.close();
+        ParcelFileDescriptor reader3 =
+                mAppSearchImpl.openReadBlob(mContext.getPackageName(), "db1", handle);
+
+        // GlobalOpenRead will share same limit.
+        e =
+                assertThrows(
+                        AppSearchException.class,
+                        () -> mAppSearchImpl.globalOpenReadBlob(handle, mSelfCallerAccess));
+        assertThat(e.getResultCode()).isEqualTo(RESULT_OUT_OF_SPACE);
+        assertThat(e)
+                .hasMessageThat()
+                .contains(
+                        "Package \""
+                                + mContext.getPackageName()
+                                + "\" exceeded limit of 2 opened file descriptors. Some file"
+                                + " descriptors must be closed to open additional ones.");
+        // Close 2st fd and global open fd will success
+        reader2.close();
+        ParcelFileDescriptor reader4 = mAppSearchImpl.globalOpenReadBlob(handle, mSelfCallerAccess);
+
+        // Keep opening will fail
+        e =
+                assertThrows(
+                        AppSearchException.class,
+                        () ->
+                                mAppSearchImpl.openReadBlob(
+                                        mContext.getPackageName(), "db1", handle));
+        assertThat(e.getResultCode()).isEqualTo(RESULT_OUT_OF_SPACE);
+        assertThat(e)
+                .hasMessageThat()
+                .contains(
+                        "Package \""
+                                + mContext.getPackageName()
+                                + "\" exceeded limit of 2 opened file descriptors. Some file"
+                                + " descriptors must be closed to open additional ones.");
+        e =
+                assertThrows(
+                        AppSearchException.class,
+                        () -> mAppSearchImpl.globalOpenReadBlob(handle, mSelfCallerAccess));
+        assertThat(e.getResultCode()).isEqualTo(RESULT_OUT_OF_SPACE);
+        assertThat(e)
+                .hasMessageThat()
+                .contains(
+                        "Package \""
+                                + mContext.getPackageName()
+                                + "\" exceeded limit of 2 opened file descriptors. Some file"
+                                + " descriptors must be closed to open additional ones.");
+
+        reader3.close();
+        reader4.close();
     }
 
     /**
@@ -4668,6 +6833,7 @@ public class AppSearchImplTest {
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         mockVisibilityChecker,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         InternalSetSchemaResponse internalSetSchemaResponse =
@@ -4723,6 +6889,7 @@ public class AppSearchImplTest {
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         mockVisibilityChecker,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         InternalSetSchemaResponse internalSetSchemaResponse =
@@ -4774,6 +6941,7 @@ public class AppSearchImplTest {
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         mockVisibilityChecker,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         InternalSetSchemaResponse internalSetSchemaResponse =
@@ -4844,6 +7012,7 @@ public class AppSearchImplTest {
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         mockVisibilityChecker,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         InternalSetSchemaResponse internalSetSchemaResponse =
@@ -4930,14 +7099,14 @@ public class AppSearchImplTest {
                         .setNotDisplayedBySystem(true)
                         .addVisibleToPackage(new PackageIdentifier("pkgBar", new byte[32]))
                         .build();
-        assertThat(mAppSearchImpl.mVisibilityStoreLocked.getVisibility(prefix + "Email"))
+        assertThat(mAppSearchImpl.mDocumentVisibilityStoreLocked.getVisibility(prefix + "Email"))
                 .isEqualTo(expectedDocument);
         // Verify the InternalVisibilityConfig is saved to AppSearchImpl.
         InternalVisibilityConfig actualDocument =
                 VisibilityToDocumentConverter.createInternalVisibilityConfig(
                         mAppSearchImpl.getDocument(
                                 VISIBILITY_PACKAGE_NAME,
-                                VISIBILITY_DATABASE_NAME,
+                                DOCUMENT_VISIBILITY_DATABASE_NAME,
                                 VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
                                 /* id= */ prefix + "Email",
                                 /* typePropertyPaths= */ Collections.emptyMap()),
@@ -4975,14 +7144,14 @@ public class AppSearchImplTest {
                         .setNotDisplayedBySystem(true)
                         .addVisibleToPackage(new PackageIdentifier("pkgBar", new byte[32]))
                         .build();
-        assertThat(mAppSearchImpl.mVisibilityStoreLocked.getVisibility(prefix1 + "Email1"))
+        assertThat(mAppSearchImpl.mDocumentVisibilityStoreLocked.getVisibility(prefix1 + "Email1"))
                 .isEqualTo(expectedDocument1);
         // Verify the InternalVisibilityConfig is saved to AppSearchImpl.
         InternalVisibilityConfig actualDocument1 =
                 VisibilityToDocumentConverter.createInternalVisibilityConfig(
                         mAppSearchImpl.getDocument(
                                 VISIBILITY_PACKAGE_NAME,
-                                VISIBILITY_DATABASE_NAME,
+                                DOCUMENT_VISIBILITY_DATABASE_NAME,
                                 VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
                                 /* id= */ prefix1 + "Email1",
                                 /* typePropertyPaths= */ Collections.emptyMap()),
@@ -5018,14 +7187,14 @@ public class AppSearchImplTest {
                         .setNotDisplayedBySystem(false)
                         .addVisibleToPackage(new PackageIdentifier("pkgFoo", new byte[32]))
                         .build();
-        assertThat(mAppSearchImpl.mVisibilityStoreLocked.getVisibility(prefix2 + "Email2"))
+        assertThat(mAppSearchImpl.mDocumentVisibilityStoreLocked.getVisibility(prefix2 + "Email2"))
                 .isEqualTo(expectedDocument2);
         // Verify the InternalVisibilityConfig is saved to AppSearchImpl.
         InternalVisibilityConfig actualDocument2 =
                 VisibilityToDocumentConverter.createInternalVisibilityConfig(
                         mAppSearchImpl.getDocument(
                                 VISIBILITY_PACKAGE_NAME,
-                                VISIBILITY_DATABASE_NAME,
+                                DOCUMENT_VISIBILITY_DATABASE_NAME,
                                 VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
                                 /* id= */ prefix2 + "Email2",
                                 /* typePropertyPaths= */ Collections.emptyMap()),
@@ -5033,14 +7202,14 @@ public class AppSearchImplTest {
         assertThat(actualDocument2).isEqualTo(expectedDocument2);
 
         // Check the existing visibility document retains.
-        assertThat(mAppSearchImpl.mVisibilityStoreLocked.getVisibility(prefix1 + "Email1"))
+        assertThat(mAppSearchImpl.mDocumentVisibilityStoreLocked.getVisibility(prefix1 + "Email1"))
                 .isEqualTo(expectedDocument1);
         // Verify the VisibilityDocument is saved to AppSearchImpl.
         actualDocument1 =
                 VisibilityToDocumentConverter.createInternalVisibilityConfig(
                         mAppSearchImpl.getDocument(
                                 VISIBILITY_PACKAGE_NAME,
-                                VISIBILITY_DATABASE_NAME,
+                                DOCUMENT_VISIBILITY_DATABASE_NAME,
                                 VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
                                 /* id= */ prefix1 + "Email1",
                                 /* typePropertyPaths= */ Collections.emptyMap()),
@@ -5077,13 +7246,13 @@ public class AppSearchImplTest {
                         .setNotDisplayedBySystem(true)
                         .addVisibleToPackage(new PackageIdentifier("pkgBar", new byte[32]))
                         .build();
-        assertThat(mAppSearchImpl.mVisibilityStoreLocked.getVisibility(prefix + "Email"))
+        assertThat(mAppSearchImpl.mDocumentVisibilityStoreLocked.getVisibility(prefix + "Email"))
                 .isEqualTo(expectedDocument);
         InternalVisibilityConfig actualDocument =
                 VisibilityToDocumentConverter.createInternalVisibilityConfig(
                         mAppSearchImpl.getDocument(
                                 VISIBILITY_PACKAGE_NAME,
-                                VISIBILITY_DATABASE_NAME,
+                                DOCUMENT_VISIBILITY_DATABASE_NAME,
                                 VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
                                 /* id= */ prefix + "Email",
                                 /* typePropertyPaths= */ Collections.emptyMap()),
@@ -5102,7 +7271,8 @@ public class AppSearchImplTest {
                         /* setSchemaStatsBuilder= */ null);
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
         // All-default visibility document won't be saved in AppSearch.
-        assertThat(mAppSearchImpl.mVisibilityStoreLocked.getVisibility(prefix + "Email")).isNull();
+        assertThat(mAppSearchImpl.mDocumentVisibilityStoreLocked.getVisibility(prefix + "Email"))
+                .isNull();
         // Verify the InternalVisibilityConfig is removed from AppSearchImpl.
         AppSearchException e =
                 assertThrows(
@@ -5110,7 +7280,7 @@ public class AppSearchImplTest {
                         () ->
                                 mAppSearchImpl.getDocument(
                                         VISIBILITY_PACKAGE_NAME,
-                                        VISIBILITY_DATABASE_NAME,
+                                        DOCUMENT_VISIBILITY_DATABASE_NAME,
                                         VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
                                         /* id= */ prefix + "Email",
                                         /* typePropertyPaths= */ Collections.emptyMap()));
@@ -5146,14 +7316,14 @@ public class AppSearchImplTest {
                         .setNotDisplayedBySystem(true)
                         .addVisibleToPackage(new PackageIdentifier("pkgBar", new byte[32]))
                         .build();
-        assertThat(mAppSearchImpl.mVisibilityStoreLocked.getVisibility(prefix + "Email"))
+        assertThat(mAppSearchImpl.mDocumentVisibilityStoreLocked.getVisibility(prefix + "Email"))
                 .isEqualTo(expectedDocument);
         // Verify the InternalVisibilityConfig is saved to AppSearchImpl.
         InternalVisibilityConfig actualDocument =
                 VisibilityToDocumentConverter.createInternalVisibilityConfig(
                         mAppSearchImpl.getDocument(
                                 VISIBILITY_PACKAGE_NAME,
-                                VISIBILITY_DATABASE_NAME,
+                                DOCUMENT_VISIBILITY_DATABASE_NAME,
                                 VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
                                 /* id= */ prefix + "Email",
                                 /* typePropertyPaths= */ Collections.emptyMap()),
@@ -5180,7 +7350,8 @@ public class AppSearchImplTest {
                 /* version= */ 0,
                 /* setSchemaStatsBuilder= */ null);
         // All-default visibility document won't be saved in AppSearch.
-        assertThat(mAppSearchImpl.mVisibilityStoreLocked.getVisibility(prefix + "Email")).isNull();
+        assertThat(mAppSearchImpl.mDocumentVisibilityStoreLocked.getVisibility(prefix + "Email"))
+                .isNull();
         // Verify there is no visibility setting for the schema.
         AppSearchException e =
                 assertThrows(
@@ -5188,7 +7359,7 @@ public class AppSearchImplTest {
                         () ->
                                 mAppSearchImpl.getDocument(
                                         VISIBILITY_PACKAGE_NAME,
-                                        VISIBILITY_DATABASE_NAME,
+                                        DOCUMENT_VISIBILITY_DATABASE_NAME,
                                         VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
                                         /* id= */ prefix + "Email",
                                         /* typePropertyPaths= */ Collections.emptyMap()));
@@ -5227,6 +7398,7 @@ public class AppSearchImplTest {
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         String prefix = PrefixUtil.createPrefix("packageName", "databaseName");
@@ -5236,14 +7408,14 @@ public class AppSearchImplTest {
                         .addVisibleToPackage(new PackageIdentifier("pkgBar", new byte[32]))
                         .build();
 
-        assertThat(mAppSearchImpl.mVisibilityStoreLocked.getVisibility(prefix + "Email"))
+        assertThat(mAppSearchImpl.mDocumentVisibilityStoreLocked.getVisibility(prefix + "Email"))
                 .isEqualTo(expectedDocument);
         // Verify the InternalVisibilityConfig is saved to AppSearchImpl.
         InternalVisibilityConfig actualDocument =
                 VisibilityToDocumentConverter.createInternalVisibilityConfig(
                         mAppSearchImpl.getDocument(
                                 VISIBILITY_PACKAGE_NAME,
-                                VISIBILITY_DATABASE_NAME,
+                                DOCUMENT_VISIBILITY_DATABASE_NAME,
                                 VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
                                 /* id= */ prefix + "Email",
                                 /* typePropertyPaths= */ Collections.emptyMap()),
@@ -5271,9 +7443,11 @@ public class AppSearchImplTest {
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
-        assertThat(mAppSearchImpl.mVisibilityStoreLocked.getVisibility(prefix + "Email")).isNull();
+        assertThat(mAppSearchImpl.mDocumentVisibilityStoreLocked.getVisibility(prefix + "Email"))
+                .isNull();
         // Verify the InternalVisibilityConfig is removed from AppSearchImpl.
         AppSearchException e =
                 assertThrows(
@@ -5281,7 +7455,7 @@ public class AppSearchImplTest {
                         () ->
                                 mAppSearchImpl.getDocument(
                                         VISIBILITY_PACKAGE_NAME,
-                                        VISIBILITY_DATABASE_NAME,
+                                        DOCUMENT_VISIBILITY_DATABASE_NAME,
                                         VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
                                         /* id= */ prefix + "Email",
                                         /* typePropertyPaths= */ Collections.emptyMap()));
@@ -5306,6 +7480,7 @@ public class AppSearchImplTest {
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         mockVisibilityChecker,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Add a schema type that is not displayed by the system
@@ -5427,6 +7602,7 @@ public class AppSearchImplTest {
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         mockVisibilityChecker,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Add two schema types that are not displayed by the system.
@@ -5512,6 +7688,7 @@ public class AppSearchImplTest {
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         publicAclMockChecker,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         List<InternalVisibilityConfig> visibilityConfigs =
@@ -5617,6 +7794,7 @@ public class AppSearchImplTest {
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         publicAclMockChecker,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         List<InternalVisibilityConfig> visibilityConfigs =
@@ -5647,21 +7825,21 @@ public class AppSearchImplTest {
         GenericDocument visibilityOverlayA =
                 mAppSearchImpl.getDocument(
                         VISIBILITY_PACKAGE_NAME,
-                        ANDROID_V_OVERLAY_DATABASE_NAME,
+                        DOCUMENT_ANDROID_V_OVERLAY_DATABASE_NAME,
                         VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE,
                         "package$database/PublicTypeA",
                         Collections.emptyMap());
         GenericDocument visibilityOverlayB =
                 mAppSearchImpl.getDocument(
                         VISIBILITY_PACKAGE_NAME,
-                        ANDROID_V_OVERLAY_DATABASE_NAME,
+                        DOCUMENT_ANDROID_V_OVERLAY_DATABASE_NAME,
                         VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE,
                         "package$database/PublicTypeB",
                         Collections.emptyMap());
         GenericDocument visibilityOverlayC =
                 mAppSearchImpl.getDocument(
                         VISIBILITY_PACKAGE_NAME,
-                        ANDROID_V_OVERLAY_DATABASE_NAME,
+                        DOCUMENT_ANDROID_V_OVERLAY_DATABASE_NAME,
                         VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE,
                         "package$database/PublicTypeC",
                         Collections.emptyMap());
@@ -5735,7 +7913,7 @@ public class AppSearchImplTest {
                         () ->
                                 mAppSearchImpl.getDocument(
                                         VISIBILITY_PACKAGE_NAME,
-                                        VISIBILITY_DATABASE_NAME,
+                                        DOCUMENT_VISIBILITY_DATABASE_NAME,
                                         VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE,
                                         "package$database/PublicTypeA",
                                         Collections.emptyMap()));
@@ -5746,7 +7924,7 @@ public class AppSearchImplTest {
                         () ->
                                 mAppSearchImpl.getDocument(
                                         VISIBILITY_PACKAGE_NAME,
-                                        VISIBILITY_DATABASE_NAME,
+                                        DOCUMENT_VISIBILITY_DATABASE_NAME,
                                         VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE,
                                         "package$database/PublicTypeB",
                                         Collections.emptyMap()));
@@ -5757,7 +7935,7 @@ public class AppSearchImplTest {
                         () ->
                                 mAppSearchImpl.getDocument(
                                         VISIBILITY_PACKAGE_NAME,
-                                        VISIBILITY_DATABASE_NAME,
+                                        DOCUMENT_VISIBILITY_DATABASE_NAME,
                                         VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE,
                                         "package$database/PublicTypeC",
                                         Collections.emptyMap()));
@@ -5824,6 +8002,7 @@ public class AppSearchImplTest {
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         rejectChecker,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Add a schema type
@@ -5942,6 +8121,7 @@ public class AppSearchImplTest {
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         visibilityChecker,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Add a schema type
@@ -6004,6 +8184,7 @@ public class AppSearchImplTest {
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         rejectChecker,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Add a schema type
@@ -6377,6 +8558,7 @@ public class AppSearchImplTest {
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         visibilityChecker,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Register an observer
@@ -6563,6 +8745,7 @@ public class AppSearchImplTest {
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         visibilityChecker,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Add a schema.
@@ -6675,6 +8858,7 @@ public class AppSearchImplTest {
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         visibilityChecker,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Add a schema.
@@ -6782,6 +8966,7 @@ public class AppSearchImplTest {
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
                         /* initStatsBuilder= */ null,
                         visibilityChecker,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Add a schema.
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/AppSearchLoggerTest.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/AppSearchLoggerTest.java
index fd17b4c9..a1b672ad 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/AppSearchLoggerTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/AppSearchLoggerTest.java
@@ -26,8 +26,12 @@ import android.app.appsearch.JoinSpec;
 import android.app.appsearch.SearchResultPage;
 import android.app.appsearch.SearchSpec;
 import android.app.appsearch.exceptions.AppSearchException;
+import android.app.appsearch.testutil.AppSearchTestUtils;
 import android.app.appsearch.testutil.SimpleTestLogger;
+import android.platform.test.annotations.RequiresFlagsDisabled;
+import android.platform.test.annotations.RequiresFlagsEnabled;
 
+import com.android.appsearch.flags.Flags;
 import com.android.server.appsearch.external.localstorage.stats.InitializeStats;
 import com.android.server.appsearch.external.localstorage.stats.OptimizeStats;
 import com.android.server.appsearch.external.localstorage.stats.PutDocumentStats;
@@ -53,6 +57,7 @@ import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.RuleChain;
 import org.junit.rules.TemporaryFolder;
 
 import java.io.File;
@@ -70,18 +75,24 @@ public class AppSearchLoggerTest {
     private static final OptimizeStrategy ALWAYS_OPTIMIZE = optimizeInfo -> true;
 
     @Rule public TemporaryFolder mTemporaryFolder = new TemporaryFolder();
+
+    @Rule public final RuleChain mRuleChain = AppSearchTestUtils.createCommonTestRules();
+
     private AppSearchImpl mAppSearchImpl;
     private SimpleTestLogger mLogger;
+    private AppSearchConfig mConfig =
+            new AppSearchConfigImpl(
+                    new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig());
 
     @Before
     public void setUp() throws Exception {
         mAppSearchImpl =
                 AppSearchImpl.create(
                         mTemporaryFolder.newFolder(),
-                        new AppSearchConfigImpl(
-                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        mConfig,
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
         mLogger = new SimpleTestLogger();
     }
@@ -376,10 +387,10 @@ public class AppSearchLoggerTest {
         AppSearchImpl appSearchImpl =
                 AppSearchImpl.create(
                         mTemporaryFolder.newFolder(),
-                        new AppSearchConfigImpl(
-                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        mConfig,
                         initStatsBuilder,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
         InitializeStats iStats = initStatsBuilder.build();
         appSearchImpl.close();
@@ -400,6 +411,7 @@ public class AppSearchLoggerTest {
     }
 
     @Test
+    @RequiresFlagsDisabled(Flags.FLAG_ENABLE_BLOB_STORE)
     public void testLoggingStats_initializeWithDocuments_success() throws Exception {
         final String testPackageName = "testPackage";
         final String testDatabase = "testDatabase";
@@ -408,10 +420,10 @@ public class AppSearchLoggerTest {
         AppSearchImpl appSearchImpl =
                 AppSearchImpl.create(
                         folder,
-                        new AppSearchConfigImpl(
-                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        mConfig,
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
         List<AppSearchSchema> schemas =
                 ImmutableList.of(
@@ -440,10 +452,10 @@ public class AppSearchLoggerTest {
         appSearchImpl =
                 AppSearchImpl.create(
                         folder,
-                        new AppSearchConfigImpl(
-                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        mConfig,
                         initStatsBuilder,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
         InitializeStats iStats = initStatsBuilder.build();
 
@@ -464,6 +476,75 @@ public class AppSearchLoggerTest {
         appSearchImpl.close();
     }
 
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_ENABLE_BLOB_STORE)
+    public void testLoggingStats_enableBlobStore_initializeWithDocuments_success()
+            throws Exception {
+        final String testPackageName = "testPackage";
+        final String testDatabase = "testDatabase";
+        final File folder = mTemporaryFolder.newFolder();
+
+        AppSearchImpl appSearchImpl =
+                AppSearchImpl.create(
+                        folder,
+                        mConfig,
+                        /* initStatsBuilder= */ null,
+                        /* visibilityChecker= */ null,
+                        new JetpackRevocableFileDescriptorStore(mConfig),
+                        ALWAYS_OPTIMIZE);
+
+        List<AppSearchSchema> schemas =
+                ImmutableList.of(
+                        new AppSearchSchema.Builder("Type1").build(),
+                        new AppSearchSchema.Builder("Type2").build());
+        InternalSetSchemaResponse internalSetSchemaResponse =
+                appSearchImpl.setSchema(
+                        testPackageName,
+                        testDatabase,
+                        schemas,
+                        /* visibilityDocuments= */ Collections.emptyList(),
+                        /* forceOverride= */ false,
+                        /* version= */ 0,
+                        /* setSchemaStatsBuilder= */ null);
+        assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
+        GenericDocument doc1 = new GenericDocument.Builder<>("namespace", "id1", "Type1").build();
+        GenericDocument doc2 = new GenericDocument.Builder<>("namespace", "id2", "Type1").build();
+        appSearchImpl.putDocument(
+                testPackageName, testDatabase, doc1, /* sendChangeNotifications= */ false, mLogger);
+        appSearchImpl.putDocument(
+                testPackageName, testDatabase, doc2, /* sendChangeNotifications= */ false, mLogger);
+        appSearchImpl.close();
+
+        // Create another appsearchImpl on the same folder
+        InitializeStats.Builder initStatsBuilder = new InitializeStats.Builder();
+        appSearchImpl =
+                AppSearchImpl.create(
+                        folder,
+                        mConfig,
+                        initStatsBuilder,
+                        /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
+                        ALWAYS_OPTIMIZE);
+        InitializeStats iStats = initStatsBuilder.build();
+
+        assertThat(iStats).isNotNull();
+        // If the process goes really fast, the total latency could be 0. Since the default of total
+        // latency is also 0, we just remove the assert about NativeLatencyMillis.
+        assertThat(iStats.getStatusCode()).isEqualTo(AppSearchResult.RESULT_OK);
+        // Total latency captured in LocalStorage
+        assertThat(iStats.getTotalLatencyMillis()).isEqualTo(0);
+        assertThat(iStats.hasDeSync()).isFalse();
+        assertThat(iStats.getDocumentStoreDataStatus())
+                .isEqualTo(InitializeStatsProto.DocumentStoreDataStatus.NO_DATA_LOSS_VALUE);
+        assertThat(iStats.getDocumentCount()).isEqualTo(2);
+        // Type1 + Type2 + 2(document and blob visibility db)
+        // * (2 for VisibilitySchema +1 for VisibilityOverlay)
+        assertThat(iStats.getSchemaTypeCount()).isEqualTo(8);
+        assertThat(iStats.hasReset()).isEqualTo(false);
+        assertThat(iStats.getResetStatusCode()).isEqualTo(AppSearchResult.RESULT_OK);
+        appSearchImpl.close();
+    }
+
     @Test
     public void testLoggingStats_initialize_failure() throws Exception {
         final String testPackageName = "testPackage";
@@ -473,10 +554,10 @@ public class AppSearchLoggerTest {
         AppSearchImpl appSearchImpl =
                 AppSearchImpl.create(
                         folder,
-                        new AppSearchConfigImpl(
-                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        mConfig,
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         List<AppSearchSchema> schemas =
@@ -515,10 +596,10 @@ public class AppSearchLoggerTest {
         appSearchImpl =
                 AppSearchImpl.create(
                         folder,
-                        new AppSearchConfigImpl(
-                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        mConfig,
                         initStatsBuilder,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
         InitializeStats iStats = initStatsBuilder.build();
 
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/BlobHandleToProtoConverterTest.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/BlobHandleToProtoConverterTest.java
new file mode 100644
index 00000000..65f861f5
--- /dev/null
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/BlobHandleToProtoConverterTest.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.external.localstorage.converter;
+
+import static android.app.appsearch.testutil.AppSearchTestUtils.calculateDigest;
+import static android.app.appsearch.testutil.AppSearchTestUtils.generateRandomBytes;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.app.appsearch.AppSearchBlobHandle;
+
+import com.android.server.appsearch.external.localstorage.util.PrefixUtil;
+import com.android.server.appsearch.icing.proto.PropertyProto;
+import com.android.server.appsearch.protobuf.ByteString;
+
+import org.junit.Test;
+
+public class BlobHandleToProtoConverterTest {
+
+    @Test
+    public void testToBlobHandleProto() throws Exception {
+        byte[] data = generateRandomBytes(20 * 1024); // 20 KiB
+        byte[] digest = calculateDigest(data);
+        AppSearchBlobHandle handle =
+                AppSearchBlobHandle.createWithSha256(digest, "package", "db1", "ns");
+
+        PropertyProto.BlobHandleProto proto = BlobHandleToProtoConverter.toBlobHandleProto(handle);
+
+        assertThat(proto.getDigest().toByteArray()).isEqualTo(digest);
+        assertThat(proto.getNamespace())
+                .isEqualTo(PrefixUtil.createPrefix("package", "db1") + "ns");
+    }
+
+    @Test
+    public void testToBlobHandle() throws Exception {
+        byte[] data = generateRandomBytes(20 * 1024); // 20 KiB
+        byte[] digest = calculateDigest(data);
+
+        PropertyProto.BlobHandleProto proto =
+                PropertyProto.BlobHandleProto.newBuilder()
+                        .setNamespace(PrefixUtil.createPrefix("package", "db1") + "ns")
+                        .setDigest(ByteString.copyFrom(digest))
+                        .build();
+        AppSearchBlobHandle handle = BlobHandleToProtoConverter.toAppSearchBlobHandle(proto);
+
+        assertThat(handle.getPackageName()).isEqualTo("package");
+        assertThat(handle.getDatabaseName()).isEqualTo("db1");
+        assertThat(handle.getNamespace()).isEqualTo("ns");
+        assertThat(handle.getSha256Digest()).isEqualTo(digest);
+    }
+}
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/GenericDocumentToProtoConverterTest.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/GenericDocumentToProtoConverterTest.java
index 3fe175f4..0bebdb81 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/GenericDocumentToProtoConverterTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/GenericDocumentToProtoConverterTest.java
@@ -16,14 +16,22 @@
 
 package com.android.server.appsearch.external.localstorage.converter;
 
+import static android.app.appsearch.testutil.AppSearchTestUtils.calculateDigest;
+
 import static com.google.common.truth.Truth.assertThat;
 
+import static org.junit.Assume.assumeTrue;
+
+import android.app.appsearch.AppSearchBlobHandle;
 import android.app.appsearch.EmbeddingVector;
 import android.app.appsearch.GenericDocument;
 
+import com.android.appsearch.flags.Flags;
 import com.android.server.appsearch.external.localstorage.AppSearchConfigImpl;
 import com.android.server.appsearch.external.localstorage.LocalStorageIcingOptionsConfig;
+import com.android.server.appsearch.external.localstorage.SchemaCache;
 import com.android.server.appsearch.external.localstorage.UnlimitedLimitConfig;
+import com.android.server.appsearch.external.localstorage.util.PrefixUtil;
 import com.android.server.appsearch.icing.proto.DocumentProto;
 import com.android.server.appsearch.icing.proto.PropertyConfigProto;
 import com.android.server.appsearch.icing.proto.PropertyProto;
@@ -61,14 +69,17 @@ public class GenericDocumentToProtoConverterTest {
                             "namespace", "sDocumentProperties2", SCHEMA_TYPE_2)
                     .setCreationTimestampMillis(6789L)
                     .build();
+    private static final String PREFIX = "package$databaseName/";
     private static final SchemaTypeConfigProto SCHEMA_PROTO_1 =
-            SchemaTypeConfigProto.newBuilder().setSchemaType(SCHEMA_TYPE_1).build();
+            SchemaTypeConfigProto.newBuilder().setSchemaType(PREFIX + SCHEMA_TYPE_1).build();
     private static final SchemaTypeConfigProto SCHEMA_PROTO_2 =
-            SchemaTypeConfigProto.newBuilder().setSchemaType(SCHEMA_TYPE_2).build();
-    private static final String PREFIX = "package$databaseName/";
-    private static final Map<String, SchemaTypeConfigProto> SCHEMA_MAP =
+            SchemaTypeConfigProto.newBuilder().setSchemaType(PREFIX + SCHEMA_TYPE_2).build();
+    private static final Map<String, Map<String, SchemaTypeConfigProto>> SCHEMA_MAP =
             ImmutableMap.of(
-                    PREFIX + SCHEMA_TYPE_1, SCHEMA_PROTO_1, PREFIX + SCHEMA_TYPE_2, SCHEMA_PROTO_2);
+                    PREFIX,
+                    ImmutableMap.of(
+                            PREFIX + SCHEMA_TYPE_1, SCHEMA_PROTO_1,
+                            PREFIX + SCHEMA_TYPE_2, SCHEMA_PROTO_2));
 
     @Test
     public void testDocumentProtoConvert() throws Exception {
@@ -139,7 +150,7 @@ public class GenericDocumentToProtoConverterTest {
                 GenericDocumentToProtoConverter.toGenericDocument(
                         documentProto,
                         PREFIX,
-                        SCHEMA_MAP,
+                        new SchemaCache(SCHEMA_MAP),
                         new AppSearchConfigImpl(
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()));
         DocumentProto convertedDocumentProto =
@@ -238,15 +249,16 @@ public class GenericDocumentToProtoConverterTest {
                         .addProperties(emptyDocumentListProperty)
                         .setSchemaType(PREFIX + SCHEMA_TYPE_1)
                         .build();
-        Map<String, SchemaTypeConfigProto> schemaMap =
-                ImmutableMap.of(PREFIX + SCHEMA_TYPE_1, schemaTypeConfigProto);
+        Map<String, Map<String, SchemaTypeConfigProto>> schemaMap =
+                ImmutableMap.of(
+                        PREFIX, ImmutableMap.of(PREFIX + SCHEMA_TYPE_1, schemaTypeConfigProto));
 
         // Convert to the other type and check if they are matched.
         GenericDocument convertedGenericDocument =
                 GenericDocumentToProtoConverter.toGenericDocument(
                         documentProto,
                         PREFIX,
-                        schemaMap,
+                        new SchemaCache(schemaMap),
                         new AppSearchConfigImpl(
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()));
         DocumentProto convertedDocumentProto =
@@ -378,19 +390,21 @@ public class GenericDocumentToProtoConverterTest {
                         .addProperties(nestedDocumentProperty)
                         .setSchemaType(PREFIX + SCHEMA_TYPE_2)
                         .build();
-        Map<String, SchemaTypeConfigProto> schemaMap =
+        Map<String, Map<String, SchemaTypeConfigProto>> schemaMap =
                 ImmutableMap.of(
-                        PREFIX + SCHEMA_TYPE_1,
-                        nestedSchemaTypeConfigProto,
-                        PREFIX + SCHEMA_TYPE_2,
-                        outerSchemaTypeConfigProto);
+                        PREFIX,
+                        ImmutableMap.of(
+                                PREFIX + SCHEMA_TYPE_1,
+                                nestedSchemaTypeConfigProto,
+                                PREFIX + SCHEMA_TYPE_2,
+                                outerSchemaTypeConfigProto));
 
         // Convert to the other type and check if they are matched.
         GenericDocument convertedGenericDocument =
                 GenericDocumentToProtoConverter.toGenericDocument(
                         outerDocumentProto,
                         PREFIX,
-                        schemaMap,
+                        new SchemaCache(schemaMap),
                         new AppSearchConfigImpl(
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()));
         DocumentProto convertedDocumentProto =
@@ -399,6 +413,78 @@ public class GenericDocumentToProtoConverterTest {
         assertThat(convertedGenericDocument).isEqualTo(outerDocument);
     }
 
+    @Test
+    public void testConvertDocument_withoutParentTypes() throws Exception {
+        assumeTrue(Flags.enableSearchResultParentTypes());
+        // Create a type with a parent type.
+        SchemaTypeConfigProto schemaProto1 =
+                SchemaTypeConfigProto.newBuilder()
+                        .setSchemaType(PREFIX + SCHEMA_TYPE_1)
+                        .addParentTypes(PREFIX + SCHEMA_TYPE_2)
+                        .build();
+        Map<String, Map<String, SchemaTypeConfigProto>> schemaMap =
+                ImmutableMap.of(
+                        PREFIX,
+                        ImmutableMap.of(
+                                PREFIX + SCHEMA_TYPE_1, schemaProto1,
+                                PREFIX + SCHEMA_TYPE_2, SCHEMA_PROTO_2));
+
+        // Create a document proto for the above type.
+        DocumentProto.Builder documentProtoBuilder =
+                DocumentProto.newBuilder()
+                        .setUri("id1")
+                        .setSchema(SCHEMA_TYPE_1)
+                        .setCreationTimestampMs(5L)
+                        .setScore(1)
+                        .setTtlMs(1L)
+                        .setNamespace("namespace");
+        HashMap<String, PropertyProto.Builder> propertyProtoMap = new HashMap<>();
+        propertyProtoMap.put(
+                "longKey1", PropertyProto.newBuilder().setName("longKey1").addInt64Values(1L));
+        propertyProtoMap.put(
+                "doubleKey1",
+                PropertyProto.newBuilder().setName("doubleKey1").addDoubleValues(1.0));
+        for (Map.Entry<String, PropertyProto.Builder> entry : propertyProtoMap.entrySet()) {
+            documentProtoBuilder.addProperties(entry.getValue());
+        }
+        DocumentProto documentProto = documentProtoBuilder.build();
+
+        // Check that the parent types list is not wrapped anywhere in GenericDocument, neither
+        // as a synthetic property nor as a meta field, since Flags.enableSearchResultParentTypes()
+        // is true.
+        GenericDocument expectedDoc =
+                new GenericDocument.Builder<GenericDocument.Builder<?>>(
+                                "namespace", "id1", SCHEMA_TYPE_1)
+                        .setCreationTimestampMillis(5L)
+                        .setScore(1)
+                        .setTtlMillis(1L)
+                        .setPropertyLong("longKey1", 1L)
+                        .setPropertyDouble("doubleKey1", 1.0)
+                        .build();
+        GenericDocument actualDoc1 =
+                GenericDocumentToProtoConverter.toGenericDocument(
+                        documentProto,
+                        PREFIX,
+                        new SchemaCache(schemaMap),
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(),
+                                new LocalStorageIcingOptionsConfig(),
+                                /* storeParentInfoAsSyntheticProperty= */ false,
+                                /* shouldRetrieveParentInfo= */ true));
+        GenericDocument actualDoc2 =
+                GenericDocumentToProtoConverter.toGenericDocument(
+                        documentProto,
+                        PREFIX,
+                        new SchemaCache(schemaMap),
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(),
+                                new LocalStorageIcingOptionsConfig(),
+                                /* storeParentInfoAsSyntheticProperty= */ true,
+                                /* shouldRetrieveParentInfo= */ true));
+        assertThat(actualDoc1).isEqualTo(expectedDoc);
+        assertThat(actualDoc2).isEqualTo(expectedDoc);
+    }
+
     @Test
     public void testDocumentProtoConvert_EmbeddingProperty() throws Exception {
         GenericDocument document =
@@ -454,7 +540,85 @@ public class GenericDocumentToProtoConverterTest {
                 GenericDocumentToProtoConverter.toGenericDocument(
                         documentProto,
                         PREFIX,
-                        SCHEMA_MAP,
+                        new SchemaCache(SCHEMA_MAP),
+                        new AppSearchConfigImpl(
+                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()));
+        DocumentProto convertedDocumentProto =
+                GenericDocumentToProtoConverter.toDocumentProto(document);
+
+        assertThat(convertedDocumentProto).isEqualTo(documentProto);
+        assertThat(convertedGenericDocument).isEqualTo(document);
+    }
+
+    @Test
+    public void testDocumentProtoConvert_blobHandleProperty() throws Exception {
+        byte[] data1 = {(byte) 1};
+        byte[] data2 = {(byte) 2};
+        byte[] digest1 = calculateDigest(data1);
+        byte[] digest2 = calculateDigest(data2);
+        AppSearchBlobHandle blobHandle1 =
+                AppSearchBlobHandle.createWithSha256(digest1, "package1", "db1", "namespace");
+        AppSearchBlobHandle blobHandle2 =
+                AppSearchBlobHandle.createWithSha256(digest2, "package1", "db1", "namespace");
+
+        GenericDocument document =
+                new GenericDocument.Builder<GenericDocument.Builder<?>>(
+                                "namespace", "id1", SCHEMA_TYPE_1)
+                        .setCreationTimestampMillis(5L)
+                        .setScore(1)
+                        .setTtlMillis(1L)
+                        .setPropertyBlobHandle("blobKey1", blobHandle1)
+                        .setPropertyBlobHandle("blobKey2", blobHandle2)
+                        .build();
+
+        // Create the Document proto. Need to sort the property order by key.
+        DocumentProto.Builder documentProtoBuilder =
+                DocumentProto.newBuilder()
+                        .setUri("id1")
+                        .setSchema(SCHEMA_TYPE_1)
+                        .setCreationTimestampMs(5L)
+                        .setScore(1)
+                        .setTtlMs(1L)
+                        .setNamespace("namespace");
+
+        // Create the BlobHandle proto.
+        HashMap<String, PropertyProto.Builder> propertyProtoMap = new HashMap<>();
+        String prefix = PrefixUtil.createPrefix("package1", "db1");
+
+        PropertyProto.BlobHandleProto.Builder blobHandleProto1 =
+                PropertyProto.BlobHandleProto.newBuilder()
+                        .setNamespace(prefix + "namespace")
+                        .setDigest(ByteString.copyFrom(blobHandle1.getSha256Digest()));
+
+        PropertyProto.BlobHandleProto.Builder blobHandleProto2 =
+                PropertyProto.BlobHandleProto.newBuilder()
+                        .setNamespace(prefix + "namespace")
+                        .setDigest(ByteString.copyFrom(blobHandle2.getSha256Digest()));
+
+        propertyProtoMap.put(
+                "blobKey1",
+                PropertyProto.newBuilder()
+                        .setName("blobKey1")
+                        .addBlobHandleValues(blobHandleProto1));
+        propertyProtoMap.put(
+                "blobKey2",
+                PropertyProto.newBuilder()
+                        .setName("blobKey2")
+                        .addBlobHandleValues(blobHandleProto2));
+
+        // Sort property by keys
+        List<String> sortedKey = new ArrayList<>(propertyProtoMap.keySet());
+        Collections.sort(sortedKey);
+        for (String key : sortedKey) {
+            documentProtoBuilder.addProperties(propertyProtoMap.get(key));
+        }
+        DocumentProto documentProto = documentProtoBuilder.build();
+
+        GenericDocument convertedGenericDocument =
+                GenericDocumentToProtoConverter.toGenericDocument(
+                        documentProto,
+                        PREFIX,
+                        new SchemaCache(SCHEMA_MAP),
                         new AppSearchConfigImpl(
                                 new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()));
         DocumentProto convertedDocumentProto =
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SchemaToProtoConverterTest.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SchemaToProtoConverterTest.java
index 9d54f3f5..4ceb6671 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SchemaToProtoConverterTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SchemaToProtoConverterTest.java
@@ -76,6 +76,15 @@ public class SchemaToProtoConverterTest {
                                         .setCardinality(
                                                 AppSearchSchema.PropertyConfig.CARDINALITY_REPEATED)
                                         .build())
+                        .addProperty(
+                                new AppSearchSchema.EmbeddingPropertyConfig.Builder("embedding")
+                                        .setDescription("The embedding that represents this email.")
+                                        .setCardinality(
+                                                AppSearchSchema.PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setIndexingType(
+                                                AppSearchSchema.EmbeddingPropertyConfig
+                                                        .INDEXING_TYPE_SIMILARITY)
+                                        .build())
                         // We don't need to actually define the Person type for this test because
                         // the converter will process each schema individually.
                         .addProperty(
@@ -112,7 +121,9 @@ public class SchemaToProtoConverterTest {
                                         .setDescription("The time at which the email was sent.")
                                         .setDataType(PropertyConfigProto.DataType.Code.INT64)
                                         .setCardinality(
-                                                PropertyConfigProto.Cardinality.Code.OPTIONAL))
+                                                PropertyConfigProto.Cardinality.Code.OPTIONAL)
+                                        .setScorableType(
+                                                PropertyConfigProto.ScorableType.Code.DISABLED))
                         .addProperties(
                                 PropertyConfigProto.newBuilder()
                                         .setPropertyName("importanceScore")
@@ -120,7 +131,9 @@ public class SchemaToProtoConverterTest {
                                                 "A value representing this document's importance.")
                                         .setDataType(PropertyConfigProto.DataType.Code.DOUBLE)
                                         .setCardinality(
-                                                PropertyConfigProto.Cardinality.Code.OPTIONAL))
+                                                PropertyConfigProto.Cardinality.Code.OPTIONAL)
+                                        .setScorableType(
+                                                PropertyConfigProto.ScorableType.Code.DISABLED))
                         .addProperties(
                                 PropertyConfigProto.newBuilder()
                                         .setPropertyName("read")
@@ -128,7 +141,9 @@ public class SchemaToProtoConverterTest {
                                                 "Whether the email has been read by the recipient")
                                         .setDataType(PropertyConfigProto.DataType.Code.BOOLEAN)
                                         .setCardinality(
-                                                PropertyConfigProto.Cardinality.Code.OPTIONAL))
+                                                PropertyConfigProto.Cardinality.Code.OPTIONAL)
+                                        .setScorableType(
+                                                PropertyConfigProto.ScorableType.Code.DISABLED))
                         .addProperties(
                                 PropertyConfigProto.newBuilder()
                                         .setPropertyName("attachment")
@@ -136,6 +151,23 @@ public class SchemaToProtoConverterTest {
                                         .setDataType(PropertyConfigProto.DataType.Code.BYTES)
                                         .setCardinality(
                                                 PropertyConfigProto.Cardinality.Code.REPEATED))
+                        .addProperties(
+                                PropertyConfigProto.newBuilder()
+                                        .setPropertyName("embedding")
+                                        .setDescription("The embedding that represents this email.")
+                                        .setDataType(PropertyConfigProto.DataType.Code.VECTOR)
+                                        .setCardinality(
+                                                PropertyConfigProto.Cardinality.Code.OPTIONAL)
+                                        .setEmbeddingIndexingConfig(
+                                                EmbeddingIndexingConfig.newBuilder()
+                                                        .setEmbeddingIndexingType(
+                                                                EmbeddingIndexingConfig
+                                                                        .EmbeddingIndexingType.Code
+                                                                        .LINEAR_SEARCH)
+                                                        .setQuantizationType(
+                                                                EmbeddingIndexingConfig
+                                                                        .QuantizationType.Code
+                                                                        .NONE)))
                         .addProperties(
                                 PropertyConfigProto.newBuilder()
                                         .setPropertyName("sender")
@@ -275,7 +307,9 @@ public class SchemaToProtoConverterTest {
                                         .setDescription("")
                                         .setDataType(PropertyConfigProto.DataType.Code.INT64)
                                         .setCardinality(
-                                                PropertyConfigProto.Cardinality.Code.OPTIONAL))
+                                                PropertyConfigProto.Cardinality.Code.OPTIONAL)
+                                        .setScorableType(
+                                                PropertyConfigProto.ScorableType.Code.DISABLED))
                         .build();
 
         assertThat(
@@ -297,12 +331,17 @@ public class SchemaToProtoConverterTest {
                                         .setJoinableValueType(
                                                 AppSearchSchema.StringPropertyConfig
                                                         .JOINABLE_VALUE_TYPE_QUALIFIED_ID)
+                                        .setDeletePropagationType(
+                                                AppSearchSchema.StringPropertyConfig
+                                                        .DELETE_PROPAGATION_TYPE_PROPAGATE_FROM)
                                         .build())
                         .build();
 
         JoinableConfig joinableConfig =
                 JoinableConfig.newBuilder()
                         .setValueType(JoinableConfig.ValueType.Code.QUALIFIED_ID)
+                        .setDeletePropagationType(
+                                JoinableConfig.DeletePropagationType.Code.PROPAGATE_FROM)
                         .build();
 
         SchemaTypeConfigProto expectedAlbumProto =
@@ -465,6 +504,21 @@ public class SchemaToProtoConverterTest {
                                         .setIndexingType(
                                                 AppSearchSchema.EmbeddingPropertyConfig
                                                         .INDEXING_TYPE_SIMILARITY)
+                                        .setQuantizationType(
+                                                AppSearchSchema.EmbeddingPropertyConfig
+                                                        .QUANTIZATION_TYPE_NONE)
+                                        .build())
+                        .addProperty(
+                                new AppSearchSchema.EmbeddingPropertyConfig.Builder(
+                                                "quantizedEmbedding")
+                                        .setCardinality(
+                                                AppSearchSchema.PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setIndexingType(
+                                                AppSearchSchema.EmbeddingPropertyConfig
+                                                        .INDEXING_TYPE_SIMILARITY)
+                                        .setQuantizationType(
+                                                AppSearchSchema.EmbeddingPropertyConfig
+                                                        .QUANTIZATION_TYPE_8_BIT)
                                         .build())
                         .build();
 
@@ -520,7 +574,87 @@ public class SchemaToProtoConverterTest {
                                                         .setEmbeddingIndexingType(
                                                                 EmbeddingIndexingConfig
                                                                         .EmbeddingIndexingType.Code
-                                                                        .LINEAR_SEARCH)))
+                                                                        .LINEAR_SEARCH)
+                                                        .setQuantizationType(
+                                                                EmbeddingIndexingConfig
+                                                                        .QuantizationType.Code
+                                                                        .NONE)))
+                        .addProperties(
+                                PropertyConfigProto.newBuilder()
+                                        .setPropertyName("quantizedEmbedding")
+                                        .setDescription("")
+                                        .setDataType(PropertyConfigProto.DataType.Code.VECTOR)
+                                        .setCardinality(
+                                                PropertyConfigProto.Cardinality.Code.OPTIONAL)
+                                        .setEmbeddingIndexingConfig(
+                                                EmbeddingIndexingConfig.newBuilder()
+                                                        .setEmbeddingIndexingType(
+                                                                EmbeddingIndexingConfig
+                                                                        .EmbeddingIndexingType.Code
+                                                                        .LINEAR_SEARCH)
+                                                        .setQuantizationType(
+                                                                EmbeddingIndexingConfig
+                                                                        .QuantizationType.Code
+                                                                        .QUANTIZE_8_BIT)))
+                        .build();
+
+        assertThat(
+                        SchemaToProtoConverter.toSchemaTypeConfigProto(
+                                emailSchema, /* version= */ 12345))
+                .isEqualTo(expectedEmailProto);
+        assertThat(SchemaToProtoConverter.toAppSearchSchema(expectedEmailProto))
+                .isEqualTo(emailSchema);
+    }
+
+    @Test
+    public void testGetProto_BlobHandleProperty() {
+        AppSearchSchema emailSchema =
+                new AppSearchSchema.Builder("Email")
+                        .addProperty(
+                                new AppSearchSchema.StringPropertyConfig.Builder("subject")
+                                        .setCardinality(
+                                                AppSearchSchema.PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setIndexingType(
+                                                AppSearchSchema.StringPropertyConfig
+                                                        .INDEXING_TYPE_PREFIXES)
+                                        .setTokenizerType(
+                                                AppSearchSchema.StringPropertyConfig
+                                                        .TOKENIZER_TYPE_PLAIN)
+                                        .build())
+                        .addProperty(
+                                new AppSearchSchema.BlobHandlePropertyConfig.Builder("blob")
+                                        .setCardinality(
+                                                AppSearchSchema.PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setDescription("The blob property")
+                                        .build())
+                        .build();
+
+        SchemaTypeConfigProto expectedEmailProto =
+                SchemaTypeConfigProto.newBuilder()
+                        .setSchemaType("Email")
+                        .setDescription("")
+                        .setVersion(12345)
+                        .addProperties(
+                                PropertyConfigProto.newBuilder()
+                                        .setPropertyName("subject")
+                                        .setDescription("")
+                                        .setDataType(PropertyConfigProto.DataType.Code.STRING)
+                                        .setCardinality(
+                                                PropertyConfigProto.Cardinality.Code.OPTIONAL)
+                                        .setStringIndexingConfig(
+                                                StringIndexingConfig.newBuilder()
+                                                        .setTokenizerType(
+                                                                StringIndexingConfig.TokenizerType
+                                                                        .Code.PLAIN)
+                                                        .setTermMatchType(
+                                                                TermMatchType.Code.PREFIX)))
+                        .addProperties(
+                                PropertyConfigProto.newBuilder()
+                                        .setPropertyName("blob")
+                                        .setDataType(PropertyConfigProto.DataType.Code.BLOB_HANDLE)
+                                        .setCardinality(
+                                                PropertyConfigProto.Cardinality.Code.OPTIONAL)
+                                        .setDescription("The blob property"))
                         .build();
 
         assertThat(
@@ -530,4 +664,67 @@ public class SchemaToProtoConverterTest {
         assertThat(SchemaToProtoConverter.toAppSearchSchema(expectedEmailProto))
                 .isEqualTo(emailSchema);
     }
+
+    @Test
+    public void testGetProto_withScorablePropertyEnabled() {
+        AppSearchSchema emailSchema =
+                new AppSearchSchema.Builder("Email")
+                        .addProperty(
+                                new AppSearchSchema.LongPropertyConfig.Builder("viewTimes")
+                                        .setCardinality(
+                                                AppSearchSchema.PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setScoringEnabled(true)
+                                        .build())
+                        .addProperty(
+                                new AppSearchSchema.DoublePropertyConfig.Builder("score")
+                                        .setCardinality(
+                                                AppSearchSchema.PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setScoringEnabled(true)
+                                        .build())
+                        .addProperty(
+                                new AppSearchSchema.BooleanPropertyConfig.Builder("read")
+                                        .setCardinality(
+                                                AppSearchSchema.PropertyConfig.CARDINALITY_OPTIONAL)
+                                        .setScoringEnabled(true)
+                                        .build())
+                        .build();
+
+        SchemaTypeConfigProto expectedProto =
+                SchemaTypeConfigProto.newBuilder()
+                        .setSchemaType("Email")
+                        .setDescription("")
+                        .setVersion(0)
+                        .addProperties(
+                                PropertyConfigProto.newBuilder()
+                                        .setPropertyName("viewTimes")
+                                        .setDescription("")
+                                        .setDataType(PropertyConfigProto.DataType.Code.INT64)
+                                        .setCardinality(
+                                                PropertyConfigProto.Cardinality.Code.OPTIONAL)
+                                        .setScorableType(
+                                                PropertyConfigProto.ScorableType.Code.ENABLED))
+                        .addProperties(
+                                PropertyConfigProto.newBuilder()
+                                        .setPropertyName("score")
+                                        .setDescription("")
+                                        .setDataType(PropertyConfigProto.DataType.Code.DOUBLE)
+                                        .setCardinality(
+                                                PropertyConfigProto.Cardinality.Code.OPTIONAL)
+                                        .setScorableType(
+                                                PropertyConfigProto.ScorableType.Code.ENABLED))
+                        .addProperties(
+                                PropertyConfigProto.newBuilder()
+                                        .setPropertyName("read")
+                                        .setDescription("")
+                                        .setDataType(PropertyConfigProto.DataType.Code.BOOLEAN)
+                                        .setCardinality(
+                                                PropertyConfigProto.Cardinality.Code.OPTIONAL)
+                                        .setScorableType(
+                                                PropertyConfigProto.ScorableType.Code.ENABLED))
+                        .build();
+
+        assertThat(SchemaToProtoConverter.toSchemaTypeConfigProto(emailSchema, /* version= */ 0))
+                .isEqualTo(expectedProto);
+        assertThat(SchemaToProtoConverter.toAppSearchSchema(expectedProto)).isEqualTo(emailSchema);
+    }
 }
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SearchResultToProtoConverterTest.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SearchResultToProtoConverterTest.java
index 26406721..a82fd93d 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SearchResultToProtoConverterTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SearchResultToProtoConverterTest.java
@@ -26,6 +26,7 @@ import android.app.appsearch.SearchResult;
 import android.app.appsearch.SearchResultPage;
 import android.app.appsearch.exceptions.AppSearchException;
 
+import com.android.appsearch.flags.Flags;
 import com.android.server.appsearch.external.localstorage.AppSearchConfigImpl;
 import com.android.server.appsearch.external.localstorage.LocalStorageIcingOptionsConfig;
 import com.android.server.appsearch.external.localstorage.SchemaCache;
@@ -35,6 +36,7 @@ import com.android.server.appsearch.icing.proto.DocumentProto;
 import com.android.server.appsearch.icing.proto.SchemaTypeConfigProto;
 import com.android.server.appsearch.icing.proto.SearchResultProto;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 
 import org.junit.Test;
@@ -43,6 +45,7 @@ import java.util.Map;
 
 public class SearchResultToProtoConverterTest {
     @Test
+    @SuppressWarnings("deprecation")
     public void testToSearchResultProto() throws Exception {
         final String prefix =
                 "com.package.foo"
@@ -51,21 +54,30 @@ public class SearchResultToProtoConverterTest {
                         + PrefixUtil.DATABASE_DELIMITER;
         final String id = "id";
         final String namespace = prefix + "namespace";
-        final String schemaType = prefix + "schema";
+        String schemaType = "schema";
+        String parentSchemaType = "parentSchema";
+        final String prefixedSchemaType = prefix + schemaType;
+        final String prefixedParentSchemaType = prefix + parentSchemaType;
         final AppSearchConfigImpl config =
                 new AppSearchConfigImpl(
-                        new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig());
+                        new UnlimitedLimitConfig(),
+                        new LocalStorageIcingOptionsConfig(),
+                        /* storeParentInfoAsSyntheticProperty= */ false,
+                        /* shouldRetrieveParentInfo= */ true);
 
         // Building the SearchResult received from query.
         DocumentProto.Builder documentProtoBuilder =
-                DocumentProto.newBuilder().setUri(id).setNamespace(namespace).setSchema(schemaType);
+                DocumentProto.newBuilder()
+                        .setUri(id)
+                        .setNamespace(namespace)
+                        .setSchema(prefixedSchemaType);
 
         // A joined document
         DocumentProto.Builder joinedDocProtoBuilder =
                 DocumentProto.newBuilder()
                         .setUri("id2")
                         .setNamespace(namespace)
-                        .setSchema(schemaType);
+                        .setSchema(prefixedSchemaType);
 
         SearchResultProto.ResultProto joinedResultProto =
                 SearchResultProto.ResultProto.newBuilder()
@@ -81,16 +93,26 @@ public class SearchResultToProtoConverterTest {
         SearchResultProto searchResultProto =
                 SearchResultProto.newBuilder().addResults(resultProto).build();
 
+        SchemaTypeConfigProto parentSchemaTypeConfigProto =
+                SchemaTypeConfigProto.newBuilder().setSchemaType(prefixedParentSchemaType).build();
         SchemaTypeConfigProto schemaTypeConfigProto =
-                SchemaTypeConfigProto.newBuilder().setSchemaType(schemaType).build();
+                SchemaTypeConfigProto.newBuilder()
+                        .addParentTypes(prefixedParentSchemaType)
+                        .setSchemaType(prefixedSchemaType)
+                        .build();
         Map<String, Map<String, SchemaTypeConfigProto>> schemaMap =
-                ImmutableMap.of(prefix, ImmutableMap.of(schemaType, schemaTypeConfigProto));
+                ImmutableMap.of(
+                        prefix,
+                        ImmutableMap.of(
+                                prefixedSchemaType, schemaTypeConfigProto,
+                                prefixedParentSchemaType, parentSchemaTypeConfigProto));
+        SchemaCache schemaCache = new SchemaCache(schemaMap);
 
         removePrefixesFromDocument(documentProtoBuilder);
         removePrefixesFromDocument(joinedDocProtoBuilder);
         SearchResultPage searchResultPage =
                 SearchResultToProtoConverter.toSearchResultPage(
-                        searchResultProto, new SchemaCache(schemaMap), config);
+                        searchResultProto, schemaCache, config);
         assertThat(searchResultPage.getResults()).hasSize(1);
         SearchResult result = searchResultPage.getResults().get(0);
         assertThat(result.getPackageName()).isEqualTo("com.package.foo");
@@ -98,19 +120,20 @@ public class SearchResultToProtoConverterTest {
         assertThat(result.getGenericDocument())
                 .isEqualTo(
                         GenericDocumentToProtoConverter.toGenericDocument(
-                                documentProtoBuilder.build(),
-                                prefix,
-                                schemaMap.get(prefix),
-                                config));
+                                documentProtoBuilder.build(), prefix, schemaCache, config));
 
         assertThat(result.getJoinedResults()).hasSize(1);
         assertThat(result.getJoinedResults().get(0).getGenericDocument())
                 .isEqualTo(
                         GenericDocumentToProtoConverter.toGenericDocument(
-                                joinedDocProtoBuilder.build(),
-                                prefix,
-                                schemaMap.get(prefix),
-                                config));
+                                joinedDocProtoBuilder.build(), prefix, schemaCache, config));
+
+        if (Flags.enableSearchResultParentTypes()) {
+            assertThat(result.getParentTypeMap())
+                    .isEqualTo(ImmutableMap.of(schemaType, ImmutableList.of(parentSchemaType)));
+        } else {
+            assertThat(result.getParentTypeMap()).isEmpty();
+        }
     }
 
     @Test
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverterTest.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverterTest.java
index 2f717d3b..292f37f1 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverterTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SearchSpecToProtoConverterTest.java
@@ -27,11 +27,15 @@ import static com.google.common.truth.Truth.assertThat;
 import android.app.appsearch.JoinSpec;
 import android.app.appsearch.SearchSpec;
 import android.app.appsearch.testutil.AppSearchTestUtils;
+import android.util.ArrayMap;
+import android.util.ArraySet;
 
+import com.android.server.appsearch.external.localstorage.AppSearchConfig;
 import com.android.server.appsearch.external.localstorage.AppSearchConfigImpl;
 import com.android.server.appsearch.external.localstorage.AppSearchImpl;
 import com.android.server.appsearch.external.localstorage.IcingOptionsConfig;
 import com.android.server.appsearch.external.localstorage.LocalStorageIcingOptionsConfig;
+import com.android.server.appsearch.external.localstorage.NamespaceCache;
 import com.android.server.appsearch.external.localstorage.OptimizeStrategy;
 import com.android.server.appsearch.external.localstorage.SchemaCache;
 import com.android.server.appsearch.external.localstorage.UnlimitedLimitConfig;
@@ -39,9 +43,12 @@ import com.android.server.appsearch.external.localstorage.util.PrefixUtil;
 import com.android.server.appsearch.external.localstorage.visibilitystore.CallerAccess;
 import com.android.server.appsearch.external.localstorage.visibilitystore.VisibilityStore;
 import com.android.server.appsearch.icing.proto.JoinSpecProto;
+import com.android.server.appsearch.icing.proto.NamespaceDocumentUriGroup;
 import com.android.server.appsearch.icing.proto.PropertyWeight;
 import com.android.server.appsearch.icing.proto.ResultSpecProto;
+import com.android.server.appsearch.icing.proto.SchemaTypeAliasMapProto;
 import com.android.server.appsearch.icing.proto.SchemaTypeConfigProto;
+import com.android.server.appsearch.icing.proto.ScoringFeatureType;
 import com.android.server.appsearch.icing.proto.ScoringSpecProto;
 import com.android.server.appsearch.icing.proto.SearchSpecProto;
 import com.android.server.appsearch.icing.proto.TypePropertyWeights;
@@ -71,15 +78,30 @@ public class SearchSpecToProtoConverterTest {
 
     private AppSearchImpl mAppSearchImpl;
 
+    private Map<String, Set<String>> extractSchemaToPrefixedSchemasMap(
+            ScoringSpecProto scoringSpecProto) {
+        Map<String, Set<String>> schemaToSchemaTypesMap = new ArrayMap<>();
+        for (SchemaTypeAliasMapProto schemaTypeAliasMapProto :
+                scoringSpecProto.getSchemaTypeAliasMapProtosList()) {
+            schemaToSchemaTypesMap.put(
+                    schemaTypeAliasMapProto.getAliasSchemaType(),
+                    new ArraySet<>(schemaTypeAliasMapProto.getSchemaTypesList()));
+        }
+        return schemaToSchemaTypesMap;
+    }
+
     @Before
     public void setUp() throws Exception {
+        AppSearchConfig config =
+                new AppSearchConfigImpl(
+                        new UnlimitedLimitConfig(), mLocalStorageIcingOptionsConfig);
         mAppSearchImpl =
                 AppSearchImpl.create(
                         mTemporaryFolder.newFolder(),
-                        new AppSearchConfigImpl(
-                                new UnlimitedLimitConfig(), mLocalStorageIcingOptionsConfig),
+                        config,
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
     }
 
@@ -100,13 +122,16 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "query",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(prefix1, prefix2),
-                        /* namespaceMap= */ ImmutableMap.of(
-                                prefix1,
-                                        ImmutableSet.of(
-                                                prefix1 + "namespace1", prefix1 + "namespace2"),
-                                prefix2,
-                                        ImmutableSet.of(
-                                                prefix2 + "namespace1", prefix2 + "namespace2")),
+                        new NamespaceCache(
+                                ImmutableMap.of(
+                                        prefix1,
+                                                ImmutableSet.of(
+                                                        prefix1 + "namespace1",
+                                                        prefix1 + "namespace2"),
+                                        prefix2,
+                                                ImmutableSet.of(
+                                                        prefix2 + "namespace1",
+                                                        prefix2 + "namespace2"))),
                         new SchemaCache(
                                 /* schemaMap= */ ImmutableMap.of(
                                         prefix1,
@@ -163,13 +188,16 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "query",
                         searchSpec.build(),
                         /* prefixes= */ ImmutableSet.of(prefix1, prefix2),
-                        /* namespaceMap= */ ImmutableMap.of(
-                                prefix1,
-                                        ImmutableSet.of(
-                                                prefix1 + "namespace1", prefix1 + "namespace2"),
-                                prefix2,
-                                        ImmutableSet.of(
-                                                prefix2 + "namespace1", prefix2 + "namespace2")),
+                        new NamespaceCache(
+                                ImmutableMap.of(
+                                        prefix1,
+                                                ImmutableSet.of(
+                                                        prefix1 + "namespace1",
+                                                        prefix1 + "namespace2"),
+                                        prefix2,
+                                                ImmutableSet.of(
+                                                        prefix2 + "namespace1",
+                                                        prefix2 + "namespace2"))),
                         new SchemaCache(
                                 /* schemaMap= */ ImmutableMap.of(
                                         prefix1,
@@ -240,11 +268,14 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "query",
                         searchSpec.build(),
                         /* prefixes= */ ImmutableSet.of(prefix1, prefix2),
-                        /* namespaceMap= */ ImmutableMap.of(
-                                prefix1,
-                                ImmutableSet.of(prefix1 + "namespace1", prefix1 + "namespace2"),
-                                prefix2,
-                                ImmutableSet.of(prefix2 + "namespace1", prefix2 + "namespace2")),
+                        new NamespaceCache(
+                                ImmutableMap.of(
+                                        prefix1,
+                                        ImmutableSet.of(
+                                                prefix1 + "namespace1", prefix1 + "namespace2"),
+                                        prefix2,
+                                        ImmutableSet.of(
+                                                prefix2 + "namespace1", prefix2 + "namespace2"))),
                         new SchemaCache(
                                 /* schemaMap= */ ImmutableMap.of(
                                         prefix1,
@@ -257,7 +288,8 @@ public class SearchSpecToProtoConverterTest {
                                                 prefix2 + "typeB", configProto))),
                         mLocalStorageIcingOptionsConfig);
 
-        VisibilityStore visibilityStore = new VisibilityStore(mAppSearchImpl);
+        VisibilityStore visibilityStore =
+                VisibilityStore.createDocumentVisibilityStore(mAppSearchImpl);
         converter.removeInaccessibleSchemaFilter(
                 new CallerAccess(/* callingPackageName= */ "package"),
                 visibilityStore,
@@ -291,7 +323,7 @@ public class SearchSpecToProtoConverterTest {
     }
 
     @Test
-    public void testToScoringSpecProto() {
+    public void testToScoringSpecProto() throws Exception {
         String prefix = PrefixUtil.createPrefix("package", "database1");
         String schemaType = "schemaType";
         String namespace = "namespace";
@@ -307,8 +339,9 @@ public class SearchSpecToProtoConverterTest {
                                 /* queryExpression= */ "",
                                 searchSpec,
                                 /* prefixes= */ ImmutableSet.of(prefix),
-                                /* namespaceMap= */ ImmutableMap.of(
-                                        prefix, ImmutableSet.of(prefix + namespace)),
+                                new NamespaceCache(
+                                        ImmutableMap.of(
+                                                prefix, ImmutableSet.of(prefix + namespace))),
                                 new SchemaCache(
                                         /* schemaMap= */ ImmutableMap.of(
                                                 prefix,
@@ -336,6 +369,51 @@ public class SearchSpecToProtoConverterTest {
                 .containsExactly(typePropertyWeights);
     }
 
+    @Test
+    public void testGenerateScoringSpecProtoWhenScorableRankingIsEnabled() throws Exception {
+        String prefix1 = PrefixUtil.createPrefix("package1", "database2");
+        String prefix2 = PrefixUtil.createPrefix("package2", "database1");
+        String gmailSchemaType = "gmail";
+        String personSchemaType = "person";
+
+        SearchSpec searchSpec =
+                new SearchSpec.Builder()
+                        .setRankingStrategy(RANKING_STRATEGY_RELEVANCE_SCORE)
+                        .setScorablePropertyRankingEnabled(true)
+                        .build();
+        SchemaTypeConfigProto configProto = SchemaTypeConfigProto.getDefaultInstance();
+        ScoringSpecProto scoringSpecProto =
+                new SearchSpecToProtoConverter(
+                                /* queryExpression= */ "",
+                                searchSpec,
+                                /* prefixes= */ ImmutableSet.of(prefix1, prefix2),
+                                new NamespaceCache(
+                                        ImmutableMap.of(
+                                                prefix1, ImmutableSet.of(prefix1 + "namespace1"),
+                                                prefix2, ImmutableSet.of(prefix2 + "namespace1"))),
+                                new SchemaCache(
+                                        /* schemaMap= */ ImmutableMap.of(
+                                                prefix1,
+                                                ImmutableMap.of(
+                                                        prefix1 + gmailSchemaType, configProto,
+                                                        prefix1 + personSchemaType, configProto),
+                                                prefix2,
+                                                ImmutableMap.of(
+                                                        prefix2 + gmailSchemaType, configProto))),
+                                mLocalStorageIcingOptionsConfig)
+                        .toScoringSpecProto();
+        assertThat(scoringSpecProto.getScoringFeatureTypesEnabledList())
+                .containsExactly(ScoringFeatureType.SCORABLE_PROPERTY_RANKING);
+        Map<String, Set<String>> schemaToPrefixedSchemasMap =
+                extractSchemaToPrefixedSchemasMap(scoringSpecProto);
+        assertThat(schemaToPrefixedSchemasMap)
+                .containsExactly(
+                        "person",
+                        ImmutableSet.of("package1$database2/person"),
+                        "gmail",
+                        ImmutableSet.of("package1$database2/gmail", "package2$database1/gmail"));
+    }
+
     @Test
     public void testToAdvancedRankingSpecProto() {
         SearchSpec searchSpec =
@@ -349,7 +427,7 @@ public class SearchSpecToProtoConverterTest {
                                 /* queryExpression= */ "query",
                                 searchSpec,
                                 /* prefixes= */ ImmutableSet.of(),
-                                /* namespaceMap= */ ImmutableMap.of(),
+                                new NamespaceCache(ImmutableMap.of()),
                                 new SchemaCache(),
                                 mLocalStorageIcingOptionsConfig)
                         .toScoringSpecProto();
@@ -377,11 +455,11 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "query",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(),
-                        /* namespaceMap= */ ImmutableMap.of(),
+                        new NamespaceCache(ImmutableMap.of()),
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
         ResultSpecProto resultSpecProto =
-                convert.toResultSpecProto(/* namespaceMap= */ ImmutableMap.of(), new SchemaCache());
+                convert.toResultSpecProto(new NamespaceCache(ImmutableMap.of()), new SchemaCache());
 
         assertThat(resultSpecProto.getNumPerPage()).isEqualTo(123);
         assertThat(resultSpecProto.getSnippetSpec().getNumToSnippet()).isEqualTo(234);
@@ -420,13 +498,13 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "query",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(),
-                        /* namespaceMap= */ ImmutableMap.of(),
+                        new NamespaceCache(ImmutableMap.of()),
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
 
         ResultSpecProto resultSpecProto =
                 converter.toResultSpecProto(
-                        /* namespaceMap= */ ImmutableMap.of(), new SchemaCache());
+                        new NamespaceCache(ImmutableMap.of()), new SchemaCache());
 
         assertThat(resultSpecProto.getNumPerPage()).isEqualTo(123);
         assertThat(resultSpecProto.getSnippetSpec().getNumToSnippet()).isEqualTo(234);
@@ -445,10 +523,11 @@ public class SearchSpecToProtoConverterTest {
                 ImmutableMap.of(
                         personPrefix, ImmutableMap.of(personPrefix + "typeA", configProto),
                         actionPrefix, ImmutableMap.of(actionPrefix + "typeA", configProto));
-        Map<String, Set<String>> namespaceMap =
-                ImmutableMap.of(
-                        personPrefix, ImmutableSet.of(personPrefix + "namespaceA"),
-                        actionPrefix, ImmutableSet.of(actionPrefix + "namespaceA"));
+        NamespaceCache namespaceCache =
+                new NamespaceCache(
+                        ImmutableMap.of(
+                                personPrefix, ImmutableSet.of(personPrefix + "namespaceA"),
+                                actionPrefix, ImmutableSet.of(actionPrefix + "namespaceA")));
 
         SearchSpec nestedSearchSpec =
                 new SearchSpec.Builder()
@@ -474,12 +553,12 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "query",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(personPrefix, actionPrefix),
-                        namespaceMap,
+                        namespaceCache,
                         new SchemaCache(schemaMap),
                         mLocalStorageIcingOptionsConfig);
 
         ResultSpecProto resultSpecProto =
-                converter.toResultSpecProto(namespaceMap, new SchemaCache(schemaMap));
+                converter.toResultSpecProto(namespaceCache, new SchemaCache(schemaMap));
 
         assertThat(resultSpecProto.getResultGroupingsCount()).isEqualTo(1);
         assertThat(resultSpecProto.getResultGroupings(0).getEntryGroupings(0).getNamespace())
@@ -492,7 +571,7 @@ public class SearchSpecToProtoConverterTest {
     }
 
     @Test
-    public void testToResultSpecProto_projection_withJoinSpec_packageFilter() {
+    public void testToResultSpecProto_projection_withJoinSpec_packageFilter() throws Exception {
         String personPrefix = PrefixUtil.createPrefix("contacts", "database");
         String actionPrefix = PrefixUtil.createPrefix("aiai", "database");
 
@@ -501,10 +580,11 @@ public class SearchSpecToProtoConverterTest {
                 ImmutableMap.of(
                         personPrefix, ImmutableMap.of(personPrefix + "Person", configProto),
                         actionPrefix, ImmutableMap.of(actionPrefix + "ContactAction", configProto));
-        Map<String, Set<String>> namespaceMap =
-                ImmutableMap.of(
-                        personPrefix, ImmutableSet.of(personPrefix + "namespaceA"),
-                        actionPrefix, ImmutableSet.of(actionPrefix + "namespaceA"));
+        NamespaceCache namespaceCache =
+                new NamespaceCache(
+                        ImmutableMap.of(
+                                personPrefix, ImmutableSet.of(personPrefix + "namespaceA"),
+                                actionPrefix, ImmutableSet.of(actionPrefix + "namespaceA")));
 
         SearchSpec nestedSearchSpec =
                 new SearchSpec.Builder()
@@ -530,12 +610,12 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "query",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(personPrefix, actionPrefix),
-                        namespaceMap,
+                        namespaceCache,
                         new SchemaCache(schemaMap),
                         mLocalStorageIcingOptionsConfig);
 
         ResultSpecProto resultSpecProto =
-                converter.toResultSpecProto(namespaceMap, new SchemaCache(schemaMap));
+                converter.toResultSpecProto(namespaceCache, new SchemaCache(schemaMap));
 
         assertThat(resultSpecProto.getTypePropertyMasksCount()).isEqualTo(1);
         assertThat(resultSpecProto.getTypePropertyMasks(0).getSchemaType())
@@ -567,13 +647,13 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "query",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(personPrefix, actionPrefix),
-                        /* namespaceMap= */ ImmutableMap.of(),
+                        new NamespaceCache(ImmutableMap.of()),
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
 
         ResultSpecProto resultSpecProto =
                 converter.toResultSpecProto(
-                        /* namespaceMap= */ ImmutableMap.of(), new SchemaCache());
+                        new NamespaceCache(ImmutableMap.of()), new SchemaCache());
 
         assertThat(resultSpecProto.getTypePropertyMasksCount()).isEqualTo(1);
         assertThat(resultSpecProto.getTypePropertyMasks(0).getSchemaType())
@@ -596,13 +676,13 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "query",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(),
-                        /* namespaceMap= */ ImmutableMap.of(),
+                        new NamespaceCache(ImmutableMap.of()),
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
 
         ResultSpecProto resultSpecProto =
                 converter.toResultSpecProto(
-                        /* namespaceMap= */ ImmutableMap.of(), new SchemaCache());
+                        new NamespaceCache(ImmutableMap.of()), new SchemaCache());
 
         assertThat(resultSpecProto.getTypePropertyMasksCount()).isEqualTo(1);
         assertThat(resultSpecProto.getTypePropertyMasks(0).getSchemaType())
@@ -611,7 +691,8 @@ public class SearchSpecToProtoConverterTest {
     }
 
     @Test
-    public void testToResultSpecProto_projection_removeSchemaWithoutParentInFilter() {
+    public void testToResultSpecProto_projection_removeSchemaWithoutParentInFilter()
+            throws Exception {
         SearchSpec searchSpec =
                 new SearchSpec.Builder()
                         .addFilterSchemas("Person")
@@ -636,20 +717,21 @@ public class SearchSpecToProtoConverterTest {
                                 "package$database/Person", personSchema,
                                 "package$database/Artist", artistSchema,
                                 "package$database/Other", otherSchema));
-        Map<String, Set<String>> namespaceMap =
-                ImmutableMap.of(prefix, ImmutableSet.of("package$database/namespace"));
+        NamespaceCache namespaceCache =
+                new NamespaceCache(
+                        ImmutableMap.of(prefix, ImmutableSet.of("package$database/namespace")));
 
         SearchSpecToProtoConverter converter =
                 new SearchSpecToProtoConverter(
                         /* queryExpression= */ "",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(prefix),
-                        /* namespaceMap= */ namespaceMap,
+                        namespaceCache,
                         new SchemaCache(schemaMap),
                         mLocalStorageIcingOptionsConfig);
 
         ResultSpecProto resultSpecProto =
-                converter.toResultSpecProto(namespaceMap, new SchemaCache(schemaMap));
+                converter.toResultSpecProto(namespaceCache, new SchemaCache(schemaMap));
 
         // The "name" property specified in Artist's projection should remain in the result,
         // since even though Artist doesn't exist in the original schema filters directly, we have
@@ -663,7 +745,7 @@ public class SearchSpecToProtoConverterTest {
     }
 
     @Test
-    public void testToSearchSpecProto_propertyFilter_withJoinSpec_packageFilter() {
+    public void testToSearchSpecProto_propertyFilter_withJoinSpec_packageFilter() throws Exception {
         String personPrefix = PrefixUtil.createPrefix("contacts", "database");
         String actionPrefix = PrefixUtil.createPrefix("aiai", "database");
 
@@ -672,10 +754,11 @@ public class SearchSpecToProtoConverterTest {
                 ImmutableMap.of(
                         personPrefix, ImmutableMap.of(personPrefix + "Person", configProto),
                         actionPrefix, ImmutableMap.of(actionPrefix + "ContactAction", configProto));
-        Map<String, Set<String>> namespaceMap =
-                ImmutableMap.of(
-                        personPrefix, ImmutableSet.of(personPrefix + "namespaceA"),
-                        actionPrefix, ImmutableSet.of(actionPrefix + "namespaceA"));
+        NamespaceCache namespaceCache =
+                new NamespaceCache(
+                        ImmutableMap.of(
+                                personPrefix, ImmutableSet.of(personPrefix + "namespaceA"),
+                                actionPrefix, ImmutableSet.of(actionPrefix + "namespaceA")));
 
         SearchSpec nestedSearchSpec =
                 new SearchSpec.Builder()
@@ -701,7 +784,7 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "query",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(personPrefix, actionPrefix),
-                        namespaceMap,
+                        namespaceCache,
                         new SchemaCache(schemaMap),
                         mLocalStorageIcingOptionsConfig);
 
@@ -736,7 +819,7 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "query",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(personPrefix, actionPrefix),
-                        /* namespaceMap= */ ImmutableMap.of(),
+                        new NamespaceCache(ImmutableMap.of()),
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
 
@@ -749,7 +832,8 @@ public class SearchSpecToProtoConverterTest {
     }
 
     @Test
-    public void testToSearchSpecProto_propertyFilter_removeSchemaWithoutParentInFilter() {
+    public void testToSearchSpecProto_propertyFilter_removeSchemaWithoutParentInFilter()
+            throws Exception {
         SearchSpec searchSpec =
                 new SearchSpec.Builder()
                         .addFilterSchemas("Person")
@@ -774,15 +858,16 @@ public class SearchSpecToProtoConverterTest {
                                 "package$database/Person", personSchema,
                                 "package$database/Artist", artistSchema,
                                 "package$database/Other", otherSchema));
-        Map<String, Set<String>> namespaceMap =
-                ImmutableMap.of(prefix, ImmutableSet.of("package$database/namespace"));
+        NamespaceCache namespaceCache =
+                new NamespaceCache(
+                        ImmutableMap.of(prefix, ImmutableSet.of("package$database/namespace")));
 
         SearchSpecToProtoConverter converter =
                 new SearchSpecToProtoConverter(
                         /* queryExpression= */ "",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(prefix),
-                        /* namespaceMap= */ namespaceMap,
+                        namespaceCache,
                         new SchemaCache(schemaMap),
                         mLocalStorageIcingOptionsConfig);
 
@@ -809,10 +894,11 @@ public class SearchSpecToProtoConverterTest {
                 ImmutableMap.of(
                         personPrefix, ImmutableMap.of(personPrefix + "Person", configProto),
                         actionPrefix, ImmutableMap.of(actionPrefix + "ContactAction", configProto));
-        Map<String, Set<String>> namespaceMap =
-                ImmutableMap.of(
-                        personPrefix, ImmutableSet.of(personPrefix + "namespaceA"),
-                        actionPrefix, ImmutableSet.of(actionPrefix + "namespaceA"));
+        NamespaceCache namespaceCache =
+                new NamespaceCache(
+                        ImmutableMap.of(
+                                personPrefix, ImmutableSet.of(personPrefix + "namespaceA"),
+                                actionPrefix, ImmutableSet.of(actionPrefix + "namespaceA")));
 
         SearchSpec nestedSearchSpec =
                 new SearchSpec.Builder()
@@ -839,7 +925,7 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "query",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(personPrefix, actionPrefix),
-                        namespaceMap,
+                        namespaceCache,
                         new SchemaCache(schemaMap),
                         mLocalStorageIcingOptionsConfig);
 
@@ -881,18 +967,21 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "query",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(prefix1, prefix2),
-                        /* namespaceMap= */ ImmutableMap.of(),
+                        new NamespaceCache(ImmutableMap.of()),
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
         ResultSpecProto resultSpecProto =
                 converter.toResultSpecProto(
-                        /* namespaceMap= */ ImmutableMap.of(
-                                prefix1,
-                                        ImmutableSet.of(
-                                                prefix1 + "namespaceA", prefix1 + "namespaceB"),
-                                prefix2,
-                                        ImmutableSet.of(
-                                                prefix2 + "namespaceA", prefix2 + "namespaceB")),
+                        new NamespaceCache(
+                                ImmutableMap.of(
+                                        prefix1,
+                                                ImmutableSet.of(
+                                                        prefix1 + "namespaceA",
+                                                        prefix1 + "namespaceB"),
+                                        prefix2,
+                                                ImmutableSet.of(
+                                                        prefix2 + "namespaceA",
+                                                        prefix2 + "namespaceB"))),
                         new SchemaCache());
 
         assertThat(resultSpecProto.getResultGroupingsCount()).isEqualTo(2);
@@ -923,20 +1012,25 @@ public class SearchSpecToProtoConverterTest {
         String prefix1 = PrefixUtil.createPrefix("package1", "database");
         String prefix2 = PrefixUtil.createPrefix("package2", "database");
 
-        Map<String, Set<String>> namespaceMap =
-                ImmutableMap.of(
-                        prefix1, ImmutableSet.of(prefix1 + "namespaceA", prefix1 + "namespaceB"),
-                        prefix2, ImmutableSet.of(prefix2 + "namespaceA", prefix2 + "namespaceB"));
+        NamespaceCache namespaceCache =
+                new NamespaceCache(
+                        ImmutableMap.of(
+                                prefix1,
+                                        ImmutableSet.of(
+                                                prefix1 + "namespaceA", prefix1 + "namespaceB"),
+                                prefix2,
+                                        ImmutableSet.of(
+                                                prefix2 + "namespaceA", prefix2 + "namespaceB")));
         SearchSpecToProtoConverter converter =
                 new SearchSpecToProtoConverter(
                         /* queryExpression= */ "query",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(prefix1, prefix2),
-                        namespaceMap,
+                        namespaceCache,
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
         ResultSpecProto resultSpecProto =
-                converter.toResultSpecProto(namespaceMap, new SchemaCache());
+                converter.toResultSpecProto(namespaceCache, new SchemaCache());
 
         assertThat(resultSpecProto.getResultGroupingsCount()).isEqualTo(2);
         // First grouping should have same namespace.
@@ -979,12 +1073,12 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "query",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(prefix1, prefix2),
-                        /* namespaceMap= */ ImmutableMap.of(),
+                        new NamespaceCache(ImmutableMap.of()),
                         new SchemaCache(schemaMap),
                         mLocalStorageIcingOptionsConfig);
         ResultSpecProto resultSpecProto =
                 converter.toResultSpecProto(
-                        /* namespaceMap= */ ImmutableMap.of(), new SchemaCache(schemaMap));
+                        new NamespaceCache(ImmutableMap.of()), new SchemaCache(schemaMap));
 
         assertThat(resultSpecProto.getResultGroupingsCount()).isEqualTo(2);
         // First grouping should have the same schema type.
@@ -1011,21 +1105,26 @@ public class SearchSpecToProtoConverterTest {
 
         String prefix1 = PrefixUtil.createPrefix("package1", "database");
         String prefix2 = PrefixUtil.createPrefix("package2", "database");
-        Map<String, Set<String>> namespaceMap =
-                /* namespaceMap= */ ImmutableMap.of(
-                        prefix1, ImmutableSet.of(prefix1 + "namespaceA", prefix1 + "namespaceB"),
-                        prefix2, ImmutableSet.of(prefix2 + "namespaceA", prefix2 + "namespaceB"));
+        NamespaceCache namespaceCache =
+                new NamespaceCache(
+                        ImmutableMap.of(
+                                prefix1,
+                                        ImmutableSet.of(
+                                                prefix1 + "namespaceA", prefix1 + "namespaceB"),
+                                prefix2,
+                                        ImmutableSet.of(
+                                                prefix2 + "namespaceA", prefix2 + "namespaceB")));
 
         SearchSpecToProtoConverter converter =
                 new SearchSpecToProtoConverter(
                         /* queryExpression= */ "query",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(prefix1, prefix2),
-                        namespaceMap,
+                        namespaceCache,
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
         ResultSpecProto resultSpecProto =
-                converter.toResultSpecProto(namespaceMap, new SchemaCache());
+                converter.toResultSpecProto(namespaceCache, new SchemaCache());
 
         // All namespace should be separated.
         assertThat(resultSpecProto.getResultGroupingsCount()).isEqualTo(4);
@@ -1062,12 +1161,12 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "query",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(prefix1, prefix2),
-                        /* namespaceMap= */ ImmutableMap.of(),
+                        new NamespaceCache(ImmutableMap.of()),
                         new SchemaCache(schemaMap),
                         mLocalStorageIcingOptionsConfig);
         ResultSpecProto resultSpecProto =
                 converter.toResultSpecProto(
-                        /* namespaceMap= */ ImmutableMap.of(), new SchemaCache(schemaMap));
+                        new NamespaceCache(ImmutableMap.of()), new SchemaCache(schemaMap));
 
         // All schema should be separated.
         assertThat(resultSpecProto.getResultGroupingsCount()).isEqualTo(4);
@@ -1089,10 +1188,15 @@ public class SearchSpecToProtoConverterTest {
 
         String prefix1 = PrefixUtil.createPrefix("package1", "database");
         String prefix2 = PrefixUtil.createPrefix("package2", "database");
-        Map<String, Set<String>> namespaceMap =
-                /* namespaceMap= */ ImmutableMap.of(
-                        prefix1, ImmutableSet.of(prefix1 + "namespaceA", prefix1 + "namespaceB"),
-                        prefix2, ImmutableSet.of(prefix2 + "namespaceA", prefix2 + "namespaceB"));
+        NamespaceCache namespaceCache =
+                new NamespaceCache(
+                        ImmutableMap.of(
+                                prefix1,
+                                        ImmutableSet.of(
+                                                prefix1 + "namespaceA", prefix1 + "namespaceB"),
+                                prefix2,
+                                        ImmutableSet.of(
+                                                prefix2 + "namespaceA", prefix2 + "namespaceB")));
         SchemaTypeConfigProto configProto = SchemaTypeConfigProto.getDefaultInstance();
         Map<String, Map<String, SchemaTypeConfigProto>> schemaMap =
                 ImmutableMap.of(
@@ -1110,11 +1214,11 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "query",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(prefix1, prefix2),
-                        namespaceMap,
+                        namespaceCache,
                         new SchemaCache(schemaMap),
                         mLocalStorageIcingOptionsConfig);
         ResultSpecProto resultSpecProto =
-                converter.toResultSpecProto(namespaceMap, new SchemaCache(schemaMap));
+                converter.toResultSpecProto(namespaceCache, new SchemaCache(schemaMap));
 
         assertThat(resultSpecProto.getResultGroupingsCount()).isEqualTo(4);
         ResultSpecProto.ResultGrouping grouping1 = resultSpecProto.getResultGroupings(0);
@@ -1178,10 +1282,15 @@ public class SearchSpecToProtoConverterTest {
                         .build();
         String prefix1 = PrefixUtil.createPrefix("package1", "database");
         String prefix2 = PrefixUtil.createPrefix("package2", "database");
-        Map<String, Set<String>> namespaceMap =
-                /* namespaceMap= */ ImmutableMap.of(
-                        prefix1, ImmutableSet.of(prefix1 + "namespaceA", prefix1 + "namespaceB"),
-                        prefix2, ImmutableSet.of(prefix2 + "namespaceA", prefix2 + "namespaceB"));
+        NamespaceCache namespaceCache =
+                new NamespaceCache(
+                        ImmutableMap.of(
+                                prefix1,
+                                        ImmutableSet.of(
+                                                prefix1 + "namespaceA", prefix1 + "namespaceB"),
+                                prefix2,
+                                        ImmutableSet.of(
+                                                prefix2 + "namespaceA", prefix2 + "namespaceB")));
         SchemaTypeConfigProto configProto = SchemaTypeConfigProto.getDefaultInstance();
         Map<String, Map<String, SchemaTypeConfigProto>> schemaMap =
                 ImmutableMap.of(
@@ -1199,11 +1308,11 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "query",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(prefix1, prefix2),
-                        namespaceMap,
+                        namespaceCache,
                         new SchemaCache(schemaMap),
                         mLocalStorageIcingOptionsConfig);
         ResultSpecProto resultSpecProto =
-                converter.toResultSpecProto(namespaceMap, new SchemaCache(schemaMap));
+                converter.toResultSpecProto(namespaceCache, new SchemaCache(schemaMap));
 
         assertThat(resultSpecProto.getResultGroupingsCount()).isEqualTo(8);
         ResultSpecProto.ResultGrouping grouping1 = resultSpecProto.getResultGroupings(0);
@@ -1278,22 +1387,23 @@ public class SearchSpecToProtoConverterTest {
         String prefix1 = PrefixUtil.createPrefix("package", "database1");
         String prefix2 = PrefixUtil.createPrefix("package", "database2");
         // search both prefixes
-        Map<String, Set<String>> namespaceMap =
-                ImmutableMap.of(
-                        prefix1,
-                                ImmutableSet.of(
-                                        "package$database1/namespace1",
-                                        "package$database1/namespace2"),
-                        prefix2,
-                                ImmutableSet.of(
-                                        "package$database2/namespace3",
-                                        "package$database2/namespace4"));
+        NamespaceCache namespaceCache =
+                new NamespaceCache(
+                        ImmutableMap.of(
+                                prefix1,
+                                        ImmutableSet.of(
+                                                "package$database1/namespace1",
+                                                "package$database1/namespace2"),
+                                prefix2,
+                                        ImmutableSet.of(
+                                                "package$database2/namespace3",
+                                                "package$database2/namespace4")));
         SearchSpecToProtoConverter converter =
                 new SearchSpecToProtoConverter(
                         /* queryExpression= */ "",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(prefix1, prefix2),
-                        namespaceMap,
+                        namespaceCache,
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
 
@@ -1317,15 +1427,16 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(prefix1),
-                        /* namespaceMap= */ ImmutableMap.of(
-                                prefix1,
-                                        ImmutableSet.of(
-                                                "package$database1/namespace1",
-                                                "package$database1/namespace2"),
-                                prefix2,
-                                        ImmutableSet.of(
-                                                "package$database2/namespace3",
-                                                "package$database2/namespace4")),
+                        new NamespaceCache(
+                                ImmutableMap.of(
+                                        prefix1,
+                                                ImmutableSet.of(
+                                                        "package$database1/namespace1",
+                                                        "package$database1/namespace2"),
+                                        prefix2,
+                                                ImmutableSet.of(
+                                                        "package$database2/namespace3",
+                                                        "package$database2/namespace4"))),
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
 
@@ -1347,11 +1458,12 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(prefix1),
-                        /* namespaceMap= */ ImmutableMap.of(
-                                prefix1,
-                                ImmutableSet.of(
-                                        "package$database1/namespace1",
-                                        "package$database1/namespace2")),
+                        new NamespaceCache(
+                                ImmutableMap.of(
+                                        prefix1,
+                                        ImmutableSet.of(
+                                                "package$database1/namespace1",
+                                                "package$database1/namespace2"))),
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
         SearchSpecProto searchSpecProto = converter.toSearchSpecProto();
@@ -1373,11 +1485,12 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(prefix1),
-                        /* namespaceMap= */ ImmutableMap.of(
-                                prefix1,
-                                ImmutableSet.of(
-                                        "package$database1/namespace1",
-                                        "package$database1/namespace2")),
+                        new NamespaceCache(
+                                ImmutableMap.of(
+                                        prefix1,
+                                        ImmutableSet.of(
+                                                "package$database1/namespace1",
+                                                "package$database1/namespace2"))),
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
         SearchSpecProto searchSpecProto = converter.toSearchSpecProto();
@@ -1388,7 +1501,7 @@ public class SearchSpecToProtoConverterTest {
     }
 
     @Test
-    public void testGetTargetSchemaFilters_emptySearchingFilter() {
+    public void testGetTargetSchemaFilters_emptySearchingFilter() throws Exception {
         SearchSpec searchSpec = new SearchSpec.Builder().build();
         String prefix1 = createPrefix("package", "database1");
         String prefix2 = createPrefix("package", "database2");
@@ -1399,8 +1512,9 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(prefix1, prefix2),
-                        /* namespaceMap= */ ImmutableMap.of(
-                                prefix1, ImmutableSet.of("package$database1/namespace1")),
+                        new NamespaceCache(
+                                ImmutableMap.of(
+                                        prefix1, ImmutableSet.of("package$database1/namespace1"))),
                         new SchemaCache(
                                 /* schemaMap= */ ImmutableMap.of(
                                         prefix1,
@@ -1425,7 +1539,7 @@ public class SearchSpecToProtoConverterTest {
     }
 
     @Test
-    public void testGetTargetSchemaFilters_searchPartialFilter() {
+    public void testGetTargetSchemaFilters_searchPartialFilter() throws Exception {
         SearchSpec searchSpec = new SearchSpec.Builder().build();
         String prefix1 = createPrefix("package", "database1");
         String prefix2 = createPrefix("package", "database2");
@@ -1437,8 +1551,9 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(prefix1),
-                        /* namespaceMap= */ ImmutableMap.of(
-                                prefix1, ImmutableSet.of("package$database1/namespace1")),
+                        new NamespaceCache(
+                                ImmutableMap.of(
+                                        prefix1, ImmutableSet.of("package$database1/namespace1"))),
                         new SchemaCache(
                                 /* schemaMap= */ ImmutableMap.of(
                                         prefix1,
@@ -1461,7 +1576,7 @@ public class SearchSpecToProtoConverterTest {
     }
 
     @Test
-    public void testGetTargetSchemaFilters_intersectionWithSearchingFilter() {
+    public void testGetTargetSchemaFilters_intersectionWithSearchingFilter() throws Exception {
         // Put some searching schemas.
         SearchSpec searchSpec =
                 new SearchSpec.Builder().addFilterSchemas("typeA", "nonExist").build();
@@ -1473,8 +1588,9 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(prefix1),
-                        /* namespaceMap= */ ImmutableMap.of(
-                                prefix1, ImmutableSet.of("package$database1/namespace1")),
+                        new NamespaceCache(
+                                ImmutableMap.of(
+                                        prefix1, ImmutableSet.of("package$database1/namespace1"))),
                         new SchemaCache(
                                 /* schemaMap= */ ImmutableMap.of(
                                         prefix1,
@@ -1491,7 +1607,7 @@ public class SearchSpecToProtoConverterTest {
     }
 
     @Test
-    public void testGetTargetSchemaFilters_polymorphismExpansion() {
+    public void testGetTargetSchemaFilters_polymorphismExpansion() throws Exception {
         SearchSpec searchSpec =
                 new SearchSpec.Builder().addFilterSchemas("Person", "nonExist").build();
         String prefix = createPrefix("package", "database");
@@ -1517,8 +1633,9 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(prefix),
-                        /* namespaceMap= */ ImmutableMap.of(
-                                prefix, ImmutableSet.of("package$database/namespace")),
+                        new NamespaceCache(
+                                ImmutableMap.of(
+                                        prefix, ImmutableSet.of("package$database/namespace"))),
                         new SchemaCache(schemaMap),
                         mLocalStorageIcingOptionsConfig);
         SearchSpecProto searchSpecProto = converter.toSearchSpecProto();
@@ -1529,7 +1646,7 @@ public class SearchSpecToProtoConverterTest {
     }
 
     @Test
-    public void testGetTargetSchemaFilters_polymorphismExpansion_multipleLevel() {
+    public void testGetTargetSchemaFilters_polymorphismExpansion_multipleLevel() throws Exception {
         SearchSpec searchSpec = new SearchSpec.Builder().addFilterSchemas("A", "B").build();
         String prefix = createPrefix("package", "database");
         SchemaTypeConfigProto schemaA =
@@ -1567,8 +1684,9 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(prefix),
-                        /* namespaceMap= */ ImmutableMap.of(
-                                prefix, ImmutableSet.of("package$database/namespace")),
+                        new NamespaceCache(
+                                ImmutableMap.of(
+                                        prefix, ImmutableSet.of("package$database/namespace"))),
                         new SchemaCache(schemaMap),
                         mLocalStorageIcingOptionsConfig);
         SearchSpecProto searchSpecProto = converter.toSearchSpecProto();
@@ -1582,7 +1700,7 @@ public class SearchSpecToProtoConverterTest {
     }
 
     @Test
-    public void testGetTargetSchemaFilters_intersectionWithNonExistFilter() {
+    public void testGetTargetSchemaFilters_intersectionWithNonExistFilter() throws Exception {
         // Put non-exist searching schema.
         SearchSpec searchSpec = new SearchSpec.Builder().addFilterSchemas("nonExist").build();
         String prefix1 = createPrefix("package", "database1");
@@ -1593,8 +1711,9 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(prefix1),
-                        /* namespaceMap= */ ImmutableMap.of(
-                                prefix1, ImmutableSet.of("package$database1/namespace1")),
+                        new NamespaceCache(
+                                ImmutableMap.of(
+                                        prefix1, ImmutableSet.of("package$database1/namespace1"))),
                         new SchemaCache(
                                 /* schemaMap= */ ImmutableMap.of(
                                         prefix1,
@@ -1610,7 +1729,8 @@ public class SearchSpecToProtoConverterTest {
 
     @Test
     public void testRemoveInaccessibleSchemaFilter() throws Exception {
-        VisibilityStore visibilityStore = new VisibilityStore(mAppSearchImpl);
+        VisibilityStore visibilityStore =
+                VisibilityStore.createDocumentVisibilityStore(mAppSearchImpl);
 
         final String prefix = PrefixUtil.createPrefix("package", "database");
         SchemaTypeConfigProto schemaTypeConfigProto =
@@ -1625,8 +1745,9 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "",
                         new SearchSpec.Builder().setJoinSpec(joinSpec).build(),
                         /* prefixes= */ ImmutableSet.of(prefix),
-                        /* namespaceMap= */ ImmutableMap.of(
-                                prefix, ImmutableSet.of("package$database/namespace1")),
+                        new NamespaceCache(
+                                ImmutableMap.of(
+                                        prefix, ImmutableSet.of("package$database/namespace1"))),
                         new SchemaCache(
                                 /* schemaMap= */ ImmutableMap.of(
                                         prefix,
@@ -1656,7 +1777,7 @@ public class SearchSpecToProtoConverterTest {
     }
 
     @Test
-    public void testIsNothingToSearch() {
+    public void testIsNothingToSearch() throws Exception {
         String prefix = PrefixUtil.createPrefix("package", "database");
         SearchSpec nestedSearchSpec = new SearchSpec.Builder().build();
         JoinSpec joinSpec =
@@ -1674,15 +1795,16 @@ public class SearchSpecToProtoConverterTest {
         Map<String, Map<String, SchemaTypeConfigProto>> schemaMap =
                 ImmutableMap.of(
                         prefix, ImmutableMap.of("package$database/schema", schemaTypeConfigProto));
-        Map<String, Set<String>> namespaceMap =
-                ImmutableMap.of(prefix, ImmutableSet.of("package$database/namespace"));
+        NamespaceCache namespaceCache =
+                new NamespaceCache(
+                        ImmutableMap.of(prefix, ImmutableSet.of("package$database/namespace")));
 
         SearchSpecToProtoConverter emptySchemaConverter =
                 new SearchSpecToProtoConverter(
                         /* queryExpression= */ "",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(prefix),
-                        /* namespaceMap= */ namespaceMap,
+                        namespaceCache,
                         new SchemaCache(),
                         mLocalStorageIcingOptionsConfig);
         assertThat(emptySchemaConverter.hasNothingToSearch()).isTrue();
@@ -1692,7 +1814,7 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(prefix),
-                        /* namespaceMap= */ ImmutableMap.of(),
+                        new NamespaceCache(ImmutableMap.of()),
                         new SchemaCache(schemaMap),
                         mLocalStorageIcingOptionsConfig);
         assertThat(emptyNamespaceConverter.hasNothingToSearch()).isTrue();
@@ -1702,7 +1824,7 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(prefix),
-                        namespaceMap,
+                        namespaceCache,
                         new SchemaCache(schemaMap),
                         mLocalStorageIcingOptionsConfig);
         assertThat(nonEmptyConverter.hasNothingToSearch()).isFalse();
@@ -1719,7 +1841,8 @@ public class SearchSpecToProtoConverterTest {
 
     @Test
     public void testRemoveInaccessibleSchemaFilterWithEmptyNestedFilter() throws Exception {
-        VisibilityStore visibilityStore = new VisibilityStore(mAppSearchImpl);
+        VisibilityStore visibilityStore =
+                VisibilityStore.createDocumentVisibilityStore(mAppSearchImpl);
 
         final String prefix = PrefixUtil.createPrefix("package", "database");
         SchemaTypeConfigProto schemaTypeConfigProto =
@@ -1737,8 +1860,9 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "",
                         new SearchSpec.Builder().setJoinSpec(joinSpec).build(),
                         /* prefixes= */ ImmutableSet.of(prefix),
-                        /* namespaceMap= */ ImmutableMap.of(
-                                prefix, ImmutableSet.of("package$database/namespace1")),
+                        new NamespaceCache(
+                                ImmutableMap.of(
+                                        prefix, ImmutableSet.of("package$database/namespace1"))),
                         new SchemaCache(
                                 /* schemaMap= */ ImmutableMap.of(
                                         prefix,
@@ -1764,7 +1888,7 @@ public class SearchSpecToProtoConverterTest {
     }
 
     @Test
-    public void testConvertPropertyWeights() {
+    public void testConvertPropertyWeights() throws Exception {
         String prefix1 = PrefixUtil.createPrefix("package", "database1");
         String prefix2 = PrefixUtil.createPrefix("package", "database2");
         String schemaTypeA = "typeA";
@@ -1778,10 +1902,11 @@ public class SearchSpecToProtoConverterTest {
                         .setPropertyWeights(schemaTypeB, ImmutableMap.of("nested.property", 0.5))
                         .build();
 
-        Map<String, Set<String>> namespaceMap =
-                ImmutableMap.of(
-                        prefix1, ImmutableSet.of(prefix1 + "namespace1"),
-                        prefix2, ImmutableSet.of(prefix2 + "namespace1"));
+        NamespaceCache namespaceCache =
+                new NamespaceCache(
+                        ImmutableMap.of(
+                                prefix1, ImmutableSet.of(prefix1 + "namespace1"),
+                                prefix2, ImmutableSet.of(prefix2 + "namespace1")));
         Map<String, Map<String, SchemaTypeConfigProto>> schemaTypeMap =
                 ImmutableMap.of(
                         prefix1,
@@ -1799,7 +1924,7 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(prefix1, prefix2),
-                        namespaceMap,
+                        namespaceCache,
                         new SchemaCache(schemaTypeMap),
                         mLocalStorageIcingOptionsConfig);
 
@@ -1839,7 +1964,7 @@ public class SearchSpecToProtoConverterTest {
     }
 
     @Test
-    public void testConvertPropertyWeights_whenNoWeightsSet() {
+    public void testConvertPropertyWeights_whenNoWeightsSet() throws Exception {
         SearchSpec searchSpec = new SearchSpec.Builder().build();
         String prefix1 = PrefixUtil.createPrefix("package", "database1");
         SchemaTypeConfigProto schemaTypeConfigProto =
@@ -1850,8 +1975,8 @@ public class SearchSpecToProtoConverterTest {
                         /* queryExpression= */ "",
                         searchSpec,
                         /* prefixes= */ ImmutableSet.of(prefix1),
-                        /* namespaceMap= */ ImmutableMap.of(
-                                prefix1, ImmutableSet.of(prefix1 + "namespace1")),
+                        new NamespaceCache(
+                                ImmutableMap.of(prefix1, ImmutableSet.of(prefix1 + "namespace1"))),
                         new SchemaCache(
                                 /* schemaMap= */ ImmutableMap.of(
                                         prefix1,
@@ -1862,4 +1987,221 @@ public class SearchSpecToProtoConverterTest {
 
         assertThat(convertedScoringSpecProto.getTypePropertyWeightsList()).isEmpty();
     }
+
+    @Test
+    public void testConvertDocumentIdFilters() throws Exception {
+        String prefix1 = PrefixUtil.createPrefix("package1", "database1");
+        String prefix2 = PrefixUtil.createPrefix("package2", "database2");
+        NamespaceCache namespaceCache =
+                new NamespaceCache(
+                        ImmutableMap.of(
+                                prefix1,
+                                        ImmutableSet.of(
+                                                prefix1 + "namespace_common",
+                                                prefix1 + "namespace1"),
+                                prefix2,
+                                        ImmutableSet.of(
+                                                prefix2 + "namespace_common",
+                                                prefix2 + "namespace2")));
+
+        SearchSpec searchSpec =
+                new SearchSpec.Builder()
+                        .addFilterDocumentIds(ImmutableList.of("uri1", "uri2"))
+                        .addFilterDocumentIds("uri3")
+                        .build();
+        SearchSpecToProtoConverter converter =
+                new SearchSpecToProtoConverter(
+                        /* queryExpression= */ "query",
+                        searchSpec,
+                        /* prefixes= */ ImmutableSet.of(prefix1, prefix2),
+                        namespaceCache,
+                        new SchemaCache(),
+                        mLocalStorageIcingOptionsConfig);
+        SearchSpecProto proto = converter.toSearchSpecProto();
+        assertThat(proto.getDocumentUriFiltersList())
+                .containsExactly(
+                        NamespaceDocumentUriGroup.newBuilder()
+                                .setNamespace("package1$database1/namespace_common")
+                                .addDocumentUris("uri1")
+                                .addDocumentUris("uri2")
+                                .addDocumentUris("uri3")
+                                .build(),
+                        NamespaceDocumentUriGroup.newBuilder()
+                                .setNamespace("package1$database1/namespace1")
+                                .addDocumentUris("uri1")
+                                .addDocumentUris("uri2")
+                                .addDocumentUris("uri3")
+                                .build(),
+                        NamespaceDocumentUriGroup.newBuilder()
+                                .setNamespace("package2$database2/namespace_common")
+                                .addDocumentUris("uri1")
+                                .addDocumentUris("uri2")
+                                .addDocumentUris("uri3")
+                                .build(),
+                        NamespaceDocumentUriGroup.newBuilder()
+                                .setNamespace("package2$database2/namespace2")
+                                .addDocumentUris("uri1")
+                                .addDocumentUris("uri2")
+                                .addDocumentUris("uri3")
+                                .build());
+    }
+
+    @Test
+    public void testConvertDocumentIdFilters_withNamespaceFilters() throws Exception {
+        String prefix1 = PrefixUtil.createPrefix("package1", "database1");
+        String prefix2 = PrefixUtil.createPrefix("package2", "database2");
+        NamespaceCache namespaceCache =
+                new NamespaceCache(
+                        ImmutableMap.of(
+                                prefix1,
+                                        ImmutableSet.of(
+                                                prefix1 + "namespace_common",
+                                                prefix1 + "namespace1"),
+                                prefix2,
+                                        ImmutableSet.of(
+                                                prefix2 + "namespace_common",
+                                                prefix2 + "namespace2")));
+
+        SearchSpec searchSpec =
+                new SearchSpec.Builder()
+                        .addFilterDocumentIds(ImmutableList.of("uri1", "uri2"))
+                        .addFilterDocumentIds("uri3")
+                        .addFilterNamespaces("namespace1")
+                        .build();
+        SearchSpecToProtoConverter converter =
+                new SearchSpecToProtoConverter(
+                        /* queryExpression= */ "query",
+                        searchSpec,
+                        /* prefixes= */ ImmutableSet.of(prefix1, prefix2),
+                        namespaceCache,
+                        new SchemaCache(),
+                        mLocalStorageIcingOptionsConfig);
+        SearchSpecProto proto = converter.toSearchSpecProto();
+        assertThat(proto.getDocumentUriFiltersList())
+                .containsExactly(
+                        NamespaceDocumentUriGroup.newBuilder()
+                                .setNamespace("package1$database1/namespace1")
+                                .addDocumentUris("uri1")
+                                .addDocumentUris("uri2")
+                                .addDocumentUris("uri3")
+                                .build());
+    }
+
+    @Test
+    public void testConvertDocumentIdFilters_withPackageFilters() throws Exception {
+        String prefix1 = PrefixUtil.createPrefix("package1", "database1");
+        String prefix2 = PrefixUtil.createPrefix("package2", "database2");
+        NamespaceCache namespaceCache =
+                new NamespaceCache(
+                        ImmutableMap.of(
+                                prefix1,
+                                        ImmutableSet.of(
+                                                prefix1 + "namespace_common",
+                                                prefix1 + "namespace1"),
+                                prefix2,
+                                        ImmutableSet.of(
+                                                prefix2 + "namespace_common",
+                                                prefix2 + "namespace2")));
+
+        SearchSpec searchSpec =
+                new SearchSpec.Builder()
+                        .addFilterDocumentIds(ImmutableList.of("uri1", "uri2"))
+                        .addFilterDocumentIds("uri3")
+                        .addFilterPackageNames("package1")
+                        .build();
+        SearchSpecToProtoConverter converter =
+                new SearchSpecToProtoConverter(
+                        /* queryExpression= */ "query",
+                        searchSpec,
+                        /* prefixes= */ ImmutableSet.of(prefix1, prefix2),
+                        namespaceCache,
+                        new SchemaCache(),
+                        mLocalStorageIcingOptionsConfig);
+        SearchSpecProto proto = converter.toSearchSpecProto();
+        assertThat(proto.getDocumentUriFiltersList())
+                .containsExactly(
+                        NamespaceDocumentUriGroup.newBuilder()
+                                .setNamespace("package1$database1/namespace_common")
+                                .addDocumentUris("uri1")
+                                .addDocumentUris("uri2")
+                                .addDocumentUris("uri3")
+                                .build(),
+                        NamespaceDocumentUriGroup.newBuilder()
+                                .setNamespace("package1$database1/namespace1")
+                                .addDocumentUris("uri1")
+                                .addDocumentUris("uri2")
+                                .addDocumentUris("uri3")
+                                .build());
+    }
+
+    @Test
+    public void testConvertDocumentIdFilters_withPackageAndNamespaceFilters() throws Exception {
+        String prefix1 = PrefixUtil.createPrefix("package1", "database1");
+        String prefix2 = PrefixUtil.createPrefix("package2", "database2");
+        NamespaceCache namespaceCache =
+                new NamespaceCache(
+                        ImmutableMap.of(
+                                prefix1,
+                                        ImmutableSet.of(
+                                                prefix1 + "namespace_common",
+                                                prefix1 + "namespace1"),
+                                prefix2,
+                                        ImmutableSet.of(
+                                                prefix2 + "namespace_common",
+                                                prefix2 + "namespace2")));
+
+        SearchSpec searchSpec =
+                new SearchSpec.Builder()
+                        .addFilterDocumentIds(ImmutableList.of("uri1", "uri2"))
+                        .addFilterDocumentIds("uri3")
+                        .addFilterPackageNames("package1")
+                        .addFilterNamespaces("namespace_common")
+                        .build();
+        SearchSpecToProtoConverter converter =
+                new SearchSpecToProtoConverter(
+                        /* queryExpression= */ "query",
+                        searchSpec,
+                        /* prefixes= */ ImmutableSet.of(prefix1, prefix2),
+                        namespaceCache,
+                        new SchemaCache(),
+                        mLocalStorageIcingOptionsConfig);
+        SearchSpecProto proto = converter.toSearchSpecProto();
+        assertThat(proto.getDocumentUriFiltersList())
+                .containsExactly(
+                        NamespaceDocumentUriGroup.newBuilder()
+                                .setNamespace("package1$database1/namespace_common")
+                                .addDocumentUris("uri1")
+                                .addDocumentUris("uri2")
+                                .addDocumentUris("uri3")
+                                .build());
+    }
+
+    @Test
+    public void testConvertDocumentIdFilters_empty() throws Exception {
+        String prefix1 = PrefixUtil.createPrefix("package1", "database1");
+        String prefix2 = PrefixUtil.createPrefix("package2", "database2");
+        NamespaceCache namespaceCache =
+                new NamespaceCache(
+                        ImmutableMap.of(
+                                prefix1,
+                                        ImmutableSet.of(
+                                                prefix1 + "namespace_common",
+                                                prefix1 + "namespace1"),
+                                prefix2,
+                                        ImmutableSet.of(
+                                                prefix2 + "namespace_common",
+                                                prefix2 + "namespace2")));
+
+        SearchSpec searchSpec = new SearchSpec.Builder().build();
+        SearchSpecToProtoConverter converter =
+                new SearchSpecToProtoConverter(
+                        /* queryExpression= */ "query",
+                        searchSpec,
+                        /* prefixes= */ ImmutableSet.of(prefix1, prefix2),
+                        namespaceCache,
+                        new SchemaCache(),
+                        mLocalStorageIcingOptionsConfig);
+        SearchSpecProto proto = converter.toSearchSpecProto();
+        assertThat(proto.getDocumentUriFiltersList()).isEmpty();
+    }
 }
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SearchSuggestionSpecToProtoConverterTest.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SearchSuggestionSpecToProtoConverterTest.java
index f16a89ce..817a9de9 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SearchSuggestionSpecToProtoConverterTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/converter/SearchSuggestionSpecToProtoConverterTest.java
@@ -20,6 +20,7 @@ import static com.google.common.truth.Truth.assertThat;
 
 import android.app.appsearch.SearchSuggestionSpec;
 
+import com.android.server.appsearch.external.localstorage.NamespaceCache;
 import com.android.server.appsearch.external.localstorage.SchemaCache;
 import com.android.server.appsearch.external.localstorage.util.PrefixUtil;
 import com.android.server.appsearch.icing.proto.NamespaceDocumentUriGroup;
@@ -53,9 +54,11 @@ public class SearchSuggestionSpecToProtoConverterTest {
                         /* queryExpression= */ "prefix",
                         searchSuggestionSpec,
                         /* prefixes= */ ImmutableSet.of(prefix1),
-                        /* namespaceMap= */ ImmutableMap.of(
-                                prefix1,
-                                ImmutableSet.of(prefix1 + "namespace1", prefix1 + "namespace2")),
+                        new NamespaceCache(
+                                ImmutableMap.of(
+                                        prefix1,
+                                        ImmutableSet.of(
+                                                prefix1 + "namespace1", prefix1 + "namespace2"))),
                         new SchemaCache(
                                 /* schemaMap= */ ImmutableMap.of(
                                         prefix1,
@@ -94,7 +97,7 @@ public class SearchSuggestionSpecToProtoConverterTest {
                         /* queryExpression= */ "prefix",
                         searchSuggestionSpec,
                         /* prefixes= */ ImmutableSet.of(prefix1),
-                        /* namespaceMap= */ ImmutableMap.of(),
+                        new NamespaceCache(ImmutableMap.of()),
                         new SchemaCache(
                                 /* schemaMap= */ ImmutableMap.of(
                                         prefix1,
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationFromV2Test.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationFromV2Test.java
index 73505ea9..e2a1be43 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationFromV2Test.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationFromV2Test.java
@@ -30,6 +30,7 @@ import android.app.appsearch.SetSchemaRequest;
 import android.app.appsearch.VisibilityPermissionConfig;
 import android.app.appsearch.exceptions.AppSearchException;
 
+import com.android.server.appsearch.external.localstorage.AppSearchConfig;
 import com.android.server.appsearch.external.localstorage.AppSearchConfigImpl;
 import com.android.server.appsearch.external.localstorage.AppSearchImpl;
 import com.android.server.appsearch.external.localstorage.LocalStorageIcingOptionsConfig;
@@ -59,6 +60,9 @@ public class VisibilityStoreMigrationFromV2Test {
 
     @Rule public TemporaryFolder mTemporaryFolder = new TemporaryFolder();
     private File mFile;
+    private AppSearchConfig mConfig =
+            new AppSearchConfigImpl(
+                    new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig());
 
     @Before
     public void setUp() throws Exception {
@@ -87,17 +91,17 @@ public class VisibilityStoreMigrationFromV2Test {
         AppSearchImpl appSearchImplInV2 =
                 AppSearchImpl.create(
                         mFile,
-                        new AppSearchConfigImpl(
-                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        mConfig,
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         // Erase overlay schemas since it doesn't exist in released V2 schema.
         InternalSetSchemaResponse internalSetAndroidVSchemaResponse =
                 appSearchImplInV2.setSchema(
                         VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                        VisibilityStore.ANDROID_V_OVERLAY_DATABASE_NAME,
+                        VisibilityStore.DOCUMENT_ANDROID_V_OVERLAY_DATABASE_NAME,
                         // no overlay schema
                         ImmutableList.of(),
                         /* prefixedVisibilityBundles= */ Collections.emptyList(),
@@ -109,7 +113,7 @@ public class VisibilityStoreMigrationFromV2Test {
         GetSchemaResponse getSchemaResponse =
                 appSearchImplInV2.getSchema(
                         VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                        VisibilityStore.VISIBILITY_DATABASE_NAME,
+                        VisibilityStore.DOCUMENT_VISIBILITY_DATABASE_NAME,
                         new CallerAccess(
                                 /* callingPackageName= */ VisibilityStore.VISIBILITY_PACKAGE_NAME));
         assertThat(getSchemaResponse.getSchemas())
@@ -119,7 +123,7 @@ public class VisibilityStoreMigrationFromV2Test {
         GetSchemaResponse getAndroidVOverlaySchemaResponse =
                 appSearchImplInV2.getSchema(
                         VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                        VisibilityStore.ANDROID_V_OVERLAY_DATABASE_NAME,
+                        VisibilityStore.DOCUMENT_ANDROID_V_OVERLAY_DATABASE_NAME,
                         new CallerAccess(
                                 /* callingPackageName= */ VisibilityStore.VISIBILITY_PACKAGE_NAME));
         assertThat(getAndroidVOverlaySchemaResponse.getSchemas()).isEmpty();
@@ -158,7 +162,7 @@ public class VisibilityStoreMigrationFromV2Test {
         // Put deprecated visibility documents in version 2 to AppSearchImpl
         appSearchImplInV2.putDocument(
                 VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                VisibilityStore.VISIBILITY_DATABASE_NAME,
+                VisibilityStore.DOCUMENT_VISIBILITY_DATABASE_NAME,
                 visibilityDocumentV2,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
@@ -168,17 +172,17 @@ public class VisibilityStoreMigrationFromV2Test {
         AppSearchImpl appSearchImpl =
                 AppSearchImpl.create(
                         mFile,
-                        new AppSearchConfigImpl(
-                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        mConfig,
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         InternalVisibilityConfig actualConfig =
                 VisibilityToDocumentConverter.createInternalVisibilityConfig(
                         appSearchImpl.getDocument(
                                 VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                                VisibilityStore.VISIBILITY_DATABASE_NAME,
+                                VisibilityStore.DOCUMENT_VISIBILITY_DATABASE_NAME,
                                 VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
                                 /* id= */ prefix + "Schema",
                                 /* typePropertyPaths= */ Collections.emptyMap()),
@@ -199,7 +203,7 @@ public class VisibilityStoreMigrationFromV2Test {
         getSchemaResponse =
                 appSearchImpl.getSchema(
                         VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                        VisibilityStore.VISIBILITY_DATABASE_NAME,
+                        VisibilityStore.DOCUMENT_VISIBILITY_DATABASE_NAME,
                         new CallerAccess(
                                 /* callingPackageName= */ VisibilityStore.VISIBILITY_PACKAGE_NAME));
         assertThat(getSchemaResponse.getSchemas())
@@ -209,7 +213,7 @@ public class VisibilityStoreMigrationFromV2Test {
         getAndroidVOverlaySchemaResponse =
                 appSearchImpl.getSchema(
                         VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                        VisibilityStore.ANDROID_V_OVERLAY_DATABASE_NAME,
+                        VisibilityStore.DOCUMENT_ANDROID_V_OVERLAY_DATABASE_NAME,
                         new CallerAccess(
                                 /* callingPackageName= */ VisibilityStore.VISIBILITY_PACKAGE_NAME));
         assertThat(getAndroidVOverlaySchemaResponse.getSchemas())
@@ -222,7 +226,7 @@ public class VisibilityStoreMigrationFromV2Test {
                         () ->
                                 appSearchImpl.getDocument(
                                         VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                                        VisibilityStore.ANDROID_V_OVERLAY_DATABASE_NAME,
+                                        VisibilityStore.DOCUMENT_ANDROID_V_OVERLAY_DATABASE_NAME,
                                         VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE,
                                         /* id= */ prefix + "Schema",
                                         /* typePropertyPaths= */ Collections.emptyMap()));
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV0Test.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV0Test.java
index c8e87422..c964983b 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV0Test.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV0Test.java
@@ -32,6 +32,7 @@ import android.app.appsearch.InternalSetSchemaResponse;
 import android.app.appsearch.InternalVisibilityConfig;
 import android.app.appsearch.PackageIdentifier;
 
+import com.android.server.appsearch.external.localstorage.AppSearchConfig;
 import com.android.server.appsearch.external.localstorage.AppSearchConfigImpl;
 import com.android.server.appsearch.external.localstorage.AppSearchImpl;
 import com.android.server.appsearch.external.localstorage.LocalStorageIcingOptionsConfig;
@@ -58,6 +59,9 @@ public class VisibilityStoreMigrationHelperFromV0Test {
 
     @Rule public TemporaryFolder mTemporaryFolder = new TemporaryFolder();
     private File mFile;
+    private AppSearchConfig mConfig =
+            new AppSearchConfigImpl(
+                    new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig());
 
     @Before
     public void setUp() throws Exception {
@@ -135,7 +139,7 @@ public class VisibilityStoreMigrationHelperFromV0Test {
         // Put deprecated visibility documents in version 0 to AppSearchImpl
         appSearchImplInV0.putDocument(
                 VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                VisibilityStore.VISIBILITY_DATABASE_NAME,
+                VisibilityStore.DOCUMENT_VISIBILITY_DATABASE_NAME,
                 deprecatedVisibilityDocument,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
@@ -145,23 +149,23 @@ public class VisibilityStoreMigrationHelperFromV0Test {
         AppSearchImpl appSearchImpl =
                 AppSearchImpl.create(
                         mFile,
-                        new AppSearchConfigImpl(
-                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        mConfig,
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         GenericDocument actualDocument1 =
                 appSearchImpl.getDocument(
                         VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                        VisibilityStore.VISIBILITY_DATABASE_NAME,
+                        VisibilityStore.DOCUMENT_VISIBILITY_DATABASE_NAME,
                         VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
                         /* id= */ prefix + "Schema1",
                         /* typePropertyPaths= */ Collections.emptyMap());
         GenericDocument actualDocument2 =
                 appSearchImpl.getDocument(
                         VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                        VisibilityStore.VISIBILITY_DATABASE_NAME,
+                        VisibilityStore.DOCUMENT_VISIBILITY_DATABASE_NAME,
                         VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
                         /* id= */ prefix + "Schema2",
                         /* typePropertyPaths= */ Collections.emptyMap());
@@ -239,15 +243,15 @@ public class VisibilityStoreMigrationHelperFromV0Test {
         AppSearchImpl appSearchImpl =
                 AppSearchImpl.create(
                         mFile,
-                        new AppSearchConfigImpl(
-                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        mConfig,
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
         InternalSetSchemaResponse internalSetSchemaResponse =
                 appSearchImpl.setSchema(
                         VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                        VisibilityStore.VISIBILITY_DATABASE_NAME,
+                        VisibilityStore.DOCUMENT_VISIBILITY_DATABASE_NAME,
                         ImmutableList.of(visibilityDocumentSchemaV0, visibilityToPackagesSchemaV0),
                         /* prefixedVisibilityBundles= */ Collections.emptyList(),
                         /* forceOverride= */ true, // force push the old version into disk
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV1Test.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV1Test.java
index 64c5e58e..03f7f213 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV1Test.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreMigrationHelperFromV1Test.java
@@ -27,6 +27,7 @@ import android.app.appsearch.InternalVisibilityConfig;
 import android.app.appsearch.PackageIdentifier;
 import android.app.appsearch.SetSchemaRequest;
 
+import com.android.server.appsearch.external.localstorage.AppSearchConfig;
 import com.android.server.appsearch.external.localstorage.AppSearchConfigImpl;
 import com.android.server.appsearch.external.localstorage.AppSearchImpl;
 import com.android.server.appsearch.external.localstorage.LocalStorageIcingOptionsConfig;
@@ -54,6 +55,9 @@ public class VisibilityStoreMigrationHelperFromV1Test {
 
     @Rule public TemporaryFolder mTemporaryFolder = new TemporaryFolder();
     private File mFile;
+    private AppSearchConfig mConfig =
+            new AppSearchConfigImpl(
+                    new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig());
 
     @Before
     public void setUp() throws Exception {
@@ -79,15 +83,15 @@ public class VisibilityStoreMigrationHelperFromV1Test {
         AppSearchImpl appSearchImplInV1 =
                 AppSearchImpl.create(
                         mFile,
-                        new AppSearchConfigImpl(
-                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        mConfig,
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
         InternalSetSchemaResponse internalSetSchemaResponse =
                 appSearchImplInV1.setSchema(
                         VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                        VisibilityStore.VISIBILITY_DATABASE_NAME,
+                        VisibilityStore.DOCUMENT_VISIBILITY_DATABASE_NAME,
                         ImmutableList.of(VisibilityDocumentV1.SCHEMA),
                         /* prefixedVisibilityBundles= */ Collections.emptyList(),
                         /* forceOverride= */ true, // force push the old version into disk
@@ -124,7 +128,7 @@ public class VisibilityStoreMigrationHelperFromV1Test {
         // Put deprecated visibility documents in version 0 to AppSearchImpl
         appSearchImplInV1.putDocument(
                 VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                VisibilityStore.VISIBILITY_DATABASE_NAME,
+                VisibilityStore.DOCUMENT_VISIBILITY_DATABASE_NAME,
                 visibilityDocumentV1,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
@@ -134,17 +138,17 @@ public class VisibilityStoreMigrationHelperFromV1Test {
         AppSearchImpl appSearchImpl =
                 AppSearchImpl.create(
                         mFile,
-                        new AppSearchConfigImpl(
-                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        mConfig,
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
 
         InternalVisibilityConfig actualConfig =
                 VisibilityToDocumentConverter.createInternalVisibilityConfig(
                         appSearchImpl.getDocument(
                                 VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                                VisibilityStore.VISIBILITY_DATABASE_NAME,
+                                VisibilityStore.DOCUMENT_VISIBILITY_DATABASE_NAME,
                                 VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
                                 /* id= */ prefix + "Schema",
                                 /* typePropertyPaths= */ Collections.emptyMap()),
diff --git a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreTest.java b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreTest.java
index 311e4e4f..aad7a542 100644
--- a/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/external/localstorage/visibilitystore/VisibilityStoreTest.java
@@ -30,6 +30,7 @@ import android.app.appsearch.SchemaVisibilityConfig;
 import android.app.appsearch.VisibilityPermissionConfig;
 import android.app.appsearch.exceptions.AppSearchException;
 
+import com.android.server.appsearch.external.localstorage.AppSearchConfig;
 import com.android.server.appsearch.external.localstorage.AppSearchConfigImpl;
 import com.android.server.appsearch.external.localstorage.AppSearchImpl;
 import com.android.server.appsearch.external.localstorage.LocalStorageIcingOptionsConfig;
@@ -63,15 +64,18 @@ public class VisibilityStoreTest {
     @Before
     public void setUp() throws Exception {
         File appSearchDir = mTemporaryFolder.newFolder();
+        AppSearchConfig config =
+                new AppSearchConfigImpl(
+                        new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig());
         mAppSearchImpl =
                 AppSearchImpl.create(
                         appSearchDir,
-                        new AppSearchConfigImpl(
-                                new UnlimitedLimitConfig(), new LocalStorageIcingOptionsConfig()),
+                        config,
                         /* initStatsBuilder= */ null,
                         /* visibilityChecker= */ null,
+                        /* revocableFileDescriptorStore= */ null,
                         ALWAYS_OPTIMIZE);
-        mVisibilityStore = new VisibilityStore(mAppSearchImpl);
+        mVisibilityStore = VisibilityStore.createDocumentVisibilityStore(mAppSearchImpl);
     }
 
     @After
@@ -95,9 +99,9 @@ public class VisibilityStoreTest {
      */
     @Test
     public void testValidDatabaseName() {
-        assertThat(VisibilityStore.VISIBILITY_DATABASE_NAME)
+        assertThat(VisibilityStore.DOCUMENT_VISIBILITY_DATABASE_NAME)
                 .doesNotContain(String.valueOf(PrefixUtil.PACKAGE_DELIMITER));
-        assertThat(VisibilityStore.VISIBILITY_DATABASE_NAME)
+        assertThat(VisibilityStore.DOCUMENT_VISIBILITY_DATABASE_NAME)
                 .doesNotContain(String.valueOf(PrefixUtil.DATABASE_DELIMITER));
     }
 
@@ -106,7 +110,7 @@ public class VisibilityStoreTest {
         GetSchemaResponse getSchemaResponse =
                 mAppSearchImpl.getSchema(
                         VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                        VisibilityStore.VISIBILITY_DATABASE_NAME,
+                        VisibilityStore.DOCUMENT_VISIBILITY_DATABASE_NAME,
                         new CallerAccess(VisibilityStore.VISIBILITY_PACKAGE_NAME));
 
         assertThat(getSchemaResponse.getSchemas())
@@ -117,7 +121,7 @@ public class VisibilityStoreTest {
         GetSchemaResponse getAndroidVOverlaySchemaResponse =
                 mAppSearchImpl.getSchema(
                         VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                        VisibilityStore.ANDROID_V_OVERLAY_DATABASE_NAME,
+                        VisibilityStore.DOCUMENT_ANDROID_V_OVERLAY_DATABASE_NAME,
                         new CallerAccess(VisibilityStore.VISIBILITY_PACKAGE_NAME));
 
         assertThat(getAndroidVOverlaySchemaResponse.getSchemas())
@@ -139,7 +143,7 @@ public class VisibilityStoreTest {
         GenericDocument actualDocument =
                 mAppSearchImpl.getDocument(
                         VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                        VisibilityStore.VISIBILITY_DATABASE_NAME,
+                        VisibilityStore.DOCUMENT_VISIBILITY_DATABASE_NAME,
                         VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
                         /* id= */ prefix + "Email",
                         /* typePropertyPaths= */ Collections.emptyMap());
@@ -167,7 +171,7 @@ public class VisibilityStoreTest {
                 VisibilityToDocumentConverter.createInternalVisibilityConfig(
                         mAppSearchImpl.getDocument(
                                 VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                                VisibilityStore.VISIBILITY_DATABASE_NAME,
+                                VisibilityStore.DOCUMENT_VISIBILITY_DATABASE_NAME,
                                 VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
                                 /* id= */ "Email",
                                 /* typePropertyPaths= */ Collections.emptyMap()),
@@ -183,7 +187,7 @@ public class VisibilityStoreTest {
                         () ->
                                 mAppSearchImpl.getDocument(
                                         VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                                        VisibilityStore.VISIBILITY_DATABASE_NAME,
+                                        VisibilityStore.DOCUMENT_VISIBILITY_DATABASE_NAME,
                                         VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_NAMESPACE,
                                         /* id= */ "Email",
                                         /* typePropertyPaths= */ Collections.emptyMap()));
@@ -203,7 +207,7 @@ public class VisibilityStoreTest {
         InternalSetSchemaResponse internalSetSchemaResponse =
                 mAppSearchImpl.setSchema(
                         VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                        VisibilityStore.VISIBILITY_DATABASE_NAME,
+                        VisibilityStore.DOCUMENT_VISIBILITY_DATABASE_NAME,
                         Collections.singletonList(brokenSchema),
                         /* visibilityConfigs= */ Collections.emptyList(),
                         /* forceOverride= */ true,
@@ -211,7 +215,7 @@ public class VisibilityStoreTest {
                         /* setSchemaStatsBuilder= */ null);
         assertThat(internalSetSchemaResponse.isSuccess()).isTrue();
         // Create VisibilityStore should recover the broken schema
-        mVisibilityStore = new VisibilityStore(mAppSearchImpl);
+        mVisibilityStore = VisibilityStore.createDocumentVisibilityStore(mAppSearchImpl);
 
         // We should be able to set and get Visibility settings.
         String prefix = PrefixUtil.createPrefix("packageName", "databaseName");
@@ -246,7 +250,7 @@ public class VisibilityStoreTest {
         GenericDocument visibleToConfigOverlay =
                 mAppSearchImpl.getDocument(
                         VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                        VisibilityStore.ANDROID_V_OVERLAY_DATABASE_NAME,
+                        VisibilityStore.DOCUMENT_ANDROID_V_OVERLAY_DATABASE_NAME,
                         VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE,
                         /* id= */ prefix + "Email",
                         /* typePropertyPaths= */ Collections.emptyMap());
@@ -266,7 +270,7 @@ public class VisibilityStoreTest {
                         () ->
                                 mAppSearchImpl.getDocument(
                                         VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                                        VisibilityStore.ANDROID_V_OVERLAY_DATABASE_NAME,
+                                        VisibilityStore.DOCUMENT_ANDROID_V_OVERLAY_DATABASE_NAME,
                                         VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE,
                                         /* id= */ prefix + "Email",
                                         /* typePropertyPaths= */ Collections.emptyMap()));
@@ -293,7 +297,7 @@ public class VisibilityStoreTest {
                         .build();
         mAppSearchImpl.putDocument(
                 VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                VisibilityStore.ANDROID_V_OVERLAY_DATABASE_NAME,
+                VisibilityStore.DOCUMENT_ANDROID_V_OVERLAY_DATABASE_NAME,
                 fakeAndroidVOverlay,
                 /* sendChangeNotifications= */ false,
                 /* logger= */ null);
@@ -310,7 +314,7 @@ public class VisibilityStoreTest {
         GenericDocument actualAndroidVOverlay =
                 mAppSearchImpl.getDocument(
                         VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                        VisibilityStore.ANDROID_V_OVERLAY_DATABASE_NAME,
+                        VisibilityStore.DOCUMENT_ANDROID_V_OVERLAY_DATABASE_NAME,
                         VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE,
                         /* id= */ "Email",
                         /* typePropertyPaths= */ Collections.emptyMap());
@@ -337,7 +341,7 @@ public class VisibilityStoreTest {
         // verify the overlay document is created.
         mAppSearchImpl.getDocument(
                 VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                VisibilityStore.ANDROID_V_OVERLAY_DATABASE_NAME,
+                VisibilityStore.DOCUMENT_ANDROID_V_OVERLAY_DATABASE_NAME,
                 VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE,
                 /* id= */ "Email",
                 /* typePropertyPaths= */ Collections.emptyMap());
@@ -354,7 +358,7 @@ public class VisibilityStoreTest {
                         () ->
                                 mAppSearchImpl.getDocument(
                                         VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                                        VisibilityStore.ANDROID_V_OVERLAY_DATABASE_NAME,
+                                        VisibilityStore.DOCUMENT_ANDROID_V_OVERLAY_DATABASE_NAME,
                                         VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE,
                                         /* id= */ "Email",
                                         /* typePropertyPaths= */ Collections.emptyMap()));
@@ -377,7 +381,7 @@ public class VisibilityStoreTest {
         // verify the overlay document is created.
         mAppSearchImpl.getDocument(
                 VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                VisibilityStore.ANDROID_V_OVERLAY_DATABASE_NAME,
+                VisibilityStore.DOCUMENT_ANDROID_V_OVERLAY_DATABASE_NAME,
                 VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE,
                 /* id= */ "Email",
                 /* typePropertyPaths= */ Collections.emptyMap());
@@ -394,7 +398,7 @@ public class VisibilityStoreTest {
                         () ->
                                 mAppSearchImpl.getDocument(
                                         VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                                        VisibilityStore.ANDROID_V_OVERLAY_DATABASE_NAME,
+                                        VisibilityStore.DOCUMENT_ANDROID_V_OVERLAY_DATABASE_NAME,
                                         VisibilityToDocumentConverter.ANDROID_V_OVERLAY_NAMESPACE,
                                         /* id= */ "Email",
                                         /* typePropertyPaths= */ Collections.emptyMap()));
@@ -406,7 +410,7 @@ public class VisibilityStoreTest {
         // Set deprecated public acl schema to main visibility database.
         mAppSearchImpl.setSchema(
                 VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                VisibilityStore.VISIBILITY_DATABASE_NAME,
+                VisibilityStore.DOCUMENT_VISIBILITY_DATABASE_NAME,
                 ImmutableList.of(
                         VisibilityToDocumentConverter.VISIBILITY_DOCUMENT_SCHEMA,
                         VisibilityPermissionConfig.SCHEMA,
@@ -418,12 +422,12 @@ public class VisibilityStoreTest {
 
         // Create VisibilityStore with success and force remove deprecated public acl schema from
         // the main visibility database.
-        mVisibilityStore = new VisibilityStore(mAppSearchImpl);
+        mVisibilityStore = VisibilityStore.createDocumentVisibilityStore(mAppSearchImpl);
 
         GetSchemaResponse getSchemaResponse =
                 mAppSearchImpl.getSchema(
                         VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                        VisibilityStore.VISIBILITY_DATABASE_NAME,
+                        VisibilityStore.DOCUMENT_VISIBILITY_DATABASE_NAME,
                         new CallerAccess(VisibilityStore.VISIBILITY_PACKAGE_NAME));
 
         assertThat(getSchemaResponse.getSchemas())
@@ -496,7 +500,7 @@ public class VisibilityStoreTest {
                         .build();
         mAppSearchImpl.setSchema(
                 VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                VisibilityStore.ANDROID_V_OVERLAY_DATABASE_NAME,
+                VisibilityStore.DOCUMENT_ANDROID_V_OVERLAY_DATABASE_NAME,
                 ImmutableList.of(
                         deprecatedOverlaySchema,
                         deprecatedVisibleToConfigSchema,
@@ -508,12 +512,12 @@ public class VisibilityStoreTest {
                 /* setSchemaStatsBuilder= */ null);
 
         // Create VisibilityStore with success and force remove override overlay schema.
-        mVisibilityStore = new VisibilityStore(mAppSearchImpl);
+        mVisibilityStore = VisibilityStore.createDocumentVisibilityStore(mAppSearchImpl);
 
         GetSchemaResponse getSchemaResponse =
                 mAppSearchImpl.getSchema(
                         VisibilityStore.VISIBILITY_PACKAGE_NAME,
-                        VisibilityStore.ANDROID_V_OVERLAY_DATABASE_NAME,
+                        VisibilityStore.DOCUMENT_ANDROID_V_OVERLAY_DATABASE_NAME,
                         new CallerAccess(VisibilityStore.VISIBILITY_PACKAGE_NAME));
 
         assertThat(getSchemaResponse.getVersion())
diff --git a/testing/servicestests/src/com/android/server/appsearch/stats/PlatformLoggerTest.java b/testing/servicestests/src/com/android/server/appsearch/stats/PlatformLoggerTest.java
index 4597045b..c4146d8c 100644
--- a/testing/servicestests/src/com/android/server/appsearch/stats/PlatformLoggerTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/stats/PlatformLoggerTest.java
@@ -40,11 +40,6 @@ import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mockito;
 
-import java.io.UnsupportedEncodingException;
-import java.math.BigInteger;
-import java.nio.charset.StandardCharsets;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
 import java.util.Map;
 
 /**
@@ -69,76 +64,6 @@ public class PlatformLoggerTest {
         };
     }
 
-    @Test
-    public void testCalculateHashCode_MD5_int32_shortString()
-            throws NoSuchAlgorithmException, UnsupportedEncodingException {
-        final String str1 = "d1";
-        final String str2 = "d2";
-
-        int hashCodeForStr1 = PlatformLogger.calculateHashCodeMd5(str1);
-
-        // hashing should be stable
-        assertThat(hashCodeForStr1).isEqualTo(
-                PlatformLogger.calculateHashCodeMd5(str1));
-        assertThat(hashCodeForStr1).isNotEqualTo(
-                PlatformLogger.calculateHashCodeMd5(str2));
-    }
-
-    @Test
-    public void testGetCalculateCode_MD5_int32_mediumString()
-            throws NoSuchAlgorithmException, UnsupportedEncodingException {
-        final String str1 = "Siblings";
-        final String str2 = "Teheran";
-
-        int hashCodeForStr1 = PlatformLogger.calculateHashCodeMd5(str1);
-
-        // hashing should be stable
-        assertThat(hashCodeForStr1).isEqualTo(
-                PlatformLogger.calculateHashCodeMd5(str1));
-        assertThat(hashCodeForStr1).isNotEqualTo(
-                PlatformLogger.calculateHashCodeMd5(str2));
-    }
-
-    @Test
-    public void testCalculateHashCode_MD5_int32_longString() throws NoSuchAlgorithmException,
-            UnsupportedEncodingException {
-        final String str1 = "abcdefghijkl-mnopqrstuvwxyz";
-        final String str2 = "abcdefghijkl-mnopqrstuvwxy123";
-
-        int hashCodeForStr1 = PlatformLogger.calculateHashCodeMd5(str1);
-
-        // hashing should be stable
-        assertThat(hashCodeForStr1).isEqualTo(
-                PlatformLogger.calculateHashCodeMd5(str1));
-        assertThat(hashCodeForStr1).isNotEqualTo(
-                PlatformLogger.calculateHashCodeMd5(str2));
-    }
-
-    @Test
-    public void testCalculateHashCode_MD5_int32_sameAsBigInteger_intValue() throws
-            NoSuchAlgorithmException, UnsupportedEncodingException {
-        final String emptyStr = "";
-        final String shortStr = "a";
-        final String mediumStr = "Teheran";
-        final String longStr = "abcd-efgh-ijkl-mnop-qrst-uvwx-yz";
-
-        int emptyHashCode = PlatformLogger.calculateHashCodeMd5(emptyStr);
-        int shortHashCode = PlatformLogger.calculateHashCodeMd5(shortStr);
-        int mediumHashCode = PlatformLogger.calculateHashCodeMd5(mediumStr);
-        int longHashCode = PlatformLogger.calculateHashCodeMd5(longStr);
-
-        assertThat(emptyHashCode).isEqualTo(calculateHashCodeMd5withBigInteger(emptyStr));
-        assertThat(shortHashCode).isEqualTo(calculateHashCodeMd5withBigInteger(shortStr));
-        assertThat(mediumHashCode).isEqualTo(calculateHashCodeMd5withBigInteger(mediumStr));
-        assertThat(longHashCode).isEqualTo(calculateHashCodeMd5withBigInteger(longStr));
-    }
-
-    @Test
-    public void testCalculateHashCode_MD5_strIsNull() throws
-            NoSuchAlgorithmException, UnsupportedEncodingException {
-        assertThat(PlatformLogger.calculateHashCodeMd5(/*str=*/ null)).isEqualTo(-1);
-    }
-
     /** Makes sure the caching works while getting the UID for calling package. */
     @Test
     public void testGetPackageUidAsUser() throws Exception {
@@ -175,14 +100,6 @@ public class PlatformLoggerTest {
         assertThat(extraStats.mPackageUid).isEqualTo(testUid);
     }
 
-    private static int calculateHashCodeMd5withBigInteger(@NonNull String str)
-            throws NoSuchAlgorithmException {
-        MessageDigest md = MessageDigest.getInstance("MD5");
-        md.update(str.getBytes(StandardCharsets.UTF_8));
-        byte[] digest = md.digest();
-        return new BigInteger(digest).intValue();
-    }
-
     @NonNull
     private PackageManager getMockPackageManager(@NonNull UserHandle user) {
         PackageManager pm = mMockPackageManagers.get(user);
diff --git a/testing/servicestests/src/com/android/server/appsearch/stats/StatsUtilTest.java b/testing/servicestests/src/com/android/server/appsearch/stats/StatsUtilTest.java
new file mode 100644
index 00000000..1e8a1cdd
--- /dev/null
+++ b/testing/servicestests/src/com/android/server/appsearch/stats/StatsUtilTest.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.appsearch.stats;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.annotation.NonNull;
+
+import com.android.server.appsearch.util.StatsUtil;
+
+import org.junit.Test;
+
+import java.io.UnsupportedEncodingException;
+import java.math.BigInteger;
+import java.nio.charset.StandardCharsets;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+/**
+ * Tests covering the functionalities in {@link StatsUtil} NOT requiring overriding any flags in
+ * {@link android.provider.DeviceConfig}.
+ *
+ * <p>To add tests rely on overriding the flags, please add them in the tests for {@link
+ * PlatformLogger} in mockingservicestests.
+ */
+public class StatsUtilTest {
+
+    @Test
+    public void testCalculateHashCode_MD5_int32_shortString()
+            throws NoSuchAlgorithmException, UnsupportedEncodingException {
+        final String str1 = "d1";
+        final String str2 = "d2";
+
+        int hashCodeForStr1 = StatsUtil.calculateHashCodeMd5(str1);
+
+        // hashing should be stable
+        assertThat(hashCodeForStr1).isEqualTo(StatsUtil.calculateHashCodeMd5(str1));
+        assertThat(hashCodeForStr1).isNotEqualTo(StatsUtil.calculateHashCodeMd5(str2));
+    }
+
+    @Test
+    public void testGetCalculateCode_MD5_int32_mediumString()
+            throws NoSuchAlgorithmException, UnsupportedEncodingException {
+        final String str1 = "Siblings";
+        final String str2 = "Teheran";
+
+        int hashCodeForStr1 = StatsUtil.calculateHashCodeMd5(str1);
+
+        // hashing should be stable
+        assertThat(hashCodeForStr1).isEqualTo(StatsUtil.calculateHashCodeMd5(str1));
+        assertThat(hashCodeForStr1).isNotEqualTo(StatsUtil.calculateHashCodeMd5(str2));
+    }
+
+    @Test
+    public void testCalculateHashCode_MD5_int32_longString()
+            throws NoSuchAlgorithmException, UnsupportedEncodingException {
+        final String str1 = "abcdefghijkl-mnopqrstuvwxyz";
+        final String str2 = "abcdefghijkl-mnopqrstuvwxy123";
+
+        int hashCodeForStr1 = StatsUtil.calculateHashCodeMd5(str1);
+
+        // hashing should be stable
+        assertThat(hashCodeForStr1).isEqualTo(StatsUtil.calculateHashCodeMd5(str1));
+        assertThat(hashCodeForStr1).isNotEqualTo(StatsUtil.calculateHashCodeMd5(str2));
+    }
+
+    @Test
+    public void testCalculateHashCode_MD5_int32_sameAsBigInteger_intValue()
+            throws NoSuchAlgorithmException, UnsupportedEncodingException {
+        final String emptyStr = "";
+        final String shortStr = "a";
+        final String mediumStr = "Teheran";
+        final String longStr = "abcd-efgh-ijkl-mnop-qrst-uvwx-yz";
+
+        int emptyHashCode = StatsUtil.calculateHashCodeMd5(emptyStr);
+        int shortHashCode = StatsUtil.calculateHashCodeMd5(shortStr);
+        int mediumHashCode = StatsUtil.calculateHashCodeMd5(mediumStr);
+        int longHashCode = StatsUtil.calculateHashCodeMd5(longStr);
+
+        assertThat(emptyHashCode).isEqualTo(calculateHashCodeMd5withBigInteger(emptyStr));
+        assertThat(shortHashCode).isEqualTo(calculateHashCodeMd5withBigInteger(shortStr));
+        assertThat(mediumHashCode).isEqualTo(calculateHashCodeMd5withBigInteger(mediumStr));
+        assertThat(longHashCode).isEqualTo(calculateHashCodeMd5withBigInteger(longStr));
+    }
+
+    @Test
+    public void testCalculateHashCode_MD5_strIsNull()
+            throws NoSuchAlgorithmException, UnsupportedEncodingException {
+        assertThat(StatsUtil.calculateHashCodeMd5(/* str= */ null)).isEqualTo(-1);
+    }
+
+    private static int calculateHashCodeMd5withBigInteger(@NonNull String str)
+            throws NoSuchAlgorithmException {
+        MessageDigest md = MessageDigest.getInstance("MD5");
+        md.update(str.getBytes(StandardCharsets.UTF_8));
+        byte[] digest = md.digest();
+        return new BigInteger(digest).intValue();
+    }
+}
diff --git a/testing/servicestests/src/com/android/server/appsearch/visibilitystore/VisibilityCheckerImplTest.java b/testing/servicestests/src/com/android/server/appsearch/visibilitystore/VisibilityCheckerImplTest.java
index 23cf16fb..705b43a9 100644
--- a/testing/servicestests/src/com/android/server/appsearch/visibilitystore/VisibilityCheckerImplTest.java
+++ b/testing/servicestests/src/com/android/server/appsearch/visibilitystore/VisibilityCheckerImplTest.java
@@ -18,6 +18,7 @@ package com.android.server.appsearch.visibilitystore;
 
 import static android.Manifest.permission.EXECUTE_APP_FUNCTIONS;
 import static android.Manifest.permission.EXECUTE_APP_FUNCTIONS_TRUSTED;
+import static android.Manifest.permission.PACKAGE_USAGE_STATS;
 import static android.Manifest.permission.READ_ASSISTANT_APP_SEARCH_DATA;
 import static android.Manifest.permission.READ_CALENDAR;
 import static android.Manifest.permission.READ_CONTACTS;
@@ -56,6 +57,7 @@ import android.util.ArrayMap;
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.platform.app.InstrumentationRegistry;
 
+import com.android.appsearch.flags.Flags;
 import com.android.server.appsearch.external.localstorage.AppSearchImpl;
 import com.android.server.appsearch.external.localstorage.OptimizeStrategy;
 import com.android.server.appsearch.external.localstorage.util.PrefixUtil;
@@ -79,11 +81,13 @@ public class VisibilityCheckerImplTest {
      * Always trigger optimize in this class. OptimizeStrategy will be tested in its own test class.
      */
     private static final OptimizeStrategy ALWAYS_OPTIMIZE = optimizeInfo -> true;
+
     // These constants are hidden in SetSchemaRequest
     private static final int ENTERPRISE_ACCESS = 7;
     private static final int MANAGED_PROFILE_CONTACTS_ACCESS = 8;
     private static final int SET_SCHEMA_REQUEST_EXECUTE_APP_FUNCTIONS = 9;
     private static final int SET_SCHEMA_REQUEST_EXECUTE_APP_FUNCTIONS_TRUSTED = 10;
+    private static final int SET_SCHEMA_REQUEST_PACKAGE_USAGE_STATS = 11;
 
     @Rule
     public final CheckFlagsRule mCheckFlagsRule = DeviceFlagsValueProvider.createCheckFlagsRule();
@@ -99,47 +103,50 @@ public class VisibilityCheckerImplTest {
     @Before
     public void setUp() throws Exception {
         Context context = ApplicationProvider.getApplicationContext();
-        mAttributionSource = AppSearchAttributionSource.createAttributionSource(context,
-                /* callingPid= */ 1);
-        mContext = new ContextWrapper(context) {
-            @Override
-            public Context createContextAsUser(UserHandle user, int flags) {
-                return new ContextWrapper(super.createContextAsUser(user, flags)) {
+        mAttributionSource =
+                AppSearchAttributionSource.createAttributionSource(context, /* callingPid= */ 1);
+        mContext =
+                new ContextWrapper(context) {
+                    @Override
+                    public Context createContextAsUser(UserHandle user, int flags) {
+                        return new ContextWrapper(super.createContextAsUser(user, flags)) {
+                            @Override
+                            public PackageManager getPackageManager() {
+                                return getMockPackageManager(user);
+                            }
+                        };
+                    }
+
                     @Override
                     public PackageManager getPackageManager() {
-                        return getMockPackageManager(user);
+                        return createContextAsUser(getUser(), /* flags= */ 0).getPackageManager();
                     }
                 };
-            }
-
-            @Override
-            public PackageManager getPackageManager() {
-                return createContextAsUser(getUser(), /*flags=*/ 0).getPackageManager();
-            }
-        };
         mUiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
         mVisibilityChecker = Mockito.spy(new VisibilityCheckerImpl(mContext));
         // Give ourselves global query permissions
-        AppSearchImpl appSearchImpl = AppSearchImpl.create(
-                mTemporaryFolder.newFolder(),
-                new FakeAppSearchConfig(),
-                /*initStatsBuilder=*/ null,
-                mVisibilityChecker,
-                ALWAYS_OPTIMIZE);
-        mVisibilityStore = new VisibilityStore(appSearchImpl);
+        AppSearchImpl appSearchImpl =
+                AppSearchImpl.create(
+                        mTemporaryFolder.newFolder(),
+                        new FakeAppSearchConfig(),
+                        /* initStatsBuilder= */ null,
+                        mVisibilityChecker,
+                        /* revocableFileDescriptorStore= */ null,
+                        ALWAYS_OPTIMIZE);
+        mVisibilityStore = VisibilityStore.createDocumentVisibilityStore(appSearchImpl);
     }
 
     @Test
     public void testDoesCallerHaveSystemAccess() {
         PackageManager mockPackageManager = getMockPackageManager(mContext.getUser());
-        when(mockPackageManager
-                .checkPermission(READ_GLOBAL_APP_SEARCH_DATA, mContext.getPackageName()))
+        when(mockPackageManager.checkPermission(
+                        READ_GLOBAL_APP_SEARCH_DATA, mContext.getPackageName()))
                 .thenReturn(PERMISSION_GRANTED);
         assertThat(mVisibilityChecker.doesCallerHaveSystemAccess(mContext.getPackageName()))
                 .isTrue();
 
-        when(mockPackageManager
-                .checkPermission(READ_GLOBAL_APP_SEARCH_DATA, mContext.getPackageName()))
+        when(mockPackageManager.checkPermission(
+                        READ_GLOBAL_APP_SEARCH_DATA, mContext.getPackageName()))
                 .thenReturn(PERMISSION_DENIED);
         assertThat(mVisibilityChecker.doesCallerHaveSystemAccess(mContext.getPackageName()))
                 .isFalse();
@@ -148,47 +155,60 @@ public class VisibilityCheckerImplTest {
     @Test
     public void testSetVisibility_displayedBySystem() throws Exception {
         // Create two InternalVisibilityConfig that are not displayed by system.
-        InternalVisibilityConfig
-                visibilityConfig1 = new InternalVisibilityConfig.Builder(/*id=*/"prefix/Schema1")
-                .setNotDisplayedBySystem(true).build();
-        InternalVisibilityConfig
-                visibilityConfig2 = new InternalVisibilityConfig.Builder(/*id=*/"prefix/Schema2")
-                .setNotDisplayedBySystem(true).build();
-        mVisibilityStore.setVisibility(
-                ImmutableList.of(visibilityConfig1, visibilityConfig2));
-
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ true,
-                        /*isForEnterprise=*/ false),
-                "package",
-                "prefix/Schema1",
-                mVisibilityStore))
+        InternalVisibilityConfig visibilityConfig1 =
+                new InternalVisibilityConfig.Builder(/* id= */ "prefix/Schema1")
+                        .setNotDisplayedBySystem(true)
+                        .build();
+        InternalVisibilityConfig visibilityConfig2 =
+                new InternalVisibilityConfig.Builder(/* id= */ "prefix/Schema2")
+                        .setNotDisplayedBySystem(true)
+                        .build();
+        mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig1, visibilityConfig2));
+
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        mAttributionSource,
+                                        /* callerHasSystemAccess= */ true,
+                                        /* isForEnterprise= */ false),
+                                "package",
+                                "prefix/Schema1",
+                                mVisibilityStore))
                 .isFalse();
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ true,
-                        /*isForEnterprise=*/ false),
-                "package",
-                "prefix/Schema2",
-                mVisibilityStore))
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        mAttributionSource,
+                                        /* callerHasSystemAccess= */ true,
+                                        /* isForEnterprise= */ false),
+                                "package",
+                                "prefix/Schema2",
+                                mVisibilityStore))
                 .isFalse();
 
         // Rewrite Visibility Document 1 to let it accessible to the system.
-        visibilityConfig1 = new InternalVisibilityConfig.Builder(/*id=*/"prefix/Schema1").build();
-        mVisibilityStore.setVisibility(
-                ImmutableList.of(visibilityConfig1, visibilityConfig2));
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ true,
-                        /*isForEnterprise=*/ false),
-                "package",
-                "prefix/Schema1",
-                mVisibilityStore))
+        visibilityConfig1 =
+                new InternalVisibilityConfig.Builder(/* id= */ "prefix/Schema1").build();
+        mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig1, visibilityConfig2));
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        mAttributionSource,
+                                        /* callerHasSystemAccess= */ true,
+                                        /* isForEnterprise= */ false),
+                                "package",
+                                "prefix/Schema1",
+                                mVisibilityStore))
                 .isTrue();
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ true,
-                        /*isForEnterprise=*/ false),
-                "package",
-                "prefix/Schema2",
-                mVisibilityStore))
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        mAttributionSource,
+                                        /* callerHasSystemAccess= */ true,
+                                        /* isForEnterprise= */ false),
+                                "package",
+                                "prefix/Schema2",
+                                mVisibilityStore))
                 .isFalse();
     }
 
@@ -210,106 +230,130 @@ public class VisibilityCheckerImplTest {
         int uidNotFooOrBar = 3;
 
         // Grant package access
-        InternalVisibilityConfig
-                visibilityConfig1 = new InternalVisibilityConfig.Builder(/*id=*/"prefix/SchemaFoo")
-                .addVisibleToPackage(new PackageIdentifier(packageNameFoo, sha256CertFoo)).build();
-        InternalVisibilityConfig
-                visibilityConfig2 = new InternalVisibilityConfig.Builder(/*id=*/"prefix/SchemaBar")
-                .addVisibleToPackage(new PackageIdentifier(packageNameBar, sha256CertBar)).build();
-        mVisibilityStore.setVisibility(
-                ImmutableList.of(visibilityConfig1, visibilityConfig2));
+        InternalVisibilityConfig visibilityConfig1 =
+                new InternalVisibilityConfig.Builder(/* id= */ "prefix/SchemaFoo")
+                        .addVisibleToPackage(new PackageIdentifier(packageNameFoo, sha256CertFoo))
+                        .build();
+        InternalVisibilityConfig visibilityConfig2 =
+                new InternalVisibilityConfig.Builder(/* id= */ "prefix/SchemaBar")
+                        .addVisibleToPackage(new PackageIdentifier(packageNameBar, sha256CertBar))
+                        .build();
+        mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig1, visibilityConfig2));
 
         // Should fail if PackageManager doesn't see that it has the proper certificate
         PackageManager mockPackageManager = getMockPackageManager(mContext.getUser());
-        when(mockPackageManager.getPackageUid(eq(packageNameFoo), /*flags=*/ anyInt()))
+        when(mockPackageManager.getPackageUid(eq(packageNameFoo), /* flags= */ anyInt()))
                 .thenReturn(uidFoo);
         when(mockPackageManager.hasSigningCertificate(
-                packageNameFoo, sha256CertFoo, PackageManager.CERT_INPUT_SHA256))
+                        packageNameFoo, sha256CertFoo, PackageManager.CERT_INPUT_SHA256))
                 .thenReturn(false);
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(new AppSearchAttributionSource(packageNameFoo, uidFoo,
-                        pidFoo),
-                        /*callerHasSystemAccess=*/ false, /*isForEnterprise=*/ false),
-                "package",
-                "prefix/SchemaFoo",
-                mVisibilityStore))
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        new AppSearchAttributionSource(
+                                                packageNameFoo, uidFoo, pidFoo),
+                                        /* callerHasSystemAccess= */ false,
+                                        /* isForEnterprise= */ false),
+                                "package",
+                                "prefix/SchemaFoo",
+                                mVisibilityStore))
                 .isFalse();
 
         // Should fail if PackageManager doesn't think the package belongs to the uid
-        when(mockPackageManager.getPackageUid(eq(packageNameFoo), /*flags=*/ anyInt()))
+        when(mockPackageManager.getPackageUid(eq(packageNameFoo), /* flags= */ anyInt()))
                 .thenReturn(uidNotFooOrBar);
         when(mockPackageManager.hasSigningCertificate(
-                packageNameFoo, sha256CertFoo, PackageManager.CERT_INPUT_SHA256))
+                        packageNameFoo, sha256CertFoo, PackageManager.CERT_INPUT_SHA256))
                 .thenReturn(true);
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(new AppSearchAttributionSource(packageNameFoo, uidFoo,
-                        pidFoo),
-                        /*callerHasSystemAccess=*/ false, /*isForEnterprise=*/ false),
-                "package",
-                "prefix/SchemaFoo",
-                mVisibilityStore))
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        new AppSearchAttributionSource(
+                                                packageNameFoo, uidFoo, pidFoo),
+                                        /* callerHasSystemAccess= */ false,
+                                        /* isForEnterprise= */ false),
+                                "package",
+                                "prefix/SchemaFoo",
+                                mVisibilityStore))
                 .isFalse();
 
         // But if uid and certificate match, then we should have access
-        when(mockPackageManager.getPackageUid(eq(packageNameFoo), /*flags=*/ anyInt()))
+        when(mockPackageManager.getPackageUid(eq(packageNameFoo), /* flags= */ anyInt()))
                 .thenReturn(uidFoo);
         when(mockPackageManager.hasSigningCertificate(
-                packageNameFoo, sha256CertFoo, PackageManager.CERT_INPUT_SHA256))
+                        packageNameFoo, sha256CertFoo, PackageManager.CERT_INPUT_SHA256))
                 .thenReturn(true);
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(new AppSearchAttributionSource(packageNameFoo, uidFoo,
-                        pidFoo),
-                        /*callerHasSystemAccess=*/ false, /*isForEnterprise=*/ false),
-                "package",
-                "prefix/SchemaFoo",
-                mVisibilityStore))
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        new AppSearchAttributionSource(
+                                                packageNameFoo, uidFoo, pidFoo),
+                                        /* callerHasSystemAccess= */ false,
+                                        /* isForEnterprise= */ false),
+                                "package",
+                                "prefix/SchemaFoo",
+                                mVisibilityStore))
                 .isTrue();
 
-        when(mockPackageManager.getPackageUid(eq(packageNameBar), /*flags=*/ anyInt()))
+        when(mockPackageManager.getPackageUid(eq(packageNameBar), /* flags= */ anyInt()))
                 .thenReturn(uidBar);
         when(mockPackageManager.hasSigningCertificate(
-                packageNameBar, sha256CertBar, PackageManager.CERT_INPUT_SHA256))
+                        packageNameBar, sha256CertBar, PackageManager.CERT_INPUT_SHA256))
                 .thenReturn(true);
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(new AppSearchAttributionSource(packageNameBar, uidBar,
-                        pidBar),
-                        /*callerHasSystemAccess=*/ false, /*isForEnterprise=*/ false),
-                "package",
-                "prefix/SchemaBar",
-                mVisibilityStore))
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        new AppSearchAttributionSource(
+                                                packageNameBar, uidBar, pidBar),
+                                        /* callerHasSystemAccess= */ false,
+                                        /* isForEnterprise= */ false),
+                                "package",
+                                "prefix/SchemaBar",
+                                mVisibilityStore))
                 .isTrue();
 
         // Save default document and, then we shouldn't have access
-        visibilityConfig1 = new InternalVisibilityConfig.Builder(/*id=*/"prefix/SchemaFoo").build();
-        visibilityConfig2 = new InternalVisibilityConfig.Builder(/*id=*/"prefix/SchemaBar").build();
+        visibilityConfig1 =
+                new InternalVisibilityConfig.Builder(/* id= */ "prefix/SchemaFoo").build();
+        visibilityConfig2 =
+                new InternalVisibilityConfig.Builder(/* id= */ "prefix/SchemaBar").build();
         mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig1, visibilityConfig2));
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(new AppSearchAttributionSource(packageNameFoo, uidFoo,
-                        pidBar),
-                        /*callerHasSystemAccess=*/ false, /*isForEnterprise=*/ false),
-                "package",
-                "prefix/SchemaFoo",
-                mVisibilityStore))
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        new AppSearchAttributionSource(
+                                                packageNameFoo, uidFoo, pidBar),
+                                        /* callerHasSystemAccess= */ false,
+                                        /* isForEnterprise= */ false),
+                                "package",
+                                "prefix/SchemaFoo",
+                                mVisibilityStore))
                 .isFalse();
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(new AppSearchAttributionSource(packageNameBar, uidBar,
-                        pidBar),
-                        /*callerHasSystemAccess=*/ false, /*isForEnterprise=*/ false),
-                "package",
-                "prefix/SchemaBar",
-                mVisibilityStore))
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        new AppSearchAttributionSource(
+                                                packageNameBar, uidBar, pidBar),
+                                        /* callerHasSystemAccess= */ false,
+                                        /* isForEnterprise= */ false),
+                                "package",
+                                "prefix/SchemaBar",
+                                mVisibilityStore))
                 .isFalse();
     }
 
     @Test
     public void testIsSchemaSearchableByCaller_noVisibilityConfig_defaultPlatformVisible() {
         String prefix = PrefixUtil.createPrefix("package", "database");
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ true,
-                        /*isForEnterprise=*/ false),
-                "package",
-                prefix + "Schema",
-                mVisibilityStore))
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        mAttributionSource,
+                                        /* callerHasSystemAccess= */ true,
+                                        /* isForEnterprise= */ false),
+                                "package",
+                                prefix + "Schema",
+                                mVisibilityStore))
                 .isTrue();
     }
 
@@ -322,22 +366,26 @@ public class VisibilityCheckerImplTest {
 
         // Pretend we can't find the Foo package.
         PackageManager mockPackageManager = getMockPackageManager(mContext.getUser());
-        when(mockPackageManager.getPackageUid(eq(packageNameFoo), /*flags=*/ anyInt()))
+        when(mockPackageManager.getPackageUid(eq(packageNameFoo), /* flags= */ anyInt()))
                 .thenThrow(new PackageManager.NameNotFoundException());
 
-        InternalVisibilityConfig
-                visibilityConfig1 = new InternalVisibilityConfig.Builder(/*id=*/"prefix/SchemaFoo")
-                .addVisibleToPackage(new PackageIdentifier(packageNameFoo, sha256CertFoo)).build();
+        InternalVisibilityConfig visibilityConfig1 =
+                new InternalVisibilityConfig.Builder(/* id= */ "prefix/SchemaFoo")
+                        .addVisibleToPackage(new PackageIdentifier(packageNameFoo, sha256CertFoo))
+                        .build();
         // Grant package access
         mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig1));
 
         // If we can't verify the Foo package that has access, assume it doesn't have access.
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ false,
-                        /*isForEnterprise=*/ false),
-                "package",
-                "prefix/SchemaFoo",
-                mVisibilityStore))
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        mAttributionSource,
+                                        /* callerHasSystemAccess= */ false,
+                                        /* isForEnterprise= */ false),
+                                "package",
+                                "prefix/SchemaFoo",
+                                mVisibilityStore))
                 .isFalse();
     }
 
@@ -347,94 +395,116 @@ public class VisibilityCheckerImplTest {
         String packageNameFoo = "packageFoo";
         byte[] sha256CertFoo = new byte[] {10};
 
-        InternalVisibilityConfig
-                visibilityConfig = new InternalVisibilityConfig.Builder(/*id=*/"$/Schema")
-                .addVisibleToPackage(new PackageIdentifier(packageNameFoo, sha256CertFoo)).build();
+        InternalVisibilityConfig visibilityConfig =
+                new InternalVisibilityConfig.Builder(/* id= */ "$/Schema")
+                        .addVisibleToPackage(new PackageIdentifier(packageNameFoo, sha256CertFoo))
+                        .build();
         mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig));
 
         // is accessible for caller who has system access.
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ true,
-                        /*isForEnterprise=*/ false),
-                /*packageName=*/ "",
-                "$/Schema",
-                mVisibilityStore)).isTrue();
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        mAttributionSource,
+                                        /* callerHasSystemAccess= */ true,
+                                        /* isForEnterprise= */ false),
+                                /* packageName= */ "",
+                                "$/Schema",
+                                mVisibilityStore))
+                .isTrue();
 
         PackageManager mockPackageManager = getMockPackageManager(mContext.getUser());
-        when(mockPackageManager.getPackageUid(eq(packageNameFoo), /*flags=*/ anyInt()))
+        when(mockPackageManager.getPackageUid(eq(packageNameFoo), /* flags= */ anyInt()))
                 .thenReturn(mAttributionSource.getUid());
         when(mockPackageManager.hasSigningCertificate(
-                packageNameFoo, sha256CertFoo, PackageManager.CERT_INPUT_SHA256))
+                        packageNameFoo, sha256CertFoo, PackageManager.CERT_INPUT_SHA256))
                 .thenReturn(true);
         // is accessible for caller who in the allow package list.
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ false,
-                        /*isForEnterprise=*/ false),
-                /*packageName=*/ "",
-                "$/Schema",
-                mVisibilityStore)).isTrue();
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        mAttributionSource,
+                                        /* callerHasSystemAccess= */ false,
+                                        /* isForEnterprise= */ false),
+                                /* packageName= */ "",
+                                "$/Schema",
+                                mVisibilityStore))
+                .isTrue();
     }
 
     @Test
     public void testSetSchema_defaultPlatformVisible() throws Exception {
         String prefix = PrefixUtil.createPrefix("package", "database");
-        InternalVisibilityConfig visibilityConfig = new InternalVisibilityConfig.Builder(
-                /*id=*/prefix + "Schema").build();
+        InternalVisibilityConfig visibilityConfig =
+                new InternalVisibilityConfig.Builder(/* id= */ prefix + "Schema").build();
         mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig));
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ true,
-                        /*isForEnterprise=*/ false),
-                "package",
-                prefix + "Schema",
-                mVisibilityStore))
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        mAttributionSource,
+                                        /* callerHasSystemAccess= */ true,
+                                        /* isForEnterprise= */ false),
+                                "package",
+                                prefix + "Schema",
+                                mVisibilityStore))
                 .isTrue();
     }
 
     @Test
     public void testSetSchema_enterpriseNotPlatformVisible() throws Exception {
         String prefix = PrefixUtil.createPrefix("package", "database");
-        InternalVisibilityConfig visibilityConfig = new InternalVisibilityConfig.Builder(
-                /*id=*/ prefix + "Schema").build();
+        InternalVisibilityConfig visibilityConfig =
+                new InternalVisibilityConfig.Builder(/* id= */ prefix + "Schema").build();
         mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig));
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ true,
-                        /*shouldCheckEnterpriseAccess=*/ true),
-                "package",
-                prefix + "Schema",
-                mVisibilityStore))
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        mAttributionSource,
+                                        /* callerHasSystemAccess= */ true,
+                                        /* shouldCheckEnterpriseAccess= */ true),
+                                "package",
+                                prefix + "Schema",
+                                mVisibilityStore))
                 .isFalse();
     }
 
     @Test
     public void testSetSchema_platformHidden() throws Exception {
         String prefix = PrefixUtil.createPrefix("package", "database");
-        InternalVisibilityConfig visibilityConfig = new InternalVisibilityConfig.Builder(
-                /*id=*/prefix + "Schema")
-                .setNotDisplayedBySystem(true).build();
+        InternalVisibilityConfig visibilityConfig =
+                new InternalVisibilityConfig.Builder(/* id= */ prefix + "Schema")
+                        .setNotDisplayedBySystem(true)
+                        .build();
         mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig));
 
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ true,
-                        /*isForEnterprise=*/ false),
-                "package",
-                prefix + "Schema",
-                mVisibilityStore))
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        mAttributionSource,
+                                        /* callerHasSystemAccess= */ true,
+                                        /* isForEnterprise= */ false),
+                                "package",
+                                prefix + "Schema",
+                                mVisibilityStore))
                 .isFalse();
     }
 
     @Test
     public void testSetSchema_defaultNotVisibleToPackages() throws Exception {
         String prefix = PrefixUtil.createPrefix("package", "database");
-        InternalVisibilityConfig visibilityConfig = new InternalVisibilityConfig.Builder(
-                /*id=*/prefix + "Schema").build();
+        InternalVisibilityConfig visibilityConfig =
+                new InternalVisibilityConfig.Builder(/* id= */ prefix + "Schema").build();
         mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig));
 
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ false,
-                        /*isForEnterprise=*/ false),
-                "package",
-                prefix + "Schema",
-                mVisibilityStore))
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        mAttributionSource,
+                                        /* callerHasSystemAccess= */ false,
+                                        /* isForEnterprise= */ false),
+                                "package",
+                                prefix + "Schema",
+                                mVisibilityStore))
                 .isFalse();
     }
 
@@ -446,25 +516,29 @@ public class VisibilityCheckerImplTest {
 
         // Make sure foo package will pass package manager checks.
         PackageManager mockPackageManager = getMockPackageManager(mContext.getUser());
-        when(mockPackageManager.getPackageUid(eq(packageNameFoo), /*flags=*/ anyInt()))
+        when(mockPackageManager.getPackageUid(eq(packageNameFoo), /* flags= */ anyInt()))
                 .thenReturn(mAttributionSource.getUid());
         when(mockPackageManager.hasSigningCertificate(
-                packageNameFoo, sha256CertFoo, PackageManager.CERT_INPUT_SHA256))
+                        packageNameFoo, sha256CertFoo, PackageManager.CERT_INPUT_SHA256))
                 .thenReturn(true);
 
         String prefix = PrefixUtil.createPrefix("package", "database");
 
-        InternalVisibilityConfig visibilityConfig = new InternalVisibilityConfig.Builder(
-                /*id=*/prefix + "Schema")
-                .addVisibleToPackage(new PackageIdentifier(packageNameFoo, sha256CertFoo)).build();
+        InternalVisibilityConfig visibilityConfig =
+                new InternalVisibilityConfig.Builder(/* id= */ prefix + "Schema")
+                        .addVisibleToPackage(new PackageIdentifier(packageNameFoo, sha256CertFoo))
+                        .build();
         mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig));
 
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ false,
-                        /*isForEnterprise=*/ false),
-                "package",
-                prefix + "Schema",
-                mVisibilityStore))
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        mAttributionSource,
+                                        /* callerHasSystemAccess= */ false,
+                                        /* isForEnterprise= */ false),
+                                "package",
+                                prefix + "Schema",
+                                mVisibilityStore))
                 .isTrue();
     }
 
@@ -476,25 +550,29 @@ public class VisibilityCheckerImplTest {
 
         // Make sure foo package will pass package manager checks.
         PackageManager mockPackageManager = getMockPackageManager(mContext.getUser());
-        when(mockPackageManager.getPackageUid(eq(packageNameFoo), /*flags=*/ anyInt()))
+        when(mockPackageManager.getPackageUid(eq(packageNameFoo), /* flags= */ anyInt()))
                 .thenReturn(mAttributionSource.getUid());
         when(mockPackageManager.hasSigningCertificate(
-                packageNameFoo, sha256CertFoo, PackageManager.CERT_INPUT_SHA256))
+                        packageNameFoo, sha256CertFoo, PackageManager.CERT_INPUT_SHA256))
                 .thenReturn(true);
 
         String prefix = PrefixUtil.createPrefix("package", "database");
 
-        InternalVisibilityConfig visibilityConfig = new InternalVisibilityConfig.Builder(
-                /*id=*/ prefix + "Schema")
-                .addVisibleToPackage(new PackageIdentifier(packageNameFoo, sha256CertFoo)).build();
+        InternalVisibilityConfig visibilityConfig =
+                new InternalVisibilityConfig.Builder(/* id= */ prefix + "Schema")
+                        .addVisibleToPackage(new PackageIdentifier(packageNameFoo, sha256CertFoo))
+                        .build();
         mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig));
 
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ false,
-                        /*shouldCheckEnterpriseAccess=*/ true),
-                "package",
-                prefix + "Schema",
-                mVisibilityStore))
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        mAttributionSource,
+                                        /* callerHasSystemAccess= */ false,
+                                        /* shouldCheckEnterpriseAccess= */ true),
+                                "package",
+                                prefix + "Schema",
+                                mVisibilityStore))
                 .isFalse();
     }
 
@@ -503,32 +581,38 @@ public class VisibilityCheckerImplTest {
         String prefix = PrefixUtil.createPrefix("package", "database");
 
         // Create a VDoc that require READ_SMS permission only.
-        InternalVisibilityConfig visibilityConfig = new InternalVisibilityConfig.Builder(
-                /*id=*/prefix + "Schema")
-                .addVisibleToPermissions(ImmutableSet.of(SetSchemaRequest.READ_SMS))
-                .build();
+        InternalVisibilityConfig visibilityConfig =
+                new InternalVisibilityConfig.Builder(/* id= */ prefix + "Schema")
+                        .addVisibleToPermissions(ImmutableSet.of(SetSchemaRequest.READ_SMS))
+                        .build();
         mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig));
 
         // Grant the READ_SMS permission, we should able to access.
         mUiAutomation.adoptShellPermissionIdentity(READ_SMS);
         try {
-            assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                    new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ false,
-                            /*isForEnterprise=*/ false),
-                    "package",
-                    prefix + "Schema",
-                    mVisibilityStore))
+            assertThat(
+                            mVisibilityChecker.isSchemaSearchableByCaller(
+                                    new FrameworkCallerAccess(
+                                            mAttributionSource,
+                                            /* callerHasSystemAccess= */ false,
+                                            /* isForEnterprise= */ false),
+                                    "package",
+                                    prefix + "Schema",
+                                    mVisibilityStore))
                     .isTrue();
         } finally {
             mUiAutomation.dropShellPermissionIdentity();
         }
         // Drop the READ_SMS permission, it becomes invisible.
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ false,
-                        /*isForEnterprise=*/ false),
-                "package",
-                prefix + "Schema",
-                mVisibilityStore))
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        mAttributionSource,
+                                        /* callerHasSystemAccess= */ false,
+                                        /* isForEnterprise= */ false),
+                                "package",
+                                prefix + "Schema",
+                                mVisibilityStore))
                 .isFalse();
     }
 
@@ -610,27 +694,74 @@ public class VisibilityCheckerImplTest {
                 .isFalse();
     }
 
+    @Test
+    @RequiresFlagsEnabled(Flags.FLAG_APP_OPEN_EVENT_INDEXER_ENABLED)
+    public void testSetSchema_visibleToPackageUsageStatsOnly() throws Exception {
+        String prefix = PrefixUtil.createPrefix("package", "database");
+
+        // Create a doc that requires either PACKAGE_USAGE_STATS permissions only.
+        InternalVisibilityConfig visibilityConfig =
+                new InternalVisibilityConfig.Builder(/* id= */ prefix + "Schema")
+                        .addVisibleToPermissions(
+                                ImmutableSet.of(SET_SCHEMA_REQUEST_PACKAGE_USAGE_STATS))
+                        .build();
+        mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig));
+
+        // Grant the PACKAGE_USAGE_STATS permission, we should able to access.
+        doReturn(true)
+                .when(mVisibilityChecker)
+                .checkPermissionForDataDeliveryGranted(eq(PACKAGE_USAGE_STATS), any(), any());
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        mAttributionSource,
+                                        /* callerHasSystemAccess= */ false,
+                                        /* isForEnterprise= */ false),
+                                "package",
+                                prefix + "Schema",
+                                mVisibilityStore))
+                .isTrue();
+
+        // Drop the PACKAGE_USAGE_STATS permission, should not be accessible
+        doReturn(false)
+                .when(mVisibilityChecker)
+                .checkPermissionForDataDeliveryGranted(eq(PACKAGE_USAGE_STATS), any(), any());
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        mAttributionSource,
+                                        /* callerHasSystemAccess= */ false,
+                                        /* isForEnterprise= */ false),
+                                "package",
+                                prefix + "Schema",
+                                mVisibilityStore))
+                .isFalse();
+    }
+
     @Test
     public void testSetSchema_enterpriseNotVisibleToPermissions_withoutEnterpriseAccessPermission()
             throws Exception {
         String prefix = PrefixUtil.createPrefix("package", "database");
 
         // Create a VDoc that require READ_SMS permission only.
-        InternalVisibilityConfig visibilityConfig = new InternalVisibilityConfig.Builder(
-                /*id=*/ prefix + "Schema")
-                .addVisibleToPermissions(ImmutableSet.of(SetSchemaRequest.READ_SMS))
-                .build();
+        InternalVisibilityConfig visibilityConfig =
+                new InternalVisibilityConfig.Builder(/* id= */ prefix + "Schema")
+                        .addVisibleToPermissions(ImmutableSet.of(SetSchemaRequest.READ_SMS))
+                        .build();
         mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig));
 
         // Grant the READ_SMS permission, but won't be able to access.
         mUiAutomation.adoptShellPermissionIdentity(READ_SMS);
         try {
-            assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                    new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ false,
-                            /*shouldCheckEnterpriseAccess=*/ true),
-                    "package",
-                    prefix + "Schema",
-                    mVisibilityStore))
+            assertThat(
+                            mVisibilityChecker.isSchemaSearchableByCaller(
+                                    new FrameworkCallerAccess(
+                                            mAttributionSource,
+                                            /* callerHasSystemAccess= */ false,
+                                            /* shouldCheckEnterpriseAccess= */ true),
+                                    "package",
+                                    prefix + "Schema",
+                                    mVisibilityStore))
                     .isFalse();
         } finally {
             mUiAutomation.dropShellPermissionIdentity();
@@ -643,34 +774,39 @@ public class VisibilityCheckerImplTest {
         String prefix = PrefixUtil.createPrefix("package", "database");
 
         // Create a VDoc that requires READ_SMS and ENTERPRISE_ACCESS permission.
-        InternalVisibilityConfig visibilityConfig = new InternalVisibilityConfig.Builder(
-                /*id=*/ prefix + "Schema")
-                .addVisibleToPermissions(
-                        ImmutableSet.of(SetSchemaRequest.READ_SMS, ENTERPRISE_ACCESS))
-                .build();
+        InternalVisibilityConfig visibilityConfig =
+                new InternalVisibilityConfig.Builder(/* id= */ prefix + "Schema")
+                        .addVisibleToPermissions(
+                                ImmutableSet.of(SetSchemaRequest.READ_SMS, ENTERPRISE_ACCESS))
+                        .build();
         mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig));
 
         // Grant the READ_SMS permission, we should be able to access.
         mUiAutomation.adoptShellPermissionIdentity(READ_SMS);
         try {
-            assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                    new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ false,
-                            /*shouldCheckEnterpriseAccess=*/ true),
-                    "package",
-                    prefix + "Schema",
-                    mVisibilityStore))
+            assertThat(
+                            mVisibilityChecker.isSchemaSearchableByCaller(
+                                    new FrameworkCallerAccess(
+                                            mAttributionSource,
+                                            /* callerHasSystemAccess= */ false,
+                                            /* shouldCheckEnterpriseAccess= */ true),
+                                    "package",
+                                    prefix + "Schema",
+                                    mVisibilityStore))
                     .isTrue();
         } finally {
             mUiAutomation.dropShellPermissionIdentity();
         }
         // Drop the READ_SMS permission, it becomes invisible.
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(mAttributionSource,
-                        /*callerHasSystemAccess=*/ false,
-                        /*shouldCheckEnterpriseAccess=*/ true),
-                "package",
-                prefix + "Schema",
-                mVisibilityStore))
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        mAttributionSource,
+                                        /* callerHasSystemAccess= */ false,
+                                        /* shouldCheckEnterpriseAccess= */ true),
+                                "package",
+                                prefix + "Schema",
+                                mVisibilityStore))
                 .isFalse();
     }
 
@@ -681,47 +817,59 @@ public class VisibilityCheckerImplTest {
 
         // Create a VDoc that requires ENTERPRISE_ACCESS and MANAGED_PROFILE_CONTACTS_ACCESS
         // permission.
-        InternalVisibilityConfig visibilityConfig = new InternalVisibilityConfig.Builder(
-                /*id=*/ prefix + "Schema")
-                .addVisibleToPermissions(
-                        ImmutableSet.of(ENTERPRISE_ACCESS, MANAGED_PROFILE_CONTACTS_ACCESS))
-                .build();
+        InternalVisibilityConfig visibilityConfig =
+                new InternalVisibilityConfig.Builder(/* id= */ prefix + "Schema")
+                        .addVisibleToPermissions(
+                                ImmutableSet.of(ENTERPRISE_ACCESS, MANAGED_PROFILE_CONTACTS_ACCESS))
+                        .build();
         mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig));
 
         // Use a policy checker without managed profile contacts access
-        mVisibilityChecker = new VisibilityCheckerImpl(mContext, new PolicyChecker() {
-            @Override
-            public boolean doesCallerHaveManagedProfileContactsAccess(
-                    @NonNull String callingPackageName) {
-                return false;
-            }
-        });
+        mVisibilityChecker =
+                new VisibilityCheckerImpl(
+                        mContext,
+                        new PolicyChecker() {
+                            @Override
+                            public boolean doesCallerHaveManagedProfileContactsAccess(
+                                    @NonNull String callingPackageName) {
+                                return false;
+                            }
+                        });
 
         // Fails without managed profile contacts access
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ false,
-                        /*shouldCheckEnterpriseAccess=*/ true),
-                "package",
-                prefix + "Schema",
-                mVisibilityStore))
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        mAttributionSource,
+                                        /* callerHasSystemAccess= */ false,
+                                        /* shouldCheckEnterpriseAccess= */ true),
+                                "package",
+                                prefix + "Schema",
+                                mVisibilityStore))
                 .isFalse();
 
         // Grant managed profile contacts access
-        mVisibilityChecker = new VisibilityCheckerImpl(mContext, new PolicyChecker() {
-            @Override
-            public boolean doesCallerHaveManagedProfileContactsAccess(
-                    @NonNull String callingPackageName) {
-                return true;
-            }
-        });
+        mVisibilityChecker =
+                new VisibilityCheckerImpl(
+                        mContext,
+                        new PolicyChecker() {
+                            @Override
+                            public boolean doesCallerHaveManagedProfileContactsAccess(
+                                    @NonNull String callingPackageName) {
+                                return true;
+                            }
+                        });
 
         // Passes with managed profile contacts access
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ false,
-                        /*shouldCheckEnterpriseAccess=*/ true),
-                "package",
-                prefix + "Schema",
-                mVisibilityStore))
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        mAttributionSource,
+                                        /* callerHasSystemAccess= */ false,
+                                        /* shouldCheckEnterpriseAccess= */ true),
+                                "package",
+                                prefix + "Schema",
+                                mVisibilityStore))
                 .isTrue();
     }
 
@@ -731,38 +879,47 @@ public class VisibilityCheckerImplTest {
         String prefix = PrefixUtil.createPrefix("package", "database");
 
         // Create a VDoc that requires READ_SMS and ENTERPRISE_ACCESS permission.
-        InternalVisibilityConfig visibilityConfig = new InternalVisibilityConfig.Builder(
-                /*id=*/ prefix + "Schema")
-                .addVisibleToPermissions(
-                        ImmutableSet.of(ENTERPRISE_ACCESS, MANAGED_PROFILE_CONTACTS_ACCESS))
-                .build();
+        InternalVisibilityConfig visibilityConfig =
+                new InternalVisibilityConfig.Builder(/* id= */ prefix + "Schema")
+                        .addVisibleToPermissions(
+                                ImmutableSet.of(ENTERPRISE_ACCESS, MANAGED_PROFILE_CONTACTS_ACCESS))
+                        .build();
         mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig));
 
         // Use a policy checker with managed profile contacts access
-        mVisibilityChecker = new VisibilityCheckerImpl(mContext, new PolicyChecker() {
-            @Override
-            public boolean doesCallerHaveManagedProfileContactsAccess(
-                    @NonNull String callingPackageName) {
-                return true;
-            }
-        });
+        mVisibilityChecker =
+                new VisibilityCheckerImpl(
+                        mContext,
+                        new PolicyChecker() {
+                            @Override
+                            public boolean doesCallerHaveManagedProfileContactsAccess(
+                                    @NonNull String callingPackageName) {
+                                return true;
+                            }
+                        });
 
         // Passes with enterprise access
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ false,
-                        /*shouldCheckEnterpriseAccess=*/ true),
-                "package",
-                prefix + "Schema",
-                mVisibilityStore))
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        mAttributionSource,
+                                        /* callerHasSystemAccess= */ false,
+                                        /* shouldCheckEnterpriseAccess= */ true),
+                                "package",
+                                prefix + "Schema",
+                                mVisibilityStore))
                 .isTrue();
 
         // Fails without enterprise access
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ false,
-                        /*shouldCheckEnterpriseAccess=*/ false),
-                "package",
-                prefix + "Schema",
-                mVisibilityStore))
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        mAttributionSource,
+                                        /* callerHasSystemAccess= */ false,
+                                        /* shouldCheckEnterpriseAccess= */ false),
+                                "package",
+                                prefix + "Schema",
+                                mVisibilityStore))
                 .isFalse();
     }
 
@@ -772,24 +929,26 @@ public class VisibilityCheckerImplTest {
         String prefix = PrefixUtil.createPrefix("package", "database");
 
         // Create a VDoc that requires ENTERPRISE_ACCESS permission.
-        InternalVisibilityConfig visibilityConfig = new InternalVisibilityConfig.Builder(
-                /*id=*/ prefix + "Schema")
-                .addVisibleToPermissions(
-                        ImmutableSet.of(ENTERPRISE_ACCESS))
-                .build();
+        InternalVisibilityConfig visibilityConfig =
+                new InternalVisibilityConfig.Builder(/* id= */ prefix + "Schema")
+                        .addVisibleToPermissions(ImmutableSet.of(ENTERPRISE_ACCESS))
+                        .build();
         mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig));
 
         // We should not be able to access since the only permission set has ENTERPRISE_ACCESS
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ false,
-                        /*isForEnterprise=*/ false),
-                "package",
-                prefix + "Schema",
-                mVisibilityStore))
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        mAttributionSource,
+                                        /* callerHasSystemAccess= */ false,
+                                        /* isForEnterprise= */ false),
+                                "package",
+                                prefix + "Schema",
+                                mVisibilityStore))
                 .isFalse();
     }
 
-    //TODO(b/202194495) add test for READ_HOME_APP_SEARCH_DATA and READ_ASSISTANT_APP_SEARCH_DATA
+    // TODO(b/202194495) add test for READ_HOME_APP_SEARCH_DATA and READ_ASSISTANT_APP_SEARCH_DATA
     // once they are available in Shell.
     @Test
     public void testSetSchema_visibleToPermissions_anyCombinations() throws Exception {
@@ -797,24 +956,29 @@ public class VisibilityCheckerImplTest {
 
         // Create a VDoc that require the querier to hold both READ_SMS and READ_CALENDAR, or
         // READ_CONTACTS only or READ_EXTERNAL_STORAGE only.
-        InternalVisibilityConfig visibilityConfig = new InternalVisibilityConfig.Builder(
-                /*id=*/prefix + "Schema")
-                .addVisibleToPermissions(
-                        ImmutableSet.of(SetSchemaRequest.READ_SMS, SetSchemaRequest.READ_CALENDAR))
-                .addVisibleToPermissions(ImmutableSet.of(SetSchemaRequest.READ_CONTACTS))
-                .addVisibleToPermissions(ImmutableSet.of(SetSchemaRequest.READ_EXTERNAL_STORAGE))
-                .build();
+        InternalVisibilityConfig visibilityConfig =
+                new InternalVisibilityConfig.Builder(/* id= */ prefix + "Schema")
+                        .addVisibleToPermissions(
+                                ImmutableSet.of(
+                                        SetSchemaRequest.READ_SMS, SetSchemaRequest.READ_CALENDAR))
+                        .addVisibleToPermissions(ImmutableSet.of(SetSchemaRequest.READ_CONTACTS))
+                        .addVisibleToPermissions(
+                                ImmutableSet.of(SetSchemaRequest.READ_EXTERNAL_STORAGE))
+                        .build();
         mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig));
 
         // Grant the READ_SMS and READ_CALENDAR permission, we should able to access.
         mUiAutomation.adoptShellPermissionIdentity(READ_SMS, READ_CALENDAR);
         try {
-            assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                    new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ false,
-                            /*isForEnterprise=*/ false),
-                    "package",
-                    prefix + "Schema",
-                    mVisibilityStore))
+            assertThat(
+                            mVisibilityChecker.isSchemaSearchableByCaller(
+                                    new FrameworkCallerAccess(
+                                            mAttributionSource,
+                                            /* callerHasSystemAccess= */ false,
+                                            /* isForEnterprise= */ false),
+                                    "package",
+                                    prefix + "Schema",
+                                    mVisibilityStore))
                     .isTrue();
         } finally {
             mUiAutomation.dropShellPermissionIdentity();
@@ -823,12 +987,15 @@ public class VisibilityCheckerImplTest {
         // Grant the READ_SMS only, it shouldn't have access.
         mUiAutomation.adoptShellPermissionIdentity(READ_SMS);
         try {
-            assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                    new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ false,
-                            /*isForEnterprise=*/ false),
-                    "package",
-                    prefix + "Schema",
-                    mVisibilityStore))
+            assertThat(
+                            mVisibilityChecker.isSchemaSearchableByCaller(
+                                    new FrameworkCallerAccess(
+                                            mAttributionSource,
+                                            /* callerHasSystemAccess= */ false,
+                                            /* isForEnterprise= */ false),
+                                    "package",
+                                    prefix + "Schema",
+                                    mVisibilityStore))
                     .isFalse();
         } finally {
             mUiAutomation.dropShellPermissionIdentity();
@@ -837,12 +1004,15 @@ public class VisibilityCheckerImplTest {
         // Grant the READ_SMS and READ_CALENDAR permission, we should able to access.
         mUiAutomation.adoptShellPermissionIdentity(READ_SMS, READ_CALENDAR);
         try {
-            assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                    new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ false,
-                            /*isForEnterprise=*/ false),
-                    "package",
-                    prefix + "Schema",
-                    mVisibilityStore))
+            assertThat(
+                            mVisibilityChecker.isSchemaSearchableByCaller(
+                                    new FrameworkCallerAccess(
+                                            mAttributionSource,
+                                            /* callerHasSystemAccess= */ false,
+                                            /* isForEnterprise= */ false),
+                                    "package",
+                                    prefix + "Schema",
+                                    mVisibilityStore))
                     .isTrue();
         } finally {
             mUiAutomation.dropShellPermissionIdentity();
@@ -851,12 +1021,15 @@ public class VisibilityCheckerImplTest {
         // Grant the READ_CONTACTS permission, we should able to access.
         mUiAutomation.adoptShellPermissionIdentity(READ_CONTACTS);
         try {
-            assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                    new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ false,
-                            /*isForEnterprise=*/ false),
-                    "package",
-                    prefix + "Schema",
-                    mVisibilityStore))
+            assertThat(
+                            mVisibilityChecker.isSchemaSearchableByCaller(
+                                    new FrameworkCallerAccess(
+                                            mAttributionSource,
+                                            /* callerHasSystemAccess= */ false,
+                                            /* isForEnterprise= */ false),
+                                    "package",
+                                    prefix + "Schema",
+                                    mVisibilityStore))
                     .isTrue();
         } finally {
             mUiAutomation.dropShellPermissionIdentity();
@@ -865,24 +1038,30 @@ public class VisibilityCheckerImplTest {
         // Grant the READ_EXTERNAL_STORAGE permission, we should able to access.
         mUiAutomation.adoptShellPermissionIdentity(READ_EXTERNAL_STORAGE);
         try {
-            assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                    new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ false,
-                            /*isForEnterprise=*/ false),
-                    "package",
-                    prefix + "Schema",
-                    mVisibilityStore))
+            assertThat(
+                            mVisibilityChecker.isSchemaSearchableByCaller(
+                                    new FrameworkCallerAccess(
+                                            mAttributionSource,
+                                            /* callerHasSystemAccess= */ false,
+                                            /* isForEnterprise= */ false),
+                                    "package",
+                                    prefix + "Schema",
+                                    mVisibilityStore))
                     .isTrue();
         } finally {
             mUiAutomation.dropShellPermissionIdentity();
         }
 
         // Drop permissions, it becomes invisible.
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ false,
-                        /*isForEnterprise=*/ false),
-                "package",
-                prefix + "Schema",
-                mVisibilityStore))
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                new FrameworkCallerAccess(
+                                        mAttributionSource,
+                                        /* callerHasSystemAccess= */ false,
+                                        /* isForEnterprise= */ false),
+                                "package",
+                                prefix + "Schema",
+                                mVisibilityStore))
                 .isFalse();
     }
 
@@ -891,20 +1070,28 @@ public class VisibilityCheckerImplTest {
         String prefix = PrefixUtil.createPrefix("package", "database");
 
         // Create a VDoc with default setting.
-        InternalVisibilityConfig visibilityConfig = new InternalVisibilityConfig.Builder(
-                /*id=*/prefix + "Schema").build();
+        InternalVisibilityConfig visibilityConfig =
+                new InternalVisibilityConfig.Builder(/* id= */ prefix + "Schema").build();
         mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig));
 
         // Give all supported permissions to the caller, it still cannot get the access.
-        mUiAutomation.adoptShellPermissionIdentity(READ_SMS, READ_CALENDAR, READ_CONTACTS,
-                READ_EXTERNAL_STORAGE, READ_HOME_APP_SEARCH_DATA, READ_ASSISTANT_APP_SEARCH_DATA);
+        mUiAutomation.adoptShellPermissionIdentity(
+                READ_SMS,
+                READ_CALENDAR,
+                READ_CONTACTS,
+                READ_EXTERNAL_STORAGE,
+                READ_HOME_APP_SEARCH_DATA,
+                READ_ASSISTANT_APP_SEARCH_DATA);
         try {
-            assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                    new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ false,
-                            /*isForEnterprise=*/ false),
-                    "package",
-                    prefix + "Schema",
-                    mVisibilityStore))
+            assertThat(
+                            mVisibilityChecker.isSchemaSearchableByCaller(
+                                    new FrameworkCallerAccess(
+                                            mAttributionSource,
+                                            /* callerHasSystemAccess= */ false,
+                                            /* isForEnterprise= */ false),
+                                    "package",
+                                    prefix + "Schema",
+                                    mVisibilityStore))
                     .isFalse();
         } finally {
             mUiAutomation.dropShellPermissionIdentity();
@@ -916,22 +1103,26 @@ public class VisibilityCheckerImplTest {
         String prefix = PrefixUtil.createPrefix("package", "database");
 
         // Create a VDoc which requires both READ_SMS and READ_CALENDAR
-        InternalVisibilityConfig visibilityConfig = new InternalVisibilityConfig.Builder(
-                /*id=*/prefix + "Schema")
-                .addVisibleToPermissions(
-                        ImmutableSet.of(SetSchemaRequest.READ_SMS, SetSchemaRequest.READ_CALENDAR))
-                .build();
+        InternalVisibilityConfig visibilityConfig =
+                new InternalVisibilityConfig.Builder(/* id= */ prefix + "Schema")
+                        .addVisibleToPermissions(
+                                ImmutableSet.of(
+                                        SetSchemaRequest.READ_SMS, SetSchemaRequest.READ_CALENDAR))
+                        .build();
         mVisibilityStore.setVisibility(ImmutableList.of(visibilityConfig));
 
         mUiAutomation.adoptShellPermissionIdentity(READ_SMS);
         try {
             // Only has READ_SMS won't have access.
-            assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                    new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ false,
-                            /*isForEnterprise=*/ false),
-                    "package",
-                    prefix + "Schema",
-                    mVisibilityStore))
+            assertThat(
+                            mVisibilityChecker.isSchemaSearchableByCaller(
+                                    new FrameworkCallerAccess(
+                                            mAttributionSource,
+                                            /* callerHasSystemAccess= */ false,
+                                            /* isForEnterprise= */ false),
+                                    "package",
+                                    prefix + "Schema",
+                                    mVisibilityStore))
                     .isFalse();
         } finally {
             mUiAutomation.dropShellPermissionIdentity();
@@ -940,12 +1131,15 @@ public class VisibilityCheckerImplTest {
         mUiAutomation.adoptShellPermissionIdentity(READ_SMS, READ_CALENDAR);
         try {
             // has READ_SMS and READ_CALENDAR will have access.
-            assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                    new FrameworkCallerAccess(mAttributionSource, /*callerHasSystemAccess=*/ false,
-                            /*isForEnterprise=*/ false),
-                    "package",
-                    prefix + "Schema",
-                    mVisibilityStore))
+            assertThat(
+                            mVisibilityChecker.isSchemaSearchableByCaller(
+                                    new FrameworkCallerAccess(
+                                            mAttributionSource,
+                                            /* callerHasSystemAccess= */ false,
+                                            /* isForEnterprise= */ false),
+                                    "package",
+                                    prefix + "Schema",
+                                    mVisibilityStore))
                     .isTrue();
         } finally {
             mUiAutomation.dropShellPermissionIdentity();
@@ -970,11 +1164,14 @@ public class VisibilityCheckerImplTest {
 
         // Mock package certificates
         when(mockPackageManager.hasSigningCertificate(
-                "A", mockSignature, PackageManager.CERT_INPUT_SHA256)).thenReturn(true);
+                        "A", mockSignature, PackageManager.CERT_INPUT_SHA256))
+                .thenReturn(true);
         when(mockPackageManager.hasSigningCertificate(
-                "B", mockSignature, PackageManager.CERT_INPUT_SHA256)).thenReturn(true);
+                        "B", mockSignature, PackageManager.CERT_INPUT_SHA256))
+                .thenReturn(true);
         when(mockPackageManager.hasSigningCertificate(
-                "C", mockSignature, PackageManager.CERT_INPUT_SHA256)).thenReturn(true);
+                        "C", mockSignature, PackageManager.CERT_INPUT_SHA256))
+                .thenReturn(true);
 
         // The Android package will own the schemas, but they will be visible from other packages.
         String prefix = PrefixUtil.createPrefix("android", "database");
@@ -985,47 +1182,96 @@ public class VisibilityCheckerImplTest {
             // android, database, schemaX
             String schemaName = prefix + "Schema" + packageName;
 
-            InternalVisibilityConfig visibilityConfig = new InternalVisibilityConfig.Builder(
-                    /*id=*/schemaName)
-                    .setPubliclyVisibleTargetPackage(
-                            new PackageIdentifier(packageName, mockSignature)).build();
+            InternalVisibilityConfig visibilityConfig =
+                    new InternalVisibilityConfig.Builder(/* id= */ schemaName)
+                            .setPubliclyVisibleTargetPackage(
+                                    new PackageIdentifier(packageName, mockSignature))
+                            .build();
             visibilityConfigs.add(visibilityConfig);
         }
         mVisibilityStore.setVisibility(visibilityConfigs);
 
         FrameworkCallerAccess callerAccessA =
-                new FrameworkCallerAccess(new AppSearchAttributionSource("A", 1,
-                        /* callingPid= */ 1),
-                        /*callerHasSystemAccess=*/ false, /*isForEnterprise=*/ false);
+                new FrameworkCallerAccess(
+                        new AppSearchAttributionSource("A", 1, /* callingPid= */ 1),
+                        /* callerHasSystemAccess= */ false,
+                        /* isForEnterprise= */ false);
         FrameworkCallerAccess callerAccessB =
-                new FrameworkCallerAccess(new AppSearchAttributionSource("B", 2,
-                        /* callingPid= */ 2),
-                        /*callerHasSystemAccess=*/ false, /*isForEnterprise=*/ false);
+                new FrameworkCallerAccess(
+                        new AppSearchAttributionSource("B", 2, /* callingPid= */ 2),
+                        /* callerHasSystemAccess= */ false,
+                        /* isForEnterprise= */ false);
         FrameworkCallerAccess callerAccessC =
-                new FrameworkCallerAccess(new AppSearchAttributionSource("C", 3,
-                        /* callingPid= */ 3),
-                        /*callerHasSystemAccess=*/ false, /*isForEnterprise=*/ false);
-
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                callerAccessA, "android", "android$database/SchemaA", mVisibilityStore)).isTrue();
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                callerAccessA, "android", "android$database/SchemaB", mVisibilityStore)).isFalse();
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                callerAccessA, "android", "android$database/SchemaC", mVisibilityStore)).isFalse();
-
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                callerAccessB, "android", "android$database/SchemaA", mVisibilityStore)).isTrue();
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                callerAccessB, "android", "android$database/SchemaB", mVisibilityStore)).isTrue();
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                callerAccessB, "android", "android$database/SchemaC", mVisibilityStore)).isFalse();
-
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                callerAccessC, "android", "android$database/SchemaA", mVisibilityStore)).isTrue();
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                callerAccessC, "android", "android$database/SchemaB", mVisibilityStore)).isTrue();
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                callerAccessC, "android", "android$database/SchemaC", mVisibilityStore)).isTrue();
+                new FrameworkCallerAccess(
+                        new AppSearchAttributionSource("C", 3, /* callingPid= */ 3),
+                        /* callerHasSystemAccess= */ false,
+                        /* isForEnterprise= */ false);
+
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                callerAccessA,
+                                "android",
+                                "android$database/SchemaA",
+                                mVisibilityStore))
+                .isTrue();
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                callerAccessA,
+                                "android",
+                                "android$database/SchemaB",
+                                mVisibilityStore))
+                .isFalse();
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                callerAccessA,
+                                "android",
+                                "android$database/SchemaC",
+                                mVisibilityStore))
+                .isFalse();
+
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                callerAccessB,
+                                "android",
+                                "android$database/SchemaA",
+                                mVisibilityStore))
+                .isTrue();
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                callerAccessB,
+                                "android",
+                                "android$database/SchemaB",
+                                mVisibilityStore))
+                .isTrue();
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                callerAccessB,
+                                "android",
+                                "android$database/SchemaC",
+                                mVisibilityStore))
+                .isFalse();
+
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                callerAccessC,
+                                "android",
+                                "android$database/SchemaA",
+                                mVisibilityStore))
+                .isTrue();
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                callerAccessC,
+                                "android",
+                                "android$database/SchemaB",
+                                mVisibilityStore))
+                .isTrue();
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                callerAccessC,
+                                "android",
+                                "android$database/SchemaC",
+                                mVisibilityStore))
+                .isTrue();
     }
 
     @Test
@@ -1037,9 +1283,11 @@ public class VisibilityCheckerImplTest {
 
         // Mock package certificates
         when(mockPackageManager.hasSigningCertificate(
-                "A", mockSignature, PackageManager.CERT_INPUT_SHA256)).thenReturn(true);
+                        "A", mockSignature, PackageManager.CERT_INPUT_SHA256))
+                .thenReturn(true);
         when(mockPackageManager.hasSigningCertificate(
-                "B", mockSignature, PackageManager.CERT_INPUT_SHA256)).thenReturn(true);
+                        "B", mockSignature, PackageManager.CERT_INPUT_SHA256))
+                .thenReturn(true);
 
         when(mockPackageManager.canPackageQuery("A", "B"))
                 .thenThrow(new PackageManager.NameNotFoundException());
@@ -1055,27 +1303,40 @@ public class VisibilityCheckerImplTest {
             // android, database, schemaX
             String schemaName = prefix + "Schema" + packageName;
 
-            InternalVisibilityConfig visibilityConfig = new InternalVisibilityConfig.Builder(
-                    /*id=*/schemaName)
-                    .setPubliclyVisibleTargetPackage(
-                            new PackageIdentifier(packageName, mockSignature)).build();
+            InternalVisibilityConfig visibilityConfig =
+                    new InternalVisibilityConfig.Builder(/* id= */ schemaName)
+                            .setPubliclyVisibleTargetPackage(
+                                    new PackageIdentifier(packageName, mockSignature))
+                            .build();
             visibilityConfigs.add(visibilityConfig);
         }
         mVisibilityStore.setVisibility(visibilityConfigs);
 
         FrameworkCallerAccess callerAccessA =
-                new FrameworkCallerAccess(new AppSearchAttributionSource("A", 1,
-                        /* callingPid= */ 1),
-                        /*callerHasSystemAccess=*/ false, /*isForEnterprise=*/ false);
+                new FrameworkCallerAccess(
+                        new AppSearchAttributionSource("A", 1, /* callingPid= */ 1),
+                        /* callerHasSystemAccess= */ false,
+                        /* isForEnterprise= */ false);
         FrameworkCallerAccess callerAccessB =
-                new FrameworkCallerAccess(new AppSearchAttributionSource("B", 2,
-                        /* callingPid= */ 2),
-                        /*callerHasSystemAccess=*/ false, /*isForEnterprise=*/ false);
-
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                callerAccessA, "android", "android$database/SchemaB", mVisibilityStore)).isFalse();
-        assertThat(mVisibilityChecker.isSchemaSearchableByCaller(
-                callerAccessB, "android", "android$database/SchemaA", mVisibilityStore)).isFalse();
+                new FrameworkCallerAccess(
+                        new AppSearchAttributionSource("B", 2, /* callingPid= */ 2),
+                        /* callerHasSystemAccess= */ false,
+                        /* isForEnterprise= */ false);
+
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                callerAccessA,
+                                "android",
+                                "android$database/SchemaB",
+                                mVisibilityStore))
+                .isFalse();
+        assertThat(
+                        mVisibilityChecker.isSchemaSearchableByCaller(
+                                callerAccessB,
+                                "android",
+                                "android$database/SchemaA",
+                                mVisibilityStore))
+                .isFalse();
     }
 
     @NonNull
```

