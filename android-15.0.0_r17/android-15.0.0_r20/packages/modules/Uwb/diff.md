```diff
diff --git a/TEST_MAPPING b/TEST_MAPPING
index 7e469b93..6e94e998 100644
--- a/TEST_MAPPING
+++ b/TEST_MAPPING
@@ -19,6 +19,9 @@
   "postsubmit": [
     {
       "name": "UwbFusionLibTests"
+    },
+    {
+      "name": "CtsRangingTestCases"
     }
   ]
 }
diff --git a/androidx_backend/Android.bp b/androidx_backend/Android.bp
index 638a25bb..2129fb57 100644
--- a/androidx_backend/Android.bp
+++ b/androidx_backend/Android.bp
@@ -44,6 +44,10 @@ aidl_interface {
             version: "2",
             imports: [],
         },
+        {
+            version: "3",
+            imports: [],
+        },
 
     ],
     frozen: true,
@@ -62,7 +66,7 @@ java_library {
     static_libs: [
         "androidx.annotation_annotation",
         "androidx.concurrent_concurrent-futures",
-        "androidx.core.uwb.backend.aidl_interface-V2-java",
+        "androidx.core.uwb.backend.aidl_interface-V3-java",
         "com.uwb.support.fira",
         "com.uwb.support.multichip",
         "com.uwb.support.dltdoa",
@@ -93,7 +97,7 @@ android_app {
     static_libs: [
         "androidx.annotation_annotation",
         "androidx.concurrent_concurrent-futures",
-        "androidx.core.uwb.backend.aidl_interface-V2-java",
+        "androidx.core.uwb.backend.aidl_interface-V3-java",
         "com.uwb.support.fira",
         "guava",
         "uwb_androidx_backend",
diff --git a/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/.hash b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/.hash
new file mode 100644
index 00000000..cf558ab1
--- /dev/null
+++ b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/.hash
@@ -0,0 +1 @@
+785e4a6107410003aaf8c045c9fcf5b82fe363c6
diff --git a/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/IRangingSessionCallback.aidl b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/IRangingSessionCallback.aidl
new file mode 100644
index 00000000..86629bcd
--- /dev/null
+++ b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/IRangingSessionCallback.aidl
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package androidx.core.uwb.backend;
+interface IRangingSessionCallback {
+  oneway void onRangingInitialized(in androidx.core.uwb.backend.UwbDevice device);
+  oneway void onRangingResult(in androidx.core.uwb.backend.UwbDevice device, in androidx.core.uwb.backend.RangingPosition position);
+  oneway void onRangingSuspended(in androidx.core.uwb.backend.UwbDevice device, int reason);
+  const int UNKNOWN = 0;
+  const int WRONG_PARAMETERS = 1;
+  const int FAILED_TO_START = 2;
+  const int STOPPED_BY_PEER = 3;
+  const int STOP_RANGING_CALLED = 4;
+  const int MAX_RANGING_ROUND_RETRY_REACHED = 5;
+}
diff --git a/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/IUwb.aidl b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/IUwb.aidl
new file mode 100644
index 00000000..d1334cfd
--- /dev/null
+++ b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/IUwb.aidl
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package androidx.core.uwb.backend;
+interface IUwb {
+  androidx.core.uwb.backend.IUwbClient getControleeClient();
+  androidx.core.uwb.backend.IUwbClient getControllerClient();
+}
diff --git a/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/IUwbAvailabilityObserver.aidl b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/IUwbAvailabilityObserver.aidl
new file mode 100644
index 00000000..60b7bc8d
--- /dev/null
+++ b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/IUwbAvailabilityObserver.aidl
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package androidx.core.uwb.backend;
+interface IUwbAvailabilityObserver {
+  void onUwbStateChanged(boolean isAvailable, int reason);
+}
diff --git a/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/IUwbClient.aidl b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/IUwbClient.aidl
new file mode 100644
index 00000000..e395a28f
--- /dev/null
+++ b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/IUwbClient.aidl
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package androidx.core.uwb.backend;
+interface IUwbClient {
+  boolean isAvailable();
+  androidx.core.uwb.backend.RangingCapabilities getRangingCapabilities();
+  androidx.core.uwb.backend.UwbAddress getLocalAddress();
+  androidx.core.uwb.backend.UwbComplexChannel getComplexChannel();
+  void startRanging(in androidx.core.uwb.backend.RangingParameters parameters, in androidx.core.uwb.backend.IRangingSessionCallback callback);
+  void stopRanging(in androidx.core.uwb.backend.IRangingSessionCallback callback);
+  void addControlee(in androidx.core.uwb.backend.UwbAddress address);
+  void addControleeWithSessionParams(in androidx.core.uwb.backend.RangingControleeParameters params);
+  void removeControlee(in androidx.core.uwb.backend.UwbAddress address);
+  void reconfigureRangingInterval(in int intervalSkipCount);
+  void reconfigureRangeDataNtf(in int configType, in int proximityNearCm, in int proximityFarCm);
+  void subscribeToAvailability(in androidx.core.uwb.backend.IUwbAvailabilityObserver observer);
+  void unsubscribeFromAvailability();
+}
diff --git a/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/RangingCapabilities.aidl b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/RangingCapabilities.aidl
new file mode 100644
index 00000000..5762da88
--- /dev/null
+++ b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/RangingCapabilities.aidl
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package androidx.core.uwb.backend;
+parcelable RangingCapabilities {
+  boolean supportsDistance;
+  boolean supportsAzimuthalAngle;
+  boolean supportsElevationAngle;
+  int minRangingInterval;
+  int[] supportedChannels;
+  int[] supportedNtfConfigs;
+  int[] supportedConfigIds;
+  @nullable int[] supportedSlotDurations;
+  @nullable int[] supportedRangingUpdateRates;
+  boolean supportsRangingIntervalReconfigure;
+  boolean hasBackgroundRangingSupport;
+}
diff --git a/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/RangingControleeParameters.aidl b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/RangingControleeParameters.aidl
new file mode 100644
index 00000000..0e6e9a72
--- /dev/null
+++ b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/RangingControleeParameters.aidl
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package androidx.core.uwb.backend;
+parcelable RangingControleeParameters {
+  androidx.core.uwb.backend.UwbAddress address;
+  int subSessionId;
+  byte[] subSessionKey;
+}
diff --git a/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/RangingMeasurement.aidl b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/RangingMeasurement.aidl
new file mode 100644
index 00000000..4c842505
--- /dev/null
+++ b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/RangingMeasurement.aidl
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package androidx.core.uwb.backend;
+parcelable RangingMeasurement {
+  int confidence;
+  float value;
+}
diff --git a/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/RangingParameters.aidl b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/RangingParameters.aidl
new file mode 100644
index 00000000..eef5efe8
--- /dev/null
+++ b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/RangingParameters.aidl
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package androidx.core.uwb.backend;
+parcelable RangingParameters {
+  int uwbConfigId;
+  int sessionId;
+  int subSessionId;
+  byte[] sessionKeyInfo;
+  byte[] subSessionKeyInfo;
+  androidx.core.uwb.backend.UwbComplexChannel complexChannel;
+  List<androidx.core.uwb.backend.UwbDevice> peerDevices;
+  int rangingUpdateRate;
+  @nullable androidx.core.uwb.backend.UwbRangeDataNtfConfig uwbRangeDataNtfConfig;
+  int slotDuration;
+  boolean isAoaDisabled;
+}
diff --git a/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/RangingPosition.aidl b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/RangingPosition.aidl
new file mode 100644
index 00000000..6a1d8bd7
--- /dev/null
+++ b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/RangingPosition.aidl
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package androidx.core.uwb.backend;
+parcelable RangingPosition {
+  androidx.core.uwb.backend.RangingMeasurement distance;
+  androidx.core.uwb.backend.RangingMeasurement azimuth;
+  androidx.core.uwb.backend.RangingMeasurement elevation;
+  long elapsedRealtimeNanos;
+}
diff --git a/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/UwbAddress.aidl b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/UwbAddress.aidl
new file mode 100644
index 00000000..bf4e6e30
--- /dev/null
+++ b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/UwbAddress.aidl
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package androidx.core.uwb.backend;
+parcelable UwbAddress {
+  byte[] address;
+}
diff --git a/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/UwbComplexChannel.aidl b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/UwbComplexChannel.aidl
new file mode 100644
index 00000000..99316af5
--- /dev/null
+++ b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/UwbComplexChannel.aidl
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package androidx.core.uwb.backend;
+parcelable UwbComplexChannel {
+  int channel;
+  int preambleIndex;
+}
diff --git a/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/UwbDevice.aidl b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/UwbDevice.aidl
new file mode 100644
index 00000000..1493f13e
--- /dev/null
+++ b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/UwbDevice.aidl
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package androidx.core.uwb.backend;
+parcelable UwbDevice {
+  androidx.core.uwb.backend.UwbAddress address;
+}
diff --git a/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/UwbRangeDataNtfConfig.aidl b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/UwbRangeDataNtfConfig.aidl
new file mode 100644
index 00000000..81df4226
--- /dev/null
+++ b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/3/androidx/core/uwb/backend/UwbRangeDataNtfConfig.aidl
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package androidx.core.uwb.backend;
+parcelable UwbRangeDataNtfConfig {
+  int rangeDataNtfConfigType;
+  int ntfProximityNearCm;
+  int ntfProximityFarCm;
+}
diff --git a/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/current/androidx/core/uwb/backend/IUwbAvailabilityObserver.aidl b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/current/androidx/core/uwb/backend/IUwbAvailabilityObserver.aidl
new file mode 100644
index 00000000..60b7bc8d
--- /dev/null
+++ b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/current/androidx/core/uwb/backend/IUwbAvailabilityObserver.aidl
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+///////////////////////////////////////////////////////////////////////////////
+// THIS FILE IS IMMUTABLE. DO NOT EDIT IN ANY CASE.                          //
+///////////////////////////////////////////////////////////////////////////////
+
+// This file is a snapshot of an AIDL file. Do not edit it manually. There are
+// two cases:
+// 1). this is a frozen version file - do not edit this in any case.
+// 2). this is a 'current' file. If you make a backwards compatible change to
+//     the interface (from the latest frozen version), the build system will
+//     prompt you to update this file with `m <name>-update-api`.
+//
+// You must not make a backward incompatible change to any AIDL file built
+// with the aidl_interface module type with versions property set. The module
+// type is used to build AIDL files in a way that they can be used across
+// independently updatable components of the system. If a device is shipped
+// with such a backward incompatible change, it has a high risk of breaking
+// later when a module using the interface is updated, e.g., Mainline modules.
+
+package androidx.core.uwb.backend;
+interface IUwbAvailabilityObserver {
+  void onUwbStateChanged(boolean isAvailable, int reason);
+}
diff --git a/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/current/androidx/core/uwb/backend/IUwbClient.aidl b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/current/androidx/core/uwb/backend/IUwbClient.aidl
index cbdda626..e395a28f 100644
--- a/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/current/androidx/core/uwb/backend/IUwbClient.aidl
+++ b/androidx_backend/aidl_api/androidx.core.uwb.backend.aidl_interface/current/androidx/core/uwb/backend/IUwbClient.aidl
@@ -44,4 +44,6 @@ interface IUwbClient {
   void removeControlee(in androidx.core.uwb.backend.UwbAddress address);
   void reconfigureRangingInterval(in int intervalSkipCount);
   void reconfigureRangeDataNtf(in int configType, in int proximityNearCm, in int proximityFarCm);
+  void subscribeToAvailability(in androidx.core.uwb.backend.IUwbAvailabilityObserver observer);
+  void unsubscribeFromAvailability();
 }
diff --git a/generic_ranging/src/com/android/sensor/MultiSensorFinderListener.java b/androidx_backend/interface/androidx/core/uwb/backend/IUwbAvailabilityObserver.aidl
similarity index 74%
rename from generic_ranging/src/com/android/sensor/MultiSensorFinderListener.java
rename to androidx_backend/interface/androidx/core/uwb/backend/IUwbAvailabilityObserver.aidl
index 505eb51d..c1333a92 100644
--- a/generic_ranging/src/com/android/sensor/MultiSensorFinderListener.java
+++ b/androidx_backend/interface/androidx/core/uwb/backend/IUwbAvailabilityObserver.aidl
@@ -13,10 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+package androidx.core.uwb.backend;
 
-package com.android.sensor;
-
-/** Listener interface to receive Estimates computed by MultiSensorFinderInterface classes. */
-public interface MultiSensorFinderListener {
-    void onUpdatedEstimate(Estimate estimate);
-}
+/** Gms Reference: com.google.android.gms.nearby.uwb.UwbAvailabilityObserver */
+interface IUwbAvailabilityObserver {
+    void onUwbStateChanged(boolean isAvailable, int reason);
+}
\ No newline at end of file
diff --git a/androidx_backend/interface/androidx/core/uwb/backend/IUwbClient.aidl b/androidx_backend/interface/androidx/core/uwb/backend/IUwbClient.aidl
index b71c163a..4f6b3a27 100644
--- a/androidx_backend/interface/androidx/core/uwb/backend/IUwbClient.aidl
+++ b/androidx_backend/interface/androidx/core/uwb/backend/IUwbClient.aidl
@@ -17,6 +17,7 @@
 package androidx.core.uwb.backend;
 
 import androidx.core.uwb.backend.IRangingSessionCallback;
+import androidx.core.uwb.backend.IUwbAvailabilityObserver;
 import androidx.core.uwb.backend.RangingCapabilities;
 import androidx.core.uwb.backend.RangingControleeParameters;
 import androidx.core.uwb.backend.RangingParameters;
@@ -36,4 +37,6 @@ interface IUwbClient {
     void removeControlee(in UwbAddress address);
     void reconfigureRangingInterval(in int intervalSkipCount);
     void reconfigureRangeDataNtf(in int configType, in int proximityNearCm, in int proximityFarCm);
+    void subscribeToAvailability(in IUwbAvailabilityObserver observer);
+    void unsubscribeFromAvailability();
 }
diff --git a/androidx_backend/src/androidx/core/uwb/backend/impl/UwbClient.java b/androidx_backend/src/androidx/core/uwb/backend/impl/UwbClient.java
index 23c9b8f9..f100f4cd 100644
--- a/androidx_backend/src/androidx/core/uwb/backend/impl/UwbClient.java
+++ b/androidx_backend/src/androidx/core/uwb/backend/impl/UwbClient.java
@@ -24,6 +24,7 @@ import android.os.RemoteException;
 import android.util.Log;
 
 import androidx.core.uwb.backend.IRangingSessionCallback;
+import androidx.core.uwb.backend.IUwbAvailabilityObserver;
 import androidx.core.uwb.backend.IUwbClient;
 import androidx.core.uwb.backend.RangingCapabilities;
 import androidx.core.uwb.backend.RangingMeasurement;
@@ -38,12 +39,16 @@ import androidx.core.uwb.backend.impl.internal.UwbServiceImpl;
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.function.Consumer;
 
 /** Implements operations of IUwbClient. */
 public abstract class UwbClient extends IUwbClient.Stub {
     protected final UwbServiceImpl mUwbService;
     protected final RangingDevice mDevice;
     protected boolean mSupportsAzimuthalAngle = true;
+    protected Consumer<IUwbAvailabilityObserver> mSubscribeConsumer = null;
+    protected Consumer<IUwbAvailabilityObserver> mUnsubscribeConsumer = null;
+    protected IUwbAvailabilityObserver mObserver = null;
 
     protected UwbClient(RangingDevice device, UwbServiceImpl uwbService) {
         mDevice = device;
@@ -116,6 +121,14 @@ public abstract class UwbClient extends IUwbClient.Stub {
                         !mSupportsAzimuthalAngle || parameters.isAoaDisabled));
     }
 
+    public void setSubscribeConsumer(Consumer<IUwbAvailabilityObserver> subscribeConsumer) {
+        mSubscribeConsumer = subscribeConsumer;
+    }
+
+    public void setUnsubscribeConsumer(Consumer<IUwbAvailabilityObserver> unsbuscribeConsumer) {
+        mUnsubscribeConsumer = unsbuscribeConsumer;
+    }
+
     protected androidx.core.uwb.backend.impl.internal.RangingSessionCallback convertCallback(
             IRangingSessionCallback callback) {
         return new RangingSessionCallback() {
@@ -176,6 +189,17 @@ public abstract class UwbClient extends IUwbClient.Stub {
                     e.printStackTrace();
                 }
             }
+
+            @Override
+            public void onPeerDisconnected(UwbDevice peer, int reason) {
+                androidx.core.uwb.backend.UwbDevice backendPeer =
+                        new androidx.core.uwb.backend.UwbDevice();
+                backendPeer.address = new UwbAddress();
+                backendPeer.address.address = peer.getAddress().toBytes();
+                // TODO: implement in jetpack
+                // callback.onPeerDisconnected(backendPeer, reason);
+            }
+
         };
     }
 
@@ -193,4 +217,16 @@ public abstract class UwbClient extends IUwbClient.Stub {
                     "Reconfiguring range data notification config failed with status %d", status));
         }
     }
+
+    @Override
+    public void subscribeToAvailability(IUwbAvailabilityObserver observer) throws RemoteException {
+        mSubscribeConsumer.accept(observer);
+        mObserver = observer;
+    }
+
+    @Override
+    public void unsubscribeFromAvailability() throws RemoteException {
+        mUnsubscribeConsumer.accept(mObserver);
+        mObserver = null;
+    }
 }
diff --git a/androidx_backend/src/androidx/core/uwb/backend/impl/UwbService.java b/androidx_backend/src/androidx/core/uwb/backend/impl/UwbService.java
index 8e90b02e..7618506a 100644
--- a/androidx_backend/src/androidx/core/uwb/backend/impl/UwbService.java
+++ b/androidx_backend/src/androidx/core/uwb/backend/impl/UwbService.java
@@ -19,18 +19,27 @@ import android.app.Service;
 import android.content.Intent;
 import android.os.Build;
 import android.os.IBinder;
+import android.os.RemoteException;
 import android.util.Log;
 
 import androidx.core.uwb.backend.IUwb;
+import androidx.core.uwb.backend.IUwbAvailabilityObserver;
 import androidx.core.uwb.backend.IUwbClient;
 import androidx.core.uwb.backend.impl.internal.UwbAvailabilityCallback;
 import androidx.core.uwb.backend.impl.internal.UwbFeatureFlags;
 import androidx.core.uwb.backend.impl.internal.UwbServiceImpl;
 
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Consumer;
+
 /** Uwb service entry point of the backend. */
 public class UwbService extends Service {
 
     private UwbServiceImpl mUwbServiceImpl;
+    private static final String TAG = "UwbService";
+
+    private List<IUwbAvailabilityObserver> mUwbAvailabilityObservers = new ArrayList<>();
     @Override
     public void onCreate() {
         super.onCreate();
@@ -40,7 +49,15 @@ public class UwbService extends Service {
                         Build.VERSION.SDK_INT <= Build.VERSION_CODES.TIRAMISU)
                 .build();
         UwbAvailabilityCallback uwbAvailabilityCallback = (isUwbAvailable, reason) -> {
-            // TODO: Implement when adding backend support.
+            for (IUwbAvailabilityObserver observer : mUwbAvailabilityObservers) {
+                if (observer != null) {
+                    try {
+                        observer.onUwbStateChanged(isUwbAvailable, reason);
+                    } catch (RemoteException e) {
+                        Log.e(TAG, "Availability observer error");
+                    }
+                }
+            }
         };
         mUwbServiceImpl = new UwbServiceImpl(this, uwbFeatureFlags, uwbAvailabilityCallback);
     }
@@ -61,7 +78,7 @@ public class UwbService extends Service {
             new IUwb.Stub() {
                 @Override
                 public IUwbClient getControleeClient() {
-                    Log.i("UwbService", "Getting controleeClient");
+                    Log.i(TAG, "Getting controleeClient");
                     return new UwbControleeClient(mUwbServiceImpl
                             .getControlee(UwbService.this.getApplicationContext()),
                             mUwbServiceImpl);
@@ -69,10 +86,25 @@ public class UwbService extends Service {
 
                 @Override
                 public IUwbClient getControllerClient() {
-                    Log.i("UwbService", "Getting controllerClient");
-                    return new UwbControllerClient(mUwbServiceImpl
+                    Log.i(TAG, "Getting controllerClient");
+                    Consumer<IUwbAvailabilityObserver> subscribeConsumer =
+                            (observer) -> {
+                                mUwbAvailabilityObservers.add(observer);
+                                try {
+                                    observer.onUwbStateChanged(mUwbServiceImpl.isAvailable(),
+                                            mUwbServiceImpl.getLastStateChangeReason());
+                                } catch (RemoteException e) {
+                                    throw new RuntimeException(e);
+                                }
+                            };
+                    Consumer<IUwbAvailabilityObserver> unsubscribeConsumer =
+                            (observer) -> mUwbAvailabilityObservers.remove(observer);
+                    UwbControllerClient client = new UwbControllerClient(mUwbServiceImpl
                             .getController(UwbService.this.getApplicationContext()),
                             mUwbServiceImpl);
+                    client.setSubscribeConsumer(subscribeConsumer);
+                    client.setUnsubscribeConsumer(unsubscribeConsumer);
+                    return client;
                 }
 
                 @Override
diff --git a/androidx_backend/src/androidx/core/uwb/backend/impl/internal/Conversions.java b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/Conversions.java
index 936fe58b..fce927f3 100644
--- a/androidx_backend/src/androidx/core/uwb/backend/impl/internal/Conversions.java
+++ b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/Conversions.java
@@ -29,6 +29,8 @@ import android.uwb.RangingSession;
 import androidx.annotation.Nullable;
 import androidx.annotation.RequiresApi;
 
+import com.google.uwb.support.fira.FiraOnControleeAddRemoveParams;
+
 import java.util.ArrayList;
 import java.util.List;
 
@@ -144,7 +146,7 @@ final class Conversions {
     }
 
     @RangingSessionCallback.RangingSuspendedReason
-    static int convertReason(int reason) {
+    static int toRangingSuspendedReason(int reason) {
         if (reason == RangingSession.Callback.REASON_BAD_PARAMETERS) {
             return RangingSessionCallback.REASON_WRONG_PARAMETERS;
         }
@@ -172,6 +174,16 @@ final class Conversions {
         return RangingSessionCallback.REASON_UNKNOWN;
     }
 
+    @RangingSessionCallback.PeerDisconnectedReason
+    static int toPeerDisconnectedReason(@FiraOnControleeAddRemoveParams.Reason int reason) {
+        switch (reason) {
+            case FiraOnControleeAddRemoveParams.Reason.LOST_CONNECTION:
+                return RangingSessionCallback.PeerDisconnectedReason.SYSTEM_POLICY;
+            default:
+                return RangingSessionCallback.PeerDisconnectedReason.UNKNOWN;
+        }
+    }
+
     @UwbAvailabilityCallback.UwbStateChangeReason
     static int convertAdapterStateReason(int reason) {
         return switch (reason) {
diff --git a/androidx_backend/src/androidx/core/uwb/backend/impl/internal/RangingController.java b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/RangingController.java
index 609c0307..19ca3e50 100644
--- a/androidx_backend/src/androidx/core/uwb/backend/impl/internal/RangingController.java
+++ b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/RangingController.java
@@ -360,6 +360,11 @@ public class RangingController extends RangingDevice {
                         .toBundle());
     }
 
+    @Override
+    public synchronized void handlePeerDisconnected(UwbDevice peer) {
+        mDynamicallyAddedPeers.remove(peer.getAddress());
+    }
+
     /**
      * Reconfigures ranging interval for an ongoing session
      *
diff --git a/androidx_backend/src/androidx/core/uwb/backend/impl/internal/RangingDevice.java b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/RangingDevice.java
index 825a0ad2..a336bd17 100644
--- a/androidx_backend/src/androidx/core/uwb/backend/impl/internal/RangingDevice.java
+++ b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/RangingDevice.java
@@ -30,6 +30,7 @@ import static com.google.uwb.support.fira.FiraParams.RANGING_DEVICE_DT_TAG;
 
 import static java.util.Objects.requireNonNull;
 
+import android.annotation.SuppressLint;
 import android.os.Build.VERSION;
 import android.os.Build.VERSION_CODES;
 import android.os.PersistableBundle;
@@ -45,6 +46,7 @@ import androidx.annotation.WorkerThread;
 
 import com.google.common.hash.Hashing;
 import com.google.uwb.support.dltdoa.DlTDoARangingRoundsUpdate;
+import com.google.uwb.support.fira.FiraOnControleeAddRemoveParams;
 import com.google.uwb.support.fira.FiraOpenSessionParams;
 import com.google.uwb.support.multichip.ChipInfoParams;
 
@@ -56,6 +58,7 @@ import java.util.concurrent.ExecutorService;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 /** Implements start/stop ranging operations. */
+@SuppressLint("NewApi")
 public abstract class RangingDevice {
 
     public static final int SESSION_ID_UNSET = 0;
@@ -295,7 +298,7 @@ public abstract class RangingDevice {
             @Override
             public void onOpenFailed(int reason, PersistableBundle params) {
                 Log.i(TAG, String.format("Session open failed: reason %s", reason));
-                int suspendedReason = Conversions.convertReason(reason);
+                int suspendedReason = Conversions.toRangingSuspendedReason(reason);
                 if (suspendedReason == REASON_UNKNOWN) {
                     suspendedReason = REASON_FAILED_TO_START;
                 }
@@ -318,7 +321,7 @@ public abstract class RangingDevice {
             @Override
             public void onStartFailed(int reason, PersistableBundle params) {
 
-                int suspendedReason = Conversions.convertReason(reason);
+                int suspendedReason = Conversions.toRangingSuspendedReason(reason);
                 if (suspendedReason != REASON_WRONG_PARAMETERS) {
                     suspendedReason = REASON_FAILED_TO_START;
                 }
@@ -347,7 +350,7 @@ public abstract class RangingDevice {
             @WorkerThread
             @Override
             public void onStopped(int reason, PersistableBundle params) {
-                int suspendedReason = Conversions.convertReason(reason);
+                int suspendedReason = Conversions.toRangingSuspendedReason(reason);
                 UwbDevice device = getUwbDevice();
                 runOnBackendCallbackThread(
                         () -> {
@@ -412,9 +415,24 @@ public abstract class RangingDevice {
             @WorkerThread
             @Override
             public void onControleeRemoved(PersistableBundle params) {
-                if (mOpAsyncCallbackRunner.isActive()) {
-                    mOpAsyncCallbackRunner.complete(true);
-                }
+                FiraOnControleeAddRemoveParams removalParams =
+                        FiraOnControleeAddRemoveParams.fromBundle(params);
+
+                runOnBackendCallbackThread(
+                        () -> {
+                            byte[] removedAddress = removalParams.getAddress().toBytes();
+                            UwbDevice removedDevice =
+                                    UwbDevice.createForAddress(
+                                            mUwbFeatureFlags.isReversedByteOrderFiraParams()
+                                                    ? Conversions.getReverseBytes(removedAddress)
+                                                    : removedAddress);
+
+                            handlePeerDisconnected(removedDevice);
+                            callback.onPeerDisconnected(
+                                    removedDevice, Conversions.toPeerDisconnectedReason(
+                                            removalParams.getReason()));
+                        });
+                mOpAsyncCallbackRunner.completeIfActive(true);
             }
 
             @WorkerThread
@@ -600,6 +618,13 @@ public abstract class RangingDevice {
         return success && result != null && result;
     }
 
+    /**
+     * Called when a peer is disconnected from the ranging session.
+     *
+     * @param peer the peer that disconnected.
+     */
+    protected synchronized void handlePeerDisconnected(UwbDevice peer) {
+    }
 
     /**
      * Reconfigures range data notification for an ongoing session.
diff --git a/androidx_backend/src/androidx/core/uwb/backend/impl/internal/RangingSessionCallback.java b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/RangingSessionCallback.java
index 2b1219bb..146be06a 100644
--- a/androidx_backend/src/androidx/core/uwb/backend/impl/internal/RangingSessionCallback.java
+++ b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/RangingSessionCallback.java
@@ -30,6 +30,9 @@ public interface RangingSessionCallback {
     /** Callback when a session has been suspended. */
     void onRangingSuspended(UwbDevice device, @RangingSuspendedReason int reason);
 
+    /** Callback when a peer disconnects from the session. */
+    void onPeerDisconnected(UwbDevice peer, @PeerDisconnectedReason int reason);
+
     /** Reason why ranging was stopped. */
     @IntDef({
             REASON_UNKNOWN,
@@ -50,4 +53,14 @@ public interface RangingSessionCallback {
     int REASON_STOP_RANGING_CALLED = 4;
     int REASON_MAX_RANGING_ROUND_RETRY_REACHED = 5;
     int REASON_SYSTEM_POLICY = 6;
+
+    /** Reason why peer disconnected. */
+    @IntDef({
+            PeerDisconnectedReason.UNKNOWN,
+            PeerDisconnectedReason.SYSTEM_POLICY,
+    })
+    @interface PeerDisconnectedReason {
+        int UNKNOWN = 0;
+        int SYSTEM_POLICY = 1;
+    }
 }
diff --git a/androidx_backend/src/androidx/core/uwb/backend/impl/internal/UwbServiceImpl.java b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/UwbServiceImpl.java
index 6cc563a3..7d10080c 100644
--- a/androidx_backend/src/androidx/core/uwb/backend/impl/internal/UwbServiceImpl.java
+++ b/androidx_backend/src/androidx/core/uwb/backend/impl/internal/UwbServiceImpl.java
@@ -33,6 +33,7 @@ import static androidx.core.uwb.backend.impl.internal.UwbAvailabilityCallback.RE
 
 import static java.util.Objects.requireNonNull;
 
+import android.annotation.SuppressLint;
 import android.content.Context;
 import android.os.Build.VERSION;
 import android.os.Build.VERSION_CODES;
@@ -164,12 +165,17 @@ public class UwbServiceImpl {
     }
 
     /** Gets ranging capabilities of the device. */
+    @SuppressLint("NewApi")
     public RangingCapabilities getRangingCapabilities() {
         requireNonNull(mUwbManager);
         requireNonNull(mUwbFeatureFlags);
 
-        if (mUwbFeatureFlags.skipRangingCapabilitiesCheck()
-                && VERSION.SDK_INT < VERSION_CODES.TIRAMISU) {
+        PersistableBundle bundle = new PersistableBundle();
+        if (!mUwbFeatureFlags.skipRangingCapabilitiesCheck()
+                || VERSION.SDK_INT >= VERSION_CODES.TIRAMISU) {
+            bundle = mUwbManager.getSpecificationInfo();
+        }
+        if (bundle.isEmpty()) {
             return new RangingCapabilities(
                     /* supportsDistance= */ true,
                     mUwbFeatureFlags.hasAzimuthSupport(),
@@ -184,7 +190,6 @@ public class UwbServiceImpl {
                     /* hasBackgroundRangingSupport */ false);
         }
 
-        PersistableBundle bundle = mUwbManager.getSpecificationInfo();
         if (bundle.keySet().contains(FIRA_SPECIFICATION_BUNDLE_KEY)) {
             bundle = requireNonNull(bundle.getPersistableBundle(FIRA_SPECIFICATION_BUNDLE_KEY));
         }
diff --git a/flags/Android.bp b/flags/Android.bp
index 0885283a..1950612c 100644
--- a/flags/Android.bp
+++ b/flags/Android.bp
@@ -29,6 +29,7 @@ aconfig_declarations {
 java_aconfig_library {
     name: "uwb_aconfig_flags_lib",
     aconfig_declarations: "uwb_aconfig_flags",
+    defaults: ["framework-minus-apex-aconfig-java-defaults"],
     min_sdk_version: "33",
     apex_available: [
         "com.android.uwb",
diff --git a/framework/Android.bp b/framework/Android.bp
index ef74192b..9818995b 100644
--- a/framework/Android.bp
+++ b/framework/Android.bp
@@ -57,6 +57,7 @@ java_defaults {
     static_libs: [
         "modules-utils-preconditions",
         "modules-utils-build",
+        "uwb_aconfig_flags_lib",
     ],
     libs: [
         "androidx.annotation_annotation",
diff --git a/framework/jarjar-rules.txt b/framework/jarjar-rules.txt
index 1d0aa5bf..51ae0a74 100644
--- a/framework/jarjar-rules.txt
+++ b/framework/jarjar-rules.txt
@@ -16,5 +16,7 @@ rule com.google.protobuf.** com.android.x.uwb.@0
 rule org.bouncycastle.** com.android.x.uwb.@0
 # Statically linked third party library
 rule com.google.thirdparty.** com.android.x.uwb.@0
+# Statically included ranging flags.
+rule com.android.uwb.flags.** com.android.x.uwb.@0
 
 ## used by both framework-uwb and service-uwb ##
diff --git a/framework/java/android/uwb/IUwbAdapter.aidl b/framework/java/android/uwb/IUwbAdapter.aidl
index 4344ee09..0716876b 100644
--- a/framework/java/android/uwb/IUwbAdapter.aidl
+++ b/framework/java/android/uwb/IUwbAdapter.aidl
@@ -443,4 +443,9 @@ interface IUwbAdapter {
    * The maximum allowed time to configure hybrid session
    */
   const int SESSION_CONFIGURATION_THRESHOLD_MS = 3000; // Value TBD
+
+  /**
+   * The maximum allowed time for RF test
+   */
+  const int RF_TEST_OPERATION_THRESHOLD_MS = 3000; // Value TBD
 }
diff --git a/framework/java/android/uwb/UwbOemExtensionCallbackListener.java b/framework/java/android/uwb/UwbOemExtensionCallbackListener.java
index 9da7492b..1160f916 100644
--- a/framework/java/android/uwb/UwbOemExtensionCallbackListener.java
+++ b/framework/java/android/uwb/UwbOemExtensionCallbackListener.java
@@ -110,17 +110,20 @@ public final class UwbOemExtensionCallbackListener extends IUwbOemExtensionCallb
             if (mCallback == null || mExecutor == null) {
                 return;
             }
+            UwbManager.UwbOemExtensionCallback callback;
+            Executor executor;
             final long identity = Binder.clearCallingIdentity();
             try {
+                callback = mCallback;
+                executor = mExecutor;
                 if (SdkLevel.isAtLeastU()) {
-                    mExecutor.execute(() ->
-                            mCallback.onDeviceStatusNotificationReceived(deviceStateBundle));
+                    executor.execute(() ->
+                           callback.onDeviceStatusNotificationReceived(deviceStateBundle));
                 }
             } finally {
                 Binder.restoreCallingIdentity(identity);
             }
         }
-
     }
 
     @Override
diff --git a/generic_ranging/proto/Android.bp b/generic_ranging/proto/Android.bp
deleted file mode 100644
index 2d475e85..00000000
--- a/generic_ranging/proto/Android.bp
+++ /dev/null
@@ -1,32 +0,0 @@
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package {
-    default_team: "trendy_team_fwk_uwb",
-    default_applicable_licenses: ["Android-Apache-2.0"],
-}
-
-filegroup {
-    name: "multi-sensor-proto",
-    srcs: [
-        "src/*.proto",
-    ],
-}
-
-java_library {
-    name: "multi-sensor-finder-configuration-java-proto",
-    proto: {
-        type: "lite",
-    },
-    sdk_version: "system_current",
-    min_sdk_version: "34",
-    srcs: ["src/**/*.proto"],
-    apex_available: [
-        "com.android.uwb",
-    ],
-}
diff --git a/generic_ranging/proto/src/debug_log.proto b/generic_ranging/proto/src/debug_log.proto
deleted file mode 100644
index 0bf3a6a2..00000000
--- a/generic_ranging/proto/src/debug_log.proto
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-syntax = "proto3";
-
-package com.android.ranging.proto;
-
-import "packages/modules/Uwb/generic_ranging/proto/src/estimate.proto";
-
-option java_package = "com.android.ranging.proto";
-option java_multiple_files = true;
-
-message Event {
-  enum Type {
-    NONE = 0;
-    START = 1;
-    STOP = 2;
-  }
-
-  Type type = 1;
-  float timestamp_sec = 2;
-}
-
-message UwbDatum {
-  float range_m = 1;
-  int32 rssi_dbm = 2;
-  float timestamp_sec = 3;
-}
-
-message OdometryDatum {
-  float x_m = 1;
-  float y_m = 2;
-  float z_m = 3;
-  float timestamp_sec = 8;
-}
-
-message InputContainer {
-  oneof input {
-    UwbDatum uwb_datum = 1;
-    OdometryDatum odometry_datum = 3;
-  }
-}
-
-message LeanEstimate {
-  com.android.ranging.proto.Estimate.Status status = 1;
-  float range_m = 2;
-  float bearing_rad = 3;
-  float estimated_beacon_position_error_std_dev_m = 4;
-  float timestamp_sec = 5;
-}
-
-message DebugLog {
-  repeated InputContainer inputs = 1;
-  repeated LeanEstimate outputs = 2;
-  repeated Event events = 3;
-}
\ No newline at end of file
diff --git a/generic_ranging/proto/src/estimate.proto b/generic_ranging/proto/src/estimate.proto
deleted file mode 100644
index 67a863a0..00000000
--- a/generic_ranging/proto/src/estimate.proto
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-syntax = "proto3";
-
-package com.android.ranging.proto;
-
-option java_package = "com.android.ranging.proto";
-option java_multiple_files = true;
-
- // Next ID: 14
- message Estimate {
-   enum Status {
-     UNSPECIFIED = 0;
-     // An estimate was successfully computed.
-     OK = 1;
-     // Could not produce an estimate. For example, no synchronized set of data
-     // is available.
-     ESTIMATE_NOT_AVAILABLE = 2;
-     // The filter has diverged and is attempting to recover.
-     RECOVERING = 3;
-     // Odometry failed and cannot recover.
-     ODOMETRY_ERROR = 4;
-     // The beacon is probably moving, and so cannot be tracked.
-     BEACON_MOVING_ERROR = 5;
-     // The configuration file contains an error and Finder can't be started.
-     CONFIGURATION_ERROR = 6;
-     // Permissions not granted to required sensors.
-     SENSOR_PERMISSION_DENIED = 7;
-     UNKNOWN_ERROR = 8;
-     // Tracking failed due to insufficient light. This can occur when using
-     // camera based odometry. The filter will automatically recover and produce
-     // an estimate when possible.
-     RECOVERING_FROM_FAILURE_DUE_TO_INSUFFICIENT_LIGHT = 9;
-     // Tracking failed due to excessive motion. The filter will automatically
-     // recover and produce an estimate when possible.
-     RECOVERING_FROM_FAILURE_DUE_TO_EXCESSIVE_MOTION = 10;
-     // Tracking failed due to insufficient features in the camera images. This
-     // can occur when using camera based odometry. The filter will automatically
-     // recover and produce an estimate when possible.
-     RECOVERING_FROM_FAILURE_DUE_TO_INSUFFICIENT_FEATURES = 11;
-     // Tracking failed because something else is using the camera. Tracking will
-     // recover automatically, but with a new origin.
-     RECOVERING_FROM_FAILURE_DUE_TO_CAMERA_UNAVAILABILITY = 12;
-     // Tracking failed due to a bad odometry state. The filter will
-     // automatically recover and produce an estimate when possible.
-     RECOVERING_FROM_FAILURE_DUE_TO_BAD_ODOMETRY_STATE = 13;
-   }
-   Status status = 1;
-   double range_m = 2;
-   double range_error_std_dev_m = 3;
-   // The bearing is with respect to the device Y-axis, positive ccw.
-   double bearing_rad = 4;
-   // This measure usually increases as you move closer to the beacon.
-   double bearing_error_std_dev_rad = 5;
-   // This measure does not vary with the distance to the beacon.
-   double estimated_beacon_position_error_std_dev_m = 7;
-   int64 timestamp_nanos = 6;
- }
diff --git a/generic_ranging/proto/src/multi_sensor_finder_configuration.proto b/generic_ranging/proto/src/multi_sensor_finder_configuration.proto
deleted file mode 100644
index 4a8e9be7..00000000
--- a/generic_ranging/proto/src/multi_sensor_finder_configuration.proto
+++ /dev/null
@@ -1,284 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-syntax = "proto3";
-
-package com.android.ranging.proto;
-
-option java_package = "com.android.ranging.proto";
-option java_multiple_files = true;
-
-enum ConfidenceLevel {
-CL_UNSPECIFIED = 0;
-CL_95 = 1;    // 95 %
-CL_97P5 = 2;  // 97.5 %
-CL_99 = 3;    // 99 %
-}
-
-// Configuration for MultiSensorFinder including the configuration of sub
-// components.
-message MultiSensorFinderConfig {
-// If unset, default values will be used.
-ParticleFilterConfig particle_filter_config = 1;
-
-// If enabled, the filter will use UWB measurements.
-bool use_uwb_measurements = 2;
-
-// If enabled, the filter will use Wi-Fi RTT measurements.
-bool use_wifi_rtt_measurements = 3;
-
-// If unset, default values will be used.
-RangeMeasurementConfig uwb_range_measurement_config = 4;
-
-// If unset, default values will be used.
-RangeMeasurementConfig wifi_rtt_range_measurement_config = 5;
-
-// If unset, default values will be used.
-FuzzyUpdateSchedulerConfig fuzzy_update_scheduler_configuration = 6;
-
-double default_xy_update_process_noise_stddev_m = 7;
-
-// If unset, default values will be used.
-OdometryNoiseAdderConfig odometry_noise_adder_config = 8;
-
-// If unset, trilateration measurement updater will not be used.
-TrilaterationMeasurementUpdaterConfig
-trilateration_measurement_updater_config = 9;
-
-// The rate at which finder will poll the odometry provider, which is also
-// the maximum rate at which finder will generate estimates.
-uint32 odometry_polling_rate_hz = 10;
-
-// If unset, odometry throttler will not be used.
-OdometryThrottlerConfig odometry_throttler_config = 11;
-
-// If unset, OBEP will not be used.
-OdometryBasedEstimatePropagatorConfig
-odometry_based_estimate_propagator_config = 12;
-
-// If unset, the NIS divergence detector will not be used.
-NisDivergenceDetectorConfig nis_divergence_detector_config = 13;
-
-InitialStateSamplerConfig uwb_initial_state_sampler_config = 14;
-
-InitialStateSamplerConfig wifi_rtt_initial_state_sampler_config = 15;
-
-// Used to input and output logs for development and debugging. If unset,
-// the debug logger will not be used.
-DebugLoggerConfiguration debug_logger_configuration = 16;
-}
-
-// Configuration for the generic sensor model, which is simply a combination of
-// a Gaussian and a Uniform distribution.
-message GenericRangeSensorModelConfig {
-double gaussian_std_dev_m = 1;
-double max_sensor_range_m = 2;
-}
-
-// Configuration for the trilateration measurement updater, which uses
-// trilateration on a set of UWB range measurements to determine if the incoming
-// range measurements are consistent over some spatial region.
-message TrilaterationMeasurementUpdaterConfig {
-int32 num_measurements_for_trilateration = 2;
-double max_trilateration_rmse_m = 3;
-}
-
-// Configuration for the sensor model associated with a range measurement and
-// any additional checks/modifiers. Currently, only the GenericRangeSensorModel
-// is supported.
-message RangeMeasurementConfig {
-// Currently supported models for a range sensor. If unspecified, the generic
-// model will be used.
-enum RangeSensorModelType {
-UNSPECIFIED = 0;
-// A generic model that consists of a Gaussian + Uniform distribution.
-// The configuration message associated with this model is
-// GenericRangeSensorModelConfig.
-GENERIC = 1;
-// Switches the measurement model based on the variance heuristic.
-VARIANCE_BASED_SWITCHING = 2;
-}
-RangeSensorModelType sensor_model_type = 1;
-GenericRangeSensorModelConfig generic_range_sensor_model_configuration = 2;
-VarianceBasedSwitchingMeasurementModelConfig
-variance_based_switching_measurement_model_config = 4;
-// If unset, the distance traveled check will not be used.
-DistanceTraveledCheckConfig distance_traveled_check_config = 3;
-}
-
-// Configuration for a scheduler which determines when a motion + measurement
-// update should be done.
-//
-// For each odometry sample, it creates a frame (or window) of +-
-// max_frame_size_nanos, and waits max_wait_time_nanos for all data to show up
-// in this frame.
-//
-// max_wait_time_nanos is directly proportional to the filter latency.
-// Increasing max_frame_size_nanos will increase the number of measurements
-// used, but can decrease accuracy because of a greater tolerance on the
-// mismatch in timestamps between odometry and range sensor data.
-message FuzzyUpdateSchedulerConfig {
-uint64 max_wait_time_nanos = 1;
-uint64 max_frame_size_nanos = 2;
-int32 max_buffer_size = 3;
-}
-
-// The distance traveled check blocks measurements from being continually
-// absorbed if a user stands still. It's a simple way to prevent particle
-// depletion.
-message DistanceTraveledCheckConfig {
-double distance_traveled_threshold_m = 2;
-}
-
-message ParticleFilterConfig {
-int32 number_of_particles = 1;
-}
-
-// The odometry noise adder adds noise during a motion update based on the speed
-// of the user.
-//
-// The mapping from speed to noise stays flat at min_noise_std_dev until the
-// speed reaches min_speed_mps, after which it ramps linearly up to
-// max_speed_mps. For speed greater than max_speed_mps, it stays at
-// max_noise_std_dev.
-//
-//
-//                    max_speed_mps
-//                    /
-//         ^          *
-//         |          ------------ max_noise_std_dev
-// sigma m |         /
-//         |        /
-//         | ------/  min_noise_std_dev
-//         ----------------------------------> Speed m/s`
-//                 *
-//                /
-//    min_speed_mps
-message OdometryNoiseAdderConfig {
-int32 num_speed_filter_taps = 2;
-double min_noise_std_dev_m = 3;
-double max_noise_std_dev_m = 4;
-double min_speed_mps = 5;
-double max_speed_mps = 6;
-}
-
-message OdometryThrottlerConfig {
-int64 throttling_dt_nanos = 1;
-}
-
-message OdometryBasedEstimatePropagatorConfig {
-// The size of the odometry buffer. Set this based on the odometry polling
-// rate.
-int32 buffer_size = 1;
-}
-
-// Uses the Normalized Innovation Squared criteria to determine if the filter
-// has diverged. The Filter will reset if divergence is detected.
-message NisDivergenceDetectorConfig {
-// A larger buffer reduces sensitivity to noisy measurements.
-int32 nis_buffer_size = 1;
-
-// A higher level yields fewer false positives.
-ConfidenceLevel confidence_level = 2;
-
-// Caps the NIS score to reduce sensitivity to outliers. For example, a value
-// of 1 sigma will cap the NIS score to the 68.3 % Gaussian interval about the
-// mean.
-double nis_sigma_bound = 3;
-
-// The detector will only be active if the std dev of the filter's error in
-// the estimated beacon position is below this threshold.
-double activation_threshold_m = 4;
-
-// The default noise covariance used when computing the NIS for UWB if an
-// online computed value is not provided to the detector.
-double default_uwb_noise_covariance = 5;
-
-// The default noise covariance used when computing the NIS for Wi-Fi RTT if
-// an online computed value is not provided to the detector.
-double default_wifi_rtt_noise_covariance = 6;
-}
-
-message UniformModelConfig {
-double min_value = 1;
-double max_value = 2;
-}
-
-message GaussianModelConfig {
-double loc = 1;
-double scale = 2;
-}
-
-message ExponentiallyWeightedGaussianModelConfig {
-double lambda_scaled = 1;
-double loc = 2;
-double scale = 3;
-}
-
-message ModelConfigContainer {
-oneof model {
-UniformModelConfig uniform_model_config = 1;
-GaussianModelConfig gaussian_model_config = 2;
-ExponentiallyWeightedGaussianModelConfig
-exponentially_weighted_gaussian_model_config = 3;
-}
-}
-
-// Configuration for the variance based switching model.
-message VarianceBasedSwitchingMeasurementModelConfig {
-double switching_threshold = 1;
-
-ModelConfigContainer low_variance_model_config = 2;
-
-// If unset, measurement updates will not be done while the sensor range
-// variance is above the variance_threshold.
-ModelConfigContainer high_variance_model_config = 3;
-
-// The size of the window over which the variance used by this model is
-// computed.
-int32 variance_window_size = 4;
-}
-
-// Configuration for an initial state sampler.
-//
-// Please note that the mean of the distribution specified in the sampler
-// configs are about the measured value; if a Gaussian sampler is used with loc
-// = 0.1 and scale = 10, then the samples will be generated using:
-//
-// measured_range + Gaussian(loc, scale).
-//
-// Additionally, note that the exponential distribution will be flipped such
-// that it is skewed towardes -ve axis rather than the standard which is skewed
-// towardes the +ve axis.
-message InitialStateSamplerConfig {
-ModelConfigContainer range_sampler_config = 1;
-ModelConfigContainer bearing_sampler_config = 2;
-}
-
-message DebugLoggerConfiguration {
-// Debug logs will be automatically emitted to the sink when they exceed this
-// size.
-int32 autodump_size_threshold_bytes = 1;
-// The rate at which odometry inputs will be throttled. Throttling is disabled
-// if set to 0.
-int64 odometry_throttling_nanos = 2;
-// The rate at which UWB range measurements will be throttled. Throttling is
-// disabled if set to 0.
-int64 uwb_throttling_nanos = 3;
-// The rate at which output estimates will be throttled. Throttling is
-// disabled if set to 0.
-int64 estimate_throttling_nanos = 4;
-}
diff --git a/generic_ranging/src/com/android/ranging/DefaultFusionConfig.java b/generic_ranging/src/com/android/ranging/DefaultFusionConfig.java
deleted file mode 100644
index e71fdec2..00000000
--- a/generic_ranging/src/com/android/ranging/DefaultFusionConfig.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.ranging;
-
-import com.android.ranging.proto.ConfidenceLevel;
-import com.android.ranging.proto.DebugLoggerConfiguration;
-import com.android.ranging.proto.DistanceTraveledCheckConfig;
-import com.android.ranging.proto.ExponentiallyWeightedGaussianModelConfig;
-import com.android.ranging.proto.FuzzyUpdateSchedulerConfig;
-import com.android.ranging.proto.InitialStateSamplerConfig;
-import com.android.ranging.proto.ModelConfigContainer;
-import com.android.ranging.proto.MultiSensorFinderConfig;
-import com.android.ranging.proto.NisDivergenceDetectorConfig;
-import com.android.ranging.proto.OdometryBasedEstimatePropagatorConfig;
-import com.android.ranging.proto.OdometryNoiseAdderConfig;
-import com.android.ranging.proto.OdometryThrottlerConfig;
-import com.android.ranging.proto.ParticleFilterConfig;
-import com.android.ranging.proto.RangeMeasurementConfig;
-import com.android.ranging.proto.RangeMeasurementConfig.RangeSensorModelType;
-import com.android.ranging.proto.VarianceBasedSwitchingMeasurementModelConfig;
-
-/** Default configuration for the Fusion algorithm. */
-public final class DefaultFusionConfig {
-
-    private DefaultFusionConfig() {
-    }
-
-    public static MultiSensorFinderConfig getDefaultConfig() {
-        return MultiSensorFinderConfig.newBuilder()
-                .setUseUwbMeasurements(true)
-                .setParticleFilterConfig(
-                        ParticleFilterConfig.newBuilder().setNumberOfParticles(500).build())
-                .setUwbRangeMeasurementConfig(
-                        RangeMeasurementConfig.newBuilder()
-                                .setSensorModelType(RangeSensorModelType.VARIANCE_BASED_SWITCHING)
-                                .setVarianceBasedSwitchingMeasurementModelConfig(
-                                        VarianceBasedSwitchingMeasurementModelConfig.newBuilder()
-                                                .setSwitchingThreshold(0.04)
-                                                .setVarianceWindowSize(5)
-                                                .setLowVarianceModelConfig(
-                                                        ModelConfigContainer.newBuilder()
-                                                                .setExponentiallyWeightedGaussianModelConfig(
-                                                                        ExponentiallyWeightedGaussianModelConfig.newBuilder()
-                                                                                .setLambdaScaled(
-                                                                                        0.52711296)
-                                                                                .setLoc(-0.16149637)
-                                                                                .setScale(
-                                                                                        0.22877243)
-                                                                                .build())
-                                                                .build())
-                                                .build())
-                                .setDistanceTraveledCheckConfig(
-                                        DistanceTraveledCheckConfig.newBuilder()
-                                                .setDistanceTraveledThresholdM(0.1016)
-                                                .build())
-                                .build())
-                .setFuzzyUpdateSchedulerConfiguration(
-                        FuzzyUpdateSchedulerConfig.newBuilder()
-                                .setMaxWaitTimeNanos(250000000)
-                                .setMaxFrameSizeNanos(250000000)
-                                .setMaxBufferSize(10)
-                                .build())
-                .setDefaultXyUpdateProcessNoiseStddevM(0.001)
-                .setOdometryNoiseAdderConfig(
-                        OdometryNoiseAdderConfig.newBuilder()
-                                .setNumSpeedFilterTaps(2)
-                                .setMinNoiseStdDevM(0.005)
-                                .setMaxNoiseStdDevM(0.05)
-                                .setMinSpeedMps(0.3)
-                                .setMaxSpeedMps(5)
-                                .build())
-                .setNisDivergenceDetectorConfig(
-                        NisDivergenceDetectorConfig.newBuilder()
-                                .setNisBufferSize(10)
-                                .setConfidenceLevel(ConfidenceLevel.CL_99)
-                                .setNisSigmaBound(2)
-                                .setActivationThresholdM(1)
-                                .setDefaultUwbNoiseCovariance(0.5)
-                                .build())
-                .setOdometryPollingRateHz(20)
-                .setOdometryThrottlerConfig(
-                        OdometryThrottlerConfig.newBuilder().setThrottlingDtNanos(
-                                100000000).build())
-                .setOdometryBasedEstimatePropagatorConfig(
-                        OdometryBasedEstimatePropagatorConfig.newBuilder().setBufferSize(
-                                100).build())
-                .setUwbInitialStateSamplerConfig(
-                        InitialStateSamplerConfig.newBuilder()
-                                .setRangeSamplerConfig(
-                                        ModelConfigContainer.newBuilder()
-                                                .setExponentiallyWeightedGaussianModelConfig(
-                                                        ExponentiallyWeightedGaussianModelConfig.newBuilder()
-                                                                .setLambdaScaled(0.3)
-                                                                .setLoc(-0.17)
-                                                                .setScale(0.7)
-                                                                .build())
-                                                .build())
-                                .build())
-                .setDebugLoggerConfiguration(
-                        DebugLoggerConfiguration.newBuilder()
-                                .setAutodumpSizeThresholdBytes(300)
-                                .setOdometryThrottlingNanos(1000000000)
-                                .setEstimateThrottlingNanos(1000000000))
-                .build();
-    }
-}
diff --git a/generic_ranging/src/com/android/ranging/RangingAdapter.java b/generic_ranging/src/com/android/ranging/RangingAdapter.java
deleted file mode 100644
index 0dcfebac..00000000
--- a/generic_ranging/src/com/android/ranging/RangingAdapter.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.ranging;
-
-import androidx.annotation.IntDef;
-
-import com.android.ranging.RangingParameters.TechnologyParameters;
-
-import com.google.common.util.concurrent.ListenableFuture;
-
-/** RangingAdapter representing a common ranging class for multiple ranging technologies. */
-public interface RangingAdapter {
-
-    /** Returns {@link RangingTechnology} of this adapter. */
-    RangingTechnology getType();
-
-    /**
-     * @return true if ranging with this ranging technology is currently enabled, or false
-     * otherwise. When this returns false it's most likely because of not being enabled in settings,
-     * airplane mode being on, etc.
-     */
-    ListenableFuture<Boolean> isEnabled();
-
-    /**
-     * Start ranging. Does nothing if the ranging technology is not enabled on device or if ranging
-     * has already been started. In the latter case, this method will not overwrite the existing
-     * callback.
-     * @param parameters to range with.
-     * @param callback to be called on the occurrence of ranging events.
-     */
-    void start(TechnologyParameters parameters, Callback callback);
-
-    /** Stop ranging. */
-    void stop();
-
-    /** Callback for getting notified when ranging starts or stops. */
-    interface Callback {
-        /**
-         * Notifies the caller that ranging has started on this device. onStarted will not be called
-         * after start if API failed to initialize, in that case onStopped with an appropriate error
-         * code will be called.
-         */
-        void onStarted();
-
-        /** Notifies the caller that ranging has stopped on this device. */
-        void onStopped(@StoppedReason int reason);
-
-        /**
-         * Notifies the caller on each instance of ranging data received from the ranging
-         * technology.
-         */
-        void onRangingData(RangingData data);
-
-        @IntDef({
-                StoppedReason.UNKNOWN,
-                StoppedReason.FAILED_TO_START,
-                StoppedReason.REQUESTED,
-                StoppedReason.LOST_CONNECTION,
-                StoppedReason.SYSTEM_POLICY,
-                StoppedReason.ERROR,
-        })
-        @interface StoppedReason {
-            int UNKNOWN = 0;
-            int ERROR = 1;
-            int FAILED_TO_START = 2;
-            int REQUESTED = 3;
-            int LOST_CONNECTION = 4;
-            int SYSTEM_POLICY = 5;
-        }
-    }
-}
diff --git a/generic_ranging/src/com/android/ranging/RangingConfig.java b/generic_ranging/src/com/android/ranging/RangingConfig.java
deleted file mode 100644
index d647fe3d..00000000
--- a/generic_ranging/src/com/android/ranging/RangingConfig.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.ranging;
-
-import com.android.ranging.proto.MultiSensorFinderConfig;
-
-import com.google.auto.value.AutoValue;
-import com.google.common.base.Preconditions;
-
-import java.time.Duration;
-import java.util.Optional;
-
-/** Configuration for multi-tecnology ranging */
-@AutoValue
-public abstract class RangingConfig {
-
-    /** Returns whether to use the fusing algorithm or not. */
-    public abstract boolean getUseFusingAlgorithm();
-
-    /**
-     * Returns the max interval at which data will be reported back. If set to 0 data will be
-     * reported immediately on reception. If set to non zero value, only latest received data that
-     * hasn't yet been reported will be reported, so there's a chance that some data doesn't get
-     * reported if multiple data points were received during the same update interval.
-     */
-    public abstract Duration getMaxUpdateInterval();
-
-    /**
-     * Returns the timeout after which precision ranging will be stopped if no data was produced
-     * since precision ranging started.
-     */
-    public abstract Duration getInitTimeout();
-
-    /**
-     * Returns the timeout to stop reporting back new data if fusion algorithm wasn't fed ranging
-     * data in that amount of time. Checked only if useFusingAlgorithm is set to true.
-     */
-    public abstract Duration getFusionAlgorithmDriftTimeout();
-
-    /**
-     * Returns the timeout to stop ranging if there were no new data updates sent in that time
-     * period.
-     */
-    public abstract Duration getNoUpdateTimeout();
-
-    /** Returns the fusion algorithm configuration if present. */
-    public abstract Optional<MultiSensorFinderConfig> getFusionAlgorithmConfig();
-
-    /** Returns a builder for {@link RangingConfig}. */
-    public static Builder builder() {
-        return new AutoValue_RangingConfig.Builder();
-    }
-
-    /** Builder for {@link RangingConfig}. */
-    @AutoValue.Builder
-    public abstract static class Builder {
-        public abstract Builder setUseFusingAlgorithm(boolean useFusingAlgorithm);
-
-        public abstract Builder setMaxUpdateInterval(Duration maxUpdateInterval);
-
-        public abstract Builder setFusionAlgorithmDriftTimeout(Duration duration);
-
-        public abstract Builder setNoUpdateTimeout(Duration duration);
-
-        public abstract Builder setInitTimeout(Duration duration);
-
-        public abstract Builder setFusionAlgorithmConfig(MultiSensorFinderConfig
-                fusionAlgorithmConfig);
-
-        abstract RangingConfig autoBuild();
-
-        public RangingConfig build() {
-            RangingConfig config = autoBuild();
-            Preconditions.checkArgument(
-                    config.getUseFusingAlgorithm() == config.getFusionAlgorithmConfig()
-                    .isPresent(),
-                    "Fusion algorithm config must be set when and only when useFusingAlgorithm"
-                    + "is set too");
-            return config;
-        }
-    }
-}
diff --git a/generic_ranging/src/com/android/ranging/RangingParameters.java b/generic_ranging/src/com/android/ranging/RangingParameters.java
deleted file mode 100644
index 5d9d9c7b..00000000
--- a/generic_ranging/src/com/android/ranging/RangingParameters.java
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Copyright 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.ranging;
-
-import androidx.annotation.NonNull;
-
-import com.android.ranging.cs.CsParameters;
-import com.android.ranging.uwb.UwbParameters;
-
-import java.util.EnumMap;
-import java.util.Optional;
-
-/** Parameters for a generic ranging session. */
-public class RangingParameters {
-    /** Parameters for a specific generic ranging technology. */
-    public interface TechnologyParameters { }
-
-    public enum DeviceRole {
-        /**
-         * The device is a controlee within the session.
-         */
-        CONTROLEE,
-        /**
-         * The device is the session controller. It decides when the session is started or stopped,
-         * ranging technology preferences, etc.
-         */
-        CONTROLLER
-    }
-
-    private final DeviceRole mRole;
-    private final EnumMap<RangingTechnology, TechnologyParameters> mParameters;
-
-    private RangingParameters(@NonNull RangingParameters.Builder builder) {
-        mRole = builder.mRole;
-        mParameters = new EnumMap<>(RangingTechnology.class);
-
-        if (builder.mUwbParameters != null) {
-            mParameters.put(RangingTechnology.UWB, builder.mUwbParameters);
-        }
-        if (builder.mCsParameters != null) {
-            mParameters.put(RangingTechnology.CS, builder.mCsParameters);
-        }
-    }
-
-    /**
-     * @return The configured device role.
-     */
-    public DeviceRole getRole() {
-        return mRole;
-    }
-
-    /**
-     * @return UWB parameters, or {@code Optional.empty()} if they were never set.
-     */
-    public Optional<UwbParameters> getUwbParameters() {
-        return Optional.ofNullable(mParameters.get(RangingTechnology.UWB))
-                .map(params -> (UwbParameters) params);
-    }
-
-    /**
-     * @return channel sounding parameters, or {@code Optional.empty()} if they were never set.
-     */
-    public Optional<CsParameters> getCsParameters() {
-        return Optional.ofNullable(mParameters.get(RangingTechnology.CS))
-                .map(params -> (CsParameters) params);
-    }
-
-    /** @return A map between technologies and their corresponding generic parameters object. */
-    public @NonNull EnumMap<RangingTechnology, TechnologyParameters> asMap() {
-        return mParameters.clone();
-    }
-
-    public static class Builder {
-        private final DeviceRole mRole;
-        private UwbParameters mUwbParameters = null;
-        private CsParameters mCsParameters = null;
-
-        /**
-         @param role of the device within the session.
-         */
-        public Builder(DeviceRole role) {
-            mRole = role;
-        }
-
-        /** Build the {@link RangingParameters object} */
-        public RangingParameters build() {
-            return new RangingParameters(this);
-        }
-
-        /**
-         * Range with UWB in this session.
-         * @param uwbParameters containing a configuration for UWB ranging.
-         */
-        public Builder useUwb(@NonNull UwbParameters uwbParameters) {
-            mUwbParameters = uwbParameters;
-            return this;
-        }
-
-        /**
-         * Range with Bluetooth Channel Sounding in this session.
-         * @param csParameters containing a configuration for CS ranging.
-         */
-        public Builder useCs(@NonNull CsParameters csParameters) {
-            mCsParameters = csParameters;
-            return this;
-        }
-    }
-}
diff --git a/generic_ranging/src/com/android/ranging/RangingSession.java b/generic_ranging/src/com/android/ranging/RangingSession.java
deleted file mode 100644
index 2678a0d8..00000000
--- a/generic_ranging/src/com/android/ranging/RangingSession.java
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.ranging;
-
-import android.os.RemoteException;
-
-import androidx.annotation.IntDef;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import com.android.ranging.uwb.backend.internal.RangingCapabilities;
-import com.android.ranging.uwb.backend.internal.UwbAddress;
-
-import com.google.common.util.concurrent.ListenableFuture;
-
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.util.EnumMap;
-
-/** A multi-technology ranging session in the Android generic ranging service */
-public interface RangingSession {
-
-    /** Starts ranging with all technologies specified, providing results via the given callback. */
-    void start(@NonNull RangingParameters parameters, @NonNull Callback callback);
-
-    /** Stops ranging. */
-    void stop();
-
-    /**
-     * Returns a map that describes the {@link TechnologyStatus} of every {@link RangingTechnology}
-     */
-    ListenableFuture<EnumMap<RangingTechnology, Integer>> getTechnologyStatus();
-
-    /** Returns UWB capabilities if UWB was requested. */
-    ListenableFuture<RangingCapabilities> getUwbCapabilities();
-
-    /** Returns UWB address if UWB was requested. */
-    ListenableFuture<UwbAddress> getUwbAddress() throws RemoteException;
-
-    /** Returns CS capabilities if CS was requested. */
-    void getCsCapabilities();
-
-    /** State of an individual {@link RangingTechnology}. */
-    @Retention(RetentionPolicy.SOURCE)
-    @IntDef({
-            /* Ranging technology is not part of this session. */
-            TechnologyStatus.UNUSED,
-            /* Ranging technology is disabled due to a device condition or user switch. */
-            TechnologyStatus.DISABLED,
-            /* Ranging technology is enabled. */
-            TechnologyStatus.ENABLED,
-    })
-    @interface TechnologyStatus {
-        int UNUSED = 0;
-        int DISABLED = 1;
-        int ENABLED = 2;
-    }
-
-    /** Callback for {@link RangingSession} events. */
-    interface Callback {
-        /**
-         * Callback method for reporting when ranging has started for a particular technology or
-         * for the entire session.
-         * @param technology that was started, or {@code null} to indicate that the entire session
-         *                   has started.
-         */
-        void onStarted(@Nullable RangingTechnology technology);
-
-        /**
-         * Callback method for reporting when ranging has stopped for a particular technology or for
-         * @param technology that was stopped, or {@code null} to indicate that the entire session
-         *                   has stopped.
-         * @param reason why the technology or session was stopped.
-         */
-        void onStopped(@Nullable RangingTechnology technology, @StoppedReason int reason);
-
-        /**
-         * Callback for reporting ranging data.
-         * @param data to be reported.
-         */
-        void onData(@NonNull RangingData data);
-
-        /** Reason why ranging was stopped. */
-        @Retention(RetentionPolicy.SOURCE)
-        @IntDef({
-                RangingAdapter.Callback.StoppedReason.UNKNOWN,
-                RangingAdapter.Callback.StoppedReason.FAILED_TO_START,
-                RangingAdapter.Callback.StoppedReason.REQUESTED,
-                RangingAdapter.Callback.StoppedReason.LOST_CONNECTION,
-                RangingAdapter.Callback.StoppedReason.SYSTEM_POLICY,
-                RangingAdapter.Callback.StoppedReason.ERROR,
-                StoppedReason.NO_INITIAL_DATA_TIMEOUT,
-                StoppedReason.NO_UPDATED_DATA_TIMEOUT,
-        })
-        @interface StoppedReason {
-            /** The session failed to report data before the initial data timeout expired. */
-            int NO_INITIAL_DATA_TIMEOUT = 6;
-            /** The session had no new data to report before the data update timeout expired. */
-            int NO_UPDATED_DATA_TIMEOUT = 7;
-        }
-    }
-}
diff --git a/generic_ranging/src/com/android/ranging/RangingSessionImpl.java b/generic_ranging/src/com/android/ranging/RangingSessionImpl.java
deleted file mode 100644
index 9534c80d..00000000
--- a/generic_ranging/src/com/android/ranging/RangingSessionImpl.java
+++ /dev/null
@@ -1,360 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.ranging;
-
-import static com.google.common.util.concurrent.Futures.immediateFailedFuture;
-
-import android.content.Context;
-import android.os.RemoteException;
-import android.util.Log;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.VisibleForTesting;
-
-import com.android.ranging.RangingParameters.DeviceRole;
-import com.android.ranging.RangingUtils.StateMachine;
-import com.android.ranging.cs.CsAdapter;
-import com.android.ranging.fusion.FusionEngine;
-import com.android.ranging.uwb.UwbAdapter;
-import com.android.ranging.uwb.backend.internal.RangingCapabilities;
-import com.android.ranging.uwb.backend.internal.UwbAddress;
-
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.ListeningExecutorService;
-import com.google.errorprone.annotations.DoNotCall;
-
-import java.time.Duration;
-import java.util.Collections;
-import java.util.EnumMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.ScheduledFuture;
-import java.util.concurrent.TimeUnit;
-import java.util.stream.Collectors;
-
-/**  Implementation of the Android multi-technology ranging layer */
-public final class RangingSessionImpl implements RangingSession {
-
-    private static final String TAG = RangingSessionImpl.class.getSimpleName();
-
-    private final Context mContext;
-    private final RangingConfig mConfig;
-
-    /** Callback for session events. Invariant: Non-null while a session is ongoing. */
-    private RangingSession.Callback mCallback;
-
-    /** Keeps track of state of the ranging session. <b>Must be synchronized.</b> */
-    private final StateMachine<State> mStateMachine;
-
-    /**
-     * Ranging adapters used for this session. <b>Must be synchronized</b>.
-     * {@code mStateMachine} lock must be acquired first if mutual synchronization is necessary.
-     */
-    private final Map<RangingTechnology, RangingAdapter> mAdapters;
-
-    /** Fusion engine to use for this session. */
-    private final FusionEngine mFusionEngine;
-
-    /** Executor for ranging technology adapters. */
-    private final ListeningExecutorService mAdapterExecutor;
-
-    /** Executor for session timeout handlers. */
-    private final ScheduledExecutorService mTimeoutExecutor;
-
-    /** Future that stops the session due to a timeout. */
-    private ScheduledFuture<?> mPendingTimeout;
-
-    public RangingSessionImpl(
-            @NonNull Context context,
-            @NonNull RangingConfig config,
-            @NonNull FusionEngine fusionEngine,
-            @NonNull ScheduledExecutorService timeoutExecutor,
-            @NonNull ListeningExecutorService rangingAdapterExecutor
-    ) {
-        mContext = context;
-        mConfig = config;
-
-        mStateMachine = new StateMachine<>(State.STOPPED);
-        mCallback = null;
-
-        mAdapters = Collections.synchronizedMap(new EnumMap<>(RangingTechnology.class));
-        mFusionEngine = fusionEngine;
-
-        mTimeoutExecutor = timeoutExecutor;
-        mAdapterExecutor = rangingAdapterExecutor;
-
-        mPendingTimeout = null;
-    }
-
-    private @NonNull RangingAdapter newAdapter(
-            @NonNull RangingTechnology technology, DeviceRole role
-    ) {
-        switch (technology) {
-            case UWB:
-                return new UwbAdapter(mContext, mAdapterExecutor, role);
-            case CS:
-                return new CsAdapter();
-            default:
-                throw new IllegalArgumentException(
-                        "Tried to create adapter for unknown technology" + technology);
-        }
-    }
-
-    @Override
-    public void start(@NonNull RangingParameters parameters, @NonNull Callback callback) {
-        EnumMap<RangingTechnology, RangingParameters.TechnologyParameters> paramsMap =
-                parameters.asMap();
-        mAdapters.keySet().retainAll(paramsMap.keySet());
-
-        Log.i(TAG, "Start Precision Ranging called.");
-        if (!mStateMachine.transition(State.STOPPED, State.STARTING)) {
-            Log.w(TAG, "Failed transition STOPPED -> STARTING");
-            return;
-        }
-        mCallback = callback;
-
-        for (RangingTechnology technology : paramsMap.keySet()) {
-            if (!technology.isSupported(mContext)) {
-                Log.w(TAG, "Attempted to range with unsupported technology " + technology
-                        + ", skipping");
-                continue;
-            }
-
-            synchronized (mAdapters) {
-                // Do not overwrite any adapters that were supplied for testing
-                if (!mAdapters.containsKey(technology)) {
-                    mAdapters.put(technology, newAdapter(technology, parameters.getRole()));
-                }
-
-                mAdapters.get(technology).start(paramsMap.get(technology),
-                        new AdapterListener(technology));
-            }
-        }
-
-        mFusionEngine.start(new FusionEngineListener());
-        scheduleTimeout(mConfig.getInitTimeout(), Callback.StoppedReason.NO_INITIAL_DATA_TIMEOUT);
-    }
-
-    @Override
-    public void stop() {
-        stopForReason(RangingAdapter.Callback.StoppedReason.REQUESTED);
-    }
-
-    /**
-     * Stop all ranging adapters and reset internal state.
-     * @param reason why the session was stopped.
-     */
-    private void stopForReason(@Callback.StoppedReason int reason) {
-        Log.i(TAG, "stopPrecisionRanging with reason: " + reason);
-        synchronized (mStateMachine) {
-            if (mStateMachine.getState() == State.STOPPED) {
-                Log.v(TAG, "Ranging already stopped, skipping");
-                return;
-            }
-            mStateMachine.setState(State.STOPPED);
-
-            // Stop all ranging technologies.
-            synchronized (mAdapters) {
-                for (RangingTechnology technology : mAdapters.keySet()) {
-                    mAdapters.get(technology).stop();
-                    mCallback.onStopped(technology, reason);
-                }
-            }
-
-            // Reset internal state.
-            mFusionEngine.stop();
-            mAdapters.clear();
-            mCallback.onStopped(null, reason);
-            mCallback = null;
-        }
-    }
-
-    @Override
-    public ListenableFuture<RangingCapabilities> getUwbCapabilities() {
-        if (!mAdapters.containsKey(RangingTechnology.UWB)) {
-            return immediateFailedFuture(
-                    new IllegalStateException("UWB was not requested for this session."));
-        }
-        UwbAdapter uwbAdapter = (UwbAdapter) mAdapters.get(RangingTechnology.UWB);
-        try {
-            return uwbAdapter.getCapabilities();
-        } catch (RemoteException e) {
-            Log.e(TAG, "Failed to get Uwb capabilities");
-            return null;
-        }
-    }
-
-    @Override
-    public ListenableFuture<UwbAddress> getUwbAddress() throws RemoteException {
-        if (!mAdapters.containsKey(RangingTechnology.UWB)) {
-            return immediateFailedFuture(
-                    new IllegalStateException("UWB was not requested for this session."));
-        }
-        UwbAdapter uwbAdapter = (UwbAdapter) mAdapters.get(RangingTechnology.UWB);
-        return uwbAdapter.getLocalAddress();
-    }
-
-    @DoNotCall("Not implemented")
-    @Override
-    public void getCsCapabilities() {
-        throw new UnsupportedOperationException("Not implemented");
-    }
-
-    @Override
-    public ListenableFuture<EnumMap<RangingTechnology, Integer>> getTechnologyStatus() {
-        // Combine all isEnabled futures for each technology into a single future. The resulting
-        // future contains a list of technologies grouped with their corresponding
-        // enabled state.
-        ListenableFuture<List<Map.Entry<RangingTechnology, Boolean>>> enabledStatesFuture;
-        synchronized (mAdapters) {
-            enabledStatesFuture = Futures.allAsList(mAdapters.entrySet().stream()
-                    .map((var entry) -> Futures.transform(
-                            entry.getValue().isEnabled(),
-                            (Boolean isEnabled) -> Map.entry(entry.getKey(), isEnabled),
-                            mAdapterExecutor)
-                    )
-                    .collect(Collectors.toList())
-            );
-        }
-
-        // Transform the list of enabled states into a technology status map.
-        return Futures.transform(
-                enabledStatesFuture,
-                (List<Map.Entry<RangingTechnology, Boolean>> enabledStates) -> {
-                    EnumMap<RangingTechnology, Integer> statuses =
-                            new EnumMap<>(RangingTechnology.class);
-                    for (RangingTechnology technology : RangingTechnology.values()) {
-                        statuses.put(technology, TechnologyStatus.UNUSED);
-                    }
-
-                    for (Map.Entry<RangingTechnology, Boolean> enabledState : enabledStates) {
-                        RangingTechnology technology = enabledState.getKey();
-                        if (enabledState.getValue()) {
-                            statuses.put(technology, TechnologyStatus.ENABLED);
-                        } else {
-                            statuses.put(technology, TechnologyStatus.DISABLED);
-                        }
-                    }
-                    return statuses;
-                },
-                mAdapterExecutor
-        );
-    }
-
-    /* If there is a pending timeout, cancel it. */
-    private synchronized void cancelScheduledTimeout() {
-        if (mPendingTimeout != null) {
-            mPendingTimeout.cancel(false);
-            mPendingTimeout = null;
-        }
-    }
-
-    /**
-     * Schedule a future that stops the session.
-     *
-     * @param timeout after which the session should be stopped.
-     * @param reason  for stopping the session.
-     */
-    private synchronized void scheduleTimeout(
-            @NonNull Duration timeout, @Callback.StoppedReason int reason
-    ) {
-        cancelScheduledTimeout();
-        mPendingTimeout = mTimeoutExecutor.schedule(
-                () -> {
-                    Log.w(TAG, "Reached scheduled timeout of " + timeout.toMillis());
-                    stopForReason(reason);
-                },
-                mConfig.getNoUpdateTimeout().toMillis(), TimeUnit.MILLISECONDS
-        );
-    }
-
-    /* Listener implementation for ranging adapter callback. */
-    private class AdapterListener implements RangingAdapter.Callback {
-        private final RangingTechnology mTechnology;
-
-        AdapterListener(RangingTechnology technology) {
-            this.mTechnology = technology;
-        }
-
-        @Override
-        public void onStarted() {
-            synchronized (mStateMachine) {
-                if (mStateMachine.getState() == State.STOPPED) {
-                    Log.w(TAG, "Received adapter onStarted but ranging session is stopped");
-                    return;
-                }
-                mFusionEngine.addDataSource(mTechnology);
-                mCallback.onStarted(mTechnology);
-            }
-        }
-
-        @Override
-        public void onStopped(@RangingAdapter.Callback.StoppedReason int reason) {
-            synchronized (mStateMachine) {
-                if (mStateMachine.getState() != State.STOPPED) {
-                    mAdapters.remove(mTechnology);
-                    mFusionEngine.removeDataSource(mTechnology);
-                    mCallback.onStopped(mTechnology, reason);
-                }
-            }
-        }
-
-        @Override
-        public void onRangingData(RangingData data) {
-            synchronized (mStateMachine) {
-                if (mStateMachine.getState() != State.STOPPED) {
-                    mFusionEngine.feed(data);
-                }
-            }
-        }
-    }
-
-    /* Listener implementation for fusion engine callback. */
-    private class FusionEngineListener implements FusionEngine.Callback {
-
-        @Override
-        public void onData(@NonNull RangingData data) {
-            synchronized (mStateMachine) {
-                if (mStateMachine.getState() == State.STOPPED) {
-                    return;
-                }
-                cancelScheduledTimeout();
-                if (mStateMachine.transition(State.STARTING, State.STARTED)) {
-                    // This is the first ranging data instance reported by the session, so start it.
-                    mCallback.onStarted(null);
-                }
-                mCallback.onData(data);
-                scheduleTimeout(
-                        mConfig.getNoUpdateTimeout(),
-                        Callback.StoppedReason.NO_UPDATED_DATA_TIMEOUT);
-            }
-        }
-    }
-
-    @VisibleForTesting
-    public void useAdapterForTesting(RangingTechnology technology, RangingAdapter adapter) {
-        mAdapters.put(technology, adapter);
-    }
-
-    private enum State {
-        STARTING,
-        STARTED,
-        STOPPED,
-    }
-}
diff --git a/generic_ranging/src/com/android/ranging/RangingUtils.java b/generic_ranging/src/com/android/ranging/RangingUtils.java
deleted file mode 100644
index de1568b8..00000000
--- a/generic_ranging/src/com/android/ranging/RangingUtils.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.ranging;
-
-/**
- * Utilities for {@link com.android.ranging}.
- */
-public class RangingUtils {
-    /**
-     * A basic synchronized state machine.
-     * @param <E> enum representing the different states of the machine.
-     */
-    public static class StateMachine<E extends Enum<E>> {
-        private E mState;
-
-        public StateMachine(E start) {
-            mState = start;
-        }
-
-        /** Gets the current state */
-        public synchronized E getState() {
-            return mState;
-        }
-
-        /** Sets the current state */
-        public synchronized void setState(E state) {
-            mState = state;
-        }
-
-        /**
-         * Sets the current state.
-         * @return true if the state was successfully changed, false if the current state is
-         * already {@code state}.
-         */
-        public synchronized boolean changeStateTo(E state) {
-            if (mState == state) {
-                return false;
-            }
-            setState(state);
-            return true;
-        }
-
-        /**
-         * If the current state is {@code from}, sets it to {@code to}.
-         * @return true if the current state is {@code from}, false otherwise.
-         */
-        public synchronized boolean transition(E from, E to) {
-            if (mState != from) {
-                return false;
-            }
-            mState = to;
-            return true;
-        }
-    }
-
-}
diff --git a/generic_ranging/src/com/android/ranging/cs/CsAdapter.java b/generic_ranging/src/com/android/ranging/cs/CsAdapter.java
deleted file mode 100644
index 24bad90e..00000000
--- a/generic_ranging/src/com/android/ranging/cs/CsAdapter.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.ranging.cs;
-
-import android.content.Context;
-
-import com.android.ranging.RangingAdapter;
-import com.android.ranging.RangingParameters.TechnologyParameters;
-import com.android.ranging.RangingTechnology;
-
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
-
-/** Channel Sounding adapter for ranging. */
-public class CsAdapter implements RangingAdapter {
-
-    public static boolean isSupported(Context context) {
-        return false;
-    }
-
-    public CsAdapter() {
-        throw new UnsupportedOperationException("Not implemented.");
-    }
-
-    @Override
-    public RangingTechnology getType() {
-        return RangingTechnology.CS;
-    }
-
-    @Override
-    public ListenableFuture<Boolean> isEnabled() {
-        return Futures.immediateFuture(false);
-    }
-
-    @Override
-    public void start(TechnologyParameters parameters, Callback callback) {
-        throw new UnsupportedOperationException("Not implemented.");
-    }
-
-    @Override
-    public void stop() {
-        throw new UnsupportedOperationException("Not implemented.");
-    }
-}
diff --git a/generic_ranging/src/com/android/ranging/uwb/UwbAdapter.java b/generic_ranging/src/com/android/ranging/uwb/UwbAdapter.java
deleted file mode 100644
index 71ff8da4..00000000
--- a/generic_ranging/src/com/android/ranging/uwb/UwbAdapter.java
+++ /dev/null
@@ -1,293 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.ranging.uwb;
-
-import static com.google.common.util.concurrent.Futures.immediateFuture;
-
-import android.content.Context;
-import android.content.pm.PackageManager;
-import android.os.Build;
-import android.os.RemoteException;
-import android.util.Log;
-
-import androidx.annotation.NonNull;
-
-import com.android.ranging.RangingAdapter;
-import com.android.ranging.RangingData;
-import com.android.ranging.RangingParameters.DeviceRole;
-import com.android.ranging.RangingParameters.TechnologyParameters;
-import com.android.ranging.RangingTechnology;
-import com.android.ranging.RangingUtils.StateMachine;
-import com.android.ranging.uwb.backend.internal.RangingCapabilities;
-import com.android.ranging.uwb.backend.internal.RangingController;
-import com.android.ranging.uwb.backend.internal.RangingDevice;
-import com.android.ranging.uwb.backend.internal.RangingParameters;
-import com.android.ranging.uwb.backend.internal.RangingPosition;
-import com.android.ranging.uwb.backend.internal.RangingSessionCallback;
-import com.android.ranging.uwb.backend.internal.Utils;
-import com.android.ranging.uwb.backend.internal.UwbAddress;
-import com.android.ranging.uwb.backend.internal.UwbComplexChannel;
-import com.android.ranging.uwb.backend.internal.UwbDevice;
-import com.android.ranging.uwb.backend.internal.UwbFeatureFlags;
-import com.android.ranging.uwb.backend.internal.UwbServiceImpl;
-
-import com.google.common.annotations.VisibleForTesting;
-import com.google.common.util.concurrent.FutureCallback;
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.ListeningExecutorService;
-
-import java.time.Duration;
-import java.util.concurrent.Executors;
-
-/** Ranging adapter for Ultra-wideband (UWB). */
-public class UwbAdapter implements RangingAdapter {
-    private static final String TAG = UwbAdapter.class.getSimpleName();
-
-    private final UwbServiceImpl mUwbService;
-    // private IUwb mIUwb;
-
-    private final RangingDevice mUwbClient;
-    private final ListeningExecutorService mExecutorService;
-    private final ExecutorResultHandlers mUwbClientResultHandlers = new ExecutorResultHandlers();
-    private final RangingSessionCallback mUwbListener = new UwbListener();
-    private final StateMachine<State> mStateMachine;
-
-    /** Invariant: non-null while a ranging session is active */
-    private Callback mCallbacks;
-
-    /** @return true if UWB is supported in the provided context, false otherwise */
-    public static boolean isSupported(Context context) {
-        return context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_UWB);
-    }
-
-    public UwbAdapter(
-            @NonNull Context context, @NonNull ListeningExecutorService executorService,
-            @NonNull DeviceRole role
-    ) {
-        this(context, executorService,
-                new UwbServiceImpl(
-                        context,
-                        new UwbFeatureFlags.Builder()
-                                .setSkipRangingCapabilitiesCheck(
-                                        Build.VERSION.SDK_INT <= Build.VERSION_CODES.S_V2)
-                                .setReversedByteOrderFiraParams(
-                                        Build.VERSION.SDK_INT <= Build.VERSION_CODES.TIRAMISU)
-                                .build(),
-                        (isUwbAvailable, reason) -> {
-                            // TODO: Implement when adding backend support.
-                        }
-                ),
-                role);
-    }
-
-    @VisibleForTesting
-    public UwbAdapter(
-            @NonNull Context context, @NonNull ListeningExecutorService executorService,
-            @NonNull UwbServiceImpl uwbService, @NonNull DeviceRole role
-    ) {
-        if (!UwbAdapter.isSupported(context)) {
-            throw new IllegalArgumentException("UWB system feature not found.");
-        }
-
-        mStateMachine = new StateMachine<>(State.STOPPED);
-        mUwbService = uwbService;
-        mUwbClient = role == DeviceRole.CONTROLLER
-                ? mUwbService.getController(context)
-                : mUwbService.getControlee(context);
-        mExecutorService = executorService;
-        mCallbacks = null;
-    }
-
-    @Override
-    public RangingTechnology getType() {
-        return RangingTechnology.UWB;
-    }
-
-    @Override
-    public ListenableFuture<Boolean> isEnabled() {
-        return Futures.immediateFuture(mUwbService.isAvailable());
-    }
-
-    @Override
-    public void start(@NonNull TechnologyParameters parameters, @NonNull Callback callbacks) {
-        Log.i(TAG, "Start called.");
-        if (!mStateMachine.transition(State.STOPPED, State.STARTED)) {
-            Log.v(TAG, "Attempted to start adapter when it was already started");
-            return;
-        }
-
-        mCallbacks = callbacks;
-        if (!(parameters instanceof RangingParameters)) {
-            Log.w(TAG, "Tried to start adapter with invalid ranging parameters");
-            mCallbacks.onStopped(Callback.StoppedReason.FAILED_TO_START);
-            return;
-        }
-        mUwbClient.setRangingParameters((RangingParameters) parameters);
-
-        var future = Futures.submit(() -> {
-            mUwbClient.startRanging(mUwbListener, Executors.newSingleThreadExecutor());
-        }, mExecutorService);
-        Futures.addCallback(future, mUwbClientResultHandlers.startRanging, mExecutorService);
-    }
-
-    @Override
-    public void stop() {
-        Log.i(TAG, "Stop called.");
-        if (!mStateMachine.transition(State.STARTED, State.STOPPED)) {
-            Log.v(TAG, "Attempted to stop adapter when it was already stopped");
-            return;
-        }
-
-        var future = Futures.submit(mUwbClient::stopRanging, mExecutorService);
-        Futures.addCallback(future, mUwbClientResultHandlers.stopRanging, mExecutorService);
-    }
-
-    public ListenableFuture<UwbAddress> getLocalAddress() {
-        return Futures.submit(() -> mUwbClient.getLocalAddress(), mExecutorService);
-    }
-
-    public ListenableFuture<UwbComplexChannel> getComplexChannel() {
-        if (!(mUwbClient instanceof RangingController)) {
-            return immediateFuture(null);
-        }
-        return Futures.submit(() -> ((RangingController) mUwbClient).getComplexChannel(),
-                mExecutorService);
-    }
-
-    public ListenableFuture<RangingCapabilities> getCapabilities() throws RemoteException {
-        return Futures.submit(mUwbService::getRangingCapabilities, mExecutorService);
-    }
-
-    private class UwbListener implements RangingSessionCallback {
-
-        @Override
-        public void onRangingInitialized(UwbDevice device) {
-            Log.i(TAG, "onRangingInitialized");
-            synchronized (mStateMachine) {
-                if (mStateMachine.getState() == State.STARTED) {
-                    mCallbacks.onStarted();
-                }
-            }
-        }
-
-        @Override
-        public void onRangingResult(UwbDevice device, RangingPosition position) {
-            RangingData.Builder dataBuilder = new RangingData.Builder()
-                    .setTechnology(RangingTechnology.UWB)
-                    .setRangeDistance(position.getDistance().getValue())
-                    .setRssi(position.getRssiDbm())
-                    .setTimestamp(Duration.ofNanos(position.getElapsedRealtimeNanos()))
-                    .setPeerAddress(device.getAddress().toBytes());
-
-            if (position.getAzimuth() != null) {
-                dataBuilder.setAzimuthRadians(position.getAzimuth().getValue());
-            }
-            if (position.getElevation() != null) {
-                dataBuilder.setElevationRadians(position.getElevation().getValue());
-            }
-            synchronized (mStateMachine) {
-                if (mStateMachine.getState() == State.STARTED) {
-                    mCallbacks.onRangingData(dataBuilder.build());
-                }
-            }
-        }
-
-        private static @Callback.StoppedReason int convertReason(
-                @RangingSessionCallback.RangingSuspendedReason int reason) {
-            switch (reason) {
-                case REASON_WRONG_PARAMETERS:
-                case REASON_FAILED_TO_START:
-                    return Callback.StoppedReason.FAILED_TO_START;
-                case REASON_STOPPED_BY_PEER:
-                case REASON_STOP_RANGING_CALLED:
-                    return Callback.StoppedReason.REQUESTED;
-                case REASON_MAX_RANGING_ROUND_RETRY_REACHED:
-                    return Callback.StoppedReason.LOST_CONNECTION;
-                case REASON_SYSTEM_POLICY:
-                    return Callback.StoppedReason.SYSTEM_POLICY;
-                default:
-                    return Callback.StoppedReason.UNKNOWN;
-            }
-        }
-
-        @Override
-        public void onRangingSuspended(UwbDevice device, @RangingSuspendedReason int reason) {
-            Log.i(TAG, "onRangingSuspended: " + reason);
-
-            synchronized (mStateMachine) {
-                mCallbacks.onStopped(convertReason(reason));
-                clear();
-            }
-        }
-    }
-
-    @VisibleForTesting
-    public void setComplexChannelForTesting() {
-        if (mUwbClient instanceof RangingController) {
-            mUwbClient.setForTesting(true);
-        }
-    }
-
-    @VisibleForTesting
-    public void setLocalAddressForTesting(@NonNull UwbAddress uwbAddress) {
-        mUwbClient.setLocalAddress(uwbAddress);
-    }
-
-    private void clear() {
-        mCallbacks = null;
-    }
-
-    public enum State {
-        STARTED,
-        STOPPED,
-    }
-
-    private class ExecutorResultHandlers {
-        public final FutureCallback<Void> startRanging = new FutureCallback<>() {
-            @Override
-            public void onSuccess(Void v) {
-                Log.i(TAG, "startRanging succeeded.");
-                // On started will be called after onRangingInitialized is invoked from
-                // the UWB callback.
-            }
-
-            @Override
-            public void onFailure(@NonNull Throwable t) {
-                Log.w(TAG, "startRanging failed ", t);
-                mCallbacks.onStopped(RangingAdapter.Callback.StoppedReason.ERROR);
-                clear();
-            }
-        };
-
-        public final FutureCallback<Integer> stopRanging = new FutureCallback<>() {
-            @Override
-            public void onSuccess(@Utils.UwbStatusCodes Integer status) {
-                // On stopped will be called after onRangingSuspended is invoked from
-                // the UWB callback.
-            }
-
-            @Override
-            public void onFailure(@NonNull Throwable t) {
-                Log.w(TAG, "stopRanging failed ", t);
-                // We failed to stop but there's nothing else we can do.
-                mCallbacks.onStopped(RangingAdapter.Callback.StoppedReason.REQUESTED);
-                clear();
-            }
-        };
-    }
-}
diff --git a/generic_ranging/src/com/android/ranging/uwb/UwbParameters.java b/generic_ranging/src/com/android/ranging/uwb/UwbParameters.java
deleted file mode 100644
index f8d6a376..00000000
--- a/generic_ranging/src/com/android/ranging/uwb/UwbParameters.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.ranging.uwb;
-
-import androidx.annotation.NonNull;
-
-import com.android.ranging.RangingParameters;
-import com.android.ranging.uwb.backend.internal.UwbAddress;
-import com.android.ranging.uwb.backend.internal.UwbComplexChannel;
-import com.android.ranging.uwb.backend.internal.UwbRangeDataNtfConfig;
-
-import java.util.List;
-
-/** Parameters for UWB ranging. */
-public class UwbParameters
-        extends com.android.ranging.uwb.backend.internal.RangingParameters
-        implements RangingParameters.TechnologyParameters {
-
-    public UwbParameters(int uwbConfigId, int sessionId, int subSessionId,
-            byte[] sessionKeyInfo,
-            byte[] subSessionKeyInfo,
-            UwbComplexChannel complexChannel,
-            List<UwbAddress> peerAddresses,
-            int rangingUpdateRate,
-            @NonNull UwbRangeDataNtfConfig uwbRangeDataNtfConfig,
-            int slotDuration, boolean isAoaDisabled) {
-        super(uwbConfigId, sessionId, subSessionId, sessionKeyInfo, subSessionKeyInfo,
-                complexChannel,
-                peerAddresses, rangingUpdateRate, uwbRangeDataNtfConfig, slotDuration,
-                isAoaDisabled);
-    }
-}
diff --git a/generic_ranging/src/com/android/sensor/AndroidMultiSensorFinderInterface.java b/generic_ranging/src/com/android/sensor/AndroidMultiSensorFinderInterface.java
deleted file mode 100644
index 5f729109..00000000
--- a/generic_ranging/src/com/android/sensor/AndroidMultiSensorFinderInterface.java
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.sensor;
-
-import android.app.Activity;
-import android.app.Application.ActivityLifecycleCallbacks;
-import android.content.Context;
-
-import java.util.concurrent.FutureTask;
-
-/**
- * Precision Finder fuses range measurements from UWB, Wifi-RTT, and BLE HADM etc. with odometry to
- * provide a range and bearing to the beacon.
- *
- * <p>Sample Usage:
- *
- * <p><code>
- * // --- To create finder ---
- * MultiSensorFinder finder = new MultiSensorFinder(config, args, ...);
- * finder.SubscribeToEstimates("name_of_user", listener);
- *
- * // --- Checking availability of finder ---
- * // IMPORTANT: Before calling start, please make that it is possible to run a particular finder
- * // implementation on the device, and that the finder implementation has all prerequisites met:
- * if (!finder.checkAvailability(context)) {
- * return;  // Can't use finder here.
- * }
- *
- * switch (finder.requestInstall(activity)) {
- * case USER_PROMPTED_TO_INSTALL_DEPENDENCIES:
- * // The activity was switched and the user was requested to install dependencies.
- * return;
- * case USER_DECLINED_TO_INSTALL_DEPENDENCIES:
- * // User declined to install dependencies.
- * return;
- * case DEVICE_INCOMPATIBLE:
- * break;
- * case OK:
- * // Everything is good to go!
- * break;
- * }
- *
- * // --- Starting finder --- //
- * finder.Start();
- *
- * // --- Providing data to finder --- //
- * finder.updateWithUwbMeasurement(rangeMeters, timestampNanos);
- * finder.updateWithWifiRTTMeasurement(rangeMeters, errorStdDevMeters, rssiDbm, timestampNanos);
- * ...
- *
- * // --- Destroying finder --- //
- * finder.stop();
- * finder.delete();
- * </code>
- *
- * <p>Please note that finder should be stopped when the activity in which it is running is switched
- * to the background, so that all sensor streams that finder is using are stopped. This can be done
- * in two ways:
- *
- * <ul>
- *   <li>Manually call finder.stop() in your activity's onPause method.
- *   <li>Call getApplication().registerActivityLifecycleCallbacks(finder) in your activity's
- *       onCreate, and finder will automatically call stop when the application goes to bg.
- * </ul>
- *
- * Additionally, finder.delete() should be called when the application is destroyed. Again, this can
- * be manually done in your applications onDestroy, or you can register finder to the activity's
- * ActivityLifecycleCallbacks to do this for you automatically.
- */
-public interface AndroidMultiSensorFinderInterface extends ActivityLifecycleCallbacks {
-
-    /**
-     * Checks if the device meets the requirements for running precision finder e.g. it has all the
-     * sensors etc.
-     */
-    FutureTask<Boolean> checkAvailability(Context context);
-
-    /**
-     * Checks if all dependencies have been installed, and if not, switch the activity and prompt
-     * the
-     * user to install them.
-     */
-    InstallStatus requestInstall(Activity activity);
-
-    /**
-     * Resets underlying variables, and starts odometry. Once started, MultiSensorFinder will accept
-     * measurements.
-     *
-     * <p>If MultiSensorFinder is already started, this method is a no-op.
-     *
-     * @return Status.OK if successful, and Status.ERROR_* otherwise.
-     */
-    Status start(Context context);
-
-    /**
-     * Stops producing estimates. Once stopped, MultiSensorFinder cannot accept measurements.
-     *
-     * <p>If already stopped, this method is a no-op.
-     *
-     * <p>@return Status.OK if successful, and Status.ERROR_* otherwise.
-     */
-    Status stop();
-
-    /**
-     * Adds a UWB measurement, which will be fused with other data to produce an estimate.
-     *
-     * <p>If MultiSensorFinder is stopped, this method is a no-op.
-     *
-     * <p>Note: The Android stack does not provide low level information on the received UWB
-     * signal,
-     * e.g. the number of peaks in the impulse response, or how much multipath is in the
-     * environment.
-     * It's not clear if the Fira API exposes this information, but it might be useful.
-     *
-     * @param rangeMeters    The range measurement from UWB.
-     * @param timestampNanos The timestamp in nanoseconds associated with the measurement.
-     */
-    void updateWithUwbMeasurement(double rangeMeters, long timestampNanos);
-
-    /**
-     * Adds a Wifi-RTT measurement, which will be fused with other data to produce an estimate.
-     *
-     * <p>If MultiSensorFinder is stopped, this method is a no-op.
-     *
-     * @param rangeMeters       The range measurement from Wifi-RTT.
-     * @param errorStdDevMeters The error bounds on the range measurement.
-     * @param rssiDbm           Beacon to finder signal strength.
-     * @param timestampNanos    The timestamp in nanoseconds associated with the measurement.
-     */
-    void updateWithWifiRttMeasurement(
-            double rangeMeters, double errorStdDevMeters, double rssiDbm, long timestampNanos);
-
-    /**
-     * Adds a subscriber that will be notified when a new Estimate is available. Note that Finder
-     * will
-     * not generate any estimates if it is stopped.
-     *
-     * @param listener The subscriber that will be registered.
-     */
-    void subscribeToEstimates(MultiSensorFinderListener listener);
-
-    /**
-     * Frees all native resources. This should be called when the application is destroyed, unless
-     * this class is registered to ActivityLifecycleCallbacks of the application using it, in which
-     * case it will be called automatically on the application's onDestroy.
-     */
-    void delete();
-}
diff --git a/generic_ranging/src/com/android/sensor/ArCoreMultiSensorFinder.java b/generic_ranging/src/com/android/sensor/ArCoreMultiSensorFinder.java
deleted file mode 100644
index 3c9c851f..00000000
--- a/generic_ranging/src/com/android/sensor/ArCoreMultiSensorFinder.java
+++ /dev/null
@@ -1,486 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.sensor;
-
-import android.app.Activity;
-import android.content.Context;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.HandlerThread;
-import android.util.Log;
-
-import androidx.annotation.GuardedBy;
-import androidx.annotation.Nullable;
-import androidx.annotation.VisibleForTesting;
-
-import com.android.ranging.proto.MultiSensorFinderConfig;
-
-import java.time.Duration;
-import java.time.Instant;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.FutureTask;
-
-/**
- * A MultiSensorFinder implementation that uses ARCore as the source of odometry.
- *
- * <p>The ArCoreMultiSensorFinder can be in two states: stopped and started.
- *
- * <p>Finder can transition between the started and stopped state via the start() and stop()
- * methods. Any unrecoverable error or calling the delete method will transition finder to the
- * stopped state. Every time finder enters the stopped state it wipes the state and the algorithm
- * starts from scratch on a subsequent start. If finder encounters a recoverable error, it will
- * return a RECOVERING_FROM_* status, in which case finder will not enter the stopped state and will
- * continually provide feedback to the client on how to help it recover (e.g. the room is too dark).
- * Once finder recovers, it will start finding the beacon from scratch.
- *
- * <p>All algo work and listener processing (except ARCore odometry which has its own thread)
- * happens in a single thread, which can be user provided.
- */
-public class ArCoreMultiSensorFinder implements AndroidMultiSensorFinderInterface {
-
-    private static final String TAG = ArCoreMultiSensorFinder.class.getSimpleName();
-    private static final int DEFAULT_ODOMETRY_POLLING_RATE_HZ = 10;
-
-    private static final long INVALID_POINTER_ADDRESS = 0;
-
-    /**
-     * ARCore's checkAvailability method can return UNKNOWN_CHECKING, meaning that it is still
-     * waiting
-     * on network to figure out if ARCore is available for a particular device. In that case, we
-     * will
-     * wait 200 milliseconds before trying again.
-     */
-    private static final long CHECK_AVAILABILITY_RETRY_DELAY_DURATION = 200;
-
-    /**
-     * How long we will wait for ARCore's checkAvailability to return a result before we give up
-     * .
-     */
-    private static final Duration CHECK_AVAILABILITY_RETRY_TIMEOUT_DURATION = Duration.ofSeconds(2);
-
-    /**
-     * The thread in which all work (except ARCore work) is done if the user did not provide a
-     * handler.
-     */
-    @Nullable
-    private HandlerThread mHandlerThread;
-
-    /**
-     * Handler to the thread in which all work (except ARCore work) is done. This can be provided by
-     * the user during construction.
-     */
-    private Handler mProcessingThreadHandler;
-
-    /**
-     * A variable for controlling ARCore's requestInstall behaviour: On first call, ask the user to
-     * install preqrequisites if required, and do not ask again on subsequent calls.
-     */
-    private boolean userRequestedInstall = false;
-
-    private final MultiSensorFinderConfig mConfig;
-
-    // Used to indicate whether this class should run its own thread for processing, or use a
-    // handler
-    // that was provided by the client.
-    private final boolean processInOwnThread;
-
-    /**
-     * Although all processing is done in a single thread, the user can still call stop/delete
-     * methods
-     * from any threads they wish. This mutex is used to guard against that.
-     */
-    private final Object mutex = new Object();
-
-    private final long odometryPollingDelayMs;
-
-    private final SessionWithArCoreNative sessionWithArCoreNative;
-
-    // Tracks whether the odometry polling runnable is running or not. This is used to guard against
-    // the case where a stop and start are called in rapid succession, and the previous odometry
-    // polling runnable did not have time to stop.
-    @GuardedBy("mutex")
-    private boolean odometryPollingRunnableIsActive = false;
-
-    /**
-     * To avoid generating garbage, native methods will populate their results in this member
-     * variable.
-     */
-    @GuardedBy("mutex")
-    private Estimate latestEstimate = new Estimate();
-
-    /** Check whether finder has been started. */
-    @GuardedBy("mutex")
-    private boolean started = false;
-
-    @GuardedBy("mutex")
-    private long nativeSessionPointer = INVALID_POINTER_ADDRESS;
-
-    @GuardedBy("mutex")
-    private final List<MultiSensorFinderListener> listeners = new ArrayList<>();
-
-    // A runnable that polls odometry and feeds it to the algorithm to generate an Estimate. This
-    // runnable is executed repeatedly at odometryPollingDelayMs.
-    private final Runnable pollAndProcessOdometryInLooperRunnable =
-            this::pollAndProcessOdometryInLooper;
-
-    // This executor is used to execute the checkAvailability method, which may take up to
-    // CHECK_AVAILABILITY_RETRY_TIMEOUT_DURATION to execute.
-    private final ExecutorService executorService;
-
-    /**
-     * Constructs ArCoreMultiSensorFinder with a user provided handler to which all algorithm and
-     * listener processing tasks will be submitted.
-     */
-    public ArCoreMultiSensorFinder(
-            MultiSensorFinderConfig config,
-            Handler processingThreadHandler,
-            SessionWithArCoreNative sessionWithArCoreNative) {
-        this.mConfig = config;
-        this.executorService = Executors.newSingleThreadExecutor();
-        this.sessionWithArCoreNative = sessionWithArCoreNative;
-
-        if (processingThreadHandler == null) {
-            processInOwnThread = true;
-        } else {
-            processInOwnThread = false;
-            this.mHandlerThread = null;
-            this.mProcessingThreadHandler = processingThreadHandler;
-        }
-
-        if (config.getOdometryPollingRateHz() > 0.0) {
-            this.odometryPollingDelayMs = (long) (1000.0 / config.getOdometryPollingRateHz());
-        } else {
-            this.odometryPollingDelayMs = (long) (1000.0 / DEFAULT_ODOMETRY_POLLING_RATE_HZ);
-        }
-    }
-
-    /**
-     * Constructs ArCoreMultiSensorFinder which will create and use its own thread and associated
-     * handler to which all algorithm and listener processing tasks will be submitted.
-     */
-    public ArCoreMultiSensorFinder(MultiSensorFinderConfig config) {
-        this(config, null, new SessionWithArCoreNative());
-    }
-
-    // For testing purposes only. A constructor for passing in a mocked SessionWithArCoreNative.
-    @VisibleForTesting
-    public ArCoreMultiSensorFinder(
-            MultiSensorFinderConfig config,
-            SessionWithArCoreNative sessionWithArCoreNative) {
-        this(config, null, sessionWithArCoreNative);
-    }
-
-    @Override
-    public FutureTask<Boolean> checkAvailability(Context context) {
-        FutureTask<Boolean> future =
-                new FutureTask<>(
-                        () -> {
-                            Instant startTime = Instant.now();
-                            Instant deadline = startTime.plus(
-                                    CHECK_AVAILABILITY_RETRY_TIMEOUT_DURATION);
-
-//                            try {
-//                                while (Instant.now().isBefore(deadline)) {
-//                                    ArCoreApk.Availability availability =
-//                                            ArCoreApk.getInstance().checkAvailability(context);
-//                                    if (availability.isTransient()) {
-//                                        // Wait until we get a response.
-//                                        TimeUnit.MILLISECONDS.sleep
-//                                        (CHECK_AVAILABILITY_RETRY_DELAY_DURATION);
-//                                    } else {
-//                                        return availability.isSupported();
-//                                    }
-//                                }
-//                            } catch (InterruptedException e) {
-//                                return false;
-//                            }
-
-                            Log.w(TAG, "Deadline expired while checking for availability");
-                            return false;
-                        });
-
-        executorService.execute(future);
-        return future;
-    }
-
-    @Override
-    public InstallStatus requestInstall(Activity activity) {
-//        try {
-//            ArCoreApk.InstallStatus installStatus =
-//                    ArCoreApk.getInstance().requestInstall(activity, !userRequestedInstall);
-//            switch (installStatus) {
-//                case INSTALLED:
-//                    return InstallStatus.OK;
-//                case INSTALL_REQUESTED:
-//                    userRequestedInstall = true;
-//                    return InstallStatus.USER_PROMPTED_TO_INSTALL_DEPENDENCIES;
-//            }
-//            return InstallStatus.UNKNOWN_ERROR;
-//        } catch (UnavailableUserDeclinedInstallationException e) {
-//            return InstallStatus.USER_DECLINED_TO_INSTALL_DEPENDENCIES;
-//        } catch (UnavailableDeviceNotCompatibleException e) {
-//            return InstallStatus.DEVICE_INCOMPATIBLE;
-//        } catch (FatalException e) {
-//            return InstallStatus.UNKNOWN_ERROR;
-//        }
-        return InstallStatus.UNKNOWN_ERROR;
-    }
-
-    @Override
-    public Status start(Context context) {
-        synchronized (mutex) {
-            if (started) {
-                return Status.OK;
-            }
-
-            // Create and start the processing thread if it has not already been started.
-            if (processInOwnThread && this.mHandlerThread == null) {
-                this.mHandlerThread = new HandlerThread("MultiSensorFinder");
-                this.mHandlerThread.start();
-                this.mProcessingThreadHandler = new Handler(this.mHandlerThread.getLooper());
-            }
-
-            // Create the session if it hasn't already been created.
-            if (nativeSessionPointer == INVALID_POINTER_ADDRESS) {
-                nativeSessionPointer = sessionWithArCoreNative.createSession(mConfig.toByteArray());
-            }
-
-            if (nativeSessionPointer == INVALID_POINTER_ADDRESS) {
-                Log.w(TAG, "Could not create session.");
-                return Status.UNKNOWN_ERROR;
-            }
-
-            // Start the session.
-            Status status = sessionWithArCoreNative.start(nativeSessionPointer, context);
-            if (status != Status.OK) {
-                Log.w(TAG, "Could not start session: " + status);
-                return status;
-            }
-            started = true;
-
-            // Start odometry polling loop if it is not already running.
-            if (!odometryPollingRunnableIsActive) {
-                mProcessingThreadHandler.post(pollAndProcessOdometryInLooperRunnable);
-                odometryPollingRunnableIsActive = true;
-            }
-        }
-
-        return Status.OK;
-    }
-
-    @Override
-    public void updateWithUwbMeasurement(double rangeMeters, long timestampNanos) {
-        mProcessingThreadHandler.post(
-                () -> updateWithUwbMeasurementInLooper(rangeMeters, timestampNanos));
-    }
-
-    @Override
-    public void updateWithWifiRttMeasurement(
-            double rangeMeters, double errorStdDevMeters, double rssiDbm, long timestampNanos) {
-        mProcessingThreadHandler.post(
-                () ->
-                        updateWithWifiRttMeasurementInLooper(
-                                rangeMeters, errorStdDevMeters, rssiDbm, timestampNanos));
-    }
-
-    @Override
-    public void subscribeToEstimates(MultiSensorFinderListener listener) {
-        synchronized (mutex) {
-            listeners.add(listener);
-        }
-    }
-
-    @Override
-    public Status stop() {
-        synchronized (mutex) {
-            if (!started) {
-                return Status.OK;
-            }
-
-            Status status = sessionWithArCoreNative.stop(nativeSessionPointer);
-            if (status != Status.OK) {
-                Log.w(TAG, "Could not stop session: " + status);
-            }
-            started = false;
-            return status;
-        }
-    }
-
-    @Override
-    public void delete() {
-        synchronized (mutex) {
-            if (nativeSessionPointer != INVALID_POINTER_ADDRESS) {
-                Status status = stop();
-                if (status != Status.OK) {
-                    Log.w(TAG, "Could not stop session: " + status);
-                }
-                sessionWithArCoreNative.deleteSession(nativeSessionPointer);
-                nativeSessionPointer = INVALID_POINTER_ADDRESS;
-            }
-
-            if (mHandlerThread != null) {
-                mHandlerThread.quit();
-                mHandlerThread = null;
-            }
-        }
-    }
-
-    @GuardedBy("mutex")
-    private void publishEstimate(Estimate estimate) {
-        for (MultiSensorFinderListener listener : listeners) {
-            listener.onUpdatedEstimate(estimate);
-        }
-    }
-
-    // A method that polls odometry at regular intervals and uses to it generate Estimates. This
-    // is intended to be called with other processing functions in one looper to avoid issues with
-    // multi-threading.
-    private void pollAndProcessOdometryInLooper() {
-        synchronized (mutex) {
-            if (!started) {
-                odometryPollingRunnableIsActive = false;
-                return;
-            }
-
-            // Attempt to update the estimate with new odometry data.
-            sessionWithArCoreNative.pollAndProcessOdometryUpdate(nativeSessionPointer);
-            sessionWithArCoreNative.getEstimate(nativeSessionPointer, latestEstimate);
-
-            // Publish estimate to all listeners.
-            if (latestEstimate.getStatus() != Status.ESTIMATE_NOT_AVAILABLE) {
-                publishEstimate(latestEstimate);
-            }
-
-            checkForErrors(latestEstimate);
-        }
-
-        mProcessingThreadHandler.postDelayed(
-                pollAndProcessOdometryInLooperRunnable, odometryPollingDelayMs);
-    }
-
-    private void updateWithUwbMeasurementInLooper(double rangeMeters, long timestampNanos) {
-        synchronized (mutex) {
-            if (!started) {
-                return;
-            }
-            sessionWithArCoreNative.updateWithUwbMeasurement(
-                    nativeSessionPointer, rangeMeters, timestampNanos);
-
-            sessionWithArCoreNative.getEstimate(nativeSessionPointer, latestEstimate);
-            if (latestEstimate.getStatus() != Status.ESTIMATE_NOT_AVAILABLE) {
-                publishEstimate(latestEstimate);
-            }
-
-            checkForErrors(latestEstimate);
-        }
-    }
-
-    private void updateWithWifiRttMeasurementInLooper(
-            double rangeMeters, double errorStdDevMeters, double rssiDbm, long timestampNanos) {
-        synchronized (mutex) {
-            if (!started) {
-                return;
-            }
-            sessionWithArCoreNative.updateWithWifiRttMeasurement(
-                    nativeSessionPointer, rangeMeters, errorStdDevMeters, rssiDbm, timestampNanos);
-
-            sessionWithArCoreNative.getEstimate(nativeSessionPointer, latestEstimate);
-            if (latestEstimate.getStatus() != Status.ESTIMATE_NOT_AVAILABLE) {
-                publishEstimate(latestEstimate);
-            }
-
-            checkForErrors(latestEstimate);
-        }
-    }
-
-    /**
-     * Checks if the latest estimate indicated an error, and transitions finder to stopped state if
-     * so.
-     */
-    @GuardedBy("mutex")
-    private void checkForErrors(Estimate estimate) {
-        // If we got anything but OK, ESTIMATE_NOT_AVAILABLE, or RECOVERING_*, that means there
-        // was an
-        // error, and we should quit.
-        if (estimate.getStatus() == Status.OK
-                || estimate.getStatus() == Status.ESTIMATE_NOT_AVAILABLE
-                || estimate.getStatus() == Status.RECOVERING_FROM_FAILURE_DUE_TO_INSUFFICIENT_LIGHT
-                || estimate.getStatus() == Status.RECOVERING_FROM_FAILURE_DUE_TO_EXCESSIVE_MOTION
-                || estimate.getStatus()
-                == Status.RECOVERING_FROM_FAILURE_DUE_TO_INSUFFICIENT_FEATURES
-                || estimate.getStatus()
-                == Status.RECOVERING_FROM_FAILURE_DUE_TO_CAMERA_UNAVAILABILITY
-                || estimate.getStatus()
-                == Status.RECOVERING_FROM_FAILURE_DUE_TO_BAD_ODOMETRY_STATE) {
-            return;
-        }
-        Status unused = stop();
-    }
-
-    @Override
-    public void onActivityCreated(Activity activity, Bundle bundle) {
-    }
-
-    @Override
-    public void onActivityStarted(Activity activity) {
-    }
-
-    @Override
-    public void onActivityResumed(Activity activity) {
-    }
-
-    public void onActivityResumeFragments(Activity activity) {
-    }
-
-    @Override
-    public void onActivitySaveInstanceState(Activity activity, Bundle bundle) {
-    }
-
-    @Override
-    public void onActivityStopped(Activity activity) {
-    }
-
-    @Override
-    public void onActivityPaused(Activity activity) {
-        Status unused = stop();
-    }
-
-    @Override
-    public void onActivityDestroyed(Activity activity) {
-        delete();
-    }
-
-    // For test purposes only. The estimate object is updated on the native side, which is mocked
-    // out
-    // for tests.
-    @VisibleForTesting
-    public void setEstimate(Estimate estimate) {
-        synchronized (mutex) {
-            latestEstimate = estimate;
-        }
-    }
-
-    @VisibleForTesting
-    public boolean isStarted() {
-        synchronized (mutex) {
-            return started;
-        }
-    }
-}
diff --git a/generic_ranging/src/com/android/sensor/Estimate.java b/generic_ranging/src/com/android/sensor/Estimate.java
deleted file mode 100644
index f1ed841e..00000000
--- a/generic_ranging/src/com/android/sensor/Estimate.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.sensor;
-
-/**
- * Estimate of range and bearing returned by Finder. This is in 1:1 correspondence with
- * location.bluemoon.Estimate proto. This class is usually populated from the native side.
- */
-public class Estimate {
-
-    private Status status;
-
-    private double rangeM;
-
-    private double rangeErrorStdDevM;
-
-    // The bearing is with respect to the device Y-axis, positive ccw.
-    private double bearingRad;
-
-    private double bearingErrorStdDevRad;
-
-    private double estimatedBeaconPositionErrorStdDevM;
-
-    private long timestampNanos;
-
-    /** Create an "empty" estimate. */
-    public Estimate() {
-        status = Status.UNKNOWN_ERROR;
-        rangeM = 0.0;
-        rangeErrorStdDevM = 0.0;
-        bearingRad = 0.0;
-        bearingErrorStdDevRad = 0.0;
-        estimatedBeaconPositionErrorStdDevM = 0.0;
-        timestampNanos = 0;
-    }
-
-    public void setStatus(Status status) {
-        this.status = status;
-    }
-
-    public void setRangeM(double rangeM) {
-        this.rangeM = rangeM;
-    }
-
-    public void setRangeErrorStdDevM(double rangeErrorStdDevM) {
-        this.rangeErrorStdDevM = rangeErrorStdDevM;
-    }
-
-    public void setBearingRad(double bearingRad) {
-        this.bearingRad = bearingRad;
-    }
-
-    public void setBearingErrorStdDevRad(double bearingErrorStdDevRad) {
-        this.bearingErrorStdDevRad = bearingErrorStdDevRad;
-    }
-
-    public void setEstimatedBeaconPositionErrorStdDevM(double estimatedBeaconPositionErrorStdDevM) {
-        this.estimatedBeaconPositionErrorStdDevM = estimatedBeaconPositionErrorStdDevM;
-    }
-
-    public void setTimestampNanos(long timestampNanos) {
-        this.timestampNanos = timestampNanos;
-    }
-
-    public Status getStatus() {
-        return status;
-    }
-
-    public double getRangeM() {
-        return rangeM;
-    }
-
-    public double getRangeErrorStdDevM() {
-        return rangeErrorStdDevM;
-    }
-
-    /** The bearing is with respect to the device Y-axis, positive ccw. */
-    public double getBearingRad() {
-        return bearingRad;
-    }
-
-    public double getBearingErrorStdDevRad() {
-        return bearingErrorStdDevRad;
-    }
-
-    public double getEstimatedBeaconPositionErrorStdDevM() {
-        return estimatedBeaconPositionErrorStdDevM;
-    }
-
-    public long getTimestampNanos() {
-        return timestampNanos;
-    }
-}
\ No newline at end of file
diff --git a/generic_ranging/src/com/android/sensor/InstallStatus.java b/generic_ranging/src/com/android/sensor/InstallStatus.java
deleted file mode 100644
index a80e7801..00000000
--- a/generic_ranging/src/com/android/sensor/InstallStatus.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.sensor;
-
-/** The status returned by MultiSensorFinder when requestInstall was called. */
-public enum InstallStatus {
-    /** Everything is installed and start can be called. */
-    OK,
-    /**
-     * The activity was switched, and the user was prompted to install dependencies. requestInstall
-     * must be called again before starting the session.
-     */
-    USER_PROMPTED_TO_INSTALL_DEPENDENCIES,
-    /**
-     * The user was asked to install dependencies, and the user rejected the request. The user will
-     * not be asked again until the app is restarted.
-     */
-    USER_DECLINED_TO_INSTALL_DEPENDENCIES,
-    /** ARCore cannot be installed on this device. */
-    DEVICE_INCOMPATIBLE,
-    UNKNOWN_ERROR
-}
diff --git a/generic_ranging/src/com/android/sensor/SessionWithArCoreNative.java b/generic_ranging/src/com/android/sensor/SessionWithArCoreNative.java
deleted file mode 100644
index a6db4cd2..00000000
--- a/generic_ranging/src/com/android/sensor/SessionWithArCoreNative.java
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.sensor;
-
-import android.content.Context;
-
-/** This class contains the Jave methods corresponding to Finder native APIs. */
-public class SessionWithArCoreNative {
-    /**
-     * The native library is loaded in the constructor so that the load can be mocked out in tests.
-     */
-    public SessionWithArCoreNative() {
-        System.loadLibrary("precisionfindingsessionwitharcorejni");
-    }
-
-    /**
-     * Creates the session. The memory allocated by this method must be freed by calling
-     * deleteSession.
-     *
-     * @return A non-zero value if the session was successfully created, zero otherwise.
-     */
-    public native long createSession(byte[] config);
-
-    /**
-     * Starts consuming sensor data streams. Once started, the session can be provided with range
-     * measurements to produce estimates.
-     *
-     * <p>IMPORTANT: Before calling start, the user must ensure that ARCore is available, and all
-     * prerequisites have been installed. This is done by using the checkAvailability and
-     * requestInstall methods.
-     * https://developers.google.com/ar/reference/java/com/google/ar/core/ArCoreApk
-     */
-    public native Status start(long sessionPointer, Context context);
-
-    /**
-     * Stops consuming all sensor data streams. Calling start after stop will start the session from
-     * scratch.
-     */
-    public native Status stop(long sessionPointer);
-
-    /**
-     * Polls and uses the latest odometry from ARCore. The result of this call can be obtained by
-     * calling getEstimate.
-     */
-    public native void pollAndProcessOdometryUpdate(long sessionPointer);
-
-    /**
-     * Forwards a UWB measurement to the underlying estimator. The result of this call can be
-     * obtained
-     * by calling getEstimate.
-     */
-    public native void updateWithUwbMeasurement(
-            long sessionPointer, double range, long timestampNanos);
-
-    /**
-     * Forwards a Wifi-RTT measurement to the underlying estimator. The result of this call can be
-     * obtained by calling getEstimate.
-     */
-    public native void updateWithWifiRttMeasurement(
-            long sessionPointer, double rangeM, double stdDevM, double rssi, long timestampNanos);
-
-    /**
-     * Returns the result of the latest call to pollAndProcessOdometryUpdate,
-     * updateWithUwbMeasurement, or updateWithWifiRttMeasurement.
-     */
-    public native void getEstimate(long sessionPointer, Estimate estimate);
-
-    /** Frees all native memory allocated by this session. */
-    public native void deleteSession(long sessionPointer);
-}
diff --git a/generic_ranging/src/com/android/sensor/Status.java b/generic_ranging/src/com/android/sensor/Status.java
deleted file mode 100644
index a415ca49..00000000
--- a/generic_ranging/src/com/android/sensor/Status.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.sensor;
-
-public enum Status {
-    /** An estimate was successfully computed. */
-    OK,
-    /** Could not produce an estimate. For example, no synchronized set of data is available. */
-    ESTIMATE_NOT_AVAILABLE,
-    /** The filter has diverged and is attempting to recover. */
-    RECOVERING,
-    /**
-     * Tracking failed due to insufficient light. This can occur when using camera based odometry.
-     * The
-     * filter will automatically recover and produce an estimate when possible.
-     */
-    RECOVERING_FROM_FAILURE_DUE_TO_INSUFFICIENT_LIGHT,
-    /**
-     * Tracking failed due to excessive motion. The filter will automatically recover and produce an
-     * estimate when possible.
-     */
-    RECOVERING_FROM_FAILURE_DUE_TO_EXCESSIVE_MOTION,
-    /**
-     * Tracking failed due to insufficient features in the camera images. This can occur when using
-     * camera based odometry. The filter will automatically recover and produce an estimate when
-     * possible.
-     */
-    RECOVERING_FROM_FAILURE_DUE_TO_INSUFFICIENT_FEATURES,
-    /**
-     * Tracking failed because something else is using the camera. Tracking will recover
-     * automatically, but with a new origin.
-     */
-    RECOVERING_FROM_FAILURE_DUE_TO_CAMERA_UNAVAILABILITY,
-    /**
-     * Tracking failed due to a bad odometry state. The filter will automatically recover and
-     * produce
-     * an estimate when possible.
-     */
-    RECOVERING_FROM_FAILURE_DUE_TO_BAD_ODOMETRY_STATE,
-    /** Odometry failed and cannot be recovered. */
-    ODOMETRY_ERROR,
-    /** The beacon is probably moving, and so cannot be tracked. */
-    BEACON_MOVING_ERROR,
-    /** The configuration file contains an error and Finder can't be started. */
-    CONFIGURATION_ERROR,
-    /** Permissions not granted to required sensors. */
-    SENSOR_PERMISSION_DENIED_ERROR,
-    UNKNOWN_ERROR,
-}
\ No newline at end of file
diff --git a/generic_ranging/tests/multidevices/lib/generic_ranging_decorator.py b/generic_ranging/tests/multidevices/lib/generic_ranging_decorator.py
deleted file mode 100644
index ab1d6392..00000000
--- a/generic_ranging/tests/multidevices/lib/generic_ranging_decorator.py
+++ /dev/null
@@ -1,109 +0,0 @@
-import time
-from typing import List
-from mobly.controllers import android_device
-from mobly.controllers.android_device_lib import jsonrpc_client_base
-from mobly.snippet import errors
-from uwb import uwb_ranging_params
-
-CALLBACK_WAIT_TIME_SEC = 3
-STOP_CALLBACK_WAIT_TIME_SEC = 6
-
-
-class GenericRangingDecorator:
-
-  def __init__(self, ad: android_device.AndroidDevice):
-    """Initialize the ranging device.
-
-    Args:
-        ad: android device object
-    """
-    self.ad = ad
-    self._event_handlers = {}
-    self.log = self.ad.log
-
-  def start_uwb_ranging_session(
-      self, params: uwb_ranging_params.UwbRangingParams
-  ):
-    handler = self.ad.ranging.startUwbRanging(params.to_dict())
-    self._event_handlers[params.session_id] = handler
-    self.verify_ranging_event_received("Started", params.session_id)
-
-  def stop_uwb_ranging_session(self, session_id: int):
-    self.ad.ranging.stopUwbRanging(session_id)
-    self.verify_ranging_event_received("Stopped", session_id)
-    self._event_handlers.pop(session_id)
-
-  def clear_all_uwb_ranging_sessions(self):
-    for session_id in self._event_handlers.keys():
-      self.ad.ranging.stopUwbRanging(session_id)
-      self.clear_ranging_callback_events(session_id)
-
-    self._event_handlers.clear()
-
-  def clear_ranging_callback_events(self, session_id: int):
-    """Clear 'GenericRangingCallback' events from EventCache.
-
-    Args:
-      session_id: ranging session id.
-    """
-    self._event_handlers[session_id].getAll("GenericRangingCallback")
-
-  def verify_ranging_event_received(
-      self,
-      ranging_event: str,
-      session_id: int,
-      timeout_s: int = CALLBACK_WAIT_TIME_SEC,
-  ) -> bool:
-    """Verifies that the expected event is received before a timeout.
-
-    Args:
-      ranging_event: expected ranging event.
-      session: ranging session.
-      timeout_s: timeout in seconds.
-
-    Returns:
-      True if the expected event was received.
-    """
-    handler = self._event_handlers[session_id]
-
-    start_time = time.time()
-    while time.time() - start_time < timeout_s:
-      try:
-        event = handler.waitAndGet("GenericRangingCallback", timeout=timeout_s)
-        event_received = event.data["genericRangingSessionEvent"]
-        self.ad.log.debug("Received event - %s" % event_received)
-        if event_received == ranging_event:
-          self.ad.log.debug(
-              f"Received event {ranging_event} in"
-              f" {round(time.time() - start_time, 2)} secs"
-          )
-          self.clear_ranging_callback_events(session_id)
-          return True
-      except errors.CallbackHandlerTimeoutError:
-        self.log.warn("Failed to receive 'RangingSessionCallback' event")
-
-    return False
-
-  def verify_uwb_peer_found(
-      self,
-      addr: List[int],
-      session_id: int,
-      timeout_s: int = CALLBACK_WAIT_TIME_SEC,
-  ):
-    """Verifies that the UWB peer is found before a timeout.
-
-    Args:
-      addr: peer address.
-      session_id: ranging session id.
-      timeout_s: timeout in seconds.
-
-    Returns:
-      True if the peer was found.
-    """
-    start_time = time.time()
-    while time.time() - start_time < timeout_s:
-      self.verify_ranging_event_received("ReportReceived", session_id)
-      if self.ad.ranging.verifyUwbPeerFound(addr, session_id):
-        return True
-
-    return False
diff --git a/generic_ranging/tests/multidevices/snippet/GenericRangingSnippet.java b/generic_ranging/tests/multidevices/snippet/GenericRangingSnippet.java
deleted file mode 100644
index 5d6d8d55..00000000
--- a/generic_ranging/tests/multidevices/snippet/GenericRangingSnippet.java
+++ /dev/null
@@ -1,342 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package multidevices.snippet.ranging;
-
-import android.app.UiAutomation;
-import android.content.Context;
-import android.net.ConnectivityManager;
-import android.os.RemoteException;
-import android.util.Log;
-import android.uwb.UwbManager;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.test.platform.app.InstrumentationRegistry;
-
-import com.android.ranging.RangingConfig;
-import com.android.ranging.RangingData;
-import com.android.ranging.RangingParameters;
-import com.android.ranging.RangingParameters.DeviceRole;
-import com.android.ranging.RangingSession;
-import com.android.ranging.RangingSessionImpl;
-import com.android.ranging.RangingTechnology;
-import com.android.ranging.fusion.DataFusers;
-import com.android.ranging.fusion.FilteringFusionEngine;
-import com.android.ranging.uwb.UwbAdapter;
-import com.android.ranging.uwb.UwbParameters;
-import com.android.ranging.uwb.backend.internal.UwbAddress;
-import com.android.ranging.uwb.backend.internal.UwbComplexChannel;
-import com.android.ranging.uwb.backend.internal.UwbRangeDataNtfConfig;
-
-import com.google.android.mobly.snippet.Snippet;
-import com.google.android.mobly.snippet.event.EventCache;
-import com.google.android.mobly.snippet.event.SnippetEvent;
-import com.google.android.mobly.snippet.rpc.AsyncRpc;
-import com.google.android.mobly.snippet.rpc.Rpc;
-import com.google.common.util.concurrent.ListeningExecutorService;
-import com.google.common.util.concurrent.MoreExecutors;
-
-import dagger.Lazy;
-
-import org.json.JSONArray;
-import org.json.JSONException;
-import org.json.JSONObject;
-
-import java.lang.reflect.Method;
-import java.time.Duration;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Optional;
-import java.util.concurrent.Executors;
-
-public class GenericRangingSnippet implements Snippet {
-    private static final String TAG = "GenericRangingSnippet";
-
-    private final Context mContext;
-    private final ConnectivityManager mConnectivityManager;
-    private final UwbManager mUwbManager;
-    private final ListeningExecutorService mExecutor = MoreExecutors.listeningDecorator(
-            Executors.newSingleThreadExecutor());
-    private final EventCache mEventCache = EventCache.getInstance();
-    private static final HashMap<String, RangingSessionImpl> sRangingHashMap =
-            new HashMap<>();
-    private static final HashMap<String, GenericRangingCallback> sRangingCallbackHashMap =
-            new HashMap<>();
-
-    public GenericRangingSnippet() throws Throwable {
-        adoptShellPermission();
-        mContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
-        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
-        mUwbManager = mContext.getSystemService(UwbManager.class);
-    }
-
-    private static class UwbManagerSnippetException extends Exception {
-
-        UwbManagerSnippetException(String msg) {
-            super(msg);
-        }
-
-        UwbManagerSnippetException(String msg, Throwable err) {
-            super(msg, err);
-        }
-    }
-
-    private void adoptShellPermission() throws Throwable {
-        UiAutomation uia = InstrumentationRegistry.getInstrumentation().getUiAutomation();
-        uia.adoptShellPermissionIdentity();
-        try {
-            Class<?> cls = Class.forName("android.app.UiAutomation");
-            Method destroyMethod = cls.getDeclaredMethod("destroy");
-            destroyMethod.invoke(uia);
-        } catch (ReflectiveOperationException e) {
-            throw new UwbManagerSnippetException("Failed to cleaup Ui Automation", e);
-        }
-    }
-
-    private enum Event {
-        Invalid(0),
-        Started(1 << 0),
-        Stopped(1 << 1),
-        ReportReceived(1 << 2),
-        EventAll(
-                1 << 0
-                        | 1 << 1
-                        | 1 << 2
-        );
-
-        private final int mType;
-
-        Event(int type) {
-            mType = type;
-        }
-
-        private int getType() {
-            return mType;
-        }
-    }
-
-    class GenericRangingCallback implements RangingSession.Callback {
-        private String mId;
-        private RangingData mLastDataReceived = null;
-
-        GenericRangingCallback(String id, int events) {
-            mId = id;
-        }
-
-        public Optional<RangingData> getLastDataReceived() {
-            return Optional.ofNullable(mLastDataReceived);
-        }
-
-        private void handleEvent(Event e) {
-            Log.d(TAG, "GenericRangingCallback#handleEvent() for " + e.toString());
-            SnippetEvent event = new SnippetEvent(mId, "GenericRangingCallback");
-            event.getData().putString("genericRangingSessionEvent", e.toString());
-            mEventCache.postEvent(event);
-        }
-
-        @Override
-        public void onStarted(@Nullable RangingTechnology technology) {
-            Log.d(TAG, "GenericRangingCallback#onStarted() called");
-            handleEvent(Event.Started);
-        }
-
-        @Override
-        public void onStopped(@Nullable RangingTechnology technology, @StoppedReason int reason) {
-            Log.d(TAG, "GenericRangingCallback#onStopped() called");
-            handleEvent(Event.Stopped);
-        }
-
-        @Override
-        public void onData(@NonNull RangingData data) {
-            Log.d(TAG, "GenericRangingCallback#onData() called");
-            mLastDataReceived = data;
-            handleEvent(Event.ReportReceived);
-        }
-    }
-
-    private RangingParameters generateRangingParameters(JSONObject j) throws JSONException {
-        if (j == null) {
-            return null;
-        }
-        List<UwbAddress> peerAddresses = new ArrayList<>();
-        if (j.has("peerAddresses")) {
-            JSONArray jArray = j.getJSONArray("peerAddresses");
-            UwbAddress[] destinationUwbAddresses = new UwbAddress[jArray.length()];
-            for (int i = 0; i < jArray.length(); i++) {
-                destinationUwbAddresses[i] = UwbAddress.fromBytes(
-                        convertJSONArrayToByteArray(jArray.getJSONArray(i)));
-            }
-            peerAddresses = Arrays.asList(destinationUwbAddresses);
-        }
-        UwbComplexChannel uwbComplexChannel = new UwbComplexChannel(9, 11);
-        UwbRangeDataNtfConfig rangeDataNtfConfig = new UwbRangeDataNtfConfig.Builder()
-                .setRangeDataConfigType(j.getInt("rangeDataConfigType"))
-                .build();
-
-        UwbParameters uwbParams = new UwbParameters(
-                j.getInt("configType"),
-                j.getInt("sessionId"),
-                j.getInt("subSessionId"),
-                convertJSONArrayToByteArray(j.getJSONArray("sessionKeyInfo")),
-                j.has("subSessionKeyInfo")
-                        ? convertJSONArrayToByteArray(j.getJSONArray("subSessionKeyInfo"))
-                        : null,
-                uwbComplexChannel,
-                peerAddresses,
-                j.getInt("updateRateType"),
-                rangeDataNtfConfig,
-                j.getInt("slotDurationMillis"),
-                j.getBoolean("isAoaDisabled")
-        );
-        DeviceRole role = j.getInt("deviceRole") == 0
-                ? DeviceRole.CONTROLEE : DeviceRole.CONTROLLER;
-        return new RangingParameters.Builder(role).useUwb(uwbParams).build();
-    }
-
-    private byte[] convertJSONArrayToByteArray(JSONArray jArray) throws JSONException {
-        if (jArray == null) {
-            return null;
-        }
-        byte[] bArray = new byte[jArray.length()];
-        for (int i = 0; i < jArray.length(); i++) {
-            bArray[i] = (byte) jArray.getInt(i);
-        }
-        return bArray;
-    }
-
-    private static String getUwbSessionKeyFromId(int sessionId) {
-        return "uwb_session_" + sessionId;
-    }
-
-    @AsyncRpc(description = "Start UWB ranging session")
-    public void startUwbRanging(String callbackId, JSONObject config)
-            throws JSONException, RemoteException {
-        int deviceRole = config.getInt("deviceRole");
-        UwbAdapter uwbAdapter = null;
-        if (deviceRole == 0) {
-            logInfo("Starting controlee session");
-            uwbAdapter = new UwbAdapter(mContext, mExecutor, DeviceRole.CONTROLEE);
-        } else {
-            logInfo("Starting controller session");
-            uwbAdapter = new UwbAdapter(mContext, mExecutor, DeviceRole.CONTROLLER);
-        }
-        uwbAdapter.setLocalAddressForTesting(UwbAddress.fromBytes(
-                convertJSONArrayToByteArray(config.getJSONArray("deviceAddress"))));
-
-        // Test forces channel to 9 and preamble to 11
-        uwbAdapter.setComplexChannelForTesting();
-        try {
-            uwbAdapter.getComplexChannel().get();
-        } catch (Exception e) {
-            Log.w(TAG, "Could not get complex channel for uwb adapter");
-            throw new RuntimeException(e);
-        }
-
-        //TODO: Make this configurable
-        //    private Provider<PrecisionRanging.Factory> mRangingFactory;
-        RangingConfig rangingConfig =
-                RangingConfig.builder()
-                        .setUseFusingAlgorithm(false)
-                        .setMaxUpdateInterval(Duration.ofMillis(200))
-                        .setFusionAlgorithmDriftTimeout(Duration.ofSeconds(1))
-                        .setNoUpdateTimeout(Duration.ofSeconds(2))
-                        .setInitTimeout(Duration.ofSeconds(3))
-                        .build();
-
-        FilteringFusionEngine fusionEngine =
-                new FilteringFusionEngine(
-                        new DataFusers.PreferentialDataFuser(RangingTechnology.UWB));
-
-        RangingSessionImpl session = new RangingSessionImpl(
-                mContext, rangingConfig, fusionEngine,
-                Executors.newSingleThreadScheduledExecutor(),
-                MoreExecutors.listeningDecorator(Executors.newSingleThreadExecutor()));
-
-        session.useAdapterForTesting(RangingTechnology.UWB, uwbAdapter);
-
-        GenericRangingCallback genericRangingCallback =
-                new GenericRangingCallback(callbackId, Event.EventAll.getType());
-        String uwbSessionKey = getUwbSessionKeyFromId(config.getInt("sessionId"));
-        sRangingHashMap.put(uwbSessionKey, session);
-        session.start(generateRangingParameters(config), genericRangingCallback);
-        sRangingCallbackHashMap.put(uwbSessionKey, genericRangingCallback);
-    }
-
-    @Rpc(description = "Stop UWB ranging session")
-    public void stopUwbRanging(int sessionId) throws JSONException {
-        String uwbSessionKey = getUwbSessionKeyFromId(sessionId);
-        if (sRangingHashMap.containsKey(uwbSessionKey)) {
-            sRangingHashMap.get(uwbSessionKey).stop();
-        }
-    }
-
-    @Rpc(description = "Check whether the last report included UWB data from the specified address")
-    public boolean verifyUwbPeerFound(JSONArray peerAddress, int sessionId)
-            throws JSONException {
-        GenericRangingCallback callback =
-                sRangingCallbackHashMap.get(getUwbSessionKeyFromId(sessionId));
-        if (callback == null) {
-            throw new IllegalArgumentException("Could not find session with id " + sessionId);
-        }
-
-        Optional<RangingData> data = callback.getLastDataReceived();
-        if (data.isEmpty()) {
-            Log.i(TAG, "No data has been received yet, or the last data received was empty");
-            return false;
-        }
-
-        byte[] address = convertJSONArrayToByteArray(peerAddress);
-        if (Arrays.equals(data.get().getPeerAddress(), address)) {
-            return true;
-        } else {
-            Log.i(TAG, "Last ranging report did not include any data from peer "
-                    + Arrays.toString(address));
-            return false;
-        }
-    }
-
-    @Rpc(description = "Check whether uwb is enabled")
-    public boolean isUwbEnabled() {
-        return mUwbManager.isUwbEnabled();
-    }
-
-    @Rpc(description = "Set airplane mode")
-    public void setAirplaneMode(boolean enabled) {
-        mConnectivityManager.setAirplaneMode(enabled);
-    }
-
-    @Rpc(description = "Log info level message to device logcat")
-    public void logInfo(String message) throws JSONException {
-        com.google.android.mobly.snippet.util.Log.i(TAG + message);
-    }
-
-    private static class CustomUwbAdapterProvider implements Lazy<UwbAdapter> {
-        private final UwbAdapter mUwbAdapter;
-
-        CustomUwbAdapterProvider(UwbAdapter uwbAdapter) {
-            this.mUwbAdapter = uwbAdapter;
-        }
-
-        @Override
-        public UwbAdapter get() {
-            return mUwbAdapter;
-        }
-    }
-}
-
diff --git a/generic_ranging/tests/multidevices/test_utils/uwb_test_utils.py b/generic_ranging/tests/multidevices/test_utils/uwb_test_utils.py
deleted file mode 100644
index f8b5cd79..00000000
--- a/generic_ranging/tests/multidevices/test_utils/uwb_test_utils.py
+++ /dev/null
@@ -1,154 +0,0 @@
-#  Copyright (C) 2024 The Android Open Source Project
-#
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#
-#       http://www.apache.org/licenses/LICENSE-2.0
-#
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
-"""Test utils for UWB."""
-
-import logging
-import time
-from typing import List
-
-from lib import generic_ranging_decorator
-from mobly import asserts
-from mobly.controllers import android_device
-
-WAIT_TIME_SEC = 3
-
-
-def assert_uwb_peer_found(
-    device: generic_ranging_decorator.GenericRangingDecorator,
-    peer_addr: List[int],
-    session_id: int,
-    timeout_s=WAIT_TIME_SEC,
-):
-  """Asserts that the UWB peer was found.
-
-  Args:
-    device: uwb ranging device.
-    peer_addr: uwb peer device address.
-    session_d: session id.
-    timeout_s: timeout in seconds.
-
-  Throws:
-      TimeoutError if peer could not be found
-  """
-  device.ad.log.info(f"Looking for peer {peer_addr}...")
-  if not device.verify_uwb_peer_found(
-      peer_addr, session_id, timeout_s=timeout_s
-  ):
-    raise TimeoutError(
-        f"Peer {peer_addr} not found before timeout expiry of"
-        f" {timeout_s} seconds"
-    )
-
-
-def initialize_uwb_country_code_if_necessary(ad: android_device.AndroidDevice):
-  """Sets UWB country code to US if the device does not have it set.
-
-  Note: This intentionally relies on an unstable API (shell command) since we
-  don't want to expose an API that allows users to circumvent the UWB
-  regulatory requirements.
-
-  Args:
-    ad: android device object.
-    handler: callback handler.
-  """
-  # Wait to see if UWB state is reported as enabled. If not, this could be
-  # because the country code is not set. Try forcing the country code in that
-  # case.
-  if is_uwb_enabled(ad, timeout_s=120):
-    return
-
-  try:
-    ad.adb.shell(["cmd", "uwb", "force-country-code", "enabled", "US"])
-  except adb.AdbError:
-    logging.warning("Unable to force country code")
-
-  # Unable to get UWB enabled even after setting country code, abort!
-  asserts.fail(not is_uwb_enabled(ad, timeout_s=120), "Uwb is not enabled")
-
-
-def is_uwb_enabled(
-    ad: android_device.AndroidDevice, timeout_s=WAIT_TIME_SEC
-) -> bool:
-  """Checks if UWB becomes enabled before the provided timeout_s"""
-  start_time = time.time()
-  while not ad.ranging.isUwbEnabled():
-    if time.time() - start_time > timeout_s:
-      return False
-
-  return True
-
-
-def set_airplane_mode(ad: android_device.AndroidDevice, isEnabled: bool):
-  """Sets the airplane mode to the given state.
-
-  Args:
-    ad: android device object.
-    isEnabled: True for Airplane mode enabled, False for disabled.
-  """
-  ad.ranging.setAirplaneMode(isEnabled)
-  start_time = time.time()
-  while get_airplane_mode(ad) != isEnabled:
-    time.sleep(0.5)
-    if time.time() - start_time > WAIT_TIME_SEC:
-      asserts.fail(f"Failed to set airplane mode to: {isEnabled}")
-
-
-def get_airplane_mode(ad: android_device.AndroidDevice) -> bool:
-  """Gets the current airplane mode setting.
-
-  Args:
-    ad: android device object.
-
-  Returns:
-    True if airplane mode On, False for Off.
-  """
-  state = ad.adb.shell(["settings", "get", "global", "airplane_mode_on"])
-  return bool(int(state.decode().strip()))
-
-
-def set_screen_rotation_landscape(
-    ad: android_device.AndroidDevice, isLandscape: bool
-):
-  """Sets screen orientation to landscape or portrait mode.
-
-  Args:
-    ad: android device object.
-    isLandscape: True for landscape mode, False for potrait.
-  """
-  ad.adb.shell(["settings", "put", "system", "accelerometer_rotation", "0"])
-  ad.adb.shell([
-      "settings",
-      "put",
-      "system",
-      "user_rotation",
-      "1" if isLandscape else "0",
-  ])
-
-
-def set_snippet_foreground_state(
-    ad: android_device.AndroidDevice, isForeground: bool
-):
-  """Sets the snippet app's foreground/background state.
-
-  Args:
-    ad: android device object.
-    isForeground: True to move snippet to foreground, False for background.
-  """
-  ad.adb.shell([
-      "cmd",
-      "uwb",
-      "simulate-app-state-change",
-      "multidevices.snippet.ranging",
-      "foreground" if isForeground else "background",
-  ])
diff --git a/generic_ranging/tests/multidevices/uwb/uwb_ranging_params.py b/generic_ranging/tests/multidevices/uwb/uwb_ranging_params.py
deleted file mode 100644
index 44d46c28..00000000
--- a/generic_ranging/tests/multidevices/uwb/uwb_ranging_params.py
+++ /dev/null
@@ -1,167 +0,0 @@
-"""Class for UWB ranging parameters for testing."""
-
-import dataclasses
-from enum import IntEnum
-from typing import Any, Dict, List, Optional
-
-
-class Constants:
-  """Class for ranging parameter constants."""
-
-  class DeviceRole(IntEnum):
-    CONTROLEE = 0
-    CONTROLLER = 1
-
-  class ConfigType(IntEnum):
-    UNICAST_DS_TWR = 1
-    MULTICAST_DS_TWR = 2
-    PROVISIONED_UNICAST_DS_TWR = 4
-    PROVISIONED_MULTICAST_DS_TWR = 5
-    PROVISIONED_INDIVIDUAL_MULTICAST_DS_TWR = 7
-
-  class RangingUpdateRate(IntEnum):
-    AUTOMATIC = 1
-    INFREQUENT = 2
-    FREQUENT = 3
-
-  class SlotDuration(IntEnum):
-    MILLIS_1 = 1
-    MILLIS_2 = 2
-
-  class RangeDataConfigType(IntEnum):
-    """Distance-based notifications are not supported in tests-- only accepted values are ENABLE or DISABLE."""
-
-    DISABLE = 0
-    ENABLE = 1
-
-
-# TODO(b/349419138): Dead code
-@dataclasses.dataclass
-class UwbRangingReconfigureParams:
-  """Class for UWB ranging reconfigure parameters.
-
-  Attributes:
-    action: Type of reconfigure action.
-    address_list: new address list.
-    block_stride_length: block stride length
-    sub_session_id_list: provisioned sts sub session id list.
-    sub_session_key_list: provisioned sts sub session key list.
-  """
-
-  action: Optional[int] = None
-  address_list: Optional[List[List[int]]] = None
-  block_stride_length: Optional[int] = None
-  sub_session_id_list: Optional[List[int]] = None
-  sub_session_key_list: Optional[List[int]] = None
-
-  def to_dict(self) -> Dict[str, Any]:
-    """Returns UWB ranging reconfigure parameters in dictionary for sl4a.
-
-    Returns:
-      UWB ranging reconfigure parameters in dictionary.
-    """
-    reconfigure_params = {}
-    if self.address_list is not None:
-      reconfigure_params["action"] = self.action
-      reconfigure_params["addressList"] = self.address_list
-      if self.sub_session_id_list is not None:
-        reconfigure_params["subSessionIdList"] = self.sub_session_id_list
-      if self.sub_session_key_list is not None:
-        reconfigure_params["subSessionKeyList"] = self.sub_session_key_list
-    elif self.block_stride_length is not None:
-      reconfigure_params["blockStrideLength"] = self.block_stride_length
-    return reconfigure_params
-
-
-# TODO(b/349419138): Dead code
-@dataclasses.dataclass
-class UwbRangingControleeParams:
-  """Class for UWB ranging controlee parameters.
-
-  Attributes:
-    action: Type of reconfigure action.
-    address_list: new address list.
-    sub_session_id_list: provisioned sts sub session id list.
-    sub_session_key_list: provisioned sts sub session key list.
-  """
-
-  action: Optional[int] = None
-  address_list: Optional[List[List[int]]] = None
-  sub_session_id_list: Optional[List[int]] = None
-  sub_session_key_list: Optional[List[int]] = None
-
-  def to_dict(self) -> Dict[str, Any]:
-    """Returns UWB ranging controlee parameters in dictionary for sl4a.
-
-    Returns:
-      UWB ranging controlee parameters in dictionary.
-    """
-    controlee_params = {}
-    if self.action is not None:
-      controlee_params["action"] = self.action
-    if self.address_list is not None:
-      controlee_params["addressList"] = self.address_list
-    if self.sub_session_id_list is not None:
-      controlee_params["subSessionIdList"] = self.sub_session_id_list
-    if self.sub_session_key_list is not None:
-      controlee_params["subSessionKeyList"] = self.sub_session_key_list
-    return controlee_params
-
-
-@dataclasses.dataclass(kw_only=True)
-class UwbRangingParams:
-  """Class for Uwb ranging parameters."""
-
-  config_type: Constants.ConfigType
-  session_id: int
-  sub_session_id: int = 0
-  session_key_info: List[int] = dataclasses.field(
-      default_factory=lambda: [1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 6, 5, 4, 3, 2, 1]
-  )
-  sub_session_key_info: Optional[List[int]] = None
-  peer_addresses: List[List[int]]
-  update_rate_type: Constants.RangingUpdateRate = (
-      Constants.RangingUpdateRate.AUTOMATIC
-  )
-  range_data_config_type: Constants.RangeDataConfigType = (
-      Constants.RangeDataConfigType.ENABLE
-  )
-  slot_duration_millis: Constants.SlotDuration = Constants.SlotDuration.MILLIS_2
-  is_aoa_disabled: bool = False
-  device_address: List[int]
-  device_role: Constants.DeviceRole
-
-  def to_dict(self) -> Dict[str, Any]:
-    """Returns UWB ranging parameters in dictionary for sl4a.
-
-    Returns:
-      UWB ranging parameters in dictionary.
-    """
-    dict = {
-        "configType": self.config_type,
-        "sessionId": self.session_id,
-        "subSessionId": self.sub_session_id,
-        "sessionKeyInfo": self.session_key_info,
-        "peerAddresses": self.peer_addresses,
-        "updateRateType": self.update_rate_type,
-        "rangeDataConfigType": self.range_data_config_type,
-        "slotDurationMillis": self.slot_duration_millis,
-        "isAoaDisabled": self.is_aoa_disabled,
-        "deviceAddress": self.device_address,
-        "deviceRole": self.device_role,
-    }
-
-    if self.sub_session_key_info is not None:
-      dict["subSessionKeyInfo"] = self.sub_session_key_info
-
-    return dict
-
-  def update(self, **kwargs: Any):
-    """Updates the UWB parameters with the new values.
-
-    Args:
-      **kwargs: uwb attributes with new values.
-    """
-    for key, value in kwargs.items():
-      if hasattr(self, key):
-        setattr(self, key, value)
diff --git a/generic_ranging/tests/multidevices/uwb/uwb_tests.py b/generic_ranging/tests/multidevices/uwb/uwb_tests.py
deleted file mode 100644
index fa516f4f..00000000
--- a/generic_ranging/tests/multidevices/uwb/uwb_tests.py
+++ /dev/null
@@ -1,204 +0,0 @@
-#  Copyright (C) 2024 The Android Open Source Project
-#
-#  Licensed under the Apache License, Version 2.0 (the "License");
-#  you may not use this file except in compliance with the License.
-#  You may obtain a copy of the License at
-#
-#       http://www.apache.org/licenses/LICENSE-2.0
-#
-#  Unless required by applicable law or agreed to in writing, software
-#  distributed under the License is distributed on an "AS IS" BASIS,
-#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#  See the License for the specific language governing permissions and
-#  limitations under the License.
-import sys
-import time
-
-from lib import generic_ranging_decorator
-from lib import ranging_base_test
-from mobly import asserts
-from mobly import config_parser
-from mobly import suite_runner
-from test_utils import uwb_test_utils
-from uwb import uwb_ranging_params as params
-
-RESPONDER_STOP_CALLBACK_TIMEOUT = 60
-
-_TEST_CASES = (
-    "test_one_to_one_ranging",
-    "test_one_to_one_ranging_provisioned_sts",
-    "test_one_to_one_ranging_disable_range_data_ntf",
-)
-
-
-class RangingTest(ranging_base_test.RangingBaseTest):
-  """Tests for UWB Ranging APIs.
-
-  Attributes:
-
-  android_devices: list of android device objects.
-  """
-
-  def __init__(self, configs: config_parser.TestRunConfig):
-    """Init method for the test class.
-
-    Args:
-
-    configs: A config_parser.TestRunConfig object.
-    """
-    super().__init__(configs)
-    self.tests = _TEST_CASES
-
-  def setup_class(self):
-    super().setup_class()
-    self.uwb_devices = [
-        generic_ranging_decorator.GenericRangingDecorator(ad)
-        for ad in self.android_devices
-    ]
-    self.initiator, self.responder = self.uwb_devices
-    self.device_addresses = self.user_params.get(
-        "device_addresses", [[1, 2], [3, 4]]
-    )
-    self.initiator_addr, self.responder_addr = self.device_addresses
-    self.new_responder_addr = [4, 5]
-    # self.p_sts_sub_session_id = 11
-    # self.p_sts_sub_session_key = [
-    #     8, 7, 6, 5, 4, 3, 2, 1, 1, 2, 3, 4, 5, 6, 7, 8]
-    # self.block_stride_length = random.randint(1, 10)
-
-  def setup_test(self):
-    super().setup_test()
-    for uwb_device in self.uwb_devices:
-      uwb_test_utils.set_airplane_mode(uwb_device.ad, isEnabled=False)
-      uwb_test_utils.set_snippet_foreground_state(
-          uwb_device.ad, isForeground=True
-      )
-
-  def teardown_test(self):
-    super().teardown_test()
-    for uwb_device in self.uwb_devices:
-      uwb_device.clear_all_uwb_ranging_sessions()
-
-  ### Helpers ###
-
-  def _start_and_verify_mutual_ranging(
-      self,
-      initiator_params: params.UwbRangingParams,
-      responder_params: params.UwbRangingParams,
-      session_id: int,
-  ):
-    """Starts one-to-one ranging session between initiator and responder.
-
-    Args:
-        session_id: id to use for the ranging session.
-    """
-    self.initiator.start_uwb_ranging_session(initiator_params)
-    self.responder.start_uwb_ranging_session(responder_params)
-
-    uwb_test_utils.assert_uwb_peer_found(
-        self.initiator, self.responder_addr, session_id
-    )
-    uwb_test_utils.assert_uwb_peer_found(
-        self.responder, self.initiator_addr, session_id
-    )
-
-  ### Test Cases ###
-
-  def test_one_to_one_ranging(self):
-    """Verifies ranging with peer device, devices range for 10 seconds."""
-    initiator_params = params.UwbRangingParams(
-        config_type=params.Constants.ConfigType.UNICAST_DS_TWR,
-        session_id=5,
-        peer_addresses=[self.responder_addr],
-        device_address=self.initiator_addr,
-        device_role=params.Constants.DeviceRole.CONTROLLER,
-    )
-    responder_params = params.UwbRangingParams(
-        config_type=params.Constants.ConfigType.UNICAST_DS_TWR,
-        session_id=5,
-        peer_addresses=[self.initiator_addr],
-        device_address=self.responder_addr,
-        device_role=params.Constants.DeviceRole.CONTROLEE,
-    )
-    self._start_and_verify_mutual_ranging(
-        initiator_params, responder_params, session_id=5
-    )
-
-    time.sleep(10)
-
-    uwb_test_utils.assert_uwb_peer_found(
-        self.initiator, self.responder_addr, session_id=5
-    )
-    uwb_test_utils.assert_uwb_peer_found(
-        self.responder, self.initiator_addr, session_id=5
-    )
-
-    self.initiator.stop_uwb_ranging_session(session_id=5)
-    self.responder.stop_uwb_ranging_session(session_id=5)
-
-  def test_one_to_one_ranging_provisioned_sts(self):
-    """Verifies ranging with peer device using provisioned sts"""
-    initiator_params = params.UwbRangingParams(
-        config_type=params.Constants.ConfigType.PROVISIONED_UNICAST_DS_TWR,
-        session_id=5,
-        peer_addresses=[self.responder_addr],
-        device_address=self.initiator_addr,
-        device_role=params.Constants.DeviceRole.CONTROLLER,
-    )
-    responder_params = params.UwbRangingParams(
-        config_type=params.Constants.ConfigType.PROVISIONED_UNICAST_DS_TWR,
-        session_id=5,
-        peer_addresses=[self.initiator_addr],
-        device_address=self.responder_addr,
-        device_role=params.Constants.DeviceRole.CONTROLEE,
-    )
-
-    self._start_and_verify_mutual_ranging(
-        initiator_params, responder_params, session_id=5
-    )
-
-    self.initiator.stop_uwb_ranging_session(session_id=5)
-    self.responder.stop_uwb_ranging_session(session_id=5)
-
-  def test_one_to_one_ranging_disable_range_data_ntf(self):
-    """Verifies device does not receive range data after disabling range data notifications"""
-    initiator_params = params.UwbRangingParams(
-        config_type=params.Constants.ConfigType.UNICAST_DS_TWR,
-        session_id=5,
-        peer_addresses=[self.responder_addr],
-        device_address=self.initiator_addr,
-        device_role=params.Constants.DeviceRole.CONTROLLER,
-        range_data_config_type=params.Constants.RangeDataConfigType.DISABLE,
-    )
-    responder_params = params.UwbRangingParams(
-        config_type=params.Constants.ConfigType.UNICAST_DS_TWR,
-        session_id=5,
-        peer_addresses=[self.initiator_addr],
-        device_address=self.responder_addr,
-        device_role=params.Constants.DeviceRole.CONTROLEE,
-        range_data_config_type=params.Constants.RangeDataConfigType.ENABLE,
-    )
-
-    self.initiator.start_uwb_ranging_session(initiator_params)
-    self.responder.start_uwb_ranging_session(responder_params)
-
-    try:
-      uwb_test_utils.assert_uwb_peer_found(
-          self.initiator, self.responder_addr, session_id=5
-      )
-      asserts.fail((
-          "Initiator found responder even though initiator has range data"
-          "notifications disabled"
-      ))
-    except TimeoutError:
-      pass
-    uwb_test_utils.assert_uwb_peer_found(
-        self.responder, self.initiator_addr, session_id=5
-    )
-
-
-if __name__ == "__main__":
-  if "--" in sys.argv:
-    index = sys.argv.index("--")
-    sys.argv = sys.argv[:1] + sys.argv[index + 1 :]
-  suite_runner.run_suite([RangingTest])
diff --git a/generic_ranging/tests/units/src/com/android/ranging/tests/RangingSessionTest.java b/generic_ranging/tests/units/src/com/android/ranging/tests/RangingSessionTest.java
deleted file mode 100644
index 5c52fd92..00000000
--- a/generic_ranging/tests/units/src/com/android/ranging/tests/RangingSessionTest.java
+++ /dev/null
@@ -1,264 +0,0 @@
-/*
- * Copyright 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.ranging.tests;
-
-import static com.android.ranging.RangingTechnology.CS;
-import static com.android.ranging.RangingTechnology.UWB;
-
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.anyLong;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.content.Context;
-import android.content.pm.PackageManager;
-
-import androidx.test.filters.SmallTest;
-
-import com.android.ranging.RangingAdapter;
-import com.android.ranging.RangingConfig;
-import com.android.ranging.RangingData;
-import com.android.ranging.RangingParameters;
-import com.android.ranging.RangingParameters.DeviceRole;
-import com.android.ranging.RangingSession;
-import com.android.ranging.RangingSessionImpl;
-import com.android.ranging.RangingTechnology;
-import com.android.ranging.cs.CsParameters;
-import com.android.ranging.fusion.DataFusers;
-import com.android.ranging.fusion.FilteringFusionEngine;
-import com.android.ranging.uwb.UwbParameters;
-
-import com.google.common.util.concurrent.MoreExecutors;
-
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Answers;
-import org.mockito.ArgumentCaptor;
-import org.mockito.InOrder;
-import org.mockito.Mock;
-import org.mockito.Mockito;
-import org.mockito.junit.MockitoJUnit;
-import org.mockito.junit.MockitoRule;
-
-import java.time.Duration;
-import java.util.EnumMap;
-import java.util.concurrent.ScheduledExecutorService;
-
-@RunWith(JUnit4.class)
-@SmallTest
-public class RangingSessionTest {
-    @Rule public final MockitoRule mMockito = MockitoJUnit.rule();
-
-    @Mock(answer = Answers.RETURNS_DEEP_STUBS) private Context mMockContext;
-    @Mock private RangingConfig mMockConfig;
-    @Mock
-    private ScheduledExecutorService mMockTimeoutExecutor;
-
-    @Mock private RangingSession.Callback mMockCallback;
-    private final EnumMap<RangingTechnology, RangingAdapter> mMockAdapters =
-            new EnumMap<>(RangingTechnology.class);
-
-    private RangingSessionImpl mSession;
-
-    /**
-     * Starts a ranging session with the provided parameters.
-     * @param params to use for the session.
-     * @return {@link RangingAdapter.Callback} for each of the provided technologies' adapters.
-     * These callbacks are captured from underlying {@link RangingAdapter} mock for each technology.
-     */
-    private EnumMap<RangingTechnology, RangingAdapter.Callback> startSession(
-            RangingParameters params
-    ) {
-        EnumMap<RangingTechnology, RangingAdapter.Callback> adapterCallbacks =
-                new EnumMap<>(RangingTechnology.class);
-
-        mSession.start(params, mMockCallback);
-
-        for (RangingTechnology technology : params.asMap().keySet()) {
-            ArgumentCaptor<RangingAdapter.Callback> callbackCaptor =
-                    ArgumentCaptor.forClass(RangingAdapter.Callback.class);
-            verify(mMockAdapters.get(technology)).start(any(), callbackCaptor.capture());
-            callbackCaptor.getValue().onStarted();
-            adapterCallbacks.put(technology, callbackCaptor.getValue());
-        }
-
-        return adapterCallbacks;
-    }
-
-    /** @param technology to generate data for */
-    private RangingData generateData(RangingTechnology technology) {
-        return new RangingData.Builder()
-                .setTechnology(technology)
-                .setRangeDistance(123)
-                .setTimestamp(Duration.ofSeconds(1))
-                .setPeerAddress(new byte[]{0x1, 0x2})
-                .build();
-    }
-
-    @Before
-    public void setup() {
-        when(mMockContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_UWB))
-                .thenReturn(true);
-        when(mMockConfig.getInitTimeout()).thenReturn(Duration.ZERO);
-        when(mMockConfig.getNoUpdateTimeout()).thenReturn(Duration.ZERO);
-        when(mMockConfig.getUseFusingAlgorithm()).thenReturn(true);
-
-        mSession = new RangingSessionImpl(
-                mMockContext, mMockConfig,
-                new FilteringFusionEngine(new DataFusers.PassthroughDataFuser()),
-                mMockTimeoutExecutor,
-                MoreExecutors.newDirectExecutorService());
-
-        for (RangingTechnology technology : RangingTechnology.values()) {
-            RangingAdapter adapter = mock(RangingAdapter.class);
-            mMockAdapters.put(technology, adapter);
-            mSession.useAdapterForTesting(technology, adapter);
-        }
-    }
-
-    @Test
-    public void start_startsTechnologyThenSession() {
-        InOrder inOrder = Mockito.inOrder(mMockCallback);
-
-        EnumMap<RangingTechnology, RangingAdapter.Callback> adapterCallbacks =
-                startSession(new RangingParameters.Builder(DeviceRole.CONTROLLER)
-                        .useUwb(mock(UwbParameters.class))
-                        .build());
-
-        inOrder.verify(mMockCallback).onStarted(eq(UWB));
-        verify(mMockCallback, never()).onStarted(eq(null));
-
-        adapterCallbacks.get(UWB).onRangingData(generateData(UWB));
-        inOrder.verify(mMockCallback).onStarted(eq(null));
-    }
-
-    @Test
-    @Ignore("TODO: Add support for technologies other than UWB")
-    public void start_startsMultipleTechnologies() {
-        startSession(new RangingParameters.Builder(DeviceRole.CONTROLLER)
-                        .useUwb(mock(UwbParameters.class))
-                        .useCs(mock(CsParameters.class))
-                        .build());
-
-//        verify(mMockCallback).onStarted(eq(null));
-        verify(mMockCallback).onStarted(eq(UWB));
-        verify(mMockCallback).onStarted(eq(CS));
-    }
-
-    @Test
-    public void start_doesNotStartUnsupportedTechnologies() {
-        when(mMockContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_UWB))
-                .thenReturn(false);
-
-        mSession.start(new RangingParameters.Builder(DeviceRole.CONTROLLER)
-                        .useUwb(mock(UwbParameters.class))
-                        .build(),
-                mMockCallback);
-
-        verify(mMockAdapters.get(UWB), never()).start(any(), any());
-        verify(mMockCallback, never()).onStarted(any());
-    }
-
-    @Test
-    public void start_doesNotStartUnusedTechnologies() {
-        startSession(new RangingParameters.Builder(DeviceRole.CONTROLLER)
-                .useUwb(mock(UwbParameters.class))
-                .build());
-
-        verify(mMockAdapters.get(CS), never()).start(any(), any());
-        verify(mMockCallback, never()).onStarted(eq(CS));
-    }
-
-    @Test
-    public void stop_stopsTechnologyAndSession() {
-        InOrder inOrder = Mockito.inOrder(mMockCallback);
-
-        startSession(new RangingParameters.Builder(DeviceRole.CONTROLLER)
-                .useUwb(mock(UwbParameters.class))
-                .build());
-
-        mSession.stop();
-
-        verify(mMockAdapters.get(UWB)).stop();
-        inOrder.verify(mMockCallback).onStopped(UWB,
-                RangingAdapter.Callback.StoppedReason.REQUESTED);
-        inOrder.verify(mMockCallback).onStopped(null,
-                RangingAdapter.Callback.StoppedReason.REQUESTED);
-    }
-
-    @Test
-    @Ignore("TODO: Add support for technologies other than UWB")
-    public void stop_stopsMultipleTechnologies() {
-        startSession(new RangingParameters.Builder(DeviceRole.CONTROLLER)
-                .useUwb(mock(UwbParameters.class))
-                .useCs(mock(CsParameters.class))
-                .build());
-
-        mSession.stop();
-
-        verify(mMockAdapters.get(UWB)).stop();
-        verify(mMockAdapters.get(CS)).stop();
-        verify(mMockCallback).onStopped(UWB, RangingAdapter.Callback.StoppedReason.REQUESTED);
-        verify(mMockCallback).onStopped(CS, RangingAdapter.Callback.StoppedReason.REQUESTED);
-        verify(mMockCallback).onStopped(null, RangingAdapter.Callback.StoppedReason.REQUESTED);
-    }
-
-    @Test
-    public void shouldStop_whenAdapterStops() {
-        EnumMap<RangingTechnology, RangingAdapter.Callback> adapterCallbacks =
-                startSession(new RangingParameters.Builder(DeviceRole.CONTROLLER)
-                        .useUwb(mock(UwbParameters.class))
-                        .build());
-
-        adapterCallbacks.get(UWB).onStopped(RangingAdapter.Callback.StoppedReason.LOST_CONNECTION);
-
-        verify(mMockCallback).onStopped(UWB, RangingAdapter.Callback.StoppedReason.LOST_CONNECTION);
-    }
-
-    @Test
-    public void shouldStop_whenNoInitialDataIsReported() {
-        startSession(new RangingParameters.Builder(DeviceRole.CONTROLLER).build());
-
-        ArgumentCaptor<Runnable> onTimeoutCaptor = ArgumentCaptor.forClass(Runnable.class);
-        verify(mMockTimeoutExecutor).scheduleWithFixedDelay(onTimeoutCaptor.capture(),
-                anyLong(), anyLong(), any());
-
-        onTimeoutCaptor.getValue().run();
-
-        verify(mMockCallback).onStopped(eq(null),
-                eq(RangingSession.Callback.StoppedReason.NO_INITIAL_DATA_TIMEOUT));
-    }
-
-    @Test
-    public void shouldReportData_fromAdapter() {
-        EnumMap<RangingTechnology, RangingAdapter.Callback> adapterCallbacks =
-                startSession(new RangingParameters.Builder(DeviceRole.CONTROLLER)
-                        .useUwb(mock(UwbParameters.class))
-                        .build());
-
-        adapterCallbacks.get(UWB).onRangingData(generateData(UWB));
-
-        verify(mMockCallback).onData(any(RangingData.class));
-    }
-}
diff --git a/generic_ranging/tests/units/src/com/android/ranging/uwb/tests/UwbAdapterTest.java b/generic_ranging/tests/units/src/com/android/ranging/uwb/tests/UwbAdapterTest.java
deleted file mode 100644
index aab30194..00000000
--- a/generic_ranging/tests/units/src/com/android/ranging/uwb/tests/UwbAdapterTest.java
+++ /dev/null
@@ -1,154 +0,0 @@
-/*
- * Copyright 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.ranging.uwb.tests;
-
-import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.anyInt;
-import static org.mockito.ArgumentMatchers.eq;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import android.content.Context;
-import android.content.pm.PackageManager;
-
-import androidx.test.filters.SmallTest;
-
-import com.android.ranging.RangingAdapter;
-import com.android.ranging.RangingData;
-import com.android.ranging.RangingParameters.DeviceRole;
-import com.android.ranging.RangingTechnology;
-import com.android.ranging.cs.CsParameters;
-import com.android.ranging.uwb.UwbAdapter;
-import com.android.ranging.uwb.UwbParameters;
-import com.android.ranging.uwb.backend.internal.RangingController;
-import com.android.ranging.uwb.backend.internal.RangingPosition;
-import com.android.ranging.uwb.backend.internal.RangingSessionCallback;
-import com.android.ranging.uwb.backend.internal.UwbDevice;
-import com.android.ranging.uwb.backend.internal.UwbServiceImpl;
-
-import com.google.common.util.concurrent.MoreExecutors;
-
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Answers;
-import org.mockito.ArgumentCaptor;
-import org.mockito.Mock;
-import org.mockito.junit.MockitoJUnit;
-import org.mockito.junit.MockitoRule;
-
-import java.util.concurrent.ExecutionException;
-
-@RunWith(JUnit4.class)
-@SmallTest
-public class UwbAdapterTest {
-    @Rule public final MockitoRule mMockito = MockitoJUnit.rule();
-
-    @Mock(answer = Answers.RETURNS_DEEP_STUBS) private Context mMockContext;
-    @Mock private UwbServiceImpl mMockUwbService;
-    @Mock private RangingController mMockUwbClient;
-
-    @Mock private RangingAdapter.Callback mMockCallback;
-
-    /** Class under test */
-    private UwbAdapter mUwbAdapter;
-
-    @Before
-    public void setup() {
-        when(mMockContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_UWB))
-                .thenReturn(true);
-        when(mMockUwbService.getController(any())).thenReturn(mMockUwbClient);
-        mUwbAdapter = new UwbAdapter(mMockContext, MoreExecutors.newDirectExecutorService(),
-                mMockUwbService, DeviceRole.CONTROLLER);
-    }
-
-    @Test
-    public void getType_returnsUwb() {
-        Assert.assertEquals(RangingTechnology.UWB, mUwbAdapter.getType());
-    }
-
-    @Test
-    public void isEnabled_checksServiceIsAvailable()
-            throws InterruptedException, ExecutionException {
-        when(mMockUwbService.isAvailable()).thenReturn(true);
-        Assert.assertTrue(mUwbAdapter.isEnabled().get());
-    }
-
-    @Test
-    public void start_failsWhenParamsInvalid() {
-        mUwbAdapter.start(mock(CsParameters.class), mMockCallback);
-        verify(mMockCallback).onStopped(eq(RangingAdapter.Callback.StoppedReason.FAILED_TO_START));
-        verify(mMockCallback, never()).onStarted();
-    }
-
-    @Test
-    public void start_startsUwbClientWithCallbacks() {
-        mUwbAdapter.start(mock(UwbParameters.class), mMockCallback);
-
-        ArgumentCaptor<RangingSessionCallback> callbackCaptor =
-                ArgumentCaptor.forClass(RangingSessionCallback.class);
-        verify(mMockUwbClient).startRanging(callbackCaptor.capture(), any());
-
-        UwbDevice mockUwbdevice = mock(UwbDevice.class, Answers.RETURNS_DEEP_STUBS);
-        callbackCaptor.getValue().onRangingInitialized(mockUwbdevice);
-        verify(mMockCallback).onStarted();
-
-        callbackCaptor.getValue().onRangingSuspended(mockUwbdevice, anyInt());
-        verify(mMockCallback).onStopped(anyInt());
-    }
-
-    @Test
-    public void stop_stopsUwbClient() {
-        mUwbAdapter.start(mock(UwbParameters.class), mMockCallback);
-        mUwbAdapter.stop();
-        verify(mMockUwbClient).stopRanging();
-    }
-
-    @Test
-    public void shouldReportData_onRangingResult() {
-        mUwbAdapter.start(mock(UwbParameters.class), mMockCallback);
-
-        ArgumentCaptor<RangingSessionCallback> callbackCaptor =
-                ArgumentCaptor.forClass(RangingSessionCallback.class);
-        verify(mMockUwbClient).startRanging(callbackCaptor.capture(), any());
-
-        UwbDevice mockDevice = mock(UwbDevice.class, Answers.RETURNS_DEEP_STUBS);
-        when(mockDevice.getAddress().toBytes()).thenReturn(new byte[]{0x1, 0x2});
-
-        RangingPosition mockPosition = mock(RangingPosition.class, Answers.RETURNS_DEEP_STUBS);
-        when(mockPosition.getDistance().getValue()).thenReturn(12F);
-        when(mockPosition.getElapsedRealtimeNanos()).thenReturn(1234L);
-
-        callbackCaptor.getValue().onRangingInitialized(mockDevice);
-        verify(mMockCallback).onStarted();
-
-        ArgumentCaptor<RangingData> dataCaptor = ArgumentCaptor.forClass(RangingData.class);
-        callbackCaptor.getValue().onRangingResult(mockDevice, mockPosition);
-        verify(mMockCallback).onRangingData(dataCaptor.capture());
-
-        RangingData data = dataCaptor.getValue();
-        Assert.assertEquals(RangingTechnology.UWB, data.getTechnology().get());
-        Assert.assertEquals(mockPosition.getDistance().getValue(), data.getRangeMeters(), 0.1);
-        Assert.assertArrayEquals(mockDevice.getAddress().toBytes(), data.getPeerAddress());
-        Assert.assertEquals(mockPosition.getElapsedRealtimeNanos(), data.getTimestamp().getNano());
-    }
-}
diff --git a/ranging/flags/Android.bp b/ranging/flags/Android.bp
index cecc7725..10b0dcda 100644
--- a/ranging/flags/Android.bp
+++ b/ranging/flags/Android.bp
@@ -22,7 +22,8 @@ package {
 aconfig_declarations {
     name: "ranging_aconfig_flags",
     package: "com.android.ranging.flags",
-    container: "com.android.ranging",
+    container: "com.android.uwb",
+    exportable: true,
     srcs: ["ranging_flags.aconfig"],
     visibility: [
         "//packages/modules/Uwb/ranging:__subpackages__",
@@ -33,9 +34,25 @@ aconfig_declarations {
 java_aconfig_library {
     name: "ranging_aconfig_flags_lib",
     aconfig_declarations: "ranging_aconfig_flags",
-    min_sdk_version: "33",
+    min_sdk_version: "30",
     apex_available: [
         "com.android.uwb",
+        "com.android.wifi",
+    ],
+    defaults: ["framework-minus-apex-aconfig-java-defaults"],
+    visibility: [
+        "//packages/modules/Uwb/ranging:__subpackages__",
+        "//packages/modules/Wifi/framework:__subpackages__",
+    ],
+}
+
+java_aconfig_library {
+    name: "com.android.ranging.flags.ranging-aconfig-java-export",
+    aconfig_declarations: "ranging_aconfig_flags",
+    mode: "exported",
+    defaults: ["framework-minus-apex-aconfig-java-defaults"],
+    visibility: [
+        "//frameworks/base",
     ],
 }
 
diff --git a/ranging/flags/ranging_flags.aconfig b/ranging/flags/ranging_flags.aconfig
index 4de30349..d9b44742 100644
--- a/ranging/flags/ranging_flags.aconfig
+++ b/ranging/flags/ranging_flags.aconfig
@@ -1,10 +1,26 @@
 package: "com.android.ranging.flags"
-container: "com.android.ranging"
+container: "com.android.uwb"
 
 flag {
     name: "ranging_stack_enabled"
     is_exported: true
-    namespace: "ranging"
+    namespace: "uwb"
     description: "This flags controls generic ranging feature"
     bug: "331206299"
+}
+
+flag {
+    name: "ranging_cs_enabled"
+    is_exported: true
+    namespace: "uwb"
+    description: "This flags controls channel sounding in generic ranging"
+    bug: "331206299"
+}
+
+flag {
+    name: "ranging_rtt_enabled"
+    is_exported: true
+    namespace: "uwb"
+    description: "This flags controls channel sounding in generic ranging"
+    bug: "331206299"
 }
\ No newline at end of file
diff --git a/ranging/framework/Android.bp b/ranging/framework/Android.bp
index cb90bbba..56224f23 100644
--- a/ranging/framework/Android.bp
+++ b/ranging/framework/Android.bp
@@ -57,9 +57,11 @@ java_defaults {
     static_libs: [
         //"modules-utils-preconditions",
         "modules-utils-build",
+        "ranging_aconfig_flags_lib",
     ],
     libs: [
         "androidx.annotation_annotation",
+        "framework-bluetooth.stubs.module_lib",
         "unsupportedappusage", // for android.compat.annotation.UnsupportedAppUsage
     ],
     srcs: [
@@ -73,8 +75,12 @@ java_library {
     name: "framework-ranging-pre-jarjar",
     defaults: ["framework-ranging-defaults"],
     sdk_version: "module_current",
+    min_sdk_version: "33",
     libs: ["framework-annotations-lib"],
     installable: false,
+    apex_available: [
+        "com.android.uwb",
+    ],
 }
 
 // post-jarjar version of framework-ranging
diff --git a/ranging/framework/api/current.txt b/ranging/framework/api/current.txt
index d802177e..2f546c3c 100644
--- a/ranging/framework/api/current.txt
+++ b/ranging/framework/api/current.txt
@@ -1 +1,486 @@
 // Signature format: 2.0
+package android.ranging {
+
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class DataNotificationConfig implements android.os.Parcelable {
+    method public int describeContents();
+    method public int getNotificationConfigType();
+    method public int getProximityFarCm();
+    method public int getProximityNearCm();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.DataNotificationConfig> CREATOR;
+    field public static final int DISABLE = 0; // 0x0
+    field public static final int ENABLE = 1; // 0x1
+    field public static final int PROXIMITY_EDGE = 3; // 0x3
+    field public static final int PROXIMITY_LEVEL = 2; // 0x2
+  }
+
+  public static final class DataNotificationConfig.Builder {
+    ctor public DataNotificationConfig.Builder();
+    method @NonNull public android.ranging.DataNotificationConfig build();
+    method @NonNull public android.ranging.DataNotificationConfig.Builder setNotificationConfigType(int);
+    method @NonNull public android.ranging.DataNotificationConfig.Builder setProximityFarCm(int);
+    method @NonNull public android.ranging.DataNotificationConfig.Builder setProximityNearCm(int);
+  }
+
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class RangingCapabilities implements android.os.Parcelable {
+    method public int describeContents();
+    method @Nullable public android.ranging.ble.cs.CsRangingCapabilities getCsCapabilities();
+    method @Nullable public android.ranging.wifi.rtt.RttRangingCapabilities getRttRangingCapabilities();
+    method @NonNull public java.util.Map<java.lang.Integer,java.lang.Integer> getTechnologyAvailability();
+    method @Nullable public android.ranging.uwb.UwbRangingCapabilities getUwbCapabilities();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.RangingCapabilities> CREATOR;
+    field public static final int DISABLED_REGULATORY = 2; // 0x2
+    field public static final int DISABLED_USER = 1; // 0x1
+    field public static final int DISABLED_USER_RESTRICTIONS = 4; // 0x4
+    field public static final int ENABLED = 3; // 0x3
+    field public static final int NOT_SUPPORTED = 0; // 0x0
+  }
+
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class RangingData implements android.os.Parcelable {
+    method public int describeContents();
+    method @Nullable public android.ranging.RangingMeasurement getAzimuth();
+    method @Nullable public android.ranging.RangingMeasurement getDistance();
+    method @Nullable public android.ranging.RangingMeasurement getElevation();
+    method public int getRangingTechnology();
+    method public int getRssi();
+    method public long getTimestampMillis();
+    method public boolean hasRssi();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.RangingData> CREATOR;
+  }
+
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class RangingDevice implements android.os.Parcelable {
+    method public int describeContents();
+    method @NonNull public java.util.UUID getUuid();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.RangingDevice> CREATOR;
+  }
+
+  public static final class RangingDevice.Builder {
+    ctor public RangingDevice.Builder();
+    method @NonNull public android.ranging.RangingDevice build();
+    method @NonNull public android.ranging.RangingDevice.Builder setUuid(@NonNull java.util.UUID);
+  }
+
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class RangingManager {
+    method @Nullable public android.ranging.RangingSession createRangingSession(@NonNull java.util.concurrent.Executor, @NonNull android.ranging.RangingSession.Callback);
+    method @NonNull public void registerCapabilitiesCallback(@NonNull java.util.concurrent.Executor, @NonNull android.ranging.RangingManager.RangingCapabilitiesCallback);
+    method @NonNull public void unregisterCapabilitiesCallback(@NonNull android.ranging.RangingManager.RangingCapabilitiesCallback);
+    field public static final int BLE_CS = 1; // 0x1
+    field public static final int BLE_RSSI = 3; // 0x3
+    field public static final int UWB = 0; // 0x0
+    field public static final int WIFI_NAN_RTT = 2; // 0x2
+  }
+
+  public static interface RangingManager.RangingCapabilitiesCallback {
+    method public void onRangingCapabilities(@NonNull android.ranging.RangingCapabilities);
+  }
+
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class RangingMeasurement implements android.os.Parcelable {
+    method public int describeContents();
+    method public int getConfidence();
+    method public double getMeasurement();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field public static final int CONFIDENCE_HIGH = 2; // 0x2
+    field public static final int CONFIDENCE_LOW = 0; // 0x0
+    field public static final int CONFIDENCE_MEDIUM = 1; // 0x1
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.RangingMeasurement> CREATOR;
+  }
+
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public abstract class RangingParams implements android.os.Parcelable {
+    ctor protected RangingParams();
+    method public int getRangingSessionType();
+    field public static final int RANGING_SESSION_OOB = 1; // 0x1
+    field public static final int RANGING_SESSION_RAW = 0; // 0x0
+  }
+
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class RangingPreference implements android.os.Parcelable {
+    method public int describeContents();
+    method public int getDeviceRole();
+    method @Nullable public android.ranging.RangingParams getRangingParameters();
+    method @NonNull public android.ranging.SessionConfiguration getSessionConfiguration();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.RangingPreference> CREATOR;
+    field public static final int DEVICE_ROLE_INITIATOR = 1; // 0x1
+    field public static final int DEVICE_ROLE_RESPONDER = 0; // 0x0
+  }
+
+  public static final class RangingPreference.Builder {
+    ctor public RangingPreference.Builder(int, @NonNull android.ranging.RangingParams);
+    method @NonNull public android.ranging.RangingPreference build();
+    method @NonNull public android.ranging.RangingPreference.Builder setSessionConfiguration(@NonNull android.ranging.SessionConfiguration);
+  }
+
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class RangingSession implements java.lang.AutoCloseable {
+    method @RequiresPermission(android.Manifest.permission.RANGING) public void addDeviceToRangingSession(@NonNull android.ranging.RangingParams);
+    method @RequiresPermission(android.Manifest.permission.RANGING) public void close();
+    method @RequiresPermission(android.Manifest.permission.RANGING) public void reconfigureRangingInterval(@IntRange(from=0, to=255) int);
+    method @RequiresPermission(android.Manifest.permission.RANGING) public void removeDeviceFromRangingSession(@NonNull android.ranging.RangingDevice);
+    method @NonNull @RequiresPermission(android.Manifest.permission.RANGING) public android.os.CancellationSignal start(@NonNull android.ranging.RangingPreference);
+    method @RequiresPermission(android.Manifest.permission.RANGING) public void stop();
+  }
+
+  public static interface RangingSession.Callback {
+    method public void onClosed(int);
+    method public void onOpenFailed(int);
+    method public void onOpened();
+    method public void onResults(@NonNull android.ranging.RangingDevice, @NonNull android.ranging.RangingData);
+    method public void onStarted(@NonNull android.ranging.RangingDevice, int);
+    method public void onStopped(@NonNull android.ranging.RangingDevice, int);
+    field public static final int REASON_LOCAL_REQUEST = 1; // 0x1
+    field public static final int REASON_NO_PEERS_FOUND = 5; // 0x5
+    field public static final int REASON_REMOTE_REQUEST = 2; // 0x2
+    field public static final int REASON_SYSTEM_POLICY = 4; // 0x4
+    field public static final int REASON_UNKNOWN = 0; // 0x0
+    field public static final int REASON_UNSUPPORTED = 3; // 0x3
+  }
+
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class SensorFusionParams implements android.os.Parcelable {
+    method public int describeContents();
+    method public boolean isSensorFusionEnabled();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.SensorFusionParams> CREATOR;
+  }
+
+  public static final class SensorFusionParams.Builder {
+    ctor public SensorFusionParams.Builder();
+    method @NonNull public android.ranging.SensorFusionParams build();
+    method @NonNull public android.ranging.SensorFusionParams.Builder setSensorFusionEnabled(boolean);
+  }
+
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class SessionConfiguration implements android.os.Parcelable {
+    method public int describeContents();
+    method @NonNull public android.ranging.DataNotificationConfig getDataNotificationConfig();
+    method @IntRange(from=0, to=65535) public int getRangingMeasurementsLimit();
+    method @NonNull public android.ranging.SensorFusionParams getSensorFusionParameters();
+    method public boolean isAngleOfArrivalNeeded();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.SessionConfiguration> CREATOR;
+  }
+
+  public static final class SessionConfiguration.Builder {
+    ctor public SessionConfiguration.Builder();
+    method @NonNull public android.ranging.SessionConfiguration build();
+    method @NonNull public android.ranging.SessionConfiguration.Builder setAngleOfArrivalNeeded(boolean);
+    method @NonNull public android.ranging.SessionConfiguration.Builder setDataNotificationConfig(@NonNull android.ranging.DataNotificationConfig);
+    method @NonNull public android.ranging.SessionConfiguration.Builder setRangingMeasurementsLimit(@IntRange(from=0, to=65535) int);
+    method @NonNull public android.ranging.SessionConfiguration.Builder setSensorFusionParameters(@NonNull android.ranging.SensorFusionParams);
+  }
+
+}
+
+package android.ranging.ble.cs {
+
+  @FlaggedApi("com.android.ranging.flags.ranging_cs_enabled") public final class CsRangingCapabilities implements android.os.Parcelable {
+    method public int describeContents();
+    method @NonNull public java.util.Set<java.lang.Integer> getSupportedSecurityLevels();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.ble.cs.CsRangingCapabilities> CREATOR;
+    field public static final int CS_SECURITY_LEVEL_FOUR = 4; // 0x4
+    field public static final int CS_SECURITY_LEVEL_ONE = 1; // 0x1
+  }
+
+  @FlaggedApi("com.android.ranging.flags.ranging_cs_enabled") public final class CsRangingParams implements android.os.Parcelable {
+    method public int describeContents();
+    method public int getLocationType();
+    method @NonNull public String getPeerBluetoothAddress();
+    method public int getRangingUpdateRate();
+    method public int getSecurityLevel();
+    method public int getSightType();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.ble.cs.CsRangingParams> CREATOR;
+    field public static final int LOCATION_TYPE_INDOOR = 1; // 0x1
+    field public static final int LOCATION_TYPE_OUTDOOR = 2; // 0x2
+    field public static final int LOCATION_TYPE_UNKNOWN = 0; // 0x0
+    field public static final int SIGHT_TYPE_LINE_OF_SIGHT = 1; // 0x1
+    field public static final int SIGHT_TYPE_NON_LINE_OF_SIGHT = 2; // 0x2
+    field public static final int SIGHT_TYPE_UNKNOWN = 0; // 0x0
+  }
+
+  public static final class CsRangingParams.Builder {
+    ctor public CsRangingParams.Builder(@NonNull String);
+    method @NonNull public android.ranging.ble.cs.CsRangingParams build();
+    method @NonNull public android.ranging.ble.cs.CsRangingParams.Builder setLocationType(int);
+    method @NonNull public android.ranging.ble.cs.CsRangingParams.Builder setRangingUpdateRate(int);
+    method @NonNull public android.ranging.ble.cs.CsRangingParams.Builder setSecurityLevel(int);
+    method @NonNull public android.ranging.ble.cs.CsRangingParams.Builder setSightType(int);
+  }
+
+}
+
+package android.ranging.ble.rssi {
+
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class BleRssiRangingParams implements android.os.Parcelable {
+    method public int describeContents();
+    method @NonNull public String getPeerBluetoothAddress();
+    method public int getRangingUpdateRate();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.ble.rssi.BleRssiRangingParams> CREATOR;
+  }
+
+  public static final class BleRssiRangingParams.Builder {
+    ctor public BleRssiRangingParams.Builder(@NonNull String);
+    method @NonNull public android.ranging.ble.rssi.BleRssiRangingParams build();
+    method @NonNull public android.ranging.ble.rssi.BleRssiRangingParams.Builder setRangingUpdateRate(int);
+  }
+
+}
+
+package android.ranging.oob {
+
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class DeviceHandle implements android.os.Parcelable {
+    method public int describeContents();
+    method @NonNull public android.ranging.RangingDevice getRangingDevice();
+    method @NonNull public android.ranging.oob.TransportHandle getTransportHandle();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.oob.DeviceHandle> CREATOR;
+  }
+
+  public static final class DeviceHandle.Builder {
+    ctor public DeviceHandle.Builder(@NonNull android.ranging.RangingDevice, @NonNull android.ranging.oob.TransportHandle);
+    method @NonNull public android.ranging.oob.DeviceHandle build();
+  }
+
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class OobInitiatorRangingParams extends android.ranging.RangingParams implements android.os.Parcelable {
+    method public int describeContents();
+    method @NonNull public java.util.List<android.ranging.oob.DeviceHandle> getDeviceHandles();
+    method @NonNull public java.time.Duration getFastestRangingInterval();
+    method @NonNull public android.util.Range<java.time.Duration> getRangingIntervalRange();
+    method public int getRangingMode();
+    method public int getSecurityLevel();
+    method @NonNull public java.time.Duration getSlowestRangingInterval();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.oob.OobInitiatorRangingParams> CREATOR;
+    field public static final int RANGING_MODE_AUTO = 0; // 0x0
+    field public static final int RANGING_MODE_FUSED = 3; // 0x3
+    field public static final int RANGING_MODE_HIGH_ACCURACY = 1; // 0x1
+    field public static final int RANGING_MODE_HIGH_ACCURACY_PREFERRED = 2; // 0x2
+    field public static final int SECURITY_LEVEL_BASIC = 0; // 0x0
+    field public static final int SECURITY_LEVEL_SECURE = 1; // 0x1
+  }
+
+  public static final class OobInitiatorRangingParams.Builder {
+    ctor public OobInitiatorRangingParams.Builder();
+    method @NonNull public android.ranging.oob.OobInitiatorRangingParams.Builder addDeviceHandle(@NonNull android.ranging.oob.DeviceHandle);
+    method @NonNull public android.ranging.oob.OobInitiatorRangingParams build();
+    method @NonNull public android.ranging.oob.OobInitiatorRangingParams.Builder setFastestRangingInterval(@NonNull java.time.Duration);
+    method @NonNull public android.ranging.oob.OobInitiatorRangingParams.Builder setRangingMode(int);
+    method @NonNull public android.ranging.oob.OobInitiatorRangingParams.Builder setSecurityLevel(int);
+    method @NonNull public android.ranging.oob.OobInitiatorRangingParams.Builder setSlowestRangingInterval(@NonNull java.time.Duration);
+  }
+
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class OobResponderRangingParams extends android.ranging.RangingParams implements android.os.Parcelable {
+    method public int describeContents();
+    method @NonNull public android.ranging.oob.DeviceHandle getDeviceHandle();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.oob.OobResponderRangingParams> CREATOR;
+  }
+
+  public static final class OobResponderRangingParams.Builder {
+    ctor public OobResponderRangingParams.Builder(@NonNull android.ranging.oob.DeviceHandle);
+    method @NonNull public android.ranging.oob.OobResponderRangingParams build();
+  }
+
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public interface TransportHandle extends java.lang.AutoCloseable {
+    method public void registerReceiveCallback(@NonNull java.util.concurrent.Executor, @NonNull android.ranging.oob.TransportHandle.ReceiveCallback);
+    method public void sendData(@NonNull byte[]);
+  }
+
+  public static interface TransportHandle.ReceiveCallback {
+    method public void onClose();
+    method public void onDisconnect();
+    method public void onReceiveData(@NonNull byte[]);
+    method public void onReconnect();
+    method public void onSendFailed();
+  }
+
+}
+
+package android.ranging.raw {
+
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class RawInitiatorRangingParams extends android.ranging.RangingParams implements android.os.Parcelable {
+    method public int describeContents();
+    method @NonNull public java.util.List<android.ranging.raw.RawRangingDevice> getRawRangingDevices();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.raw.RawInitiatorRangingParams> CREATOR;
+  }
+
+  public static final class RawInitiatorRangingParams.Builder {
+    ctor public RawInitiatorRangingParams.Builder();
+    method @NonNull public android.ranging.raw.RawInitiatorRangingParams.Builder addRawRangingDevice(@NonNull android.ranging.raw.RawRangingDevice);
+    method @NonNull public android.ranging.raw.RawInitiatorRangingParams build();
+  }
+
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class RawRangingDevice implements android.os.Parcelable {
+    method public int describeContents();
+    method @Nullable public android.ranging.ble.rssi.BleRssiRangingParams getBleRssiRangingParams();
+    method @Nullable public android.ranging.ble.cs.CsRangingParams getCsRangingParams();
+    method @NonNull public android.ranging.RangingDevice getRangingDevice();
+    method @Nullable public android.ranging.wifi.rtt.RttRangingParams getRttRangingParams();
+    method @Nullable public android.ranging.uwb.UwbRangingParams getUwbRangingParams();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.raw.RawRangingDevice> CREATOR;
+    field public static final int UPDATE_RATE_FREQUENT = 3; // 0x3
+    field public static final int UPDATE_RATE_INFREQUENT = 2; // 0x2
+    field public static final int UPDATE_RATE_NORMAL = 1; // 0x1
+  }
+
+  public static final class RawRangingDevice.Builder {
+    ctor public RawRangingDevice.Builder();
+    method @NonNull public android.ranging.raw.RawRangingDevice build();
+    method @NonNull public android.ranging.raw.RawRangingDevice.Builder setBleRssiRangingParams(@NonNull android.ranging.ble.rssi.BleRssiRangingParams);
+    method @NonNull public android.ranging.raw.RawRangingDevice.Builder setCsRangingParams(@NonNull android.ranging.ble.cs.CsRangingParams);
+    method @NonNull public android.ranging.raw.RawRangingDevice.Builder setRangingDevice(@NonNull android.ranging.RangingDevice);
+    method @NonNull public android.ranging.raw.RawRangingDevice.Builder setRttRangingParams(@NonNull android.ranging.wifi.rtt.RttRangingParams);
+    method @NonNull public android.ranging.raw.RawRangingDevice.Builder setUwbRangingParams(@NonNull android.ranging.uwb.UwbRangingParams);
+  }
+
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class RawResponderRangingParams extends android.ranging.RangingParams implements android.os.Parcelable {
+    method public int describeContents();
+    method @NonNull public android.ranging.raw.RawRangingDevice getRawRangingDevice();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.raw.RawResponderRangingParams> CREATOR;
+  }
+
+  public static final class RawResponderRangingParams.Builder {
+    ctor public RawResponderRangingParams.Builder();
+    method @NonNull public android.ranging.raw.RawResponderRangingParams build();
+    method @NonNull public android.ranging.raw.RawResponderRangingParams.Builder setRawRangingDevice(@NonNull android.ranging.raw.RawRangingDevice);
+  }
+
+}
+
+package android.ranging.uwb {
+
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class UwbAddress implements android.os.Parcelable {
+    method public int describeContents();
+    method @NonNull public static android.ranging.uwb.UwbAddress fromBytes(@NonNull byte[]);
+    method @NonNull public byte[] getAddressBytes();
+    method @NonNull public static android.ranging.uwb.UwbAddress getRandomShortAddress();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.uwb.UwbAddress> CREATOR;
+    field public static final int EXTENDED_ADDRESS_BYTE_LENGTH = 8; // 0x8
+    field public static final int SHORT_ADDRESS_BYTE_LENGTH = 2; // 0x2
+  }
+
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class UwbComplexChannel implements android.os.Parcelable {
+    method public int describeContents();
+    method public int getChannel();
+    method public int getPreambleIndex();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.uwb.UwbComplexChannel> CREATOR;
+    field public static final int UWB_CHANNEL_10 = 10; // 0xa
+    field public static final int UWB_CHANNEL_12 = 12; // 0xc
+    field public static final int UWB_CHANNEL_13 = 13; // 0xd
+    field public static final int UWB_CHANNEL_14 = 14; // 0xe
+    field public static final int UWB_CHANNEL_5 = 5; // 0x5
+    field public static final int UWB_CHANNEL_6 = 6; // 0x6
+    field public static final int UWB_CHANNEL_8 = 8; // 0x8
+    field public static final int UWB_CHANNEL_9 = 9; // 0x9
+    field public static final int UWB_PREAMBLE_CODE_INDEX_10 = 10; // 0xa
+    field public static final int UWB_PREAMBLE_CODE_INDEX_11 = 11; // 0xb
+    field public static final int UWB_PREAMBLE_CODE_INDEX_12 = 12; // 0xc
+    field public static final int UWB_PREAMBLE_CODE_INDEX_25 = 25; // 0x19
+    field public static final int UWB_PREAMBLE_CODE_INDEX_26 = 26; // 0x1a
+    field public static final int UWB_PREAMBLE_CODE_INDEX_27 = 27; // 0x1b
+    field public static final int UWB_PREAMBLE_CODE_INDEX_28 = 28; // 0x1c
+    field public static final int UWB_PREAMBLE_CODE_INDEX_29 = 29; // 0x1d
+    field public static final int UWB_PREAMBLE_CODE_INDEX_30 = 30; // 0x1e
+    field public static final int UWB_PREAMBLE_CODE_INDEX_31 = 31; // 0x1f
+    field public static final int UWB_PREAMBLE_CODE_INDEX_32 = 32; // 0x20
+    field public static final int UWB_PREAMBLE_CODE_INDEX_9 = 9; // 0x9
+  }
+
+  public static final class UwbComplexChannel.Builder {
+    ctor public UwbComplexChannel.Builder();
+    method @NonNull public android.ranging.uwb.UwbComplexChannel build();
+    method @NonNull public android.ranging.uwb.UwbComplexChannel.Builder setChannel(int);
+    method @NonNull public android.ranging.uwb.UwbComplexChannel.Builder setPreambleIndex(int);
+  }
+
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class UwbRangingCapabilities implements android.os.Parcelable {
+    method public int describeContents();
+    method @NonNull public java.time.Duration getMinimumRangingInterval();
+    method @NonNull public java.util.List<java.lang.Integer> getSupportedChannels();
+    method @NonNull public java.util.List<java.lang.Integer> getSupportedConfigIds();
+    method @NonNull public java.util.List<java.lang.Integer> getSupportedNotificationConfigurations();
+    method @NonNull public java.util.List<java.lang.Integer> getSupportedPreambleIndexes();
+    method @NonNull public java.util.List<java.lang.Integer> getSupportedRangingUpdateRates();
+    method @NonNull public java.util.List<java.lang.Integer> getSupportedSlotDurations();
+    method public boolean isAzimuthalAngleSupported();
+    method public boolean isBackgroundRangingSupported();
+    method public boolean isDistanceMeasurementSupported();
+    method public boolean isElevationAngleSupported();
+    method public boolean isRangingIntervalReconfigurationSupported();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.uwb.UwbRangingCapabilities> CREATOR;
+  }
+
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class UwbRangingParams implements android.os.Parcelable {
+    method public int describeContents();
+    method @NonNull public android.ranging.uwb.UwbComplexChannel getComplexChannel();
+    method public int getConfigId();
+    method @NonNull public android.ranging.uwb.UwbAddress getDeviceAddress();
+    method @NonNull public android.ranging.uwb.UwbAddress getPeerAddress();
+    method public int getRangingUpdateRate();
+    method public int getSessionId();
+    method @Nullable public byte[] getSessionKeyInfo();
+    method public int getSlotDuration();
+    method public int getSubSessionId();
+    method @Nullable public byte[] getSubSessionKeyInfo();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field public static final int CONFIG_MULTICAST_DS_TWR = 2; // 0x2
+    field public static final int CONFIG_PROVISIONED_INDIVIDUAL_MULTICAST_DS_TWR = 5; // 0x5
+    field public static final int CONFIG_PROVISIONED_MULTICAST_DS_TWR = 4; // 0x4
+    field public static final int CONFIG_PROVISIONED_UNICAST_DS_TWR = 3; // 0x3
+    field public static final int CONFIG_PROVISIONED_UNICAST_DS_TWR_VERY_FAST = 6; // 0x6
+    field public static final int CONFIG_UNICAST_DS_TWR = 1; // 0x1
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.uwb.UwbRangingParams> CREATOR;
+    field public static final int DURATION_1_MS = 1; // 0x1
+    field public static final int DURATION_2_MS = 2; // 0x2
+    field public static final int SUB_SESSION_UNDEFINED = -1; // 0xffffffff
+  }
+
+  public static final class UwbRangingParams.Builder {
+    ctor public UwbRangingParams.Builder(int, int, @NonNull android.ranging.uwb.UwbAddress, @NonNull android.ranging.uwb.UwbAddress);
+    method @NonNull public android.ranging.uwb.UwbRangingParams build();
+    method @NonNull public android.ranging.uwb.UwbRangingParams.Builder setComplexChannel(@NonNull android.ranging.uwb.UwbComplexChannel);
+    method @NonNull public android.ranging.uwb.UwbRangingParams.Builder setRangingUpdateRate(int);
+    method @NonNull public android.ranging.uwb.UwbRangingParams.Builder setSessionKeyInfo(@NonNull byte[]);
+    method @NonNull public android.ranging.uwb.UwbRangingParams.Builder setSlotDuration(int);
+    method @NonNull public android.ranging.uwb.UwbRangingParams.Builder setSubSessionId(int);
+    method @NonNull public android.ranging.uwb.UwbRangingParams.Builder setSubSessionKeyInfo(@NonNull byte[]);
+  }
+
+}
+
+package android.ranging.wifi.rtt {
+
+  @FlaggedApi("com.android.ranging.flags.ranging_rtt_enabled") public final class RttRangingCapabilities implements android.os.Parcelable {
+    method public int describeContents();
+    method public boolean hasPeriodicRangingHwFeature();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.wifi.rtt.RttRangingCapabilities> CREATOR;
+  }
+
+  @FlaggedApi("com.android.ranging.flags.ranging_rtt_enabled") public final class RttRangingParams implements android.os.Parcelable {
+    method public int describeContents();
+    method @Nullable public byte[] getMatchFilter();
+    method public int getRangingUpdateRate();
+    method @NonNull public String getServiceName();
+    method public boolean isPeriodicRangingHwFeatureEnabled();
+    method public void writeToParcel(@NonNull android.os.Parcel, int);
+    field @NonNull public static final android.os.Parcelable.Creator<android.ranging.wifi.rtt.RttRangingParams> CREATOR;
+  }
+
+  public static final class RttRangingParams.Builder {
+    ctor public RttRangingParams.Builder(@NonNull String);
+    method @NonNull public android.ranging.wifi.rtt.RttRangingParams build();
+    method @NonNull public android.ranging.wifi.rtt.RttRangingParams.Builder setMatchFilter(@NonNull byte[]);
+    method @NonNull public android.ranging.wifi.rtt.RttRangingParams.Builder setPeriodicRangingHwFeatureEnabled(boolean);
+    method @NonNull public android.ranging.wifi.rtt.RttRangingParams.Builder setRangingUpdateRate(int);
+  }
+
+}
+
diff --git a/ranging/framework/api/module-lib-current.txt b/ranging/framework/api/module-lib-current.txt
index ed33736f..1d197d02 100644
--- a/ranging/framework/api/module-lib-current.txt
+++ b/ranging/framework/api/module-lib-current.txt
@@ -1,7 +1,8 @@
 // Signature format: 2.0
 package android.ranging {
 
-  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public class RangingFrameworkInitializer {
+  @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled") public final class RangingFrameworkInitializer {
+    method public static void registerServiceWrappers();
   }
 
 }
diff --git a/ranging/framework/api/test-current.txt b/ranging/framework/api/test-current.txt
deleted file mode 100644
index e69de29b..00000000
diff --git a/ranging/framework/api/test-removed.txt b/ranging/framework/api/test-removed.txt
deleted file mode 100644
index e69de29b..00000000
diff --git a/ranging/framework/jarjar-rules.txt b/ranging/framework/jarjar-rules.txt
index 54088a52..bcec79bf 100644
--- a/ranging/framework/jarjar-rules.txt
+++ b/ranging/framework/jarjar-rules.txt
@@ -1,3 +1,9 @@
 ## used by both framework-uwb and service-uwb ##
 # Statically included module utils.
-rule com.android.modules.utils.** com.android.x.ranging.@0
\ No newline at end of file
+rule com.android.modules.utils.** com.android.x.ranging.@0
+# Statically included ranging flags.
+rule com.android.ranging.flags.** com.android.x.ranging.@0
+# Statically included UWB support lib and guava lib.
+rule com.google.common.** com.android.x.ranging.@0
+# Included by support lib.
+rule com.android.internal.util.** com.android.x.ranging.@0
diff --git a/ranging/framework/java/android/ranging/CapabilitiesListener.java b/ranging/framework/java/android/ranging/CapabilitiesListener.java
new file mode 100644
index 00000000..7ae8e77b
--- /dev/null
+++ b/ranging/framework/java/android/ranging/CapabilitiesListener.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging;
+
+import android.annotation.NonNull;
+import android.os.Binder;
+import android.os.RemoteException;
+import android.ranging.RangingManager.RangingCapabilitiesCallback;
+import android.util.Log;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.Executor;
+
+/**
+ * @hide
+ */
+public class CapabilitiesListener extends IRangingCapabilitiesCallback.Stub {
+
+    private static final String TAG = CapabilitiesListener.class.getSimpleName();
+    private final IRangingAdapter mRangingAdapter;
+    private boolean mIsRegistered = false;
+
+    private final Map<RangingCapabilitiesCallback, Executor> mCallbackMap =
+            new ConcurrentHashMap<>();
+    private RangingCapabilities mCachedCapabilities;
+
+    public CapabilitiesListener(@NonNull IRangingAdapter rangingAdapter) {
+        mRangingAdapter = rangingAdapter;
+    }
+
+
+    public void register(@NonNull Executor executor,
+            @NonNull RangingCapabilitiesCallback callback) {
+        if (mCallbackMap.containsKey(callback)) {
+            return;
+        }
+        mCallbackMap.put(callback, executor);
+
+        if (!mIsRegistered) {
+            try {
+                mRangingAdapter.registerCapabilitiesCallback(this);
+                mIsRegistered = true;
+            } catch (RemoteException e) {
+                Log.w(TAG, "Failed to register capabilities callback");
+                throw e.rethrowFromSystemServer();
+            }
+        } else {
+            sendCurrentCapabilities(callback);
+        }
+    }
+
+    public void unregister(@NonNull RangingCapabilitiesCallback callback) {
+        synchronized (this) {
+            if (!mCallbackMap.containsKey(callback)) {
+                return;
+            }
+            mCallbackMap.remove(callback);
+
+            if (mCallbackMap.isEmpty() && mIsRegistered) {
+                try {
+                    mRangingAdapter.unregisterCapabilitiesCallback(this);
+                    mIsRegistered = false;
+                } catch (RemoteException e) {
+                    Log.w(TAG, "Failed to unregister capabilities callback");
+                    throw e.rethrowFromSystemServer();
+                }
+            }
+        }
+    }
+
+    private void sendCurrentCapabilities(@NonNull RangingCapabilitiesCallback callback) {
+        synchronized (this) {
+            if (mCachedCapabilities != null) {
+                Executor executor = mCallbackMap.get(callback);
+                long identity = Binder.clearCallingIdentity();
+                try {
+                    executor.execute(() -> callback.onRangingCapabilities(mCachedCapabilities));
+                } finally {
+                    Binder.restoreCallingIdentity(identity);
+                }
+            }
+        }
+    }
+
+    private void onCapabilitiesUpdated(RangingCapabilities rangingCapabilities) {
+        synchronized (this) {
+            mCachedCapabilities = rangingCapabilities;
+            for (RangingCapabilitiesCallback cb : mCallbackMap.keySet()) {
+                sendCurrentCapabilities(cb);
+            }
+        }
+    }
+
+    @Override
+    public void onRangingCapabilities(RangingCapabilities rangingCapabilities)
+            throws RemoteException {
+        onCapabilitiesUpdated(rangingCapabilities);
+    }
+}
diff --git a/ranging/framework/java/android/ranging/DataNotificationConfig.java b/ranging/framework/java/android/ranging/DataNotificationConfig.java
new file mode 100644
index 00000000..caef9f12
--- /dev/null
+++ b/ranging/framework/java/android/ranging/DataNotificationConfig.java
@@ -0,0 +1,206 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging;
+
+import android.annotation.FlaggedApi;
+import android.annotation.IntDef;
+import android.annotation.NonNull;
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import com.android.ranging.flags.Flags;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * Represents the configuration for data notifications in ranging operations.
+ *
+ * <p>This class holds the configuration settings for how notifications are sent
+ * regarding the proximity of ranging devices.
+ */
+@FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
+public final class DataNotificationConfig implements Parcelable {
+
+    private final @NotificationConfigType int mNotificationConfigType;
+    private final int mProximityNearCm;
+    private final int mProximityFarCm;
+
+    private DataNotificationConfig(Parcel in) {
+        mNotificationConfigType = in.readInt();
+        mProximityNearCm = in.readInt();
+        mProximityFarCm = in.readInt();
+    }
+
+    @NonNull
+    public static final Creator<DataNotificationConfig> CREATOR = new Creator<>() {
+        @Override
+        public DataNotificationConfig createFromParcel(Parcel in) {
+            return new DataNotificationConfig(in);
+        }
+
+        @Override
+        public DataNotificationConfig[] newArray(int size) {
+            return new DataNotificationConfig[size];
+        }
+    };
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        dest.writeInt(mNotificationConfigType);
+        dest.writeInt(mProximityNearCm);
+        dest.writeInt(mProximityFarCm);
+    }
+
+    /**
+     * @hide
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({
+            DISABLE,
+            ENABLE,
+            PROXIMITY_LEVEL,
+            PROXIMITY_EDGE,
+    })
+    public @interface NotificationConfigType {
+    }
+
+    // Range data notification will be disabled.
+    public static final int DISABLE = 0;
+    // Range data notification will be enabled (default).
+    public static final int ENABLE = 1;
+    // Range data notification is enabled when peer device is in the configured range - [near, far].
+    public static final int PROXIMITY_LEVEL = 2;
+    //Range data notification is enabled when peer device enters or exits the configured range -
+    // [near, far].
+    public static final int PROXIMITY_EDGE = 3;
+
+
+    private DataNotificationConfig(Builder builder) {
+        if (builder.mProximityNearCm > builder.mProximityFarCm) {
+            throw new IllegalArgumentException(
+                    "Ntf proximity near cannot be greater than Ntf proximity far");
+        }
+        mNotificationConfigType = builder.mNotificationConfigType;
+        mProximityNearCm = builder.mProximityNearCm;
+        mProximityFarCm = builder.mProximityFarCm;
+    }
+
+    /**
+     * Returns the configured notification configuration type.
+     *
+     * @return the notification configuration type.
+     *
+     */
+    @NotificationConfigType
+    public int getNotificationConfigType() {
+        return mNotificationConfigType;
+    }
+
+    /**
+     * Returns the near proximity threshold in centimeters.
+     *
+     * @return the near proximity in centimeters.
+     */
+    public int getProximityNearCm() {
+        return mProximityNearCm;
+    }
+
+    /**
+     * Returns the far proximity threshold in centimeters.
+     *
+     * @return the far proximity in centimeters.
+     */
+    public int getProximityFarCm() {
+        return mProximityFarCm;
+    }
+
+    /** Builder for {@link DataNotificationConfig} */
+    public static final class Builder {
+        @NotificationConfigType
+        private int mNotificationConfigType = ENABLE;
+        private int mProximityNearCm = 0;
+        private int mProximityFarCm = 20_000;
+
+        /**
+         * Sets the notification configuration type.
+         *  <p> defaults to {@link NotificationConfigType#ENABLE}
+         *
+         * @param config The notification configuration type to set.
+         * @return this Builder instance.
+         */
+        @NonNull
+        public Builder setNotificationConfigType(@NotificationConfigType int config) {
+            mNotificationConfigType = config;
+            return this;
+        }
+
+        /**
+         * Sets the near proximity threshold in centimeters.
+         * <p> defaults to 0 cm.
+         *
+         * @param proximityCm The near proximity to set, in centimeters.
+         * @return this Builder instance.
+         */
+        @NonNull
+        public Builder setProximityNearCm(int proximityCm) {
+            mProximityNearCm = proximityCm;
+            return this;
+        }
+
+        /**
+         * Sets the far proximity threshold in centimeters.
+         * <p> defaults to 20000 cm.
+         *
+         * @param proximityCm The far proximity to set, in centimeters.
+         * @return this Builder instance.
+         */
+        @NonNull
+        public Builder setProximityFarCm(int proximityCm) {
+            mProximityFarCm = proximityCm;
+            return this;
+        }
+
+        /**
+         * Builds a new instance of {@link DataNotificationConfig}.
+         *
+         * @return a new {@link DataNotificationConfig} instance created using the current state of
+         * the builder.
+         */
+        @NonNull
+        public DataNotificationConfig build() {
+            return new DataNotificationConfig(this);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "DataNotificationConfig{ "
+                + "mNotificationConfigType="
+                + mNotificationConfigType
+                + ", mProximityNearCm="
+                + mProximityNearCm
+                + ", mProximityFarCm="
+                + mProximityFarCm
+                + " }";
+    }
+}
diff --git a/ranging/framework/java/android/ranging/IRangingAdapter.aidl b/ranging/framework/java/android/ranging/IRangingAdapter.aidl
index ca593f86..2c94381a 100644
--- a/ranging/framework/java/android/ranging/IRangingAdapter.aidl
+++ b/ranging/framework/java/android/ranging/IRangingAdapter.aidl
@@ -16,8 +16,42 @@
 
 package android.ranging;
 
+import android.content.AttributionSource;
+import android.ranging.IRangingCapabilitiesCallback;
+import android.ranging.IRangingCallbacks;
+import android.ranging.SessionHandle;
+import android.ranging.RangingPreference;
+import android.ranging.RangingDevice;
+import android.ranging.raw.RawResponderRangingParams;
+import android.ranging.oob.OobHandle;
+import android.ranging.oob.IOobSendDataListener;
+import android.ranging.oob.OobResponderRangingParams;
+
 /**
 *  @hide
 */
 interface IRangingAdapter {
+
+    void startRanging(in AttributionSource attributionSource, in SessionHandle sessionHandle,
+                 in RangingPreference rangingPreference, in IRangingCallbacks callbacks);
+
+    void reconfigureRangingInterval(in SessionHandle sessionHandle, int intervalSkipCount);
+
+    void addRawDevice(in SessionHandle sessionHandle, in RawResponderRangingParams rangingParams);
+
+    void addOobDevice(in SessionHandle sessionHandle, in OobResponderRangingParams rangingParams);
+
+    void removeDevice(in SessionHandle sessionHandle, in RangingDevice rangingDevice);
+
+    void stopRanging(in SessionHandle sessionHandle);
+
+    void registerCapabilitiesCallback(in IRangingCapabilitiesCallback rangingCapabilitiesCallback);
+
+    void unregisterCapabilitiesCallback(in IRangingCapabilitiesCallback rangingCapabilitiesCallback);
+
+    void oobDataReceived(in OobHandle oobHandle, in byte[] data);
+    void deviceOobDisconnected(in OobHandle oobHandle);
+    void deviceOobReconnected(in OobHandle oobHandle);
+    void deviceOobClosed(in OobHandle oobHandle);
+    void registerOobSendDataListener(in IOobSendDataListener oobSendDataListener);
 }
\ No newline at end of file
diff --git a/ranging/framework/java/android/ranging/IRangingCallbacks.aidl b/ranging/framework/java/android/ranging/IRangingCallbacks.aidl
new file mode 100644
index 00000000..9dedaf98
--- /dev/null
+++ b/ranging/framework/java/android/ranging/IRangingCallbacks.aidl
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging;
+
+import android.ranging.SessionHandle;
+import android.ranging.RangingDevice;
+import android.ranging.RangingData;
+
+/**
+*  @hide
+*/
+oneway interface IRangingCallbacks {
+    void onOpened(in SessionHandle session);
+    void onOpenFailed(in SessionHandle session, in int reason);
+    void onStarted(in SessionHandle session, in RangingDevice peer, in int technology);
+    void onResults(in SessionHandle session, in RangingDevice peer, in RangingData data);
+    void onStopped(in SessionHandle session, in RangingDevice peer, in int technology);
+    void onClosed(in SessionHandle session, in int reason);
+}
\ No newline at end of file
diff --git a/ranging/framework/java/android/ranging/IRangingCapabilitiesCallback.aidl b/ranging/framework/java/android/ranging/IRangingCapabilitiesCallback.aidl
new file mode 100644
index 00000000..108ea934
--- /dev/null
+++ b/ranging/framework/java/android/ranging/IRangingCapabilitiesCallback.aidl
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging;
+
+import android.ranging.RangingCapabilities;
+/**
+*  @hide
+*/
+oneway interface IRangingCapabilitiesCallback {
+    void onRangingCapabilities(in RangingCapabilities rangingCapabilities);
+}
\ No newline at end of file
diff --git a/ranging/framework/java/android/ranging/RangingCapabilities.aidl b/ranging/framework/java/android/ranging/RangingCapabilities.aidl
new file mode 100644
index 00000000..ce4bf16f
--- /dev/null
+++ b/ranging/framework/java/android/ranging/RangingCapabilities.aidl
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging;
+
+/**
+*  @hide
+*/
+parcelable RangingCapabilities;
\ No newline at end of file
diff --git a/ranging/framework/java/android/ranging/RangingCapabilities.java b/ranging/framework/java/android/ranging/RangingCapabilities.java
new file mode 100644
index 00000000..daa83431
--- /dev/null
+++ b/ranging/framework/java/android/ranging/RangingCapabilities.java
@@ -0,0 +1,258 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging;
+
+import android.annotation.FlaggedApi;
+import android.annotation.IntDef;
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.ranging.RangingManager.RangingTechnology;
+import android.ranging.ble.cs.CsRangingCapabilities;
+import android.ranging.uwb.UwbRangingCapabilities;
+import android.ranging.wifi.rtt.RttRangingCapabilities;
+
+import com.android.ranging.flags.Flags;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Represents the capabilities and availability of various ranging technologies.
+ *
+ * <p>The {@code RangingCapabilities} class encapsulates the status of different ranging
+ * technologies. It also allows querying the availability of other ranging technologies through a
+ * mapping of technology identifiers to availability statuses.</p>
+ */
+@FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
+public final class RangingCapabilities implements Parcelable {
+
+    /**
+     * Capabilities object for an individual ranging technology.
+     *
+     * @hide
+     */
+    public interface TechnologyCapabilities {
+        /** @return the technology that these capabilities are associated with. */
+        @RangingManager.RangingTechnology
+        int getTechnology();
+    }
+
+    @Nullable
+    private final UwbRangingCapabilities mUwbCapabilities;
+
+    @Nullable
+    private final RttRangingCapabilities mRttRangingCapabilities;
+
+    @Nullable
+    private final CsRangingCapabilities mCsCapabilities;
+
+    /**
+     * @hide
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @Target({ElementType.TYPE_USE})
+    @IntDef({
+            /* Ranging technology is not supported on this device. */
+            NOT_SUPPORTED,
+            /* Ranging technology is disabled. */
+            DISABLED_USER,
+            /* Ranging technology disabled due to regulation. */
+            DISABLED_REGULATORY,
+            /* Ranging technology is enabled. */
+            ENABLED,
+            /* Ranging technology disabled due to admin restrictions. */
+            DISABLED_USER_RESTRICTIONS
+    })
+    public @interface RangingTechnologyAvailability {
+    }
+
+    /**
+     * Indicates that the ranging technology is not supported on the current device.
+     */
+    public static final int NOT_SUPPORTED = 0;
+
+    /**
+     * Indicates that the ranging technology is disabled by the user.
+     */
+    public static final int DISABLED_USER = 1;
+
+    /**
+     * Indicates that the ranging technology is disabled due to regulatory restrictions.
+     */
+    public static final int DISABLED_REGULATORY = 2;
+
+    /**
+     * Indicates that the ranging technology is enabled and available for use.
+     */
+    public static final int ENABLED = 3;
+
+    /**
+     * Indicates that the ranging technology is disabled due to device usage restrictions.
+     */
+    public static final int DISABLED_USER_RESTRICTIONS = 4;
+
+    private final Map<@RangingManager.RangingTechnology Integer,
+            @RangingTechnologyAvailability Integer> mAvailabilities;
+
+    private RangingCapabilities(Builder builder) {
+        mUwbCapabilities =
+                (UwbRangingCapabilities) builder.mCapabilities.get(RangingManager.UWB);
+        mRttRangingCapabilities = (RttRangingCapabilities) builder.mCapabilities.get(
+                RangingManager.WIFI_NAN_RTT);
+        mCsCapabilities = (CsRangingCapabilities) builder.mCapabilities.get(RangingManager.BLE_CS);
+        mAvailabilities = builder.mAvailabilities;
+    }
+
+    private RangingCapabilities(Parcel in) {
+        mUwbCapabilities = in.readParcelable(
+                UwbRangingCapabilities.class.getClassLoader(),
+                UwbRangingCapabilities.class);
+        mRttRangingCapabilities = in.readParcelable(RttRangingCapabilities.class.getClassLoader(),
+                RttRangingCapabilities.class);
+        mCsCapabilities = in.readParcelable(
+                CsRangingCapabilities.class.getClassLoader(), CsRangingCapabilities.class);
+        int size = in.readInt();
+        mAvailabilities = new HashMap<>(size);
+        for (int i = 0; i < size; i++) {
+            int key = in.readInt();
+            int value = in.readInt();
+            mAvailabilities.put(key, value);
+        }
+    }
+
+    @NonNull
+    public static final Creator<RangingCapabilities> CREATOR =
+            new Creator<RangingCapabilities>() {
+                @Override
+                public RangingCapabilities createFromParcel(Parcel in) {
+                    return new RangingCapabilities(in);
+                }
+
+                @Override
+                public RangingCapabilities[] newArray(int size) {
+                    return new RangingCapabilities[size];
+                }
+            };
+
+    /**
+     * Gets a map containing the availability of various ranging technologies.
+     *
+     * <p>The map uses technology identifiers as keys and their respective availability
+     * statuses as values.</p>
+     *
+     * @return a {@link Map} with key {@link RangingTechnology} and value
+     * {@link RangingTechnologyAvailability}.
+     */
+    @NonNull
+    public Map<@RangingTechnology Integer, @RangingTechnologyAvailability Integer>
+            getTechnologyAvailability() {
+        return mAvailabilities;
+    }
+
+    /**
+     * Gets the UWB ranging capabilities.
+     *
+     * @return a {@link UwbRangingCapabilities} object or {@code null} if not available.
+     */
+    @Nullable
+    public UwbRangingCapabilities getUwbCapabilities() {
+        return mUwbCapabilities;
+    }
+
+    /**
+     * Gets the WiFi NAN-RTT ranging capabilities.
+     *
+     * @return a {@link RttRangingCapabilities} object or {@code null} if not available.
+     */
+    @Nullable
+    public RttRangingCapabilities getRttRangingCapabilities() {
+        return mRttRangingCapabilities;
+    }
+
+    /**
+     * Gets the BLE channel sounding ranging capabilities.
+     *
+     * @return a {@link CsRangingCapabilities} object or {@code null} if not available.
+     */
+    @Nullable
+    public CsRangingCapabilities getCsCapabilities() {
+        return mCsCapabilities;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(@androidx.annotation.NonNull Parcel dest, int flags) {
+        dest.writeParcelable(mUwbCapabilities, flags);
+        dest.writeParcelable(mRttRangingCapabilities, flags);
+        dest.writeParcelable(mCsCapabilities, flags);
+        dest.writeInt(mAvailabilities.size()); // Write map size
+        for (Map.Entry<Integer, Integer> entry : mAvailabilities.entrySet()) {
+            dest.writeInt(entry.getKey()); // Write the key
+            dest.writeInt(entry.getValue()); // Write the value
+        }
+    }
+
+    /**
+     * Builder for {@link RangingCapabilities}
+     *
+     * @hide
+     */
+    public static class Builder {
+        private final HashMap<Integer, TechnologyCapabilities> mCapabilities = new HashMap<>();
+        private final HashMap<Integer, Integer> mAvailabilities = new HashMap<>();
+
+        public Builder addCapabilities(@NonNull TechnologyCapabilities capabilities) {
+            mCapabilities.put(capabilities.getTechnology(), capabilities);
+            return this;
+        }
+
+        public Builder addAvailability(
+                @RangingTechnology int technology, @RangingTechnologyAvailability int availability
+        ) {
+            mAvailabilities.put(technology, availability);
+            return this;
+        }
+
+        public RangingCapabilities build() {
+            return new RangingCapabilities(this);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "RangingCapabilities{ "
+                + "mUwbCapabilities="
+                + mUwbCapabilities
+                + ", mRttRangingCapabilities="
+                + mRttRangingCapabilities
+                + ", mCsCapabilities="
+                + mCsCapabilities
+                + ", mAvailabilities="
+                + mAvailabilities
+                + " }";
+    }
+}
diff --git a/ranging/framework/java/android/ranging/RangingData.aidl b/ranging/framework/java/android/ranging/RangingData.aidl
new file mode 100644
index 00000000..0b5c32ed
--- /dev/null
+++ b/ranging/framework/java/android/ranging/RangingData.aidl
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging;
+
+parcelable RangingData;
diff --git a/ranging/framework/java/android/ranging/RangingData.java b/ranging/framework/java/android/ranging/RangingData.java
new file mode 100644
index 00000000..58e5a7f8
--- /dev/null
+++ b/ranging/framework/java/android/ranging/RangingData.java
@@ -0,0 +1,277 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging;
+
+import android.annotation.CurrentTimeMillisLong;
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.ranging.RangingManager.RangingTechnology;
+
+import com.android.ranging.flags.Flags;
+
+import java.util.Objects;
+
+/**
+ * Represents ranging data, including distance, azimuth, elevation, and RSSI measurements,
+ * along with the ranging technology used and a timestamp.
+ *
+ */
+@FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
+public final class RangingData implements Parcelable {
+
+    @RangingManager.RangingTechnology
+    private final int mRangingTechnology;
+    private final RangingMeasurement mDistance;
+    @Nullable private final RangingMeasurement mAzimuth;
+    @Nullable private final RangingMeasurement mElevation;
+    private final int mRssi;
+    private final long mTimestamp;
+
+    private RangingData(Builder builder) {
+        if (builder.mDistance == null) {
+            throw new IllegalArgumentException("Missing required parameter: distance");
+        }
+        if (builder.mTimestamp == Long.MIN_VALUE) {
+            throw new IllegalArgumentException("Missing required parameter: timestamp");
+        }
+        if (builder.mRangingTechnology == Integer.MIN_VALUE) {
+            throw new IllegalArgumentException("Missing required parameter: rangingTechnology");
+        }
+        mRangingTechnology = (int) builder.mRangingTechnology;
+        mDistance = builder.mDistance;
+        mAzimuth = builder.mAzimuth;
+        mElevation = builder.mElevation;
+        mRssi = builder.mRssi;
+        mTimestamp = builder.mTimestamp;
+    }
+
+    private RangingData(Parcel in) {
+        mRangingTechnology = in.readInt();
+        mDistance = Objects.requireNonNull(
+                in.readParcelable(RangingMeasurement.class.getClassLoader(),
+                        RangingMeasurement.class));
+        mAzimuth = in.readParcelable(
+                RangingMeasurement.class.getClassLoader(), RangingMeasurement.class);
+        mElevation = in.readParcelable(
+                RangingMeasurement.class.getClassLoader(), RangingMeasurement.class);
+        mRssi = in.readInt();
+        mTimestamp = in.readLong();
+    }
+
+    public static final @NonNull Creator<RangingData> CREATOR = new Creator<>() {
+        @Override
+        public RangingData createFromParcel(Parcel in) {
+            return new RangingData(in);
+        }
+
+        @Override
+        public RangingData[] newArray(int size) {
+            return new RangingData[size];
+        }
+    };
+
+    /**
+     * Returns the ranging technology used.
+     *
+     * @return The ranging technology as an integer.
+     */
+    public @RangingTechnology int getRangingTechnology() {
+        return mRangingTechnology;
+    }
+
+    /**
+     * Returns the distance measurement.
+     *
+     * @return The {@link RangingMeasurement} representing the distance.
+     */
+    @Nullable
+    public RangingMeasurement getDistance() {
+        return mDistance;
+    }
+
+    /**
+     * Returns the azimuth measurement, or {@code null} if not available.
+     *
+     * @return The {@link RangingMeasurement} representing the azimuth, or {@code null}.
+     */
+    @Nullable
+    public RangingMeasurement getAzimuth() {
+        return mAzimuth;
+    }
+
+    /**
+     * Returns the elevation measurement, or {@code null} if not available.
+     *
+     * @return The {@link RangingMeasurement} representing the elevation, or {@code null}.
+     */
+    @Nullable
+    public RangingMeasurement getElevation() {
+        return mElevation;
+    }
+
+    /**
+     * Returns whether an RSSI measurement is included with the data.
+     *
+     * @return The RSSI value as an integer.
+     */
+    public boolean hasRssi() {
+        return mRssi != Integer.MIN_VALUE;
+    }
+
+    /**
+     * Returns the RSSI (Received Signal Strength Indicator) value.
+     *
+     * @return The RSSI value as an integer.
+     * @throws IllegalStateException if rssi is not set.
+     */
+    public int getRssi() {
+        if (!hasRssi()) {
+            throw new IllegalStateException("rssi is not set");
+        }
+        return mRssi;
+    }
+
+    /**
+     * Returns the timestamp of when the ranging data was collected.
+     *
+     * @return The timestamp in milliseconds.
+     */
+    @CurrentTimeMillisLong
+    public long getTimestampMillis() {
+        return mTimestamp;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        dest.writeInt(mRangingTechnology);
+        dest.writeParcelable(mDistance, flags);
+        dest.writeParcelable(mAzimuth, flags);
+        dest.writeParcelable(mElevation, flags);
+        dest.writeInt(mRssi);
+        dest.writeLong(mTimestamp);
+    }
+
+    /**
+     * Builder class for creating instances of {@link RangingData}.
+     *
+     * @hide
+     */
+    public static final class Builder {
+        private int mRangingTechnology = Integer.MIN_VALUE;
+        private RangingMeasurement mDistance = null;
+        private RangingMeasurement mAzimuth = null;
+        private RangingMeasurement mElevation = null;
+        private int mRssi = Integer.MIN_VALUE;
+        private long mTimestamp = Long.MIN_VALUE;
+
+        /**
+         * Sets the ranging technology.
+         *
+         * @param rangingTechnology The ranging technology used.
+         * @return This {@link Builder} instance.
+         */
+        @NonNull
+        public Builder setRangingTechnology(@RangingTechnology int rangingTechnology) {
+            mRangingTechnology = rangingTechnology;
+            return this;
+        }
+
+        /**
+         * Sets the distance measurement.
+         *
+         * @param distance The {@link RangingMeasurement} representing the distance.
+         * @return This {@link Builder} instance.
+         *
+         * @throws IllegalArgumentException if the provided measurement is null.
+         */
+        @NonNull
+        public Builder setDistance(@NonNull RangingMeasurement distance) {
+            mDistance = distance;
+            return this;
+        }
+
+        /**
+         * Sets the azimuth measurement.
+         *
+         * @param azimuth The {@link RangingMeasurement} representing the azimuth.
+         * @return This {@link Builder} instance.
+         *
+         * @throws IllegalArgumentException if the provided measurement is null.
+         */
+        @NonNull
+        public Builder setAzimuth(@NonNull RangingMeasurement azimuth) {
+            mAzimuth = azimuth;
+            return this;
+        }
+
+        /**
+         * Sets the elevation measurement.
+         *
+         * @param elevation The {@link RangingMeasurement} representing the elevation.
+         * @return This {@link Builder} instance.
+         *
+         * @throws IllegalArgumentException if the provided measurement is null.
+         */
+        @NonNull
+        public Builder setElevation(@NonNull RangingMeasurement elevation) {
+            mElevation = elevation;
+            return this;
+        }
+
+        /**
+         * Sets the RSSI value.
+         *
+         * @param rssi The RSSI value as an integer.
+         * @return This {@link Builder} instance.
+         */
+        @NonNull
+        public Builder setRssi(int rssi) {
+            mRssi = rssi;
+            return this;
+        }
+
+        /**
+         * Sets the timestamp of the ranging data.
+         *
+         * @param timestamp The timestamp in milliseconds.
+         * @return This {@link Builder} instance.
+         */
+        @NonNull
+        public Builder setTimestampMillis(long timestamp) {
+            mTimestamp = timestamp;
+            return this;
+        }
+
+        /**
+         * Builds and returns a new instance of {@link RangingData}.
+         *
+         * @return A new {@link RangingData} instance.
+         */
+        @NonNull
+        public RangingData build() {
+            return new RangingData(this);
+        }
+    }
+}
diff --git a/ranging/framework/java/android/ranging/RangingDevice.aidl b/ranging/framework/java/android/ranging/RangingDevice.aidl
new file mode 100644
index 00000000..0783c45a
--- /dev/null
+++ b/ranging/framework/java/android/ranging/RangingDevice.aidl
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging;
+
+parcelable RangingDevice;
diff --git a/ranging/framework/java/android/ranging/RangingDevice.java b/ranging/framework/java/android/ranging/RangingDevice.java
new file mode 100644
index 00000000..281b683c
--- /dev/null
+++ b/ranging/framework/java/android/ranging/RangingDevice.java
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import com.android.ranging.flags.Flags;
+
+import java.util.UUID;
+
+/**
+ * Represents a ranging device identified by a unique UUID.
+ *
+ * <p> This class is designed for ranging operations, where each device involved in the ranging
+ * session is uniquely identified by a {@link UUID}.
+ *
+ */
+@FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
+public final class RangingDevice implements Parcelable {
+    private final UUID mId;
+
+    private RangingDevice(Builder builder) {
+        mId = builder.mId;
+    }
+
+    private RangingDevice(Parcel in) {
+        // Read the UUID as two long values (UUID is stored as two longs)
+        long mostSigBits = in.readLong();
+        long leastSigBits = in.readLong();
+        mId = new UUID(mostSigBits, leastSigBits);
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        dest.writeLong(mId.getMostSignificantBits());
+        dest.writeLong(mId.getLeastSignificantBits());
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @NonNull
+    public static final Creator<RangingDevice> CREATOR = new Creator<RangingDevice>() {
+        @Override
+        public RangingDevice createFromParcel(Parcel in) {
+            return new RangingDevice(in);
+        }
+
+        @Override
+        public RangingDevice[] newArray(int size) {
+            return new RangingDevice[size];
+        }
+    };
+
+    /**
+     * Returns the UUID that uniquely identifies the ranging device.
+     *
+     * @return The device's {@link UUID}.
+     */
+    @NonNull
+    public UUID getUuid() {
+        return mId;
+    }
+
+    @Override
+    public int hashCode() {
+        return mId.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (obj instanceof RangingDevice device) {
+            return mId.equals(device.getUuid());
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * A builder class for creating instances of {@link RangingDevice}.
+     */
+    public static final class Builder {
+        private UUID mId = UUID.randomUUID();
+
+        /**
+         * Sets the UUID for the device.
+         *
+         * @param id The {@link UUID} to assign to the device.
+         * @return This {@link Builder} instance.
+         *
+         * @throws IllegalArgumentException if the provided UUID is null.
+         */
+        @NonNull
+        public Builder setUuid(@NonNull UUID id) {
+            mId = id;
+            return this;
+        }
+
+        /**
+         * Builds a new instance of {@link RangingDevice} with the provided configuration.
+         *
+         * @return A new {@link RangingDevice} instance.
+         */
+        @NonNull
+        public RangingDevice build() {
+            return new RangingDevice(this);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "RangingDevice{ "
+                + mId
+                + " }";
+    }
+}
diff --git a/ranging/framework/java/android/ranging/RangingFrameworkInitializer.java b/ranging/framework/java/android/ranging/RangingFrameworkInitializer.java
index db37be28..cc3e1127 100644
--- a/ranging/framework/java/android/ranging/RangingFrameworkInitializer.java
+++ b/ranging/framework/java/android/ranging/RangingFrameworkInitializer.java
@@ -17,27 +17,30 @@
 package android.ranging;
 
 import android.annotation.FlaggedApi;
-import android.annotation.Hide;
 import android.annotation.SystemApi;
 import android.app.SystemServiceRegistry;
 import android.content.Context;
 
+import com.android.ranging.flags.Flags;
+
 
 /**
  * Class for performing registration for Ranging service.
  *
  * @hide
  */
-@FlaggedApi("com.android.ranging.flags.ranging_stack_enabled")
+@FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
 @SystemApi(client = SystemApi.Client.MODULE_LIBRARIES)
-public class RangingFrameworkInitializer {
+public final class RangingFrameworkInitializer {
     private RangingFrameworkInitializer() {}
 
     /**
-     * @hide
+     * Called by {@link SystemServiceRegistry}'s static initializer and registers Ranging service
+     * to {@link Context}, so that {@link Context#getSystemService} can return them.
+     *
+     * @throws IllegalStateException if this is called from anywhere besides
+     * {@link SystemServiceRegistry}
      */
-    @Hide
-    @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled")
     public static void registerServiceWrappers() {
         SystemServiceRegistry.registerContextAwareService(
                 Context.RANGING_SERVICE,
diff --git a/ranging/framework/java/android/ranging/RangingManager.java b/ranging/framework/java/android/ranging/RangingManager.java
index 1ff11f33..77d16a53 100644
--- a/ranging/framework/java/android/ranging/RangingManager.java
+++ b/ranging/framework/java/android/ranging/RangingManager.java
@@ -16,11 +16,25 @@
 
 package android.ranging;
 
+import android.annotation.CallbackExecutor;
 import android.annotation.FlaggedApi;
-import android.annotation.Hide;
+import android.annotation.IntDef;
 import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.annotation.RequiresNoPermission;
+import android.annotation.SystemService;
+import android.content.AttributionSource;
 import android.content.Context;
 
+import com.android.ranging.flags.Flags;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+import java.util.Objects;
+import java.util.concurrent.Executor;
+
 
 /**
  * This class provides a way to perform ranging operations such as querying the
@@ -30,30 +44,151 @@ import android.content.Context;
  * <p>To get a {@link RangingManager}, call the
  * <code>Context.getSystemService(RangingManager.class)</code>.
  *
- * @hide
  */
-//@SystemApi
-//@SystemService(Context.UWB_SERVICE)
 
-/**
- * @hide
- */
-@Hide
-@FlaggedApi("com.android.ranging.flags.ranging_stack_enabled")
+@SystemService(Context.RANGING_SERVICE)
+@FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
 public final class RangingManager {
     private static final String TAG = "RangingManager";
 
-    public RangingManager(@NonNull Context context, IRangingAdapter adapter) {
+    private final Context mContext;
+    private final IRangingAdapter mRangingAdapter;
+    private final CapabilitiesListener mCapabilitiesListener;
 
-    }
+    private final RangingSessionManager mRangingSessionManager;
+
+    /**
+     * The interface Ranging technology.
+     *
+     * @hide
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @Target({ElementType.TYPE_USE})
+    @IntDef({
+            UWB,
+            BLE_CS,
+            WIFI_NAN_RTT,
+            BLE_RSSI,
+    })
+    public @interface RangingTechnology {}
+    /**
+     * Ultra-Wideband (UWB) technology.
+     */
+    public static final int UWB = 0;
+
+    /**
+     * Bluetooth Channel Sounding (BT-CS) technology.
+     */
+    public static final int BLE_CS = 1;
+
+    /**
+     * WiFi Round Trip Time (WiFi-RTT) technology.
+     */
+    public static final int WIFI_NAN_RTT = 2;
+
+    /**
+     * Bluetooth Low Energy (BLE) RSSI-based ranging technology.
+     */
+    public static final int BLE_RSSI = 3;
 
     /**
      * @hide
      */
-    @Hide
+    public RangingManager(@NonNull Context context, @NonNull IRangingAdapter adapter) {
+        mContext = context;
+        mRangingAdapter = adapter;
+        mCapabilitiesListener = new CapabilitiesListener(adapter);
+        mRangingSessionManager = new RangingSessionManager(adapter);
+    }
+
+    /**
+     * Registers a callback to receive ranging capabilities updates.
+     *
+     * @param executor The {@link Executor} on which the callback will be executed.
+     *                 Must not be null.
+     * @param callback The {@link RangingCapabilitiesCallback} that will handle the
+     *                 capabilities updates. Must not be null.
+     * @throws NullPointerException if the {@code executor} or {@code callback} is null.
+     */
+    @RequiresNoPermission
+    @NonNull
+    public void registerCapabilitiesCallback(
+            @NonNull @CallbackExecutor Executor executor,
+            @NonNull RangingCapabilitiesCallback callback) {
+        Objects.requireNonNull(executor, "Executor cannot be null");
+        Objects.requireNonNull(callback, "Capabilities callback cannot be null");
+        mCapabilitiesListener.register(executor, callback);
+    }
+
+    /**
+     * Unregisters a previously registered ranging capabilities callback.
+     *
+     * @param callback The {@link RangingCapabilitiesCallback} to be unregistered.
+     *                 Must not be null.
+     * @throws NullPointerException if the {@code callback} is null.
+     */
+    @RequiresNoPermission
     @NonNull
-    @FlaggedApi("com.android.ranging.flags.ranging_stack_enabled")
-    RangingSession createRangingSession() {
-        return new RangingSession();
+    public void unregisterCapabilitiesCallback(@NonNull RangingCapabilitiesCallback callback) {
+        Objects.requireNonNull(callback, "Capabilities callback cannot be null");
+        mCapabilitiesListener.unregister(callback);
+    }
+
+    /**
+     * Creates a new ranging session. A ranging session enables the application
+     * to perform ranging operations using available technologies such as
+     * UWB (Ultra-Wideband) or WiFi RTT (Round Trip Time).
+     *
+     * <p>This method returns a {@link RangingSession} instance, which can be
+     * used to initiate, manage, and stop ranging operations. The provided
+     * {@link RangingSession.Callback} will be used to receive session-related
+     * events, such as session start, stop, and ranging updates.
+     *
+     * <p>It is recommended to provide an appropriate {@link Executor} to ensure
+     * that callback events are handled on a suitable thread.
+     *
+     * @param callback the {@link RangingSession.Callback} to handle session-related events.
+     *                 Must not be {@code null}.
+     * @param executor the {@link Executor} on which the callback will be invoked.
+     *                 Must not be {@code null}.
+     * @return the {@link RangingSession} instance if the session was successfully created,
+     * or {@code null} if the session could not be created.
+     * @throws NullPointerException if {@code callback} or {@code executor} is null.
+     * @throws SecurityException    if the calling app does not have the necessary permissions
+     *                              to create a ranging session.
+     */
+    @RequiresNoPermission
+    @Nullable
+    public RangingSession createRangingSession(@NonNull Executor executor,
+            @NonNull RangingSession.Callback callback) {
+        Objects.requireNonNull(executor, "Executor cannot be null");
+        Objects.requireNonNull(callback, "Callback cannot be null");
+        return createRangingSessionInternal(mContext.getAttributionSource(), callback, executor);
+    }
+
+    private RangingSession createRangingSessionInternal(AttributionSource attributionSource,
+            RangingSession.Callback callback, Executor executor) {
+        return mRangingSessionManager.createRangingSessionInstance(attributionSource, callback,
+                executor);
+    }
+
+    /**
+     * Callback interface to receive the availabilities and capabilities of all the ranging
+     * technology supported by the device.
+     *
+     * <p>This interface is used to asynchronously provide information about the
+     * supported ranging capabilities of the device. The callback is invoked first time when
+     * registered and if any capabilities are updated until it is unregistered. </p>
+     */
+    public interface RangingCapabilitiesCallback {
+
+        /**
+         * Called when the ranging capabilities are available.
+         *
+         * @param capabilities the {@link RangingCapabilities} object containing
+         *                     detailed information about the supported features
+         *                     and limitations of the ranging technology.
+         */
+        void onRangingCapabilities(@NonNull RangingCapabilities capabilities);
     }
 }
diff --git a/ranging/framework/java/android/ranging/RangingMeasurement.java b/ranging/framework/java/android/ranging/RangingMeasurement.java
new file mode 100644
index 00000000..c1aefa6b
--- /dev/null
+++ b/ranging/framework/java/android/ranging/RangingMeasurement.java
@@ -0,0 +1,176 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging;
+
+import android.annotation.FlaggedApi;
+import android.annotation.IntDef;
+import android.annotation.NonNull;
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import com.android.ranging.flags.Flags;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * Represents a ranging measurement.
+ *
+ * <p>This class provides a measurement result, such as a distance or angle.
+ *
+ */
+@FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
+public final class RangingMeasurement implements Parcelable {
+
+    /**
+     * @hide
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({
+            CONFIDENCE_LOW,
+            CONFIDENCE_MEDIUM,
+            CONFIDENCE_HIGH
+    })
+    public @interface Confidence {
+    }
+
+    /** Ranging measurement with low confidence.
+     *
+     */
+    public static final int CONFIDENCE_LOW = 0;
+    /** Ranging measurement with medium confidence.
+     *
+     */
+    public static final int CONFIDENCE_MEDIUM = 1;
+    /** Ranging measurement with high confidence.
+     *
+     */
+    public static final int CONFIDENCE_HIGH = 2;
+    private final double mMeasurement;
+    @Confidence
+    private final int mConfidence;
+
+    private RangingMeasurement(Builder builder) {
+        if (Double.isNaN(builder.mMeasurement)) {
+            throw new IllegalArgumentException("Missing required parameter: measurement");
+        }
+        mMeasurement = builder.mMeasurement;
+        mConfidence = builder.mConfidence;
+    }
+
+    private RangingMeasurement(@NonNull Parcel in) {
+        mMeasurement = in.readDouble();
+        mConfidence = in.readInt();
+    }
+
+    @NonNull
+    public static final Creator<RangingMeasurement> CREATOR = new Creator<RangingMeasurement>() {
+        @Override
+        public RangingMeasurement createFromParcel(Parcel in) {
+            return new RangingMeasurement(in);
+        }
+
+        @Override
+        public RangingMeasurement[] newArray(int size) {
+            return new RangingMeasurement[size];
+        }
+    };
+
+    /**
+     * Returns the measurement value.
+     *
+     * @return The measurement, such as a distance in meters or an angle in degrees.
+     */
+    public double getMeasurement() {
+        return mMeasurement;
+    }
+
+    /**
+     * Returns the confidence score for this measurement.
+     *
+     */
+    @Confidence
+    public int getConfidence() {
+        return mConfidence;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        dest.writeDouble(mMeasurement);
+        dest.writeInt(mConfidence);
+    }
+
+    /**
+     * A builder class for creating instances of {@link RangingMeasurement}.
+     *
+     * @hide
+     */
+    public static final class Builder {
+        private double mMeasurement = Double.NaN;
+        @Confidence private int mConfidence = CONFIDENCE_MEDIUM;
+
+        /**
+         * Sets the measurement value.
+         *
+         * @param measurement The measurement value, such as a distance in meters or angle in
+         *                    degrees.
+         * @return This {@link Builder} instance.
+         */
+        @NonNull
+        public Builder setMeasurement(double measurement) {
+            mMeasurement = measurement;
+            return this;
+        }
+
+        /**
+         * Sets the confidence score for the measurement.
+         *
+         * @param confidence indicating confidence in the measurement.
+         * @return This {@link Builder} instance.
+         */
+        @NonNull
+        public Builder setConfidence(@Confidence int confidence) {
+            mConfidence = confidence;
+            return this;
+        }
+
+        /**
+         * Builds a new {@link RangingMeasurement} instance with the specified parameters.
+         *
+         * @return A new {@link RangingMeasurement} object.
+         */
+        @NonNull
+        public RangingMeasurement build() {
+            return new RangingMeasurement(this);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "RangingMeasurement{ "
+                + "mMeasurement="
+                + mMeasurement
+                + ", mConfidence="
+                + mConfidence
+                + " }";
+    }
+}
diff --git a/ranging/framework/java/android/ranging/RangingParams.java b/ranging/framework/java/android/ranging/RangingParams.java
new file mode 100644
index 00000000..4b6fc9da
--- /dev/null
+++ b/ranging/framework/java/android/ranging/RangingParams.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging;
+
+import android.annotation.FlaggedApi;
+import android.annotation.IntDef;
+import android.annotation.SuppressLint;
+import android.os.Parcelable;
+
+import com.android.ranging.flags.Flags;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * Abstract class to represent type of ranging parameters.
+ *
+ * <p>Subclasses include:</p>
+ * <ul>
+ *     <li>{@link android.ranging.raw.RawResponderRangingParams}</li>
+ *     <li>{@link android.ranging.raw.RawInitiatorRangingParams}</li>
+ *     <li>{@link android.ranging.oob.OobResponderRangingParams}</li>
+ *     <li>{@link android.ranging.oob.OobInitiatorRangingParams}</li>
+ * </ul>
+ */
+@FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
+@SuppressLint({"ParcelCreator", "ParcelNotFinal"})
+public abstract class RangingParams implements Parcelable {
+    /**
+     * @hide
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({
+            RANGING_SESSION_RAW,
+            RANGING_SESSION_OOB,
+    })
+    public @interface RangingSessionType {
+    }
+
+    protected RangingParams() { }
+
+    /** Ranging session with the out-of-band negotiations performed by the app. */
+    public static final int RANGING_SESSION_RAW = 0;
+    /** Ranging session with the out-of-band negotiations performed by the ranging API. */
+    public static final int RANGING_SESSION_OOB = 1;
+
+    @RangingSessionType
+    private int mRangingSessionType;
+
+    /**
+     * @hide
+     */
+    protected void setRangingSessionType(@RangingSessionType int rangingSessionType) {
+        mRangingSessionType = rangingSessionType;
+    }
+
+    /**
+     * Gets the ranging session type {@link RangingSessionType}
+     *
+     * @return the type of ranging session.
+     */
+    public int getRangingSessionType() {
+        return mRangingSessionType;
+    }
+
+    @Override
+    public String toString() {
+        return "RangingParams{ "
+                + "mRangingSessionType="
+                + mRangingSessionType
+                + " }";
+    }
+}
diff --git a/ranging/framework/java/android/ranging/RangingPreference.aidl b/ranging/framework/java/android/ranging/RangingPreference.aidl
new file mode 100644
index 00000000..acf14b57
--- /dev/null
+++ b/ranging/framework/java/android/ranging/RangingPreference.aidl
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging;
+
+/**
+*  @hide
+*/
+parcelable RangingPreference;
\ No newline at end of file
diff --git a/ranging/framework/java/android/ranging/RangingPreference.java b/ranging/framework/java/android/ranging/RangingPreference.java
new file mode 100644
index 00000000..08663820
--- /dev/null
+++ b/ranging/framework/java/android/ranging/RangingPreference.java
@@ -0,0 +1,225 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging;
+
+import android.annotation.FlaggedApi;
+import android.annotation.IntDef;
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import com.android.ranging.flags.Flags;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.Objects;
+
+/**
+ * Represents the configuration preferences for a ranging session.
+ *
+ * <p>The {@code RangingPreference} class allows users to specify various parameters
+ * required for a ranging session, including ranging parameters, sensor fusion settings,
+ * and data notification configurations. It provides a {@link Builder} to construct
+ * an instance with custom configurations.</p>
+ */
+@FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
+public final class RangingPreference implements Parcelable {
+
+    /**
+     * @hide
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({
+            DEVICE_ROLE_RESPONDER,
+            DEVICE_ROLE_INITIATOR,
+    })
+    public @interface DeviceRole {
+    }
+
+    /** The device that responds to a session. */
+    public static final int DEVICE_ROLE_RESPONDER = 0;
+    /** The device that initiates the session. */
+    public static final int DEVICE_ROLE_INITIATOR = 1;
+
+    @DeviceRole
+    private final int mDeviceRole;
+    private final RangingParams mRangingParameters;
+
+    private final SessionConfiguration mSessionConfig;
+
+    private RangingPreference(Builder builder) {
+        mDeviceRole = builder.mDeviceRole;
+        mRangingParameters = builder.mRangingParameters;
+        mSessionConfig = builder.mSessionConfig;
+    }
+
+    private RangingPreference(Parcel in) {
+        mDeviceRole = in.readInt();
+        mRangingParameters = in.readParcelable(
+                RangingParams.class.getClassLoader(),
+                RangingParams.class);
+        mSessionConfig = in.readParcelable(
+                SessionConfiguration.class.getClassLoader(), SessionConfiguration.class);
+    }
+
+    @NonNull
+    public static final Creator<RangingPreference> CREATOR = new Creator<>() {
+        @Override
+        public RangingPreference createFromParcel(Parcel in) {
+            return new RangingPreference(in);
+        }
+
+        @Override
+        public RangingPreference[] newArray(int size) {
+            return new RangingPreference[size];
+        }
+    };
+
+    /**
+     * Returns the device role.
+     */
+    @DeviceRole
+    public int getDeviceRole() {
+        return mDeviceRole;
+    }
+
+    /**
+     * Returns the ranging parameters associated with this preference.
+     *
+     * @return the {@link android.ranging.RangingParams} or {@code null} if not set.
+     */
+    @Nullable
+    public RangingParams getRangingParameters() {
+        return mRangingParameters;
+    }
+
+    /**
+     * Returns the ranging session configuration params.
+     *
+     * @return a non-null {@link SessionConfiguration} instance.
+     */
+    @NonNull
+    public SessionConfiguration getSessionConfiguration() {
+        return mSessionConfig;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        dest.writeInt(mDeviceRole);
+        dest.writeParcelable(mRangingParameters, flags);
+        dest.writeParcelable(mSessionConfig, flags);
+    }
+
+    /**
+     * Builder for creating instances of {@code RangingPreference}.
+     *
+     * <p>This Builder class provides a flexible way to construct a {@link RangingPreference}
+     * instance by setting required and optional parameters. It ensures that all necessary
+     * parameters are specified and provides default values for optional configurations.</p>
+     *
+     * <p>Example usage:</p>
+     *
+     * <pre>{@code
+     * RangingPreference rangingPreference = new RangingPreference.Builder(DEVICE_ROLE_RESPONDER,
+     *     new RawResponderRangingParams.Builder()
+     *         .setRawRangingDevice(
+     *             new RawRangingDevice.Builder()
+     *                 .setRangingDevice(
+     *                     new RangingDevice.Builder()
+     *                         .build())
+     *                .setBleRssiRangingParams(
+     *                new BleRssiRangingParams.Builder("AA:BB:CC:00:11:22")
+     *                    .build())
+     *            .build())
+     *        build())
+     *    .build();
+     * }</pre>
+     */
+    public static final class Builder {
+        @DeviceRole
+        private final int mDeviceRole;
+        private final RangingParams mRangingParameters;
+        private SessionConfiguration mSessionConfig = new SessionConfiguration.Builder().build();
+
+        /**
+         * Creates a Builder instance with the required device role and {@link RangingParams}.
+         *
+         * @param role the role of the device in {@link DeviceRole}
+         * @param rangingParams the {@link RangingParams} to use.
+         *                      Needs to be an instance of one of the following:
+         *  <ul>
+         *     <li>{@link android.ranging.raw.RawResponderRangingParams}</li>
+         *     <li>{@link android.ranging.raw.RawInitiatorRangingParams}</li>
+         *     <li>{@link android.ranging.oob.OobResponderRangingParams}</li>
+         *     <li>{@link android.ranging.oob.OobInitiatorRangingParams}</li>
+         *  </ul>
+         * @throws NullPointerException if {@code rangingParams} is null.
+         */
+        public Builder(@DeviceRole int role, @NonNull RangingParams rangingParams) {
+            Objects.requireNonNull(rangingParams);
+            mDeviceRole = role;
+            mRangingParameters = rangingParams;
+        }
+
+        /**
+         * Sets the configuration parameters for the ranging session policy.
+         *
+         * <p>This method allows specifying additional configuration parameters encapsulated in
+         * {@link SessionConfiguration} for fine-tuning the behavior of the ranging session.
+         *
+         * @param config the {@link SessionConfiguration}.
+         * @return this {@link Builder} instance.
+         * @throws NullPointerException if {@code params} is null.
+         */
+        @NonNull
+        public Builder setSessionConfiguration(@NonNull SessionConfiguration config) {
+            Objects.requireNonNull(config);
+            mSessionConfig = config;
+            return this;
+        }
+
+        /**
+         * Builds the {@code RangingPreference} instance.
+         *
+         * <p>If the {@link SessionConfiguration} is not set, default instances will be used.
+         *
+         * @return a new {@code RangingPreference} instance.
+         */
+        @NonNull
+        public RangingPreference build() {
+            return new RangingPreference(this);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "RangingPreference{ "
+                + "mDeviceRole="
+                + mDeviceRole
+                + ", mRangingParameters="
+                + mRangingParameters
+                + ", mSessionConfig="
+                + mSessionConfig
+                + " }";
+    }
+}
diff --git a/ranging/framework/java/android/ranging/RangingSession.java b/ranging/framework/java/android/ranging/RangingSession.java
index 5cf2b487..5432f770 100644
--- a/ranging/framework/java/android/ranging/RangingSession.java
+++ b/ranging/framework/java/android/ranging/RangingSession.java
@@ -16,14 +16,431 @@
 
 package android.ranging;
 
+import android.Manifest;
 import android.annotation.FlaggedApi;
-import android.annotation.Hide;
+import android.annotation.IntDef;
+import android.annotation.IntRange;
+import android.annotation.NonNull;
+import android.annotation.RequiresPermission;
+import android.content.AttributionSource;
+import android.os.CancellationSignal;
+import android.os.RemoteException;
+import android.ranging.oob.DeviceHandle;
+import android.ranging.oob.OobHandle;
+import android.ranging.oob.OobInitiatorRangingParams;
+import android.ranging.oob.OobResponderRangingParams;
+import android.ranging.oob.TransportHandle;
+import android.ranging.raw.RawResponderRangingParams;
+import android.util.Log;
+
+import com.android.ranging.flags.Flags;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
 
 
 /**
- * @hide
+ * Represents a session for performing ranging operations. A {@link RangingSession} manages
+ * the lifecycle of a ranging operation, including start, stop, and event callbacks.
+ *
+ * <p>All methods are asynchronous and rely on the provided {@link Executor} to invoke
+ * callbacks on appropriate threads.
+ *
+ * <p>This class implements {@link AutoCloseable}, ensuring that resources can be
+ * automatically released when the session is closed.
+ *
  */
-@Hide
-@FlaggedApi("com.android.ranging.flags.ranging_stack_enabled")
-public class RangingSession {
+@FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
+public final class RangingSession implements AutoCloseable {
+    private static final String TAG = "RangingSession";
+    private final AttributionSource mAttributionSource;
+    private final SessionHandle mSessionHandle;
+    private final IRangingAdapter mRangingAdapter;
+    private final RangingSessionManager mRangingSessionManager;
+    private final Callback mCallback;
+    private final Executor mExecutor;
+    private final Map<RangingDevice, android.ranging.oob.TransportHandle> mTransportHandles =
+            new ConcurrentHashMap<>();
+
+
+    /**
+     * @hide
+     */
+    public RangingSession(RangingSessionManager rangingSessionManager,
+            AttributionSource attributionSource,
+            SessionHandle sessionHandle, IRangingAdapter rangingAdapter,
+            Callback callback, Executor executor) {
+        mRangingSessionManager = rangingSessionManager;
+        mAttributionSource = attributionSource;
+        mSessionHandle = sessionHandle;
+        mRangingAdapter = rangingAdapter;
+        mCallback = callback;
+        mExecutor = executor;
+    }
+
+    /**
+     * Starts the ranging session with the provided ranging preferences.
+     * <p>The {@link Callback#onOpened()} will be called when the session finishes starting.
+     *
+     * <p>The provided {@link RangingPreference} determines the configuration for the session.
+     * A {@link CancellationSignal} is returned to allow the caller to cancel the session
+     * if needed. If the session is canceled, the {@link #close()} method will be invoked
+     * automatically to release resources.
+     *
+     * @param rangingPreference {@link RangingPreference} the preferences for configuring the
+     *                          ranging session.
+     * @return a {@link CancellationSignal} to close the session.
+     */
+    @RequiresPermission(Manifest.permission.RANGING)
+    @NonNull
+    public CancellationSignal start(@NonNull RangingPreference rangingPreference) {
+        //TODO : check whether this needs to be called after start, or handle when a session is
+        // created in ranging service.
+        if (rangingPreference.getRangingParameters().getRangingSessionType()
+                == RangingParams.RANGING_SESSION_OOB) {
+            mRangingSessionManager.registerOobSendDataListener();
+            setupTransportHandles(rangingPreference);
+        }
+        try {
+            mRangingAdapter.startRanging(mAttributionSource, mSessionHandle, rangingPreference,
+                    mRangingSessionManager);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+        CancellationSignal cancellationSignal = new CancellationSignal();
+        cancellationSignal.setOnCancelListener(this::close);
+
+        return cancellationSignal;
+    }
+
+    private void setupTransportHandles(RangingPreference rangingPreference) {
+        List<DeviceHandle> deviceHandleList = new ArrayList<>();
+        if (rangingPreference.getRangingParameters() instanceof OobInitiatorRangingParams) {
+            deviceHandleList.addAll(((OobInitiatorRangingParams)
+                    rangingPreference.getRangingParameters()).getDeviceHandles());
+        } else if (rangingPreference.getRangingParameters() instanceof OobResponderRangingParams) {
+            deviceHandleList.add(((OobResponderRangingParams)
+                    rangingPreference.getRangingParameters()).getDeviceHandle());
+        }
+        for (DeviceHandle deviceHandle : deviceHandleList) {
+            TransportHandleReceiveCallback receiveCallback =
+                    new TransportHandleReceiveCallback(deviceHandle.getRangingDevice());
+            deviceHandle.getTransportHandle().registerReceiveCallback(
+                    Executors.newCachedThreadPool(), receiveCallback);
+            mTransportHandles.put(deviceHandle.getRangingDevice(),
+                    deviceHandle.getTransportHandle());
+        }
+    }
+
+    /**
+     * Adds a new device to an ongoing ranging session.
+     * <p>
+     * This method allows for adding a new device to an active ranging session using either
+     * raw or out-of-band (OOB) ranging parameters. Only devices represented by
+     * {@link RawResponderRangingParams} or {@link OobResponderRangingParams} are supported.
+     * If the provided {@link RangingParams} does not match one of these types, the addition fails
+     * and invokes {@link Callback#onOpenFailed(int)} with a reason of
+     * {@link Callback#REASON_UNSUPPORTED}.
+     * </p>
+     *
+     * @param deviceRangingParams the ranging parameters for the device to be added,
+     *                            which must be an instance of either
+     *                            {@link RawResponderRangingParams}
+     *                            or {@link OobResponderRangingParams}.
+     *
+     * @apiNote If the underlying ranging technology cannot support this dynamic addition, failure
+     * will be indicated via {@code Callback#onStartFailed(REASON_UNSUPPORTED, RangingDevice)}
+     *
+     */
+    @RequiresPermission(Manifest.permission.RANGING)
+    public void addDeviceToRangingSession(@NonNull RangingParams deviceRangingParams) {
+        try {
+            if (deviceRangingParams instanceof RawResponderRangingParams) {
+                mRangingAdapter.addRawDevice(mSessionHandle,
+                        (RawResponderRangingParams) deviceRangingParams);
+            } else if (deviceRangingParams instanceof OobResponderRangingParams) {
+                mRangingAdapter.addOobDevice(mSessionHandle,
+                        (OobResponderRangingParams) deviceRangingParams);
+            } else {
+                mCallback.onOpenFailed(Callback.REASON_UNSUPPORTED);
+            }
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /**
+     * Removes a specific device from an ongoing ranging session.
+     * <p>
+     * This method removes a specified device from the active ranging session, stopping
+     * further ranging operations for that device. The operation is handled by the system
+     * server and may throw a {@link RemoteException} in case of server-side communication
+     * issues.
+     * </p>
+     *
+     * @param rangingDevice the device to be removed from the session.
+     * @apiNote Currently, this API is supported only for UWB multicast session if using
+     * {@link RangingParams#RANGING_SESSION_RAW}.
+     *
+     */
+    @RequiresPermission(Manifest.permission.RANGING)
+    public void removeDeviceFromRangingSession(@NonNull RangingDevice rangingDevice) {
+        try {
+            mRangingAdapter.removeDevice(mSessionHandle, rangingDevice);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /**
+     * Reconfigures the ranging interval for the current session by setting the interval
+     * skip count. The {@code intervalSkipCount} defines how many intervals should be skipped
+     * between successive ranging rounds. Valid values range from 0 to 255.
+     *
+     * @param intervalSkipCount the number of intervals to skip, ranging from 0 to 255.
+     */
+    @RequiresPermission(Manifest.permission.RANGING)
+    public void reconfigureRangingInterval(@IntRange(from = 0, to = 255) int intervalSkipCount) {
+        try {
+            mRangingAdapter.reconfigureRangingInterval(mSessionHandle, intervalSkipCount);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /**
+     * Stops the ranging session.
+     *
+     * <p>This method releases any ongoing ranging operations. If the operation fails,
+     * it will propagate a {@link RemoteException} from the system server.
+     */
+    @RequiresPermission(Manifest.permission.RANGING)
+    public void stop() {
+        try {
+            mRangingAdapter.stopRanging(mSessionHandle);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    /**
+     * @hide
+     */
+    public void onOpened() {
+        mExecutor.execute(mCallback::onOpened);
+    }
+
+    /**
+     * @hide
+     */
+    public void onOpenFailed(@Callback.Reason int reason) {
+        mExecutor.execute(() -> mCallback.onOpenFailed(reason));
+    }
+
+    /**
+     * @hide
+     */
+    public void onStarted(RangingDevice peer, @RangingManager.RangingTechnology int technology) {
+        mExecutor.execute(() -> mCallback.onStarted(peer, technology));
+    }
+
+    /**
+     * @hide
+     */
+    public void onResults(RangingDevice peer, RangingData data) {
+        mExecutor.execute(() -> mCallback.onResults(peer, data));
+    }
+
+    /**
+     * @hide
+     */
+    public void onStopped(RangingDevice peer, @RangingManager.RangingTechnology int technology) {
+        mExecutor.execute(() -> mCallback.onStopped(peer, technology));
+    }
+
+    /**
+     * @hide
+     */
+    public void onClosed(@Callback.Reason int reason) {
+        mExecutor.execute(() -> mCallback.onClosed(reason));
+    }
+
+    /**
+     * @hide
+     */
+    void sendOobData(RangingDevice toDevice, byte[] data) {
+        if (!mTransportHandles.containsKey(toDevice)) {
+            Log.e(TAG, "TransportHandle not found for session: " + mSessionHandle + ", device: "
+                    + toDevice);
+        }
+        mTransportHandles.get(toDevice).sendData(data);
+    }
+
+    @RequiresPermission(Manifest.permission.RANGING)
+    @Override
+    public void close() {
+        stop();
+    }
+
+    /**
+     * Callback interface for receiving ranging session events.
+     */
+    public interface Callback {
+        /**
+         * @hide
+         */
+        @Retention(RetentionPolicy.SOURCE)
+        @IntDef(value = {
+                REASON_UNKNOWN,
+                REASON_LOCAL_REQUEST,
+                REASON_REMOTE_REQUEST,
+                REASON_UNSUPPORTED,
+                REASON_SYSTEM_POLICY,
+                REASON_NO_PEERS_FOUND,
+        })
+        @interface Reason {
+        }
+
+        /**
+         * Indicates that the session was closed due to an unknown reason.
+         */
+        int REASON_UNKNOWN = 0;
+
+        /**
+         * Indicates that the session was closed because {@link AutoCloseable#close()} or
+         * {@link RangingSession#stop()} was called.
+         */
+        int REASON_LOCAL_REQUEST = 1;
+
+        /**
+         * Indicates that the session was closed at the request of a remote peer.
+         */
+        int REASON_REMOTE_REQUEST = 2;
+
+        /**
+         * Indicates that the session closed because the provided session parameters were not
+         * supported.
+         */
+        int REASON_UNSUPPORTED = 3;
+
+        /**
+         * Indicates that the local system policy forced the session to close, such
+         * as power management policy, airplane mode etc.
+         */
+        int REASON_SYSTEM_POLICY = 4;
+
+        /**
+         * Indicates that the session was closed because none of the specified peers were found.
+         */
+        int REASON_NO_PEERS_FOUND = 5;
+
+        /**
+         * Called when the ranging session opens successfully.
+         */
+        void onOpened();
+
+        /**
+         * Called when the ranging session failed to open.
+         *
+         * @param reason the reason for the failure, limited to values defined by
+         *               {@link Reason}.
+         */
+        void onOpenFailed(@Reason int reason);
+
+        /**
+         * Called when ranging has started with a particular peer using a particular technology
+         * during an ongoing session.
+         *
+         * @param peer       {@link RangingDevice} the peer with which ranging has started.
+         * @param technology {@link android.ranging.RangingManager.RangingTechnology}
+         *                   the ranging technology that started.
+         */
+        void onStarted(
+                @NonNull RangingDevice peer, @RangingManager.RangingTechnology int technology);
+
+        /**
+         * Called when ranging data has been received from a peer.
+         *
+         * @param peer {@link RangingDevice} the peer from which ranging data was received.
+         * @param data {@link RangingData} the received.
+         */
+        void onResults(@NonNull RangingDevice peer, @NonNull RangingData data);
+
+        /**
+         * Called when ranging has stopped with a particular peer using a particular technology
+         * during an ongoing session.
+         *
+         * @param peer       {@link RangingDevice} the peer with which ranging has stopped.
+         * @param technology {@link android.ranging.RangingManager.RangingTechnology}
+         *                   the ranging technology that stopped.
+         */
+        void onStopped(
+                @NonNull RangingDevice peer, @RangingManager.RangingTechnology int technology);
+
+        /**
+         * Called when the ranging session has closed.
+         *
+         * @param reason the reason why the session was closed, limited to values
+         *               defined by {@link Reason}.
+         */
+        void onClosed(@Reason int reason);
+
+    }
+
+    class TransportHandleReceiveCallback implements TransportHandle.ReceiveCallback {
+
+        private final android.ranging.oob.OobHandle mOobHandle;
+
+        TransportHandleReceiveCallback(RangingDevice device) {
+            mOobHandle = new OobHandle(mSessionHandle, device);
+        }
+
+        @Override
+        public void onReceiveData(byte[] data) {
+            mRangingSessionManager.oobDataReceived(mOobHandle, data);
+        }
+
+        @Override
+        public void onSendFailed() {
+        }
+
+        @Override
+        public void onDisconnect() {
+            mRangingSessionManager.deviceOobDisconnected(mOobHandle);
+        }
+
+        @Override
+        public void onReconnect() {
+            mRangingSessionManager.deviceOobReconnected(mOobHandle);
+        }
+
+        @Override
+        public void onClose() {
+            mRangingSessionManager.deviceOobClosed(mOobHandle);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "RangingSession{ "
+                + "mSessionHandle="
+                + mSessionHandle
+                + ", mRangingAdapter="
+                + mRangingAdapter
+                + ", mRangingSessionManager="
+                + mRangingSessionManager
+                + ", mCallback="
+                + mCallback
+                + ", mExecutor="
+                + mExecutor
+                + ", mTransportHandles="
+                + mTransportHandles
+                + " }";
+    }
 }
diff --git a/ranging/framework/java/android/ranging/RangingSessionManager.java b/ranging/framework/java/android/ranging/RangingSessionManager.java
new file mode 100644
index 00000000..e9b45048
--- /dev/null
+++ b/ranging/framework/java/android/ranging/RangingSessionManager.java
@@ -0,0 +1,190 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging;
+
+import android.content.AttributionSource;
+import android.os.Process;
+import android.os.RemoteException;
+import android.ranging.oob.IOobSendDataListener;
+import android.ranging.oob.OobHandle;
+import android.util.Log;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.Executor;
+
+/**
+ * @hide
+ */
+public final class RangingSessionManager extends IRangingCallbacks.Stub {
+
+    private static final String TAG = "RangingSessionManager";
+    private static long sSessionIdCounter = 1;
+    private final IRangingAdapter mRangingAdapter;
+    private final Map<SessionHandle, RangingSession> mSessions = new ConcurrentHashMap<>();
+    private boolean mOobListenerRegistered = false;
+
+    public RangingSessionManager(IRangingAdapter rangingAdapter) {
+        mRangingAdapter = rangingAdapter;
+    }
+
+    /**
+     * Lazy registration of Oob data listener.
+     */
+    public void registerOobSendDataListener() {
+        if (!mOobListenerRegistered) {
+            try {
+                mRangingAdapter.registerOobSendDataListener(new OobSendDataListener());
+                mOobListenerRegistered = true;
+            } catch (RemoteException e) {
+                Log.e(TAG, "Failed to register OobSendDataListener", e);
+            }
+        }
+    }
+
+    RangingSession createRangingSessionInstance(AttributionSource attributionSource,
+            RangingSession.Callback callback, Executor executor) {
+        SessionHandle sessionHandle = new SessionHandle(sSessionIdCounter++, attributionSource,
+                Process.myPid());
+        RangingSession rangingSession = new RangingSession(this, attributionSource, sessionHandle,
+                mRangingAdapter, callback, executor);
+        mSessions.put(sessionHandle, rangingSession);
+        return rangingSession;
+    }
+
+    @Override
+    public void onOpened(SessionHandle session) {
+        if (!mSessions.containsKey(session)) {
+            Log.e(TAG, "SessionHandle not found");
+            return;
+        }
+        mSessions.get(session).onOpened();
+    }
+
+    @Override
+    public void onOpenFailed(SessionHandle session, int reason) {
+        if (!mSessions.containsKey(session)) {
+            Log.e(TAG, "SessionHandle not found");
+            return;
+        }
+        mSessions.get(session).onOpenFailed(reason);
+    }
+
+    @Override
+    public void onStarted(SessionHandle session, RangingDevice peer, int technology) {
+        if (!mSessions.containsKey(session)) {
+            Log.e(TAG, "SessionHandle not found");
+            return;
+        }
+        mSessions.get(session).onStarted(peer, technology);
+    }
+
+    @Override
+    public void onResults(SessionHandle session, RangingDevice peer, RangingData data) {
+        if (!mSessions.containsKey(session)) {
+            Log.e(TAG, "SessionHandle not found");
+            return;
+        }
+        mSessions.get(session).onResults(peer, data);
+    }
+
+    @Override
+    public void onStopped(SessionHandle session, RangingDevice peer, int technology) {
+        if (!mSessions.containsKey(session)) {
+            Log.e(TAG, "SessionHandle not found");
+            return;
+        }
+        mSessions.get(session).onStopped(peer, technology);
+    }
+
+    @Override
+    public void onClosed(SessionHandle session, int reason) {
+        if (!mSessions.containsKey(session)) {
+            Log.e(TAG, "SessionHandle not found");
+            return;
+        }
+        mSessions.get(session).onClosed(reason);
+    }
+
+    /**
+     * Tells the service that OOB data has been received.
+     *
+     * @param oobHandle uniquely identifiers a session/device pair for OOB communication.
+     * @param data      payload
+     */
+    public void oobDataReceived(OobHandle oobHandle, byte[] data) {
+        try {
+            mRangingAdapter.oobDataReceived(oobHandle, data);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Failed mRangingAdapter.oobDataReceived", e);
+        }
+    }
+
+    /**
+     * Tells the service that OOB channel has been reconnected.
+     *
+     * @param oobHandle uniquely identifiers a session/device pair for OOB communication.
+     */
+    public void deviceOobReconnected(OobHandle oobHandle) {
+        try {
+            mRangingAdapter.deviceOobReconnected(oobHandle);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Failed mRangingAdapter.deviceOobReconnected", e);
+        }
+    }
+
+    /**
+     * Tells the service that OOB channel has been disconnected.
+     *
+     * @param oobHandle uniquely identifiers a session/device pair for OOB communication.
+     */
+    public void deviceOobDisconnected(OobHandle oobHandle) {
+        try {
+            mRangingAdapter.deviceOobDisconnected(oobHandle);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Failed mRangingAdapter.deviceOobDisconnected", e);
+        }
+
+    }
+
+    /**
+     * Tells the service that OOB channel has been permanently closed.
+     *
+     * @param oobHandle uniquely identifiers a session/device pair for OOB communication.
+     */
+    public void deviceOobClosed(OobHandle oobHandle) {
+        try {
+            mRangingAdapter.deviceOobClosed(oobHandle);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Failed mRangingAdapter.deviceOobClosed", e);
+        }
+    }
+
+    class OobSendDataListener extends IOobSendDataListener.Stub {
+
+        @Override
+        public void sendOobData(OobHandle oobHandle, byte[] data) throws RemoteException {
+            SessionHandle session = oobHandle.getSessionHandle();
+            if (!mSessions.containsKey(session)) {
+                Log.e(TAG, "SessionHandle not found, session: " + session);
+                return;
+            }
+            mSessions.get(session).sendOobData(oobHandle.getRangingDevice(),
+                    data);
+        }
+    }
+}
diff --git a/ranging/framework/java/android/ranging/SensorFusionParams.java b/ranging/framework/java/android/ranging/SensorFusionParams.java
new file mode 100644
index 00000000..69191f3a
--- /dev/null
+++ b/ranging/framework/java/android/ranging/SensorFusionParams.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import com.android.ranging.flags.Flags;
+
+/**
+ * Represents the parameters for sensor fusion in ranging operations. Uses IMU sensors to correct
+ * HW AOA measurements. Adds a moving average filter for distance measurements to remove outliers.
+ */
+@FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
+public final class SensorFusionParams implements Parcelable {
+    private final boolean mSensorFusionEnabled;
+
+    private SensorFusionParams(Builder builder) {
+        mSensorFusionEnabled = builder.mSensorFusionEnabled;
+    }
+
+    private SensorFusionParams(@NonNull Parcel in) {
+        mSensorFusionEnabled = in.readBoolean();
+    }
+
+    /**
+     * Gets whether sensor fusion was requested.
+     *
+     * @return true if sensor fusion is enabled; false otherwise.
+     */
+    public boolean isSensorFusionEnabled() {
+        return mSensorFusionEnabled;
+    }
+
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        dest.writeBoolean(mSensorFusionEnabled);
+    }
+
+    @NonNull
+    public static final Creator<SensorFusionParams> CREATOR = new Creator<>() {
+        @Override
+        public SensorFusionParams createFromParcel(Parcel in) {
+            return new SensorFusionParams(in);
+        }
+
+        @Override
+        public SensorFusionParams[] newArray(int size) {
+            return new SensorFusionParams[size];
+        }
+    };
+
+    /**
+     * Builder class for creating instances of {@link SensorFusionParams}.
+     */
+    public static final class Builder {
+        private boolean mSensorFusionEnabled = true;
+
+        /**
+         * Builds a new instance of {@link SensorFusionParams}.
+         *
+         * @return a new {@link SensorFusionParams} instance created using the current state of
+         * the builder.
+         */
+        @NonNull
+        public SensorFusionParams build() {
+            return new SensorFusionParams(this);
+        }
+
+        /**
+         * Sets whether to use sensor fusion.
+         * <p> defaults to true.
+         *
+         * @param sensorFusionEnabled true to enable sensor fusion; false to disable it.
+         * @return this Builder instance for method chaining.
+         */
+        @NonNull
+        public Builder setSensorFusionEnabled(boolean sensorFusionEnabled) {
+            mSensorFusionEnabled = sensorFusionEnabled;
+            return this;
+        }
+    }
+
+    /** @hide */
+    @Override
+    public String toString() {
+        return "SensorFusionParams{ "
+                + "mSensorFusionEnabled="
+                + mSensorFusionEnabled
+                + " }";
+    }
+}
diff --git a/ranging/framework/java/android/ranging/SessionConfiguration.java b/ranging/framework/java/android/ranging/SessionConfiguration.java
new file mode 100644
index 00000000..344417c6
--- /dev/null
+++ b/ranging/framework/java/android/ranging/SessionConfiguration.java
@@ -0,0 +1,220 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging;
+
+import android.annotation.FlaggedApi;
+import android.annotation.IntRange;
+import android.annotation.NonNull;
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import com.android.ranging.flags.Flags;
+
+/**
+ * Defines the ranging session configurations.
+ *
+ * <p>This class allows apps to set various parameters related to a ranging session.
+ *
+ */
+@FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
+public final class SessionConfiguration implements Parcelable {
+
+    private final SensorFusionParams mFusionParameters;
+    private final DataNotificationConfig mDataNotificationConfig;
+    private final boolean mIsAngleOfArrivalNeeded;
+    private final int mRangingMeasurementsLimit;
+
+    private SessionConfiguration(Builder builder) {
+        mFusionParameters = builder.mFusionParameters;
+        mDataNotificationConfig = builder.mDataNotificationConfig;
+        mIsAngleOfArrivalNeeded = builder.mIsAngleOfArrivalNeeded;
+        mRangingMeasurementsLimit = builder.mRangingMeasurementsLimit;
+    }
+
+    private SessionConfiguration(Parcel in) {
+        mFusionParameters = in.readParcelable(SensorFusionParams.class.getClassLoader(),
+                SensorFusionParams.class);
+        mDataNotificationConfig = in.readParcelable(DataNotificationConfig.class.getClassLoader(),
+                DataNotificationConfig.class);
+        mIsAngleOfArrivalNeeded = in.readBoolean();
+        mRangingMeasurementsLimit = in.readInt();
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        dest.writeParcelable(mFusionParameters, flags);
+        dest.writeParcelable(mDataNotificationConfig, flags);
+        dest.writeBoolean(mIsAngleOfArrivalNeeded);
+        dest.writeInt(mRangingMeasurementsLimit);
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @NonNull
+    public static final Creator<SessionConfiguration> CREATOR =
+            new Creator<SessionConfiguration>() {
+                @Override
+                public SessionConfiguration createFromParcel(Parcel in) {
+                    return new SessionConfiguration(in);
+                }
+
+                @Override
+                public SessionConfiguration[] newArray(int size) {
+                    return new SessionConfiguration[size];
+                }
+            };
+
+    /**
+     * Returns the sensor fusion parameters used for this preference.
+     *
+     * @return a non-null {@link SensorFusionParams} instance.
+     */
+    @NonNull
+    public SensorFusionParams getSensorFusionParameters() {
+        return mFusionParameters;
+    }
+
+    /**
+     * Returns the data notification configuration for this preference.
+     *
+     * @return a non-null {@link DataNotificationConfig} instance.
+     */
+    @NonNull
+    public DataNotificationConfig getDataNotificationConfig() {
+        return mDataNotificationConfig;
+    }
+
+    /**
+     * Returns whether Angle-of-arrival was requested by the app.
+     */
+    public boolean isAngleOfArrivalNeeded() {
+        return mIsAngleOfArrivalNeeded;
+    }
+
+    /**
+     * Returns the configured ranging measurements limit for the ranging session.
+     */
+    @IntRange(from = 0, to = 65535)
+    public int getRangingMeasurementsLimit() {
+        return mRangingMeasurementsLimit;
+    }
+
+    /**
+     * Builder for creating instances of {@link SessionConfiguration}.
+     */
+    public static final class Builder {
+        private DataNotificationConfig mDataNotificationConfig =
+                new DataNotificationConfig.Builder().build();
+        private SensorFusionParams mFusionParameters = new SensorFusionParams.Builder().build();
+        private boolean mIsAngleOfArrivalNeeded = false;
+        private int mRangingMeasurementsLimit = 0;
+
+        /**
+         * Sets the sensor fusion parameters for this preference.
+         *
+         * @param parameters the {@link SensorFusionParams} to use.
+         * @return the builder instance.
+         * @throws IllegalArgumentException if the parameters is null.
+         */
+        @NonNull
+        public Builder setSensorFusionParameters(
+                @NonNull SensorFusionParams parameters) {
+            mFusionParameters = parameters;
+            return this;
+        }
+
+        /**
+         * Sets the data notification configuration for this preference.
+         *
+         * @param config the {@link DataNotificationConfig} to use.
+         * @return the builder instance for chaining.
+         * @throws IllegalArgumentException if the config is null.
+         */
+        @NonNull
+        public Builder setDataNotificationConfig(
+                @NonNull DataNotificationConfig config) {
+            mDataNotificationConfig = config;
+            return this;
+        }
+
+        /**
+         * Sets whether Angle of Arrival (AoA) is required for the ranging operation.
+         *
+         * <p> Defaults to false
+         *
+         * @param isAngleOfArrivalNeeded {@code true} if AoA data is required; {@code false}
+         *                               otherwise.
+         * @return The {@link Builder} instance.
+         */
+        @NonNull
+        public Builder setAngleOfArrivalNeeded(boolean isAngleOfArrivalNeeded) {
+            mIsAngleOfArrivalNeeded = isAngleOfArrivalNeeded;
+            return this;
+        }
+
+        /**
+         * Sets the maximum number of ranging rounds for this session. This includes all ranging
+         * rounds, irrespective of whether they were successful or not. For 1:many sessions, a round
+         * includes ranging to all peers within that round.
+         *
+         * <p> By default, when the value is set to {@code 0}, the ranging session will run
+         * indefinitely.
+         *
+         * @param rangingMeasurementsLimit the maximum number of ranging rounds (0 to 65535).
+         * @return this {@link Builder} instance.
+         * @throws IllegalArgumentException if the value is outside the allowed range (0 to 65535).
+         */
+        @NonNull
+        public Builder setRangingMeasurementsLimit(
+                @IntRange(from = 0, to = 65535) int rangingMeasurementsLimit) {
+            if (rangingMeasurementsLimit < 0
+                    || rangingMeasurementsLimit > 65535) {
+                throw new IllegalArgumentException(
+                        "Ranging measurements limit must be between 0 and 65535");
+            }
+            mRangingMeasurementsLimit = rangingMeasurementsLimit;
+            return this;
+        }
+
+        /**
+         * Builds a new {@link SessionConfiguration} instance.
+         *
+         * @return the new {@link SessionConfiguration} instance.
+         */
+        @NonNull
+        public SessionConfiguration build() {
+            return new SessionConfiguration(this);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "SessionConfiguration{"
+                + "mFusionParameters="
+                + mFusionParameters
+                + ", mDataNotificationConfig="
+                + mDataNotificationConfig
+                + ", mIsAngleOfArrivalNeeded="
+                + mIsAngleOfArrivalNeeded
+                + ", mRangingMeasurementsLimit="
+                + mRangingMeasurementsLimit
+                + "}";
+    }
+}
diff --git a/ranging/framework/java/android/ranging/SessionHandle.aidl b/ranging/framework/java/android/ranging/SessionHandle.aidl
new file mode 100644
index 00000000..8f1fe7e4
--- /dev/null
+++ b/ranging/framework/java/android/ranging/SessionHandle.aidl
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging;
+
+parcelable SessionHandle;
\ No newline at end of file
diff --git a/ranging/framework/java/android/ranging/SessionHandle.java b/ranging/framework/java/android/ranging/SessionHandle.java
new file mode 100644
index 00000000..737dfd2b
--- /dev/null
+++ b/ranging/framework/java/android/ranging/SessionHandle.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging;
+
+import android.content.AttributionSource;
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import java.util.Objects;
+
+/**
+ * @hide
+ */
+public final class SessionHandle implements Parcelable  {
+    private final long mId;
+    private final String mPackageName;
+    private final int mUid;
+    private final int mPid;
+
+    public SessionHandle(long id, AttributionSource attributionSource, int pid) {
+        this(id, attributionSource.getPackageName(), attributionSource.getUid(), pid);
+    }
+
+    private SessionHandle(long id, String packageName, int uid, int pid) {
+        mId = id;
+        mPackageName = packageName;
+        mUid = uid;
+        mPid = pid;
+    }
+
+    protected SessionHandle(Parcel in) {
+        mId = in.readLong();
+        mPackageName = in.readString();
+        mUid = in.readInt();
+        mPid = in.readInt();
+    }
+
+    public static final Creator<SessionHandle> CREATOR = new Creator<SessionHandle>() {
+        @Override
+        public SessionHandle createFromParcel(Parcel in) {
+            return new SessionHandle(in);
+        }
+
+        @Override
+        public SessionHandle[] newArray(int size) {
+            return new SessionHandle[size];
+        }
+    };
+
+    public long getId() {
+        return mId;
+    }
+
+    public String getPackageName() {
+        return mPackageName;
+    }
+
+    public int getUid() {
+        return mUid;
+    }
+
+    public int getPid() {
+        return mPid;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeLong(mId);
+        dest.writeString(mPackageName);
+        dest.writeInt(mUid);
+        dest.writeInt(mPid);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+
+        if (obj instanceof SessionHandle) {
+            SessionHandle other = (SessionHandle) obj;
+            return mId == other.mId
+                    && Objects.equals(mPackageName, other.mPackageName)
+                    && mUid == other.mUid
+                    && mPid == other.mPid;
+        }
+        return false;
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(mId, mPackageName, mUid, mPid);
+    }
+
+    @Override
+    public String toString() {
+        return "SessionHandle{ "
+                + "mId="
+                + mId
+                + ", mPackageName='"
+                + mPackageName
+                + ", mUid="
+                + mUid
+                + ", mPid="
+                + mPid
+                + " }";
+    }
+}
diff --git a/ranging/framework/java/android/ranging/ble/cs/CsRangingCapabilities.java b/ranging/framework/java/android/ranging/ble/cs/CsRangingCapabilities.java
new file mode 100644
index 00000000..c3be78de
--- /dev/null
+++ b/ranging/framework/java/android/ranging/ble/cs/CsRangingCapabilities.java
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging.ble.cs;
+
+import android.annotation.FlaggedApi;
+import android.annotation.IntDef;
+import android.annotation.NonNull;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.ranging.RangingCapabilities.TechnologyCapabilities;
+import android.ranging.RangingManager;
+
+import com.android.ranging.flags.Flags;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * Represents the capabilities of the Bluetooth-based Channel Sounding (CS) ranging.
+ *
+ */
+@FlaggedApi(Flags.FLAG_RANGING_CS_ENABLED)
+public final class CsRangingCapabilities implements Parcelable, TechnologyCapabilities {
+    /**
+     * @hide
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({
+            CS_SECURITY_LEVEL_ONE,
+            CS_SECURITY_LEVEL_FOUR,
+    })
+    public @interface SecurityLevel {
+    }
+
+    /**
+     * Security Level 1:
+     * Either CS tone or CS RTT..
+     */
+    public static final int CS_SECURITY_LEVEL_ONE = 1;
+
+    /**
+     * Security Level 4:
+     * 10 ns CS RTT accuracy and CS tones with the addition of CS RTT sounding sequence or random
+     * sequence payloads, and support of the Normalized Attack Detector Metric requirements.
+     */
+    public static final int CS_SECURITY_LEVEL_FOUR = 4;
+
+    private final List<Integer> mSupportedSecurityLevels;
+
+    /**
+     * Returns a list of the supported security levels.
+     *
+     * @return a {@link Set} of integers representing the security levels,
+     *         where each level is one of {@link SecurityLevel}.
+     */
+    @NonNull
+    @SecurityLevel
+    public Set<Integer> getSupportedSecurityLevels() {
+        return new HashSet<>(mSupportedSecurityLevels);
+    }
+
+    private CsRangingCapabilities(Builder builder) {
+        mSupportedSecurityLevels = builder.mSupportedSecurityLevels;
+    }
+
+    private CsRangingCapabilities(Parcel in) {
+        mSupportedSecurityLevels = new ArrayList<>();
+        in.readList(mSupportedSecurityLevels, Integer.class.getClassLoader(), Integer.class);
+    }
+
+    @NonNull
+    public static final Creator<CsRangingCapabilities> CREATOR =
+            new Creator<CsRangingCapabilities>() {
+                @Override
+                public CsRangingCapabilities createFromParcel(Parcel in) {
+                    return new CsRangingCapabilities(in);
+                }
+
+                @Override
+                public CsRangingCapabilities[] newArray(int size) {
+                    return new CsRangingCapabilities[size];
+                }
+            };
+
+    /**
+     * @hide
+     */
+    @Override
+    public int getTechnology() {
+        return RangingManager.BLE_CS;
+    }
+
+    /**
+     * @hide
+     */
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        dest.writeList(mSupportedSecurityLevels);
+    }
+
+    /**
+     * Builder class for {@link CsRangingCapabilities}.
+     * This class provides a fluent API for constructing instances of {@link CsRangingCapabilities}.
+     *
+     * @hide
+     */
+    public static final class Builder {
+        private List<Integer> mSupportedSecurityLevels;
+
+        /**
+         * Set supported security levels to the capabilities.
+         *
+         * @param supportedSecurityLevels the supported security levels {@link SecurityLevel}.
+         * @return this {@link Builder} instance for chaining calls.
+         * TODO(b/361634062): Make this a set in the API to match CS API.
+         */
+        @NonNull
+        public Builder setSupportedSecurityLevels(List<Integer> supportedSecurityLevels) {
+            this.mSupportedSecurityLevels = supportedSecurityLevels;
+            return this;
+        }
+
+        /**
+         * Builds and returns a {@link CsRangingCapabilities} instance.
+         *
+         * @return a new {@link CsRangingCapabilities} object.
+         */
+        @NonNull
+        public CsRangingCapabilities build() {
+            return new CsRangingCapabilities(this);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "CsRangingCapabilities{ "
+                + "mSupportedSecurityLevels="
+                + mSupportedSecurityLevels
+                + " }";
+    }
+}
diff --git a/ranging/framework/java/android/ranging/ble/cs/CsRangingParams.java b/ranging/framework/java/android/ranging/ble/cs/CsRangingParams.java
new file mode 100644
index 00000000..e5522a46
--- /dev/null
+++ b/ranging/framework/java/android/ranging/ble/cs/CsRangingParams.java
@@ -0,0 +1,294 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging.ble.cs;
+
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_NORMAL;
+
+import android.annotation.FlaggedApi;
+import android.annotation.IntDef;
+import android.annotation.NonNull;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.ranging.raw.RawRangingDevice;
+import android.ranging.raw.RawRangingDevice.RangingUpdateRate;
+
+import com.android.ranging.flags.Flags;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * CsRangingParams encapsulates the parameters required for a bluetooth channel sounding ranging
+ * session.
+ */
+@FlaggedApi(Flags.FLAG_RANGING_CS_ENABLED)
+public final class CsRangingParams implements Parcelable {
+
+    /**
+     * @hide
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef(
+            value = {
+                    SIGHT_TYPE_UNKNOWN,
+                    SIGHT_TYPE_LINE_OF_SIGHT,
+                    SIGHT_TYPE_NON_LINE_OF_SIGHT,
+            })
+    @interface SightType {
+    }
+
+    /**
+     * Sight type is unknown.
+     */
+    public static final int SIGHT_TYPE_UNKNOWN = 0;
+    /**
+     * Remote device is in line of sight.
+     */
+    public static final int SIGHT_TYPE_LINE_OF_SIGHT = 1;
+    /**
+     * Remote device is not in line of sight.
+     */
+    public static final int SIGHT_TYPE_NON_LINE_OF_SIGHT = 2;
+
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef(
+            value = {
+                    LOCATION_TYPE_UNKNOWN,
+                    LOCATION_TYPE_INDOOR,
+                    LOCATION_TYPE_OUTDOOR,
+            })
+    @interface LocationType {
+    }
+
+    /**
+     * Location of the device is unknown.
+     */
+    public static final int LOCATION_TYPE_UNKNOWN = 0;
+    /**
+     * Location of the device is indoor.
+     */
+    public static final int LOCATION_TYPE_INDOOR = 1;
+    /**
+     * Location of the device is outdoor.
+     */
+    public static final int LOCATION_TYPE_OUTDOOR = 2;
+
+    private final String mPeerBluetoothAddress;
+    @RawRangingDevice.RangingUpdateRate
+    private final int mRangingUpdateRate;
+    @SightType
+    private final int mSightType;
+    @LocationType
+    private final int mLocationType;
+    @CsRangingCapabilities.SecurityLevel
+    private final int mSecurityLevel;
+
+    private CsRangingParams(Builder builder) {
+        mPeerBluetoothAddress = builder.mPeerBluetoothAddress;
+        mRangingUpdateRate = builder.mRangingUpdateRate;
+        mSightType = builder.mSightType;
+        mLocationType = builder.mLocationType;
+        mSecurityLevel = builder.mSecurityLevel;
+    }
+
+    private CsRangingParams(Parcel in) {
+        mPeerBluetoothAddress = in.readString();
+        mRangingUpdateRate = in.readInt();
+        mSightType = in.readInt();
+        mLocationType = in.readInt();
+        mSecurityLevel = in.readInt();
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        dest.writeString(mPeerBluetoothAddress);
+        dest.writeInt(mRangingUpdateRate);
+        dest.writeInt(mSightType);
+        dest.writeInt(mLocationType);
+        dest.writeInt(mSecurityLevel);
+    }
+
+    @NonNull
+    public static final Creator<CsRangingParams> CREATOR = new Creator<CsRangingParams>() {
+        @Override
+        public CsRangingParams createFromParcel(Parcel in) {
+            return new CsRangingParams(in);
+        }
+
+        @Override
+        public CsRangingParams[] newArray(int size) {
+            return new CsRangingParams[size];
+        }
+    };
+
+
+    /**
+     * Returns the Bluetooth address of the peer device.
+     *
+     * @return String representing the Bluetooth address.
+     */
+    @NonNull
+    public String getPeerBluetoothAddress() {
+        return mPeerBluetoothAddress;
+    }
+
+    /**
+     * Returns the ranging update rate.
+     *
+     * @return ranging update rate.
+     */
+    @RangingUpdateRate
+    public int getRangingUpdateRate() {
+        return mRangingUpdateRate;
+    }
+
+    /**
+     * Returns the sight type for this ranging session.
+     *
+     * @return the sight type
+     */
+    @SightType
+    public int getSightType() {
+        return mSightType;
+    }
+
+    /**
+     * Returns the location type for the ranging session.
+     *
+     * @return the location type.
+     */
+    @LocationType
+    public int getLocationType() {
+        return mLocationType;
+    }
+
+    /**
+     * Returns the security level for the ranging session.
+     *
+     * @return the security level
+     */
+    @CsRangingCapabilities.SecurityLevel
+    public int getSecurityLevel() {
+        return mSecurityLevel;
+    }
+
+    /**
+     * Builder class to create {@link CsRangingParams} instances.
+     */
+    public static final class Builder {
+        private String mPeerBluetoothAddress;
+        @RangingUpdateRate
+        private int mRangingUpdateRate = UPDATE_RATE_NORMAL;
+        @SightType
+        private int mSightType = SIGHT_TYPE_UNKNOWN;
+        @LocationType
+        private int mLocationType = LOCATION_TYPE_UNKNOWN;
+        @CsRangingCapabilities.SecurityLevel
+        private int mSecurityLevel = CsRangingCapabilities.CS_SECURITY_LEVEL_ONE;
+
+        /**
+         * Constructs a new {@link Builder} for creating a channel sounding ranging session.
+         *
+         * <p>Valid Bluetooth hardware addresses must be upper case, in big endian byte order, and
+         * in a format such as "00:11:22:33:AA:BB". The helper
+         * {@link android.bluetooth.BluetoothAdapter#checkBluetoothAddress} is available to validate
+         * a Bluetooth address.
+         *
+         * @param peerBluetoothAddress The address of the peer device must be non-null Bluetooth
+         *                             address.
+         * @throws IllegalArgumentException if {@code peerBluetoothAddress} is null or does not
+         * conform to "00:11:22:33:AA:BB" format.
+         * @see android.bluetooth.BluetoothDevice#getAddress()
+         */
+        public Builder(@NonNull String peerBluetoothAddress) {
+            if (!android.bluetooth.BluetoothAdapter.checkBluetoothAddress(peerBluetoothAddress)) {
+                throw new IllegalArgumentException(
+                        "Bluetooth address is not in 00:11:22:33:AA:BB format");
+            }
+            mPeerBluetoothAddress = peerBluetoothAddress;
+        }
+
+        /**
+         * Sets the update rate for the CS ranging session.
+         * <p>Defaults to {@link RangingUpdateRate#UPDATE_RATE_NORMAL}
+         *
+         * @param updateRate the reporting frequency.
+         * @return this {@link Builder} instance.
+         */
+        @NonNull
+        public Builder setRangingUpdateRate(@RawRangingDevice.RangingUpdateRate int updateRate) {
+            mRangingUpdateRate = updateRate;
+            return this;
+        }
+
+        /**
+         * Sets the sight type for the ranging session.
+         * <p>Defaults to {@link #SIGHT_TYPE_UNKNOWN}
+         *
+         * @param sightType the sight type.
+         * @return this {@link Builder} instance.
+         */
+        @NonNull
+        public Builder setSightType(@SightType int sightType) {
+            mSightType = sightType;
+            return this;
+        }
+
+        /**
+         * Sets the location type for the ranging session.
+         * <p>Defaults to {@link #LOCATION_TYPE_UNKNOWN}
+         *
+         * @param locationType the location type.
+         * @return this {@link Builder} instance.
+         */
+        @NonNull
+        public Builder setLocationType(@LocationType int locationType) {
+            mLocationType = locationType;
+            return this;
+        }
+
+        /**
+         * Sets the security level for the ranging session.
+         * <p>Defaults to {@link CsRangingCapabilities#CS_SECURITY_LEVEL_ONE}
+         *
+         * @param securityLevel the security level.
+         * @return this {@link Builder} instance.
+         */
+        @NonNull
+        public Builder setSecurityLevel(@CsRangingCapabilities.SecurityLevel int securityLevel) {
+            mSecurityLevel = securityLevel;
+            return this;
+        }
+
+        /**
+         * Builds and returns a {@link CsRangingParams} instance.
+         *
+         * @return a new {@link CsRangingParams}.
+         */
+        @NonNull
+        public CsRangingParams build() {
+            return new CsRangingParams(this);
+        }
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+}
+
diff --git a/ranging/framework/java/android/ranging/ble/rssi/BleRssiRangingParams.java b/ranging/framework/java/android/ranging/ble/rssi/BleRssiRangingParams.java
new file mode 100644
index 00000000..5bf53c76
--- /dev/null
+++ b/ranging/framework/java/android/ranging/ble/rssi/BleRssiRangingParams.java
@@ -0,0 +1,151 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging.ble.rssi;
+
+
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_NORMAL;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.ranging.raw.RawRangingDevice.RangingUpdateRate;
+
+import com.android.ranging.flags.Flags;
+
+/**
+ * BleRssiRangingParams encapsulates the parameters required for a bluetooth rssi based ranging
+ * session.
+ */
+@FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
+public final class BleRssiRangingParams implements Parcelable {
+
+    private final String mPeerBluetoothAddress;
+
+    @RangingUpdateRate
+    private final int mRangingUpdateRate;
+
+    private BleRssiRangingParams(Builder builder) {
+        mPeerBluetoothAddress = builder.mPeerBluetoothAddress;
+        mRangingUpdateRate = builder.mRangingUpdateRate;
+    }
+
+    private BleRssiRangingParams(Parcel in) {
+        mPeerBluetoothAddress = in.readString();
+        mRangingUpdateRate = in.readInt();
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        dest.writeString(mPeerBluetoothAddress);
+        dest.writeInt(mRangingUpdateRate);
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @NonNull
+    public static final Creator<BleRssiRangingParams> CREATOR =
+            new Creator<BleRssiRangingParams>() {
+                @Override
+                public BleRssiRangingParams createFromParcel(Parcel in) {
+                    return new BleRssiRangingParams(in);
+                }
+
+                @Override
+                public BleRssiRangingParams[] newArray(int size) {
+                    return new BleRssiRangingParams[size];
+                }
+            };
+
+    /**
+     * Returns the Bluetooth address of the peer device.
+     *
+     * @return String representing the Bluetooth address.
+     */
+    @NonNull
+    public String getPeerBluetoothAddress() {
+        return mPeerBluetoothAddress;
+    }
+
+    /**
+     * Returns the ranging update rate.
+     *
+     * @return ranging update rate.
+     */
+    @RangingUpdateRate
+    public int getRangingUpdateRate() {
+        return mRangingUpdateRate;
+    }
+
+    /**
+     * Builder class to create {@link BleRssiRangingParams} instances.
+     */
+    public static final class Builder {
+        private String mPeerBluetoothAddress;
+
+        @RangingUpdateRate
+        private int mRangingUpdateRate = UPDATE_RATE_NORMAL;
+
+        /**
+         * Constructs a new {@link Builder} for creating a bluetooth rssi ranging session.
+         *
+         * <p>Valid Bluetooth hardware addresses must be upper case, in big endian byte order, and
+         * in a format such as "00:11:22:33:AA:BB". The helper
+         * {@see android.bluetooth.BluetoothAdapter#checkBluetoothAddress} is available to validate
+         * a Bluetooth address.
+         *
+         * @param peerBluetoothAddress The address of the peer device must be non-null
+         *                             Bluetooth address.
+         *  {@see android.bluetooth.BluetoothDevice#getAddress()}
+         * @throws IllegalArgumentException if {@code peerBluetoothAddress} is null or does not
+         * conform to "00:11:22:33:AA:BB" format.
+         */
+        public Builder(@NonNull String peerBluetoothAddress) {
+            if (!android.bluetooth.BluetoothAdapter.checkBluetoothAddress(peerBluetoothAddress)) {
+                throw new IllegalArgumentException(
+                        "Bluetooth address is not in 00:11:22:33:AA:BB format");
+            }
+            mPeerBluetoothAddress = peerBluetoothAddress;
+        }
+
+        /**
+         * Sets the update rate for the BLE rssi ranging session.
+         * <p>Defaults to {@link RangingUpdateRate#UPDATE_RATE_NORMAL}
+         *
+         * @param updateRate the reporting frequency.
+         * @return this {@link Builder} instance.
+         */
+        @NonNull
+        public Builder setRangingUpdateRate(@RangingUpdateRate int updateRate) {
+            mRangingUpdateRate = updateRate;
+            return this;
+        }
+
+        /**
+         * Builds and returns a {@link BleRssiRangingParams} instance.
+         *
+         * @return a new {@link BleRssiRangingParams}.
+         */
+        @NonNull
+        public BleRssiRangingParams build() {
+            return new BleRssiRangingParams(this);
+        }
+    }
+}
diff --git a/ranging/framework/java/android/ranging/oob/DeviceHandle.java b/ranging/framework/java/android/ranging/oob/DeviceHandle.java
new file mode 100644
index 00000000..e97989ad
--- /dev/null
+++ b/ranging/framework/java/android/ranging/oob/DeviceHandle.java
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging.oob;
+
+import android.annotation.FlaggedApi;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.ranging.RangingDevice;
+
+import androidx.annotation.NonNull;
+
+import com.android.ranging.flags.Flags;
+
+import java.util.Objects;
+
+/**
+ * Represents a handle to a ranging device, containing information about the device
+ * and a transport handle for out-of-band communication.
+ *
+ */
+@FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
+public final class DeviceHandle implements Parcelable {
+
+    private final RangingDevice mRangingDevice;
+
+    private final TransportHandle mTransportHandle;
+
+    private DeviceHandle(Builder builder) {
+        mRangingDevice = builder.mRangingDevice;
+        mTransportHandle = builder.mTransportHandle;
+    }
+
+    private DeviceHandle(Parcel in) {
+        mRangingDevice = in.readParcelable(RangingDevice.class.getClassLoader());
+        // Not need in service layer.
+        mTransportHandle = null;
+    }
+
+    @NonNull
+    public static final Creator<DeviceHandle> CREATOR = new Creator<DeviceHandle>() {
+        @Override
+        public DeviceHandle createFromParcel(Parcel in) {
+            return new DeviceHandle(in);
+        }
+
+        @Override
+        public DeviceHandle[] newArray(int size) {
+            return new DeviceHandle[size];
+        }
+    };
+
+    /**
+     * Returns the ranging device associated with this handle.
+     *
+     * @return The {@link RangingDevice} instance.
+     */
+    @NonNull
+    public RangingDevice getRangingDevice() {
+        return mRangingDevice;
+    }
+
+    /**
+     * Returns the transport handle, if set, for communication.
+     *
+     * @return The {@link TransportHandle} instance.
+     */
+    @NonNull
+    public TransportHandle getTransportHandle() {
+        return mTransportHandle;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        dest.writeParcelable(mRangingDevice, flags);
+    }
+
+    /**
+     * Builder class for creating instances of {@link DeviceHandle}.
+     */
+    public static final class Builder {
+        private RangingDevice mRangingDevice;
+        private TransportHandle mTransportHandle;
+
+        /**
+         * Constructs a new {@link Builder} with the required {@link RangingDevice}
+         * and {@link TransportHandle}.
+         *
+         * @param rangingDevice the {@link RangingDevice}
+         * @param transportHandle Implementation of {@link TransportHandle} for sending/receiving
+         * OOB data from peer
+         * @throws NullPointerException if either parameter is {@code null}.
+         */
+        public Builder(@NonNull RangingDevice rangingDevice,
+                @NonNull TransportHandle transportHandle) {
+            Objects.requireNonNull(rangingDevice);
+            Objects.requireNonNull(transportHandle);
+            mRangingDevice = rangingDevice;
+            mTransportHandle = transportHandle;
+        }
+
+        /**
+         * Builds and returns a new {@link DeviceHandle} instance using the
+         * parameters provided to this builder.
+         *
+         * @return a newly created {@link DeviceHandle} instance.
+         */
+        @NonNull
+        public DeviceHandle build() {
+            return new DeviceHandle(this);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "DeviceHandle{ "
+                + "mRangingDevice="
+                + mRangingDevice
+                + ", mTransportHandle="
+                + mTransportHandle + " }";
+    }
+}
diff --git a/ranging/framework/java/android/ranging/oob/IOobSendDataListener.aidl b/ranging/framework/java/android/ranging/oob/IOobSendDataListener.aidl
new file mode 100644
index 00000000..a12e3755
--- /dev/null
+++ b/ranging/framework/java/android/ranging/oob/IOobSendDataListener.aidl
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging.oob;
+
+import android.ranging.oob.OobHandle;
+
+/**
+* Interface for sending data over the OOB channel.
+*
+*  @hide
+*/
+oneway interface IOobSendDataListener {
+    void sendOobData(in OobHandle oobHandle, in byte[] data);
+}
\ No newline at end of file
diff --git a/ranging/framework/java/android/ranging/oob/OobHandle.aidl b/ranging/framework/java/android/ranging/oob/OobHandle.aidl
new file mode 100644
index 00000000..fc65cb9e
--- /dev/null
+++ b/ranging/framework/java/android/ranging/oob/OobHandle.aidl
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging.oob;
+
+parcelable OobHandle;
\ No newline at end of file
diff --git a/ranging/framework/java/android/ranging/oob/OobHandle.java b/ranging/framework/java/android/ranging/oob/OobHandle.java
new file mode 100644
index 00000000..5b9308f4
--- /dev/null
+++ b/ranging/framework/java/android/ranging/oob/OobHandle.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging.oob;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.ranging.RangingDevice;
+import android.ranging.SessionHandle;
+
+import java.util.Objects;
+
+/**
+ * OobHandle identifies a unique session and device pair.
+ *
+ * @hide
+ */
+public final class OobHandle implements Parcelable {
+    public static final Creator<OobHandle> CREATOR = new Creator<OobHandle>() {
+        @Override
+        public OobHandle createFromParcel(Parcel in) {
+            return new OobHandle(in);
+        }
+
+        @Override
+        public OobHandle[] newArray(int size) {
+            return new OobHandle[size];
+        }
+    };
+    private final SessionHandle mSessionHandle;
+    private final RangingDevice mRangingDevice;
+
+    public OobHandle(SessionHandle sessionHandle, RangingDevice device) {
+        mSessionHandle = sessionHandle;
+        mRangingDevice = device;
+    }
+
+    protected OobHandle(Parcel in) {
+        mSessionHandle = in.readParcelable(SessionHandle.class.getClassLoader(),
+                SessionHandle.class);
+        mRangingDevice = in.readParcelable(RangingDevice.class.getClassLoader(),
+                RangingDevice.class);
+    }
+
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeParcelable(mSessionHandle, flags);
+        dest.writeParcelable(mRangingDevice, flags);
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    public SessionHandle getSessionHandle() {
+        return mSessionHandle;
+    }
+
+    public RangingDevice getRangingDevice() {
+        return mRangingDevice;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof OobHandle oobHandle)) return false;
+        return Objects.equals(getSessionHandle(), oobHandle.getSessionHandle())
+                && Objects.equals(getRangingDevice(), oobHandle.getRangingDevice());
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(getSessionHandle(), getRangingDevice());
+    }
+
+    @Override
+    public String toString() {
+        return "OobHandle{ "
+                + "mSessionHandle="
+                + mSessionHandle
+                + ", mRangingDevice="
+                + mRangingDevice
+                + " }";
+    }
+}
diff --git a/ranging/framework/java/android/ranging/oob/OobInitiatorRangingParams.java b/ranging/framework/java/android/ranging/oob/OobInitiatorRangingParams.java
new file mode 100644
index 00000000..e6d14543
--- /dev/null
+++ b/ranging/framework/java/android/ranging/oob/OobInitiatorRangingParams.java
@@ -0,0 +1,337 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging.oob;
+
+import android.annotation.FlaggedApi;
+import android.annotation.IntDef;
+import android.annotation.NonNull;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.ranging.RangingParams;
+import android.util.Range;
+
+import com.android.ranging.flags.Flags;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.time.Duration;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Represents the parameters for an Out-of-Band (OOB) initiator in a ranging session.
+ * This class includes configuration options such as device handles, security level,
+ * ranging mode, and interval range for setting up an OOB initiator ranging session.
+ */
+@FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
+public final class OobInitiatorRangingParams extends RangingParams implements Parcelable {
+
+    /**
+     * @hide
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({
+            SECURITY_LEVEL_BASIC,
+            SECURITY_LEVEL_SECURE,
+    })
+    public @interface SecurityLevel {
+    }
+
+    /**
+     * Basic security level for the ranging session.
+     * <p>Example usage:
+     * UWB: Static-STS
+     * BLE-CS: Security level one
+     */
+    public static final int SECURITY_LEVEL_BASIC = 0;
+
+    /**
+     * Basic security level for the ranging session.
+     * <p>Example usage:
+     * UWB: Provisioned-STS
+     * BLE-CS: Security level four
+     */
+    public static final int SECURITY_LEVEL_SECURE = 1;
+
+    /**
+     * @hide
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({
+            RANGING_MODE_AUTO,
+            RANGING_MODE_HIGH_ACCURACY,
+            RANGING_MODE_HIGH_ACCURACY_PREFERRED,
+            RANGING_MODE_FUSED,
+    })
+    public @interface RangingMode {
+    }
+
+    /**
+     * Automatic ranging mode, allows the system to choose the best mode.
+     */
+    public static final int RANGING_MODE_AUTO = 0;
+    /**
+     * High accuracy ranging mode. Fallback to ranging technologies if high accuracy ranging is not
+     * supported
+     */
+    public static final int RANGING_MODE_HIGH_ACCURACY = 1;
+    /**
+     * High accuracy ranging mode. No fallback allowed.
+     */
+    public static final int RANGING_MODE_HIGH_ACCURACY_PREFERRED = 2;
+    /**
+     * Starts ranging with all the ranging technologies both devices support.
+     */
+    public static final int RANGING_MODE_FUSED = 3;
+
+    private final List<DeviceHandle> mDeviceHandles;
+
+    private final Range<Duration> mRangingIntervalRange;
+
+    @SecurityLevel
+    private final int mSecurityLevel;
+
+    @RangingMode
+    private final int mRangingMode;
+
+    private OobInitiatorRangingParams(Builder builder) {
+        setRangingSessionType(RangingParams.RANGING_SESSION_OOB);
+        mDeviceHandles = new ArrayList<>(builder.mDeviceHandles);
+        mSecurityLevel = builder.mSecurityLevel;
+        mRangingMode = builder.mRangingMode;
+        mRangingIntervalRange = new Range<>(builder.mSlowestRangingInterval,
+                builder.mFastestRangingInterval);
+    }
+
+    private OobInitiatorRangingParams(Parcel in) {
+        setRangingSessionType(in.readInt());
+        mDeviceHandles = in.createTypedArrayList(DeviceHandle.CREATOR);
+        mSecurityLevel = in.readInt();
+        mRangingMode = in.readInt();
+        Duration lower = Duration.ofMillis(in.readLong());
+        Duration upper = Duration.ofMillis(in.readLong());
+        mRangingIntervalRange = new Range<>(lower, upper);
+
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        dest.writeInt(getRangingSessionType());
+        dest.writeTypedList(mDeviceHandles);
+        dest.writeInt(mSecurityLevel);
+        dest.writeInt(mRangingMode);
+        dest.writeLong(mRangingIntervalRange.getLower().toMillis());
+        dest.writeLong(mRangingIntervalRange.getUpper().toMillis());
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @NonNull
+    public static final Creator<OobInitiatorRangingParams> CREATOR =
+            new Creator<OobInitiatorRangingParams>() {
+                @Override
+                public OobInitiatorRangingParams createFromParcel(Parcel in) {
+                    return new OobInitiatorRangingParams(in);
+                }
+
+                @Override
+                public OobInitiatorRangingParams[] newArray(int size) {
+                    return new OobInitiatorRangingParams[size];
+                }
+            };
+
+    /**
+     * Returns the list of DeviceHandles associated with the OOB initiator.
+     *
+     * @return A list of DeviceHandle objects.
+     */
+    @NonNull
+    public List<DeviceHandle> getDeviceHandles() {
+        return mDeviceHandles;
+    }
+
+    /**
+     * Returns the ranging interval range configuration.
+     *
+     * @return The {@link Range} associated with this OOB initiator.
+     */
+    @NonNull
+    public Range<Duration> getRangingIntervalRange() {
+        return mRangingIntervalRange;
+    }
+
+    /**
+     * Returns the fastest requested ranging interval.
+     *
+     * @return The fastest interval.
+     */
+    @NonNull
+    public Duration getFastestRangingInterval() {
+        return mRangingIntervalRange.getLower();
+    }
+
+    /**
+     * Returns the slowest acceptable ranging.
+     *
+     * @return The slowest interval.
+     */
+    @NonNull
+    public Duration getSlowestRangingInterval() {
+        return mRangingIntervalRange.getUpper();
+    }
+
+    /**
+     * Returns the security level set for the ranging session.
+     *
+     * @return the security level.
+     * <p>Possible values:
+     * {@link #SECURITY_LEVEL_BASIC}
+     * {@link #SECURITY_LEVEL_SECURE}
+     */
+    @SecurityLevel
+    public int getSecurityLevel() {
+        return mSecurityLevel;
+    }
+
+    /**
+     * Returns the ranging mode for the session.
+     *
+     * @return the ranging mode.
+     * <p>Possible values:
+     * {@link #RANGING_MODE_AUTO}
+     * {@link #RANGING_MODE_HIGH_ACCURACY}
+     * {@link #RANGING_MODE_HIGH_ACCURACY_PREFERRED}
+     * {@link #RANGING_MODE_FUSED}
+     */
+
+    @RangingMode
+    public int getRangingMode() {
+        return mRangingMode;
+    }
+
+    /**
+     * Builder class for creating instances of {@link OobInitiatorRangingParams}.
+     */
+    public static final class Builder {
+        private final List<DeviceHandle> mDeviceHandles = new ArrayList<>();
+        @SecurityLevel
+        private int mSecurityLevel = SECURITY_LEVEL_BASIC;
+        @RangingMode
+        private int mRangingMode = RANGING_MODE_AUTO;
+
+        private Duration mFastestRangingInterval = Duration.ofMillis(100);
+        private Duration mSlowestRangingInterval = Duration.ofMillis(5000);
+
+        /**
+         * Sets the fastest ranging interval in milliseconds.
+         *
+         * @param intervalMs The fastest interval in milliseconds.
+         *                   Defaults to 100ms
+         * @return The Builder instance, for chaining calls.
+         */
+        @NonNull
+        public Builder setFastestRangingInterval(@NonNull Duration intervalMs) {
+            this.mFastestRangingInterval = intervalMs;
+            return this;
+        }
+
+        /**
+         * Sets the slowest ranging interval in milliseconds.
+         *
+         * @param intervalMs The slowest interval in milliseconds.
+         *                   Defaults to 5000ms
+         * @return The Builder instance, for chaining calls.
+         */
+        @NonNull
+        public Builder setSlowestRangingInterval(@NonNull Duration intervalMs) {
+            if (intervalMs.isNegative() || intervalMs.isZero()) {
+                throw new IllegalArgumentException("Slowest duration cannot be negative or zero");
+            }
+            this.mSlowestRangingInterval = intervalMs;
+            return this;
+        }
+
+        /**
+         * Adds a DeviceHandle to the list of devices for the ranging session.
+         *
+         * @param deviceHandle The DeviceHandle to add.
+         * @return The Builder instance.
+         */
+        @NonNull
+        public Builder addDeviceHandle(@NonNull DeviceHandle deviceHandle) {
+            mDeviceHandles.add(deviceHandle);
+            return this;
+        }
+
+
+        /**
+         * Sets the security level for the ranging session.
+         *
+         * @param securityLevel The security level to set.
+         *                      Defaults to {@link #SECURITY_LEVEL_BASIC}
+         * @return The Builder instance.
+         */
+        @NonNull
+        public Builder setSecurityLevel(@SecurityLevel int securityLevel) {
+            this.mSecurityLevel = securityLevel;
+            return this;
+        }
+
+        /**
+         * Sets the ranging mode for the session.
+         *
+         * @param rangingMode The ranging mode to set.
+         *                    Defaults to {@link #RANGING_MODE_AUTO}
+         * @return The Builder instance.
+         */
+        @NonNull
+        public Builder setRangingMode(@RangingMode int rangingMode) {
+            this.mRangingMode = rangingMode;
+            return this;
+        }
+
+        /**
+         * Builds an instance of {@link OobInitiatorRangingParams} with the provided parameters.
+         *
+         * @return A new OobInitiatorRangingParams instance.
+         */
+        @NonNull
+        public OobInitiatorRangingParams build() {
+            return new OobInitiatorRangingParams(this);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "OobInitiatorRangingParams{ "
+                + "mDeviceHandles="
+                + mDeviceHandles
+                + ", mRangingIntervalRange="
+                + mRangingIntervalRange
+                + ", mSecurityLevel="
+                + mSecurityLevel
+                + ", mRangingMode="
+                + mRangingMode
+                + ", "
+                + super.toString()
+                + ", "
+                + " }";
+    }
+}
diff --git a/ranging/framework/java/android/ranging/oob/OobResponderRangingParams.aidl b/ranging/framework/java/android/ranging/oob/OobResponderRangingParams.aidl
new file mode 100644
index 00000000..c6ac04ab
--- /dev/null
+++ b/ranging/framework/java/android/ranging/oob/OobResponderRangingParams.aidl
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging.oob;
+
+parcelable OobResponderRangingParams;
\ No newline at end of file
diff --git a/ranging/framework/java/android/ranging/oob/OobResponderRangingParams.java b/ranging/framework/java/android/ranging/oob/OobResponderRangingParams.java
new file mode 100644
index 00000000..23444798
--- /dev/null
+++ b/ranging/framework/java/android/ranging/oob/OobResponderRangingParams.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging.oob;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.ranging.RangingParams;
+
+import com.android.ranging.flags.Flags;
+
+/**
+ * Represents the parameters for an Out-of-Band (OOB) responder in a ranging session.
+ * This class contains configuration and device handle information for establishing
+ * a ranging session with an initiator.
+ */
+@FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
+public final class OobResponderRangingParams extends RangingParams implements Parcelable {
+
+    private final android.ranging.oob.DeviceHandle mDeviceHandle;
+
+    private OobResponderRangingParams(Builder builder) {
+        setRangingSessionType(RangingParams.RANGING_SESSION_OOB);
+        mDeviceHandle = builder.mDeviceHandle;
+    }
+
+
+    private OobResponderRangingParams(Parcel in) {
+        setRangingSessionType(in.readInt());
+        mDeviceHandle = in.readParcelable(
+                DeviceHandle.class.getClassLoader(), android.ranging.oob.DeviceHandle.class);
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        dest.writeInt(getRangingSessionType());
+        dest.writeParcelable(mDeviceHandle, flags);
+    }
+
+    @NonNull
+    public static final Creator<OobResponderRangingParams> CREATOR =
+            new Creator<OobResponderRangingParams>() {
+                @Override
+                public OobResponderRangingParams createFromParcel(Parcel in) {
+                    return new OobResponderRangingParams(in);
+                }
+
+                @Override
+                public OobResponderRangingParams[] newArray(int size) {
+                    return new OobResponderRangingParams[size];
+                }
+            };
+
+    /**
+     * Returns the DeviceHandle associated with this OOB responder.
+     *
+     * @return The DeviceHandle of the OOB responder.
+     */
+    @NonNull
+    public android.ranging.oob.DeviceHandle getDeviceHandle() {
+        return mDeviceHandle;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Builder class for creating instances of {@link OobResponderRangingParams}.
+     */
+    public static final class Builder {
+        private final android.ranging.oob.DeviceHandle mDeviceHandle;
+
+        /**
+         * Constructs a new Builder instance with the specified DeviceHandle.
+         *
+         * @param deviceHandle The DeviceHandle to associate with this OOB responder.
+         */
+        public Builder(@NonNull android.ranging.oob.DeviceHandle deviceHandle) {
+            mDeviceHandle = deviceHandle;
+        }
+
+        /**
+         * Builds an instance of {@link OobResponderRangingParams} with the provided parameters.
+         *
+         * @return A new OobResponderRangingParams instance.
+         */
+        @NonNull
+        public OobResponderRangingParams build() {
+            return new OobResponderRangingParams(this);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "OobResponderRangingParams{ "
+                + "mDeviceHandle="
+                + mDeviceHandle
+                + ", "
+                + super.toString()
+                + ", "
+                + " }";
+    }
+}
diff --git a/ranging/framework/java/android/ranging/oob/TransportHandle.java b/ranging/framework/java/android/ranging/oob/TransportHandle.java
new file mode 100644
index 00000000..0a288fe2
--- /dev/null
+++ b/ranging/framework/java/android/ranging/oob/TransportHandle.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging.oob;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.annotation.SuppressLint;
+
+import com.android.ranging.flags.Flags;
+
+import java.util.concurrent.Executor;
+
+/**
+ * TransportHandle is used as the Out-Of-Band (OOB) transport mechanism by ranging module.
+ * In cases where module is used in a non-raw ranging mode, the user shall provide an implementation
+ * of the TransportHandle, allowing ranging module to do the necessary OOB communication with a peer
+ * device using the provided transport handle. Some examples of OOB transport between two peer
+ * devices are:
+ * <ul>
+ *     <li>BLE GATT connection</li>
+ *     <li>Wi-Fi MDNS link</li>
+ *     <li>Internet</li>
+ * </ul>
+ */
+@FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
+public interface TransportHandle extends AutoCloseable {
+
+    /** Send data to the peer device via the implemented OOB transport.
+     *
+     * @param data the data to be sent to the peer device. Must not be null.
+     * @throws IllegalArgumentException if the provided data is null or invalid
+     */
+    void sendData(@NonNull byte[] data);
+
+    /**
+     * Registers a callback to receive updates from the transport mechanism.
+     *
+     * <p>The callback should be used to notify information about the peer device including the
+     * data received from the peer device.
+     *
+     * @param executor the {@link Executor} on which the callback should be invoked. Must not be
+     *                 null.
+     * @param callback the {@link ReceiveCallback} instance to receive updates. Must not be null.
+     * @throws IllegalArgumentException if either {@code executor} or {@code callback} is null.
+     */
+    @SuppressLint({"PairedRegistration"})
+    void registerReceiveCallback(@NonNull Executor executor, @NonNull ReceiveCallback callback);
+
+    /** TransportHandle callback. */
+    interface ReceiveCallback {
+        /**
+         * Notifies and provides data received from the peer device.
+         *
+         * @param data the data received from the peer device. Must not be null.
+         */
+        void onReceiveData(@NonNull byte[] data);
+
+        /**
+         * Called when a data send operation fails.
+         */
+        void onSendFailed();
+
+        /**
+         * Notifies the receiver that the TransportHandle instance can't be used to receive or send
+         * data until {@see onReconnect()} is called.
+         */
+        void onDisconnect();
+
+        /**
+         * Notifies the receiver the TransportHandle instance can be used again to send and receive
+         * data. Should only be called if {@see onDisconnect()} preceded it.
+         */
+        void onReconnect();
+
+        /**
+         * Notifies the receiver that the TransportHandle instance can't be used anymore to receive
+         * or send data. Also call this in {@link AutoCloseable#close()}.
+         */
+        void onClose();
+    }
+}
diff --git a/ranging/framework/java/android/ranging/raw/RawInitiatorRangingParams.java b/ranging/framework/java/android/ranging/raw/RawInitiatorRangingParams.java
new file mode 100644
index 00000000..eca07ec5
--- /dev/null
+++ b/ranging/framework/java/android/ranging/raw/RawInitiatorRangingParams.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging.raw;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.ranging.RangingParams;
+
+import com.android.ranging.flags.Flags;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Represents the parameters for initiating a raw ranging session.
+ * This class encapsulates a list of {@link android.ranging.raw.RawRangingDevice} objects that
+ * participate in the
+ * session.
+ */
+@FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
+public final class RawInitiatorRangingParams extends RangingParams implements Parcelable {
+
+    private final List<android.ranging.raw.RawRangingDevice> mRawRangingDevices;
+
+    private RawInitiatorRangingParams(Builder builder) {
+        setRangingSessionType(RangingParams.RANGING_SESSION_RAW);
+        mRawRangingDevices = new ArrayList<>(builder.mRawRangingDeviceList);
+    }
+
+    private RawInitiatorRangingParams(Parcel in) {
+        setRangingSessionType(in.readInt());
+        mRawRangingDevices = in.createTypedArrayList(android.ranging.raw.RawRangingDevice.CREATOR);
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        dest.writeInt(getRangingSessionType());
+        dest.writeTypedList(mRawRangingDevices);
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @NonNull
+    public static final Creator<RawInitiatorRangingParams> CREATOR =
+            new Creator<RawInitiatorRangingParams>() {
+                @Override
+                public RawInitiatorRangingParams createFromParcel(Parcel in) {
+                    return new RawInitiatorRangingParams(in);
+                }
+
+                @Override
+                public RawInitiatorRangingParams[] newArray(int size) {
+                    return new RawInitiatorRangingParams[size];
+                }
+            };
+
+    /**
+     * Returns the list of {@link android.ranging.raw.RawRangingDevice} objects involved in this
+     * session.
+     *
+     * @return a list of ranging devices.
+     */
+    @NonNull
+    public List<RawRangingDevice> getRawRangingDevices() {
+        return mRawRangingDevices;
+    }
+
+    /**
+     * Builder class for constructing instances of {@link RawInitiatorRangingParams}.
+     */
+    public static final class Builder {
+        private final List<android.ranging.raw.RawRangingDevice> mRawRangingDeviceList =
+                new ArrayList<>();
+
+        /**
+         * Adds a {@link android.ranging.raw.RawRangingDevice} to the list of devices for this
+         * session.
+         *
+         * @param rangingDevice the device to be added.
+         * @return this {@link Builder} instance.
+         */
+        @NonNull
+        public Builder addRawRangingDevice(
+                @NonNull android.ranging.raw.RawRangingDevice rangingDevice) {
+            mRawRangingDeviceList.add(rangingDevice);
+            return this;
+        }
+
+        /**
+         * Builds and returns a new {@link RawInitiatorRangingParams} instance.
+         *
+         * @return a configured instance of {@link RawInitiatorRangingParams}.
+         */
+        @NonNull
+        public RawInitiatorRangingParams build() {
+            return new RawInitiatorRangingParams(this);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "RawInitiatorRangingParams{ "
+                + "mRawRangingDevices="
+                + mRawRangingDevices
+                + ", "
+                + super.toString()
+                + ", "
+                + " }";
+    }
+}
diff --git a/ranging/framework/java/android/ranging/raw/RawRangingDevice.java b/ranging/framework/java/android/ranging/raw/RawRangingDevice.java
new file mode 100644
index 00000000..f344ade3
--- /dev/null
+++ b/ranging/framework/java/android/ranging/raw/RawRangingDevice.java
@@ -0,0 +1,275 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging.raw;
+
+import android.annotation.FlaggedApi;
+import android.annotation.IntDef;
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.ranging.RangingDevice;
+import android.ranging.ble.cs.CsRangingParams;
+import android.ranging.ble.rssi.BleRssiRangingParams;
+import android.ranging.uwb.UwbRangingParams;
+import android.ranging.wifi.rtt.RttRangingParams;
+
+import com.android.ranging.flags.Flags;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/**
+ * Represents a device participating in ranging operations.
+ * This class supports multiple ranging technologies, including UWB, BLE CS, BLE RSSI and Wi-Fi
+ * NAN-RTT. The configuration for each technology is provided through corresponding parameter
+ * objects.
+ *
+ */
+@FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
+public final class RawRangingDevice implements Parcelable {
+
+    /**
+     * Defines the configuration IDs for different ranging scenarios.
+     *
+     * @hide
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({
+            UPDATE_RATE_NORMAL,
+            UPDATE_RATE_INFREQUENT,
+            UPDATE_RATE_FREQUENT,
+    })
+    public @interface RangingUpdateRate {
+    }
+
+    /** Ranging interval between 200ms - 240ms for UWB, 2 seconds for BT-CS. */
+    public static final int UPDATE_RATE_NORMAL = 1;
+    /** Ranging interval between 600ms - 800ms for UWB, 5 seconds for BT-CS. */
+    public static final int UPDATE_RATE_INFREQUENT = 2;
+    /** Ranging interval between 100ms - 200ms for UWB, 1 second for BT-CS. */
+    public static final int UPDATE_RATE_FREQUENT = 3;
+    private final RangingDevice mRangingDevice;
+    private final UwbRangingParams mUwbRangingParams;
+    private final CsRangingParams mCsRangingParams;
+    private final RttRangingParams mRttRangingParams;
+    private final BleRssiRangingParams mBleRssiRangingParams;
+
+
+    private RawRangingDevice(Builder builder) {
+        mRangingDevice = builder.mRangingDevice;
+        mUwbRangingParams = builder.mUwbRangingParams;
+        mCsRangingParams = builder.mCsRangingParams;
+        mRttRangingParams = builder.mRttRangingParams;
+        mBleRssiRangingParams = builder.mBleRssiRangingParams;
+    }
+
+
+    private RawRangingDevice(Parcel in) {
+        mRangingDevice = in.readParcelable(RangingDevice.class.getClassLoader(), RangingDevice.class
+        );
+        mUwbRangingParams = in.readParcelable(UwbRangingParams.class.getClassLoader(),
+                UwbRangingParams.class);
+        mCsRangingParams = in.readParcelable(CsRangingParams.class.getClassLoader(),
+                CsRangingParams.class
+        );
+        mRttRangingParams = in.readParcelable(RttRangingParams.class.getClassLoader(),
+                RttRangingParams.class);
+        mBleRssiRangingParams = in.readParcelable(BleRssiRangingParams.class.getClassLoader(),
+                BleRssiRangingParams.class);
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        dest.writeParcelable(mRangingDevice, flags);
+        dest.writeParcelable(mUwbRangingParams, flags);
+        dest.writeParcelable(mCsRangingParams, flags);
+        dest.writeParcelable(mRttRangingParams, flags);
+        dest.writeParcelable(mBleRssiRangingParams, flags);
+    }
+
+    @NonNull
+    public static final Creator<RawRangingDevice> CREATOR = new Creator<RawRangingDevice>() {
+        @Override
+        public RawRangingDevice createFromParcel(Parcel in) {
+            return new RawRangingDevice(in);
+        }
+
+        @Override
+        public RawRangingDevice[] newArray(int size) {
+            return new RawRangingDevice[size];
+        }
+    };
+
+    /**
+     * Returns the {@link RangingDevice} associated with this instance.
+     *
+     * @return the ranging device.
+     */
+    @NonNull
+    public RangingDevice getRangingDevice() {
+        return mRangingDevice;
+    }
+
+    /**
+     * Returns the UWB ranging parameters, if applicable.
+     *
+     * @return the {@link UwbRangingParams}, or {@code null} if not set.
+     */
+    @Nullable
+    public UwbRangingParams getUwbRangingParams() {
+        return mUwbRangingParams;
+    }
+
+    /**
+     * Returns the CS ranging parameters, if applicable.
+     *
+     * @return the {@link CsRangingParams}, or {@code null} if not set.
+     *
+     */
+    @Nullable
+    public CsRangingParams getCsRangingParams() {
+        return mCsRangingParams;
+    }
+
+    /**
+     * Returns the RTT ranging parameters, if applicable.
+     *
+     * @return the {@link RttRangingParams}, or {@code null} if not set.
+     *
+     */
+    @Nullable
+    public RttRangingParams getRttRangingParams() {
+        return mRttRangingParams;
+    }
+
+    /**
+     * Returns the BLE rssi ranging parameters, if applicable.
+     *
+     * @return the {@link BleRssiRangingParams}, or {@code null} if not set.
+     *
+     */
+    @Nullable
+    public BleRssiRangingParams getBleRssiRangingParams() {
+        return mBleRssiRangingParams;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * Builder class for creating instances of {@link RawRangingDevice}.
+     */
+    public static final class Builder {
+        private RangingDevice mRangingDevice;
+        private UwbRangingParams mUwbRangingParams;
+        private CsRangingParams mCsRangingParams;
+        private RttRangingParams mRttRangingParams;
+        private BleRssiRangingParams mBleRssiRangingParams;
+
+        /**
+         * Sets the ranging device.
+         *
+         * @param rangingDevice the {@link RangingDevice} to be set.
+         * @return this {@link Builder} instance for chaining calls.
+         */
+        @NonNull
+        public Builder setRangingDevice(@NonNull RangingDevice rangingDevice) {
+            mRangingDevice = rangingDevice;
+            return this;
+        }
+
+        /**
+         * Sets the UWB ranging parameters.
+         *
+         * @param params the {@link UwbRangingParams} to be set.
+         * @return this {@link Builder} instance for chaining calls.
+         */
+        @NonNull
+        public Builder setUwbRangingParams(@NonNull UwbRangingParams params) {
+            mUwbRangingParams = params;
+            return this;
+        }
+
+        /**
+         * Sets the WiFi NAN-RTT ranging parameters.
+         *
+         * @param params the {@link RttRangingParams} to be set.
+         * @return this {@link Builder} instance for chaining calls.
+         *
+         */
+        @NonNull
+        public Builder setRttRangingParams(@NonNull RttRangingParams params) {
+            mRttRangingParams = params;
+            return this;
+        }
+
+        /**
+         * Sets the BLE channel sounding ranging parameters.
+         *
+         * @param params the {@link CsRangingParams} to be set.
+         * @return this {@link Builder} instance for chaining calls.
+         *
+         */
+        @NonNull
+        public Builder setCsRangingParams(@NonNull CsRangingParams params) {
+            mCsRangingParams = params;
+            return this;
+        }
+
+        /**
+         * Sets the BLE rssi ranging parameters.
+         *
+         * @param params the {@link CsRangingParams} to be set.
+         * @return this {@link Builder} instance for chaining calls.
+         *
+         */
+        @NonNull
+        public Builder setBleRssiRangingParams(@NonNull BleRssiRangingParams params) {
+            mBleRssiRangingParams = params;
+            return this;
+        }
+
+        /**
+         * Builds and returns a new {@link RawRangingDevice} instance.
+         *
+         * @return a new {@link RawRangingDevice} configured with the specified parameters.
+         */
+        @NonNull
+        public RawRangingDevice build() {
+            return new RawRangingDevice(this);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "RawRangingDevice{ "
+                + "mRangingDevice="
+                + mRangingDevice
+                + ", mUwbRangingParams="
+                + mUwbRangingParams
+                + ", mCsRangingParams="
+                + mCsRangingParams
+                + ", mRttRangingParams="
+                + mRttRangingParams
+                + ", mBleRssiRangingParams="
+                + mBleRssiRangingParams
+                + " }";
+    }
+}
diff --git a/ranging/framework/java/android/ranging/raw/RawResponderRangingParams.aidl b/ranging/framework/java/android/ranging/raw/RawResponderRangingParams.aidl
new file mode 100644
index 00000000..c167808a
--- /dev/null
+++ b/ranging/framework/java/android/ranging/raw/RawResponderRangingParams.aidl
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging.raw;
+
+parcelable RawResponderRangingParams;
\ No newline at end of file
diff --git a/ranging/framework/java/android/ranging/raw/RawResponderRangingParams.java b/ranging/framework/java/android/ranging/raw/RawResponderRangingParams.java
new file mode 100644
index 00000000..60372b06
--- /dev/null
+++ b/ranging/framework/java/android/ranging/raw/RawResponderRangingParams.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging.raw;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.ranging.RangingParams;
+
+import com.android.ranging.flags.Flags;
+
+/**
+ * Represents the parameters for a raw ranging session initiated by a responder device.
+ * This class holds a {@link android.ranging.raw.RawRangingDevice} object that participates in the
+ * session.
+ */
+@FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
+public final class RawResponderRangingParams extends RangingParams implements Parcelable {
+
+    private final android.ranging.raw.RawRangingDevice mRawRangingDevice;
+
+    private RawResponderRangingParams(Builder builder) {
+        setRangingSessionType(RangingParams.RANGING_SESSION_RAW);
+        mRawRangingDevice = builder.mRawRangingDevice;
+    }
+
+    private RawResponderRangingParams(Parcel in) {
+        setRangingSessionType(in.readInt());
+        mRawRangingDevice = in.readParcelable(
+                android.ranging.raw.RawRangingDevice.class.getClassLoader());
+    }
+
+    @NonNull
+    public static final Creator<RawResponderRangingParams> CREATOR =
+            new Creator<RawResponderRangingParams>() {
+                @Override
+                public RawResponderRangingParams createFromParcel(Parcel in) {
+                    return new RawResponderRangingParams(in);
+                }
+
+                @Override
+                public RawResponderRangingParams[] newArray(int size) {
+                    return new RawResponderRangingParams[size];
+                }
+            };
+
+    /**
+     * Returns the {@link android.ranging.raw.RawRangingDevice} participating in this session as the
+     * responder.
+     *
+     * @return the raw ranging device.
+     */
+    @NonNull
+    public android.ranging.raw.RawRangingDevice getRawRangingDevice() {
+        return mRawRangingDevice;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        dest.writeInt(getRangingSessionType());
+        dest.writeParcelable(mRawRangingDevice, flags);
+    }
+
+    /**
+     * Builder class for constructing instances of {@link RawResponderRangingParams}.
+     */
+    public static final class Builder {
+        private RawRangingDevice mRawRangingDevice;
+
+        /**
+         * Sets the {@link android.ranging.raw.RawRangingDevice} for this responder session.
+         *
+         * @param rangingDevice the raw ranging device.
+         * @return this {@link Builder} instance.
+         */
+        @NonNull
+        public Builder setRawRangingDevice(
+                @NonNull android.ranging.raw.RawRangingDevice rangingDevice) {
+            mRawRangingDevice = rangingDevice;
+            return this;
+        }
+
+        /**
+         * Builds and returns a new {@link RawResponderRangingParams} instance.
+         *
+         * @return a configured instance of {@link RawResponderRangingParams}.
+         */
+        @NonNull
+        public RawResponderRangingParams build() {
+            return new RawResponderRangingParams(this);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "RawResponderRangingParams{ "
+                + "mRawRangingDevice="
+                + mRawRangingDevice
+                + ", "
+                + super.toString()
+                + ", "
+                + " }";
+    }
+}
+
+
+
+
diff --git a/ranging/framework/java/android/ranging/uwb/UwbAddress.java b/ranging/framework/java/android/ranging/uwb/UwbAddress.java
new file mode 100644
index 00000000..594d62cd
--- /dev/null
+++ b/ranging/framework/java/android/ranging/uwb/UwbAddress.java
@@ -0,0 +1,154 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging.uwb;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import com.android.ranging.flags.Flags;
+
+import java.security.SecureRandom;
+import java.util.Arrays;
+
+/**
+ * A class representing a UWB address
+ */
+@FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
+public final class UwbAddress implements Parcelable {
+    public static final int SHORT_ADDRESS_BYTE_LENGTH = 2;
+    public static final int EXTENDED_ADDRESS_BYTE_LENGTH = 8;
+
+    private final byte[] mAddressBytes;
+
+    private UwbAddress(byte[] address) {
+        mAddressBytes = address;
+    }
+
+    /**
+     * Create a {@link android.uwb.UwbAddress} from a byte array.
+     *
+     * <p>If the provided array is {@link #SHORT_ADDRESS_BYTE_LENGTH} bytes, a short address is
+     * created. If the provided array is {@link #EXTENDED_ADDRESS_BYTE_LENGTH} bytes, then an
+     * extended address is created.
+     *
+     * @param address a byte array to convert to a {@link android.uwb.UwbAddress}
+     * @return a {@link android.uwb.UwbAddress} created from the input byte array
+     * @throws IllegalArgumentException when the length is not one of
+     *       {@link #SHORT_ADDRESS_BYTE_LENGTH} or {@link #EXTENDED_ADDRESS_BYTE_LENGTH} bytes
+     */
+    @NonNull
+    public static UwbAddress fromBytes(@NonNull byte[] address) {
+        if (address.length != SHORT_ADDRESS_BYTE_LENGTH
+                && address.length != EXTENDED_ADDRESS_BYTE_LENGTH) {
+            throw new IllegalArgumentException("Invalid UwbAddress length " + address.length);
+        }
+        return new UwbAddress(address);
+    }
+
+    /**
+     * Generates a random 2 bytes {@link UwbAddress}.
+     *
+     * @return a randomly generated {@link UwbAddress}.
+     */
+    @NonNull
+    public static UwbAddress getRandomShortAddress() {
+        SecureRandom secureRandom = new SecureRandom();
+        return fromBytes(generateRandomByteArray(SHORT_ADDRESS_BYTE_LENGTH, secureRandom));
+    }
+
+    /**
+     * Generates a random 8 bytes {@link UwbAddress}.
+     *
+     * @return a randomly generated {@link UwbAddress}.
+     *
+     * @hide Intentionally hidden.
+     */
+    @NonNull
+    public static UwbAddress getRandomExtendedAddress() {
+        SecureRandom secureRandom = new SecureRandom();
+        return fromBytes(generateRandomByteArray(EXTENDED_ADDRESS_BYTE_LENGTH, secureRandom));
+    }
+
+    private static byte[] generateRandomByteArray(int len, SecureRandom secureRandom) {
+        byte[] bytes = new byte[len];
+        secureRandom.nextBytes(bytes);
+        return bytes;
+    }
+
+
+    /**
+     * Get the address as a byte array
+     *
+     * @return the byte representation of this {@link android.uwb.UwbAddress}
+     */
+    @NonNull
+    public byte[] getAddressBytes() {
+        return mAddressBytes;
+    }
+
+    @NonNull
+    @Override
+    public String toString() {
+        StringBuilder builder = new StringBuilder("0x");
+        for (byte addressByte : mAddressBytes) {
+            builder.append(String.format("%02X", addressByte));
+        }
+        return builder.toString();
+    }
+
+    @Override
+    public boolean equals(@Nullable Object obj) {
+        if (obj instanceof UwbAddress) {
+            return Arrays.equals(mAddressBytes, ((UwbAddress) obj).getAddressBytes());
+        }
+        return false;
+    }
+
+    @Override
+    public int hashCode() {
+        return Arrays.hashCode(mAddressBytes);
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        dest.writeInt(mAddressBytes.length);
+        dest.writeByteArray(mAddressBytes);
+    }
+
+    public static final @android.annotation.NonNull Creator<UwbAddress> CREATOR =
+            new Creator<UwbAddress>() {
+                @Override
+                public UwbAddress createFromParcel(Parcel in) {
+                    byte[] address = new byte[in.readInt()];
+                    in.readByteArray(address);
+                    return UwbAddress.fromBytes(address);
+                }
+
+                @Override
+                public UwbAddress[] newArray(int size) {
+                    return new UwbAddress[size];
+                }
+            };
+}
diff --git a/ranging/framework/java/android/ranging/uwb/UwbComplexChannel.java b/ranging/framework/java/android/ranging/uwb/UwbComplexChannel.java
new file mode 100644
index 00000000..4124a66a
--- /dev/null
+++ b/ranging/framework/java/android/ranging/uwb/UwbComplexChannel.java
@@ -0,0 +1,272 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging.uwb;
+
+import android.annotation.FlaggedApi;
+import android.annotation.IntDef;
+import android.annotation.NonNull;
+import android.os.Parcel;
+import android.os.Parcelable;
+
+import com.android.ranging.flags.Flags;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.Objects;
+import java.util.Random;
+
+/**
+ * A Class representing the complex channel for UWB which comprises channel and preamble index
+ * negotiated between peer devices out of band before ranging.
+ *
+ * <p> PRF (Pulse Repetition Frequency) supported:
+ * <ul>
+ *     <li> BPRF - Base Pulse Repetition Frequency.</li>
+ *     <li> HPRF - Higher Pulse Repetition Frequency.</li>
+ * </ul>
+ */
+@FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
+public final class UwbComplexChannel implements Parcelable {
+
+    /**
+     * UWB Channel selections
+     *
+     * @hide
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef(
+            value = {
+                    UWB_CHANNEL_5,
+                    UWB_CHANNEL_6,
+                    UWB_CHANNEL_8,
+                    UWB_CHANNEL_9,
+                    UWB_CHANNEL_10,
+                    UWB_CHANNEL_12,
+                    UWB_CHANNEL_13,
+                    UWB_CHANNEL_14,
+            })
+    public @interface UwbChannel {
+    }
+
+    /** UWB channel 5 */
+    public static final int UWB_CHANNEL_5 = 5;
+    /** UWB channel 6 */
+    public static final int UWB_CHANNEL_6 = 6;
+    /** UWB channel 8 */
+    public static final int UWB_CHANNEL_8 = 8;
+    /** UWB channel 9 */
+    public static final int UWB_CHANNEL_9 = 9;
+    /** UWB channel 10 */
+    public static final int UWB_CHANNEL_10 = 10;
+    /** UWB channel 12 */
+    public static final int UWB_CHANNEL_12 = 12;
+    /** UWB channel 13 */
+    public static final int UWB_CHANNEL_13 = 13;
+    /** UWB channel 14 */
+    public static final int UWB_CHANNEL_14 = 14;
+
+    /**
+     * UWB preamble selections
+     *
+     * @hide
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef(
+            value = {
+                    UWB_PREAMBLE_CODE_INDEX_9,
+                    UWB_PREAMBLE_CODE_INDEX_10,
+                    UWB_PREAMBLE_CODE_INDEX_11,
+                    UWB_PREAMBLE_CODE_INDEX_12,
+                    UWB_PREAMBLE_CODE_INDEX_25,
+                    UWB_PREAMBLE_CODE_INDEX_26,
+                    UWB_PREAMBLE_CODE_INDEX_27,
+                    UWB_PREAMBLE_CODE_INDEX_28,
+                    UWB_PREAMBLE_CODE_INDEX_29,
+                    UWB_PREAMBLE_CODE_INDEX_30,
+                    UWB_PREAMBLE_CODE_INDEX_31,
+                    UWB_PREAMBLE_CODE_INDEX_32,
+            })
+    public @interface UwbPreambleCodeIndex {
+    }
+
+    /** UWB preamble code index 9 (PRF mode - BPRF). */
+    public static final int UWB_PREAMBLE_CODE_INDEX_9 = 9;
+    /** UWB preamble code index 10 (PRF mode - BPRF). */
+    public static final int UWB_PREAMBLE_CODE_INDEX_10 = 10;
+    /** UWB preamble code index 11 (PRF mode - BPRF). */
+    public static final int UWB_PREAMBLE_CODE_INDEX_11 = 11;
+    /** UWB preamble code index 12 (PRF mode - BPRF). */
+    public static final int UWB_PREAMBLE_CODE_INDEX_12 = 12;
+    /** UWB preamble code index 25 (PRF mode - HPRF). */
+    public static final int UWB_PREAMBLE_CODE_INDEX_25 = 25;
+    /** UWB preamble code index 26 (PRF mode - HPRF). */
+    public static final int UWB_PREAMBLE_CODE_INDEX_26 = 26;
+    /** UWB preamble code index 27 (PRF mode - HPRF). */
+    public static final int UWB_PREAMBLE_CODE_INDEX_27 = 27;
+    /** UWB preamble code index 28 (PRF mode - HPRF). */
+    public static final int UWB_PREAMBLE_CODE_INDEX_28 = 28;
+    /** UWB preamble code index 29 (PRF mode - HPRF). */
+    public static final int UWB_PREAMBLE_CODE_INDEX_29 = 29;
+    /** UWB preamble code index 30 (PRF mode - HPRF). */
+    public static final int UWB_PREAMBLE_CODE_INDEX_30 = 30;
+    /** UWB preamble code index 31 (PRF mode - HPRF). */
+    public static final int UWB_PREAMBLE_CODE_INDEX_31 = 31;
+    /** UWB preamble code index 32 (PRF mode - HPRF). */
+    public static final int UWB_PREAMBLE_CODE_INDEX_32 = 32;
+
+    private static final int[] PREAMBLE_INDEXES_BPRF =
+            new int[]{UWB_PREAMBLE_CODE_INDEX_9,
+                    UWB_PREAMBLE_CODE_INDEX_10,
+                    UWB_PREAMBLE_CODE_INDEX_11,
+                    UWB_PREAMBLE_CODE_INDEX_12};
+    @UwbChannel
+    private final int mChannel;
+    @UwbPreambleCodeIndex
+    private final int mPreambleIndex;
+
+    private UwbComplexChannel(Builder builder) {
+        mChannel = builder.mChannel;
+        mPreambleIndex = builder.mPreambleIndex;
+    }
+
+    private UwbComplexChannel(@NonNull Parcel in) {
+        mChannel = in.readInt();
+        mPreambleIndex = in.readInt();
+    }
+
+    @NonNull
+    public static final Creator<UwbComplexChannel> CREATOR = new Creator<UwbComplexChannel>() {
+        @Override
+        public UwbComplexChannel createFromParcel(Parcel in) {
+            return new UwbComplexChannel(in);
+        }
+
+        @Override
+        public UwbComplexChannel[] newArray(int size) {
+            return new UwbComplexChannel[size];
+        }
+    };
+
+    /**
+     * Gets the UWB channel associated with this configuration.
+     *
+     * @return The channel number, which is one of the predefined UWB channels:
+     */
+    @UwbChannel
+    public int getChannel() {
+        return mChannel;
+    }
+
+    /**
+     * Gets the UWB preamble index associated with this configuration.
+     *
+     * @return The preamble index, which is one of the predefined UWB preamble indices:
+     *
+     * See <a href="https://groups.firaconsortium.org/wg/members/document/1949> FiRa UCI Spec.</a>
+     */
+
+    @UwbPreambleCodeIndex
+    public int getPreambleIndex() {
+        return mPreambleIndex;
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        dest.writeInt(mChannel);
+        dest.writeInt(mPreambleIndex);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof UwbComplexChannel other)) return false;
+        return mChannel == other.mChannel && mPreambleIndex == other.mPreambleIndex;
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(mChannel, mPreambleIndex);
+    }
+
+    /**
+     * Builder for creating instances of {@link UwbComplexChannel}.
+     */
+    public static final class Builder {
+        @UwbChannel
+        private int mChannel = UWB_CHANNEL_5;
+        @UwbPreambleCodeIndex
+        private int mPreambleIndex = PREAMBLE_INDEXES_BPRF[new Random().nextInt(
+                PREAMBLE_INDEXES_BPRF.length)];
+
+        /**
+         * Sets the channel for the ranging device.
+         * <p> Defaults to {@link #UWB_CHANNEL_5}
+         *
+         * @param channel The channel number to be set.
+         * @return This {@link Builder} instance.
+         */
+        @NonNull
+        public Builder setChannel(@UwbChannel int channel) {
+            mChannel = channel;
+            return this;
+        }
+
+        /**
+         * Sets the preamble index for the ranging device as defined in
+         * See <a href="https://groups.firaconsortium.org/wg/members/document/1949> FiRa UCI
+         * Spec.</a>}
+         * <p> PRF (Pulse Repetition Frequency) is selected based on the preamble index set here.
+         *
+         * <p> Defaults to a random BPRF preamble index.
+         * One among {@link #UWB_PREAMBLE_CODE_INDEX_9}, {@link #UWB_PREAMBLE_CODE_INDEX_10},
+         * {@link #UWB_PREAMBLE_CODE_INDEX_11} or {@link #UWB_PREAMBLE_CODE_INDEX_12}.
+         * For better performance always use a random preamble index for each ranging session.
+         *
+         * @param preambleIndex The preamble index to be set.
+         * @return This {@link Builder} instance.
+         */
+        @NonNull
+        public Builder setPreambleIndex(@UwbPreambleCodeIndex int preambleIndex) {
+            mPreambleIndex = preambleIndex;
+            return this;
+        }
+
+        /**
+         * Builds and returns a new instance of {@link UwbComplexChannel}.
+         *
+         * @return A new {@link UwbComplexChannel} instance.
+         */
+        @NonNull
+        public UwbComplexChannel build() {
+            return new UwbComplexChannel(this);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "UwbComplexChannel{ mChannel="
+                + mChannel
+                + ", mPreambleIndex="
+                + mPreambleIndex
+                + " }";
+    }
+}
diff --git a/ranging/framework/java/android/ranging/uwb/UwbRangingCapabilities.java b/ranging/framework/java/android/ranging/uwb/UwbRangingCapabilities.java
new file mode 100644
index 00000000..55f023ed
--- /dev/null
+++ b/ranging/framework/java/android/ranging/uwb/UwbRangingCapabilities.java
@@ -0,0 +1,478 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging.uwb;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.ranging.DataNotificationConfig.NotificationConfigType;
+import android.ranging.RangingCapabilities.TechnologyCapabilities;
+import android.ranging.RangingManager;
+import android.ranging.raw.RawRangingDevice.RangingUpdateRate;
+import android.ranging.uwb.UwbComplexChannel.UwbChannel;
+import android.ranging.uwb.UwbComplexChannel.UwbPreambleCodeIndex;
+import android.ranging.uwb.UwbRangingParams.ConfigId;
+import android.ranging.uwb.UwbRangingParams.SlotDuration;
+
+import com.android.ranging.flags.Flags;
+
+import java.time.Duration;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Represents the capabilities of Ultra-Wideband (UWB) ranging technology.
+ *
+ * <p>This class encapsulates various UWB-related features, including support for specific
+ * measurement types (e.g., distance, azimuth, elevation), ranging configurations, and
+ * operational parameters like update rates and channel availability.</p>
+ */
+@FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
+public final class UwbRangingCapabilities implements Parcelable, TechnologyCapabilities {
+
+    private final boolean mSupportsDistance;
+    private final boolean mSupportsAzimuthalAngle;
+    private final boolean mSupportsElevationAngle;
+    private final boolean mSupportsRangingIntervalReconfigure;
+    private final Duration mMinRangingInterval;
+    private final List<Integer> mSupportedChannels;
+    private final List<Integer> mSupportedNtfConfigs;
+    private final List<Integer> mSupportedConfigIds;
+    private final List<Integer> mSupportedSlotDurations;
+    private final List<Integer> mSupportedRangingUpdateRates;
+    private final List<Integer> mSupportedPreambleIndexes;
+    private final boolean mHasBackgroundRangingSupport;
+
+    private UwbRangingCapabilities(Builder builder) {
+        mSupportsDistance = builder.mSupportsDistance;
+        mSupportsAzimuthalAngle = builder.mSupportsAzimuthalAngle;
+        mSupportsElevationAngle = builder.mSupportsElevationAngle;
+        mSupportsRangingIntervalReconfigure = builder.mSupportsRangingIntervalReconfigure;
+        mMinRangingInterval = builder.mMinRangingInterval;
+        mSupportedChannels = builder.mSupportedChannels;
+        mSupportedNtfConfigs = builder.mSupportedNtfConfigs;
+        mSupportedConfigIds = builder.mSupportedConfigIds;
+        mSupportedSlotDurations = builder.mSupportedSlotDurations;
+        mSupportedRangingUpdateRates = builder.mSupportedRangingUpdateRates;
+        mSupportedPreambleIndexes = builder.mSupportedPreambleIndexes;
+        mHasBackgroundRangingSupport = builder.mHasBackgroundRangingSupport;
+    }
+
+    private UwbRangingCapabilities(Parcel in) {
+        mSupportsDistance = in.readByte() != 0;
+        mSupportsAzimuthalAngle = in.readByte() != 0;
+        mSupportsElevationAngle = in.readByte() != 0;
+        mSupportsRangingIntervalReconfigure = in.readByte() != 0;
+        mMinRangingInterval = Duration.ofMillis(in.readLong());
+        mSupportedChannels = new ArrayList<>();
+        in.readList(mSupportedChannels, Integer.class.getClassLoader(), Integer.class);
+        mSupportedNtfConfigs = new ArrayList<>();
+        in.readList(mSupportedNtfConfigs, Integer.class.getClassLoader(), Integer.class);
+        mSupportedConfigIds = new ArrayList<>();
+        in.readList(mSupportedConfigIds, Integer.class.getClassLoader(), Integer.class);
+        mSupportedSlotDurations = new ArrayList<>();
+        in.readList(mSupportedSlotDurations, Integer.class.getClassLoader(), Integer.class);
+        mSupportedRangingUpdateRates = new ArrayList<>();
+        in.readList(mSupportedRangingUpdateRates, Integer.class.getClassLoader(), Integer.class);
+        mSupportedPreambleIndexes = new ArrayList<>();
+        in.readList(mSupportedPreambleIndexes, Integer.class.getClassLoader(), Integer.class);
+        mHasBackgroundRangingSupport = in.readByte() != 0;
+    }
+
+    @NonNull
+    public static final Creator<UwbRangingCapabilities> CREATOR =
+            new Creator<UwbRangingCapabilities>() {
+                @Override
+                public UwbRangingCapabilities createFromParcel(Parcel in) {
+                    return new UwbRangingCapabilities(in);
+                }
+
+                @Override
+                public UwbRangingCapabilities[] newArray(int size) {
+                    return new UwbRangingCapabilities[size];
+                }
+            };
+
+    /**
+     * @hide
+     */
+    @Override
+    public @RangingManager.RangingTechnology int getTechnology() {
+        return RangingManager.UWB;
+    }
+
+    /**
+     * Checks if the device supports distance measurement.
+     *
+     * @return {@code true} if distance measurement is supported; {@code false} otherwise.
+     */
+    public boolean isDistanceMeasurementSupported() {
+        return mSupportsDistance;
+    }
+
+    /**
+     * Checks if the device hardware supports azimuthal angle measurement.
+     *
+     * @return {@code true} if azimuthal angle measurement is supported; {@code false} otherwise.
+     */
+    public boolean isAzimuthalAngleSupported() {
+        return mSupportsAzimuthalAngle;
+    }
+
+    /**
+     * Checks if the device hardware supports elevation angle measurement.
+     *
+     * @return {@code true} if elevation angle measurement is supported; {@code false} otherwise.
+     */
+    public boolean isElevationAngleSupported() {
+        return mSupportsElevationAngle;
+    }
+
+    /**
+     * Checks if the ranging interval can be reconfigured.
+     *
+     * @return {@code true} if the interval is configurable; {@code false} otherwise.
+     */
+    public boolean isRangingIntervalReconfigurationSupported() {
+        return mSupportsRangingIntervalReconfigure;
+    }
+
+    /**
+     * Gets the minimum supported ranging interval.
+     *
+     * @return the minimum ranging interval.
+     */
+    @NonNull
+    public Duration getMinimumRangingInterval() {
+        return mMinRangingInterval;
+    }
+
+    /**
+     * Gets the list of supported UWB channels.
+     *
+     * @return a list of supported channel numbers.
+     */
+    @NonNull
+    @UwbChannel
+    public List<Integer> getSupportedChannels() {
+        return List.copyOf(mSupportedChannels);
+    }
+
+
+    /**
+     * Gets the list of supported preamble indexes.
+     *
+     * @return a list of supported preamble indexes.
+     *
+     */
+    @NonNull
+    @UwbPreambleCodeIndex
+    public List<Integer> getSupportedPreambleIndexes() {
+        return List.copyOf(mSupportedPreambleIndexes);
+
+    }
+
+    /**
+     * Gets the list of supported notification configurations.
+     *
+     * @return a list of supported notification configuration type.
+     */
+    @NonNull
+    @NotificationConfigType
+    public List<Integer> getSupportedNotificationConfigurations() {
+        return List.copyOf(mSupportedNtfConfigs);
+    }
+
+    /**
+     * Gets the list of supported configuration IDs.
+     *
+     * @return a list of supported configuration IDs.
+     */
+    @NonNull
+    @ConfigId
+    public List<Integer> getSupportedConfigIds() {
+        return List.copyOf(mSupportedConfigIds);
+    }
+
+    /**
+     * Gets the list of supported slot durations in microseconds.
+     *
+     * @return a list of supported slot durations.
+     */
+    @NonNull
+    @SlotDuration
+    public List<Integer> getSupportedSlotDurations() {
+        return List.copyOf(mSupportedSlotDurations);
+    }
+
+    /**
+     * Gets the list of supported ranging update rates.
+     *
+     * @return a list of supported update rates.
+     */
+    @NonNull
+    @RangingUpdateRate
+    public List<Integer> getSupportedRangingUpdateRates() {
+        return List.copyOf(mSupportedRangingUpdateRates);
+    }
+
+    /**
+     * Checks if background ranging is supported.
+     *
+     * @return {@code true} if background ranging is supported; {@code false} otherwise.
+     */
+    public boolean isBackgroundRangingSupported() {
+        return mHasBackgroundRangingSupport;
+    }
+
+    /**
+     * @hide
+     */
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        dest.writeByte((byte) (mSupportsDistance ? 1 : 0));
+        dest.writeByte((byte) (mSupportsAzimuthalAngle ? 1 : 0));
+        dest.writeByte((byte) (mSupportsElevationAngle ? 1 : 0));
+        dest.writeByte((byte) (mSupportsRangingIntervalReconfigure ? 1 : 0));
+        dest.writeLong(mMinRangingInterval.toMillis());
+        dest.writeList(mSupportedChannels);
+        dest.writeList(mSupportedNtfConfigs);
+        dest.writeList(mSupportedConfigIds);
+        dest.writeList(mSupportedSlotDurations);
+        dest.writeList(mSupportedRangingUpdateRates);
+        dest.writeList(mSupportedPreambleIndexes);
+        dest.writeByte((byte) (mHasBackgroundRangingSupport ? 1 : 0));
+    }
+
+    /**
+     * Builder for {@link UwbRangingCapabilities}
+     *
+     * @hide
+     */
+    public static class Builder {
+        private boolean mSupportsDistance;
+        private boolean mSupportsAzimuthalAngle;
+        private boolean mSupportsElevationAngle;
+        private boolean mSupportsRangingIntervalReconfigure;
+        private Duration mMinRangingInterval;
+        private List<Integer> mSupportedChannels;
+        private List<Integer> mSupportedNtfConfigs;
+        private List<Integer> mSupportedConfigIds;
+        private List<Integer> mSupportedSlotDurations;
+        private List<Integer> mSupportedRangingUpdateRates;
+        private List<Integer> mSupportedPreambleIndexes;
+        private boolean mHasBackgroundRangingSupport;
+
+        /**
+         * Sets supports distance.
+         *
+         * @param supportsDistance the supports distance
+         * @return the supports distance
+         */
+        @NonNull
+        public Builder setSupportsDistance(boolean supportsDistance) {
+            this.mSupportsDistance = supportsDistance;
+            return this;
+        }
+
+        /**
+         * Sets supports azimuthal angle.
+         *
+         * @param supportsAzimuthalAngle the supports azimuthal angle
+         * @return the supports azimuthal angle
+         */
+        @NonNull
+        public Builder setSupportsAzimuthalAngle(boolean supportsAzimuthalAngle) {
+            this.mSupportsAzimuthalAngle = supportsAzimuthalAngle;
+            return this;
+        }
+
+        /**
+         * Sets supports elevation angle.
+         *
+         * @param supportsElevationAngle the supports elevation angle
+         * @return the supports elevation angle
+         */
+        @NonNull
+        public Builder setSupportsElevationAngle(boolean supportsElevationAngle) {
+            this.mSupportsElevationAngle = supportsElevationAngle;
+            return this;
+        }
+
+        /**
+         * Sets supports ranging interval reconfigure.
+         *
+         * @param supportsRangingIntervalReconfigure the supports ranging interval reconfigure
+         * @return the supports ranging interval reconfigure
+         */
+        @NonNull
+        public Builder setSupportsRangingIntervalReconfigure(
+                boolean supportsRangingIntervalReconfigure) {
+            this.mSupportsRangingIntervalReconfigure = supportsRangingIntervalReconfigure;
+            return this;
+        }
+
+        /**
+         * Sets min ranging interval.
+         *
+         * @param minRangingInterval the min ranging interval
+         * @return the min ranging interval
+         */
+        @NonNull
+        public Builder setMinRangingInterval(Duration minRangingInterval) {
+            this.mMinRangingInterval = minRangingInterval;
+            return this;
+        }
+
+        /**
+         * Sets supported channels.
+         *
+         * @param supportedChannels the supported channels
+         * @return the supported channels
+         * @throws IllegalArgumentException if the provided list is null.
+         */
+        @NonNull
+        public Builder setSupportedChannels(List<Integer> supportedChannels) {
+            this.mSupportedChannels = supportedChannels;
+            return this;
+        }
+
+        /**
+         * Sets preamble indexes.
+         *
+         * @param supportedPreambleIndexes the supported preamble indexes
+         * @return {@link Builder} instance.
+         * @throws IllegalArgumentException if the provided list is null.
+         */
+        @NonNull
+        public Builder setSupportedPreambleIndexes(List<Integer> supportedPreambleIndexes) {
+            this.mSupportedPreambleIndexes = supportedPreambleIndexes;
+            return this;
+        }
+
+        /**
+         * Sets supported ntf configs.
+         *
+         * @param supportedNtfConfigs the supported ntf configs
+         * @return the supported ntf configs
+         * @throws IllegalArgumentException if the provided list is null.
+         */
+        @NonNull
+        public Builder setSupportedNtfConfigs(@NonNull List<Integer> supportedNtfConfigs) {
+            this.mSupportedNtfConfigs = supportedNtfConfigs;
+            return this;
+        }
+
+        /**
+         * Sets supported config ids.
+         *
+         * @param supportedConfigIds the supported config ids
+         * @return the supported config ids
+         * @throws IllegalArgumentException if the provided list is null.
+         */
+        @NonNull
+        public Builder setSupportedConfigIds(@NonNull List<Integer> supportedConfigIds) {
+            this.mSupportedConfigIds = supportedConfigIds;
+            return this;
+        }
+
+        /**
+         * Sets supported slot durations.
+         *
+         * @param supportedSlotDurations the supported slot durations
+         * @return the supported slot durations
+         * @throws IllegalArgumentException if the provided list is null.
+         */
+        @NonNull
+        public Builder setSupportedSlotDurations(@NonNull List<Integer> supportedSlotDurations) {
+            this.mSupportedSlotDurations = supportedSlotDurations;
+            return this;
+        }
+
+        /**
+         * Sets supported ranging update rates.
+         *
+         * @param supportedRangingUpdateRates the supported ranging update rates
+         * @return the supported ranging update rates
+         * @throws IllegalArgumentException if the provided list is null.
+         */
+        @NonNull
+        public Builder setSupportedRangingUpdateRates(
+                @NonNull List<Integer> supportedRangingUpdateRates) {
+            this.mSupportedRangingUpdateRates = supportedRangingUpdateRates;
+            return this;
+        }
+
+        /**
+         * Sets has background ranging support.
+         *
+         * @param hasBackgroundRangingSupport the has background ranging support
+         * @return the has background ranging support
+         */
+        @NonNull
+        public Builder setHasBackgroundRangingSupport(boolean hasBackgroundRangingSupport) {
+            this.mHasBackgroundRangingSupport = hasBackgroundRangingSupport;
+            return this;
+        }
+
+        /**
+         * Build uwb ranging capabilities.
+         *
+         * @return the uwb ranging capabilities
+         */
+        @NonNull
+        public UwbRangingCapabilities build() {
+            return new UwbRangingCapabilities(this);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "UwbRangingCapabilities{ "
+                + "mSupportsDistance="
+                + mSupportsDistance
+                + ", mSupportsAzimuthalAngle="
+                + mSupportsAzimuthalAngle
+                + ", mSupportsElevationAngle="
+                + mSupportsElevationAngle
+                + ", mSupportsRangingIntervalReconfigure="
+                + mSupportsRangingIntervalReconfigure
+                + ", mMinRangingInterval="
+                + mMinRangingInterval
+                + ", mSupportedChannels="
+                + mSupportedChannels
+                + ", mSupportedNtfConfigs="
+                + mSupportedNtfConfigs
+                + ", mSupportedConfigIds="
+                + mSupportedConfigIds
+                + ", mSupportedSlotDurations="
+                + mSupportedSlotDurations
+                + ", mSupportedRangingUpdateRates="
+                + mSupportedRangingUpdateRates
+                + ", mSupportedPreambleIndexes="
+                + mSupportedPreambleIndexes
+                + ", mHasBackgroundRangingSupport="
+                + mHasBackgroundRangingSupport
+                + " }";
+    }
+}
diff --git a/ranging/framework/java/android/ranging/uwb/UwbRangingParams.java b/ranging/framework/java/android/ranging/uwb/UwbRangingParams.java
new file mode 100644
index 00000000..929262ee
--- /dev/null
+++ b/ranging/framework/java/android/ranging/uwb/UwbRangingParams.java
@@ -0,0 +1,447 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging.uwb;
+
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_NORMAL;
+
+import android.annotation.FlaggedApi;
+import android.annotation.IntDef;
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.ranging.raw.RawRangingDevice.RangingUpdateRate;
+
+import com.android.ranging.flags.Flags;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.Arrays;
+import java.util.Objects;
+
+/**
+ * UwbRangingParams encapsulates the parameters required for a UWB ranging session.
+ */
+@FlaggedApi(Flags.FLAG_RANGING_STACK_ENABLED)
+public final class UwbRangingParams implements Parcelable {
+
+    private final int mSessionId;
+
+    private final int mSubSessionId;
+
+    private UwbRangingParams(Parcel in) {
+        mSessionId = in.readInt();
+        mSubSessionId = in.readInt();
+        mConfigId = in.readInt();
+        mDeviceAddress = in.readParcelable(UwbAddress.class.getClassLoader());
+        mSessionKeyInfo = in.readBlob();
+        mSubSessionKeyInfo = in.readBlob();
+        mComplexChannel = in.readParcelable(UwbComplexChannel.class.getClassLoader());
+        mRangingUpdateRate = in.readInt();
+        mPeerAddress = in.readParcelable(UwbAddress.class.getClassLoader());
+        mSlotDurationMillis = in.readInt();
+    }
+
+    @NonNull
+    public static final Creator<UwbRangingParams> CREATOR = new Creator<UwbRangingParams>() {
+        @Override
+        public UwbRangingParams createFromParcel(Parcel in) {
+            return new UwbRangingParams(in);
+        }
+
+        @Override
+        public UwbRangingParams[] newArray(int size) {
+            return new UwbRangingParams[size];
+        }
+    };
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(@androidx.annotation.NonNull Parcel dest, int flags) {
+        dest.writeInt(mSessionId);
+        dest.writeInt(mSubSessionId);
+        dest.writeInt(mConfigId);
+        dest.writeParcelable(mDeviceAddress, flags);
+        dest.writeBlob(mSessionKeyInfo);
+        dest.writeBlob(mSubSessionKeyInfo);
+        dest.writeParcelable(mComplexChannel, flags);
+        dest.writeInt(mRangingUpdateRate);
+        dest.writeParcelable(mPeerAddress, flags);
+        dest.writeInt(mSlotDurationMillis);
+    }
+
+    /**
+     * Defines the roles that a device can assume within a UWB ranging session.
+     *
+     * @hide
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({
+            CONFIG_UNICAST_DS_TWR,
+            CONFIG_MULTICAST_DS_TWR,
+            CONFIG_PROVISIONED_UNICAST_DS_TWR,
+            CONFIG_PROVISIONED_MULTICAST_DS_TWR,
+            CONFIG_PROVISIONED_INDIVIDUAL_MULTICAST_DS_TWR,
+            CONFIG_PROVISIONED_UNICAST_DS_TWR_VERY_FAST,
+    })
+    public @interface ConfigId {
+    }
+
+    /**
+     * FiRa-defined unicast {@code STATIC STS DS-TWR} ranging, deferred mode, ranging interval
+     * Fast (120ms), Normal (240ms), Infrequent (600ms)
+     */
+    public static final int CONFIG_UNICAST_DS_TWR = 1;
+
+    /**
+     * FiRa-defined multicast {@code STATIC STS DS-TWR} ranging, deferred mode, ranging interval
+     * Fast (120ms), Normal (200ms), Infrequent (600ms)
+     */
+    public static final int CONFIG_MULTICAST_DS_TWR = 2;
+    /** Same as {@code CONFIG_UNICAST_DS_TWR}, except P-STS security mode is enabled. */
+    public static final int CONFIG_PROVISIONED_UNICAST_DS_TWR = 3;
+    /** Same as {@code CONFIG_MULTICAST_DS_TWR}, except P-STS security mode is enabled. */
+    public static final int CONFIG_PROVISIONED_MULTICAST_DS_TWR = 4;
+    /**
+     * Same as {@code CONFIG_UNICAST_DS_TWR}, except P-STS individual controlee key mode is
+     * enabled.
+     */
+    public static final int CONFIG_PROVISIONED_INDIVIDUAL_MULTICAST_DS_TWR = 5;
+
+    /** Same as {@code CONFIG_ID_3}, except fast ranging interval is 96 milliseconds. */
+    public static final int CONFIG_PROVISIONED_UNICAST_DS_TWR_VERY_FAST = 6;
+
+    /** Sub session id not applicable. */
+    public static final int SUB_SESSION_UNDEFINED = -1;
+
+    @ConfigId
+    private final int mConfigId;
+
+    private final UwbAddress mDeviceAddress;
+
+    private final byte[] mSessionKeyInfo;
+
+    private final byte[] mSubSessionKeyInfo;
+
+    private final UwbComplexChannel mComplexChannel;
+
+    private final UwbAddress mPeerAddress;
+
+    /**
+     * Defines slot supported slot durations.
+     *
+     * @hide
+     */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({
+            DURATION_1_MS,
+            DURATION_2_MS,
+    })
+    public @interface SlotDuration {
+    }
+
+    /** 1 millisecond slot duration */
+    public static final int DURATION_1_MS = 1;
+
+    /** 2 millisecond slot duration */
+    public static final int DURATION_2_MS = 2;
+
+    @RangingUpdateRate
+    private final int mRangingUpdateRate;
+
+    @SlotDuration
+    private final int mSlotDurationMillis;
+
+    private UwbRangingParams(Builder builder) {
+        mSessionId = builder.mSessionId;
+        mSubSessionId = builder.mSubSessionId;
+        mConfigId = builder.mConfigId;
+        mDeviceAddress = builder.mDeviceAddress;
+        mSessionKeyInfo = builder.mSessionKeyInfo;
+        mSubSessionKeyInfo = builder.mSubSessionKeyInfo;
+        mComplexChannel = builder.mComplexChannel;
+        mPeerAddress = builder.mPeerAddress;
+        mRangingUpdateRate = builder.mRangingUpdateRate;
+        mSlotDurationMillis = builder.mSlotDuration;
+    }
+
+    /**
+     * Gets the session ID associated with this ranging session.
+     *
+     * @return The session ID as an integer.
+     */
+    public int getSessionId() {
+        return mSessionId;
+    }
+
+    /**
+     * Gets the sub-session ID if applicable for the session.
+     *
+     * @return The sub-session ID as an integer or {@link #SUB_SESSION_UNDEFINED} if not applicable.
+     */
+    public int getSubSessionId() {
+        return mSubSessionId;
+    }
+
+    /**
+     * Gets the configuration ID associated with this session.
+     *
+     * @return The configuration ID as an integer.
+     */
+    @ConfigId
+    public int getConfigId() {
+        return mConfigId;
+    }
+
+    /**
+     * Gets the UWB address of the device.
+     *
+     * @return The {@link UwbAddress} of the device.
+     */
+    @NonNull
+    public UwbAddress getDeviceAddress() {
+        return mDeviceAddress;
+    }
+
+    /**
+     * Gets session key information, if available.
+     *
+     * @return A byte array containing session key info, or null if not available.
+     */
+    @Nullable
+    public byte[] getSessionKeyInfo() {
+        return mSessionKeyInfo == null ? null : Arrays.copyOf(mSessionKeyInfo,
+                mSessionKeyInfo.length);
+    }
+
+    /**
+     * Gets sub-session key information, if available.
+     *
+     * @return A byte array containing sub-session key info, or null if not available.
+     */
+    @Nullable
+    public byte[] getSubSessionKeyInfo() {
+        return mSubSessionKeyInfo == null ? null : Arrays.copyOf(mSubSessionKeyInfo,
+                mSubSessionKeyInfo.length);
+    }
+
+    /**
+     * Gets the complex channel information for this session.
+     *
+     * @return A {@link UwbComplexChannel} object containing channel and preamble index.
+     */
+    @NonNull
+    public UwbComplexChannel getComplexChannel() {
+        return mComplexChannel;
+    }
+
+    /**
+     * Returns the UwbAddress of the peer device.
+     *
+     * @return A {@link UwbAddress} corresponding to the peer device to range with.
+     */
+    @NonNull
+    public UwbAddress getPeerAddress() {
+        return mPeerAddress;
+    }
+
+    /**
+     * Returns the update rate for ranging operations.
+     *
+     * @return The ranging update rate.
+     */
+    @RangingUpdateRate
+    public int getRangingUpdateRate() {
+        return mRangingUpdateRate;
+    }
+
+    /**
+     * Returns slot duration of the session.
+     *
+     * @return the slot duration.
+     */
+    @SlotDuration
+    public int getSlotDuration() {
+        return mSlotDurationMillis;
+    }
+
+
+    /**
+     * Builder class for creating instances of {@link UwbRangingParams}
+     */
+    public static final class Builder {
+        private int mSessionId;
+        private int mSubSessionId = SUB_SESSION_UNDEFINED;
+        private int mConfigId;
+        private UwbAddress mDeviceAddress = null;
+        private byte[] mSessionKeyInfo = null;
+        private byte[] mSubSessionKeyInfo = null;
+        private UwbComplexChannel mComplexChannel = new UwbComplexChannel.Builder().build();
+        private UwbAddress mPeerAddress = null;
+        @RangingUpdateRate
+        private int mRangingUpdateRate = UPDATE_RATE_NORMAL;
+        @SlotDuration
+        private int mSlotDuration = DURATION_2_MS;
+
+        /**
+         * Constructs a new {@link Builder} for creating a ranging session.
+         *
+         * @param sessionId     A unique identifier for the session.
+         * @param configId      The configuration ID for the ranging parameters.
+         * @param deviceAddress The {@link UwbAddress} representing the device's address.
+         *                      Must be non-null.
+         * @param peerAddress   The {@link UwbAddress} of the peer device.
+         *                      Must be non-null.
+         * @throws IllegalArgumentException if either {@code deviceAddress} or {@code peerAddress}
+         *                                  is null.
+         */
+        public Builder(int sessionId, @ConfigId int configId, @NonNull UwbAddress deviceAddress,
+                @NonNull UwbAddress peerAddress) {
+            Objects.requireNonNull(deviceAddress);
+            Objects.requireNonNull(peerAddress);
+            mSessionId = sessionId;
+            mConfigId = configId;
+            mDeviceAddress = deviceAddress;
+            mPeerAddress = peerAddress;
+        }
+
+        /**
+         * Sets the sub-session ID for the ranging session.
+         *
+         * @param subSessionId the sub-session ID, which should be a unique identifier for the
+         *                     sub-session.
+         * @return this Builder instance for method chaining.
+         */
+        @NonNull
+        public Builder setSubSessionId(int subSessionId) {
+            mSubSessionId = subSessionId;
+            return this;
+        }
+
+        /**
+         * Sets the session key information for secure ranging.
+         *
+         * @param sessionKeyInfo a byte array containing session key information.
+         * @return this Builder instance.
+         * @throws IllegalArgumentException if the provided byte array is null.
+         */
+        @NonNull
+        public Builder setSessionKeyInfo(@NonNull byte[] sessionKeyInfo) {
+            Objects.requireNonNull(sessionKeyInfo);
+            mSessionKeyInfo = Arrays.copyOf(sessionKeyInfo, sessionKeyInfo.length);
+            return this;
+        }
+
+        /**
+         * Sets the sub-session key information for secure ranging.
+         *
+         * @param subSessionKeyInfo a byte array containing sub-session key information.
+         * @return this Builder instance.
+         * @throws IllegalArgumentException if the provided map is null.
+         */
+        @NonNull
+        public Builder setSubSessionKeyInfo(@NonNull byte[] subSessionKeyInfo) {
+            Objects.requireNonNull(subSessionKeyInfo);
+            mSubSessionKeyInfo = Arrays.copyOf(subSessionKeyInfo, subSessionKeyInfo.length);
+            return this;
+        }
+
+        /**
+         * Sets the complex channel configuration for the ranging session.
+         *
+         * @param complexChannel a non-null {@link UwbComplexChannel} instance representing the
+         *                       channel and preamble configuration. For better performance always
+         *                       use a random preamble index for each ranging session.
+         * @return this Builder instance.
+         * @throws IllegalArgumentException if the provided complex channel is null.
+         */
+        @NonNull
+        public Builder setComplexChannel(@NonNull UwbComplexChannel complexChannel) {
+            mComplexChannel = complexChannel;
+            return this;
+        }
+
+        /**
+         * Sets the ranging update rate for the session.
+         * <p> Defaults to {@link RangingUpdateRate#UPDATE_RATE_NORMAL}.
+         *
+         * @param rate the ranging update rate, defined as one of the constants in
+         *             {@link RangingUpdateRate}.
+         * @return this Builder instance.
+         */
+        @NonNull
+        public Builder setRangingUpdateRate(@RangingUpdateRate int rate) {
+            mRangingUpdateRate = rate;
+            return this;
+        }
+
+        /**
+         * Sets the slot duration in milliseconds for the ranging session.
+         * <p> Defaults to {@link #DURATION_2_MS}.
+         *
+         * @param durationMs the slot duration {@link SlotDuration}
+         * @return this Builder instance.
+         * @throws IllegalArgumentException if the provided duration is out of range.
+         */
+        @NonNull
+        public Builder setSlotDuration(@SlotDuration int durationMs) {
+            mSlotDuration = durationMs;
+            return this;
+        }
+
+        /**
+         * Builds a new instance of {@link UwbRangingParams}.
+         *
+         * @return a new instance of {@link UwbRangingParams} created using the current state of
+         * the builder.
+         */
+        @NonNull
+        public UwbRangingParams build() {
+            return new UwbRangingParams(this);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "UwbRangingParams{ "
+                + "mSessionId="
+                + mSessionId
+                + ", mSubSessionId="
+                + mSubSessionId
+                + ", mConfigId="
+                + mConfigId
+                + ", mDeviceAddress="
+                + mDeviceAddress
+                + ", mSessionKeyInfo="
+                + Arrays.toString(mSessionKeyInfo)
+                + ", mSubSessionKeyInfo="
+                + Arrays.toString(mSubSessionKeyInfo)
+                + ", mComplexChannel="
+                + mComplexChannel
+                + ", mPeerAddress="
+                + mPeerAddress
+                + ", mRangingUpdateRate="
+                + mRangingUpdateRate
+                + ", mSlotDurationMillis="
+                + mSlotDurationMillis
+                + " }";
+    }
+}
diff --git a/ranging/framework/java/android/ranging/wifi/rtt/RttRangingCapabilities.java b/ranging/framework/java/android/ranging/wifi/rtt/RttRangingCapabilities.java
new file mode 100644
index 00000000..467a55e0
--- /dev/null
+++ b/ranging/framework/java/android/ranging/wifi/rtt/RttRangingCapabilities.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging.wifi.rtt;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.ranging.RangingCapabilities.TechnologyCapabilities;
+import android.ranging.RangingManager;
+
+import com.android.ranging.flags.Flags;
+
+/**
+ * Represents the capabilities of the WiFi Neighbor Awareness Networking Round Trip Time (NAN-RTT)
+ * ranging.
+ *
+ */
+@FlaggedApi(Flags.FLAG_RANGING_RTT_ENABLED)
+public final class RttRangingCapabilities implements Parcelable, TechnologyCapabilities {
+
+    private final boolean mHasPeriodicRangingHwFeature;
+
+    private RttRangingCapabilities(Builder builder) {
+        mHasPeriodicRangingHwFeature = builder.mHasPeriodicRangingHwFeature;
+    }
+
+    private RttRangingCapabilities(Parcel in) {
+        mHasPeriodicRangingHwFeature = in.readBoolean();
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        dest.writeBoolean(mHasPeriodicRangingHwFeature);
+    }
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @NonNull
+    public static final Creator<RttRangingCapabilities> CREATOR =
+            new Creator<RttRangingCapabilities>() {
+                @Override
+                public RttRangingCapabilities createFromParcel(Parcel in) {
+                    return new RttRangingCapabilities(in);
+                }
+
+                @Override
+                public RttRangingCapabilities[] newArray(int size) {
+                    return new RttRangingCapabilities[size];
+                }
+            };
+
+    /**
+     * @hide
+     */
+    @Override
+    public @RangingManager.RangingTechnology int getTechnology() {
+        return RangingManager.WIFI_NAN_RTT;
+    }
+
+    /**
+     * Indicates whether the hardware supports periodic ranging feature.
+     *
+     * @return {@code true} if periodic ranging is supported; {@code false} otherwise.
+     */
+    public boolean hasPeriodicRangingHwFeature() {
+        return mHasPeriodicRangingHwFeature;
+    }
+
+    /**
+     * Builder for {@link RttRangingCapabilities}
+     *
+     * @hide
+     */
+    public static class Builder {
+        private boolean mHasPeriodicRangingHwFeature = false;
+
+        /**
+         * Sets whether hardware supports periodic ranging feature.
+         *
+         * @param periodicRangingHwFeature {@code true} if periodic ranging is supported;
+         *                               {@code false} otherwise.
+         * @return this {@link Builder} instance for method chaining.
+         */
+        @NonNull
+        public Builder setPeriodicRangingHwFeature(boolean periodicRangingHwFeature) {
+            mHasPeriodicRangingHwFeature = periodicRangingHwFeature;
+            return this;
+        }
+
+        /**
+         * Builds and returns an {@link RttRangingCapabilities} instance configured with the
+         * provided settings.
+         *
+         * @return a new {@link RttRangingCapabilities} instance.
+         */
+        @NonNull
+        public RttRangingCapabilities build() {
+            return new RttRangingCapabilities(this);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "RttRangingCapabilities{ "
+                + "mHasPeriodicRangingHwFeature="
+                + mHasPeriodicRangingHwFeature
+                + " }";
+    }
+}
diff --git a/ranging/framework/java/android/ranging/wifi/rtt/RttRangingParams.java b/ranging/framework/java/android/ranging/wifi/rtt/RttRangingParams.java
new file mode 100644
index 00000000..8c2aa4b7
--- /dev/null
+++ b/ranging/framework/java/android/ranging/wifi/rtt/RttRangingParams.java
@@ -0,0 +1,229 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging.wifi.rtt;
+
+import android.annotation.FlaggedApi;
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.ranging.raw.RawRangingDevice;
+import android.ranging.raw.RawRangingDevice.RangingUpdateRate;
+
+import com.android.ranging.flags.Flags;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Objects;
+
+/**
+ * Represents the parameters required to perform Wi-Fi Round Trip Time (RTT) ranging.
+ *
+ */
+@FlaggedApi(Flags.FLAG_RANGING_RTT_ENABLED)
+public final class RttRangingParams implements Parcelable {
+
+    private RttRangingParams(Parcel in) {
+        mServiceName = in.readString();
+        mMatchFilter = in.createByteArray();
+        mRangingUpdateRate = in.readInt();
+        mPeriodicRangingHwFeatureEnabled = in.readBoolean();
+    }
+
+    @NonNull
+    public static final Creator<RttRangingParams> CREATOR = new Creator<RttRangingParams>() {
+        @Override
+        public RttRangingParams createFromParcel(Parcel in) {
+            return new RttRangingParams(in);
+        }
+
+        @Override
+        public RttRangingParams[] newArray(int size) {
+            return new RttRangingParams[size];
+        }
+    };
+
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    @Override
+    public void writeToParcel(@NonNull Parcel dest, int flags) {
+        dest.writeString(mServiceName);
+        dest.writeByteArray(mMatchFilter);
+        dest.writeInt(mRangingUpdateRate);
+        dest.writeBoolean(mPeriodicRangingHwFeatureEnabled);
+    }
+
+    private final String mServiceName;
+
+    private final byte[] mMatchFilter;
+
+    @RangingUpdateRate
+    private final int mRangingUpdateRate;
+
+    private final boolean mPeriodicRangingHwFeatureEnabled;
+
+    /**
+     * Returns the service name associated with this RTT ranging session.
+     *
+     * @return the service name as a {@link String}.
+     * @see android.net.wifi.aware.PublishConfig.Builder#setServiceName(String)
+     * @see android.net.wifi.aware.SubscribeConfig.Builder#setServiceName(String)
+     */
+    @NonNull
+    public String getServiceName() {
+        return mServiceName;
+    }
+
+    /**
+     * Returns the match filter for this ranging session.
+     *
+     * @return a byte array representing the match filter.
+     * @see android.net.wifi.aware.PublishConfig.Builder#setMatchFilter(List)
+     * @see android.net.wifi.aware.SubscribeConfig.Builder#setMatchFilter(List)
+     */
+    @Nullable
+    public byte[] getMatchFilter() {
+        return mMatchFilter;
+    }
+
+    /**
+     * Returns the ranging update rate.
+     *
+     * @return ranging update rate.
+     * <p>Possible values:
+     * {@link RangingUpdateRate#UPDATE_RATE_NORMAL}
+     * {@link RangingUpdateRate#UPDATE_RATE_INFREQUENT}
+     * {@link RangingUpdateRate#UPDATE_RATE_FREQUENT}
+     */
+    @RangingUpdateRate
+    public int getRangingUpdateRate() {
+        return mRangingUpdateRate;
+    }
+
+    /**
+     * Returns whether the periodic ranging hardware feature was enabled.
+     *
+     * @return returns {@code true} if periodic ranging hardware feature was enabled, {@code false}
+     * otherwise
+     */
+    public boolean isPeriodicRangingHwFeatureEnabled() {
+        return mPeriodicRangingHwFeatureEnabled;
+    }
+
+    private RttRangingParams(Builder builder) {
+        mServiceName = builder.mServiceName;
+        mMatchFilter = builder.mMatchFilter;
+        mRangingUpdateRate = builder.mRangingUpdateRate;
+        mPeriodicRangingHwFeatureEnabled = builder.mPeriodicRangingHwFeatureEnabled;
+    }
+
+    /**
+     * Builder class for {@link RttRangingParams}.
+     */
+    public static final class Builder {
+        private String mServiceName = "";
+
+        private byte[] mMatchFilter = null;
+
+        private boolean mPeriodicRangingHwFeatureEnabled = false;
+        @RawRangingDevice.RangingUpdateRate
+        private int mRangingUpdateRate = RawRangingDevice.UPDATE_RATE_NORMAL;
+
+        /**
+         * Constructs a new {@link Builder} for creating a Wifi NAN-RTT ranging session.
+         *
+         * @param serviceName The service name associated with this session
+         * @throws IllegalArgumentException if {@code serviceName} is null.
+         */
+        public Builder(@NonNull String serviceName) {
+            Objects.requireNonNull(serviceName);
+            mServiceName = serviceName;
+        }
+
+        /**
+         * Sets the match filter to identify specific devices or services for RTT.
+         *
+         * @param matchFilter a byte array representing the filter.
+         *
+         * @return this {@link Builder} instance.
+         * @throws NullPointerException if either parameter is {@code matchFilter} is null.
+         */
+        @NonNull
+        public Builder setMatchFilter(@NonNull byte[] matchFilter) {
+            Objects.requireNonNull(matchFilter);
+            this.mMatchFilter = matchFilter.clone();
+            return this;
+        }
+
+        /**
+         * Sets the update rate for the RTT ranging session.
+         * <p>Defaults to {@link RangingUpdateRate#UPDATE_RATE_NORMAL}
+         *
+         * @param updateRate the reporting frequency.
+         *                   <p>Possible values:
+         *                   {@link RangingUpdateRate#UPDATE_RATE_NORMAL}
+         *                   {@link RangingUpdateRate#UPDATE_RATE_INFREQUENT}
+         *                   {@link RangingUpdateRate#UPDATE_RATE_FREQUENT}
+         * @return this {@link Builder} instance.
+         */
+        @NonNull
+        public Builder setRangingUpdateRate(@RawRangingDevice.RangingUpdateRate int updateRate) {
+            mRangingUpdateRate = updateRate;
+            return this;
+        }
+
+        /**
+         * Sets whether to use hardware supported periodic ranging feature in WiFi Nan-RTT.
+         *
+         * @param periodicRangingHwFeatureEnabled {@code true} to enable periodic ranging;
+         *                                        {@code false} otherwise.
+         * @return this {@link Builder} instance.
+         */
+        @NonNull
+        public Builder setPeriodicRangingHwFeatureEnabled(boolean periodicRangingHwFeatureEnabled) {
+            mPeriodicRangingHwFeatureEnabled = periodicRangingHwFeatureEnabled;
+            return this;
+        }
+
+        /**
+         * Builds and returns a new {@link RttRangingParams} instance.
+         *
+         * @return a new {@link RttRangingParams} object configured with the provided parameters.
+         */
+        @NonNull
+        public RttRangingParams build() {
+            return new RttRangingParams(this);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "RttRangingParams{ "
+                + "mServiceName='"
+                + mServiceName
+                + ", mMatchFilter="
+                + Arrays.toString(mMatchFilter)
+                + ", mRangingUpdateRate="
+                + mRangingUpdateRate
+                + ", mPeriodicRangingHwFeatureEnabled="
+                + mPeriodicRangingHwFeatureEnabled
+                + " }";
+    }
+}
diff --git a/generic_ranging/Android.bp b/ranging/rtt_backend/Android.bp
similarity index 72%
rename from generic_ranging/Android.bp
rename to ranging/rtt_backend/Android.bp
index 0d6663d2..0bf557bf 100644
--- a/generic_ranging/Android.bp
+++ b/ranging/rtt_backend/Android.bp
@@ -18,32 +18,26 @@ package {
 }
 
 java_library {
-    name: "generic_ranging",
+    name: "ranging_rtt_backend",
     sdk_version: "system_UpsideDownCake",
-    min_sdk_version: "34",
+    min_sdk_version: "33",
     installable: false,
     srcs: [
         "src/**/*.java",
     ],
-    plugins: [
-        "auto_value_plugin",
-    ],
-    libs: [
-        "auto_value_annotations",
-        "error_prone_annotations",
-    ],
+    //libs: ["android-support-annotations"],
     static_libs: [
         "androidx.annotation_annotation",
         "androidx.concurrent_concurrent-futures",
-        "androidx.concurrent_concurrent-futures",
-        "dagger2",
-        "framework-annotations-lib",
         "guava",
-        "multi-sensor-finder-configuration-java-proto",
-        "com.uwb.fusion",
-        "ranging_uwb_backend",
+    ],
+    apex_available: [
+        "com.android.uwb",
+        "com.android.tethering",
+        "//apex_available:platform",
     ],
     visibility: [
         ":__subpackages__",
+        "//packages/modules/Uwb/ranging:__subpackages__",
     ],
 }
diff --git a/ranging/rtt_backend/AndroidManifest.xml b/ranging/rtt_backend/AndroidManifest.xml
new file mode 100644
index 00000000..9ea448d2
--- /dev/null
+++ b/ranging/rtt_backend/AndroidManifest.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="utf-8"?>
+<manifest
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.android.ranging.rtt.backend">
+
+<uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
+<uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
+<!-- If your app targets Android 13 (API level 33) or higher, you must declare the NEARBY_WIFI_DEVICES permission. -->
+<uses-permission android:name="android.permission.NEARBY_WIFI_DEVICES" android:usesPermissionFlags="neverForLocation" />
+<!-- If your app derives location information from Wi-Fi APIs, don't include the "usesPermissionFlags" attribute. -->
+<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" android:maxSdkVersion="32" />
+<!-- If any feature in your app relies on precise location information, don't include the "maxSdkVersion" attribute. -->
+
+  <application
+         android:persistent="true"
+         android:directBootAware="true"
+         android:defaultToDeviceProtectedStorage="true">
+      <!--
+    <service android:name=".impl.RttService"
+            android:exported="true"
+            android:process=":remote">
+        <intent-filter>
+          <action android:name="com.android.ranging.rtt.backend"></action>
+        </intent-filter>
+    </service>
+    -->
+  </application>
+</manifest>
diff --git a/ranging/rtt_backend/com.android.ranging.rtt.backend.xml b/ranging/rtt_backend/com.android.ranging.rtt.backend.xml
new file mode 100644
index 00000000..b08e7a42
--- /dev/null
+++ b/ranging/rtt_backend/com.android.ranging.rtt.backend.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License
+  -->
+<permissions>
+    <privapp-permissions package="com.android.ranging.rtt.backend">
+        <permission name="android.permission.RTT_PRIVILEGED"/>
+        <permission name="android.permission.RTT_RANGING"/>
+    </privapp-permissions>
+</permissions>
+
diff --git a/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttDevice.java b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttDevice.java
new file mode 100644
index 00000000..f698bdcf
--- /dev/null
+++ b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttDevice.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rtt.backend.internal;
+
+/*
+ * Represents a RTT device.
+ */
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+
+import androidx.annotation.NonNull;
+
+import java.util.Arrays;
+
+public class RttDevice {
+
+    private final RttRangingDevice mRttRangingDevice;
+    private RttAddress mAddress;
+
+    /**
+     * Ranging Device for Wifi RTT
+     *
+     * @param rttRangingDevice RttRangingDevices
+     */
+    public RttDevice(RttRangingDevice rttRangingDevice) {
+        mRttRangingDevice = rttRangingDevice;
+        mAddress = new RttAddress(new byte[]{});
+    }
+
+    public RttAddress getAddress() {
+        return mAddress;
+    }
+
+    public void setAddress(String addressStr) {
+        mAddress = new RttAddress(addressStr);
+    }
+
+    @Override
+    public int hashCode() {
+        return Arrays.hashCode(mAddress.toBytes());
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (!(obj instanceof RttDevice device)) {
+            return false;
+        }
+        return Arrays.equals(mAddress.toBytes(), device.mAddress.toBytes());
+    }
+
+    /**
+     * Represents a RTT address.
+     */
+    public static class RttAddress {
+        byte[] mAddress;
+
+        /**
+         * Creates a RttAddress from a HEX string.
+         */
+        public RttAddress(@NonNull String address) {
+            this.mAddress = address.getBytes(UTF_8);
+        }
+
+        /**
+         * Creates a RttAddress from a byte array.
+         */
+        public RttAddress(@NonNull byte[] address) {
+            this.mAddress = address;
+        }
+
+        public byte[] toBytes() {
+            return mAddress;
+        }
+
+        /**
+         * Gets the device address (eg, MAC address).
+         *
+         * @return RTT address
+         */
+        public byte[] getAddress() {
+            return mAddress;
+        }
+    }
+}
diff --git a/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRanger.java b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRanger.java
new file mode 100644
index 00000000..55598751
--- /dev/null
+++ b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRanger.java
@@ -0,0 +1,139 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.ranging.rtt.backend.internal;
+
+import android.net.wifi.aware.PeerHandle;
+import android.net.wifi.rtt.RangingRequest;
+import android.net.wifi.rtt.RangingResult;
+import android.net.wifi.rtt.RangingResultCallback;
+import android.net.wifi.rtt.WifiRttManager;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+
+import java.util.List;
+import java.util.concurrent.Executor;
+
+/** Ranges to a given WiFi Aware Peer handle. */
+public class RttRanger {
+    private static final String TAG = RttRanger.class.getName();
+
+    private final WifiRttManager mWifiRttManager;
+    private final Executor mExecutor;
+
+    private RttRangerListener mRttRangerListener;
+    private PeerHandle mPeerHandle;
+
+    private boolean mIsRunning;
+
+    public RttRanger(WifiRttManager wiFiRttManager, Executor executor) {
+        this.mExecutor = executor;
+        this.mWifiRttManager = wiFiRttManager;
+    }
+
+    public void startRanging(@NonNull PeerHandle peerHandle,
+            @NonNull RttRangerListener rttRangerListener) {
+        if (mIsRunning) {
+            Log.w(TAG, "startRanging - already running");
+            return;
+        }
+        mIsRunning = true;
+        this.mPeerHandle = peerHandle;
+        this.mRttRangerListener = rttRangerListener;
+        startRangingInternal();
+    }
+
+    private void startRangingInternal() {
+        if (!mWifiRttManager.isAvailable()) {
+            Log.w(TAG, "WifiRttManager is not available");
+            stopRanging();
+            mRttRangerListener.onRangingFailure(
+                    RttRangerListener.STATUS_CODE_FAIL_RTT_NOT_AVAILABLE);
+            return;
+        }
+        mWifiRttManager.startRanging(
+                new RangingRequest.Builder().addWifiAwarePeer(mPeerHandle).build(),
+                mExecutor,
+                mRangingResultCallback);
+    }
+
+    public void stopRanging() {
+        mIsRunning = false;
+    }
+
+    private final RangingResultCallback mRangingResultCallback = new RangingResultCallback() {
+        @Override
+        public void onRangingFailure(int code) {
+            Log.w(TAG, "RTT ranging failed: " + code);
+            mRttRangerListener.onRangingFailure(code);
+        }
+
+        @Override
+        public void onRangingResults(List<RangingResult> results) {
+            if (results == null) {
+                Log.w(TAG, "Rtt Ranging result is null");
+                return;
+            }
+            Log.i(TAG, "RTT ranging results: " + results);
+            if (mRttRangerListener == null) {
+                Log.w(TAG, "Rtt Ranging Listener is null");
+                return;
+            }
+
+            if (results.isEmpty()) {
+                mRttRangerListener.onRangingFailure(
+                        RttRangerListener.STATUS_CODE_FAIL_RESULT_EMPTY);
+                return;
+            }
+
+            RangingResult result = results.get(0);
+            int status = result.getStatus();
+
+            if (status == RangingResult.STATUS_RESPONDER_DOES_NOT_SUPPORT_IEEE80211MC) {
+                Log.w(TAG, "Responder does not support 11mc");
+                mRttRangerListener.onRangingFailure(
+                        RttRangerListener.STATUS_CODE_FAIL_RTT_NOT_AVAILABLE);
+                return;
+            } else if (status == RangingResult.UNSPECIFIED) {
+                Log.w(TAG, "Unspecified failed.");
+                mRttRangerListener.onRangingFailure(
+                        RttRangerListener.STATUS_CODE_FAIL_RTT_NOT_AVAILABLE);
+                return;
+            } else if (status == RangingResult.STATUS_FAIL) {
+                mRttRangerListener.onRangingFailure(
+                        RttRangerListener.STATUS_CODE_FAIL_RESULT_FAIL);
+            } else if (status == RangingResult.STATUS_SUCCESS) {
+                mRttRangerListener.onRangingResult(result);
+            }
+
+            if (mIsRunning) {
+                startRangingInternal();
+            }
+        }
+    };
+
+    /** Listener for range results. */
+    public interface RttRangerListener {
+        int STATUS_CODE_FAIL = 1;
+        int STATUS_CODE_FAIL_RTT_NOT_AVAILABLE = 2;
+        int STATUS_CODE_FAIL_RESULT_EMPTY = 3;
+        int STATUS_CODE_FAIL_RESULT_FAIL = 4;
+
+        void onRangingFailure(int code);
+
+        void onRangingResult(RangingResult results);
+    }
+}
diff --git a/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRangingDevice.java b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRangingDevice.java
new file mode 100644
index 00000000..339174f0
--- /dev/null
+++ b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRangingDevice.java
@@ -0,0 +1,372 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rtt.backend.internal;
+
+import static com.android.ranging.rtt.backend.internal.RttRangingSessionCallback.REASON_STOP_RANGING_CALLED;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+
+import android.content.Context;
+import android.net.wifi.aware.AttachCallback;
+import android.net.wifi.aware.DiscoverySessionCallback;
+import android.net.wifi.aware.PeerHandle;
+import android.net.wifi.aware.PublishConfig;
+import android.net.wifi.aware.PublishDiscoverySession;
+import android.net.wifi.aware.SubscribeConfig;
+import android.net.wifi.aware.SubscribeDiscoverySession;
+import android.net.wifi.aware.WifiAwareManager;
+import android.net.wifi.aware.WifiAwareSession;
+import android.net.wifi.rtt.RangingResult;
+import android.net.wifi.rtt.WifiRttManager;
+import android.os.Build;
+import android.os.Handler;
+import android.os.Looper;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+
+import com.android.ranging.rtt.backend.internal.RttRanger.RttRangerListener;
+
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+
+/**
+ * Class for interacting with nearby RTT devices to perform ranging.
+ */
+public class RttRangingDevice {
+    private static final String TAG = RttRangingDevice.class.getName();
+    private static final int GRAPI_RTT_MESSAGE_ID = 1;
+    private final Handler mHandler;
+    private final WifiAwareManager mWifiAwareManager;
+    private WifiAwareSession mWifiAwareSession;
+    private RttRangingSessionCallback mRttListener = null;
+    private PublishDiscoverySession mCurrentPublishDiscoverySession = null;
+    private SubscribeDiscoverySession mCurrentSubscribeDiscoverySession = null;
+    private final Context mContext;
+    private final DeviceType mDeviceType;
+    private RttRangingParameters mRttRangingParameters = null;
+    private PeerHandle mPeerHandle = null;
+    private final RttDevice mRttDevice;
+    private final RttRanger mRttRanger;
+    private String mPeerName = null;
+    private boolean mIsRunning;
+    private final Object mLock = new Object();
+    private final WifiRttManager mWifiRttManager;
+
+    /** Listener for range results. */
+    private RttRangerListener mRttRangingListener = new RttRangerListener() {
+        @Override
+        public void onRangingFailure(int code) {
+            switch (code) {
+                case STATUS_CODE_FAIL:
+                    Log.w(TAG, "Failed to range");
+                    break;
+
+                case STATUS_CODE_FAIL_RESULT_EMPTY:
+                    Log.i(TAG, "Range results are empty");
+                    synchronized (mLock) {
+//                        if (mRttListener != null) {
+//                            mRttListener.onRangingSuspended(mRttDevice,
+//                                    RttRangingSessionCallback.REASON_RTT_NOT_AVAILABLE);
+//                        }
+                        stopRanging();
+                    }
+                    break;
+                case STATUS_CODE_FAIL_RTT_NOT_AVAILABLE:
+                    Log.w(TAG, "RTT Not Available");
+                    synchronized (mLock) {
+//                        if (mRttListener != null) {
+//                            mRttListener.onRangingSuspended(mRttDevice,
+//                                    RttRangingSessionCallback.REASON_RTT_NOT_AVAILABLE);
+//                        }
+                        stopRanging();
+                    }
+                    break;
+            }
+        }
+
+        @Override
+        public void onRangingResult(RangingResult result) {
+            if (!mIsRunning) {
+                Log.w(TAG, "onRangingResult - ranging has stopped already.");
+                stopRanging();
+                return;
+            }
+
+            PeerHandle peerHandle = result.getPeerHandle();
+            if (mPeerHandle.equals(peerHandle)) {
+                synchronized (mLock) {
+                    if (mRttListener != null) {
+                        mRttListener.onRangingResult(mRttDevice, new RttRangingPosition(result));
+                    }
+                }
+                Log.i(TAG, "callback onRangingResult");
+            } else {
+                Log.i(TAG, "Received PeerHandle is unknown. lastPeerHandle = " + mPeerHandle
+                        + ", gotPeerHandle = " + peerHandle);
+            }
+        }
+    };
+
+    private Runnable mRunnablePingPublisher = new Runnable() {
+        @Override
+        public void run() {
+            synchronized (mLock) {
+                if (!mIsRunning) {
+                    Log.w(TAG, "RttRangingDevice is not running");
+                    return;
+                }
+                if (mRttListener != null) {
+                    mRttListener.onRangingResult(mRttDevice, new RttRangingPosition());
+                }
+                pingPublisher();
+            }
+        }
+    };
+
+    public RttRangingDevice(@NonNull Context context, @NonNull DeviceType deviceType) {
+        mContext = context;
+        mDeviceType = deviceType;
+
+        mHandler = new Handler(Looper.getMainLooper());
+        mWifiAwareManager = context.getSystemService(WifiAwareManager.class);
+        mWifiRttManager = context.getSystemService(WifiRttManager.class);
+        mRttRanger = new RttRanger(mWifiRttManager, mHandler::post);
+        mRttDevice = new RttDevice(this);
+        mIsRunning = false;
+    }
+
+    public void setRangingParameters(@NonNull RttRangingParameters rttRangingParameters) {
+        this.mRttRangingParameters = rttRangingParameters;
+    }
+
+    public void startRanging(@NonNull RttRangingSessionCallback rttListener,
+            ExecutorService executorService) {
+        Log.i(TAG, "Start ranging");
+
+        if (mRttRangingParameters == null) {
+            Log.w(TAG, "Tried to start ranging but no ranging parameters have been provided");
+            return;
+        }
+        if (!mWifiAwareManager.isAvailable()) {
+            Log.w(TAG, "Wifi Aware Manager is not available");
+            return;
+        }
+
+        synchronized (mLock) {
+            if (mIsRunning) {
+                Log.w(TAG, "This client is already running.");
+                return;
+            }
+            mIsRunning = true;
+            mRttListener = rttListener;
+            mWifiAwareManager.attach(new AwareAttachCallback(mDeviceType, mRttRangingParameters),
+                    mHandler);
+        }
+    }
+
+    public void stopRanging() {
+        Log.i(TAG, "Closing WiFi aware session");
+
+        synchronized (mLock) {
+            if (!mIsRunning) {
+                Log.w(TAG, "This client has stopped ranging already");
+                return;
+            }
+            mIsRunning = false;
+            mRttRanger.stopRanging();
+            mHandler.removeCallbacks(mRunnablePingPublisher);
+
+            if (mWifiAwareSession != null) {
+                mWifiAwareSession.close();
+                mWifiAwareSession = null;
+            }
+            mCurrentPublishDiscoverySession = null;
+            mCurrentSubscribeDiscoverySession = null;
+        }
+
+    }
+
+    private void notifyPeer(PeerHandle peerHandle, byte[] message) {
+        if (mCurrentPublishDiscoverySession != null) {
+            mCurrentPublishDiscoverySession.sendMessage(peerHandle, GRAPI_RTT_MESSAGE_ID, message);
+        } else if (mCurrentSubscribeDiscoverySession != null) {
+            mCurrentSubscribeDiscoverySession.sendMessage(peerHandle, GRAPI_RTT_MESSAGE_ID,
+                    message);
+        }
+    }
+
+    private void pingPublisher() {
+//        Log.i(TAG, "Publisher ping");
+//        mHandler.postDelayed(mRunnablePingPublisher,
+//                mRttRangingParameters.getPublisherPingDuration().toMillis());
+    }
+
+    private DiscoverySessionCallback createPublishDiscoverySessionCallback() {
+        return new DiscoverySessionCallback() {
+            @Override
+            public void onPublishStarted(PublishDiscoverySession session) {
+                Log.i(TAG, "onPublishStarted, PublishDiscoverySession= " + session);
+                mCurrentPublishDiscoverySession = session;
+                if (mRttListener != null) {
+                    mRttListener.onRangingInitialized(mRttDevice);
+                }
+            }
+
+            @Override
+            public void onMessageReceived(PeerHandle peerHandle, byte[] message) {
+                Log.i(TAG, "onMessageReceived from subscriber");
+                // Received message from subscriber and send device name
+                mPeerName = new String(message, UTF_8);
+                notifyPeer(peerHandle, Build.MODEL.getBytes(UTF_8));
+
+                if (mPeerHandle == null) {
+                    mPeerHandle = peerHandle; // Initialize mPeerHandle at publisher side.
+                }
+
+                if (mRttRangingParameters.getEnablePublisherRanging()) {
+                    mRttListener.onRangingInitialized(mRttDevice);
+                    mRttRanger.startRanging(peerHandle, mRttRangingListener);
+                } else {
+                    pingPublisher();
+                }
+            }
+
+            @Override
+            public void onSessionTerminated() {
+                Log.i(TAG, "onSession Terminated. ");
+                // TODO: Check whether we can get the reason code.
+                mRttListener.onRangingSuspended(mRttDevice, REASON_STOP_RANGING_CALLED);
+                mRttListener = null;
+            }
+        };
+    }
+
+    private DiscoverySessionCallback createSubscribeDiscoverySessionCallback() {
+        return new DiscoverySessionCallback() {
+
+            @Override
+            public void onSubscribeStarted(SubscribeDiscoverySession session) {
+                Log.i(TAG, "onSubscribeStarted, SubscribeDiscoverySession= " + session);
+                mCurrentSubscribeDiscoverySession = session;
+                if (mRttListener != null) {
+                    mRttListener.onRangingInitialized(mRttDevice);
+                }
+            }
+
+            @Override
+            public void onMessageReceived(PeerHandle peerHandle, byte[] message) {
+                Log.i(TAG, "onMessageReceived from publisher");
+                mPeerName = new String(message, UTF_8);
+            }
+
+            @Override
+            public void onServiceDiscoveredWithinRange(
+                    PeerHandle peerHandle,
+                    byte[] serviceSpecificInfo,
+                    List<byte[]> matchFilter,
+                    int distanceMm) {
+                Log.i(TAG,
+                        "onServiceDiscovered, peerHandle= " + peerHandle + ", initial distanceMm= "
+                                + distanceMm);
+
+                mPeerHandle = peerHandle;
+                notifyPeer(peerHandle, Build.MODEL.getBytes(UTF_8));
+
+                if (mRttListener != null) {
+                    mRttListener.onRangingInitialized(mRttDevice);
+                    mRttRanger.startRanging(peerHandle, mRttRangingListener);
+                } else {
+                    Log.e(TAG, "Rtt Listener is null");
+                }
+            }
+
+            @Override
+            public void onSessionTerminated() {
+                Log.i(TAG, "onSession Terminated. ");
+                // TODO: Check whether we can get the reason code.
+                mRttListener.onRangingSuspended(mRttDevice, REASON_STOP_RANGING_CALLED);
+                mRttListener = null;
+            }
+        };
+    }
+
+    private class AwareAttachCallback extends AttachCallback {
+        private final PublishConfig mPublishConfig;
+        private final SubscribeConfig mSubscribeConfig;
+
+        private final DeviceType mDeviceType;
+
+        AwareAttachCallback(DeviceType deviceType,
+                RttRangingParameters rttRangingParameters) {
+            mDeviceType = deviceType;
+
+            if (deviceType == DeviceType.PUBLISHER) {
+                mPublishConfig = new PublishConfig.Builder()
+                        .setMatchFilter(
+                                Collections.singletonList(rttRangingParameters.getMatchFilter()))
+                        .setServiceName(rttRangingParameters.getServiceName())
+                        .setRangingEnabled(true)
+                        .setTerminateNotificationEnabled(true)
+                        .build();
+                mSubscribeConfig = null;
+            } else if (deviceType == DeviceType.SUBSCRIBER) {
+                mSubscribeConfig = new SubscribeConfig.Builder()
+                        .setMatchFilter(
+                                Collections.singletonList(rttRangingParameters.getMatchFilter()))
+                        .setServiceName(rttRangingParameters.getServiceName())
+                        .setMaxDistanceMm(rttRangingParameters.getMaxDistanceMm())
+                        .setMinDistanceMm(rttRangingParameters.getMinDistanceMm())
+                        .setTerminateNotificationEnabled(true)
+                        .build();
+                mPublishConfig = null;
+            } else {
+                Log.w(TAG, "Unknown deviceType");
+                mPublishConfig = null;
+                mSubscribeConfig = null;
+            }
+        }
+
+        @Override
+        public void onAttached(WifiAwareSession session) {
+            Log.i(TAG, "onAttached, session = " + session);
+            mWifiAwareSession = session;
+            if (mDeviceType == DeviceType.PUBLISHER) {
+                session.publish(mPublishConfig, createPublishDiscoverySessionCallback(), mHandler);
+            } else if (mDeviceType == DeviceType.SUBSCRIBER) {
+                session.subscribe(mSubscribeConfig, createSubscribeDiscoverySessionCallback(),
+                        mHandler);
+            }
+        }
+
+        @Override
+        public void onAttachFailed() {
+            Log.w(TAG, "Wifi Aware attach failed");
+            if (mRttListener != null) {
+                mRttListener.onRangingSuspended(mRttDevice,
+                        RttRangingSessionCallback.REASON_FAILED_TO_START);
+            }
+            stopRanging();
+        }
+    }
+
+    public enum DeviceType {
+        PUBLISHER,
+        SUBSCRIBER,
+    }
+}
diff --git a/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRangingParameters.java b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRangingParameters.java
new file mode 100644
index 00000000..9e5ba561
--- /dev/null
+++ b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRangingParameters.java
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rtt.backend.internal;
+
+import androidx.annotation.IntDef;
+import androidx.annotation.NonNull;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.time.Duration;
+import java.util.Arrays;
+
+public class RttRangingParameters {
+
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef({
+            DeviceRole.PUBLISHER,
+            DeviceRole.SUBSCRIBER,
+    })
+    public @interface DeviceRole {
+        int PUBLISHER = 0;
+        int SUBSCRIBER = 1;
+    }
+
+    private final @DeviceRole int mDeviceRole;
+    /**
+     * Returns Service ID for WiFi Aware
+     */
+    protected final byte mServiceId;
+    protected final byte[] mMatchFilter;
+    protected final String mServiceName;
+    protected final int mMaxDistanceMm;
+    protected final int mMinDistanceMm;
+    protected final boolean mEnablePublisherRanging;
+    protected final Duration mPublisherPingDuration;
+
+    public int getDeviceRole() {
+        return mDeviceRole;
+    }
+
+    /**
+     * get Service ID of the RTT session
+     *
+     * @return Service ID of the RTT session
+     */
+    public byte getServiceId() {
+        return mServiceId;
+    }
+
+    /**
+     * get Service name of the RTT session
+     *
+     * @return Service name of the RTT session
+     */
+    public String getServiceName() {
+        return mServiceName;
+    }
+
+    /**
+     * get Match filter bytes of the RTT session
+     *
+     * @return Match filter bytes of the RTT session
+     */
+    public byte[] getMatchFilter() {
+        return mMatchFilter;
+    }
+
+    /**
+     * get Max Distance limit of the RTT session(Unit : mm)
+     *
+     * @return Max Distance limit of the RTT session(Unit : mm)
+     */
+    public int getMaxDistanceMm() {
+        return mMaxDistanceMm;
+    }
+
+    /**
+     * get Min Distance limit of the RTT session(Unit : mm)
+     *
+     * @return Min Distance limit of the RTT session(Unit : mm)
+     */
+    public int getMinDistanceMm() {
+        return mMinDistanceMm;
+    }
+
+    /**
+     * If it is a publisher type, get whether a publisher will range.
+     *
+     * @return whether a publisher will range.
+     */
+    public boolean getEnablePublisherRanging() {
+        return mEnablePublisherRanging;
+    }
+
+    /**
+     * If it is a publisher type, get whether to return a empty ping value by itself to maintain
+     * connection.
+     *
+     * @return whether to return a empty ping value by itself to maintain connection.
+     */
+    public Duration getPublisherPingDuration() {
+        return mPublisherPingDuration;
+    }
+
+    public RttRangingParameters(Builder builder) {
+        mDeviceRole = builder.mDeviceRole;
+        mServiceId = builder.mServiceId;
+        mServiceName = builder.mServiceName;
+        mMatchFilter = builder.mMatchFilter;
+        mMaxDistanceMm = builder.mMaxDistanceMm;
+        mMinDistanceMm = builder.mMinDistanceMm;
+        mEnablePublisherRanging = builder.mEnablePublisherRanging;
+        mPublisherPingDuration = builder.mPublisherPingDuration;
+    }
+
+
+    /**
+     * Returns a builder for {@link com.android.ranging.generic.ranging.rtt.RttRangingParameters}.
+     */
+    public static class Builder {
+        protected @DeviceRole int mDeviceRole = DeviceRole.PUBLISHER;
+        protected byte mServiceId = 0;
+        protected String mServiceName = "";
+        protected byte[] mMatchFilter = new byte[]{};
+        protected int mMaxDistanceMm = 30 * 100 * 100;
+        protected int mMinDistanceMm = 0;
+        protected boolean mEnablePublisherRanging = false;
+        protected Duration mPublisherPingDuration = Duration.ofSeconds(10);
+
+        public Builder setDeviceRole(int deviceRole) {
+            mDeviceRole = deviceRole;
+            return this;
+        }
+
+        /** Set the service ID that produced this data */
+        public Builder setServiceId(byte serviceId) {
+            mServiceId = serviceId;
+            return this;
+        }
+
+        public Builder setServiceName(String serviceName) {
+            mServiceName = serviceName;
+            return this;
+        }
+
+        public Builder setMaxDistanceMm(int maxDistanceMm) {
+            mMaxDistanceMm = maxDistanceMm;
+            return this;
+        }
+
+        public Builder setMinDistanceMm(int minDistanceMm) {
+            mMinDistanceMm = minDistanceMm;
+            return this;
+        }
+
+        public Builder setEnablePublisherRanging(boolean enablePublisherRanging) {
+            mEnablePublisherRanging = enablePublisherRanging;
+            return this;
+        }
+
+        public Builder setPublisherPingDuration(@NonNull Duration ping) {
+            mPublisherPingDuration = ping;
+            return this;
+        }
+
+        public Builder setMatchFilter(byte[] matchFilter) {
+            mMatchFilter = matchFilter;
+            return this;
+        }
+
+        public RttRangingParameters build() {
+            return new RttRangingParameters(this);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "RttRangingParameters{ "
+                + "deviceRole: "
+                + mDeviceRole
+                + ", serviceId: "
+                + mServiceId
+                + ", serviceName: "
+                + mServiceName
+                + ", matchFilter: "
+                + Arrays.toString(mMatchFilter)
+                + ", maxDistanceMm: "
+                + mMaxDistanceMm
+                + ", minDistanceMm: "
+                + mMinDistanceMm
+                + ", enablePublisherRanging: "
+                + mEnablePublisherRanging
+                + ", publisherPingDuration: "
+                + mPublisherPingDuration
+                + " }";
+    }
+}
diff --git a/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRangingPosition.java b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRangingPosition.java
new file mode 100644
index 00000000..4bc01a29
--- /dev/null
+++ b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRangingPosition.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rtt.backend.internal;
+
+import android.net.MacAddress;
+import android.net.wifi.aware.PeerHandle;
+import android.net.wifi.rtt.RangingResult;
+import android.net.wifi.rtt.ResponderLocation;
+import android.os.Build;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+
+/**
+ * This class is transform class of RangingResult to fit with RttAdapter.
+ */
+public class RttRangingPosition {
+    private static final String TAG = RttRangingPosition.class.getName();
+
+    private int mDistanceMm;
+    private int mDistanceStdDevMm;
+    private byte[] mLci;
+    private byte[] mLcr;
+    private MacAddress mMacAddress;
+    //    private long mMaxTimeBetweenNtbMeasurementsMicros;
+    private int mMeasurementBandwidth;
+    private int mMeasurementChannelFrequencyMHz;
+    //    private long mMinTimeBetweenNtbMeasurementsMicros;
+    private int mNumAttemptedMeasurements;
+    private int mNumSuccessfulMeasurements;
+    private PeerHandle mPeerHandle;
+    private long mRangingTimestampMillis;
+    private int mRssi;
+    private int mStatus;
+    private ResponderLocation mUnverifiedResponderLocation;
+    boolean mIs80211azNtbMeasurement;
+    boolean mIs80211mcMeasurement;
+
+    Azimuth mAzimuth;
+    Elevation mElevation;
+
+
+    /**
+     * Create empty Ranging Position for RTT.
+     */
+    public RttRangingPosition() {
+        mDistanceMm = 0;
+        mDistanceStdDevMm = 0;
+        mLci = null;
+        mLcr = null;
+        mMacAddress = null;
+        mMeasurementBandwidth = 0;
+        mMeasurementChannelFrequencyMHz = 0;
+        mNumAttemptedMeasurements = 0;
+        mNumSuccessfulMeasurements = 0;
+        mPeerHandle = null;
+        mAzimuth = null;
+        mElevation = null;
+        mRangingTimestampMillis = System.currentTimeMillis();
+    }
+
+    /**
+     * Create Ranging Position for RTT from RangingResult
+     */
+    public RttRangingPosition(@NonNull RangingResult rangingResult) {
+        mDistanceMm = rangingResult.getDistanceMm();
+        mDistanceStdDevMm = rangingResult.getDistanceStdDevMm();
+        mLci = rangingResult.getLci();
+        mLcr = rangingResult.getLcr();
+        mMacAddress = rangingResult.getMacAddress();
+//        mMaxTimeBetweenNtbMeasurementsMicros = rangingResult
+//        .getMaxTimeBetweenNtbMeasurementsMicros();
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
+            mMeasurementBandwidth = rangingResult.getMeasurementBandwidth();
+            mMeasurementChannelFrequencyMHz = rangingResult.getMeasurementChannelFrequencyMHz();
+        }
+//        mMinTimeBetweenNtbMeasurementsMicros = rangingResult
+//        .getMinTimeBetweenNtbMeasurementsMicros();
+        mNumAttemptedMeasurements = rangingResult.getNumAttemptedMeasurements();
+        mNumSuccessfulMeasurements = rangingResult.getNumSuccessfulMeasurements();
+        mPeerHandle = rangingResult.getPeerHandle();
+        mAzimuth = null;
+        mElevation = null;
+        mRangingTimestampMillis = rangingResult.getRangingTimestampMillis();
+
+    }
+
+    /**
+     * get Distamce(Unit : mm)
+     */
+    public double getDistance() {
+        return mDistanceMm;
+    }
+
+    /**
+     * get Rssi Dbm
+     */
+    public int getRssiDbm() {
+        return mRssi;
+    }
+
+    /**
+     * get Ranging Time stamp(Unit : ms)
+     */
+    public long getRangingTimestampMillis() {
+        return mRangingTimestampMillis;
+    }
+
+    // WiFi RTT doesn't support Azimuth yet.
+
+    /**
+     * get Azumith(Not supported yet)
+     */
+    public Azimuth getAzimuth() {
+        Log.w(TAG, "Azimuth feature is not yet supported in WiFi RTT");
+        return mAzimuth;
+    }
+
+    // WiFi RTT doesn't support Elevation yet.
+
+    /**
+     * get Elevation(Not supported yet)
+     */
+    public Elevation getElevation() {
+        Log.w(TAG, "Elevation feature is not yet supported in WiFi RTT");
+        return mElevation;
+    }
+
+    /**
+     * Azimuth data(Not supported yet)
+     */
+    public static class Azimuth {
+        public int getValue() {
+            return 0;
+        }
+    }
+
+    /**
+     * Elevation data(Not supported yet)
+     */
+    public static class Elevation {
+        public int getValue() {
+            return 0;
+        }
+    }
+}
diff --git a/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRangingSessionCallback.java b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRangingSessionCallback.java
new file mode 100644
index 00000000..4ae0d558
--- /dev/null
+++ b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttRangingSessionCallback.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rtt.backend.internal;
+
+/**
+ * Callbacks used by startRanging.
+ */
+public interface RttRangingSessionCallback {
+
+    int REASON_UNKNOWN = 0;
+    int REASON_WRONG_PARAMETERS = 1;
+    int REASON_FAILED_TO_START = 2;
+    int REASON_STOPPED_BY_PEER = 3;
+    int REASON_STOP_RANGING_CALLED = 4;
+    int REASON_MAX_RANGING_ROUND_RETRY_REACHED = 5;
+    int REASON_SYSTEM_POLICY = 6;
+    int REASON_RTT_NOT_AVAILABLE = 7;
+
+    /**
+     * Callback when a ranging session has been initiated.
+     */
+    void onRangingInitialized(RttDevice device);
+
+    /**
+     * Callback when a ranging device's position is received.
+     */
+    void onRangingResult(RttDevice device, RttRangingPosition position);
+
+    /**
+     * Callback when a session has been suspended.
+     */
+    void onRangingSuspended(RttDevice device, int reason);
+
+}
diff --git a/generic_ranging/src/com/android/ranging/cs/CsParameters.java b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttService.java
similarity index 66%
rename from generic_ranging/src/com/android/ranging/cs/CsParameters.java
rename to ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttService.java
index 4973e49b..8ca53c9b 100644
--- a/generic_ranging/src/com/android/ranging/cs/CsParameters.java
+++ b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttService.java
@@ -1,27 +1,29 @@
-/*
- * Copyright 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.ranging.cs;
-
-import com.android.ranging.RangingParameters;
-
-/** Parameters for Bluetooth channel sounding ranging. */
-public class CsParameters implements RangingParameters.TechnologyParameters {
-    public CsParameters() {
-        throw new UnsupportedOperationException("Not implemented!");
-    }
-}
-
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rtt.backend.internal;
+
+import android.content.Context;
+
+public interface RttService {
+    RttRangingDevice getPublisher(Context context);
+
+    RttRangingDevice getSubscriber(Context context);
+
+    boolean isAvailable();
+
+    boolean hasPeriodicRangingSupport();
+}
diff --git a/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttServiceImpl.java b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttServiceImpl.java
new file mode 100644
index 00000000..bfe0c89b
--- /dev/null
+++ b/ranging/rtt_backend/src/com/android/ranging/rtt/backend/internal/RttServiceImpl.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ranging.rtt.backend.internal;
+
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.net.wifi.aware.WifiAwareManager;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+
+/**
+ *
+ */
+public class RttServiceImpl implements RttService {
+    private static final String TAG = RttServiceImpl.class.getSimpleName();
+    private final Context mContext;
+    private WifiAwareManager mWifiAwareManager;
+
+    public RttServiceImpl(@NonNull Context context) {
+        this.mContext = context;
+        if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_AWARE)) {
+            mWifiAwareManager = context.getSystemService(WifiAwareManager.class);
+            if (mWifiAwareManager == null) {
+                Log.e(TAG, "Failed to get WifiAwareManager");
+            }
+        }
+    }
+
+    @Override
+    public RttRangingDevice getPublisher(Context context) {
+        return new RttRangingDevice(context, RttRangingDevice.DeviceType.PUBLISHER);
+    }
+
+    @Override
+    public RttRangingDevice getSubscriber(Context context) {
+        return new RttRangingDevice(context, RttRangingDevice.DeviceType.SUBSCRIBER);
+    }
+
+    @Override
+    public boolean isAvailable() {
+        if (mWifiAwareManager == null || !mWifiAwareManager.isAvailable()) {
+            Log.w(TAG, "Wifi RTT unavailable");
+            return false;
+        }
+        return true;
+    }
+
+    @Override
+    public boolean hasPeriodicRangingSupport() {
+        if (mWifiAwareManager == null) {
+            Log.e(TAG, "WifiAwareManager is null");
+            return false;
+        }
+        try {
+            //TODO: Uncomment when the support is added.
+                //return mWifiAwareManager.getCharacteristics().isPeriodicRangingSupported();
+        } catch (RuntimeException e) {
+            Log.e(TAG, "Failed to get WifiAwareManager#characteristics");
+        }
+        return false;
+    }
+}
diff --git a/ranging/rtt_backend/tests/Android.bp b/ranging/rtt_backend/tests/Android.bp
new file mode 100644
index 00000000..96a63511
--- /dev/null
+++ b/ranging/rtt_backend/tests/Android.bp
@@ -0,0 +1,64 @@
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Make test APK
+// ============================================================
+package {
+    default_team: "trendy_team_fwk_uwb",
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+android_test {
+    name: "RangingRttBackendTests",
+
+    srcs: [
+        "**/*.java",
+    ],
+
+    dxflags: ["--multi-dex"],
+
+    java_version: "1.9",
+
+    static_libs: [
+        "androidx.test.rules",
+        "collector-device-lib",
+        "hamcrest-library",
+        "mockito-target-extended-minus-junit4",
+        "platform-test-annotations",
+        "frameworks-base-testutils",
+        "truth",
+        "guava",
+        "ranging_rtt_backend",
+    ],
+
+    libs: [
+        "android.test.runner.stubs.system",
+        "android.test.base.stubs.system",
+        "android.test.mock.stubs.system",
+        "framework-annotations-lib",
+    ],
+
+    jni_libs: [
+        // these are needed for Extended Mockito
+        "libdexmakerjvmtiagent",
+        "libstaticjvmtiagent",
+    ],
+    compile_multilib: "both",
+
+    min_sdk_version: "Tiramisu",
+
+    test_suites: [
+        "general-tests",
+    ],
+}
diff --git a/ranging/rtt_backend/tests/AndroidManifest.xml b/ranging/rtt_backend/tests/AndroidManifest.xml
new file mode 100644
index 00000000..5f5cb507
--- /dev/null
+++ b/ranging/rtt_backend/tests/AndroidManifest.xml
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.android.ranging.rtt.backend">
+
+    <application android:debuggable="true"
+         android:largeHeap="true">
+        <uses-library android:name="android.test.runner"/>
+        <activity android:label="RttTestDummyLabel"
+             android:name="RttTestDummyName"
+             android:exported="true">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN"/>
+                <category android:name="android.intent.category.LAUNCHER"/>
+            </intent-filter>
+        </activity>
+    </application>
+
+    <!-- This is a self-instrumenting test package. -->
+    <instrumentation android:name="androidx.test.runner.AndroidJUnitRunner"
+        android:targetPackage="com.android.ranging.rtt.backend"
+        android:label="Tests for the generic ranging Rtt backend">
+    </instrumentation>
+
+</manifest>
diff --git a/ranging/rtt_backend/tests/AndroidTest.xml b/ranging/rtt_backend/tests/AndroidTest.xml
new file mode 100644
index 00000000..b48665e9
--- /dev/null
+++ b/ranging/rtt_backend/tests/AndroidTest.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<configuration description="Tests for the generic ranging RTT backend">
+    <target_preparer class="com.android.tradefed.targetprep.suite.SuiteApkInstaller">
+        <option name="test-file-name" value="RangingRttBackendTests.apk" />
+    </target_preparer>
+
+    <option name="test-suite-tag" value="apct" />
+    <option name="test-tag" value="RangingRttBackendTests" />
+    <test class="com.android.tradefed.testtype.AndroidJUnitTest" >
+        <option name="package" value="com.android.ranging.rtt.backend" />
+        <option name="runner" value="androidx.test.runner.AndroidJUnitRunner" />
+        <option name="hidden-api-checks" value="false"/>
+    </test>
+</configuration>
\ No newline at end of file
diff --git a/ranging/service/Android.bp b/ranging/service/Android.bp
index f85cdb81..321bdf57 100644
--- a/ranging/service/Android.bp
+++ b/ranging/service/Android.bp
@@ -42,11 +42,14 @@ java_library {
     srcs: [":service-ranging-srcs"],
     sdk_version: "system_server_current",
 
+    plugins: [
+        "auto_value_plugin",
+    ],
     libs: [
         "androidx.annotation_annotation",
+        "error_prone_annotations",
         "framework-annotations-lib",
         "framework-configinfrastructure.stubs.module_lib",
-        "framework-ranging-pre-jarjar",
         "framework-statsd.stubs.module_lib",
         "framework-wifi.stubs.module_lib",
         "framework-bluetooth.stubs.module_lib",
@@ -57,8 +60,18 @@ java_library {
         "guava",
         "modules-utils-shell-command-handler",
         "modules-utils-handlerexecutor",
+        // TODO: migrate away from auto value if possible.
+        "auto_value_annotations",
         //"modules-utils-preconditions",
         //"modules-utils-build",
+        "framework-ranging-pre-jarjar",
+        "androidx.annotation_annotation",
+        "androidx.concurrent_concurrent-futures",
+        "androidx.concurrent_concurrent-futures",
+        "com.uwb.fusion",
+        "ranging_rtt_backend",
+        "ranging_uwb_backend",
+        "ranging_flags_lib",
     ],
 
     apex_available: [
@@ -76,7 +89,10 @@ java_library {
         "standalone-system-server-module-optimize-defaults",
     ],
     installable: true,
-    static_libs: ["service-ranging-pre-jarjar"],
+    static_libs: [
+        "service-ranging-pre-jarjar",
+        "ranging_uwb_backend",
+    ],
 
     // Need to include `libs` so that Soong doesn't complain about missing classes after jarjaring
     // The below libraries are not actually needed to build since no source is compiled
diff --git a/ranging/service/java/com/android/server/ranging/CapabilitiesProvider.java b/ranging/service/java/com/android/server/ranging/CapabilitiesProvider.java
new file mode 100644
index 00000000..af7e2522
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/CapabilitiesProvider.java
@@ -0,0 +1,181 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging;
+
+import android.annotation.IntDef;
+import android.annotation.Nullable;
+import android.os.Binder;
+import android.os.RemoteCallbackList;
+import android.os.RemoteException;
+import android.ranging.IRangingCapabilitiesCallback;
+import android.ranging.RangingCapabilities;
+import android.ranging.RangingCapabilities.RangingTechnologyAvailability;
+import android.ranging.RangingCapabilities.TechnologyCapabilities;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.util.HashMap;
+import java.util.Map;
+
+public class CapabilitiesProvider {
+
+    /**
+     * An adapter to the capability and availability APIs exposed by an underlying technology's
+     * stack.
+     */
+    public abstract static class CapabilitiesAdapter {
+        private TechnologyAvailabilityListener mListener;
+
+        protected CapabilitiesAdapter(@NonNull TechnologyAvailabilityListener listener) {
+            mListener = listener;
+        }
+
+        public @Nullable TechnologyAvailabilityListener getAvailabilityListener() {
+            return mListener;
+        }
+
+        public abstract @RangingTechnologyAvailability int getAvailability();
+
+        public abstract @Nullable TechnologyCapabilities getCapabilities();
+    }
+
+    @IntDef({
+            AvailabilityChangedReason.UNKNOWN,
+            AvailabilityChangedReason.SYSTEM_POLICY,
+    })
+    public @interface AvailabilityChangedReason {
+        int UNKNOWN = 0;
+        int SYSTEM_POLICY = 1;
+    }
+
+    private static final String TAG = CapabilitiesProvider.class.getSimpleName();
+    private final RangingInjector mRangingInjector;
+    private final Map<RangingTechnology, CapabilitiesAdapter> mCapabilityAdapters;
+    private RangingCapabilities mCachedCapabilities;
+
+    /** Callbacks provided from the framework */
+    private final RemoteCallbackList<IRangingCapabilitiesCallback> mCallbacks =
+            new RemoteCallbackList<>();
+
+    public CapabilitiesProvider(RangingInjector rangingInjector) {
+        mRangingInjector = rangingInjector;
+        mCapabilityAdapters = new HashMap<>();
+        mCachedCapabilities = null;
+    }
+
+    public synchronized void registerCapabilitiesCallback(
+            @NonNull IRangingCapabilitiesCallback callback
+    ) {
+        mCallbacks.register(callback);
+        if (mCachedCapabilities == null) {
+            initializeAdaptersForAllTechnologies();
+            mCachedCapabilities = getCapabilities().build();
+        }
+        try {
+            callback.onRangingCapabilities(mCachedCapabilities);
+        } catch (RemoteException e) {
+            Log.e(TAG, "Failed to call provided capabilities callback", e);
+        }
+    }
+
+    public synchronized void unregisterCapabilitiesCallback(
+            @NonNull IRangingCapabilitiesCallback callback
+    ) {
+        mCallbacks.unregister(callback);
+    }
+
+    private synchronized RangingCapabilities.Builder getCapabilities() {
+        RangingCapabilities.Builder builder = new RangingCapabilities.Builder();
+        for (RangingTechnology technology : mCapabilityAdapters.keySet()) {
+            CapabilitiesAdapter adapter = mCapabilityAdapters.get(technology);
+            // Any calls to the corresponding technology stacks must be
+            // done with a clear calling identity.
+            long token = Binder.clearCallingIdentity();
+            TechnologyCapabilities capabilities = adapter.getCapabilities();
+            builder.addAvailability(technology.getValue(), adapter.getAvailability());
+            if (capabilities != null) {
+                builder.addCapabilities(capabilities);
+            }
+            Binder.restoreCallingIdentity(token);
+        }
+        return builder;
+    }
+
+    private synchronized void initializeAdaptersForAllTechnologies() {
+        Log.i(TAG, "Registering availability listeners for each technology");
+        // Any calls to the corresponding technology stacks must be
+        // done with a clear calling identity.
+        long token = Binder.clearCallingIdentity();
+        for (RangingTechnology technology : RangingTechnology.TECHNOLOGIES) {
+            mCapabilityAdapters.put(
+                    technology,
+                    mRangingInjector.createCapabilitiesAdapter(
+                            technology,
+                            new TechnologyAvailabilityListener(technology)));
+        }
+        Binder.restoreCallingIdentity(token);
+    }
+
+    public class TechnologyAvailabilityListener {
+        private final RangingTechnology mTechnology;
+
+        TechnologyAvailabilityListener(RangingTechnology technology) {
+            mTechnology = technology;
+        }
+
+        public void onAvailabilityChange(
+                @RangingTechnologyAvailability int availability,
+                @AvailabilityChangedReason int unused
+        ) {
+            synchronized (CapabilitiesProvider.this) {
+                mCachedCapabilities = getCapabilities()
+                        .addAvailability(mTechnology.getValue(), availability)
+                        .build();
+                synchronized (mCallbacks) {
+                    int i = mCallbacks.beginBroadcast();
+                    while (i > 0) {
+                        i--;
+                        try {
+                            mCallbacks.getBroadcastItem(i)
+                                    .onRangingCapabilities(mCachedCapabilities);
+                        } catch (RemoteException e) {
+                            Log.w(TAG,
+                                    "Failed to notify callback " + i + " of availability change");
+                        }
+                    }
+                    mCallbacks.finishBroadcast();
+                }
+            }
+        }
+    }
+
+    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        pw.println("---- Dump of CapabilitiesProvider ----");
+        for (Map.Entry<RangingTechnology, CapabilitiesAdapter> adapter :
+                mCapabilityAdapters.entrySet()
+        ) {
+            pw.println("-- Dump of CapabilitiesAdapter for technology " + adapter.getKey() + " --");
+            pw.println("Availability: " + adapter.getValue().getAvailability());
+            pw.println("Capabilities: " + adapter.getValue().getCapabilities());
+            pw.println("-- Dump of CapabilitiesAdapter for technology " + adapter.getKey() + " --");
+        }
+        pw.println("---- Dump of CapabilitiesProvider ----");
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/RangingAdapter.java b/ranging/service/java/com/android/server/ranging/RangingAdapter.java
new file mode 100644
index 00000000..0107551d
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/RangingAdapter.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging;
+
+import android.ranging.RangingData;
+import android.ranging.RangingDevice;
+
+import androidx.annotation.IntDef;
+import androidx.annotation.NonNull;
+
+import com.android.server.ranging.session.RangingSessionConfig;
+
+/** RangingAdapter representing a common ranging class for multiple ranging technologies. */
+public interface RangingAdapter {
+
+    /** Returns {@link RangingTechnology} of this adapter. */
+    @NonNull RangingTechnology getTechnology();
+
+    /**
+     * Start ranging. Does nothing if the ranging technology is not enabled on device or if ranging
+     * has already been started. In the latter case, this method will not overwrite the existing
+     * callback.
+     * @param config for the ranging session.
+     * @param callback to be called on the occurrence of ranging events.
+     */
+    void start(@NonNull RangingSessionConfig.TechnologyConfig config, @NonNull Callback callback);
+
+    /** Stop ranging. */
+    void stop();
+
+    /** Callback for getting notified when ranging starts or stops. */
+    interface Callback {
+        /**
+         * Notifies the caller that ranging has started with a particular peer. onStarted will not
+         * be called after start if API failed to initialize, in that case onClosed with an
+         * appropriate error code will be called instead.
+         *
+         * @param peer that ranging was started with.
+         */
+        void onStarted(@NonNull RangingDevice peer);
+
+
+        /**
+         * Notifies the caller that ranging has stopped with a particular peer.
+         *
+         * @param peer that ranging was stopped with.
+         */
+        void onStopped(@NonNull RangingDevice peer);
+
+        /**
+         * Notifies the caller on each instance of ranging data received from the ranging
+         * technology.
+         *
+         * @param peer device whose distance was measured.
+         * @param data the distance measurement and other position-related data.
+         */
+        void onRangingData(@NonNull RangingDevice peer, @NonNull RangingData data);
+
+        @IntDef({
+                ClosedReason.UNKNOWN,
+                ClosedReason.FAILED_TO_START,
+                ClosedReason.REQUESTED,
+                ClosedReason.LOST_CONNECTION,
+                ClosedReason.SYSTEM_POLICY,
+                ClosedReason.ERROR,
+        })
+        @interface ClosedReason {
+            int UNKNOWN = 0;
+            int ERROR = 1;
+            int FAILED_TO_START = 2;
+            int REQUESTED = 3;
+            int LOST_CONNECTION = 4;
+            int SYSTEM_POLICY = 5;
+        }
+
+        /**
+         * Notifies the caller that the ranging session was closed.
+         *
+         * @param reason why the session was closed.
+         */
+        void onClosed(@ClosedReason int reason);
+    }
+}
diff --git a/generic_ranging/src/com/android/ranging/RangingData.java b/ranging/service/java/com/android/server/ranging/RangingData.java
similarity index 90%
rename from generic_ranging/src/com/android/ranging/RangingData.java
rename to ranging/service/java/com/android/server/ranging/RangingData.java
index ee64916e..c772aacf 100644
--- a/generic_ranging/src/com/android/ranging/RangingData.java
+++ b/ranging/service/java/com/android/server/ranging/RangingData.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.android.ranging;
+package com.android.server.ranging;
 
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
@@ -22,6 +22,7 @@ import androidx.annotation.Nullable;
 import com.google.common.base.Preconditions;
 
 import java.time.Duration;
+import java.util.Arrays;
 import java.util.Optional;
 import java.util.OptionalDouble;
 import java.util.OptionalInt;
@@ -176,4 +177,24 @@ public class RangingData {
             return this;
         }
     }
+
+    @Override
+    public String toString() {
+        return "RangingData{ "
+                + "mTechnology="
+                + mTechnology
+                + ", mRangeDistance="
+                + mRangeDistance
+                + ", mAzimuth="
+                + mAzimuth
+                + ", mElevation="
+                + mElevation
+                + ", mRssi="
+                + mRssi
+                + ", mTimestamp="
+                + mTimestamp
+                + ", mPeerAddress="
+                + Arrays.toString(mPeerAddress)
+                + " }";
+    }
 }
diff --git a/ranging/service/java/com/android/server/ranging/RangingInjector.java b/ranging/service/java/com/android/server/ranging/RangingInjector.java
new file mode 100644
index 00000000..980816d2
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/RangingInjector.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging;
+
+import static android.Manifest.permission.RANGING;
+import static android.permission.PermissionManager.PERMISSION_GRANTED;
+
+import android.annotation.NonNull;
+import android.content.AttributionSource;
+import android.content.Context;
+import android.os.Binder;
+import android.os.HandlerThread;
+import android.os.Looper;
+import android.permission.PermissionManager;
+import android.ranging.RangingPreference;
+
+import com.android.server.ranging.CapabilitiesProvider.CapabilitiesAdapter;
+import com.android.server.ranging.blerssi.BleRssiAdapter;
+import com.android.server.ranging.blerssi.BleRssiCapabilitiesAdapter;
+import com.android.server.ranging.cs.CsAdapter;
+import com.android.server.ranging.cs.CsCapabilitiesAdapter;
+import com.android.server.ranging.rtt.RttAdapter;
+import com.android.server.ranging.rtt.RttCapabilitiesAdapter;
+import com.android.server.ranging.session.RangingSessionConfig;
+import com.android.server.ranging.uwb.UwbAdapter;
+import com.android.server.ranging.uwb.UwbCapabilitiesAdapter;
+
+import com.google.common.util.concurrent.ListeningExecutorService;
+
+public class RangingInjector {
+
+    private static final String TAG = "RangingInjector";
+
+    private final Context mContext;
+    private final RangingServiceManager mRangingServiceManager;
+
+    private final CapabilitiesProvider mCapabilitiesProvider;
+    private final PermissionManager mPermissionManager;
+
+    private final Looper mLooper;
+
+    public RangingInjector(@NonNull Context context) {
+        HandlerThread rangingHandlerThread = new HandlerThread("RangingServiceHandler");
+        rangingHandlerThread.start();
+        mLooper = rangingHandlerThread.getLooper();
+        mContext = context;
+        mCapabilitiesProvider = new CapabilitiesProvider(this);
+        mRangingServiceManager = new RangingServiceManager(this, mLooper);
+        mPermissionManager = context.getSystemService(PermissionManager.class);
+    }
+
+    public Context getContext() {
+        return mContext;
+    }
+
+    public CapabilitiesProvider getCapabilitiesProvider() {
+        return mCapabilitiesProvider;
+    }
+
+    public RangingServiceManager getRangingServiceManager() {
+        return mRangingServiceManager;
+    }
+
+    /**
+     * Create a new adapter for a technology.
+     */
+    public @NonNull RangingAdapter createAdapter(
+            @NonNull RangingSessionConfig.TechnologyConfig config,
+            @RangingPreference.DeviceRole int role,
+            @NonNull ListeningExecutorService executor
+    ) {
+        switch (config.getTechnology()) {
+            case UWB:
+                return new UwbAdapter(mContext, executor, role);
+            case CS:
+                return new CsAdapter(mContext);
+            case RTT:
+                return new RttAdapter(mContext, executor, role);
+            case RSSI:
+                return new BleRssiAdapter(mContext);
+            default:
+                throw new IllegalArgumentException(
+                        "Adapter does not exist for technology " + config.getTechnology());
+        }
+    }
+
+    public @NonNull CapabilitiesAdapter createCapabilitiesAdapter(
+            @NonNull RangingTechnology technology,
+            @NonNull CapabilitiesProvider.TechnologyAvailabilityListener listener
+    ) {
+        switch (technology) {
+            case UWB:
+                return new UwbCapabilitiesAdapter(mContext, listener);
+            case CS:
+                return new CsCapabilitiesAdapter(mContext, listener);
+            case RTT:
+                return new RttCapabilitiesAdapter(mContext, listener);
+            case RSSI:
+                return new BleRssiCapabilitiesAdapter(mContext, listener);
+            default:
+                throw new IllegalArgumentException(
+                        "CapabilitiesAdapter does not exist for technology " + technology);
+        }
+    }
+
+
+    public void enforceRangingPermissionForPreflight(
+            @NonNull AttributionSource attributionSource) {
+        if (!attributionSource.checkCallingUid()) {
+            throw new SecurityException("Invalid attribution source " + attributionSource
+                    + ", callingUid: " + Binder.getCallingUid());
+        }
+        int permissionCheckResult = mPermissionManager.checkPermissionForPreflight(
+                RANGING, attributionSource);
+        if (permissionCheckResult != PERMISSION_GRANTED) {
+            throw new SecurityException("Caller does not hold RANGING permission");
+        }
+    }
+
+    public boolean checkUwbRangingPermissionForStartDataDelivery(
+            @NonNull AttributionSource attributionSource, @NonNull String message) {
+        int permissionCheckResult = mPermissionManager.checkPermissionForStartDataDelivery(
+                RANGING, attributionSource, message);
+        return permissionCheckResult == PERMISSION_GRANTED;
+    }
+
+}
diff --git a/ranging/service/java/com/android/server/ranging/RangingService.java b/ranging/service/java/com/android/server/ranging/RangingService.java
index 8d790810..19382370 100644
--- a/ranging/service/java/com/android/server/ranging/RangingService.java
+++ b/ranging/service/java/com/android/server/ranging/RangingService.java
@@ -23,12 +23,16 @@ import com.android.server.SystemService;
 
 public class RangingService extends SystemService {
     private static final String TAG = "RangingService";
+    private final RangingServiceImpl mRangingImpl;
+
     public RangingService(Context context) {
         super(context);
+        mRangingImpl = new RangingServiceImpl(context, new RangingInjector(context));
     }
 
     @Override
     public void onStart() {
         Log.i(TAG, "Registering Ranging service");
+        publishBinderService(Context.RANGING_SERVICE, mRangingImpl);
     }
 }
diff --git a/ranging/service/java/com/android/server/ranging/RangingServiceImpl.java b/ranging/service/java/com/android/server/ranging/RangingServiceImpl.java
new file mode 100644
index 00000000..af51c8bd
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/RangingServiceImpl.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging;
+
+import static android.content.pm.PackageManager.PERMISSION_GRANTED;
+
+import android.annotation.NonNull;
+import android.content.AttributionSource;
+import android.content.Context;
+import android.os.Binder;
+import android.os.RemoteException;
+import android.ranging.IRangingAdapter;
+import android.ranging.IRangingCallbacks;
+import android.ranging.IRangingCapabilitiesCallback;
+import android.ranging.RangingDevice;
+import android.ranging.RangingPreference;
+import android.ranging.SessionHandle;
+import android.ranging.oob.IOobSendDataListener;
+import android.ranging.oob.OobHandle;
+import android.ranging.oob.OobResponderRangingParams;
+import android.ranging.raw.RawResponderRangingParams;
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+
+public class RangingServiceImpl extends IRangingAdapter.Stub {
+
+    private static final String TAG = "RangingServiceImpl";
+    private final RangingInjector mRangingInjector;
+    private final Context mContext;
+
+    RangingServiceImpl(@NonNull Context context, @NonNull RangingInjector rangingInjector) {
+        mContext = context;
+        mRangingInjector = rangingInjector;
+    }
+
+
+    @Override
+    public void registerCapabilitiesCallback(IRangingCapabilitiesCallback callback)
+            throws RemoteException {
+        mRangingInjector.getRangingServiceManager().registerCapabilitiesCallback(callback);
+    }
+
+    @Override
+    public void unregisterCapabilitiesCallback(IRangingCapabilitiesCallback callback)
+            throws RemoteException {
+        mRangingInjector.getRangingServiceManager().unregisterCapabilitiesCallback(callback);
+    }
+
+    @Override
+    public void startRanging(AttributionSource attributionSource, SessionHandle sessionHandle,
+            RangingPreference rangingPreference, IRangingCallbacks callbacks) {
+        mRangingInjector.enforceRangingPermissionForPreflight(attributionSource);
+        mRangingInjector.getRangingServiceManager().startRanging(attributionSource, sessionHandle,
+                rangingPreference, callbacks);
+    }
+
+    @Override
+    public void reconfigureRangingInterval(SessionHandle sessionHandle, int intervalSkipCount) {
+        enforceRangingPermission();
+        mRangingInjector.getRangingServiceManager().reconfigureInterval(sessionHandle,
+                intervalSkipCount);
+    }
+
+    @Override
+    public void addRawDevice(SessionHandle sessionHandle, RawResponderRangingParams rangingParams) {
+        enforceRangingPermission();
+        mRangingInjector.getRangingServiceManager().addRawPeer(sessionHandle, rangingParams);
+    }
+
+    @Override
+    public void addOobDevice(SessionHandle sessionHandle, OobResponderRangingParams rangingParams) {
+        enforceRangingPermission();
+        throw new IllegalArgumentException("Dynamic addition of oob peer not supported yet");
+    }
+
+    @Override
+    public void removeDevice(SessionHandle sessionHandle, RangingDevice rangingDevice) {
+        enforceRangingPermission();
+        mRangingInjector.getRangingServiceManager().removePeer(sessionHandle, rangingDevice);
+    }
+
+    @Override
+    public void stopRanging(SessionHandle sessionHandle) {
+        enforceRangingPermission();
+        mRangingInjector.getRangingServiceManager().stopRanging(sessionHandle);
+    }
+
+    @Override
+    public void oobDataReceived(OobHandle oobHandle, byte[] data) {
+        mRangingInjector.getRangingServiceManager().oobDataReceived(oobHandle, data);
+    }
+
+    @Override
+    public void deviceOobDisconnected(OobHandle oobHandle) {
+        mRangingInjector.getRangingServiceManager().deviceOobDisconnected(oobHandle);
+    }
+
+    @Override
+    public void deviceOobReconnected(OobHandle oobHandle) {
+        mRangingInjector.getRangingServiceManager().deviceOobReconnected(oobHandle);
+    }
+
+    @Override
+    public void deviceOobClosed(OobHandle oobHandle) {
+        mRangingInjector.getRangingServiceManager().deviceOobClosed(oobHandle);
+    }
+
+    @Override
+    public void registerOobSendDataListener(IOobSendDataListener oobSendDataListener) {
+        mRangingInjector.getRangingServiceManager().registerOobSendDataListener(
+                oobSendDataListener);
+    }
+
+    private void enforceRangingPermission() {
+        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.RANGING,
+                "RangingService");
+    }
+
+    @Override
+    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP)
+                != PERMISSION_GRANTED) {
+            pw.println("Permission Denial: can't dump RangingService from pid="
+                    + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
+            return;
+        }
+        mRangingInjector.getRangingServiceManager().dump(fd, pw, args);
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/RangingServiceManager.java b/ranging/service/java/com/android/server/ranging/RangingServiceManager.java
new file mode 100644
index 00000000..7f0b4fd4
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/RangingServiceManager.java
@@ -0,0 +1,455 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging;
+
+import static android.ranging.RangingSession.Callback.REASON_LOCAL_REQUEST;
+import static android.ranging.RangingSession.Callback.REASON_NO_PEERS_FOUND;
+import static android.ranging.RangingSession.Callback.REASON_SYSTEM_POLICY;
+import static android.ranging.RangingSession.Callback.REASON_UNKNOWN;
+import static android.ranging.RangingSession.Callback.REASON_UNSUPPORTED;
+
+import android.content.AttributionSource;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.Message;
+import android.os.RemoteException;
+import android.ranging.IRangingCallbacks;
+import android.ranging.IRangingCapabilitiesCallback;
+import android.ranging.RangingData;
+import android.ranging.RangingDevice;
+import android.ranging.RangingParams;
+import android.ranging.RangingPreference;
+import android.ranging.RangingSession.Callback;
+import android.ranging.SessionHandle;
+import android.ranging.oob.IOobSendDataListener;
+import android.ranging.oob.OobHandle;
+import android.ranging.oob.OobInitiatorRangingParams;
+import android.ranging.oob.OobResponderRangingParams;
+import android.ranging.raw.RawInitiatorRangingParams;
+import android.ranging.raw.RawResponderRangingParams;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+
+import com.android.server.ranging.oob.OobHandler;
+import com.android.server.ranging.session.OobInitiatorRangingSession;
+import com.android.server.ranging.session.OobResponderRangingSession;
+import com.android.server.ranging.session.RangingSession;
+import com.android.server.ranging.session.RangingSessionConfig;
+import com.android.server.ranging.session.RawInitiatorRangingSession;
+import com.android.server.ranging.session.RawResponderRangingSession;
+
+import com.google.common.util.concurrent.ListeningExecutorService;
+import com.google.common.util.concurrent.MoreExecutors;
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.Executors;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+public final class RangingServiceManager {
+    private static final String TAG = RangingServiceManager.class.getSimpleName();
+
+    public enum RangingTask {
+        TASK_START_RANGING(1),
+        TASK_STOP_RANGING(2),
+        TASK_ADD_DEVICE(3),
+        TASK_REMOVE_DEVICE(4),
+        TASK_RECONFIGURE_INTERVAL(5);
+
+        private final int mVal;
+
+        RangingTask(int val) {
+            this.mVal = val;
+        }
+
+        public int getValue() {
+            return mVal;
+        }
+
+        public static RangingTask fromValue(int code) {
+            for (RangingTask task : RangingTask.values()) {
+                if (task.getValue() == code) {
+                    return task;
+                }
+            }
+            throw new IllegalArgumentException("Unknown task code: " + code);
+        }
+    }
+
+    private final RangingInjector mRangingInjector;
+    private final ListeningExecutorService mAdapterExecutor;
+    private final RangingTaskManager mRangingTaskManager;
+    private final Map<SessionHandle, RangingSession<?>> mSessions = new ConcurrentHashMap<>();
+
+    private IOobSendDataListener mOobDataSender;
+
+    public RangingServiceManager(RangingInjector rangingInjector, Looper looper) {
+        mRangingInjector = rangingInjector;
+        mAdapterExecutor = MoreExecutors.listeningDecorator(Executors.newSingleThreadExecutor());
+        mRangingTaskManager = new RangingTaskManager(looper);
+    }
+
+    public void registerCapabilitiesCallback(IRangingCapabilitiesCallback capabilitiesCallback) {
+        Log.w(TAG, "Registering ranging capabilities callback");
+        mRangingInjector
+                .getCapabilitiesProvider()
+                .registerCapabilitiesCallback(capabilitiesCallback);
+    }
+
+    public void unregisterCapabilitiesCallback(IRangingCapabilitiesCallback capabilitiesCallback) {
+        mRangingInjector
+                .getCapabilitiesProvider()
+                .unregisterCapabilitiesCallback(capabilitiesCallback);
+    }
+
+    public void startRanging(
+            AttributionSource attributionSource, SessionHandle handle, RangingPreference preference,
+            IRangingCallbacks callbacks
+    ) {
+        // TODO android.permission.RANGING permission check here
+//        Context context = mRangingInjector.getContext()
+//                .createContext(new ContextParams
+//                        .Builder()
+//                        .setNextAttributionSource(attributionSource)
+//                        .build());
+
+        RangingTaskManager.StartRangingArgs args = new RangingTaskManager.StartRangingArgs(
+                attributionSource, handle, preference, callbacks);
+        mRangingTaskManager.enqueueTask(RangingTask.TASK_START_RANGING, args);
+    }
+
+    public void addRawPeer(SessionHandle handle, RawResponderRangingParams params) {
+        if (!mSessions.containsKey(handle)) {
+            Log.e(TAG, "Failed to add peer. Ranging session not found");
+        }
+        DynamicPeer peer = new DynamicPeer(params.getRawRangingDevice().getRangingDevice(),
+                mSessions.get(handle));
+        mRangingTaskManager.enqueueTask(RangingTask.TASK_ADD_DEVICE, peer);
+    }
+
+    public void removePeer(SessionHandle handle, RangingDevice device) {
+        if (!mSessions.containsKey(handle)) {
+            Log.e(TAG, "Failed to remove peer. Ranging session not found");
+        }
+        DynamicPeer peer = new DynamicPeer(device, mSessions.get(handle));
+        mRangingTaskManager.enqueueTask(RangingTask.TASK_REMOVE_DEVICE, peer);
+    }
+
+    public void reconfigureInterval(SessionHandle handle, int intervalSkipCount) {
+        if (!mSessions.containsKey(handle)) {
+            Log.e(TAG, "Failed to reconfigure ranging interval. Ranging session not found");
+        }
+        mRangingTaskManager.enqueueTask(RangingTask.TASK_RECONFIGURE_INTERVAL,
+                mSessions.get(handle), intervalSkipCount);
+    }
+
+    public void stopRanging(SessionHandle handle) {
+        RangingSession<?> session = mSessions.get(handle);
+        if (session == null) {
+            Log.e(TAG, "stopRanging for nonexistent session");
+            return;
+        }
+        mRangingTaskManager.enqueueTask(RangingTask.TASK_STOP_RANGING, session);
+    }
+
+    /**
+     * Received data from the peer device.
+     *
+     * @param oobHandle unique session/device pair identifier.
+     * @param data      payload
+     */
+    public void oobDataReceived(OobHandle oobHandle, byte[] data) {
+        if (mSessions.get(oobHandle.getSessionHandle()) instanceof OobHandler session) {
+            session.handleOobMessage(oobHandle, data);
+        } else {
+            Log.e(TAG, "oobDataReceived for non-oob session " + oobHandle.getSessionHandle());
+        }
+    }
+
+    /**
+     * Device disconnected from the OOB channel.
+     *
+     * @param oobHandle unique session/device pair identifier.
+     */
+    public void deviceOobDisconnected(OobHandle oobHandle) {
+        if (mSessions.get(oobHandle.getSessionHandle()) instanceof OobHandler session) {
+            session.handleOobDeviceDisconnected(oobHandle);
+        } else {
+            Log.e(TAG, "deviceOobDisconnected for non-oob session " + oobHandle.getSessionHandle());
+        }
+    }
+
+    /**
+     * Device reconnected to the OOB channel
+     *
+     * @param oobHandle unique session/device pair identifier.
+     */
+    public void deviceOobReconnected(OobHandle oobHandle) {
+        if (mSessions.get(oobHandle.getSessionHandle()) instanceof OobHandler session) {
+            session.handleOobDeviceReconnected(oobHandle);
+        } else {
+            Log.e(TAG, "deviceOobReconnected for non-oob session " + oobHandle.getSessionHandle());
+        }
+    }
+
+    /**
+     * Device closed the OOB channel.
+     *
+     * @param oobHandle unique session/device pair identifier.
+     */
+    public void deviceOobClosed(OobHandle oobHandle) {
+        if (mSessions.get(oobHandle.getSessionHandle()) instanceof OobHandler session) {
+            session.handleOobClosed(oobHandle);
+        } else {
+            Log.e(TAG, "deviceOobClosed for non-oob session " + oobHandle.getSessionHandle());
+        }
+    }
+
+    /**
+     * Register send data listener.
+     *
+     * @param oobSendDataListener listener for sending the data via OOB.
+     */
+    public void registerOobSendDataListener(IOobSendDataListener oobSendDataListener) {
+        mOobDataSender = oobSendDataListener;
+    }
+
+    /**
+     * Listens for peer-specific events within a session and translates them to
+     * {@link IRangingCallbacks} calls.
+     */
+    public class SessionListener implements IBinder.DeathRecipient {
+        private final SessionHandle mSessionHandle;
+        private final IRangingCallbacks mRangingCallbacks;
+        private final AtomicBoolean mIsSessionStarted;
+
+        SessionListener(SessionHandle sessionHandle, IRangingCallbacks callbacks) {
+            mSessionHandle = sessionHandle;
+            mRangingCallbacks = callbacks;
+            mIsSessionStarted = new AtomicBoolean(false);
+            try {
+                mRangingCallbacks.asBinder().linkToDeath(this, 0);
+            } catch (RemoteException e) {
+                Log.e(TAG, "Failed to link to death: " + sessionHandle, e);
+                stopRanging(mSessionHandle);
+            }
+        }
+
+        @Override
+        public void binderDied() {
+            Log.i(TAG, "binderDied : Stopping session: " + mSessionHandle);
+            stopRanging(mSessionHandle);
+        }
+
+        public void onTechnologyStarted(
+                @NonNull RangingDevice peer, @NonNull RangingTechnology technology
+        ) {
+            if (!mIsSessionStarted.getAndSet(true)) {
+                try {
+                    mRangingCallbacks.onOpened(mSessionHandle);
+                } catch (RemoteException e) {
+                    Log.e(TAG, "onOpened callback failed: " + e);
+                }
+            }
+            try {
+                mRangingCallbacks.onStarted(mSessionHandle, peer, technology.getValue());
+            } catch (RemoteException e) {
+                Log.e(TAG, "onTechnologyStarted callback failed: " + e);
+            }
+        }
+
+        public void onTechnologyStopped(
+                @NonNull RangingDevice peer, @NonNull RangingTechnology technology
+        ) {
+            try {
+                mRangingCallbacks.onStopped(mSessionHandle, peer, technology.getValue());
+            } catch (RemoteException e) {
+                Log.e(TAG, "onTechnologyStopped callback failed: " + e);
+            }
+        }
+
+        public void onResults(
+                @NonNull RangingDevice peer, @NonNull RangingData data
+        ) {
+            try {
+                mRangingCallbacks.onResults(mSessionHandle, peer, data);
+            } catch (RemoteException e) {
+                Log.e(TAG, "onData callback failed: " + e);
+            }
+        }
+
+        /**
+         * Signals that ranging in the session has stopped. Called by a {@link RangingSession} once
+         * all of its constituent technology-specific sessions have stopped.
+         */
+        public void onSessionStopped(@RangingAdapter.Callback.ClosedReason int reason) {
+            mSessions.remove(mSessionHandle);
+            if (mIsSessionStarted.get()) {
+                try {
+                    mRangingCallbacks.onClosed(mSessionHandle, convertReason(reason));
+                } catch (RemoteException e) {
+                    Log.e(TAG, "onClosed callback failed: " + e);
+                }
+            } else {
+                try {
+                    mRangingCallbacks.onOpenFailed(mSessionHandle, convertReason(reason));
+                } catch (RemoteException e) {
+                    Log.e(TAG, "onOpenFailed callback failed: " + e);
+                }
+            }
+        }
+
+        private @Callback.Reason int convertReason(
+                @RangingAdapter.Callback.ClosedReason int reason
+        ) {
+            switch (reason) {
+                case RangingAdapter.Callback.ClosedReason.REQUESTED:
+                    return REASON_LOCAL_REQUEST;
+                case RangingAdapter.Callback.ClosedReason.FAILED_TO_START:
+                    return REASON_UNSUPPORTED;
+                case RangingAdapter.Callback.ClosedReason.LOST_CONNECTION:
+                    return REASON_NO_PEERS_FOUND;
+                case RangingAdapter.Callback.ClosedReason.SYSTEM_POLICY:
+                    return REASON_SYSTEM_POLICY;
+                default:
+                    return REASON_UNKNOWN;
+            }
+        }
+    }
+
+    private class RangingTaskManager extends Handler {
+        RangingTaskManager(Looper looper) {
+            super(looper);
+        }
+
+        public void enqueueTask(RangingTask task, Object obj) {
+            Message msg = mRangingTaskManager.obtainMessage();
+            msg.what = task.getValue();
+            msg.obj = obj;
+            this.sendMessage(msg);
+        }
+
+        public void enqueueTask(RangingTask task, Object obj, int arg1) {
+            Message msg = mRangingTaskManager.obtainMessage();
+            msg.what = task.getValue();
+            msg.obj = obj;
+            msg.arg1 = arg1;
+            this.sendMessage(msg);
+        }
+
+        @Override
+        public void handleMessage(Message msg) {
+            RangingTask task = RangingTask.fromValue(msg.what);
+            switch (task) {
+                case TASK_START_RANGING -> handleStartRanging((StartRangingArgs) msg.obj);
+                case TASK_STOP_RANGING -> {
+                    RangingSession rangingSession = (RangingSession) msg.obj;
+                    rangingSession.stop();
+                }
+                case TASK_ADD_DEVICE -> {
+                    DynamicPeer peer = (DynamicPeer) msg.obj;
+                    peer.mSession.addPeer(peer.mDevice);
+                }
+                case TASK_REMOVE_DEVICE -> {
+                    DynamicPeer peer = (DynamicPeer) msg.obj;
+                    peer.mSession.removePeer(peer.mDevice);
+                }
+                case TASK_RECONFIGURE_INTERVAL -> {
+                    RangingSession session = (RangingSession) msg.obj;
+                    session.reconfigureInterval(msg.arg1);
+                }
+            }
+        }
+
+        public record StartRangingArgs(
+                AttributionSource attributionSource,
+                SessionHandle handle,
+                RangingPreference preference,
+                IRangingCallbacks callbacks
+        ) {
+        }
+
+        public void handleStartRanging(StartRangingArgs args) {
+            RangingSessionConfig config = new RangingSessionConfig.Builder()
+                    .setDeviceRole(
+                            args.preference.getDeviceRole())
+                    .setSensorFusionConfig(
+                            args.preference.getSessionConfiguration().getSensorFusionParameters())
+                    .setDataNotificationConfig(
+                            args.preference.getSessionConfiguration().getDataNotificationConfig())
+                    .setAoaNeeded(
+                            args.preference.getSessionConfiguration().isAngleOfArrivalNeeded())
+                    .build();
+
+            RangingParams baseParams = args.preference.getRangingParameters();
+            if (baseParams instanceof RawInitiatorRangingParams params) {
+                RawInitiatorRangingSession session = new RawInitiatorRangingSession(
+                        args.attributionSource, args.handle, mRangingInjector, config,
+                        new SessionListener(args.handle, args.callbacks), mAdapterExecutor
+                );
+                session.start(params);
+                mSessions.put(args.handle, session);
+            } else if (baseParams instanceof RawResponderRangingParams params) {
+                RawResponderRangingSession session = new RawResponderRangingSession(
+                        args.attributionSource, args.handle, mRangingInjector, config,
+                        new SessionListener(args.handle, args.callbacks), mAdapterExecutor
+                );
+                session.start(params);
+                mSessions.put(args.handle, session);
+            } else if (baseParams instanceof OobInitiatorRangingParams params) {
+                OobInitiatorRangingSession session = new OobInitiatorRangingSession(
+                        args.attributionSource, args.handle, mRangingInjector, config,
+                        new SessionListener(args.handle, args.callbacks), mOobDataSender,
+                        mAdapterExecutor
+                );
+                session.start(params);
+                mSessions.put(args.handle, session);
+            } else if (baseParams instanceof OobResponderRangingParams params) {
+                OobResponderRangingSession session = new OobResponderRangingSession(
+                        args.attributionSource, args.handle, mRangingInjector, config,
+                        new SessionListener(args.handle, args.callbacks), mOobDataSender,
+                        mAdapterExecutor
+                );
+                session.start(params);
+                mSessions.put(args.handle, session);
+            }
+        }
+    }
+
+    public static final class DynamicPeer {
+        public final RangingDevice mDevice;
+        public final RangingSession<?> mSession;
+
+        public DynamicPeer(RangingDevice device, RangingSession<?> session) {
+            mDevice = device;
+            mSession = session;
+        }
+    }
+
+    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        pw.println("---- Dump of RangingServiceManager ----");
+        for (RangingSession<?> session : mSessions.values()) {
+            session.dump(fd, pw, args);
+        }
+        pw.println("---- Dump of RangingServiceManager ----");
+        mRangingInjector.getCapabilitiesProvider().dump(fd, pw, args);
+    }
+}
diff --git a/generic_ranging/src/com/android/ranging/RangingTechnology.java b/ranging/service/java/com/android/server/ranging/RangingTechnology.java
similarity index 50%
rename from generic_ranging/src/com/android/ranging/RangingTechnology.java
rename to ranging/service/java/com/android/server/ranging/RangingTechnology.java
index 83b60649..92c8c532 100644
--- a/generic_ranging/src/com/android/ranging/RangingTechnology.java
+++ b/ranging/service/java/com/android/server/ranging/RangingTechnology.java
@@ -14,12 +14,17 @@
  * limitations under the License.
  */
 
-package com.android.ranging;
+package com.android.server.ranging;
+
+import static java.lang.Math.min;
 
 import android.content.Context;
+import android.ranging.RangingManager;
 
-import com.android.ranging.cs.CsAdapter;
-import com.android.ranging.uwb.UwbAdapter;
+import com.android.server.ranging.blerssi.BleRssiCapabilitiesAdapter;
+import com.android.server.ranging.cs.CsCapabilitiesAdapter;
+import com.android.server.ranging.rtt.RttCapabilitiesAdapter;
+import com.android.server.ranging.uwb.UwbCapabilitiesAdapter;
 
 import com.google.common.collect.ImmutableList;
 
@@ -29,7 +34,15 @@ import java.util.List;
 /** Enum representing an individual ranging technology. */
 public enum RangingTechnology {
     UWB(0), // Ultra-Wide Band
-    CS(1); // Channel Sounding, formerly known as HADM
+    CS(1), // Channel Sounding, formerly known as HADM
+
+    RTT(2), // Wifi RTT.
+    RSSI(3); // BLE RSSI.
+
+    public static final ImmutableList<RangingTechnology> TECHNOLOGIES =
+            ImmutableList.copyOf(RangingTechnology.values());
+
+    private static final int BITMAP_SIZE_BYTES = 2;
 
     private final int value;
 
@@ -37,12 +50,12 @@ public enum RangingTechnology {
         this.value = value;
     }
 
-    public int getValue() {
+    public @RangingManager.RangingTechnology int getValue() {
         return value;
     }
 
     public byte toByte() {
-        return (byte) (1 << value);
+        return (byte) value;
     }
 
     /**
@@ -52,9 +65,13 @@ public enum RangingTechnology {
     public boolean isSupported(Context context) {
         switch (this) {
             case UWB:
-                return UwbAdapter.isSupported(context);
+                return UwbCapabilitiesAdapter.isSupported(context);
             case CS:
-                return CsAdapter.isSupported(context);
+                return CsCapabilitiesAdapter.isSupported(context);
+            case RTT:
+                return RttCapabilitiesAdapter.isSupported(context);
+            case RSSI:
+                return BleRssiCapabilitiesAdapter.isSupported(context);
             default:
                 return false;
         }
@@ -71,14 +88,31 @@ public enum RangingTechnology {
         return technologies.build();
     }
 
-    public static byte toBitmap(List<RangingTechnology> technologies) {
+    public static byte[] toBitmap(List<RangingTechnology> technologies) {
         if (technologies.isEmpty()) {
-            return 0x0;
+            return new byte[BITMAP_SIZE_BYTES];
         }
-        BitSet bitset = new BitSet();
+        BitSet bitset = new BitSet(BITMAP_SIZE_BYTES * 8);
         for (RangingTechnology technology : technologies) {
             bitset.set(technology.value);
         }
-        return bitset.toByteArray()[0];
+        byte[] bitmap = new byte[BITMAP_SIZE_BYTES];
+        System.arraycopy(
+                bitset.toByteArray(), 0, bitmap, 0,
+                min(BITMAP_SIZE_BYTES, bitset.toByteArray().length));
+        return bitmap;
+    }
+
+    public static ImmutableList<RangingTechnology> fromBitmap(byte[] technologiesBitmap) {
+        ImmutableList.Builder<RangingTechnology> techs = ImmutableList.builder();
+        BitSet bitSet = BitSet.valueOf(technologiesBitmap);
+        for (int i = 0; i < BITMAP_SIZE_BYTES * 8; i++) {
+            if (bitSet.get(i)) {
+                if (i < RangingTechnology.values().length) {
+                    techs.add(RangingTechnology.values()[i]);
+                }
+            }
+        }
+        return techs.build();
     }
 }
\ No newline at end of file
diff --git a/ranging/service/java/com/android/server/ranging/RangingUtils.java b/ranging/service/java/com/android/server/ranging/RangingUtils.java
new file mode 100644
index 00000000..546cb2ac
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/RangingUtils.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging;
+
+import static java.lang.Math.min;
+
+import com.google.common.collect.ImmutableList;
+
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.util.BitSet;
+import java.util.List;
+
+/**
+ * Utilities for {@link com.android.ranging}.
+ */
+public class RangingUtils {
+    /**
+     * A basic synchronized state machine.
+     * @param <E> enum representing the different states of the machine.
+     */
+    public static class StateMachine<E extends Enum<E>> {
+        private E mState;
+
+        public StateMachine(E start) {
+            mState = start;
+        }
+
+        /** Gets the current state */
+        public synchronized E getState() {
+            return mState;
+        }
+
+        /** Sets the current state */
+        public synchronized void setState(E state) {
+            mState = state;
+        }
+
+        /**
+         * Sets the current state.
+         * @return true if the state was successfully changed, false if the current state is
+         * already {@code state}.
+         */
+        public synchronized boolean changeStateTo(E state) {
+            if (mState == state) {
+                return false;
+            }
+            setState(state);
+            return true;
+        }
+
+        /**
+         * If the current state is {@code from}, sets it to {@code to}.
+         * @return true if the current state is {@code from}, false otherwise.
+         */
+        public synchronized boolean transition(E from, E to) {
+            if (mState != from) {
+                return false;
+            }
+            mState = to;
+            return true;
+        }
+
+        @Override
+        public String toString() {
+            return "StateMachine{ "
+                    + mState
+                    + "}";
+        }
+    }
+
+    public static class Conversions {
+        /**
+         * Converts a list of integers to a byte array representing a bitmap of the integers. Given
+         * integers are first shifted by the shift param amount before being placed into the bitmap
+         * (e.g int x results in bit at pos "x - shift" being set).
+         */
+        public static byte[] intListToByteArrayBitmap(
+                List<Integer> list, int expectedSizeBytes, int shift) {
+            BitSet bitSet = new BitSet(expectedSizeBytes * 8);
+            for (int i : list) {
+                bitSet.set(i - shift);
+            }
+            byte[] byteArray = new byte[expectedSizeBytes];
+            System.arraycopy(bitSet.toByteArray(), 0, byteArray, 0,
+                    min(expectedSizeBytes, bitSet.toByteArray().length));
+            return byteArray;
+        }
+
+        /**
+         * Converts a byte array representing a bitmap of integers to a list of integers. The
+         * resulting integers are shifted by the shift param amount (e.g bit set at pos x results
+         * to "x + shift" int in the final list).
+         */
+        public static ImmutableList<Integer> byteArrayToIntList(byte[] byteArray, int shift) {
+            ImmutableList.Builder<Integer> list = ImmutableList.builder();
+            BitSet bitSet = BitSet.valueOf(byteArray);
+            for (int i = 0; i < bitSet.length(); i++) {
+                if (bitSet.get(i)) {
+                    list.add(i + shift);
+                }
+            }
+            return list.build();
+        }
+
+        /** Converts an int to a byte array of a given size, using little endianness. */
+        public static byte[] intToByteArray(int value, int expectedSizeBytes) {
+            ByteBuffer buffer = ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN);
+            buffer.putInt(value).rewind();
+            byte[] byteArray = new byte[expectedSizeBytes];
+            buffer.get(byteArray, 0, min(expectedSizeBytes, 4));
+            return byteArray;
+        }
+
+        /** Converts the given byte array to an integer using little endianness. */
+        public static int byteArrayToInt(byte[] byteArray) {
+            ByteBuffer buffer = ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN);
+            buffer.put(byteArray).rewind();
+            return buffer.getInt();
+        }
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/blerssi/BleRssiAdapter.java b/ranging/service/java/com/android/server/ranging/blerssi/BleRssiAdapter.java
new file mode 100644
index 00000000..b5b09319
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/blerssi/BleRssiAdapter.java
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.blerssi;
+
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_FREQUENT;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_INFREQUENT;
+
+import android.annotation.NonNull;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothManager;
+import android.bluetooth.le.DistanceMeasurementManager;
+import android.bluetooth.le.DistanceMeasurementMethod;
+import android.bluetooth.le.DistanceMeasurementParams;
+import android.bluetooth.le.DistanceMeasurementResult;
+import android.bluetooth.le.DistanceMeasurementSession;
+import android.content.Context;
+import android.ranging.RangingData;
+import android.ranging.RangingDevice;
+import android.ranging.RangingManager;
+import android.ranging.RangingMeasurement;
+import android.ranging.ble.rssi.BleRssiRangingParams;
+import android.util.Log;
+
+import com.android.server.ranging.RangingAdapter;
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.RangingUtils.StateMachine;
+import com.android.server.ranging.session.RangingSessionConfig;
+
+import java.util.concurrent.Executors;
+
+public class BleRssiAdapter implements RangingAdapter {
+
+    private static final String TAG = BleRssiAdapter.class.getSimpleName();
+
+    private final BluetoothAdapter mBluetoothAdapter;
+    private final StateMachine<State> mStateMachine;
+    private Callback mCallbacks;
+    private BluetoothDevice mDeviceFromPeerBluetoothAddress;
+    private RangingDevice mRangingDevice;
+    private DistanceMeasurementSession mSession;
+    private BleRssiConfig mConfig;
+
+    public BleRssiAdapter(@NonNull Context context) {
+        if (!RangingTechnology.RSSI.isSupported(context)) {
+            throw new IllegalArgumentException("BT_RSSI system feature not found.");
+        }
+        mBluetoothAdapter = context.getSystemService(BluetoothManager.class).getAdapter();
+        mStateMachine = new StateMachine<>(State.STOPPED);
+        mCallbacks = null;
+        mSession = null;
+        mConfig = null;
+    }
+
+    @Override
+    public @NonNull RangingTechnology getTechnology() {
+        return RangingTechnology.RSSI;
+    }
+
+    @Override
+    public void start(
+            @NonNull RangingSessionConfig.TechnologyConfig config, @NonNull Callback callback
+    ) {
+        Log.i(TAG, "Start called.");
+        if (!mStateMachine.transition(State.STOPPED, State.STARTED)) {
+            Log.v(TAG, "Attempted to start adapter when it was already started");
+            return;
+        }
+
+        if (!(config instanceof BleRssiConfig bleRssiConfig)) {
+            Log.w(TAG, "Tried to start adapter with invalid ranging parameters");
+            return;
+        }
+
+        BleRssiRangingParams bleRssiRangingParams = bleRssiConfig.getRangingParams();
+        if ((bleRssiConfig.getPeerDevice() == null)
+                || (bleRssiRangingParams.getPeerBluetoothAddress() == null)) {
+            Log.e(TAG, "Peer device is null");
+            return;
+        }
+
+        mConfig = bleRssiConfig;
+        mCallbacks = callback;
+        mRangingDevice = bleRssiConfig.getPeerDevice();
+        mDeviceFromPeerBluetoothAddress =
+                mBluetoothAdapter.getRemoteDevice(bleRssiRangingParams.getPeerBluetoothAddress());
+        DistanceMeasurementManager distanceMeasurementManager =
+                mBluetoothAdapter.getDistanceMeasurementManager();
+
+        DistanceMeasurementParams params =
+                new DistanceMeasurementParams.Builder(mDeviceFromPeerBluetoothAddress)
+                        .setDurationSeconds(DistanceMeasurementParams.getDefaultDurationSeconds())
+                        .setFrequency(getBleRssiFrequency(
+                                bleRssiConfig.getRangingParams().getRangingUpdateRate()))
+                        .setMethodId(DistanceMeasurementMethod.DISTANCE_MEASUREMENT_METHOD_RSSI)
+                        .build();
+
+        distanceMeasurementManager.startMeasurementSession(params,
+                Executors.newSingleThreadExecutor(), mDistanceMeasurementCallback);
+        // Added callback here to be consistent with other ranging technology.
+        mCallbacks.onStarted(bleRssiConfig.getPeerDevice());
+    }
+
+    public enum State {
+        STARTED,
+        STOPPED,
+    }
+
+    public static int getBleRssiFrequency(int updateRate) {
+        switch (updateRate) {
+            case UPDATE_RATE_INFREQUENT:
+                return DistanceMeasurementParams.REPORT_FREQUENCY_LOW;
+            case UPDATE_RATE_FREQUENT:
+                return DistanceMeasurementParams.REPORT_FREQUENCY_HIGH;
+            default:
+                return DistanceMeasurementParams.REPORT_FREQUENCY_MEDIUM;
+        }
+    }
+
+    @Override
+    public void stop() {
+        Log.i(TAG, "Stop called.");
+        if (!mStateMachine.transition(State.STARTED, State.STOPPED)) {
+            Log.v(TAG, "Attempted to stop adapter when it was already stopped");
+            return;
+        }
+
+        if (mSession == null) {
+            Log.v(TAG, "Attempted to stop adapter when ranging session was already stopped");
+            return;
+        }
+        mSession.stopSession();
+    }
+
+    private void clear() {
+        mSession = null;
+        mCallbacks = null;
+    }
+
+    private void closeForReason(@Callback.ClosedReason int reason) {
+        mCallbacks.onStopped(mConfig.getPeerDevice());
+        mCallbacks.onClosed(reason);
+        clear();
+    }
+
+    private final DistanceMeasurementSession.Callback mDistanceMeasurementCallback =
+            new DistanceMeasurementSession.Callback() {
+                public void onStarted(DistanceMeasurementSession session) {
+                    Log.i(TAG, "DistanceMeasurement onStarted !");
+                    mSession = session;
+                    // onStarted is called right after start measurement is called, other ranging
+                    // technologies do not wait for this callback till they find the peer, if peer
+                    // is not found here, we get onStartFail.
+                    //mCallbacks.onStarted(mConfig.getPeerDevice());
+                }
+
+                public void onStartFail(int reason) {
+                    Log.i(TAG, "DistanceMeasurement onStartFail ! reason " + reason);
+                    closeForReason(Callback.ClosedReason.FAILED_TO_START);
+                }
+
+                public void onStopped(DistanceMeasurementSession session, int reason) {
+                    Log.i(TAG, "DistanceMeasurement onStopped ! reason " + reason);
+                    // TODO: Check this.
+                    closeForReason(Callback.ClosedReason.REQUESTED);
+                }
+
+                public void onResult(BluetoothDevice device, DistanceMeasurementResult result) {
+                    Log.i(TAG, "DistanceMeasurement onResult ! "
+                            + result.getResultMeters()
+                            + ", "
+                            + result.getErrorMeters());
+                    RangingData.Builder dataBuilder = new RangingData.Builder()
+                            .setRangingTechnology(RangingManager.BLE_RSSI)
+                            .setDistance(new RangingMeasurement.Builder()
+                                    .setMeasurement(result.getResultMeters())
+                                    .build())
+                            .setTimestampMillis(result.getMeasurementTimestampNanos() * 1000);
+                    if (!Double.isNaN(result.getAzimuthAngle())) {
+                        dataBuilder.setAzimuth(new RangingMeasurement.Builder()
+                                .setMeasurement(result.getAzimuthAngle())
+                                .build());
+                    }
+                    if (!Double.isNaN(result.getAltitudeAngle())) {
+                        dataBuilder.setElevation(new RangingMeasurement.Builder()
+                                .setMeasurement(result.getAltitudeAngle())
+                                .build());
+                    }
+
+                    synchronized (mStateMachine) {
+                        if (mStateMachine.getState() == State.STARTED) {
+                            mCallbacks.onRangingData(mRangingDevice, dataBuilder.build());
+                        }
+                    }
+                }
+            };
+}
diff --git a/ranging/service/java/com/android/server/ranging/blerssi/BleRssiCapabilitiesAdapter.java b/ranging/service/java/com/android/server/ranging/blerssi/BleRssiCapabilitiesAdapter.java
new file mode 100644
index 00000000..331a18c8
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/blerssi/BleRssiCapabilitiesAdapter.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.blerssi;
+
+import static android.ranging.RangingCapabilities.DISABLED_USER;
+import static android.ranging.RangingCapabilities.ENABLED;
+import static android.ranging.RangingCapabilities.NOT_SUPPORTED;
+
+import android.annotation.NonNull;
+import android.annotation.Nullable;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothManager;
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.ranging.RangingCapabilities;
+
+import com.android.server.ranging.CapabilitiesProvider;
+import com.android.server.ranging.CapabilitiesProvider.TechnologyAvailabilityListener;
+
+public class BleRssiCapabilitiesAdapter extends CapabilitiesProvider.CapabilitiesAdapter {
+
+    private final Context mContext;
+    private final BluetoothManager mBluetoothManager;
+
+    public BleRssiCapabilitiesAdapter(
+            @NonNull Context context,
+            @NonNull TechnologyAvailabilityListener listener
+    ) {
+        super(listener);
+        mContext = context;
+        if (isSupported(mContext)) {
+            mBluetoothManager = mContext.getSystemService(BluetoothManager.class);
+        } else {
+            mBluetoothManager = null;
+        }
+    }
+
+    public static boolean isSupported(Context context) {
+        return context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE);
+    }
+
+    @Override
+    public @RangingCapabilities.RangingTechnologyAvailability int getAvailability() {
+        if (mBluetoothManager == null) {
+            return NOT_SUPPORTED;
+        } else if (isAvailable()) {
+            return ENABLED;
+        } else {
+            return DISABLED_USER;
+        }
+    }
+
+    public boolean isAvailable() {
+        return mBluetoothManager.getAdapter().getState() == BluetoothAdapter.STATE_ON;
+    }
+
+    @Nullable
+    @Override
+    public RangingCapabilities.TechnologyCapabilities getCapabilities() {
+        // No special capabilities.
+        return null;
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/blerssi/BleRssiConfig.java b/ranging/service/java/com/android/server/ranging/blerssi/BleRssiConfig.java
new file mode 100644
index 00000000..612d0222
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/blerssi/BleRssiConfig.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.blerssi;
+
+import android.ranging.DataNotificationConfig;
+import android.ranging.RangingDevice;
+import android.ranging.RangingPreference;
+import android.ranging.ble.rssi.BleRssiRangingParams;
+
+import androidx.annotation.NonNull;
+
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.session.RangingSessionConfig;
+
+public class BleRssiConfig implements RangingSessionConfig.UnicastTechnologyConfig {
+    private static final String TAG = BleRssiConfig.class.getSimpleName();
+
+    private final DataNotificationConfig mDataNotificationConfig;
+    private final BleRssiRangingParams mRangingParams;
+
+    private final RangingDevice mPeerDevice;
+
+    @RangingPreference.DeviceRole
+    private final int mDeviceRole;
+
+    public BleRssiConfig(int deviceRole,
+            BleRssiRangingParams bleRssiRangingParams,
+            DataNotificationConfig dataNotificationConfig,
+            RangingDevice peerDevice) {
+        mDeviceRole = deviceRole;
+        mRangingParams = bleRssiRangingParams;
+        mDataNotificationConfig = dataNotificationConfig;
+        mPeerDevice = peerDevice;
+    }
+
+    @Override
+    public @NonNull RangingTechnology getTechnology() {
+        return RangingTechnology.RSSI;
+    }
+
+    public DataNotificationConfig getDataNotificationConfig() {
+        return mDataNotificationConfig;
+    }
+
+    public BleRssiRangingParams getRangingParams() {
+        return mRangingParams;
+    }
+
+    public int getDeviceRole() {
+        return mDeviceRole;
+    }
+
+    @Override
+    public @NonNull RangingDevice getPeerDevice() {
+        return mPeerDevice;
+    }
+
+    @Override
+    public String toString() {
+        return "BleRssiConfig{ "
+                + "mDataNotificationConfig="
+                + mDataNotificationConfig
+                + ", mRangingParams="
+                + mRangingParams
+                + ", mDeviceRole="
+                + mDeviceRole
+                + ", mPeerDevice="
+                + mPeerDevice
+                + " }";
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/cs/CsAdapter.java b/ranging/service/java/com/android/server/ranging/cs/CsAdapter.java
new file mode 100644
index 00000000..70864f76
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/cs/CsAdapter.java
@@ -0,0 +1,225 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.cs;
+
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_FREQUENT;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_INFREQUENT;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_NORMAL;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothManager;
+import android.bluetooth.le.ChannelSoundingParams;
+import android.bluetooth.le.DistanceMeasurementManager;
+import android.bluetooth.le.DistanceMeasurementMethod;
+import android.bluetooth.le.DistanceMeasurementParams;
+import android.bluetooth.le.DistanceMeasurementResult;
+import android.bluetooth.le.DistanceMeasurementSession;
+import android.content.Context;
+import android.ranging.RangingData;
+import android.ranging.RangingDevice;
+import android.ranging.RangingMeasurement;
+import android.ranging.ble.cs.CsRangingParams;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+
+import com.android.server.ranging.RangingAdapter;
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.RangingUtils.StateMachine;
+import com.android.server.ranging.session.RangingSessionConfig;
+
+import java.util.concurrent.Executors;
+
+/**
+ * Channel Sounding adapter for ranging.
+ * TODO(b/380125808): Need to coalesce requests from multiple apps for the same remote device.
+ */
+public class CsAdapter implements RangingAdapter {
+    private static final String TAG = CsAdapter.class.getSimpleName();
+
+    private final BluetoothAdapter mBluetoothAdapter;
+    private final StateMachine<State> mStateMachine;
+    private Callback mCallbacks;
+
+    /** Invariant: non-null while a ranging session is active */
+    private BluetoothDevice mDeviceFromPeerBluetoothAddress;
+
+    /** Invariant: non-null while a ranging session is active */
+    private RangingDevice mRangingDevice;
+
+    /** Invariant: non-null while a ranging session is active */
+    private DistanceMeasurementSession mSession;
+
+    /** Injectable constructor for testing. */
+    public CsAdapter(@NonNull Context context) {
+        if (!RangingTechnology.CS.isSupported(context)) {
+            throw new IllegalArgumentException("BT_CS system feature not found.");
+        }
+        mBluetoothAdapter = context.getSystemService(BluetoothManager.class).getAdapter();
+        mStateMachine = new StateMachine<>(State.STOPPED);
+        mCallbacks = null;
+        mSession = null;
+    }
+
+    @Override
+    public @NonNull RangingTechnology getTechnology() {
+        return RangingTechnology.CS;
+    }
+
+    @Override
+    public void start(
+            @NonNull RangingSessionConfig.TechnologyConfig config, @NonNull Callback callback
+    ) {
+        Log.i(TAG, "Start called.");
+        if (!mStateMachine.transition(State.STOPPED, State.STARTED)) {
+            Log.v(TAG, "Attempted to start adapter when it was already started");
+            return;
+        }
+
+        if (!(config instanceof CsConfig csConfig)) {
+            Log.w(TAG, "Tried to start adapter with invalid ranging parameters");
+            return;
+        }
+
+        CsRangingParams csRangingParams = csConfig.getRangingParams();
+        if ((csConfig.getPeerDevice() == null)
+                || (csRangingParams.getPeerBluetoothAddress() == null)) {
+            Log.e(TAG, "Peer device is null");
+            return;
+        }
+
+        mCallbacks = callback;
+        mRangingDevice = csConfig.getPeerDevice();
+        mDeviceFromPeerBluetoothAddress =
+                mBluetoothAdapter.getRemoteDevice(csRangingParams.getPeerBluetoothAddress());
+        DistanceMeasurementManager distanceMeasurementManager =
+                mBluetoothAdapter.getDistanceMeasurementManager();
+        int duration = DistanceMeasurementParams.getMaxDurationSeconds();
+        int frequency = getFrequency(csRangingParams.getRangingUpdateRate());
+        int methodId = DistanceMeasurementMethod.DISTANCE_MEASUREMENT_METHOD_CHANNEL_SOUNDING;
+
+        DistanceMeasurementParams params =
+                new DistanceMeasurementParams.Builder(mDeviceFromPeerBluetoothAddress)
+                        .setChannelSoundingParams(new ChannelSoundingParams.Builder()
+                                .setLocationType(csRangingParams.getLocationType())
+                                .setCsSecurityLevel(csRangingParams.getSecurityLevel())
+                                .setSightType(csRangingParams.getSightType())
+                                .build())
+                        .setDurationSeconds(duration)
+                        .setFrequency(frequency)
+                        .setMethodId(methodId)
+                        .build();
+
+        distanceMeasurementManager.startMeasurementSession(params,
+                Executors.newSingleThreadExecutor(), mDistanceMeasurementCallback);
+        // Callback here to be consistent with other ranging technologies.
+        mCallbacks.onStarted(csConfig.getPeerDevice());
+    }
+
+    @Override
+    public void stop() {
+        Log.i(TAG, "Stop called.");
+        if (!mStateMachine.transition(State.STARTED, State.STOPPED)) {
+            Log.v(TAG, "Attempted to stop adapter when it was already stopped");
+            return;
+        }
+
+        if (mSession == null) {
+            Log.v(TAG, "Attempted to stop adapter when ranging session was already stopped");
+            return;
+        }
+        mSession.stopSession();
+    }
+
+    private int getFrequency(int updateRate) {
+        if (updateRate == UPDATE_RATE_INFREQUENT) {
+            return DistanceMeasurementParams.REPORT_FREQUENCY_LOW;
+        } else if (updateRate == UPDATE_RATE_NORMAL) {
+            return DistanceMeasurementParams.REPORT_FREQUENCY_MEDIUM;
+        } else if (updateRate == UPDATE_RATE_FREQUENT) {
+            return DistanceMeasurementParams.REPORT_FREQUENCY_HIGH;
+        }
+        return DistanceMeasurementParams.REPORT_FREQUENCY_LOW;
+    }
+
+    private void closeForReason(@Callback.ClosedReason int reason) {
+        mCallbacks.onStopped(mRangingDevice);
+        mCallbacks.onClosed(reason);
+        clear();
+    }
+
+    private void clear() {
+        mSession = null;
+        mCallbacks = null;
+    }
+
+    public enum State {
+        STARTED,
+        STOPPED,
+    }
+
+    private DistanceMeasurementSession.Callback mDistanceMeasurementCallback =
+            new DistanceMeasurementSession.Callback() {
+                public void onStarted(DistanceMeasurementSession session) {
+                    Log.i(TAG, "DistanceMeasurement onStarted !");
+                    mSession = session;
+                    // onStarted is called right after start measurement is called, other ranging
+                    // technologies do not wait for this callback till they find the peer, if peer
+                    // is not found here, we get onStartFail.
+                    //mCallbacks.onStarted(mRangingDevice);
+                }
+
+                public void onStartFail(int reason) {
+                    Log.i(TAG, "DistanceMeasurement onStartFail ! reason " + reason);
+                    closeForReason(Callback.ClosedReason.FAILED_TO_START);
+                }
+
+                public void onStopped(DistanceMeasurementSession session, int reason) {
+                    Log.i(TAG, "DistanceMeasurement onStopped ! reason " + reason);
+                    closeForReason(Callback.ClosedReason.REQUESTED);
+                }
+
+                public void onResult(BluetoothDevice device, DistanceMeasurementResult result) {
+                    Log.i(TAG, "DistanceMeasurement onResult ! "
+                                    + result.getResultMeters()
+                                    + ", "
+                                    + result.getErrorMeters());
+                    RangingData.Builder dataBuilder = new RangingData.Builder()
+                            .setRangingTechnology((int) RangingTechnology.CS.getValue())
+                            .setDistance(new RangingMeasurement.Builder()
+                                    .setMeasurement(result.getResultMeters())
+                                    .build())
+                            .setTimestampMillis(result.getMeasurementTimestampNanos() * 1000);
+                    if (!Double.isNaN(result.getAzimuthAngle())) {
+                        dataBuilder.setAzimuth(new RangingMeasurement.Builder()
+                                .setMeasurement(result.getAzimuthAngle())
+                                .build());
+                    }
+                    if (!Double.isNaN(result.getAltitudeAngle())) {
+                        dataBuilder.setElevation(new RangingMeasurement.Builder()
+                                .setMeasurement(result.getAltitudeAngle())
+                                .build());
+                    }
+                    synchronized (mStateMachine) {
+                        if (mStateMachine.getState() == State.STARTED) {
+                            mCallbacks.onRangingData(mRangingDevice, dataBuilder.build());
+                        }
+                    }
+                }
+            };
+}
diff --git a/ranging/service/java/com/android/server/ranging/cs/CsCapabilities.java b/ranging/service/java/com/android/server/ranging/cs/CsCapabilities.java
new file mode 100644
index 00000000..88d85a9f
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/cs/CsCapabilities.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.cs;
+
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.RangingUtils.Conversions;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableList;
+
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+/** Channel Sounding Capability data send as part of CapabilityResponseMessage during Finder OOB. */
+@AutoValue
+public abstract class CsCapabilities {
+
+    /** Size in bytes of all properties when serialized. */
+    private static final int EXPECTED_SIZE_BYTES = 2;
+
+    // Size in bytes for each properties for serialization/deserialization.
+    private static final int TECHNOLOGY_ID_SIZE = 1;
+    private static final int SECURITY_LEVELS_SIZE = 4;
+
+    private static final int SECURITY_LEVELS_SHIFT = 0;
+
+    /** Returns the size of this {@link CsCapabilities} object when serialized. */
+    public int getSize() {
+        return EXPECTED_SIZE_BYTES;
+    }
+
+    /**
+     * Parses the given byte array and returns {@link CsCapabilities} object. Throws {@link
+     * IllegalArgumentException} on invalid input.
+     */
+    public static CsCapabilities parseBytes(byte[] csCapabilitiesBytes) {
+        if (csCapabilitiesBytes.length < EXPECTED_SIZE_BYTES) {
+            throw new IllegalArgumentException("Couldn't parse CsCapabilities, invalid byte size");
+        }
+
+        int parseCursor = 0;
+        var technology = RangingTechnology.parseByte(csCapabilitiesBytes[parseCursor]);
+        if (technology.size() != 1 || technology.get(0) != RangingTechnology.CS) {
+            throw new IllegalArgumentException(
+                    "Couldn't parse CsCapabilities, invalid technology id");
+        }
+        parseCursor += TECHNOLOGY_ID_SIZE;
+
+        // Parse Supported Channels
+        ImmutableList<Integer> supportedSecurityLevels =
+                Conversions.byteArrayToIntList(
+                        Arrays.copyOfRange(csCapabilitiesBytes, parseCursor,
+                                parseCursor + SECURITY_LEVELS_SIZE),
+                        SECURITY_LEVELS_SHIFT);
+        parseCursor += SECURITY_LEVELS_SIZE;
+
+        return CsCapabilities.builder()
+                .setSupportedSecurityLevels(supportedSecurityLevels)
+                .build();
+    }
+
+    /** Serializes this {@link CsCapabilities} object to bytes. */
+    public final byte[] toBytes() {
+        ByteBuffer byteBuffer = ByteBuffer.allocate(EXPECTED_SIZE_BYTES);
+        byteBuffer
+                .put(RangingTechnology.CS.toByte())
+                .put(Conversions.intListToByteArrayBitmap(getSupportedSecurityLevels(),
+                        SECURITY_LEVELS_SIZE, SECURITY_LEVELS_SHIFT));
+
+        return byteBuffer.array();
+    }
+
+    /** Returns a list of supported security levels. */
+    public abstract ImmutableList<Integer> getSupportedSecurityLevels();
+
+    /** Returns a builder for {@link CsCapabilities}. */
+    public static Builder builder() {
+        return new AutoValue_CsCapabilities.Builder();
+    }
+
+    /** Builder for {@link CsCapabilities}. */
+    @AutoValue.Builder
+    public abstract static class Builder {
+        /** Returns maximum supported security level. */
+        public abstract Builder
+                setSupportedSecurityLevels(ImmutableList<Integer> supportedChannels);
+
+        /** Returns a builder for {@link CsCapabilities}. */
+        public abstract CsCapabilities build();
+    }
+
+    @Override
+    public String toString() {
+        return "CsCapabilities{ "
+                + "supportedSecurityLevels="
+                + getSupportedSecurityLevels()
+                + " }";
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/cs/CsCapabilitiesAdapter.java b/ranging/service/java/com/android/server/ranging/cs/CsCapabilitiesAdapter.java
new file mode 100644
index 00000000..8596e575
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/cs/CsCapabilitiesAdapter.java
@@ -0,0 +1,110 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.cs;
+
+import static android.ranging.RangingCapabilities.DISABLED_USER;
+import static android.ranging.RangingCapabilities.ENABLED;
+import static android.ranging.RangingCapabilities.NOT_SUPPORTED;
+
+import android.annotation.NonNull;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothManager;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.PackageManager;
+import android.ranging.RangingCapabilities.RangingTechnologyAvailability;
+import android.ranging.ble.cs.CsRangingCapabilities;
+
+import androidx.annotation.Nullable;
+
+import com.android.server.ranging.CapabilitiesProvider;
+import com.android.server.ranging.CapabilitiesProvider.CapabilitiesAdapter;
+import com.android.server.ranging.CapabilitiesProvider.TechnologyAvailabilityListener;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class CsCapabilitiesAdapter extends CapabilitiesAdapter {
+
+    private final Context mContext;
+
+    private final BluetoothManager mBluetoothManager;
+
+    /** @return true if CS is supported in the provided context, false otherwise */
+    public static boolean isSupported(Context context) {
+        return context.getPackageManager()
+                .hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE_CHANNEL_SOUNDING);
+    }
+
+    @Override
+    public @RangingTechnologyAvailability int getAvailability() {
+        if (mBluetoothManager == null) {
+            return NOT_SUPPORTED;
+        } else if (mBluetoothManager.getAdapter().getState() == BluetoothAdapter.STATE_ON) {
+            return ENABLED;
+        } else {
+            return DISABLED_USER;
+        }
+    }
+
+    @Override
+    public @Nullable CsRangingCapabilities getCapabilities() {
+        if (getAvailability() == ENABLED) {
+            List<Integer> securityLevels = new ArrayList<>(
+                mContext.getSystemService(BluetoothManager.class)
+                    .getAdapter()
+                    .getDistanceMeasurementManager()
+                    .getChannelSoundingSupportedSecurityLevels());
+            return new CsRangingCapabilities.Builder()
+                    .setSupportedSecurityLevels(securityLevels)
+                    .build();
+        } else {
+            return null;
+        }
+    }
+
+    public CsCapabilitiesAdapter(
+            @NonNull Context context, @NonNull TechnologyAvailabilityListener listener
+    ) {
+        super(listener);
+        mContext = context;
+
+        if (isSupported(mContext)) {
+            mBluetoothManager = mContext.getSystemService(BluetoothManager.class);
+
+            BluetoothStateChangeReceiver receiver = new BluetoothStateChangeReceiver();
+            IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
+            mContext.registerReceiver(receiver, filter, Context.RECEIVER_NOT_EXPORTED);
+        } else {
+            mBluetoothManager = null;
+        }
+    }
+
+    private class BluetoothStateChangeReceiver extends BroadcastReceiver {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            TechnologyAvailabilityListener listener = getAvailabilityListener();
+            if (listener != null) {
+                listener.onAvailabilityChange(
+                        getAvailability(),
+                        CapabilitiesProvider.AvailabilityChangedReason.SYSTEM_POLICY);
+            }
+        }
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/cs/CsConfig.java b/ranging/service/java/com/android/server/ranging/cs/CsConfig.java
new file mode 100644
index 00000000..a0b3762b
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/cs/CsConfig.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.cs;
+
+import android.annotation.NonNull;
+import android.ranging.DataNotificationConfig;
+import android.ranging.RangingDevice;
+import android.ranging.RangingPreference;
+import android.ranging.ble.cs.CsRangingParams;
+
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.session.RangingSessionConfig.UnicastTechnologyConfig;
+
+public class CsConfig implements UnicastTechnologyConfig {
+    private static final String TAG = CsConfig.class.getSimpleName();
+
+    private final DataNotificationConfig mDataNotificationConfig;
+    private final CsRangingParams mRangingParams;
+
+    private final RangingDevice mPeerDevice;
+
+    @RangingPreference.DeviceRole
+    private final int mDeviceRole;
+
+    public CsConfig(int deviceRole,
+            CsRangingParams csRangingParams,
+            DataNotificationConfig dataNotificationConfig,
+            @NonNull RangingDevice peerDevice) {
+        mDeviceRole = deviceRole;
+        mRangingParams = csRangingParams;
+        mDataNotificationConfig = dataNotificationConfig;
+        mPeerDevice = peerDevice;
+    }
+
+    @Override
+    public @NonNull RangingTechnology getTechnology() {
+        return RangingTechnology.CS;
+    }
+
+    public DataNotificationConfig getDataNotificationConfig() {
+        return mDataNotificationConfig;
+    }
+
+    public CsRangingParams getRangingParams() {
+        return mRangingParams;
+    }
+
+    public int getDeviceRole() {
+        return mDeviceRole;
+    }
+
+    @Override
+    public @NonNull RangingDevice getPeerDevice() {
+        return mPeerDevice;
+    }
+
+    @Override
+    public String toString() {
+        return "CsConfig{ "
+                + "mDataNotificationConfig="
+                + mDataNotificationConfig
+                + ", mRangingParams="
+                + mRangingParams
+                + ", mDeviceRole="
+                + mDeviceRole
+                + ", mPeerDevice="
+                + mPeerDevice
+                + " }";
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/cs/CsOobCapabilities.java b/ranging/service/java/com/android/server/ranging/cs/CsOobCapabilities.java
new file mode 100644
index 00000000..8056dda0
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/cs/CsOobCapabilities.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.cs;
+
+import com.google.errorprone.annotations.DoNotCall;
+
+/** Channel Sounding Capability data send as part of CapabilityResponseMessage during Finder OOB. */
+public final class CsOobCapabilities {
+
+    private CsOobCapabilities() {
+    }
+
+    // // CS data
+    // // 2 byte bitmask bit 0 - standard, rest rfu
+    // private byte[] supportedFeatures;
+    // private boolean isDeviceBonded;
+    // // 16 bytes
+    // private byte[] confirmationHash;
+    // private boolean isRandmizerHashPresent;
+    // // 16 bytes if it exists
+    // private byte[] randmizerHash;
+    // // 7 bytes
+    // private byte[] deviceAddress;
+    // // 1 byte
+    // private int deviceRole;
+    // // 16 bytes
+    // private byte[] leTemporaryKey;
+    // // 2 bytes
+    // private byte[] leAppearance;
+    // private int discoveryMode;
+
+    /** Returns the size of this {@link CsOobCapabilities} object when serialized. */
+    @DoNotCall("Always throws UnsupportedOperationException.")
+    public int getSize() {
+        throw new UnsupportedOperationException("Not implemented");
+    }
+
+    /**
+     * Parses the given byte array and returns {@link CsOobCapabilities} object. Throws {@link
+     * IllegalArgumentException} on invalid input.
+     */
+    @DoNotCall("Always throws UnsupportedOperationException.")
+    public static CsOobCapabilities parseBytes(byte[] csCapabilitiesBytes) {
+        throw new UnsupportedOperationException("Not implemented");
+    }
+
+    /** Serializes this {@link CsOobCapabilities} object to bytes. */
+    @DoNotCall("Always throws UnsupportedOperationException.")
+    public byte[] toBytes() {
+        throw new UnsupportedOperationException("Not implemented");
+    }
+
+    @Override
+    public String toString() {
+        return "CsCapabilities{}";
+    }
+}
diff --git a/generic_ranging/src/com/android/ranging/fusion/DataFusers.java b/ranging/service/java/com/android/server/ranging/fusion/DataFusers.java
similarity index 88%
rename from generic_ranging/src/com/android/ranging/fusion/DataFusers.java
rename to ranging/service/java/com/android/server/ranging/fusion/DataFusers.java
index 1d67b84c..92824d6e 100644
--- a/generic_ranging/src/com/android/ranging/fusion/DataFusers.java
+++ b/ranging/service/java/com/android/server/ranging/fusion/DataFusers.java
@@ -14,12 +14,13 @@
  * limitations under the License.
  */
 
-package com.android.ranging.fusion;
+package com.android.server.ranging.fusion;
+
+import android.ranging.RangingData;
 
 import androidx.annotation.NonNull;
 
-import com.android.ranging.RangingData;
-import com.android.ranging.RangingTechnology;
+import com.android.server.ranging.RangingTechnology;
 
 import java.util.Optional;
 import java.util.Set;
@@ -29,7 +30,11 @@ public class DataFusers {
      * A data fuser that passes through all provided data as fused data.
      */
     public static class PassthroughDataFuser implements FusionEngine.DataFuser {
-
+        /**
+         * {@inheritDoc}
+         *
+         * @param sources is ignored
+         */
         @Override
         public Optional<RangingData> fuse(
                 @NonNull RangingData data, final @NonNull Set<RangingTechnology> sources
@@ -63,7 +68,7 @@ public class DataFusers {
                 @NonNull RangingData data, final @NonNull Set<RangingTechnology> sources
         ) {
             if (sources.contains(mPreferred)) {
-                if (data.getTechnology().isPresent() && mPreferred == data.getTechnology().get()) {
+                if (data.getRangingTechnology() == (int) mPreferred.getValue()) {
                     return Optional.of(data);
                 } else {
                     return Optional.empty();
diff --git a/generic_ranging/src/com/android/ranging/fusion/FilteringFusionEngine.java b/ranging/service/java/com/android/server/ranging/fusion/FilteringFusionEngine.java
similarity index 57%
rename from generic_ranging/src/com/android/ranging/fusion/FilteringFusionEngine.java
rename to ranging/service/java/com/android/server/ranging/fusion/FilteringFusionEngine.java
index 7055601f..e7d42d68 100644
--- a/generic_ranging/src/com/android/ranging/fusion/FilteringFusionEngine.java
+++ b/ranging/service/java/com/android/server/ranging/fusion/FilteringFusionEngine.java
@@ -14,16 +14,19 @@
  * limitations under the License.
  */
 
-package com.android.ranging.fusion;
+package com.android.server.ranging.fusion;
+
+import android.ranging.RangingData;
+import android.ranging.RangingMeasurement;
 
 import androidx.annotation.NonNull;
 
-import com.android.ranging.RangingData;
-import com.android.ranging.RangingTechnology;
+import com.android.server.ranging.RangingTechnology;
 import com.android.uwb.fusion.UwbFilterEngine;
 import com.android.uwb.fusion.math.SphericalVector;
 
 import java.util.EnumMap;
+import java.util.Optional;
 import java.util.Set;
 
 /**
@@ -63,34 +66,50 @@ public class FilteringFusionEngine extends FusionEngine {
 
     @Override
     public void feed(@NonNull RangingData data) {
-        if (data.getTechnology().isEmpty()) {
-            return;
-        }
+        Optional<RangingMeasurement> azimuth = Optional.ofNullable(data.getAzimuth());
+        Optional<RangingMeasurement> elevation = Optional.ofNullable(data.getElevation());
 
         SphericalVector.Annotated in = SphericalVector.fromRadians(
-                (float) data.getAzimuthRadians().orElse(0.0),
-                (float) data.getElevationRadians().orElse(0.0),
-                (float) data.getRangeMeters()
+                azimuth.map(RangingMeasurement::getMeasurement).orElse(0.0).floatValue(),
+                elevation.map(RangingMeasurement::getMeasurement).orElse(0.0).floatValue(),
+                (float) data.getDistance().getMeasurement()
         ).toAnnotated(
-                data.getAzimuthRadians().isPresent(),
-                data.getElevationRadians().isPresent(),
+                azimuth.isPresent(),
+                elevation.isPresent(),
                 true
         );
 
-        UwbFilterEngine engine = mFilters.get(data.getTechnology().get());
-        engine.add(in, data.getTimestamp().toMillis());
-        SphericalVector.Annotated out = engine.compute(data.getTimestamp().toMillis());
+        UwbFilterEngine engine = mFilters.get(
+                RangingTechnology.TECHNOLOGIES.get(data.getRangingTechnology()));
+        engine.add(in, data.getTimestampMillis());
+        SphericalVector.Annotated out = engine.compute(data.getTimestampMillis());
         if (out == null) {
             return;
         }
 
-        RangingData.Builder filteredData = RangingData.Builder.fromBuilt(data);
-        filteredData.setRangeDistance(out.distance);
-        if (data.getAzimuthRadians().isPresent()) {
-            filteredData.setAzimuthRadians(out.azimuth);
-        }
-        if (data.getElevationRadians().isPresent()) {
-            filteredData.setElevationRadians(out.elevation);
+        RangingData.Builder filteredData = new RangingData.Builder()
+                .setRangingTechnology(data.getRangingTechnology())
+                .setTimestampMillis(data.getTimestampMillis())
+                .setDistance(
+                        new RangingMeasurement.Builder()
+                                .setMeasurement(out.distance)
+                                .setConfidence(data.getDistance().getConfidence())
+                                .build()
+                );
+        azimuth.ifPresent(azimuthMeasure -> filteredData.setAzimuth(
+                new RangingMeasurement.Builder()
+                        .setMeasurement(out.azimuth)
+                        .setConfidence(azimuthMeasure.getConfidence())
+                        .build()
+        ));
+        elevation.ifPresent(elevationMeasure -> filteredData.setElevation(
+                new RangingMeasurement.Builder()
+                        .setMeasurement(out.elevation)
+                        .setConfidence(elevationMeasure.getConfidence())
+                        .build()
+        ));
+        if (data.hasRssi()) {
+            filteredData.setRssi(data.getRssi());
         }
 
         super.feed(filteredData.build());
diff --git a/generic_ranging/src/com/android/ranging/fusion/FusionEngine.java b/ranging/service/java/com/android/server/ranging/fusion/FusionEngine.java
similarity index 95%
rename from generic_ranging/src/com/android/ranging/fusion/FusionEngine.java
rename to ranging/service/java/com/android/server/ranging/fusion/FusionEngine.java
index 6753a54c..c0957422 100644
--- a/generic_ranging/src/com/android/ranging/fusion/FusionEngine.java
+++ b/ranging/service/java/com/android/server/ranging/fusion/FusionEngine.java
@@ -14,12 +14,13 @@
  * limitations under the License.
  */
 
-package com.android.ranging.fusion;
+package com.android.server.ranging.fusion;
+
+import android.ranging.RangingData;
 
 import androidx.annotation.NonNull;
 
-import com.android.ranging.RangingData;
-import com.android.ranging.RangingTechnology;
+import com.android.server.ranging.RangingTechnology;
 
 import java.util.Optional;
 import java.util.Set;
@@ -83,7 +84,8 @@ public abstract class FusionEngine {
     /**
      * Stop the fusion engine.
      */
-    public abstract void stop();
+    public void stop() {
+    }
 
     /**
      * Feed data to the engine.
diff --git a/ranging/service/java/com/android/server/ranging/oob/CapabilityRequestMessage.java b/ranging/service/java/com/android/server/ranging/oob/CapabilityRequestMessage.java
new file mode 100644
index 00000000..604f6ba1
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/oob/CapabilityRequestMessage.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.oob;
+
+import com.android.server.ranging.RangingTechnology;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableList;
+
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+/** The Capability Request Message Additional Data for Finder OOB. */
+@AutoValue
+public abstract class CapabilityRequestMessage {
+
+    // Size of capability specific payload.
+    private static final int CAPABILITY_SIZE_BYTES = 2;
+
+    /**
+     * Parses the given byte array and returns {@link CapabilityRequestMessage} object. Throws
+     * {@link
+     * IllegalArgumentException} on invalid input.
+     */
+    public static CapabilityRequestMessage parseBytes(byte[] payload) {
+        OobHeader header = OobHeader.parseBytes(payload);
+
+        if (payload.length < header.getSize() + CAPABILITY_SIZE_BYTES) {
+            throw new IllegalArgumentException(
+                    String.format("CapabilityRequestMessage payload size is %d bytes",
+                            payload.length));
+        }
+
+        int parseCursor = header.getSize();
+        byte[] capabilityBytes =
+                Arrays.copyOfRange(payload, parseCursor, parseCursor + CAPABILITY_SIZE_BYTES);
+        ImmutableList<RangingTechnology> rangingTechnologies =
+                RangingTechnology.fromBitmap(capabilityBytes);
+
+        return builder().setHeader(header).setRequestedRangingTechnologies(
+                rangingTechnologies).build();
+    }
+
+    /** Serializes this {@link CapabilityRequestMessage} object to bytes. */
+    public final byte[] toBytes() {
+        int size = CAPABILITY_SIZE_BYTES + getHeader().getSize();
+        ByteBuffer byteBuffer = ByteBuffer.allocate(size);
+        byteBuffer
+                .put(getHeader().toBytes())
+                .put(RangingTechnology.toBitmap(getRequestedRangingTechnologies()));
+        return byteBuffer.array();
+    }
+
+    /** Returns the OOB header. */
+    public abstract OobHeader getHeader();
+
+    /** Returns a list of ranging technologies for which capabilities are requested. */
+    public abstract ImmutableList<RangingTechnology> getRequestedRangingTechnologies();
+
+    /** Returns a builder for {@link CapabilityRequestMessage}. */
+    public static Builder builder() {
+        return new AutoValue_CapabilityRequestMessage.Builder();
+    }
+
+    /** Builder for {@link CapabilityRequestMessage}. */
+    @AutoValue.Builder
+    public abstract static class Builder {
+        public abstract Builder setRequestedRangingTechnologies(
+                ImmutableList<RangingTechnology> requestedRangingTechnologies);
+
+        public abstract Builder setHeader(OobHeader header);
+
+        public abstract CapabilityRequestMessage build();
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/oob/CapabilityResponseMessage.java b/ranging/service/java/com/android/server/ranging/oob/CapabilityResponseMessage.java
new file mode 100644
index 00000000..c07ad8c7
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/oob/CapabilityResponseMessage.java
@@ -0,0 +1,192 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.oob;
+
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.cs.CsOobCapabilities;
+import com.android.server.ranging.uwb.UwbOobCapabilities;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Sets;
+
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+import javax.annotation.Nullable;
+
+/** The Capability Response Message Additional Data for Finder OOB. */
+@AutoValue
+public abstract class CapabilityResponseMessage {
+
+    // Size of properties in bytes when serialized.
+    private static final int MIN_SIZE_BYTES = 2;
+
+    private static final int RANGING_TECHNOLOGIES_SIZE_BYTES = 2;
+
+    /**
+     * Parses the given byte array and returns {@link CapabilityResponseMessage} object. Throws
+     * {@link
+     * IllegalArgumentException} on invalid input.
+     */
+    public static CapabilityResponseMessage parseBytes(byte[] payload) {
+        OobHeader header = OobHeader.parseBytes(payload);
+
+        if (payload.length < header.getSize() + MIN_SIZE_BYTES) {
+            throw new IllegalArgumentException(
+                    String.format("CapabilityResponseMessage payload size is %d bytes",
+                            payload.length));
+        }
+
+        int parseCursor = header.getSize();
+
+        // Parse ranging technologies bitfield
+        byte[] rangingTechnologiesBytes =
+                Arrays.copyOfRange(payload, parseCursor,
+                        parseCursor + RANGING_TECHNOLOGIES_SIZE_BYTES);
+        ImmutableList<RangingTechnology> rangingTechnologies =
+                RangingTechnology.fromBitmap(rangingTechnologiesBytes);
+        parseCursor += RANGING_TECHNOLOGIES_SIZE_BYTES;
+
+        // Parse Capability data for different ranging technologies
+        UwbOobCapabilities uwbCapabilities = null;
+        CsOobCapabilities csCapabilities = null;
+        ImmutableList.Builder<RangingTechnology> rangingTechnologiesPriority =
+                ImmutableList.builder();
+        int countTechsParsed = 0;
+        while (parseCursor < payload.length && countTechsParsed++ < rangingTechnologies.size()) {
+            byte[] remainingBytes = Arrays.copyOfRange(payload, parseCursor, payload.length);
+            TechnologyHeader techHeader = TechnologyHeader.parseBytes(remainingBytes);
+            switch (techHeader.getRangingTechnology()) {
+                case UWB:
+                    uwbCapabilities = UwbOobCapabilities.parseBytes(remainingBytes);
+                    parseCursor += techHeader.getSize();
+                    rangingTechnologiesPriority.add(RangingTechnology.UWB);
+
+                    break;
+                default:
+                    rangingTechnologiesPriority.add(techHeader.getRangingTechnology());
+                    parseCursor += techHeader.getSize();
+                    break;
+            }
+        }
+
+        return CapabilityResponseMessage.builder()
+                .setHeader(header)
+                .setSupportedRangingTechnologies(rangingTechnologies)
+                .setUwbCapabilities(uwbCapabilities)
+                .setCsCapabilities(csCapabilities)
+                .setRangingTechnologiesPriority(rangingTechnologiesPriority.build())
+                .build();
+    }
+
+    /** Serializes this {@link CapabilityResponseMessage} object to bytes. */
+    public final byte[] toBytes() {
+        int size = MIN_SIZE_BYTES + getHeader().getSize();
+        if (getUwbCapabilities() != null) {
+            size += UwbOobCapabilities.getSize();
+        }
+        ByteBuffer byteBuffer = ByteBuffer.allocate(size);
+        byteBuffer
+                .put(getHeader().toBytes())
+                .put(RangingTechnology.toBitmap(getSupportedRangingTechnologies()));
+        for (RangingTechnology tech : getRangingTechnologiesPriority()) {
+            switch (tech) {
+                case UWB:
+                    UwbOobCapabilities uwbCapabilities = getUwbCapabilities();
+                    if (uwbCapabilities != null) {
+                        byteBuffer.put(uwbCapabilities.toBytes());
+                    }
+                    break;
+                default:
+                    throw new UnsupportedOperationException("Not implemented");
+            }
+        }
+        return byteBuffer.array();
+    }
+
+    /** Returns the OOB header. */
+    public abstract OobHeader getHeader();
+
+    /** Returns the supported ranging technologies. */
+    public abstract ImmutableList<RangingTechnology> getSupportedRangingTechnologies();
+
+    /**
+     * Returns the priority of requested ranging technologies, with earlier items in the list being
+     * of
+     * higher priority.
+     */
+    public abstract ImmutableList<RangingTechnology> getRangingTechnologiesPriority();
+
+    /** Returns an Optional of UWB capability data. */
+    @Nullable
+    public abstract UwbOobCapabilities getUwbCapabilities();
+
+    /** Returns an Optional of CS capability data. */
+    @Nullable
+    public abstract CsOobCapabilities getCsCapabilities();
+
+    /** Returns a builder for {@link CapabilityResponseMessage}. */
+    public static Builder builder() {
+        return new AutoValue_CapabilityResponseMessage.Builder()
+                .setRangingTechnologiesPriority(ImmutableList.of());
+    }
+
+    /** Builder for {@link CapabilityResponseMessage}. */
+    @AutoValue.Builder
+    public abstract static class Builder {
+
+        public abstract Builder setHeader(OobHeader header);
+
+        public abstract Builder setSupportedRangingTechnologies(
+                ImmutableList<RangingTechnology> rangingTechnologies);
+
+        public abstract Builder setUwbCapabilities(@Nullable UwbOobCapabilities uwbCapabilities);
+
+        public abstract Builder setCsCapabilities(@Nullable CsOobCapabilities csCapabilities);
+
+        public abstract Builder setRangingTechnologiesPriority(
+                ImmutableList<RangingTechnology> rangingTechnologiesPriority
+        );
+
+        abstract CapabilityResponseMessage autoBuild();
+
+        public final CapabilityResponseMessage build() {
+            CapabilityResponseMessage capabilityResponseMessage = autoBuild();
+            Preconditions.checkArgument(
+                    (capabilityResponseMessage
+                            .getRangingTechnologiesPriority()
+                            .contains(RangingTechnology.UWB)
+                            == (capabilityResponseMessage.getUwbCapabilities() != null)),
+                    "Priority list doesn't match UWB capabilities set.");
+            Preconditions.checkArgument(
+                    (capabilityResponseMessage.getRangingTechnologiesPriority().contains(
+                            RangingTechnology.CS)
+                            == (capabilityResponseMessage.getCsCapabilities() != null)),
+                    "Priority list doesn't match CS capabilities set.");
+            Preconditions.checkArgument(
+                    capabilityResponseMessage.getRangingTechnologiesPriority().size()
+                            == Sets.newEnumSet(
+                                    capabilityResponseMessage.getRangingTechnologiesPriority(),
+                                    RangingTechnology.class)
+                            .size(),
+                    "Priority list contains duplicates.");
+            return capabilityResponseMessage;
+        }
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/oob/MessageType.java b/ranging/service/java/com/android/server/ranging/oob/MessageType.java
new file mode 100644
index 00000000..6758dcb6
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/oob/MessageType.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.oob;
+
+/** Enum representing a message type of the OOB message. */
+public enum MessageType {
+    CAPABILITY_REQUEST(0),
+    CAPABILITY_RESPONSE(1),
+    SET_CONFIGURATION(2),
+    SET_CONFIGURATION_RESPONSE(3),
+    START_RANGING(4),
+    START_RANGING_RESPONSE(5),
+    STOP_RANGING(6),
+    STOP_RANGING_RESPONSE(7),
+    UNKNOWN(8);
+
+    private final int mValue;
+
+    MessageType(int value) {
+        this.mValue = value;
+    }
+
+    public int getValue() {
+        return mValue;
+    }
+
+    public byte toByte() {
+        return (byte) mValue;
+    }
+
+    public static MessageType parseByte(byte messageId) {
+        if (messageId > 8) {
+            return UNKNOWN;
+        }
+        return MessageType.values()[messageId];
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/oob/OobHandler.java b/ranging/service/java/com/android/server/ranging/oob/OobHandler.java
new file mode 100644
index 00000000..3b0210f2
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/oob/OobHandler.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.oob;
+
+import android.ranging.oob.OobHandle;
+
+public interface OobHandler {
+    void handleOobMessage(OobHandle oobHandle, byte[] data);
+
+    void handleOobDeviceDisconnected(OobHandle oobHandle);
+
+    void handleOobDeviceReconnected(OobHandle oobHandle);
+
+    void handleOobClosed(OobHandle oobHandle);
+}
diff --git a/ranging/service/java/com/android/server/ranging/oob/OobHeader.java b/ranging/service/java/com/android/server/ranging/oob/OobHeader.java
new file mode 100644
index 00000000..159e0778
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/oob/OobHeader.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.oob;
+
+import com.google.auto.value.AutoValue;
+
+/** Header for OOB messages. */
+@AutoValue
+public abstract class OobHeader {
+
+    private static final int SIZE_BYTES = 2;
+
+    public static OobHeader parseBytes(byte[] payload) {
+        if (payload.length < SIZE_BYTES) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "Header is too short, expected at least %d bytes, got %d",
+                            SIZE_BYTES, payload.length));
+        }
+
+        int parseCursor = 0;
+        int version = payload[parseCursor++];
+        MessageType messageType = MessageType.parseByte(payload[parseCursor++]);
+        return builder().setVersion(version).setMessageType(messageType).build();
+    }
+
+    public byte[] toBytes() {
+        byte[] payload = new byte[SIZE_BYTES];
+        int parseCursor = 0;
+        payload[parseCursor++] = (byte) getVersion();
+        payload[parseCursor++] = (byte) getMessageType().getValue();
+        return payload;
+    }
+
+    public int getSize() {
+        return SIZE_BYTES;
+    }
+
+    /** Returns the version. */
+    public abstract int getVersion();
+
+    /** Returns the message type. */
+    public abstract MessageType getMessageType();
+
+    /** Returns a builder for {@link OobHeader}. */
+    public static Builder builder() {
+        return new AutoValue_OobHeader.Builder();
+    }
+
+    /** Builder for {@link OobHeader}. */
+    @AutoValue.Builder
+    public abstract static class Builder {
+        public abstract Builder setVersion(int version);
+
+        public abstract Builder setMessageType(MessageType messageType);
+
+        public abstract OobHeader build();
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/oob/SetConfigurationMessage.java b/ranging/service/java/com/android/server/ranging/oob/SetConfigurationMessage.java
new file mode 100644
index 00000000..0b1ec591
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/oob/SetConfigurationMessage.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.oob;
+
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.uwb.UwbOobConfig;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Preconditions;
+import com.google.common.collect.ImmutableList;
+
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+import javax.annotation.Nullable;
+
+/** The Set Configuration Message Additional Data for Finder OOB. */
+@AutoValue
+public abstract class SetConfigurationMessage {
+
+    // Size in bytes of properties when serialized.
+    private static final int MIN_SIZE_BYTES = 4;
+    private static final int RANGING_TECHNOLOGIES_SET_SIZE = 2;
+    private static final int START_RANGING_LIST_SIZE = 2;
+
+    /**
+     * Parses the given byte array and returns {@link SetConfigurationMessage} object. Throws {@link
+     * IllegalArgumentException} on invalid input.
+     */
+    public static SetConfigurationMessage parseBytes(byte[] payload) {
+        OobHeader header = OobHeader.parseBytes(payload);
+
+        if (payload.length < header.getSize() + MIN_SIZE_BYTES) {
+            throw new IllegalArgumentException(
+                    String.format("CapabilityResponseMessage payload size is %d bytes",
+                            payload.length));
+        }
+
+        int parseCursor = header.getSize();
+
+        // Parse Ranging Technologies Set
+        var rangingTechnologiesSet =
+                RangingTechnology.fromBitmap(
+                        Arrays.copyOfRange(payload, parseCursor,
+                                parseCursor + RANGING_TECHNOLOGIES_SET_SIZE));
+        parseCursor += RANGING_TECHNOLOGIES_SET_SIZE;
+
+        // Parse Start Ranging List
+        var startRangingList =
+                RangingTechnology.fromBitmap(
+                        Arrays.copyOfRange(payload, parseCursor,
+                                parseCursor + START_RANGING_LIST_SIZE));
+        parseCursor += START_RANGING_LIST_SIZE;
+
+        // Parse Configs for ranging technologies that are set
+        UwbOobConfig uwbConfig = null;
+        int countTechsParsed = 0;
+        while (parseCursor < payload.length && countTechsParsed++ < rangingTechnologiesSet.size()) {
+            byte[] remainingBytes = Arrays.copyOfRange(payload, parseCursor, payload.length);
+            TechnologyHeader techHeader = TechnologyHeader.parseBytes(remainingBytes);
+            switch (techHeader.getRangingTechnology()) {
+                case UWB:
+                    if (uwbConfig != null) {
+                        throw new IllegalArgumentException(
+                                "Failed to parse SetConfigurationMessage, UwbConfig already set. "
+                                        + "Bytes:"
+                                        + Arrays.toString(payload));
+                    }
+                    uwbConfig = UwbOobConfig.parseBytes(remainingBytes);
+                    parseCursor += uwbConfig.getSize();
+                    break;
+                default:
+                    parseCursor += techHeader.getSize();
+            }
+        }
+
+        return builder()
+                .setHeader(header)
+                .setRangingTechnologiesSet(rangingTechnologiesSet)
+                .setStartRangingList(startRangingList)
+                .setUwbConfig(uwbConfig)
+                .build();
+    }
+
+    /** Serializes this {@link SetConfigurationMessage} object to bytes. */
+    public final byte[] toBytes() {
+        int size = MIN_SIZE_BYTES + getHeader().getSize();
+        UwbOobConfig uwbConfig = getUwbConfig();
+        if (uwbConfig != null) {
+            size += uwbConfig.getSize();
+        }
+        ByteBuffer byteBuffer = ByteBuffer.allocate(size);
+        byteBuffer
+                .put(getHeader().toBytes())
+                .put(RangingTechnology.toBitmap(getRangingTechnologiesSet()))
+                .put(RangingTechnology.toBitmap(getStartRangingList()));
+        if (uwbConfig != null) {
+            byteBuffer.put(uwbConfig.toBytes());
+        }
+        return byteBuffer.array();
+    }
+
+    /** Returns the OOB header. */
+    public abstract OobHeader getHeader();
+
+    /** Returns a list of ranging technologies that are set as part of this message. */
+    public abstract ImmutableList<RangingTechnology> getRangingTechnologiesSet();
+
+    /**
+     * Returns a list of ranging technologies that should start ranging as soon as this message is
+     * received.
+     */
+    public abstract ImmutableList<RangingTechnology> getStartRangingList();
+
+    /** Returns @Nullable UwbConfig data that should be used to configure UWB ranging session. */
+    @Nullable
+    public abstract UwbOobConfig getUwbConfig();
+
+    /** Returns a builder for {@link SetConfigurationMessage}. */
+    public static Builder builder() {
+        return new AutoValue_SetConfigurationMessage.Builder()
+                .setRangingTechnologiesSet(ImmutableList.of())
+                .setStartRangingList(ImmutableList.of());
+    }
+
+    /** Builder for {@link SetConfigurationMessage}. */
+    @AutoValue.Builder
+    public abstract static class Builder {
+
+        public abstract Builder setHeader(OobHeader header);
+
+        public abstract Builder setRangingTechnologiesSet(
+                ImmutableList<RangingTechnology> rangingTechnologiesSet);
+
+        public abstract Builder setStartRangingList(
+                ImmutableList<RangingTechnology> startRangingList);
+
+        public abstract Builder setUwbConfig(@Nullable UwbOobConfig uwbConfig);
+
+        abstract SetConfigurationMessage autoBuild();
+
+        public SetConfigurationMessage build() {
+            SetConfigurationMessage setConfigurationMessage = autoBuild();
+            Preconditions.checkArgument(
+                    setConfigurationMessage
+                            .getRangingTechnologiesSet()
+                            .containsAll(setConfigurationMessage.getStartRangingList()),
+                    "startRangingList contains items that are not in rangingTechnologiesSet list.");
+            Preconditions.checkArgument(
+                    setConfigurationMessage
+                            .getRangingTechnologiesSet()
+                            .contains(RangingTechnology.UWB)
+                            == (setConfigurationMessage.getUwbConfig() != null),
+                    "UwbConfig or rangingTechnologiesSet for UWB not set properly.");
+            return setConfigurationMessage;
+        }
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/oob/StartRangingMessage.java b/ranging/service/java/com/android/server/ranging/oob/StartRangingMessage.java
new file mode 100644
index 00000000..52a8530e
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/oob/StartRangingMessage.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.oob;
+
+import com.android.server.ranging.RangingTechnology;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableList;
+
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+/** The Start Ranging Message Additional Data for Finder OOB. */
+@AutoValue
+public abstract class StartRangingMessage {
+
+    // Size in bytes when serialized
+    private static final int SIZE_IN_BYTES = 2;
+
+    /**
+     * Parses the given byte array and returns {@link StartRangingMessage} object. Throws {@link
+     * IllegalArgumentException} on invalid input.
+     */
+    public static StartRangingMessage parseBytes(byte[] payload) {
+        OobHeader header = OobHeader.parseBytes(payload);
+
+        if (payload.length < header.getSize() + SIZE_IN_BYTES) {
+            throw new IllegalArgumentException(
+                    String.format("StartRangingMessage payload size is %d bytes", payload.length));
+        }
+
+        int parseCursor = header.getSize();
+        ImmutableList<RangingTechnology> rangingTechnologiesToStart =
+                RangingTechnology.fromBitmap(
+                        Arrays.copyOfRange(payload, parseCursor, parseCursor + SIZE_IN_BYTES));
+
+        return builder()
+                .setOobHeader(header)
+                .setRangingTechnologiesToStart(rangingTechnologiesToStart)
+                .build();
+    }
+
+    /** Serializes this {@link StartRangingMessage} object to bytes. */
+    public final byte[] toBytes() {
+        int size = SIZE_IN_BYTES + getOobHeader().getSize();
+        ByteBuffer byteBuffer = ByteBuffer.allocate(size);
+        byteBuffer
+                .put(getOobHeader().toBytes())
+                .put(RangingTechnology.toBitmap(getRangingTechnologiesToStart()));
+        return byteBuffer.array();
+    }
+
+    /** Returns the OOB header. */
+    public abstract OobHeader getOobHeader();
+
+    /** Returns a list of ranging technologies that should start ranging. */
+    public abstract ImmutableList<RangingTechnology> getRangingTechnologiesToStart();
+
+    /** Returns a builder for {@link StartRangingMessage}. */
+    public static Builder builder() {
+        return new AutoValue_StartRangingMessage.Builder();
+    }
+
+    /** Builder for {@link StartRangingMessage}. */
+    @AutoValue.Builder
+    public abstract static class Builder {
+        public abstract Builder setOobHeader(OobHeader oobHeader);
+
+        public abstract Builder setRangingTechnologiesToStart(
+                ImmutableList<RangingTechnology> rangingTechnologiesToStart);
+
+        public abstract StartRangingMessage build();
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/oob/StatusResponseMessage.java b/ranging/service/java/com/android/server/ranging/oob/StatusResponseMessage.java
new file mode 100644
index 00000000..0b3322b4
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/oob/StatusResponseMessage.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.oob;
+
+import com.android.server.ranging.RangingTechnology;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableList;
+
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+/**
+ * Represents a response message for set configuration, start ranging, and stop ranging requests.
+ * The response is a bitmap of the status for the requested action for each technology.
+ */
+@AutoValue
+public abstract class StatusResponseMessage {
+
+    // Size in bytes when serialized
+    private static final int SIZE_IN_BYTES = 2;
+
+    /**
+     * Parses the given byte array and returns {@link StatusResponseMessage} object. Throws {@link
+     * IllegalArgumentException} on invalid input.
+     */
+    public static StatusResponseMessage parseBytes(byte[] payload) {
+        OobHeader header = OobHeader.parseBytes(payload);
+
+        if (payload.length < header.getSize() + SIZE_IN_BYTES) {
+            throw new IllegalArgumentException(
+                    String.format("StatusResponseMessage payload size is %d bytes",
+                            payload.length));
+        }
+
+        int parseCursor = header.getSize();
+        ImmutableList<RangingTechnology> rangingTechnologiesStatus =
+                RangingTechnology.fromBitmap(
+                        Arrays.copyOfRange(payload, parseCursor, parseCursor + SIZE_IN_BYTES));
+
+        return builder()
+                .setOobHeader(header)
+                .setSuccessfulRangingTechnologies(rangingTechnologiesStatus)
+                .build();
+    }
+
+    /** Serializes this {@link StatusResponseMessage} object to bytes. */
+    public final byte[] toBytes() {
+        int size = SIZE_IN_BYTES + getOobHeader().getSize();
+        ByteBuffer byteBuffer = ByteBuffer.allocate(size);
+        byteBuffer
+                .put(getOobHeader().toBytes())
+                .put(RangingTechnology.toBitmap(getSuccessfulRangingTechnologies()));
+        return byteBuffer.array();
+    }
+
+    /** Returns the OOB header. */
+    public abstract OobHeader getOobHeader();
+
+    /** Returns a list of the status of the requested action for each Ranging Technology. */
+    public abstract ImmutableList<RangingTechnology> getSuccessfulRangingTechnologies();
+
+    /** Returns a builder for {@link StatusResponseMessage}. */
+    public static Builder builder() {
+        return new AutoValue_StatusResponseMessage.Builder();
+    }
+
+    public abstract Builder toBuilder();
+
+    /** Builder for {@link StatusResponseMessage}. */
+    @AutoValue.Builder
+    public abstract static class Builder {
+        public abstract Builder setOobHeader(OobHeader oobHeader);
+
+        public abstract Builder setSuccessfulRangingTechnologies(
+                ImmutableList<RangingTechnology> successfulRangingTechnologies);
+
+        public abstract StatusResponseMessage build();
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/oob/StopRangingMessage.java b/ranging/service/java/com/android/server/ranging/oob/StopRangingMessage.java
new file mode 100644
index 00000000..5b441067
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/oob/StopRangingMessage.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.oob;
+
+import com.android.server.ranging.RangingTechnology;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableList;
+
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+/** The Stop Ranging Message Additional Data for Finder OOB. */
+@AutoValue
+public abstract class StopRangingMessage {
+
+    // Size in bytes when serialized
+    private static final int SIZE_IN_BYTES = 2;
+
+    /**
+     * Parses the given byte array and returns {@link StopRangingMessage} object. Throws {@link
+     * IllegalArgumentException} on invalid input.
+     */
+    public static StopRangingMessage parseBytes(byte[] payload) {
+        OobHeader header = OobHeader.parseBytes(payload);
+
+        if (payload.length < header.getSize() + SIZE_IN_BYTES) {
+            throw new IllegalArgumentException(
+                    String.format("StopRangingMessage payload size is %d bytes", payload.length));
+        }
+
+        int parseCursor = header.getSize();
+        ImmutableList<RangingTechnology> rangingTechnologiesToStop =
+                RangingTechnology.fromBitmap(
+                        Arrays.copyOfRange(payload, parseCursor, parseCursor + SIZE_IN_BYTES));
+
+        return builder()
+                .setOobHeader(header)
+                .setRangingTechnologiesToStop(rangingTechnologiesToStop)
+                .build();
+    }
+
+    /** Serializes this {@link StopRangingMessage} object to bytes. */
+    public final byte[] toBytes() {
+        int size = SIZE_IN_BYTES + getOobHeader().getSize();
+        ByteBuffer byteBuffer = ByteBuffer.allocate(size);
+        byteBuffer
+                .put(getOobHeader().toBytes())
+                .put(RangingTechnology.toBitmap(getRangingTechnologiesToStop()));
+        return byteBuffer.array();
+    }
+
+    /** Returns the OOB header. */
+    public abstract OobHeader getOobHeader();
+
+    /** Returns a list of ranging technologies that should stop ranging. */
+    public abstract ImmutableList<RangingTechnology> getRangingTechnologiesToStop();
+
+    /** Returns a builder for {@link StopRangingMessage}. */
+    public static Builder builder() {
+        return new AutoValue_StopRangingMessage.Builder();
+    }
+
+    /** Builder for {@link StopRangingMessage}. */
+    @AutoValue.Builder
+    public abstract static class Builder {
+        public abstract Builder setOobHeader(OobHeader oobHeader);
+
+        public abstract Builder setRangingTechnologiesToStop(
+                ImmutableList<RangingTechnology> rangingTechnologiesToStop);
+
+        public abstract StopRangingMessage build();
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/oob/TechnologyHeader.java b/ranging/service/java/com/android/server/ranging/oob/TechnologyHeader.java
new file mode 100644
index 00000000..442ab132
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/oob/TechnologyHeader.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.oob;
+
+import com.android.server.ranging.RangingTechnology;
+
+import com.google.auto.value.AutoValue;
+
+/** Header for individual technology capability. */
+@AutoValue
+public abstract class TechnologyHeader {
+
+    public static final int SIZE_BYTES = 2;
+
+    public static TechnologyHeader parseBytes(byte[] payload) {
+        if (payload.length < SIZE_BYTES) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "Header is too short, expected at least %d bytes, got %d",
+                            SIZE_BYTES, payload.length));
+        }
+
+        int parseCursor = 0;
+        RangingTechnology rangingTechnology =
+                RangingTechnology.TECHNOLOGIES.get(payload[parseCursor++]);
+        int size = payload[parseCursor++];
+
+        return builder().setRangingTechnology(rangingTechnology).setSize(size).build();
+    }
+
+    public byte[] toBytes() {
+        byte[] payload = new byte[SIZE_BYTES];
+        int parseCursor = 0;
+        payload[parseCursor++] = getRangingTechnology().toByte();
+        payload[parseCursor++] = (byte) getSize();
+        return payload;
+    }
+
+    public int getHeaderSize() {
+        return SIZE_BYTES;
+    }
+
+    /** Returns the version. */
+    public abstract RangingTechnology getRangingTechnology();
+
+    /** Returns the message type. */
+    public abstract int getSize();
+
+    /** Returns a builder for {@link TechnologyHeader}. */
+    public static Builder builder() {
+        return new AutoValue_TechnologyHeader.Builder();
+    }
+
+    /** Builder for {@link TechnologyHeader}. */
+    @AutoValue.Builder
+    public abstract static class Builder {
+        public abstract Builder setSize(int size);
+
+        public abstract Builder setRangingTechnology(RangingTechnology rangingTechnology);
+
+        public abstract TechnologyHeader build();
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/rtt/RttAdapter.java b/ranging/service/java/com/android/server/ranging/rtt/RttAdapter.java
new file mode 100644
index 00000000..76b4f55d
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/rtt/RttAdapter.java
@@ -0,0 +1,243 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.rtt;
+
+import static android.ranging.RangingPreference.DEVICE_ROLE_INITIATOR;
+
+import android.content.Context;
+import android.ranging.RangingData;
+import android.ranging.RangingDevice;
+import android.ranging.RangingManager;
+import android.ranging.RangingMeasurement;
+import android.ranging.RangingPreference;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+
+import com.android.ranging.rtt.backend.internal.RttDevice;
+import com.android.ranging.rtt.backend.internal.RttRangingDevice;
+import com.android.ranging.rtt.backend.internal.RttRangingPosition;
+import com.android.ranging.rtt.backend.internal.RttRangingSessionCallback;
+import com.android.ranging.rtt.backend.internal.RttService;
+import com.android.ranging.rtt.backend.internal.RttServiceImpl;
+import com.android.server.ranging.RangingAdapter;
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.RangingUtils.StateMachine;
+import com.android.server.ranging.session.RangingSessionConfig;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.util.concurrent.FutureCallback;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListeningExecutorService;
+
+import java.util.concurrent.Executors;
+
+/** Ranging adapter for WiFi Round-To-Trip(RTT). */
+public class RttAdapter implements RangingAdapter {
+
+    private static final String TAG = RttAdapter.class.getSimpleName();
+
+    private final RttService mRttService;
+    private final RttRangingDevice mRttClient;
+    private final ListeningExecutorService mExecutorService;
+    private final ExecutorResultHandlers mRttClientResultHandlers = new ExecutorResultHandlers();
+    private final RttRangingSessionCallback mRttListener = new RttListener();
+    private final StateMachine<State> mStateMachine;
+
+    /** Invariant: non-null while a ranging session is active */
+    private Callback mCallbacks;
+    /** Invariant: non-null while a ranging session is active */
+    private RangingDevice mPeerDevice;
+
+    public RttAdapter(
+            @NonNull Context context, @NonNull ListeningExecutorService executorService,
+            @RangingPreference.DeviceRole int role
+    ) {
+        this(context, executorService, new RttServiceImpl(context), role);
+    }
+
+    @VisibleForTesting
+    public RttAdapter(@NonNull Context context, @NonNull ListeningExecutorService executorService,
+            @NonNull RttService rttService, @RangingPreference.DeviceRole int role) {
+        if (!RttCapabilitiesAdapter.isSupported(context)) {
+            throw new IllegalArgumentException("WiFi RTT system feature not found.");
+        }
+
+        mStateMachine = new StateMachine<>(State.STOPPED);
+        mRttService = rttService;
+        mRttClient = role == DEVICE_ROLE_INITIATOR
+                ? mRttService.getSubscriber(context)
+                : mRttService.getPublisher(context);
+
+        mExecutorService = executorService;
+        mCallbacks = null;
+        mPeerDevice = null;
+    }
+
+    @Override
+    public @NonNull RangingTechnology getTechnology() {
+        return RangingTechnology.RTT;
+    }
+
+    @Override
+    public void start(
+            @NonNull RangingSessionConfig.TechnologyConfig config, @NonNull Callback callbacks
+    ) {
+        Log.i(TAG, "Start called.");
+        if (!mStateMachine.transition(State.STOPPED, State.STARTED)) {
+            Log.v(TAG, "Attempted to start adapter when it was already started");
+            return;
+        }
+
+        mCallbacks = callbacks;
+        if (!(config instanceof RttConfig rttConfig)) {
+            Log.w(TAG, "Tried to start adapter with invalid ranging parameters");
+            closeForReason(Callback.ClosedReason.FAILED_TO_START);
+            return;
+        }
+        mPeerDevice = rttConfig.getPeerDevice();
+        mRttClient.setRangingParameters(rttConfig.asBackendParameters());
+
+        var future = Futures.submit(() -> {
+            mRttClient.startRanging(mRttListener, Executors.newSingleThreadExecutor());
+        }, mExecutorService);
+        Futures.addCallback(future, mRttClientResultHandlers.startRanging, mExecutorService);
+    }
+
+    @Override
+    public void stop() {
+        Log.i(TAG, "Stop called.");
+        if (!mStateMachine.transition(State.STARTED, State.STOPPED)) {
+            Log.v(TAG, "Attempted to stop adapter when it was already stopped");
+            return;
+        }
+
+        var future = Futures.submit(mRttClient::stopRanging, mExecutorService);
+        Futures.addCallback(future, mRttClientResultHandlers.stopRanging, mExecutorService);
+    }
+
+
+    private class RttListener implements RttRangingSessionCallback {
+        @Override
+        public void onRangingInitialized(RttDevice device) {
+            Log.i(TAG, "onRangingInitialized");
+            synchronized (mStateMachine) {
+                if (mStateMachine.getState() == State.STARTED) {
+                    mCallbacks.onStarted(mPeerDevice);
+                }
+            }
+        }
+
+        @Override
+        public void onRangingResult(RttDevice peer, RttRangingPosition position) {
+            RangingData.Builder dataBuilder = new RangingData.Builder()
+                    .setRangingTechnology(RangingManager.WIFI_NAN_RTT)
+                    .setDistance(new RangingMeasurement.Builder()
+                            .setMeasurement(position.getDistance())
+                            .build())
+                    .setRssi(position.getRssiDbm())
+                    .setTimestampMillis(position.getRangingTimestampMillis());
+
+            if (position.getAzimuth() != null) {
+                dataBuilder.setAzimuth(new RangingMeasurement.Builder()
+                        .setMeasurement(position.getAzimuth().getValue())
+                        .build());
+            }
+            if (position.getElevation() != null) {
+                dataBuilder.setElevation(new RangingMeasurement.Builder()
+                        .setMeasurement(position.getElevation().getValue())
+                        .build());
+            }
+            synchronized (mStateMachine) {
+                if (mStateMachine.getState() == State.STARTED) {
+                    mCallbacks.onRangingData(mPeerDevice, dataBuilder.build());
+                }
+            }
+        }
+
+        private static int convertReason(int reason) {
+            switch (reason) {
+                case REASON_WRONG_PARAMETERS:
+                case REASON_FAILED_TO_START:
+                    return Callback.ClosedReason.FAILED_TO_START;
+                case REASON_STOPPED_BY_PEER:
+                case REASON_STOP_RANGING_CALLED:
+                    return Callback.ClosedReason.REQUESTED;
+                case REASON_MAX_RANGING_ROUND_RETRY_REACHED:
+                    return Callback.ClosedReason.LOST_CONNECTION;
+                case REASON_SYSTEM_POLICY:
+                    return Callback.ClosedReason.SYSTEM_POLICY;
+                default:
+                    return Callback.ClosedReason.UNKNOWN;
+            }
+        }
+
+        @Override
+        public void onRangingSuspended(RttDevice localDevice, int reason) {
+            Log.i(TAG, "onRangingSuspended: " + reason);
+            closeForReason(convertReason(reason));
+        }
+    }
+
+    /** Close the session, disconnecting the peer and resetting internal state. */
+    private void closeForReason(@Callback.ClosedReason int reason) {
+        synchronized (mStateMachine) {
+            mStateMachine.setState(State.STOPPED);
+            mCallbacks.onStopped(mPeerDevice);
+            mCallbacks.onClosed(reason);
+            clear();
+        }
+    }
+
+    private void clear() {
+        mRttClient.stopRanging();
+        mCallbacks = null;
+        mPeerDevice = null;
+    }
+
+    public enum State {
+        STARTED,
+        STOPPED,
+    }
+
+    private class ExecutorResultHandlers {
+        public final FutureCallback<Void> startRanging = new FutureCallback<>() {
+            @Override
+            public void onSuccess(Void v) {
+                Log.i(TAG, "startRanging succeeded.");
+            }
+
+            @Override
+            public void onFailure(@NonNull Throwable t) {
+                Log.w(TAG, "startRanging failed ", t);
+                closeForReason(Callback.ClosedReason.ERROR);
+            }
+        };
+
+        public final FutureCallback<Void> stopRanging = new FutureCallback<>() {
+            @Override
+            public void onSuccess(Void v) {
+            }
+
+            @Override
+            public void onFailure(@NonNull Throwable t) {
+                Log.w(TAG, "stopRanging failed ", t);
+                closeForReason(Callback.ClosedReason.ERROR);
+            }
+        };
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/rtt/RttCapabilitiesAdapter.java b/ranging/service/java/com/android/server/ranging/rtt/RttCapabilitiesAdapter.java
new file mode 100644
index 00000000..d71c7dcd
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/rtt/RttCapabilitiesAdapter.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.rtt;
+
+import static android.net.wifi.aware.WifiAwareManager.ACTION_WIFI_AWARE_STATE_CHANGED;
+import static android.ranging.RangingCapabilities.DISABLED_USER;
+import static android.ranging.RangingCapabilities.ENABLED;
+import static android.ranging.RangingCapabilities.NOT_SUPPORTED;
+
+import android.annotation.NonNull;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.PackageManager;
+import android.ranging.RangingCapabilities.RangingTechnologyAvailability;
+import android.ranging.wifi.rtt.RttRangingCapabilities;
+
+import androidx.annotation.Nullable;
+
+import com.android.ranging.rtt.backend.internal.RttServiceImpl;
+import com.android.server.ranging.CapabilitiesProvider;
+import com.android.server.ranging.CapabilitiesProvider.CapabilitiesAdapter;
+import com.android.server.ranging.CapabilitiesProvider.TechnologyAvailabilityListener;
+
+public class RttCapabilitiesAdapter extends CapabilitiesAdapter {
+
+    private final Context mContext;
+    private final RttServiceImpl mRttService;
+
+    /** @return true if WiFi RTT is supported in the provided context, false otherwise */
+    public static boolean isSupported(Context context) {
+        return context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI_AWARE);
+    }
+
+    public RttCapabilitiesAdapter(
+            @NonNull Context context,
+            @NonNull TechnologyAvailabilityListener listener
+    ) {
+        super(listener);
+        mContext = context;
+        if (isSupported(mContext)) {
+            mRttService = new RttServiceImpl(context);
+            WifiAwareStateChangeReceiver receiver = new WifiAwareStateChangeReceiver();
+            IntentFilter filter = new IntentFilter(ACTION_WIFI_AWARE_STATE_CHANGED);
+            mContext.registerReceiver(receiver, filter, Context.RECEIVER_NOT_EXPORTED);
+        } else {
+            mRttService = null;
+        }
+    }
+
+    @Override
+    public @RangingTechnologyAvailability int getAvailability() {
+        if (mRttService == null) {
+            return NOT_SUPPORTED;
+        } else if (mRttService.isAvailable()) {
+            return ENABLED;
+        } else {
+            return DISABLED_USER;
+        }
+    }
+
+    @Override
+    @Nullable
+    public RttRangingCapabilities getCapabilities() {
+        if (getAvailability() == ENABLED) {
+            return new RttRangingCapabilities.Builder()
+                    .setPeriodicRangingHwFeature(mRttService.hasPeriodicRangingSupport())
+                    .build();
+        }
+        return null;
+    }
+
+    private class WifiAwareStateChangeReceiver extends BroadcastReceiver {
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            TechnologyAvailabilityListener listener = getAvailabilityListener();
+            if (listener != null) {
+                listener.onAvailabilityChange(
+                        getAvailability(),
+                        CapabilitiesProvider.AvailabilityChangedReason.SYSTEM_POLICY);
+            }
+        }
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/rtt/RttConfig.java b/ranging/service/java/com/android/server/ranging/rtt/RttConfig.java
new file mode 100644
index 00000000..06388ef2
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/rtt/RttConfig.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.rtt;
+
+import android.ranging.DataNotificationConfig;
+import android.ranging.RangingDevice;
+import android.ranging.RangingPreference;
+import android.ranging.wifi.rtt.RttRangingParams;
+
+import androidx.annotation.NonNull;
+
+import com.android.ranging.rtt.backend.internal.RttRangingParameters;
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.session.RangingSessionConfig;
+
+public class RttConfig implements RangingSessionConfig.UnicastTechnologyConfig {
+
+    private final DataNotificationConfig mDataNotificationConfig;
+    private final RttRangingParams mRangingParams;
+    private final RangingDevice mPeerDevice;
+
+    private final @RangingPreference.DeviceRole int mDeviceRole;
+
+    public RttConfig(
+            int deviceRole,
+            @NonNull RttRangingParams rttRangingParams,
+            @NonNull DataNotificationConfig dataNotificationConfig,
+            @NonNull RangingDevice peerDevice
+    ) {
+        mDeviceRole = deviceRole;
+        mRangingParams = rttRangingParams;
+        mDataNotificationConfig = dataNotificationConfig;
+        mPeerDevice = peerDevice;
+    }
+
+    @Override
+    @NonNull public RangingTechnology getTechnology() {
+        return RangingTechnology.RTT;
+    }
+
+    public DataNotificationConfig getDataNotificationConfig() {
+        return mDataNotificationConfig;
+    }
+
+    public RttRangingParams getRangingParams() {
+        return mRangingParams;
+    }
+
+    public int getDeviceRole() {
+        return mDeviceRole;
+    }
+
+    @Override
+    public @NonNull RangingDevice getPeerDevice() {
+        return mPeerDevice;
+    }
+
+    public RttRangingParameters asBackendParameters() {
+        return new RttRangingParameters.Builder()
+                .setDeviceRole(mDeviceRole)
+                .setServiceName(mRangingParams.getServiceName())
+                .setMatchFilter(mRangingParams.getMatchFilter())
+                .setMaxDistanceMm(mDataNotificationConfig.getProximityFarCm() * 100)
+                .setMinDistanceMm(mDataNotificationConfig.getProximityNearCm() * 100)
+                .setEnablePublisherRanging(true)
+                .build();
+    }
+
+    @Override
+    public String toString() {
+        return "RttConfig{ "
+                + "mDataNotificationConfig="
+                + mDataNotificationConfig
+                + ", mRangingParams="
+                + mRangingParams
+                + ", mPeerDevice="
+                + mPeerDevice
+                + ", mDeviceRole="
+                + mDeviceRole
+                + " }";
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/rtt/RttParameters.java b/ranging/service/java/com/android/server/ranging/rtt/RttParameters.java
new file mode 100644
index 00000000..1e7e3529
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/rtt/RttParameters.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.rtt;
+
+import android.ranging.RangingDevice;
+
+import androidx.annotation.NonNull;
+
+import com.android.ranging.rtt.backend.internal.RttRangingParameters;
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.session.RangingSessionConfig;
+
+import java.time.Duration;
+
+public class RttParameters extends com.android.ranging.rtt.backend.internal.RttRangingParameters
+        implements RangingSessionConfig.UnicastTechnologyConfig {
+    public RttParameters(Builder builder) {
+        super(builder);
+    }
+
+    @Override
+    public @NonNull RangingTechnology getTechnology() {
+        return RangingTechnology.RTT;
+    }
+
+    @Override
+    public @NonNull RangingDevice getPeerDevice() {
+        throw new UnsupportedOperationException("Not implemented!");
+    }
+
+    public static class Builder extends RttRangingParameters.Builder {
+        /** Set the service ID that produced this data */
+        public Builder setServiceId(byte serviceId) {
+            mServiceId = serviceId;
+            return this;
+        }
+
+        public Builder setServiceName(String serviceName) {
+            mServiceName = serviceName;
+            return this;
+        }
+
+        public Builder setMaxDistanceMm(int maxDistanceMm) {
+            mMaxDistanceMm = maxDistanceMm;
+            return this;
+        }
+
+        public Builder setMinDistanceMm(int minDistanceMm) {
+            mMinDistanceMm = minDistanceMm;
+            return this;
+        }
+
+        public Builder setEnablePublisherRanging(boolean enablePublisherRange) {
+            mEnablePublisherRanging = enablePublisherRange;
+            return this;
+        }
+
+        public Builder setPublisherPingDuration(@NonNull Duration ping) {
+            mPublisherPingDuration = ping;
+            return this;
+        }
+
+        public Builder setMatchFilter(byte[] matchFilter) {
+            mMatchFilter = matchFilter;
+            return this;
+        }
+
+        public RttParameters build() {
+            return new RttParameters(this);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return super.toString();
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/session/BaseRangingSession.java b/ranging/service/java/com/android/server/ranging/session/BaseRangingSession.java
new file mode 100644
index 00000000..fc2e7e43
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/session/BaseRangingSession.java
@@ -0,0 +1,328 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.session;
+
+import android.content.AttributionSource;
+import android.os.Binder;
+import android.ranging.RangingData;
+import android.ranging.RangingDevice;
+import android.ranging.SessionHandle;
+import android.util.Log;
+
+import androidx.annotation.GuardedBy;
+import androidx.annotation.NonNull;
+
+import com.android.server.ranging.RangingAdapter;
+import com.android.server.ranging.RangingInjector;
+import com.android.server.ranging.RangingServiceManager;
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.RangingUtils.StateMachine;
+import com.android.server.ranging.fusion.DataFusers;
+import com.android.server.ranging.fusion.FilteringFusionEngine;
+import com.android.server.ranging.fusion.FusionEngine;
+import com.android.server.ranging.session.RangingSessionConfig.MulticastTechnologyConfig;
+import com.android.server.ranging.session.RangingSessionConfig.TechnologyConfig;
+import com.android.server.ranging.session.RangingSessionConfig.UnicastTechnologyConfig;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
+import com.google.common.util.concurrent.ListeningExecutorService;
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+/** A multi-technology ranging session in the Android generic ranging service */
+public class BaseRangingSession {
+    private static final String TAG = BaseRangingSession.class.getSimpleName();
+
+    private final RangingInjector mInjector;
+    private final AttributionSource mAttributionSource;
+    private final RangingServiceManager.SessionListener mSessionListener;
+    private final ListeningExecutorService mAdapterExecutor;
+
+    protected final SessionHandle mSessionHandle;
+    protected final RangingSessionConfig mConfig;
+
+    /* Lock for internal state. */
+    private final Object mLock = new Object();
+
+    /**
+     * Keeps track of state of the ranging session.
+     */
+    @GuardedBy("mLock")
+    private final StateMachine<State> mStateMachine;
+
+    /**
+     * Ranging adapters used for this session.
+     * <ul>
+     *    <li /> Each {@link TechnologyConfig} provided in the {@link RangingSessionConfig}
+     *    configures a unique adapter.
+     *    <li /> One adapter handles ranging for one technology.
+     *    <li /> One adapter may handle ranging for multiple peers if the technology supports
+     *    multicasting
+     *    <li /> A session may contain multiple adapters for a single technology.
+     * </ul>
+     */
+    @GuardedBy("mLock")
+    private final ConcurrentMap<TechnologyConfig, RangingAdapter> mAdapters;
+
+    /** State of all peers in the session */
+    @GuardedBy("mLock")
+    private final ConcurrentMap<RangingDevice, Peer> mPeers;
+
+    /** The state of a peer that is ranging with the local device. */
+    private class Peer {
+        /** Technologies that this peer is ranging with. */
+        public final Set<RangingTechnology> technologies;
+        /** Fusion engine to use for this device. */
+        public final FusionEngine fusionEngine;
+
+        Peer(@NonNull RangingDevice device, @NonNull RangingTechnology initialTechnology) {
+            technologies = Sets.newConcurrentHashSet(Set.of(initialTechnology));
+            if (mConfig.getSensorFusionConfig().isSensorFusionEnabled()) {
+                fusionEngine = new FilteringFusionEngine(
+                        new DataFusers.PreferentialDataFuser(RangingTechnology.UWB));
+            } else {
+                fusionEngine = new NoOpFusionEngine(device);
+            }
+            fusionEngine.start(new FusionEngineListener(device));
+        }
+
+        public void setUsingTechnology(@NonNull RangingTechnology technology) {
+            technologies.add(technology);
+            fusionEngine.addDataSource(technology);
+        }
+
+        public void setNotUsingTechnology(@NonNull RangingTechnology technology) {
+            technologies.remove(technology);
+            fusionEngine.removeDataSource(technology);
+        }
+    }
+
+    public BaseRangingSession(
+            @NonNull AttributionSource attributionSource,
+            @NonNull SessionHandle sessionHandle,
+            @NonNull RangingInjector injector,
+            @NonNull RangingSessionConfig config,
+            @NonNull RangingServiceManager.SessionListener listener,
+            @NonNull ListeningExecutorService adapterExecutor
+    ) {
+        mInjector = injector;
+        mAttributionSource = attributionSource;
+        mSessionHandle = sessionHandle;
+        mConfig = config;
+        mSessionListener = listener;
+        mAdapterExecutor = adapterExecutor;
+        mStateMachine = new StateMachine<>(State.STOPPED);
+        mPeers = new ConcurrentHashMap<>();
+        mAdapters = new ConcurrentHashMap<>();
+    }
+
+    /** Start ranging in this session. */
+    public void start(ImmutableSet<TechnologyConfig> technologyConfigs) {
+        synchronized (mLock) {
+            if (!mStateMachine.transition(State.STOPPED, State.STARTING)) {
+                Log.w(TAG, "Failed transition STOPPED -> STARTING");
+                return;
+            }
+
+            for (TechnologyConfig config : technologyConfigs) {
+                ImmutableSet<RangingDevice> peerDevices;
+
+                if (config instanceof UnicastTechnologyConfig unicastConfig) {
+                    peerDevices = ImmutableSet.of(unicastConfig.getPeerDevice());
+                } else if (config instanceof MulticastTechnologyConfig multicastConfig) {
+                    peerDevices = multicastConfig.getPeerDevices();
+                } else {
+                    Log.e(TAG,
+                            "Received unsupported config for technology " + config.getTechnology());
+                    mSessionListener.onSessionStopped(
+                            RangingAdapter.Callback.ClosedReason.FAILED_TO_START);
+                    return;
+                }
+
+                for (RangingDevice peerDevice : peerDevices) {
+                    if (mPeers.containsKey(peerDevice)) {
+                        mPeers.get(peerDevice).setUsingTechnology(config.getTechnology());
+                    } else {
+                        mPeers.put(peerDevice, new Peer(peerDevice, config.getTechnology()));
+                    }
+                }
+
+                // Any calls to the corresponding technology stacks must be
+                // done with a clear calling identity.
+                long token = Binder.clearCallingIdentity();
+                RangingAdapter adapter = mInjector.createAdapter(
+                        config, mConfig.getDeviceRole(), mAdapterExecutor);
+                mAdapters.put(config, adapter);
+                adapter.start(config, new AdapterListener(config));
+                Binder.restoreCallingIdentity(token);
+            }
+        }
+    }
+
+    public void addPeer(RangingDevice params) {
+        //TODO: Implement this
+        throw new IllegalArgumentException("Dynamic addition of raw peer not supported yet");
+    }
+
+    public void removePeer(RangingDevice params) {
+        //TODO: Implement this
+        throw new IllegalArgumentException("Dynamic addition of raw peer not supported yet");
+    }
+
+    public void reconfigureInterval(int intervalSkipCount) {
+        //TODO: Implement this
+        throw new IllegalArgumentException("Dynamic addition of raw peer not supported yet");
+    }
+
+    /** Stop ranging in this session. */
+    public void stop() {
+        synchronized (mLock) {
+            if (mStateMachine.getState() == State.STOPPING
+                    || mStateMachine.getState() == State.STOPPED) {
+                Log.v(TAG, "Ranging already stopping or stopped, skipping");
+                return;
+            }
+            mStateMachine.setState(State.STOPPING);
+
+            // Any calls to the corresponding technology stacks must be
+            // done with a clear calling identity.
+            long token = Binder.clearCallingIdentity();
+            for (RangingAdapter adapter : mAdapters.values()) {
+                adapter.stop();
+            }
+            Binder.restoreCallingIdentity(token);
+        }
+    }
+
+    private class AdapterListener implements RangingAdapter.Callback {
+        private final TechnologyConfig mConfig;
+
+        AdapterListener(@NonNull TechnologyConfig config) {
+            mConfig = config;
+        }
+
+        @Override
+        public void onStarted(@NonNull RangingDevice peerDevice) {
+            synchronized (mLock) {
+                mStateMachine.transition(State.STARTING, State.STARTED);
+                mPeers.get(peerDevice).setUsingTechnology(mConfig.getTechnology());
+                mSessionListener.onTechnologyStarted(peerDevice, mConfig.getTechnology());
+            }
+        }
+
+        @Override
+        public void onStopped(@NonNull RangingDevice peerDevice) {
+            synchronized (mLock) {
+                Peer peer = mPeers.get(peerDevice);
+                peer.setNotUsingTechnology(mConfig.getTechnology());
+                mSessionListener.onTechnologyStopped(peerDevice, mConfig.getTechnology());
+                if (peer.technologies.isEmpty()) {
+                    peer.fusionEngine.stop();
+                    mPeers.remove(peerDevice);
+                }
+            }
+        }
+
+        @Override
+        public void onRangingData(@NonNull RangingDevice peerDevice, @NonNull RangingData data) {
+            synchronized (mLock) {
+                if (mStateMachine.getState() != State.STOPPING
+                        && mStateMachine.getState() != State.STOPPED
+                ) {
+                    mPeers.get(peerDevice).fusionEngine.feed(data);
+                }
+            }
+        }
+
+        @Override
+        public void onClosed(@ClosedReason int reason) {
+            synchronized (mLock) {
+                mAdapters.remove(mConfig);
+                if (mAdapters.isEmpty()) {
+                    mStateMachine.setState(State.STOPPED);
+                    mSessionListener.onSessionStopped(reason);
+                }
+            }
+        }
+    }
+
+    /** Listens for fusion engine events. */
+    private class FusionEngineListener implements FusionEngine.Callback {
+        private final RangingDevice mPeer;
+
+        FusionEngineListener(@NonNull RangingDevice peer) {
+            mPeer = peer;
+        }
+
+        @Override
+        public void onData(@NonNull RangingData data) {
+            synchronized (mLock) {
+                if (mStateMachine.getState() != State.STOPPING
+                        && mStateMachine.getState() != State.STOPPED
+                ) {
+                    mSessionListener.onResults(mPeer, data);
+                }
+            }
+        }
+    }
+
+    private class NoOpFusionEngine extends FusionEngine {
+        private final RangingDevice mPeer;
+
+        NoOpFusionEngine(@NonNull RangingDevice peer) {
+            super(new DataFusers.PassthroughDataFuser());
+            mPeer = peer;
+        }
+
+        protected @NonNull Set<RangingTechnology> getDataSources() {
+            return mPeers.get(mPeer).technologies;
+        }
+
+        public void addDataSource(@NonNull RangingTechnology technology) {
+        }
+
+        public void removeDataSource(@NonNull RangingTechnology technology) {
+        }
+    }
+
+    private enum State {
+        STARTING,
+        STARTED,
+        STOPPING,
+        STOPPED,
+    }
+
+    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        pw.println("---- Dump of RangingSession ----");
+        pw.println("Session handle: " + mSessionHandle);
+        pw.println("Attribution source: " + mAttributionSource);
+        pw.println("Adapters:");
+        for (RangingAdapter adapter : mAdapters.values()) {
+            pw.println(adapter);
+        }
+        pw.println("Peers:");
+        for (Peer peer : mPeers.values()) {
+            pw.println(peer);
+        }
+        pw.println("---- Dump of RangingSession ----");
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/session/OobInitiatorRangingSession.java b/ranging/service/java/com/android/server/ranging/session/OobInitiatorRangingSession.java
new file mode 100644
index 00000000..d3c799ef
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/session/OobInitiatorRangingSession.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.session;
+
+import android.content.AttributionSource;
+import android.ranging.SessionHandle;
+import android.ranging.oob.IOobSendDataListener;
+import android.ranging.oob.OobHandle;
+import android.ranging.oob.OobInitiatorRangingParams;
+
+import androidx.annotation.NonNull;
+
+import com.android.server.ranging.RangingInjector;
+import com.android.server.ranging.RangingServiceManager;
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.oob.CapabilityRequestMessage;
+import com.android.server.ranging.oob.OobHandler;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.ListeningExecutorService;
+
+public class OobInitiatorRangingSession
+        extends BaseRangingSession
+        implements RangingSession<OobInitiatorRangingParams>, OobHandler {
+
+    private final IOobSendDataListener mOobDataSender;
+
+    private ImmutableSet<OobHandle> mOobHandles;
+
+    public OobInitiatorRangingSession(
+            @NonNull AttributionSource attributionSource,
+            @NonNull SessionHandle sessionHandle,
+            @NonNull RangingInjector injector,
+            @NonNull RangingSessionConfig config,
+            @NonNull RangingServiceManager.SessionListener listener,
+            @NonNull IOobSendDataListener oobDataSender,
+            @NonNull ListeningExecutorService adapterExecutor
+    ) {
+        super(attributionSource, sessionHandle, injector, config, listener, adapterExecutor);
+        mOobDataSender = oobDataSender;
+        mOobHandles = null;
+    }
+
+    @Override
+    public void start(@NonNull OobInitiatorRangingParams params) {
+
+        mOobHandles = params.getDeviceHandles()
+                .stream().map((handle) -> new OobHandle(mSessionHandle, handle.getRangingDevice()))
+                .collect(ImmutableSet.toImmutableSet());
+
+        // TODO
+        CapabilityRequestMessage message = CapabilityRequestMessage.builder()
+                .setRequestedRangingTechnologies(ImmutableList.of(RangingTechnology.UWB))
+                .build();
+    }
+
+    @Override
+    public void handleOobMessage(OobHandle oobHandle, byte[] data) {
+        // TODO
+        throw new UnsupportedOperationException("Not implemented");
+    }
+
+    @Override
+    public void handleOobDeviceDisconnected(OobHandle oobHandle) {
+        // TODO
+        throw new UnsupportedOperationException("Not implemented");
+    }
+
+    @Override
+    public void handleOobDeviceReconnected(OobHandle oobHandle) {
+        // TODO
+        throw new UnsupportedOperationException("Not implemented");
+    }
+
+    @Override
+    public void handleOobClosed(OobHandle oobHandle) {
+        // TODO
+        throw new UnsupportedOperationException("Not implemented");
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/session/OobResponderRangingSession.java b/ranging/service/java/com/android/server/ranging/session/OobResponderRangingSession.java
new file mode 100644
index 00000000..207e65d8
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/session/OobResponderRangingSession.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.session;
+
+import android.content.AttributionSource;
+import android.ranging.SessionHandle;
+import android.ranging.oob.IOobSendDataListener;
+import android.ranging.oob.OobHandle;
+import android.ranging.oob.OobResponderRangingParams;
+
+import androidx.annotation.NonNull;
+
+import com.android.server.ranging.RangingInjector;
+import com.android.server.ranging.RangingServiceManager;
+import com.android.server.ranging.oob.OobHandler;
+
+import com.google.common.util.concurrent.ListeningExecutorService;
+
+public class OobResponderRangingSession
+        extends BaseRangingSession
+        implements RangingSession<OobResponderRangingParams>, OobHandler {
+
+    private final IOobSendDataListener mOobDataSender;
+
+    public OobResponderRangingSession(
+            @NonNull AttributionSource attributionSource,
+            @NonNull SessionHandle sessionHandle,
+            @NonNull RangingInjector injector,
+            @NonNull RangingSessionConfig config,
+            @NonNull RangingServiceManager.SessionListener listener,
+            @NonNull IOobSendDataListener oobDataSender,
+            @NonNull ListeningExecutorService adapterExecutor
+    ) {
+        super(attributionSource, sessionHandle, injector, config, listener, adapterExecutor);
+        mOobDataSender = oobDataSender;
+    }
+
+    @Override
+    public void start(@NonNull OobResponderRangingParams params) {
+        // TODO
+        throw new UnsupportedOperationException("Not implemented");
+    }
+
+    @Override
+    public void handleOobMessage(OobHandle oobHandle, byte[] data) {
+        // TODO
+        throw new UnsupportedOperationException("Not implemented");
+    }
+
+    @Override
+    public void handleOobDeviceDisconnected(OobHandle oobHandle) {
+        // TODO
+        throw new UnsupportedOperationException("Not implemented");
+    }
+
+    @Override
+    public void handleOobDeviceReconnected(OobHandle oobHandle) {
+        // TODO
+        throw new UnsupportedOperationException("Not implemented");
+    }
+
+    @Override
+    public void handleOobClosed(OobHandle oobHandle) {
+        // TODO
+        throw new UnsupportedOperationException("Not implemented");
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/session/RangingSession.java b/ranging/service/java/com/android/server/ranging/session/RangingSession.java
new file mode 100644
index 00000000..b956588a
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/session/RangingSession.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.session;
+
+import android.ranging.RangingDevice;
+import android.ranging.RangingParams;
+
+import androidx.annotation.NonNull;
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+
+public interface RangingSession<P extends RangingParams> {
+    void start(@NonNull P params);
+
+    void stop();
+
+    void addPeer(RangingDevice params);
+
+    void removePeer(RangingDevice params);
+
+    void reconfigureInterval(int intervalSkipCount);
+
+    void dump(FileDescriptor fd, PrintWriter pw, String[] args);
+}
diff --git a/ranging/service/java/com/android/server/ranging/session/RangingSessionConfig.java b/ranging/service/java/com/android/server/ranging/session/RangingSessionConfig.java
new file mode 100644
index 00000000..af24af82
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/session/RangingSessionConfig.java
@@ -0,0 +1,277 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.session;
+
+import android.ranging.DataNotificationConfig;
+import android.ranging.RangingDevice;
+import android.ranging.RangingManager;
+import android.ranging.RangingPreference;
+import android.ranging.SensorFusionParams;
+import android.ranging.raw.RawRangingDevice;
+import android.ranging.uwb.UwbAddress;
+import android.ranging.uwb.UwbRangingParams;
+
+import androidx.annotation.NonNull;
+
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.blerssi.BleRssiConfig;
+import com.android.server.ranging.cs.CsConfig;
+import com.android.server.ranging.rtt.RttConfig;
+import com.android.server.ranging.uwb.UwbConfig;
+
+import com.google.common.collect.BiMap;
+import com.google.common.collect.HashBiMap;
+import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+
+public class RangingSessionConfig {
+    private final @RangingPreference.DeviceRole int mDeviceRole;
+    private final SensorFusionParams mFusionConfig;
+    private final boolean mIsAoaNeeded;
+    private final DataNotificationConfig mDataNotificationConfig;
+
+    /** A complete configuration for a session within a specific ranging technology's stack */
+    public interface TechnologyConfig {
+        @NonNull RangingTechnology getTechnology();
+    }
+
+    /** A config for a technology that only supports 1 peer per session. */
+    public interface UnicastTechnologyConfig extends TechnologyConfig {
+        @NonNull RangingDevice getPeerDevice();
+    }
+
+    /** A config for a technology that supports multiple peers per session. */
+    public interface MulticastTechnologyConfig extends TechnologyConfig {
+        /**
+         * @return the set of peers within this technology-specific session.
+         */
+        @NonNull ImmutableSet<RangingDevice> getPeerDevices();
+    }
+
+    private RangingSessionConfig(Builder builder) {
+        mDeviceRole = builder.mDeviceRole;
+        mFusionConfig = builder.mFusionConfig;
+        mIsAoaNeeded = builder.mIsAoaNeeded;
+        mDataNotificationConfig = builder.mDataNotificationConfig;
+    }
+
+    public @NonNull ImmutableSet<TechnologyConfig> getTechnologyConfigs(
+            @NonNull Set<RawRangingDevice> peerParams
+    ) {
+        return ImmutableSet.copyOf(Sets.union(
+                getConfigsForUnicastTechnologies(peerParams),
+                getConfigsForMulticastTechnologies(peerParams)));
+    }
+
+    private @NonNull Set<MulticastTechnologyConfig> getConfigsForMulticastTechnologies(
+            @NonNull Set<RawRangingDevice> peerParams
+    ) {
+        Set<MulticastTechnologyConfig> configs = new HashSet<>();
+
+        Map<PeerIgnoringParamsHasher<UwbRangingParams>, BiMap<RangingDevice, UwbAddress>>
+                uwbPeersByParams = PeerIgnoringParamsHasher.groupUwbPeersByParams(peerParams);
+
+        // Create a config for each unique params. When multiple peers share the same params, this
+        // config will specify a multicast session containing all of them.
+        for (PeerIgnoringParamsHasher<UwbRangingParams> key : uwbPeersByParams.keySet()) {
+            configs.add(new UwbConfig.Builder(key.mParams)
+                    .setDeviceRole(mDeviceRole)
+                    .setPeerAddresses(ImmutableBiMap.copyOf(uwbPeersByParams.get(key)))
+                    .setAoaNeeded(mIsAoaNeeded)
+                    // TODO(370077264): Set country code based on geolocation.
+                    .setCountryCode("US")
+                    .setDataNotificationConfig(mDataNotificationConfig)
+                    .build());
+        }
+
+        return configs;
+    }
+
+    private @NonNull Set<UnicastTechnologyConfig> getConfigsForUnicastTechnologies(
+            @NonNull Set<RawRangingDevice> peerParams
+    ) {
+        Set<UnicastTechnologyConfig> configs = new HashSet<>();
+
+        for (RawRangingDevice peer : peerParams) {
+            if (peer.getRttRangingParams() != null) {
+                configs.add(new RttConfig(
+                        mDeviceRole,
+                        peer.getRttRangingParams(),
+                        mDataNotificationConfig,
+                        peer.getRangingDevice()));
+            }
+            if (peer.getBleRssiRangingParams() != null) {
+                configs.add(new BleRssiConfig(
+                        mDeviceRole,
+                        peer.getBleRssiRangingParams(),
+                        mDataNotificationConfig,
+                        peer.getRangingDevice()));
+            }
+            if (peer.getCsRangingParams() != null) {
+                configs.add(new CsConfig(
+                        mDeviceRole,
+                        peer.getCsRangingParams(),
+                        mDataNotificationConfig,
+                        peer.getRangingDevice()));
+            }
+        }
+
+        return configs;
+    }
+
+    public @RangingPreference.DeviceRole int getDeviceRole() {
+        return mDeviceRole;
+    }
+
+    public @NonNull SensorFusionParams getSensorFusionConfig() {
+        return mFusionConfig;
+    }
+
+    public boolean isAoaNeeded() {
+        return mIsAoaNeeded;
+    }
+
+    public @NonNull DataNotificationConfig getDataNotificationConfig() {
+        return mDataNotificationConfig;
+    }
+
+    public static class Builder {
+        private @RangingPreference.DeviceRole int mDeviceRole;
+        private SensorFusionParams mFusionConfig;
+        private boolean mIsAoaNeeded;
+        private DataNotificationConfig mDataNotificationConfig;
+
+        public RangingSessionConfig build() {
+            return new RangingSessionConfig(this);
+        }
+
+        public Builder setDeviceRole(@RangingPreference.DeviceRole int role) {
+            mDeviceRole = role;
+            return this;
+        }
+
+        public Builder setSensorFusionConfig(@NonNull SensorFusionParams config) {
+            mFusionConfig = config;
+            return this;
+        }
+
+        public Builder setDataNotificationConfig(@NonNull DataNotificationConfig config) {
+            mDataNotificationConfig = config;
+            return this;
+        }
+
+        public Builder setAoaNeeded(boolean isAoaNeeded) {
+            mIsAoaNeeded = isAoaNeeded;
+            return this;
+        }
+    }
+
+    private static class PeerIgnoringParamsHasher<P> {
+        private final P mParams;
+
+        /**
+         * Group together UWB peer devices that share the same params so that they can be put into a
+         * a multicast session.
+         */
+        public static
+        Map<PeerIgnoringParamsHasher<UwbRangingParams>, BiMap<RangingDevice, UwbAddress>>
+        groupUwbPeersByParams(@NonNull Set<RawRangingDevice> peerParams) {
+            Map<PeerIgnoringParamsHasher<UwbRangingParams>, BiMap<RangingDevice, UwbAddress>>
+                    peersByParams = new HashMap<>();
+            for (RawRangingDevice peer : peerParams) {
+                if (peer.getUwbRangingParams() == null) continue;
+
+                PeerIgnoringParamsHasher<UwbRangingParams> key =
+                        new PeerIgnoringParamsHasher<>(peer.getUwbRangingParams());
+
+                if (peersByParams.containsKey(key)) {
+                    peersByParams.get(key).put(
+                            peer.getRangingDevice(),
+                            key.mParams.getPeerAddress());
+                } else {
+                    peersByParams.put(key, HashBiMap.create(Map.of(
+                            peer.getRangingDevice(),
+                            key.mParams.getPeerAddress())));
+                }
+            }
+            return peersByParams;
+        }
+
+        PeerIgnoringParamsHasher(P params) {
+            mParams = params;
+        }
+
+        @Override
+        public int hashCode() {
+            if (mParams instanceof UwbRangingParams params) {
+                return Objects.hash(
+                        RangingManager.UWB,
+                        params.getSessionId(),
+                        params.getSubSessionId(),
+                        params.getConfigId(),
+                        params.getDeviceAddress(),
+                        Arrays.hashCode(params.getSessionKeyInfo()),
+                        Arrays.hashCode(params.getSubSessionKeyInfo()),
+                        params.getComplexChannel(),
+                        params.getRangingUpdateRate(),
+                        params.getSlotDuration());
+            } else {
+                throw new IllegalArgumentException("Provided params object is not supported");
+            }
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (!(o instanceof PeerIgnoringParamsHasher<?> hasher)) return false;
+
+            if (mParams instanceof UwbRangingParams me
+                    && hasher.mParams instanceof UwbRangingParams other
+            ) {
+                return me.getSessionId() == other.getSessionId()
+                        && me.getSubSessionId() == other.getSubSessionId()
+                        && me.getConfigId() == other.getConfigId()
+                        && me.getDeviceAddress().equals(other.getDeviceAddress())
+                        && Arrays.equals(me.getSessionKeyInfo(), other.getSessionKeyInfo())
+                        && Arrays.equals(me.getSubSessionKeyInfo(), other.getSubSessionKeyInfo())
+                        && me.getComplexChannel().equals(other.getComplexChannel())
+                        && me.getRangingUpdateRate() == other.getRangingUpdateRate()
+                        && me.getSlotDuration() == other.getSlotDuration();
+            }
+
+            return false;
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "RangingSessionConfig{" +
+                "mDeviceRole=" + mDeviceRole +
+                ", mFusionConfig=" + mFusionConfig +
+                ", mIsAoaNeeded=" + mIsAoaNeeded +
+                ", mDataNotificationConfig=" + mDataNotificationConfig +
+                '}';
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/session/RawInitiatorRangingSession.java b/ranging/service/java/com/android/server/ranging/session/RawInitiatorRangingSession.java
new file mode 100644
index 00000000..d3b4345d
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/session/RawInitiatorRangingSession.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.session;
+
+import android.content.AttributionSource;
+import android.ranging.SessionHandle;
+import android.ranging.raw.RawInitiatorRangingParams;
+
+import androidx.annotation.NonNull;
+
+import com.android.server.ranging.RangingInjector;
+import com.android.server.ranging.RangingServiceManager;
+
+import com.google.common.util.concurrent.ListeningExecutorService;
+
+import java.util.Set;
+
+public class RawInitiatorRangingSession
+        extends BaseRangingSession
+        implements RangingSession<RawInitiatorRangingParams> {
+
+    public RawInitiatorRangingSession(
+            @NonNull AttributionSource attributionSource,
+            @NonNull SessionHandle sessionHandle,
+            @NonNull RangingInjector injector,
+            @NonNull RangingSessionConfig config,
+            @NonNull RangingServiceManager.SessionListener listener,
+            @NonNull ListeningExecutorService adapterExecutor
+    ) {
+        super(attributionSource, sessionHandle, injector, config, listener, adapterExecutor);
+    }
+
+    @Override
+    public void start(@NonNull RawInitiatorRangingParams params) {
+        super.start(mConfig.getTechnologyConfigs(Set.copyOf(params.getRawRangingDevices())));
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/session/RawResponderRangingSession.java b/ranging/service/java/com/android/server/ranging/session/RawResponderRangingSession.java
new file mode 100644
index 00000000..74ade6da
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/session/RawResponderRangingSession.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.session;
+
+import android.content.AttributionSource;
+import android.ranging.SessionHandle;
+import android.ranging.raw.RawResponderRangingParams;
+
+import androidx.annotation.NonNull;
+
+import com.android.server.ranging.RangingInjector;
+import com.android.server.ranging.RangingServiceManager;
+
+import com.google.common.util.concurrent.ListeningExecutorService;
+
+import java.util.Set;
+
+public class RawResponderRangingSession
+        extends BaseRangingSession
+        implements RangingSession<RawResponderRangingParams> {
+
+    public RawResponderRangingSession(
+            @NonNull AttributionSource attributionSource,
+            @NonNull SessionHandle sessionHandle,
+            @NonNull RangingInjector injector,
+            @NonNull RangingSessionConfig config,
+            @NonNull RangingServiceManager.SessionListener listener,
+            @NonNull ListeningExecutorService adapterExecutor
+    ) {
+        super(attributionSource, sessionHandle, injector, config, listener, adapterExecutor);
+    }
+
+    @Override
+    public void start(@NonNull RawResponderRangingParams params) {
+        super.start(mConfig.getTechnologyConfigs(Set.of(params.getRawRangingDevice())));
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/uwb/UwbAdapter.java b/ranging/service/java/com/android/server/ranging/uwb/UwbAdapter.java
new file mode 100644
index 00000000..d93270cb
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/uwb/UwbAdapter.java
@@ -0,0 +1,322 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.uwb;
+
+import static com.android.ranging.uwb.backend.internal.RangingMeasurement.CONFIDENCE_HIGH;
+import static com.android.ranging.uwb.backend.internal.RangingMeasurement.CONFIDENCE_MEDIUM;
+import static com.android.server.ranging.uwb.UwbConfig.toBackend;
+
+import android.content.Context;
+import android.ranging.RangingData;
+import android.ranging.RangingDevice;
+import android.ranging.RangingMeasurement;
+import android.ranging.RangingPreference;
+import android.ranging.uwb.UwbAddress;
+import android.ranging.uwb.UwbComplexChannel;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+
+import com.android.ranging.uwb.backend.internal.RangingController;
+import com.android.ranging.uwb.backend.internal.RangingPosition;
+import com.android.ranging.uwb.backend.internal.RangingSessionCallback;
+import com.android.ranging.uwb.backend.internal.Utils;
+import com.android.ranging.uwb.backend.internal.UwbDevice;
+import com.android.ranging.uwb.backend.internal.UwbServiceImpl;
+import com.android.server.ranging.RangingAdapter;
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.RangingUtils.StateMachine;
+import com.android.server.ranging.session.RangingSessionConfig;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.collect.BiMap;
+import com.google.common.collect.HashBiMap;
+import com.google.common.util.concurrent.FutureCallback;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListeningExecutorService;
+
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+/** Ranging adapter for Ultra-wideband (UWB). */
+public class UwbAdapter implements RangingAdapter {
+    private static final String TAG = UwbAdapter.class.getSimpleName();
+
+    private final com.android.ranging.uwb.backend.internal.RangingDevice mUwbClient;
+    private final ListeningExecutorService mExecutorService;
+    private final ExecutorService mBackendExecutor;
+    private final ExecutorResultHandlers mUwbClientResultHandlers = new ExecutorResultHandlers();
+    private final RangingSessionCallback mUwbListener = new UwbListener();
+    private final StateMachine<State> mStateMachine;
+    private final BiMap<RangingDevice, UwbAddress> mPeers;
+
+    /** Invariant: non-null while a ranging session is active */
+    private Callback mCallbacks;
+
+    public UwbAdapter(
+            @NonNull Context context, @NonNull ListeningExecutorService executor,
+            @RangingPreference.DeviceRole int role
+    ) {
+        this(context, executor, Executors.newSingleThreadExecutor(), role);
+    }
+
+    /** Intermediary constructor used to make an additional reference to backendExecutor. */
+    private UwbAdapter(
+            @NonNull Context context, @NonNull ListeningExecutorService executor,
+            @NonNull ExecutorService backendExecutor, @RangingPreference.DeviceRole int role
+    ) {
+        this(context, executor, backendExecutor,
+                role == RangingPreference.DEVICE_ROLE_INITIATOR
+                        ? UwbServiceImpl.getController(context, backendExecutor)
+                        : UwbServiceImpl.getControlee(context, backendExecutor));
+    }
+
+    /** Injectable constructor for testing. */
+    @VisibleForTesting
+    public UwbAdapter(
+            @NonNull Context context, @NonNull ListeningExecutorService executor,
+            @NonNull ExecutorService backendExecutor,
+            @NonNull com.android.ranging.uwb.backend.internal.RangingDevice uwbClient
+    ) {
+        if (!RangingTechnology.UWB.isSupported(context)) {
+            throw new IllegalArgumentException("UWB system feature not found.");
+        }
+
+        mStateMachine = new StateMachine<>(State.STOPPED);
+        mUwbClient = uwbClient;
+        mExecutorService = executor;
+        mBackendExecutor = backendExecutor;
+        mCallbacks = null;
+        mPeers = HashBiMap.create();
+    }
+
+    @Override
+    public @NonNull RangingTechnology getTechnology() {
+        return RangingTechnology.UWB;
+    }
+
+    @Override
+    public void start(
+            @NonNull RangingSessionConfig.TechnologyConfig config, @NonNull Callback callbacks
+    ) {
+        Log.i(TAG, "Start called.");
+        if (!mStateMachine.transition(State.STOPPED, State.STARTED)) {
+            Log.v(TAG, "Attempted to start adapter when it was already started");
+            return;
+        }
+
+        mCallbacks = callbacks;
+        if (!(config instanceof UwbConfig uwbConfig)) {
+            Log.w(TAG, "Tried to start adapter with invalid ranging parameters");
+            closeForReason(Callback.ClosedReason.FAILED_TO_START);
+            return;
+        }
+        mPeers.putAll(uwbConfig.getPeerAddresses());
+        mUwbClient.setRangingParameters(uwbConfig.asBackendParameters());
+        mUwbClient.setLocalAddress(toBackend(uwbConfig.getParameters().getDeviceAddress()));
+        if (mUwbClient instanceof RangingController controller) {
+            controller.setComplexChannel(
+                    toBackend(uwbConfig.getParameters().getComplexChannel()));
+        }
+
+        var future = Futures.submit(() -> {
+            mUwbClient.startRanging(mUwbListener, mBackendExecutor);
+        }, mExecutorService);
+        Futures.addCallback(future, mUwbClientResultHandlers.startRanging, mExecutorService);
+    }
+
+    @Override
+    public void stop() {
+        Log.i(TAG, "Stop called.");
+        if (!mStateMachine.transition(State.STARTED, State.STOPPED)) {
+            Log.v(TAG, "Attempted to stop adapter when it was already stopped");
+            return;
+        }
+
+        var future = Futures.submit(mUwbClient::stopRanging, mExecutorService);
+        Futures.addCallback(future, mUwbClientResultHandlers.stopRanging, mExecutorService);
+    }
+
+    public @Nullable UwbComplexChannel getComplexChannel() {
+        if (!(mUwbClient instanceof RangingController controller)) {
+            return null;
+        }
+        com.android.ranging.uwb.backend.internal.UwbComplexChannel complexChannel =
+                controller.getComplexChannel();
+        return new UwbComplexChannel.Builder()
+                .setChannel((int) complexChannel.getChannel())
+                .setPreambleIndex((int) complexChannel.getPreambleIndex())
+                .build();
+    }
+
+    private class UwbListener implements RangingSessionCallback {
+
+        @Override
+        public void onRangingInitialized(UwbDevice localDevice) {
+            Log.i(TAG, "onRangingInitialized");
+            synchronized (mStateMachine) {
+                if (mStateMachine.getState() == State.STARTED) {
+                    mPeers.keySet().forEach(mCallbacks::onStarted);
+                }
+            }
+        }
+
+        @Override
+        public void onRangingResult(UwbDevice peer, RangingPosition position) {
+            RangingData.Builder dataBuilder = new RangingData.Builder()
+                    .setRangingTechnology((int) RangingTechnology.UWB.getValue())
+                    .setDistance(convertMeasurement(position.getDistance()))
+                    .setTimestampMillis(position.getElapsedRealtimeNanos());
+
+            if (position.getAzimuth() != null) {
+                dataBuilder.setAzimuth(convertMeasurement(position.getAzimuth()));
+            }
+            if (position.getElevation() != null) {
+                dataBuilder.setElevation(convertMeasurement(position.getElevation()));
+            }
+            if (position.getRssiDbm() != RangingPosition.RSSI_UNKNOWN) {
+                dataBuilder.setRssi(position.getRssiDbm());
+            }
+
+            synchronized (mStateMachine) {
+                if (mStateMachine.getState() == State.STARTED) {
+                    RangingDevice device = convertPeerDevice(peer);
+                    if (device != null) {
+                        mCallbacks.onRangingData(device, dataBuilder.build());
+                    }
+                }
+            }
+        }
+
+        @Override
+        public void onRangingSuspended(UwbDevice localDevice, @RangingSuspendedReason int reason) {
+            Log.i(TAG, "onRangingSuspended: " + reason);
+            closeForReason(convertReason(reason));
+        }
+
+        @Override
+        public void onPeerDisconnected(UwbDevice peer, @PeerDisconnectedReason int reason) {
+            Log.i(TAG, "onPeerDisconnected: " + peer.getAddress() + ", " + reason);
+
+            synchronized (mStateMachine) {
+                RangingDevice device = convertPeerDevice(peer);
+                if (device != null) {
+                    mPeers.remove(device);
+                    mCallbacks.onStopped(device);
+                }
+            }
+        }
+
+        private static @Callback.ClosedReason int convertReason(
+                @RangingSessionCallback.RangingSuspendedReason int reason) {
+            switch (reason) {
+                case REASON_WRONG_PARAMETERS:
+                case REASON_FAILED_TO_START:
+                    return Callback.ClosedReason.FAILED_TO_START;
+                case REASON_STOPPED_BY_PEER:
+                case REASON_STOP_RANGING_CALLED:
+                    return Callback.ClosedReason.REQUESTED;
+                case REASON_MAX_RANGING_ROUND_RETRY_REACHED:
+                    return Callback.ClosedReason.LOST_CONNECTION;
+                case REASON_SYSTEM_POLICY:
+                    return Callback.ClosedReason.SYSTEM_POLICY;
+                default:
+                    return Callback.ClosedReason.UNKNOWN;
+            }
+        }
+
+        private @Nullable RangingDevice convertPeerDevice(
+                @NonNull com.android.ranging.uwb.backend.internal.UwbDevice peer
+        ) {
+            RangingDevice device = mPeers
+                    .inverse()
+                    .get(UwbAddress.fromBytes(peer.getAddress().toBytes()));
+            if (device == null) {
+                Log.e(TAG, "Attempted lookup of unknown peer with UWB address "
+                        + peer.getAddress().toHexString());
+                return null;
+            }
+            return device;
+        }
+
+        private static RangingMeasurement convertMeasurement(
+                @NonNull com.android.ranging.uwb.backend.internal.RangingMeasurement measurement
+        ) {
+            return new RangingMeasurement.Builder()
+                    .setMeasurement(measurement.getValue())
+                    .setConfidence(convertConfidence(measurement.getConfidence()))
+                    .build();
+        }
+    }
+
+    /** Close the session, disconnecting all peers and resetting internal state. */
+    private void closeForReason(@Callback.ClosedReason int reason) {
+        synchronized (mStateMachine) {
+            mStateMachine.setState(State.STOPPED);
+            mPeers.keySet().forEach(mCallbacks::onStopped);
+            mCallbacks.onClosed(reason);
+            clear();
+        }
+    }
+
+    private void clear() {
+        mCallbacks = null;
+        mPeers.clear();
+    }
+
+    public enum State {
+        STARTED,
+        STOPPED,
+    }
+
+    private class ExecutorResultHandlers {
+        public final FutureCallback<Void> startRanging = new FutureCallback<>() {
+            @Override
+            public void onSuccess(Void v) {
+                Log.i(TAG, "startRanging succeeded.");
+            }
+
+            @Override
+            public void onFailure(@NonNull Throwable t) {
+                Log.w(TAG, "startRanging failed ", t);
+                closeForReason(Callback.ClosedReason.ERROR);
+            }
+        };
+
+        public final FutureCallback<Integer> stopRanging = new FutureCallback<>() {
+            @Override
+            public void onSuccess(@Utils.UwbStatusCodes Integer status) {
+            }
+
+            @Override
+            public void onFailure(@NonNull Throwable t) {
+                Log.w(TAG, "stopRanging failed ", t);
+                // We failed to stop but there's nothing else we can do.
+                closeForReason(Callback.ClosedReason.ERROR);
+            }
+        };
+    }
+
+    public static int convertConfidence(int confidence) {
+        return switch (confidence) {
+            case CONFIDENCE_HIGH -> android.ranging.RangingMeasurement.CONFIDENCE_HIGH;
+            case CONFIDENCE_MEDIUM -> android.ranging.RangingMeasurement.CONFIDENCE_MEDIUM;
+            default -> android.ranging.RangingMeasurement.CONFIDENCE_LOW;
+        };
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/uwb/UwbCapabilitiesAdapter.java b/ranging/service/java/com/android/server/ranging/uwb/UwbCapabilitiesAdapter.java
new file mode 100644
index 00000000..bb156723
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/uwb/UwbCapabilitiesAdapter.java
@@ -0,0 +1,156 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.uwb;
+
+import static android.ranging.RangingCapabilities.DISABLED_REGULATORY;
+import static android.ranging.RangingCapabilities.DISABLED_USER;
+import static android.ranging.RangingCapabilities.ENABLED;
+import static android.ranging.RangingCapabilities.NOT_SUPPORTED;
+
+import android.annotation.NonNull;
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.ranging.RangingCapabilities.RangingTechnologyAvailability;
+import android.ranging.uwb.UwbRangingCapabilities;
+import android.util.Log;
+
+import androidx.annotation.Nullable;
+
+import com.android.ranging.uwb.backend.internal.UwbAvailabilityCallback;
+import com.android.ranging.uwb.backend.internal.UwbServiceImpl;
+import com.android.server.ranging.CapabilitiesProvider.AvailabilityChangedReason;
+import com.android.server.ranging.CapabilitiesProvider.CapabilitiesAdapter;
+import com.android.server.ranging.CapabilitiesProvider.TechnologyAvailabilityListener;
+
+import java.time.Duration;
+
+public class UwbCapabilitiesAdapter extends CapabilitiesAdapter {
+    private static final String TAG = UwbCapabilitiesAdapter.class.getSimpleName();
+
+    private final Context mContext;
+    /** Null if UWB is not available on this device */
+    private final UwbServiceImpl mUwbService;
+
+    /** @return true if UWB is supported in the provided context, false otherwise */
+    public static boolean isSupported(Context context) {
+        return context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_UWB);
+    }
+
+    public UwbCapabilitiesAdapter(
+            @NonNull Context context,
+            @NonNull TechnologyAvailabilityListener listener
+    ) {
+        super(listener);
+        mContext = context;
+        if (isSupported(mContext)) {
+            mUwbService = new UwbServiceImpl(
+                    context,
+                    UwbServiceImpl.FEATURE_FLAGS,
+                    new AvailabilityListener());
+        } else {
+            mUwbService = null;
+        }
+    }
+
+    @Override
+    public @RangingTechnologyAvailability int getAvailability() {
+        if (mUwbService == null) {
+            return NOT_SUPPORTED;
+        } else if (mUwbService.isAvailable()) {
+            return ENABLED;
+        } else {
+            return DISABLED_USER;
+        }
+    }
+
+    private static UwbRangingCapabilities convertCapabilities(
+            com.android.ranging.uwb.backend.internal.RangingCapabilities capabilities
+    ) {
+        return new UwbRangingCapabilities.Builder()
+                .setSupportsDistance(capabilities.supportsDistance())
+                .setSupportsAzimuthalAngle(
+                        capabilities.supportsAzimuthalAngle())
+                .setSupportsElevationAngle(
+                        capabilities.supportsElevationAngle())
+                .setSupportsRangingIntervalReconfigure(
+                        capabilities.supportsRangingIntervalReconfigure())
+                .setMinRangingInterval(Duration.ofMillis(
+                        capabilities.getMinRangingInterval()))
+                .setSupportedChannels(
+                        capabilities.getSupportedChannels())
+                .setSupportedNtfConfigs(
+                        capabilities.getSupportedNtfConfigs())
+                .setSupportedConfigIds(
+                        capabilities.getSupportedConfigIds())
+                .setSupportedSlotDurations(
+                        capabilities.getSupportedSlotDurations())
+                .setSupportedRangingUpdateRates(
+                        capabilities.getSupportedRangingUpdateRates())
+                .setSupportedPreambleIndexes(capabilities.getSupportedPreambleIndexes())
+                .setHasBackgroundRangingSupport(
+                        capabilities.hasBackgroundRangingSupport())
+                .build();
+    }
+
+    @Override
+    public @Nullable UwbRangingCapabilities getCapabilities() {
+        if (getAvailability() == ENABLED) {
+            try {
+                return convertCapabilities(mUwbService.getRangingCapabilities());
+            } catch (IllegalStateException e) {
+                Log.w(TAG, "Failed to get capabilities from UWB backend " + e);
+            }
+        }
+        return null;
+    }
+
+    private class AvailabilityListener implements UwbAvailabilityCallback {
+
+        public static @AvailabilityChangedReason int convertReason(
+                @UwbStateChangeReason int reason
+        ) {
+            switch (reason) {
+                case REASON_SYSTEM_POLICY:
+                case REASON_COUNTRY_CODE_ERROR:
+                    return AvailabilityChangedReason.SYSTEM_POLICY;
+                default:
+                    return AvailabilityChangedReason.UNKNOWN;
+
+            }
+        }
+
+        @Override
+        public void onUwbAvailabilityChanged(
+                boolean isUwbAvailable, @UwbStateChangeReason int reason
+        ) {
+            TechnologyAvailabilityListener listener = getAvailabilityListener();
+            if (listener == null) return;
+
+            if (reason == REASON_COUNTRY_CODE_ERROR && !isUwbAvailable) {
+                listener.onAvailabilityChange(
+                        DISABLED_REGULATORY,
+                        convertReason(reason));
+            } else {
+                listener.onAvailabilityChange(
+                        isUwbAvailable
+                                ? ENABLED
+                                : DISABLED_USER,
+                        convertReason(reason));
+            }
+        }
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/uwb/UwbConfig.java b/ranging/service/java/com/android/server/ranging/uwb/UwbConfig.java
new file mode 100644
index 00000000..0c3495e3
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/uwb/UwbConfig.java
@@ -0,0 +1,227 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.uwb;
+
+import static android.ranging.RangingPreference.DEVICE_ROLE_RESPONDER;
+
+import android.ranging.DataNotificationConfig;
+import android.ranging.RangingDevice;
+import android.ranging.RangingPreference;
+import android.ranging.uwb.UwbAddress;
+import android.ranging.uwb.UwbComplexChannel;
+import android.ranging.uwb.UwbRangingParams;
+
+import androidx.annotation.NonNull;
+
+import com.android.ranging.uwb.backend.internal.UwbRangeDataNtfConfig;
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.session.RangingSessionConfig;
+
+import com.google.common.collect.ImmutableBiMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.uwb.support.base.RequiredParam;
+
+import java.util.List;
+import java.util.stream.Collectors;
+
+/**
+ * A complete configuration for UWB ranging. This encapsulates all information contained in a
+ * configuration message sent over OOB and everything required to start a session in the underlying
+ * UWB system API.
+ */
+public class UwbConfig implements RangingSessionConfig.MulticastTechnologyConfig {
+    private static final String TAG = UwbConfig.class.getSimpleName();
+
+    private final String mCountryCode;
+    private final DataNotificationConfig mDataNotificationConfig;
+    private final UwbRangingParams mParameters;
+    private final int mDeviceRole;
+    private final boolean mIsAoaNeeded;
+    private final ImmutableBiMap<RangingDevice, UwbAddress> mPeerAddresses;
+
+    private UwbConfig(Builder builder) {
+        mParameters = builder.mParameters;
+        mCountryCode = builder.mCountryCode.get();
+        mDataNotificationConfig = builder.mDataNotificationConfig;
+        mDeviceRole = builder.mDeviceRole;
+        mIsAoaNeeded = builder.mIsAoaNeeded;
+        mPeerAddresses = builder.mPeerAddresses.get();
+    }
+
+    @Override
+    public @NonNull RangingTechnology getTechnology() {
+        return RangingTechnology.UWB;
+    }
+
+    @Override
+    public @NonNull ImmutableSet<RangingDevice> getPeerDevices() {
+        return mPeerAddresses.keySet();
+    }
+
+    /** Returns the length of the session key. */
+    public final int getSessionKeyInfoLength() {
+        if (mParameters.getSessionKeyInfo() == null) {
+            return 0;
+        } else {
+            return mParameters.getSessionKeyInfo().length;
+        }
+    }
+
+    public @NonNull UwbRangingParams getParameters() {
+        return mParameters;
+    }
+
+    public @NonNull String getCountryCode() {
+        return mCountryCode;
+    }
+
+    public @NonNull DataNotificationConfig getDataNotificationConfig() {
+        return mDataNotificationConfig;
+    }
+
+    public int getDeviceRole() {
+        return mDeviceRole;
+    }
+
+    public boolean isAoaNeeded() {
+        return mIsAoaNeeded;
+    }
+
+    public @NonNull ImmutableBiMap<RangingDevice, UwbAddress> getPeerAddresses() {
+        return mPeerAddresses;
+    }
+
+
+    /**
+     * @return the configuration converted to a
+     * {@link androidx.core.uwb.backend.impl.internal.RangingParameters} accepted by the UWB
+     * backend.
+     */
+    public com.android.ranging.uwb.backend.internal.RangingParameters asBackendParameters() {
+        List<com.android.ranging.uwb.backend.internal.UwbAddress> peerAddresses = mPeerAddresses
+                .values()
+                .stream()
+                .map((address) ->
+                        com.android.ranging.uwb.backend.internal.UwbAddress.fromBytes(
+                                address.getAddressBytes()))
+                .collect(Collectors.toList());
+        return new com.android.ranging.uwb.backend.internal.RangingParameters(
+                (int) mParameters.getConfigId(),
+                mParameters.getSessionId(),
+                mParameters.getSubSessionId(),
+                mParameters.getSessionKeyInfo(),
+                mParameters.getSubSessionKeyInfo(),
+                toBackend(mParameters.getComplexChannel()),
+                peerAddresses,
+                (int) mParameters.getRangingUpdateRate(),
+                toBackend(getDataNotificationConfig()),
+                (int) mParameters.getSlotDuration(),
+                mIsAoaNeeded
+        );
+    }
+
+    public static @NonNull UwbRangeDataNtfConfig toBackend(
+            @NonNull DataNotificationConfig rangeDataNtfConfig
+    ) {
+        return new UwbRangeDataNtfConfig.Builder()
+                .setRangeDataConfigType((int) rangeDataNtfConfig.getNotificationConfigType())
+                .setNtfProximityNear(rangeDataNtfConfig.getProximityNearCm())
+                .setNtfProximityFar(rangeDataNtfConfig.getProximityFarCm())
+                .build();
+    }
+
+    public static @NonNull com.android.ranging.uwb.backend.internal.UwbComplexChannel toBackend(
+            @NonNull UwbComplexChannel complexChannel
+    ) {
+        return new com.android.ranging.uwb.backend.internal.UwbComplexChannel(
+                (int) complexChannel.getChannel(), (int) complexChannel.getPreambleIndex());
+    }
+
+    public static @NonNull com.android.ranging.uwb.backend.internal.UwbAddress toBackend(
+            @NonNull UwbAddress address
+    ) {
+        return com.android.ranging.uwb.backend.internal.UwbAddress.fromBytes(
+                address.getAddressBytes());
+    }
+
+
+    /** Builder for {@link UwbConfig}. */
+    public static class Builder {
+        private final UwbRangingParams mParameters;
+        private final RequiredParam<ImmutableBiMap<RangingDevice, UwbAddress>> mPeerAddresses =
+                new RequiredParam<>();
+        private final RequiredParam<String> mCountryCode = new RequiredParam<>();
+        private DataNotificationConfig mDataNotificationConfig =
+                new DataNotificationConfig.Builder().build();
+
+        private int mDeviceRole = DEVICE_ROLE_RESPONDER;
+        private boolean mIsAoaNeeded = false;
+
+        public Builder(@NonNull UwbRangingParams parameters) {
+            mParameters = parameters;
+        }
+
+        public @NonNull UwbConfig build() {
+            return new UwbConfig(this);
+        }
+
+        public Builder setPeerAddresses(
+                @NonNull ImmutableBiMap<RangingDevice, UwbAddress> addresses
+        ) {
+            mPeerAddresses.set(addresses);
+            return this;
+        }
+
+        public Builder setCountryCode(@NonNull String countryCode) {
+            mCountryCode.set(countryCode);
+            return this;
+        }
+
+        public Builder setDeviceRole(@RangingPreference.DeviceRole int deviceRole) {
+            mDeviceRole = deviceRole;
+            return this;
+        }
+
+        public Builder setAoaNeeded(boolean isAoaNeeded) {
+            mIsAoaNeeded = isAoaNeeded;
+            return this;
+        }
+
+        public Builder setDataNotificationConfig(@NonNull DataNotificationConfig config) {
+            mDataNotificationConfig = config;
+            return this;
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "UwbConfig{"
+                + "mParameters="
+                + mParameters
+                + ", mCountryCode='"
+                + mCountryCode
+                + ", mDataNotificationConfig="
+                + mDataNotificationConfig
+                + ", mDeviceRole="
+                + mDeviceRole
+                + ", mIsAoaNeeded="
+                + mIsAoaNeeded
+                + ", mPeerAddresses="
+                + mPeerAddresses
+                + " }";
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/uwb/UwbOobCapabilities.java b/ranging/service/java/com/android/server/ranging/uwb/UwbOobCapabilities.java
new file mode 100644
index 00000000..6a0a7202
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/uwb/UwbOobCapabilities.java
@@ -0,0 +1,231 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.uwb;
+
+import static com.google.common.collect.ImmutableList.toImmutableList;
+
+import android.ranging.uwb.UwbAddress;
+
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.RangingUtils.Conversions;
+import com.android.server.ranging.oob.TechnologyHeader;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableList;
+
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+/** Capability data for UWB sent as part of CapabilityResponseMessage. */
+@AutoValue
+public abstract class UwbOobCapabilities {
+
+    /** Size in bytes of all properties when serialized. */
+    private static final int EXPECTED_SIZE_BYTES = 20;
+
+    // Size in bytes for each properties for serialization/deserialization.
+    private static final int UWB_ADDRESS_SIZE = 2;
+    private static final int CHANNELS_SIZE = 4;
+    private static final int PREAMBLES_SIZE = 4;
+    private static final int CONFIG_IDS_SIZE = 4;
+    private static final int MIN_INTERVAL_SIZE = 2;
+    private static final int MIN_SLOT_SIZE = 1;
+    private static final int DEVICE_ROLE_SIZE = 1;
+
+    private static final int CHANNELS_SHIFT = 0;
+    private static final int PREAMBLES_SHIFT = 1;
+    private static final int CONFIG_IDS_SHIFT = 0;
+    private static final int DEVICE_ROLE_SHIFT = 1;
+
+    /** Returns the size of the object in bytes when serialized. */
+    public static int getSize() {
+        return EXPECTED_SIZE_BYTES;
+    }
+
+    /**
+     * Parses the given byte array and returns {@link UwbOobCapabilities} object. Throws {@link
+     * IllegalArgumentException} on invalid input.
+     */
+    public static UwbOobCapabilities parseBytes(byte[] capabilitiesBytes) {
+        TechnologyHeader header = TechnologyHeader.parseBytes(capabilitiesBytes);
+
+        if (capabilitiesBytes.length < EXPECTED_SIZE_BYTES) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "UwbCapabilities size is %d, expected at least %d",
+                            capabilitiesBytes.length, EXPECTED_SIZE_BYTES));
+        }
+
+        if (capabilitiesBytes.length < header.getSize()) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "UwbCapabilities header size field is %d, but the size of the array "
+                                    + "is %d",
+                            header.getSize(), capabilitiesBytes.length));
+        }
+
+        if (header.getRangingTechnology() != RangingTechnology.UWB) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "UwbCapabilities header technology field is %s, expected %s",
+                            header.getRangingTechnology(), RangingTechnology.UWB));
+        }
+
+        int parseCursor = header.getHeaderSize();
+
+        // Parse UWB Address
+        UwbAddress uwbAddress =
+                UwbAddress.fromBytes(
+                        Arrays.copyOfRange(capabilitiesBytes, parseCursor,
+                                parseCursor + UWB_ADDRESS_SIZE));
+        parseCursor += UWB_ADDRESS_SIZE;
+
+        // Parse Supported Channels
+        ImmutableList<Integer> supportedChannels =
+                Conversions.byteArrayToIntList(
+                        Arrays.copyOfRange(capabilitiesBytes, parseCursor,
+                                parseCursor + CHANNELS_SIZE),
+                        CHANNELS_SHIFT);
+        parseCursor += CHANNELS_SIZE;
+
+        // Parse Supported Preamble Indexes
+        ImmutableList<Integer> supportedPreambleIndexes =
+                Conversions.byteArrayToIntList(
+                        Arrays.copyOfRange(capabilitiesBytes, parseCursor,
+                                parseCursor + PREAMBLES_SIZE),
+                        PREAMBLES_SHIFT);
+        parseCursor += PREAMBLES_SIZE;
+
+        // Parse Supported Config Ids
+        ImmutableList<Integer> supportedConfigIds =
+                Conversions.byteArrayToIntList(
+                        Arrays.copyOfRange(capabilitiesBytes, parseCursor,
+                                parseCursor + CONFIG_IDS_SIZE),
+                        CONFIG_IDS_SHIFT);
+        parseCursor += CONFIG_IDS_SIZE;
+
+        // Parse Minimum Ranging Interval Ms
+        int minimumRangingIntervalMs =
+                Conversions.byteArrayToInt(
+                        Arrays.copyOfRange(capabilitiesBytes, parseCursor,
+                                parseCursor + MIN_INTERVAL_SIZE));
+        parseCursor += MIN_INTERVAL_SIZE;
+
+        // Parse Minimum Slot Duration Ms
+        int minimumSlotDurationMs =
+                Conversions.byteArrayToInt(
+                        Arrays.copyOfRange(capabilitiesBytes, parseCursor,
+                                parseCursor + MIN_SLOT_SIZE));
+        parseCursor += MIN_SLOT_SIZE;
+
+        // Parse Device Role
+        ImmutableList<Integer> deviceRoles =
+                Conversions.byteArrayToIntList(
+                                Arrays.copyOfRange(capabilitiesBytes, parseCursor,
+                                        parseCursor + DEVICE_ROLE_SIZE),
+                                DEVICE_ROLE_SHIFT)
+                        .stream()
+                        .collect(toImmutableList());
+        parseCursor += DEVICE_ROLE_SIZE;
+
+        return UwbOobCapabilities.builder()
+                .setUwbAddress(uwbAddress)
+                .setSupportedChannels(supportedChannels)
+                .setSupportedConfigIds(supportedConfigIds)
+                .setSupportedPreambleIndexes(supportedPreambleIndexes)
+                .setMinimumRangingIntervalMs(minimumRangingIntervalMs)
+                .setMinimumSlotDurationMs(minimumSlotDurationMs)
+                .setSupportedDeviceRole(deviceRoles)
+                .build();
+    }
+
+    /** Serializes this {@link UwbOobCapabilities} object to bytes. */
+    public final byte[] toBytes() {
+        ByteBuffer byteBuffer = ByteBuffer.allocate(EXPECTED_SIZE_BYTES);
+        byteBuffer
+                .put(RangingTechnology.UWB.toByte())
+                .put((byte) EXPECTED_SIZE_BYTES)
+                .put(getUwbAddress().getAddressBytes())
+                .put(Conversions.intListToByteArrayBitmap(getSupportedChannels(), CHANNELS_SIZE,
+                        CHANNELS_SHIFT))
+                .put(
+                        Conversions.intListToByteArrayBitmap(
+                                getSupportedPreambleIndexes(), PREAMBLES_SIZE, PREAMBLES_SHIFT))
+                .put(
+                        Conversions.intListToByteArrayBitmap(
+                                getSupportedConfigIds(), CONFIG_IDS_SIZE, CONFIG_IDS_SHIFT))
+                .put(Conversions.intToByteArray(getMinimumRangingIntervalMs(), MIN_INTERVAL_SIZE))
+                .put(Conversions.intToByteArray(getMinimumSlotDurationMs(), MIN_SLOT_SIZE))
+                .put(
+                        Conversions.intListToByteArrayBitmap(
+                                getSupportedDeviceRole().stream()
+                                        .collect(toImmutableList()),
+                                DEVICE_ROLE_SIZE,
+                                DEVICE_ROLE_SHIFT));
+
+        return byteBuffer.array();
+    }
+
+    /** Returns the {@link UwbAddress} of the device. */
+    public abstract UwbAddress getUwbAddress();
+
+    /** Returns a list of supported channels. */
+    public abstract ImmutableList<Integer> getSupportedChannels();
+
+    /** Returns a list of supported preamble indexes. */
+    public abstract ImmutableList<Integer> getSupportedPreambleIndexes();
+
+    /** Returns a list of supported config Ids. */
+    public abstract ImmutableList<Integer> getSupportedConfigIds();
+
+    /** Returns minimum supported ranging interval in ms. */
+    public abstract int getMinimumRangingIntervalMs();
+
+    /** Returns minimum supported slot duration in ms. */
+    public abstract int getMinimumSlotDurationMs();
+
+    /** Returns supported device roles. */
+    public abstract ImmutableList<Integer> getSupportedDeviceRole();
+
+    /** Returns a builder for {@link UwbOobCapabilities}. */
+    public static Builder builder() {
+        return new AutoValue_UwbOobCapabilities.Builder();
+    }
+
+    /** Builder for {@link UwbOobCapabilities}. */
+    @AutoValue.Builder
+    public abstract static class Builder {
+
+        public abstract Builder setUwbAddress(UwbAddress uwbAddress);
+
+        public abstract Builder setSupportedChannels(ImmutableList<Integer> supportedChannels);
+
+        public abstract Builder setSupportedPreambleIndexes(
+                ImmutableList<Integer> supportedPreambleIndexes);
+
+        public abstract Builder setSupportedConfigIds(ImmutableList<Integer> supportedConfigIds);
+
+        public abstract Builder setMinimumRangingIntervalMs(int minimumRangingIntervalMs);
+
+        public abstract Builder setMinimumSlotDurationMs(int minimumSlotDurationMs);
+
+        public abstract Builder setSupportedDeviceRole(
+                ImmutableList<Integer> supportedDeviceRole);
+
+        public abstract UwbOobCapabilities build();
+    }
+}
diff --git a/ranging/service/java/com/android/server/ranging/uwb/UwbOobConfig.java b/ranging/service/java/com/android/server/ranging/uwb/UwbOobConfig.java
new file mode 100644
index 00000000..4e00df33
--- /dev/null
+++ b/ranging/service/java/com/android/server/ranging/uwb/UwbOobConfig.java
@@ -0,0 +1,307 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.uwb;
+
+import static java.nio.charset.StandardCharsets.US_ASCII;
+
+import android.annotation.IntDef;
+import android.ranging.uwb.UwbAddress;
+
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.RangingUtils.Conversions;
+import com.android.server.ranging.oob.TechnologyHeader;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Preconditions;
+
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+/** Configuration for UWB sent as part SetConfigurationMessage for Finder OOB. */
+@AutoValue
+public abstract class UwbOobConfig {
+
+    @IntDef({
+            OobDeviceMode.UNKNOWN,
+            OobDeviceMode.CONTROLLER,
+            OobDeviceMode.CONTROLEE,
+    })
+    public @interface OobDeviceMode {
+        int UNKNOWN = 0;
+        int CONTROLLER = 1;
+        int CONTROLEE = 2;
+    }
+
+    @IntDef({
+            OobDeviceRole.UNKNOWN,
+            OobDeviceRole.INITIATOR,
+            OobDeviceRole.RESPONDER,
+    })
+    public @interface OobDeviceRole {
+        int UNKNOWN = 0;
+        int INITIATOR = 1;
+        int RESPONDER = 2;
+    }
+
+    private static final int MIN_SIZE_BYTES = 20;
+
+    // Size in bytes for properties when serialized.
+    private static final int UWB_ADDRESS_SIZE = 2;
+    private static final int SESSION_ID_SIZE = 4;
+    private static final int CONFIG_ID_SIZE = 1;
+    private static final int CHANNEL_SIZE = 1;
+    private static final int PREAMBLE_INDEX_SIZE = 1;
+    private static final int RANGING_INTERVAL_SIZE = 2;
+    private static final int SLOT_DURATION_SIZE = 1;
+    private static final int SESSION_KEY_LENGTH_SIZE = 1;
+    private static final int STS_SESSION_KEY_SIZE = 8;
+    private static final int PSTS_SHORT_SESSION_KEY_SIZE = 16;
+    private static final int PSTS_LONG_SESSION_KEY_SIZE = 32;
+    private static final int COUNTRY_CODE_SIZE = 2;
+    private static final int DEVICE_ROLE_SIZE = 1;
+    private static final int DEVICE_MODE_SIZE = 1;
+
+    /** Returns the size of the object in bytes when serialized. */
+    public final int getSize() {
+        return MIN_SIZE_BYTES + getSessionKeyLength();
+    }
+
+    /**
+     * Parses the given byte array and returns {@link UwbOobConfig} object. Throws {@link
+     * IllegalArgumentException} on invalid input.
+     */
+    public static UwbOobConfig parseBytes(byte[] uwbConfigBytes) {
+        TechnologyHeader header = TechnologyHeader.parseBytes(uwbConfigBytes);
+
+        if (uwbConfigBytes.length < MIN_SIZE_BYTES) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "UwbConfig size is %d, expected at least %d", uwbConfigBytes.length,
+                            MIN_SIZE_BYTES));
+        }
+
+        if (uwbConfigBytes.length < header.getSize()) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "UwbConfig header size field is %d, but the size of the array is %d",
+                            header.getSize(), uwbConfigBytes.length));
+        }
+
+        if (header.getRangingTechnology() != RangingTechnology.UWB) {
+            throw new IllegalArgumentException(
+                    String.format(
+                            "UwbConfig header technology field is %s, expected %s",
+                            header.getRangingTechnology(), RangingTechnology.UWB));
+        }
+
+        int parseCursor = header.getHeaderSize();
+
+        // Parse Uwb Address
+        UwbAddress uwbAddress =
+                UwbAddress.fromBytes(
+                        Arrays.copyOfRange(uwbConfigBytes, parseCursor,
+                                parseCursor + UWB_ADDRESS_SIZE));
+        parseCursor += UWB_ADDRESS_SIZE;
+
+        // Parse Session Id
+        int sessionId =
+                Conversions.byteArrayToInt(
+                        Arrays.copyOfRange(uwbConfigBytes, parseCursor,
+                                parseCursor + SESSION_ID_SIZE));
+        parseCursor += SESSION_ID_SIZE;
+
+        // Parse Config Id
+        int configId = uwbConfigBytes[parseCursor];
+        parseCursor += CONFIG_ID_SIZE;
+
+        // Parse Channel
+        int channel = uwbConfigBytes[parseCursor];
+        parseCursor += CHANNEL_SIZE;
+
+        // Parse Preamble Index
+        int preambleIndex = uwbConfigBytes[parseCursor];
+        parseCursor += PREAMBLE_INDEX_SIZE;
+
+        // Parse Ranging Interval Ms
+        int rangingIntervalMs =
+                Conversions.byteArrayToInt(
+                        Arrays.copyOfRange(uwbConfigBytes, parseCursor,
+                                parseCursor + RANGING_INTERVAL_SIZE));
+        parseCursor += RANGING_INTERVAL_SIZE;
+
+        // Parse Slot Duration
+        int slotDurationMs = uwbConfigBytes[parseCursor];
+        parseCursor += SLOT_DURATION_SIZE;
+
+        // Parse Session Key
+        int sessionKeyLength = uwbConfigBytes[parseCursor];
+        parseCursor += SESSION_KEY_LENGTH_SIZE;
+
+        if (uwbConfigBytes.length < MIN_SIZE_BYTES + sessionKeyLength) {
+            throw new IllegalArgumentException(
+                    "Failed to parse UwbConfig, invalid size. Bytes: " + Arrays.toString(
+                            uwbConfigBytes));
+        }
+        byte[] sessionKey = Arrays.copyOfRange(
+                uwbConfigBytes, parseCursor, parseCursor + sessionKeyLength);
+        parseCursor += sessionKeyLength;
+
+        // Parse Country Code
+        String countryCode =
+                new String(
+                        Arrays.copyOfRange(uwbConfigBytes, parseCursor,
+                                parseCursor + COUNTRY_CODE_SIZE));
+        parseCursor += COUNTRY_CODE_SIZE;
+
+        // Parse Device Role
+        @OobDeviceRole int deviceRole = uwbConfigBytes[parseCursor];
+        parseCursor += DEVICE_ROLE_SIZE;
+
+        // Parse Device Mode
+        @OobDeviceMode int deviceMode = uwbConfigBytes[parseCursor];
+        parseCursor += DEVICE_MODE_SIZE;
+
+        return builder()
+                .setUwbAddress(uwbAddress)
+                .setSessionId(sessionId)
+                .setSelectedConfigId(configId)
+                .setSelectedChannel(channel)
+                .setSelectedPreambleIndex(preambleIndex)
+                .setSelectedRangingIntervalMs(rangingIntervalMs)
+                .setSelectedSlotDurationMs(slotDurationMs)
+                .setSessionKey(sessionKey)
+                .setCountryCode(countryCode)
+                .setDeviceRole(deviceRole)
+                .setDeviceMode(deviceMode)
+                .build();
+    }
+
+    /** Serializes this {@link UwbOobConfig} object to bytes. */
+    public final byte[] toBytes() {
+        int size = MIN_SIZE_BYTES + getSessionKeyLength();
+        return ByteBuffer.allocate(size)
+                .put(RangingTechnology.UWB.toByte())
+                .put((byte) size)
+                .put(RangingTechnology.UWB.toByte())
+                .put(getUwbAddress().getAddressBytes())
+                .put(Conversions.intToByteArray(getSessionId(), SESSION_ID_SIZE))
+                .put(Conversions.intToByteArray(getSelectedConfigId(), CONFIG_ID_SIZE))
+                .put(Conversions.intToByteArray(getSelectedChannel(), CHANNEL_SIZE))
+                .put(Conversions.intToByteArray(getSelectedPreambleIndex(), PREAMBLE_INDEX_SIZE))
+                .put(Conversions.intToByteArray(getSelectedRangingIntervalMs(),
+                        RANGING_INTERVAL_SIZE))
+                .put(Conversions.intToByteArray(getSelectedSlotDurationMs(), SLOT_DURATION_SIZE))
+                .put(Conversions.intToByteArray(getSessionKeyLength(), SESSION_KEY_LENGTH_SIZE))
+                .put(getSessionKey())
+                .put(getCountryCode().getBytes(US_ASCII))
+                .put(Conversions.intToByteArray(getDeviceRole(), DEVICE_ROLE_SIZE))
+                .put(Conversions.intToByteArray(getDeviceMode(), DEVICE_MODE_SIZE))
+                .array();
+    }
+
+    /** Returns {@link UwbAddress} of the device. */
+    public abstract UwbAddress getUwbAddress();
+
+    /** Returns the session Id. */
+    public abstract int getSessionId();
+
+    /** Returns the selected config Id. */
+    public abstract int getSelectedConfigId();
+
+    /** Returns the selected channel. */
+    public abstract int getSelectedChannel();
+
+    /** Returns the selected preamble index. */
+    public abstract int getSelectedPreambleIndex();
+
+    /** Returns the selected ranging interval in ms. */
+    public abstract int getSelectedRangingIntervalMs();
+
+    /** Returns the selected slot duration in ms. */
+    public abstract int getSelectedSlotDurationMs();
+
+    /** Returns the length of the session key. */
+    public final int getSessionKeyLength() {
+        return getSessionKey().length;
+    }
+
+    /**
+     * Returns the session key bytes. If S-STS is used then first two bytes are VENDOR ID and
+     * following 6 bytes are STATIC STS IV. If P-STS is used then this is either a 16 byte or 32
+     * byte
+     * session key.
+     */
+    @SuppressWarnings("mutable")
+    public abstract byte[] getSessionKey();
+
+    /** Returns ISO 3166-1 alpha-2 country code, represented by 2 ascii characters */
+    public abstract String getCountryCode();
+
+    /** Returns Device Role. */
+    public abstract @OobDeviceRole int getDeviceRole();
+
+    /** Returns Device Mode. */
+    public abstract @OobDeviceMode int getDeviceMode();
+
+    /** Returns a builder for {@link UwbOobConfig}. */
+    public static Builder builder() {
+        return new AutoValue_UwbOobConfig.Builder().setSessionKey(new byte[]{});
+    }
+
+    /** Builder for {@link UwbOobConfig}. */
+    @AutoValue.Builder
+    public abstract static class Builder {
+        public abstract Builder setUwbAddress(UwbAddress uwbAddress);
+
+        public abstract Builder setSessionId(int sessionId);
+
+        public abstract Builder setSelectedConfigId(int selectedConfigId);
+
+        public abstract Builder setSelectedChannel(int selectedChannel);
+
+        public abstract Builder setSelectedPreambleIndex(int selectedPreambleIndex);
+
+        public abstract Builder setSelectedRangingIntervalMs(int selectedRangingIntervalMs);
+
+        public abstract Builder setSelectedSlotDurationMs(int selectedSlotDurationMs);
+
+        public abstract Builder setSessionKey(byte[] sessionKey);
+
+        public abstract Builder setCountryCode(String countryCode);
+
+        public abstract Builder setDeviceRole(@OobDeviceRole int deviceRole);
+
+        public abstract Builder setDeviceMode(@OobDeviceMode int deviceMode);
+
+        abstract UwbOobConfig autoBuild();
+
+        public UwbOobConfig build() {
+            UwbOobConfig uwbConfig = autoBuild();
+            Preconditions.checkNotNull(uwbConfig.getUwbAddress(), "UwbAddress cannot be null");
+            int sessionKeyLength = uwbConfig.getSessionKeyLength();
+            Preconditions.checkArgument(
+                    sessionKeyLength == STS_SESSION_KEY_SIZE
+                            || sessionKeyLength == PSTS_SHORT_SESSION_KEY_SIZE
+                            || sessionKeyLength == PSTS_LONG_SESSION_KEY_SIZE,
+                    "Invalid session key length");
+            Preconditions.checkArgument(
+                    uwbConfig.getCountryCode().length() == COUNTRY_CODE_SIZE,
+                    "Invalid country code length");
+            return uwbConfig;
+        }
+    }
+}
diff --git a/generic_ranging/tests/units/Android.bp b/ranging/service/tests/unittests/Android.bp
similarity index 82%
rename from generic_ranging/tests/units/Android.bp
rename to ranging/service/tests/unittests/Android.bp
index 90367bba..f1e431d0 100644
--- a/generic_ranging/tests/units/Android.bp
+++ b/ranging/service/tests/unittests/Android.bp
@@ -25,12 +25,17 @@ android_test {
     sdk_version: "34",
     certificate: "platform",
     static_libs: [
-        "generic_ranging",
+        "service-ranging-pre-jarjar",
         "framework-uwb.stubs.module_lib",
         "androidx.test.rules",
         "androidx.test.ext.junit",
         "androidx.test.runner",
-        "mockito-target-minus-junit4",
+        "mockito-target-extended-minus-junit4",
+    ],
+    jni_libs: [
+        // these are needed for Extended Mockito
+        "libdexmakerjvmtiagent",
+        "libstaticjvmtiagent",
     ],
     test_suites: ["device-tests"],
 }
diff --git a/generic_ranging/tests/units/AndroidManifest.xml b/ranging/service/tests/unittests/AndroidManifest.xml
similarity index 96%
rename from generic_ranging/tests/units/AndroidManifest.xml
rename to ranging/service/tests/unittests/AndroidManifest.xml
index b763a898..ab8b7596 100644
--- a/generic_ranging/tests/units/AndroidManifest.xml
+++ b/ranging/service/tests/unittests/AndroidManifest.xml
@@ -21,7 +21,7 @@
 
     <uses-sdk android:minSdkVersion="34" android:targetSdkVersion="34" />
 
-    <application>
+    <application android:debuggable="true">
         <uses-library android:name="android.test.runner" />
     </application>
 
diff --git a/generic_ranging/tests/units/AndroidTest.xml b/ranging/service/tests/unittests/AndroidTest.xml
similarity index 100%
rename from generic_ranging/tests/units/AndroidTest.xml
rename to ranging/service/tests/unittests/AndroidTest.xml
diff --git a/generic_ranging/tests/units/OWNERS b/ranging/service/tests/unittests/OWNERS
similarity index 100%
rename from generic_ranging/tests/units/OWNERS
rename to ranging/service/tests/unittests/OWNERS
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/CapabilitiesProviderTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/CapabilitiesProviderTest.java
new file mode 100644
index 00000000..8389791e
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/CapabilitiesProviderTest.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests;
+
+import static com.android.server.ranging.CapabilitiesProvider.AvailabilityChangedReason.SYSTEM_POLICY;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.argThat;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.os.RemoteException;
+import android.ranging.IRangingCapabilitiesCallback;
+
+import androidx.test.filters.SmallTest;
+
+import com.android.server.ranging.CapabilitiesProvider;
+import com.android.server.ranging.CapabilitiesProvider.CapabilitiesAdapter;
+import com.android.server.ranging.CapabilitiesProvider.TechnologyAvailabilityListener;
+import com.android.server.ranging.RangingInjector;
+import com.android.server.ranging.RangingTechnology;
+
+import junit.framework.Assert;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Answers;
+import org.mockito.ArgumentCaptor;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.junit.MockitoJUnit;
+import org.mockito.junit.MockitoRule;
+
+import java.util.EnumMap;
+
+@RunWith(JUnit4.class)
+@SmallTest
+public class CapabilitiesProviderTest {
+    @Rule
+    public final MockitoRule mMockito = MockitoJUnit.rule();
+
+    @Mock
+    private RangingInjector mMockInjector;
+
+    @Mock(answer = Answers.RETURNS_DEEP_STUBS)
+    private IRangingCapabilitiesCallback mMockCallback;
+
+    private final EnumMap<RangingTechnology, CapabilitiesAdapter> mMockAdapters =
+            new EnumMap<>(RangingTechnology.class);
+
+    private CapabilitiesProvider mCapabilitiesProvider;
+
+    public void registerInitialCallback() {
+        mCapabilitiesProvider.registerCapabilitiesCallback(mMockCallback);
+
+        for (RangingTechnology technology : RangingTechnology.TECHNOLOGIES) {
+            ArgumentCaptor<TechnologyAvailabilityListener> captor =
+                    ArgumentCaptor.forClass(TechnologyAvailabilityListener.class);
+
+            verify(mMockInjector)
+                    .createCapabilitiesAdapter(eq(technology), captor.capture());
+
+            when(mMockAdapters.get(technology).getAvailabilityListener())
+                    .thenReturn(captor.getValue());
+        }
+    }
+
+    @Before
+    public void setup() {
+        for (RangingTechnology technology : RangingTechnology.TECHNOLOGIES) {
+            CapabilitiesAdapter adapter = mock(CapabilitiesAdapter.class);
+            mMockAdapters.put(technology, adapter);
+            when(mMockInjector.createCapabilitiesAdapter(eq(technology), any()))
+                    .thenReturn(adapter);
+
+        }
+
+        mCapabilitiesProvider = new CapabilitiesProvider(mMockInjector);
+    }
+
+    @Test
+    public void should_sendCapabilitiesAfterRegistration() throws RemoteException {
+        registerInitialCallback();
+
+        verify(mMockCallback).onRangingCapabilities(
+                argThat((capabilities) -> capabilities
+                        .getTechnologyAvailability()
+                        .keySet()
+                        .containsAll(RangingTechnology.TECHNOLOGIES
+                                .stream()
+                                .map(RangingTechnology::getValue).toList())
+                )
+        );
+
+        for (CapabilitiesAdapter adapter : mMockAdapters.values()) {
+            Assert.assertNotNull(adapter.getAvailabilityListener());
+            verify(adapter).getCapabilities();
+            verify(adapter).getAvailability();
+        }
+    }
+
+    @Test
+    public void should_sendCapabilitiesWhenAdapterAvailabilityChanges() throws RemoteException {
+        InOrder inOrder = inOrder(mMockCallback);
+
+        registerInitialCallback();
+        inOrder.verify(mMockCallback).onRangingCapabilities(any());
+
+        CapabilitiesAdapter adapter = mMockAdapters.get(RangingTechnology.UWB);
+        Assert.assertNotNull(adapter.getAvailabilityListener());
+
+        Integer mockAvailability = mock(Integer.class);
+        adapter.getAvailabilityListener().onAvailabilityChange(mockAvailability, SYSTEM_POLICY);
+        inOrder.verify(mMockCallback).onRangingCapabilities(
+                argThat((capabilities) -> capabilities
+                        .getTechnologyAvailability()
+                        .get(RangingTechnology.UWB.getValue()).equals(mockAvailability)
+                )
+        );
+    }
+
+    @Test
+    public void shouldNot_getCapabilitiesFromAdaptersWhenCached() throws RemoteException {
+        registerInitialCallback();
+        mCapabilitiesProvider.registerCapabilitiesCallback(mMockCallback);
+
+        verify(mMockCallback, times(2)).onRangingCapabilities(any());
+        for (CapabilitiesAdapter adapter : mMockAdapters.values()) {
+            verify(adapter, times(1)).getCapabilities();
+        }
+    }
+
+    @Test
+    public void
+    should_notifyMultipleCallbacksWhenAdapterAvailabilityChanges() throws RemoteException {
+        IRangingCapabilitiesCallback anotherMockCallback =
+                mock(IRangingCapabilitiesCallback.class, Answers.RETURNS_DEEP_STUBS);
+
+        registerInitialCallback();
+        mCapabilitiesProvider.registerCapabilitiesCallback(anotherMockCallback);
+
+        for (CapabilitiesAdapter adapter : mMockAdapters.values()) {
+            Assert.assertNotNull(adapter.getAvailabilityListener());
+            adapter.getAvailabilityListener()
+                    .onAvailabilityChange(mock(Integer.class), mock(Integer.class));
+        }
+
+        verify(mMockCallback, times(1 + mMockAdapters.size())).onRangingCapabilities(any());
+        verify(anotherMockCallback, times(1 + mMockAdapters.size())).onRangingCapabilities(any());
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/RangingSessionConfigTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/RangingSessionConfigTest.java
new file mode 100644
index 00000000..26af22f6
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/RangingSessionConfigTest.java
@@ -0,0 +1,152 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests;
+
+import static android.ranging.RangingPreference.DEVICE_ROLE_INITIATOR;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_NORMAL;
+import static android.ranging.uwb.UwbRangingParams.CONFIG_UNICAST_DS_TWR;
+import static android.ranging.uwb.UwbRangingParams.DURATION_1_MS;
+import static android.ranging.uwb.UwbRangingParams.DURATION_2_MS;
+
+import static org.mockito.Mockito.mock;
+
+import android.ranging.DataNotificationConfig;
+import android.ranging.RangingDevice;
+import android.ranging.SensorFusionParams;
+import android.ranging.raw.RawRangingDevice;
+import android.ranging.uwb.UwbAddress;
+import android.ranging.uwb.UwbComplexChannel;
+import android.ranging.uwb.UwbRangingParams;
+import android.util.Pair;
+
+import androidx.test.filters.SmallTest;
+
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.session.RangingSessionConfig;
+import com.android.server.ranging.session.RangingSessionConfig.MulticastTechnologyConfig;
+import com.android.server.ranging.session.RangingSessionConfig.TechnologyConfig;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.util.List;
+import java.util.Set;
+
+@SuppressWarnings("ConstantConditions")
+@RunWith(JUnit4.class)
+@SmallTest
+public class RangingSessionConfigTest {
+
+    private RangingSessionConfig mConfig;
+
+    private UwbRangingParams.Builder generateUwbParams(UwbAddress peerAddress) {
+        return new UwbRangingParams.Builder(
+                10,
+                CONFIG_UNICAST_DS_TWR,
+                UwbAddress.fromBytes(new byte[]{1, 2}),
+                peerAddress)
+                .setComplexChannel(
+                        new UwbComplexChannel.Builder()
+                                .setChannel(9)
+                                .setPreambleIndex(11)
+                                .build())
+                .setRangingUpdateRate(UPDATE_RATE_NORMAL);
+    }
+
+    @Before
+    public void setup() {
+        mConfig = new RangingSessionConfig.Builder()
+                .setDeviceRole(DEVICE_ROLE_INITIATOR)
+                .setSensorFusionConfig(new SensorFusionParams.Builder().build())
+                .setDataNotificationConfig(new DataNotificationConfig.Builder().build())
+                .setAoaNeeded(true)
+                .build();
+    }
+
+    @Test
+    public void should_combineIdenticallyConfiguredUwbSessions() {
+        List<Pair<RangingDevice, UwbAddress>> peers = List.of(
+                Pair.create(mock(RangingDevice.class), UwbAddress.fromBytes(new byte[]{1, 2})),
+                Pair.create(mock(RangingDevice.class), UwbAddress.fromBytes(new byte[]{3, 4})));
+
+        Set<RawRangingDevice> deviceParams = Set.of(
+                new RawRangingDevice.Builder()
+                        .setRangingDevice(peers.get(0).first)
+                        .setUwbRangingParams(generateUwbParams(peers.get(0).second).build())
+                        .build(),
+                new RawRangingDevice.Builder()
+                        .setRangingDevice(peers.get(1).first)
+                        .setUwbRangingParams(generateUwbParams(peers.get(1).second).build())
+                        .build()
+        );
+
+        ImmutableSet<TechnologyConfig> tcs = mConfig.getTechnologyConfigs(deviceParams);
+
+        Assert.assertEquals(1, tcs.size());
+
+        TechnologyConfig tc = Iterables.getOnlyElement(tcs);
+
+        Assert.assertEquals(RangingTechnology.UWB, tc.getTechnology());
+        Assert.assertTrue(tc instanceof MulticastTechnologyConfig);
+
+        MulticastTechnologyConfig mtc = (MulticastTechnologyConfig) tc;
+        Assert.assertEquals(2, mtc.getPeerDevices().size());
+        Assert.assertTrue(mtc.getPeerDevices().contains(peers.get(0).first));
+        Assert.assertTrue(mtc.getPeerDevices().contains(peers.get(1).first));
+    }
+
+    @Test
+    public void shouldNot_combineUniquelyConfiguredUwbSessions() {
+        List<Pair<RangingDevice, UwbAddress>> peers = List.of(
+                Pair.create(mock(RangingDevice.class), UwbAddress.fromBytes(new byte[]{1, 2})),
+                Pair.create(mock(RangingDevice.class), UwbAddress.fromBytes(new byte[]{3, 4})));
+
+        Set<RawRangingDevice> deviceParams = Set.of(
+                new RawRangingDevice.Builder()
+                        .setRangingDevice(peers.get(0).first)
+                        .setUwbRangingParams(
+                                generateUwbParams(peers.get(0).second)
+                                        .setSlotDuration(DURATION_1_MS)
+                                        .build())
+                        .build(),
+                new RawRangingDevice.Builder()
+                        .setRangingDevice(peers.get(1).first)
+                        .setUwbRangingParams(
+                                generateUwbParams(peers.get(1).second)
+                                        .setSlotDuration(DURATION_2_MS)
+                                        .build())
+                        .build()
+        );
+
+        ImmutableSet<TechnologyConfig> tcs = mConfig.getTechnologyConfigs(deviceParams);
+        Assert.assertEquals(2, tcs.size());
+
+        for (TechnologyConfig tc : tcs) {
+            Assert.assertEquals(RangingTechnology.UWB, tc.getTechnology());
+            Assert.assertTrue(tc instanceof MulticastTechnologyConfig);
+
+            MulticastTechnologyConfig mtc = (MulticastTechnologyConfig) tc;
+            Assert.assertEquals(1, mtc.getPeerDevices().size());
+        }
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/RangingSessionTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/RangingSessionTest.java
new file mode 100644
index 00000000..6628194c
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/RangingSessionTest.java
@@ -0,0 +1,363 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests;
+
+import static com.android.server.ranging.RangingTechnology.CS;
+import static com.android.server.ranging.RangingTechnology.RTT;
+import static com.android.server.ranging.RangingTechnology.UWB;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.argThat;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.AttributionSource;
+import android.ranging.RangingData;
+import android.ranging.RangingDevice;
+import android.ranging.RangingMeasurement;
+import android.ranging.SensorFusionParams;
+import android.ranging.SessionHandle;
+import android.ranging.raw.RawInitiatorRangingParams;
+
+import androidx.test.filters.SmallTest;
+
+import com.android.server.ranging.RangingAdapter;
+import com.android.server.ranging.RangingAdapter.Callback.ClosedReason;
+import com.android.server.ranging.RangingInjector;
+import com.android.server.ranging.RangingServiceManager;
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.session.RangingSessionConfig;
+import com.android.server.ranging.session.RangingSessionConfig.MulticastTechnologyConfig;
+import com.android.server.ranging.session.RangingSessionConfig.TechnologyConfig;
+import com.android.server.ranging.session.RangingSessionConfig.UnicastTechnologyConfig;
+import com.android.server.ranging.session.RawInitiatorRangingSession;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
+import com.google.common.util.concurrent.MoreExecutors;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Answers;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.junit.MockitoJUnit;
+import org.mockito.junit.MockitoRule;
+
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+@SuppressWarnings("ConstantConditions")
+@RunWith(JUnit4.class)
+@SmallTest
+public class RangingSessionTest {
+    @Rule
+    public final MockitoRule mMockito = MockitoJUnit.rule();
+
+    private @Mock AttributionSource mMockAttributionSource;
+    private @Mock SessionHandle mMockSessionHandle;
+    private @Mock(answer = Answers.RETURNS_DEEP_STUBS) RangingInjector mMockInjector;
+    private @Mock(answer = Answers.RETURNS_DEEP_STUBS) RangingSessionConfig mMockConfig;
+    private @Mock(answer = Answers.RETURNS_DEEP_STUBS) RawInitiatorRangingParams mMockParams;
+    private @Mock RangingServiceManager.SessionListener mMockSessionListener;
+    private Map<TechnologyConfig, RangingAdapter> mMockAdapters;
+    private RawInitiatorRangingSession mSession;
+
+    private void configureSession(Set<TechnologyConfig> technologyConfigs) {
+        // Create some mock adapters for this session.
+        for (TechnologyConfig config : technologyConfigs) {
+            RangingAdapter adapter = mock(RangingAdapter.class);
+            mMockAdapters.put(config, adapter);
+            when(mMockInjector.createAdapter(eq(config), anyInt(), any())).thenReturn(adapter);
+        }
+
+        // Start the session
+        when(mMockConfig.getTechnologyConfigs(any())).thenReturn(
+                ImmutableSet.copyOf(technologyConfigs)
+        );
+    }
+
+    /**
+     * Starts adapters for the session with the provided configs.
+     *
+     * @param technologyConfigs to use for the session.
+     * @return {@link RangingAdapter.Callback} for each of the provided configs.
+     * These callbacks are captured from underlying {@link RangingAdapter} mock for each config.
+     */
+    private Map<TechnologyConfig, RangingAdapter.Callback> mockStartAdapters(
+            Set<TechnologyConfig> technologyConfigs
+    ) {
+        ImmutableMap.Builder<TechnologyConfig, RangingAdapter.Callback> adapterCallbacks =
+                ImmutableMap.builder();
+
+        for (TechnologyConfig config : technologyConfigs) {
+            ArgumentCaptor<RangingAdapter.Callback> callbackCaptor =
+                    ArgumentCaptor.forClass(RangingAdapter.Callback.class);
+
+            verify(mMockAdapters.get(config)).start(eq(config), callbackCaptor.capture());
+
+            if (config instanceof MulticastTechnologyConfig c) {
+                c.getPeerDevices().forEach(callbackCaptor.getValue()::onStarted);
+            } else if (config instanceof UnicastTechnologyConfig c) {
+                callbackCaptor.getValue().onStarted(c.getPeerDevice());
+            }
+
+            adapterCallbacks.put(config, callbackCaptor.getValue());
+        }
+
+        return adapterCallbacks.build();
+    }
+
+    private void mockStopAdapters(Map<TechnologyConfig, RangingAdapter.Callback> callbacks) {
+        for (TechnologyConfig config : callbacks.keySet()) {
+            verify(mMockAdapters.get(config)).stop();
+
+            callbacks.get(config).onClosed(ClosedReason.REQUESTED);
+            if (config instanceof MulticastTechnologyConfig c) {
+                c.getPeerDevices().forEach(callbacks.get(config)::onStopped);
+            } else if (config instanceof UnicastTechnologyConfig c) {
+                callbacks.get(config).onStopped(c.getPeerDevice());
+            }
+        }
+    }
+
+    private MulticastTechnologyConfig mockTechnologyConfig(
+            RangingTechnology technology, Set<RangingDevice> peers
+    ) {
+        MulticastTechnologyConfig config = mock(MulticastTechnologyConfig.class);
+        when(config.getTechnology()).thenReturn(technology);
+        when(config.getPeerDevices()).thenReturn(ImmutableSet.copyOf(peers));
+        return config;
+    }
+
+    private UnicastTechnologyConfig mockTechnologyConfig(
+            RangingTechnology technology, RangingDevice peer
+    ) {
+        UnicastTechnologyConfig config = mock(UnicastTechnologyConfig.class);
+        when(config.getTechnology()).thenReturn(technology);
+        when(config.getPeerDevice()).thenReturn(peer);
+        return config;
+    }
+
+
+    /** @param technology to generate data for */
+    private RangingData generateData(RangingTechnology technology) {
+        return new RangingData.Builder()
+                .setRangingTechnology(technology.getValue())
+                .setDistance(new RangingMeasurement.Builder().setMeasurement(123).build())
+                .setTimestampMillis(1)
+                .build();
+    }
+
+    @Before
+    public void setup() {
+        when(mMockConfig.getSensorFusionConfig()).thenReturn(
+                new SensorFusionParams.Builder().setSensorFusionEnabled(true).build()
+        );
+
+        mSession = new RawInitiatorRangingSession(
+                mMockAttributionSource, mMockSessionHandle, mMockInjector, mMockConfig,
+                mMockSessionListener, MoreExecutors.newDirectExecutorService());
+
+        mMockAdapters = Maps.newHashMap();
+    }
+
+    @Test
+    public void start_startsUnicastTechnology() {
+        RangingDevice peer = mock(RangingDevice.class);
+        Set<TechnologyConfig> configs = Set.of(mockTechnologyConfig(UWB, peer));
+
+        configureSession(configs);
+        mSession.start(mMockParams);
+        mockStartAdapters(configs);
+
+        verify(mMockSessionListener).onTechnologyStarted(eq(peer), eq(UWB));
+    }
+
+    @Test
+    public void start_startsMultipleUnicastTechnologies() {
+        RangingDevice peer = mock(RangingDevice.class);
+        Set<TechnologyConfig> configs = Set.of(
+                mockTechnologyConfig(UWB, peer),
+                mockTechnologyConfig(RTT, peer));
+
+        configureSession(configs);
+        mSession.start(mMockParams);
+        mockStartAdapters(configs);
+
+        verify(mMockSessionListener).onTechnologyStarted(eq(peer), eq(UWB));
+        verify(mMockSessionListener).onTechnologyStarted(eq(peer), eq(RTT));
+    }
+
+    @Test
+    public void start_startsMultipleOfTheSameTechnology() {
+        List<RangingDevice> peers = List.of(mock(RangingDevice.class), mock(RangingDevice.class));
+        Set<TechnologyConfig> configs = Set.of(
+                mockTechnologyConfig(UWB, peers.get(0)),
+                mockTechnologyConfig(UWB, peers.get(1)));
+
+        configureSession(configs);
+        mSession.start(mMockParams);
+        mockStartAdapters(configs);
+
+        verify(mMockSessionListener).onTechnologyStarted(eq(peers.get(0)), eq(UWB));
+        verify(mMockSessionListener).onTechnologyStarted(eq(peers.get(1)), eq(UWB));
+    }
+
+    @Test
+    public void start_startsMulticastTechnology() {
+        List<RangingDevice> peers = List.of(mock(RangingDevice.class), mock(RangingDevice.class));
+        Set<TechnologyConfig> configs = Set.of(mockTechnologyConfig(UWB, Set.copyOf(peers)));
+
+        configureSession(configs);
+        mSession.start(mMockParams);
+        mockStartAdapters(configs);
+
+        verify(mMockSessionListener).onTechnologyStarted(eq(peers.get(0)), eq(UWB));
+        verify(mMockSessionListener).onTechnologyStarted(eq(peers.get(1)), eq(UWB));
+    }
+
+    @Test
+    public void start_doesNotStartUnusedTechnology() {
+        Set<TechnologyConfig> configs = Set.of(
+                mockTechnologyConfig(UWB, mock(RangingDevice.class)));
+
+        configureSession(configs);
+        mSession.start(mMockParams);
+        mockStartAdapters(configs);
+
+        verify(mMockSessionListener, never()).onTechnologyStarted(any(), eq(CS));
+    }
+
+    @Test
+    public void stop_stopsUnicastTechnology() {
+        RangingDevice peer = mock(RangingDevice.class);
+        Set<TechnologyConfig> configs = Set.of(mockTechnologyConfig(UWB, peer));
+
+        configureSession(configs);
+        mSession.start(mMockParams);
+        Map<TechnologyConfig, RangingAdapter.Callback> adapterCallbacks =
+                mockStartAdapters(configs);
+
+        mSession.stop();
+        mockStopAdapters(adapterCallbacks);
+
+        verify(mMockSessionListener).onTechnologyStopped(eq(peer), eq(UWB));
+        verify(mMockSessionListener).onSessionStopped(ClosedReason.REQUESTED);
+    }
+
+    @Test
+    public void stop_stopsMultipleUnicastTechnologies() {
+        RangingDevice peer = mock(RangingDevice.class);
+        Set<TechnologyConfig> configs = Set.of(
+                mockTechnologyConfig(UWB, peer),
+                mockTechnologyConfig(RTT, peer));
+
+        configureSession(configs);
+        mSession.start(mMockParams);
+        Map<TechnologyConfig, RangingAdapter.Callback> adapterCallbacks =
+                mockStartAdapters(configs);
+
+        mSession.stop();
+        mockStopAdapters(adapterCallbacks);
+
+        verify(mMockSessionListener).onTechnologyStopped(eq(peer), eq(UWB));
+        verify(mMockSessionListener).onTechnologyStopped(eq(peer), eq(UWB));
+        verify(mMockSessionListener).onSessionStopped(eq(ClosedReason.REQUESTED));
+    }
+
+    @Test
+    public void stop_stopsMulticastTechnology() {
+        List<RangingDevice> peers = List.of(mock(RangingDevice.class), mock(RangingDevice.class));
+        Set<TechnologyConfig> configs = Set.of(mockTechnologyConfig(UWB, Set.copyOf(peers)));
+
+        configureSession(configs);
+        mSession.start(mMockParams);
+        Map<TechnologyConfig, RangingAdapter.Callback> adapterCallbacks =
+                mockStartAdapters(configs);
+
+        mSession.stop();
+        mockStopAdapters(adapterCallbacks);
+
+        verify(mMockSessionListener).onTechnologyStopped(eq(peers.get(0)), eq(UWB));
+        verify(mMockSessionListener).onTechnologyStopped(eq(peers.get(1)), eq(UWB));
+        verify(mMockSessionListener).onSessionStopped(eq(ClosedReason.REQUESTED));
+    }
+
+    @Test
+    public void shouldStop_whenTechnologyStops() {
+        RangingDevice peer = mock(RangingDevice.class);
+        UnicastTechnologyConfig config = mockTechnologyConfig(UWB, peer);
+
+        configureSession(Set.of(config));
+        mSession.start(mMockParams);
+        Map<TechnologyConfig, RangingAdapter.Callback> adapterCallbacks =
+                mockStartAdapters(Set.of(config));
+
+        adapterCallbacks.get(config).onStopped(peer);
+        adapterCallbacks.get(config).onClosed(ClosedReason.LOST_CONNECTION);
+
+        verify(mMockSessionListener).onTechnologyStopped(eq(peer), eq(UWB));
+        verify(mMockSessionListener).onSessionStopped(eq(ClosedReason.LOST_CONNECTION));
+    }
+
+    @Test
+    public void shouldStop_whenTechnologyFailsToStart() {
+        RangingDevice peer = mock(RangingDevice.class);
+        UnicastTechnologyConfig config = mockTechnologyConfig(UWB, peer);
+
+        configureSession(Set.of(config));
+        mSession.start(mMockParams);
+
+        ArgumentCaptor<RangingAdapter.Callback> adapterCallbacks =
+                ArgumentCaptor.forClass(RangingAdapter.Callback.class);
+        verify(mMockAdapters.get(config)).start(eq(config), adapterCallbacks.capture());
+
+        adapterCallbacks.getValue().onClosed(ClosedReason.FAILED_TO_START);
+
+        verify(mMockSessionListener).onSessionStopped(eq(ClosedReason.FAILED_TO_START));
+    }
+
+    @Test
+    public void shouldReportData_fromTechnology() {
+        RangingDevice peer = mock(RangingDevice.class);
+        RangingData data = generateData(UWB);
+
+        UnicastTechnologyConfig config = mockTechnologyConfig(UWB, peer);
+
+        configureSession(Set.of(config));
+        mSession.start(mMockParams);
+        Map<TechnologyConfig, RangingAdapter.Callback> adapterCallbacks =
+                mockStartAdapters(Set.of(config));
+
+        adapterCallbacks.get(config).onRangingData(peer, data);
+        verify(mMockSessionListener).onResults(
+                eq(peer),
+                argThat((arg) -> arg.getRangingTechnology() == UWB.getValue())
+        );
+        verify(mMockSessionListener).onTechnologyStarted(eq(peer), eq(UWB));
+    }
+}
diff --git a/ranging/service/tests/unittests/src/com/android/ranging/tests/UwbAdapterTest.java b/ranging/service/tests/unittests/src/com/android/ranging/tests/UwbAdapterTest.java
new file mode 100644
index 00000000..89954704
--- /dev/null
+++ b/ranging/service/tests/unittests/src/com/android/ranging/tests/UwbAdapterTest.java
@@ -0,0 +1,237 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.ranging.tests;
+
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_NORMAL;
+import static android.ranging.uwb.UwbRangingParams.CONFIG_MULTICAST_DS_TWR;
+import static android.ranging.uwb.UwbRangingParams.CONFIG_UNICAST_DS_TWR;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.argThat;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.ranging.RangingDevice;
+import android.ranging.uwb.UwbAddress;
+import android.ranging.uwb.UwbComplexChannel;
+import android.ranging.uwb.UwbRangingParams;
+
+import androidx.test.filters.SmallTest;
+
+import com.android.ranging.uwb.backend.internal.RangingController;
+import com.android.ranging.uwb.backend.internal.RangingPosition;
+import com.android.ranging.uwb.backend.internal.RangingSessionCallback;
+import com.android.ranging.uwb.backend.internal.UwbDevice;
+import com.android.server.ranging.RangingAdapter;
+import com.android.server.ranging.RangingTechnology;
+import com.android.server.ranging.cs.CsConfig;
+import com.android.server.ranging.uwb.UwbAdapter;
+import com.android.server.ranging.uwb.UwbConfig;
+
+import com.google.common.collect.ImmutableBiMap;
+import com.google.common.util.concurrent.MoreExecutors;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Answers;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.junit.MockitoJUnit;
+import org.mockito.junit.MockitoRule;
+
+import java.util.List;
+import java.util.Map;
+
+@RunWith(JUnit4.class)
+@SmallTest
+@SuppressWarnings("ConstantConditions")
+public class UwbAdapterTest {
+    @Rule
+    public final MockitoRule mMockito = MockitoJUnit.rule();
+
+    @Mock(answer = Answers.RETURNS_DEEP_STUBS)
+    private Context mMockContext;
+    @Mock
+    private RangingController mMockUwbClient;
+
+    @Mock
+    private RangingAdapter.Callback mMockCallback;
+
+    @Mock private UwbDevice mMockLocalDevice;
+
+    /** Class under test */
+    private UwbAdapter mUwbAdapter;
+
+    private UwbConfig generateConfig(Map<RangingDevice, UwbAddress> peers) {
+        return new UwbConfig.Builder(
+                new UwbRangingParams.Builder(
+                        10,
+                        peers.size() == 1 ? CONFIG_UNICAST_DS_TWR : CONFIG_MULTICAST_DS_TWR,
+                        UwbAddress.fromBytes(new byte[]{1, 2}),
+                        mock(UwbAddress.class))
+                        .setComplexChannel(
+                                new UwbComplexChannel.Builder()
+                                        .setChannel(9)
+                                        .setPreambleIndex(11)
+                                        .build())
+                        .setRangingUpdateRate(UPDATE_RATE_NORMAL)
+                        .build())
+                .setCountryCode("US")
+                .setPeerAddresses(ImmutableBiMap.copyOf(peers))
+                .build();
+    }
+
+    @Before
+    public void setup() {
+        when(mMockContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_UWB))
+                .thenReturn(true);
+        mUwbAdapter = new UwbAdapter(mMockContext, MoreExecutors.newDirectExecutorService(),
+                MoreExecutors.newDirectExecutorService(), mMockUwbClient);
+    }
+
+    @Test
+    public void getTechnology_returnsUwb() {
+        Assert.assertEquals(RangingTechnology.UWB, mUwbAdapter.getTechnology());
+    }
+
+    @Test
+    public void start_failsWhenParamsInvalid() {
+        mUwbAdapter.start(mock(CsConfig.class), mMockCallback);
+        verify(mMockCallback, never()).onStarted(any());
+        verify(mMockCallback).onClosed(eq(RangingAdapter.Callback.ClosedReason.FAILED_TO_START));
+        verify(mMockCallback, never()).onStopped(any());
+    }
+
+    @Test
+    public void start_startsPeer() {
+        RangingDevice peer = mock(RangingDevice.class);
+        mUwbAdapter.start(
+                generateConfig(Map.of(peer, UwbAddress.fromBytes(new byte[]{1, 2}))),
+                mMockCallback);
+
+        ArgumentCaptor<RangingSessionCallback> callback =
+                ArgumentCaptor.forClass(RangingSessionCallback.class);
+        verify(mMockUwbClient).startRanging(callback.capture(), any());
+
+        callback.getValue().onRangingInitialized(mMockLocalDevice);
+        verify(mMockCallback).onStarted(eq(peer));
+    }
+
+    @Test
+    public void start_startsMultiplePeers() {
+        List<RangingDevice> peers = List.of(mock(RangingDevice.class), mock(RangingDevice.class));
+        mUwbAdapter.start(
+                generateConfig(Map.of(
+                        peers.get(0), UwbAddress.fromBytes(new byte[]{1, 2}),
+                        peers.get(1), UwbAddress.fromBytes(new byte[]{3, 4}))),
+                mMockCallback);
+
+        ArgumentCaptor<RangingSessionCallback> callback =
+                ArgumentCaptor.forClass(RangingSessionCallback.class);
+        verify(mMockUwbClient).startRanging(callback.capture(), any());
+
+        callback.getValue().onRangingInitialized(mMockLocalDevice);
+        verify(mMockCallback).onStarted(eq(peers.get(0)));
+        verify(mMockCallback).onStarted(eq(peers.get(1)));
+    }
+
+    @Test
+    public void stop_stopsMultiplePeersAndClosesAdapter() {
+        List<RangingDevice> peers = List.of(mock(RangingDevice.class), mock(RangingDevice.class));
+        mUwbAdapter.start(
+                generateConfig(Map.of(
+                        peers.get(0), UwbAddress.fromBytes(new byte[]{1, 2}),
+                        peers.get(1), UwbAddress.fromBytes(new byte[]{3, 4}))),
+                mMockCallback);
+
+        ArgumentCaptor<RangingSessionCallback> callback =
+                ArgumentCaptor.forClass(RangingSessionCallback.class);
+        verify(mMockUwbClient).startRanging(callback.capture(), any());
+
+        callback.getValue().onRangingInitialized(mMockLocalDevice);
+
+        mUwbAdapter.stop();
+        verify(mMockUwbClient).stopRanging();
+
+        callback.getValue().onRangingSuspended(
+                mMockLocalDevice,
+                RangingSessionCallback.REASON_STOP_RANGING_CALLED);
+        verify(mMockCallback).onStopped(eq(peers.get(0)));
+        verify(mMockCallback).onStopped(eq(peers.get(1)));
+        verify(mMockCallback).onClosed(RangingAdapter.Callback.ClosedReason.REQUESTED);
+    }
+
+    @Test
+    public void shouldClose_whenLastPeerDisconnects() {
+        RangingDevice peerDevice = mock(RangingDevice.class);
+        byte[] peerAddress = new byte[]{1, 2};
+
+        mUwbAdapter.start(
+                generateConfig(Map.of(peerDevice, UwbAddress.fromBytes(peerAddress))),
+                mMockCallback);
+
+        ArgumentCaptor<RangingSessionCallback> callback =
+                ArgumentCaptor.forClass(RangingSessionCallback.class);
+        verify(mMockUwbClient).startRanging(callback.capture(), any());
+
+        callback.getValue().onRangingInitialized(mMockLocalDevice);
+        callback.getValue().onPeerDisconnected(
+                UwbDevice.createForAddress(peerAddress),
+                RangingSessionCallback.PeerDisconnectedReason.SYSTEM_POLICY);
+        // UWB stack will suspend the session after an error streak timeout occurs.
+        callback.getValue().onRangingSuspended(
+                UwbDevice.createForAddress(peerAddress),
+                RangingSessionCallback.REASON_MAX_RANGING_ROUND_RETRY_REACHED);
+
+        verify(mMockCallback).onStopped(eq(peerDevice));
+        verify(mMockCallback).onClosed(eq(RangingAdapter.Callback.ClosedReason.LOST_CONNECTION));
+    }
+
+    @Test
+    public void shouldReportData_onRangingResult() {
+        RangingDevice peerDevice = mock(RangingDevice.class);
+        byte[] peerAddress = new byte[]{1, 2};
+
+        mUwbAdapter.start(
+                generateConfig(Map.of(peerDevice, UwbAddress.fromBytes(peerAddress))),
+                mMockCallback);
+
+        ArgumentCaptor<RangingSessionCallback> callback =
+                ArgumentCaptor.forClass(RangingSessionCallback.class);
+        verify(mMockUwbClient).startRanging(callback.capture(), any());
+
+        callback.getValue().onRangingInitialized(mMockLocalDevice);
+
+        RangingPosition mockPosition = mock(RangingPosition.class, Answers.RETURNS_DEEP_STUBS);
+        when(mockPosition.getDistance().getValue()).thenReturn(12F);
+        when(mockPosition.getElapsedRealtimeNanos()).thenReturn(1234L);
+        callback.getValue().onRangingResult(UwbDevice.createForAddress(peerAddress), mockPosition);
+
+        verify(mMockCallback).onRangingData(
+                eq(peerDevice),
+                argThat((arg) -> arg.getRangingTechnology() == RangingTechnology.UWB.getValue()));
+    }
+}
diff --git a/ranging/tests/cts/tests/Android.bp b/ranging/tests/cts/tests/Android.bp
new file mode 100644
index 00000000..d2efc433
--- /dev/null
+++ b/ranging/tests/cts/tests/Android.bp
@@ -0,0 +1,71 @@
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package {
+    default_team: "trendy_team_fwk_uwb",
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+soong_config_module_type {
+    name: "custom_android_test",
+    module_type: "android_test",
+    config_namespace: "bootclasspath",
+    bool_variables: [
+        "release_ranging_stack",
+    ],
+    properties: [
+        "enabled",
+    ],
+}
+
+custom_android_test {
+    name: "CtsRangingTestCases",
+    soong_config_variables: {
+        release_ranging_stack: {
+            enabled: true,
+            conditions_default: {
+                enabled: false,
+            },
+        },
+    },
+    defaults: [
+        "cts_defaults",
+    ],
+    // Tag this module as a cts test artifact
+    test_suites: [
+        "cts",
+        "general-tests",
+        "mts-uwb",
+        "mcts-uwb",
+    ],
+    libs: ["android.test.runner.stubs.system"],
+    static_libs: [
+        "androidx.test.ext.junit",
+        "ctstestrunner-axt",
+        "compatibility-device-util-axt",
+        "mockito-target-minus-junit4",
+        "ranging_flags_lib",
+        "framework-ranging.impl",
+        "framework-bluetooth.stubs.module_lib",
+        "bluetooth-test-util-lib",
+        "framework-uwb.stubs.module_lib",
+        "framework-wifi.stubs.module_lib",
+        "framework-connectivity.stubs.module_lib",
+        "framework-location.stubs.module_lib",
+    ],
+    srcs: ["src/**/*.java"],
+    platform_apis: true,
+    sdk_version: "module_current",
+    min_sdk_version: "35",
+}
diff --git a/ranging/tests/cts/tests/AndroidManifest.xml b/ranging/tests/cts/tests/AndroidManifest.xml
new file mode 100644
index 00000000..17b2d8a9
--- /dev/null
+++ b/ranging/tests/cts/tests/AndroidManifest.xml
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+          package="android.ranging.cts">
+
+    <!--  self-instrumenting test package. -->
+    <instrumentation
+        android:name="androidx.test.runner.AndroidJUnitRunner"
+        android:label="CTS tests for android.ranging"
+        android:targetPackage="android.ranging.cts" >
+
+    </instrumentation>
+
+    <uses-permission android:name="android.permissions.UWB_PRIVILEGED" />
+    <!-- Add an instrumentation tag so that the app can be launched through an
+         instrument command. The runner `com.google.android.mobly.snippet.SnippetRunner`
+         is derived from `AndroidJUnitRunner`, and is required to use the
+         Mobly Snippet Lib. -->
+    <uses-permission android:name="android.permission.UWB_RANGING" />
+</manifest>
+
diff --git a/ranging/tests/cts/tests/AndroidTest.xml b/ranging/tests/cts/tests/AndroidTest.xml
new file mode 100644
index 00000000..5d5892fc
--- /dev/null
+++ b/ranging/tests/cts/tests/AndroidTest.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2024 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<configuration description="Config for CTS Ranging test cases">
+    <option name="test-suite-tag" value="cts" />
+    <option name="config-descriptor:metadata" key="component" value="systems" />
+    <option name="config-descriptor:metadata" key="parameter" value="instant_app" />
+    <option name="config-descriptor:metadata" key="parameter" value="not_multi_abi" />
+    <option name="config-descriptor:metadata" key="parameter" value="secondary_user" />
+    <option name="config-descriptor:metadata" key="parameter" value="secondary_user_on_secondary_display" />
+    <option name="config-descriptor:metadata" key="mainline-param" value="com.google.android.uwb.apex" />
+    <target_preparer class="com.android.tradefed.targetprep.suite.SuiteApkInstaller">
+        <option name="cleanup-apks" value="true" />
+        <option name="test-file-name" value="CtsRangingTestCases.apk" />
+    </target_preparer>
+    <test class="com.android.tradefed.testtype.AndroidJUnitTest" >
+        <option name="package" value="android.ranging.cts" />
+    </test>
+    <object type="module_controller" class="com.android.tradefed.testtype.suite.module.MainlineTestModuleController">
+        <option name="mainline-module-package-name" value="com.google.android.uwb" />
+    </object>
+</configuration>
\ No newline at end of file
diff --git a/generic_ranging/tests/multidevices/OWNERS b/ranging/tests/cts/tests/OWNERS
similarity index 100%
rename from generic_ranging/tests/multidevices/OWNERS
rename to ranging/tests/cts/tests/OWNERS
diff --git a/ranging/tests/cts/tests/src/android/ranging/cts/RangingManagerTest.java b/ranging/tests/cts/tests/src/android/ranging/cts/RangingManagerTest.java
new file mode 100644
index 00000000..2d1a3631
--- /dev/null
+++ b/ranging/tests/cts/tests/src/android/ranging/cts/RangingManagerTest.java
@@ -0,0 +1,793 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.ranging.cts;
+
+import static android.ranging.RangingPreference.DEVICE_ROLE_INITIATOR;
+import static android.ranging.RangingPreference.DEVICE_ROLE_RESPONDER;
+import static android.ranging.raw.RawRangingDevice.UPDATE_RATE_NORMAL;
+import static android.ranging.uwb.UwbRangingParams.CONFIG_UNICAST_DS_TWR;
+import static android.uwb.UwbManager.AdapterStateCallback.STATE_ENABLED_INACTIVE;
+
+import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeTrue;
+
+import android.app.UiAutomation;
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.test_utils.BlockingBluetoothAdapter;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.PackageManager;
+import android.location.LocationManager;
+import android.net.ConnectivityManager;
+import android.net.wifi.WifiManager;
+import android.net.wifi.aware.WifiAwareManager;
+import android.platform.test.annotations.AppModeFull;
+import android.platform.test.annotations.RequiresFlagsEnabled;
+import android.ranging.RangingCapabilities;
+import android.ranging.RangingData;
+import android.ranging.RangingDevice;
+import android.ranging.RangingManager;
+import android.ranging.RangingManager.RangingCapabilitiesCallback;
+import android.ranging.RangingPreference;
+import android.ranging.RangingSession;
+import android.ranging.SensorFusionParams;
+import android.ranging.SessionConfiguration;
+import android.ranging.ble.cs.CsRangingParams;
+import android.ranging.ble.rssi.BleRssiRangingParams;
+import android.ranging.raw.RawInitiatorRangingParams;
+import android.ranging.raw.RawRangingDevice;
+import android.ranging.raw.RawResponderRangingParams;
+import android.ranging.uwb.UwbAddress;
+import android.ranging.uwb.UwbComplexChannel;
+import android.ranging.uwb.UwbRangingParams;
+import android.ranging.wifi.rtt.RttRangingParams;
+import android.util.Log;
+import android.uwb.UwbManager;
+
+import androidx.annotation.NonNull;
+import androidx.test.InstrumentationRegistry;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+import androidx.test.filters.SmallTest;
+
+import com.android.compatibility.common.util.CddTest;
+import com.android.ranging.flags.Flags;
+
+import com.google.common.util.concurrent.MoreExecutors;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+@SmallTest
+@RunWith(AndroidJUnit4.class)
+@AppModeFull(reason = "Cannot get RangingManager in instant app mode")
+public class RangingManagerTest {
+    private static final String TAG = "RangingManagerTest";
+    private final Context mContext = InstrumentationRegistry.getContext();
+    private RangingManager mRangingManager;
+
+    private final Set<Integer> mSupportedTechnologies = new HashSet<>();
+
+    @Before
+    public void setup() throws Exception {
+        assumeTrue(Flags.rangingStackEnabled());
+        mRangingManager = mContext.getSystemService(RangingManager.class);
+        assertThat(mRangingManager).isNotNull();
+        PackageManager packageManager = mContext.getPackageManager();
+        assertThat(packageManager).isNotNull();
+        if (packageManager.hasSystemFeature(PackageManager.FEATURE_UWB)) {
+            mSupportedTechnologies.add(RangingManager.UWB);
+        }
+        if (packageManager.hasSystemFeature(PackageManager.FEATURE_WIFI_AWARE)) {
+            mSupportedTechnologies.add(RangingManager.WIFI_NAN_RTT);
+        }
+        if (packageManager.hasSystemFeature(
+                PackageManager.FEATURE_BLUETOOTH_LE_CHANNEL_SOUNDING)) {
+            mSupportedTechnologies.add(RangingManager.BLE_CS);
+        }
+        if (packageManager.hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
+            mSupportedTechnologies.add(RangingManager.BLE_RSSI);
+        }
+    }
+
+    @After
+    public void teardown() throws Exception {
+        // Just in case if some test failed.
+        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
+        uiAutomation.dropShellPermissionIdentity();
+    }
+
+    private void enableUwb() {
+        UwbManager uwbManager = mContext.getSystemService(UwbManager.class);
+        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
+        // Ensure UWB is toggled on.
+        try {
+            // Needs UWB_PRIVILEGED permission which is held by shell.
+            uiAutomation.adoptShellPermissionIdentity();
+            assert uwbManager != null;
+            if (!uwbManager.isUwbEnabled()) {
+                CountDownLatch countDownLatch = new CountDownLatch(1);
+                int adapterState = STATE_ENABLED_INACTIVE;
+                AdapterStateCallback adapterStateCallback =
+                        new AdapterStateCallback(countDownLatch, adapterState);
+                uwbManager.registerAdapterStateCallback(
+                        Executors.newSingleThreadExecutor(), adapterStateCallback);
+                try {
+                    uwbManager.setUwbEnabled(true);
+                    assertThat(countDownLatch.await(2, TimeUnit.SECONDS)).isTrue();
+                    assertThat(uwbManager.isUwbEnabled()).isEqualTo(true);
+                    assertThat(adapterStateCallback.state).isEqualTo(adapterState);
+                } finally {
+                    uwbManager.unregisterAdapterStateCallback(adapterStateCallback);
+                }
+            }
+            if (uwbManager.isUwbHwIdleTurnOffEnabled()) {
+                // If HW idle mode is turned on, vote for the UWB hardware for tests to pass.
+                CountDownLatch countDownLatch = new CountDownLatch(1);
+                int adapterState = STATE_ENABLED_INACTIVE;
+                AdapterStateCallback adapterStateCallback =
+                        new AdapterStateCallback(countDownLatch, adapterState);
+                try {
+                    uwbManager.registerAdapterStateCallback(
+                            Executors.newSingleThreadExecutor(), adapterStateCallback);
+                    uwbManager.requestUwbHwEnabled(true);
+                    assertThat(countDownLatch.await(2, TimeUnit.SECONDS)).isTrue();
+                    assertThat(adapterStateCallback.state).isEqualTo(adapterState);
+                } finally {
+                    uwbManager.unregisterAdapterStateCallback(adapterStateCallback);
+                }
+            }
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+        } finally {
+            uiAutomation.dropShellPermissionIdentity();
+        }
+    }
+
+    private void enableWifiNanRtt() throws InterruptedException {
+        assertTrue("Wi-Fi Aware requires Location to be Enabled",
+                (mContext.getSystemService(LocationManager.class).isLocationEnabled()));
+        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
+        uiAutomation.adoptShellPermissionIdentity();
+        try {
+            WifiManager wifiManager = mContext.getSystemService(WifiManager.class);
+            assertNotNull("Wi-Fi Manager", wifiManager);
+
+            WifiAwareManager wifiAwareManager = mContext.getSystemService(WifiAwareManager.class);
+            assertNotNull("Wi-Fi Aware Manager", wifiAwareManager);
+
+            // Turn on Wi-Fi
+            if (!wifiManager.isWifiEnabled()) {
+                wifiManager.setWifiEnabled(true);
+            }
+
+            ConnectivityManager connectivityManager =
+                    mContext.getSystemService(ConnectivityManager.class);
+            assertNotNull("Connectivity Manager", connectivityManager);
+
+            IntentFilter intentFilter = new IntentFilter();
+            intentFilter.addAction(WifiAwareManager.ACTION_WIFI_AWARE_STATE_CHANGED);
+            WifiAwareStateBroadcastReceiver receiver = new WifiAwareStateBroadcastReceiver();
+            mContext.registerReceiver(receiver, intentFilter);
+            if (!wifiAwareManager.isAvailable()) {
+                assertTrue("Timeout waiting for Wi-Fi Aware to change status",
+                        receiver.waitForStateChange());
+                assertTrue("Wi-Fi Aware is not available (should be)",
+                        wifiAwareManager.isAvailable());
+            }
+        } finally {
+            uiAutomation.dropShellPermissionIdentity();
+        }
+    }
+
+    public void enableBluetooth() {
+        BluetoothAdapter adapter = BlockingBluetoothAdapter.getAdapter();
+        assertThat(adapter).isNotNull();
+        assertThat(BlockingBluetoothAdapter.enable()).isTrue();
+    }
+
+    private RangingPreference getGenericRangingPreference(int deviceRole) {
+        // Generic ranging preference, Improve this method based on future needs.
+        return new RangingPreference.Builder(deviceRole,
+                new RawInitiatorRangingParams.Builder()
+                        .addRawRangingDevice(new RawRangingDevice.Builder()
+                                .setRangingDevice(new RangingDevice.Builder().build())
+                                .setUwbRangingParams(new UwbRangingParams.Builder(10,
+                                        CONFIG_UNICAST_DS_TWR,
+                                        UwbAddress.fromBytes(new byte[]{1, 2}),
+                                        UwbAddress.fromBytes(new byte[]{3, 4}))
+                                        .setComplexChannel(
+                                                new UwbComplexChannel.Builder().setChannel(
+                                                        9).setPreambleIndex(11).build())
+                                        .setSessionKeyInfo(
+                                                new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 6, 5, 4, 3,
+                                                        2, 1})
+                                        .setRangingUpdateRate(UPDATE_RATE_NORMAL)
+                                        .build())
+                                .build())
+                        .build())
+                .build();
+    }
+
+    @Test
+    @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
+    @RequiresFlagsEnabled("com.android.ranging.flags.ranging_stack_enabled")
+    public void testStartRangingSession_WithoutPermission() throws Exception {
+        RangingSessionCallback callback = new RangingSessionCallback();
+
+        RangingSession rangingSession = mRangingManager.createRangingSession(
+                MoreExecutors.directExecutor(), callback);
+        assertThat(rangingSession).isNotNull();
+
+        RangingPreference preference = getGenericRangingPreference(DEVICE_ROLE_INITIATOR);
+
+        try {
+            rangingSession.start(preference);
+            // Caller does not hold RANGING permission, should fail if start was successful.
+            fail();
+        } catch (SecurityException e) {
+            // pass
+            Log.i(TAG, "Failed with expected security exception: " + e);
+        }
+    }
+
+    @Test
+    @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
+    @RequiresFlagsEnabled("com.android.ranging.flags.ranging_stack_enabled")
+    public void testStopRangingSession_WithoutPermission() throws Exception {
+
+        RangingSessionCallback callback = new RangingSessionCallback();
+
+        RangingSession rangingSession = mRangingManager.createRangingSession(
+                MoreExecutors.directExecutor(), callback);
+        assertThat(rangingSession).isNotNull();
+
+        try {
+            rangingSession.stop();
+            // Caller does not hold RANGING permission, should fail if start was successful.
+            fail();
+        } catch (SecurityException e) {
+            // pass
+            Log.i(TAG, "Failed with expected security exception: " + e);
+        }
+    }
+    @Test
+    @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
+    @RequiresFlagsEnabled("com.android.ranging.flags.ranging_stack_enabled")
+    public void testUwbRangingSession() throws Exception {
+        assumeTrue(mSupportedTechnologies.contains(RangingManager.UWB));
+        enableUwb();
+        int sessionId = 10;
+        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
+        uiAutomation.adoptShellPermissionIdentity();
+
+        RangingSessionCallback callback = new RangingSessionCallback();
+
+        RangingSession rangingSession = mRangingManager.createRangingSession(
+                MoreExecutors.directExecutor(), callback);
+        assertThat(rangingSession).isNotNull();
+
+        RangingPreference preference = new RangingPreference.Builder(DEVICE_ROLE_INITIATOR,
+                new RawInitiatorRangingParams.Builder()
+                        .addRawRangingDevice(new RawRangingDevice.Builder()
+                                .setRangingDevice(new RangingDevice.Builder().build())
+                                .setUwbRangingParams(new UwbRangingParams.Builder(
+                                        sessionId, CONFIG_UNICAST_DS_TWR,
+                                        UwbAddress.fromBytes(new byte[]{1, 2}),
+                                        UwbAddress.fromBytes(new byte[]{3, 4}))
+                                        .setComplexChannel(
+                                                new UwbComplexChannel.Builder().setChannel(
+                                                        9).setPreambleIndex(11).build())
+                                        .setSessionKeyInfo(
+                                                new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 6, 5, 4, 3,
+                                                        2, 1})
+                                        .setRangingUpdateRate(UPDATE_RATE_NORMAL)
+                                        .build())
+                                .build())
+                        .build())
+                .setSessionConfiguration(new SessionConfiguration.Builder()
+                        .setRangingMeasurementsLimit(1000)
+                        .setAngleOfArrivalNeeded(true)
+                        .setSensorFusionParameters(
+                                new SensorFusionParams.Builder()
+                                        .setSensorFusionEnabled(false)
+                                        .build())
+                        .build())
+                .build();
+
+        rangingSession.start(preference);
+        assertThat(callback.mOnOpenedCalled.await(1, TimeUnit.SECONDS)).isTrue();
+
+        rangingSession.stop();
+        assertThat(callback.mOnClosedCalled.await(2, TimeUnit.SECONDS)).isTrue();
+
+        uiAutomation.dropShellPermissionIdentity();
+    }
+
+    @Test
+    @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
+    @RequiresFlagsEnabled("com.android.ranging.flags.ranging_stack_enabled")
+    public void testMultipleUwbRangingSessions() throws Exception {
+        assumeTrue(mSupportedTechnologies.contains(RangingManager.UWB));
+        enableUwb();
+        int sessionId1 = 10;
+        int sessionId2 = 15;
+        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
+        uiAutomation.adoptShellPermissionIdentity();
+
+        RangingSessionCallback callback1 = new RangingSessionCallback();
+        RangingSessionCallback callback2 = new RangingSessionCallback();
+
+        RangingSession rangingSession1 = mRangingManager.createRangingSession(
+                MoreExecutors.directExecutor(), callback1);
+        assertThat(rangingSession1).isNotNull();
+
+        RangingSession rangingSession2 = mRangingManager.createRangingSession(
+                MoreExecutors.directExecutor(), callback2);
+        assertThat(rangingSession2).isNotNull();
+        RangingPreference preference1 = new RangingPreference.Builder(DEVICE_ROLE_INITIATOR,
+                new RawInitiatorRangingParams.Builder()
+                        .addRawRangingDevice(new RawRangingDevice.Builder()
+                                .setRangingDevice(new RangingDevice.Builder().build())
+                                .setUwbRangingParams(new UwbRangingParams.Builder(sessionId1,
+                                        CONFIG_UNICAST_DS_TWR,
+                                        UwbAddress.fromBytes(new byte[]{1, 2}),
+                                        UwbAddress.fromBytes(new byte[]{3, 4}))
+                                        .setComplexChannel(
+                                                new UwbComplexChannel.Builder().setChannel(
+                                                        9).setPreambleIndex(11).build())
+                                        .setSessionKeyInfo(
+                                                new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 6, 5, 4, 3,
+                                                        2, 1})
+                                        .setRangingUpdateRate(UPDATE_RATE_NORMAL)
+                                        .build())
+                                .build())
+                        .build())
+                .build();
+
+        RangingPreference preference2 = new RangingPreference.Builder(DEVICE_ROLE_INITIATOR,
+                new RawInitiatorRangingParams.Builder()
+                        .addRawRangingDevice(new RawRangingDevice.Builder()
+                                .setRangingDevice(new RangingDevice.Builder().build())
+                                .setUwbRangingParams(new UwbRangingParams.Builder(sessionId2,
+                                        CONFIG_UNICAST_DS_TWR,
+                                        UwbAddress.fromBytes(new byte[]{3, 5}),
+                                        UwbAddress.fromBytes(new byte[]{1, 2}))
+                                        .setComplexChannel(
+                                                new UwbComplexChannel.Builder().setChannel(
+                                                        9).setPreambleIndex(11).build())
+                                        .setSessionKeyInfo(
+                                                new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 6, 5, 4, 3,
+                                                        2, 1})
+                                        .setRangingUpdateRate(UPDATE_RATE_NORMAL)
+                                        .build())
+                                .build())
+                        .build())
+                .build();
+
+        rangingSession1.start(preference1);
+        rangingSession2.start(preference2);
+
+        assertThat(callback1.mOnOpenedCalled.await(1, TimeUnit.SECONDS)).isTrue();
+        assertThat(callback2.mOnOpenedCalled.await(1, TimeUnit.SECONDS)).isTrue();
+
+        rangingSession1.stop();
+        rangingSession2.stop();
+
+        assertThat(callback1.mOnClosedCalled.await(2, TimeUnit.SECONDS)).isTrue();
+        assertThat(callback2.mOnClosedCalled.await(2, TimeUnit.SECONDS)).isTrue();
+
+        uiAutomation.dropShellPermissionIdentity();
+    }
+
+    private static class RangingSessionCallback implements RangingSession.Callback {
+
+        private final CountDownLatch mOnOpenedCalled = new CountDownLatch(1);
+        private final CountDownLatch mOnClosedCalled = new CountDownLatch(1);
+
+        @Override
+        public void onOpened() {
+            mOnOpenedCalled.countDown();
+        }
+
+        @Override
+        public void onOpenFailed(int reason) {
+        }
+
+        @Override
+        public void onStarted(@NonNull RangingDevice peer,
+                @RangingManager.RangingTechnology int technology) {
+        }
+
+        @Override
+        public void onResults(@NonNull RangingDevice peer, @NonNull RangingData data) {
+        }
+
+        @Override
+        public void onStopped(@NonNull RangingDevice peer,
+                @RangingManager.RangingTechnology int technology) {
+        }
+
+        @Override
+        public void onClosed(int reasonCode) {
+            mOnClosedCalled.countDown();
+        }
+
+    }
+
+    @Test
+    @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
+    @RequiresFlagsEnabled("com.android.ranging.flags.ranging_stack_enabled")
+    public void testCapabilitiesListener() throws InterruptedException {
+        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
+        uiAutomation.adoptShellPermissionIdentity();
+
+        CapabilitiesCallback callback = new CapabilitiesCallback(new CountDownLatch(1));
+        mRangingManager.registerCapabilitiesCallback(Executors.newSingleThreadExecutor(),
+                callback);
+
+        assertThat(callback.mCountDownLatch.await(2, TimeUnit.SECONDS)).isTrue();
+        assertThat(callback.mOnCapabilitiesReceived).isTrue();
+        assertThat(callback.mRangingCapabilities).isNotNull();
+
+        callback.reset(new CountDownLatch(1));
+        UwbManager uwbManager = mContext.getSystemService(UwbManager.class);
+        uwbManager.setUwbEnabled(!uwbManager.isUwbEnabled());
+
+        assertThat(callback.mCountDownLatch.await(2, TimeUnit.SECONDS)).isTrue();
+        assertThat(callback.mOnCapabilitiesReceived).isTrue();
+        assertThat(callback.mRangingCapabilities).isNotNull();
+
+        uwbManager.setUwbEnabled(true);
+        callback.reset(new CountDownLatch(1));
+        assertThat(callback.mCountDownLatch.await(2, TimeUnit.SECONDS)).isTrue();
+        assertThat(callback.mOnCapabilitiesReceived).isTrue();
+        assertThat(callback.mRangingCapabilities).isNotNull();
+
+        uiAutomation.dropShellPermissionIdentity();
+    }
+
+    @Test
+    @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
+    @RequiresFlagsEnabled("com.android.ranging.flags.ranging_rtt_enabled")
+    public void testRttRangingInitiator() throws InterruptedException {
+        assumeTrue(mSupportedTechnologies.contains(RangingManager.WIFI_NAN_RTT));
+        enableWifiNanRtt();
+        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
+        uiAutomation.adoptShellPermissionIdentity();
+
+        CapabilitiesCallback capabilitiesCallback = new CapabilitiesCallback(new CountDownLatch(1));
+        mRangingManager.registerCapabilitiesCallback(Executors.newSingleThreadExecutor(),
+                capabilitiesCallback);
+
+        assertThat(capabilitiesCallback.mCountDownLatch.await(3, TimeUnit.SECONDS)).isTrue();
+        assertThat(capabilitiesCallback.mOnCapabilitiesReceived).isTrue();
+        assertThat(capabilitiesCallback.mRangingCapabilities).isNotNull();
+        assertThat(
+                capabilitiesCallback.mRangingCapabilities.getTechnologyAvailability())
+                .isNotNull();
+
+        RangingPreference preference = new RangingPreference.Builder(DEVICE_ROLE_INITIATOR,
+                new RawInitiatorRangingParams.Builder()
+                        .addRawRangingDevice(new RawRangingDevice.Builder()
+                                .setRangingDevice(new RangingDevice.Builder().build())
+                                .setRttRangingParams(new RttRangingParams.Builder("test_rtt_1")
+                                        .build())
+                                .build())
+                        .addRawRangingDevice(new RawRangingDevice.Builder()
+                                .setRangingDevice(new RangingDevice.Builder().build())
+                                .setRttRangingParams(new RttRangingParams.Builder("test_rtt_2")
+                                        .build())
+                                .build())
+                        .build())
+                .build();
+
+        RangingSessionCallback callback = new RangingSessionCallback();
+        RangingSession rangingSession = mRangingManager.createRangingSession(
+                MoreExecutors.directExecutor(), callback);
+        assertThat(rangingSession).isNotNull();
+
+        rangingSession.start(preference);
+        assertThat(callback.mOnOpenedCalled.await(1, TimeUnit.SECONDS)).isTrue();
+        rangingSession.stop();
+        assertThat(callback.mOnClosedCalled.await(1, TimeUnit.SECONDS)).isTrue();
+
+        mRangingManager.unregisterCapabilitiesCallback(capabilitiesCallback);
+        uiAutomation.dropShellPermissionIdentity();
+    }
+
+    @Test
+    @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
+    @RequiresFlagsEnabled("com.android.ranging.flags.ranging_rtt_enabled")
+    public void testRttRangingResponder() throws InterruptedException {
+        assumeTrue(mSupportedTechnologies.contains(RangingManager.WIFI_NAN_RTT));
+        enableWifiNanRtt();
+        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
+        uiAutomation.adoptShellPermissionIdentity();
+        CapabilitiesCallback capabilitiesCallback = new CapabilitiesCallback(new CountDownLatch(1));
+        mRangingManager.registerCapabilitiesCallback(Executors.newSingleThreadExecutor(),
+                capabilitiesCallback);
+
+        assertThat(capabilitiesCallback.mCountDownLatch.await(3, TimeUnit.SECONDS)).isTrue();
+        assertThat(capabilitiesCallback.mOnCapabilitiesReceived).isTrue();
+        assertThat(capabilitiesCallback.mRangingCapabilities).isNotNull();
+        assertThat(
+                capabilitiesCallback.mRangingCapabilities.getTechnologyAvailability())
+                .isNotNull();
+
+        RangingPreference preference = new RangingPreference.Builder(DEVICE_ROLE_RESPONDER,
+                new RawResponderRangingParams.Builder()
+                        .setRawRangingDevice(new RawRangingDevice.Builder()
+                                .setRangingDevice(new RangingDevice.Builder().build())
+                                .setRttRangingParams(new RttRangingParams.Builder("test_rtt_1")
+                                        .build())
+                                .build())
+                        .build())
+                .build();
+
+        RangingSessionCallback callback = new RangingSessionCallback();
+        RangingSession rangingSession = mRangingManager.createRangingSession(
+                MoreExecutors.directExecutor(), callback);
+        assertThat(rangingSession).isNotNull();
+
+        rangingSession.start(preference);
+        assertThat(callback.mOnOpenedCalled.await(2, TimeUnit.SECONDS)).isTrue();
+        rangingSession.stop();
+        assertThat(callback.mOnClosedCalled.await(2, TimeUnit.SECONDS)).isTrue();
+
+        mRangingManager.unregisterCapabilitiesCallback(capabilitiesCallback);
+        uiAutomation.dropShellPermissionIdentity();
+    }
+
+    @Test
+    @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
+    @RequiresFlagsEnabled("com.android.ranging.flags.ranging_rtt_enabled")
+    public void testMultiRangingSession() throws InterruptedException {
+        assumeTrue(mSupportedTechnologies.contains(RangingManager.WIFI_NAN_RTT));
+        assumeTrue(mSupportedTechnologies.contains(RangingManager.UWB));
+        enableUwb();
+        enableWifiNanRtt();
+        int sessionId = 10;
+        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
+        uiAutomation.adoptShellPermissionIdentity();
+        CapabilitiesCallback capabilitiesCallback = new CapabilitiesCallback(new CountDownLatch(1));
+        mRangingManager.registerCapabilitiesCallback(Executors.newSingleThreadExecutor(),
+                capabilitiesCallback);
+
+        assertThat(capabilitiesCallback.mCountDownLatch.await(3, TimeUnit.SECONDS)).isTrue();
+        assertThat(capabilitiesCallback.mOnCapabilitiesReceived).isTrue();
+        assertThat(capabilitiesCallback.mRangingCapabilities).isNotNull();
+        assertThat(
+                capabilitiesCallback.mRangingCapabilities.getTechnologyAvailability())
+                .isNotNull();
+
+        RangingPreference preference = new RangingPreference.Builder(DEVICE_ROLE_RESPONDER,
+                new RawResponderRangingParams.Builder()
+                        .setRawRangingDevice(new RawRangingDevice.Builder()
+                                .setRangingDevice(new RangingDevice.Builder().build())
+                                .setRttRangingParams(new RttRangingParams.Builder("test_rtt_multi")
+                                        .build())
+                                .setUwbRangingParams(new UwbRangingParams.Builder(
+                                        sessionId, CONFIG_UNICAST_DS_TWR,
+                                        UwbAddress.fromBytes(new byte[]{3, 5}),
+                                        UwbAddress.fromBytes(new byte[]{1, 2}))
+                                        .setComplexChannel(
+                                                new UwbComplexChannel.Builder().setChannel(
+                                                        9).setPreambleIndex(11).build())
+                                        .setSessionKeyInfo(
+                                                new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 6, 5, 4, 3,
+                                                        2, 1})
+                                        .setRangingUpdateRate(UPDATE_RATE_NORMAL)
+                                        .build())
+                                .build())
+                        .build())
+                .build();
+
+        RangingSessionCallback callback = new RangingSessionCallback();
+        RangingSession rangingSession = mRangingManager.createRangingSession(
+                MoreExecutors.directExecutor(), callback);
+        assertThat(rangingSession).isNotNull();
+
+        rangingSession.start(preference);
+        assertThat(callback.mOnOpenedCalled.await(1, TimeUnit.SECONDS)).isTrue();
+
+        rangingSession.stop();
+        assertThat(callback.mOnClosedCalled.await(4, TimeUnit.SECONDS)).isTrue();
+
+        mRangingManager.unregisterCapabilitiesCallback(capabilitiesCallback);
+        uiAutomation.dropShellPermissionIdentity();
+    }
+
+    @Test
+    @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
+    @RequiresFlagsEnabled("com.android.ranging.flags.ranging_stack_enabled")
+    public void testBleRssiRangingSession() throws Exception {
+        assumeTrue(mSupportedTechnologies.contains(RangingManager.BLE_RSSI));
+        enableBluetooth();
+        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
+        uiAutomation.adoptShellPermissionIdentity();
+
+        RangingSessionCallback callback = new RangingSessionCallback();
+
+        RangingSession rangingSession = mRangingManager.createRangingSession(
+                MoreExecutors.directExecutor(), callback);
+        assertThat(rangingSession).isNotNull();
+
+        RangingPreference preference = new RangingPreference.Builder(DEVICE_ROLE_INITIATOR,
+                new RawInitiatorRangingParams.Builder()
+                        .addRawRangingDevice(new RawRangingDevice.Builder()
+                                .setRangingDevice(new RangingDevice.Builder().build())
+                                .setBleRssiRangingParams(
+                                        new BleRssiRangingParams.Builder("00:11:22:33:AA:BB")
+                                                .build())
+                                .build())
+                        .build())
+                .setSessionConfiguration(new SessionConfiguration.Builder()
+                        .setRangingMeasurementsLimit(1000)
+                        .setAngleOfArrivalNeeded(true)
+                        .setSensorFusionParameters(
+                                new SensorFusionParams.Builder()
+                                        .setSensorFusionEnabled(false)
+                                        .build())
+                        .build())
+                .build();
+
+        rangingSession.start(preference);
+        assertThat(callback.mOnOpenedCalled.await(1, TimeUnit.SECONDS)).isTrue();
+
+        rangingSession.stop();
+        assertThat(callback.mOnClosedCalled.await(2, TimeUnit.SECONDS)).isTrue();
+
+        uiAutomation.dropShellPermissionIdentity();
+    }
+
+    @Test
+    @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
+    @RequiresFlagsEnabled("com.android.ranging.flags.ranging_cs_enabled")
+    public void testBleCsRangingSession() throws Exception {
+        assumeTrue(mSupportedTechnologies.contains(RangingManager.BLE_CS));
+        enableBluetooth();
+        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
+        uiAutomation.adoptShellPermissionIdentity();
+
+        RangingSessionCallback callback = new RangingSessionCallback();
+
+        RangingSession rangingSession = mRangingManager.createRangingSession(
+                MoreExecutors.directExecutor(), callback);
+        assertThat(rangingSession).isNotNull();
+
+        RangingPreference preference = new RangingPreference.Builder(DEVICE_ROLE_INITIATOR,
+                new RawInitiatorRangingParams.Builder()
+                        .addRawRangingDevice(new RawRangingDevice.Builder()
+                                .setRangingDevice(new RangingDevice.Builder().build())
+                                .setCsRangingParams(new
+                                        CsRangingParams.Builder("00:11:22:33:AA:BB")
+                                        .build())
+                                .build())
+                        .build())
+                .setSessionConfiguration(new SessionConfiguration.Builder()
+                        .setRangingMeasurementsLimit(1000)
+                        .setAngleOfArrivalNeeded(true)
+                        .setSensorFusionParameters(
+                                new SensorFusionParams.Builder()
+                                        .setSensorFusionEnabled(false)
+                                        .build())
+                        .build())
+                .build();
+
+        rangingSession.start(preference);
+        assertThat(callback.mOnOpenedCalled.await(1, TimeUnit.SECONDS)).isTrue();
+
+        rangingSession.stop();
+        assertThat(callback.mOnClosedCalled.await(2, TimeUnit.SECONDS)).isTrue();
+
+        uiAutomation.dropShellPermissionIdentity();
+    }
+
+
+    private static class CapabilitiesCallback implements RangingCapabilitiesCallback {
+
+        private CountDownLatch mCountDownLatch;
+        private boolean mOnCapabilitiesReceived = false;
+        private RangingCapabilities mRangingCapabilities = null;
+
+        CapabilitiesCallback(CountDownLatch countDownLatch) {
+            mCountDownLatch = countDownLatch;
+        }
+
+        @Override
+        public void onRangingCapabilities(@NonNull RangingCapabilities capabilities) {
+            mOnCapabilitiesReceived = true;
+            mRangingCapabilities = capabilities;
+            mCountDownLatch.countDown();
+        }
+
+        public void reset(CountDownLatch latch) {
+            mCountDownLatch = latch;
+            mOnCapabilitiesReceived = false;
+        }
+    }
+
+    private static class AdapterStateCallback implements UwbManager.AdapterStateCallback {
+        private final CountDownLatch mCountDownLatch;
+        private final Integer mWaitForState;
+        public int state;
+        public int reason;
+
+        AdapterStateCallback(CountDownLatch countDownLatch, Integer waitForState) {
+            mCountDownLatch = countDownLatch;
+            mWaitForState = waitForState;
+        }
+
+        public void onStateChanged(int state, int reason) {
+            this.state = state;
+            this.reason = reason;
+            if (mWaitForState != null) {
+                if (mWaitForState == state) {
+                    mCountDownLatch.countDown();
+                }
+            } else {
+                mCountDownLatch.countDown();
+            }
+        }
+    }
+
+    private static class WifiAwareStateBroadcastReceiver extends BroadcastReceiver {
+        private final Object mLock = new Object();
+        private CountDownLatch mBlocker = new CountDownLatch(1);
+        private int mCountNumber = 0;
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (WifiAwareManager.ACTION_WIFI_AWARE_STATE_CHANGED.equals(intent.getAction())) {
+                synchronized (mLock) {
+                    mCountNumber += 1;
+                    mBlocker.countDown();
+                    mBlocker = new CountDownLatch(1);
+                }
+            }
+        }
+
+        boolean waitForStateChange() throws InterruptedException {
+            CountDownLatch blocker;
+            synchronized (mLock) {
+                mCountNumber--;
+                if (mCountNumber >= 0) {
+                    return true;
+                }
+                blocker = mBlocker;
+            }
+            return blocker.await(10, TimeUnit.SECONDS);
+        }
+    }
+
+}
diff --git a/generic_ranging/tests/multidevices/Android.bp b/ranging/tests/multidevices/Android.bp
similarity index 70%
rename from generic_ranging/tests/multidevices/Android.bp
rename to ranging/tests/multidevices/Android.bp
index da75970d..23f69e9e 100644
--- a/generic_ranging/tests/multidevices/Android.bp
+++ b/ranging/tests/multidevices/Android.bp
@@ -18,7 +18,7 @@ package {
 }
 
 python_defaults {
-    name: "GenericRangingMultiDevicePythonDefaults",
+    name: "RangingMultiDevicePythonDefaults",
     libs: [
         "mobly",
     ],
@@ -34,23 +34,22 @@ python_defaults {
 }
 
 python_test_host {
-    name: "MultiDeviceRangingTestCase_Uwb",
-    main: "uwb/uwb_tests.py",
+    name: "MultiDeviceRangingTestCases",
+    main: "RangingManagerTests/ranging_manager_tests.py",
     srcs: [
-        "uwb/uwb_tests.py",
-        "uwb/uwb_ranging_params.py",
-        "lib/ranging_base_test.py",
-        "lib/generic_ranging_decorator.py",
-        "test_utils/uwb_test_utils.py",
+        "RangingManagerTests/ranging_manager_tests.py",
+        "lib/*.py",
     ],
-    test_config: "uwb/AndroidTest.xml",
+    test_config: "RangingManagerTests/AndroidTest.xml",
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
-        ":generic_ranging_snippet",
+        ":bluetooth_multi_devices_snippet",
+        ":ranging_snippet",
+        ":uwb_snippet",
         "README.md",
     ],
-    defaults: ["GenericRangingMultiDevicePythonDefaults"],
+    defaults: ["RangingMultiDevicePythonDefaults"],
 }
diff --git a/ranging/tests/multidevices/OWNERS b/ranging/tests/multidevices/OWNERS
new file mode 100644
index 00000000..c87aad8e
--- /dev/null
+++ b/ranging/tests/multidevices/OWNERS
@@ -0,0 +1,2 @@
+# Bug component: 1042770
+include platform/packages/modules/Uwb:/OWNERS
\ No newline at end of file
diff --git a/generic_ranging/tests/multidevices/README.md b/ranging/tests/multidevices/README.md
similarity index 100%
rename from generic_ranging/tests/multidevices/README.md
rename to ranging/tests/multidevices/README.md
diff --git a/generic_ranging/tests/multidevices/uwb/AndroidTest.xml b/ranging/tests/multidevices/RangingManagerTests/AndroidTest.xml
similarity index 70%
rename from generic_ranging/tests/multidevices/uwb/AndroidTest.xml
rename to ranging/tests/multidevices/RangingManagerTests/AndroidTest.xml
index 731d73cc..ef2fa25f 100644
--- a/generic_ranging/tests/multidevices/uwb/AndroidTest.xml
+++ b/ranging/tests/multidevices/RangingManagerTests/AndroidTest.xml
@@ -14,7 +14,7 @@
   ~ See the License for the specific language governing permissions and
   ~ limitations under the License.
   -->
-<configuration description="Config for CTS Uwb multi-device test cases">
+<configuration description="Config for ranging multi-device test cases">
     <option name="test-suite-tag" value="cts" />
     <option name="config-descriptor:metadata" key="component" value="uwb" />
     <option name="config-descriptor:metadata" key="parameter" value="not_instant_app" />
@@ -22,14 +22,16 @@
     <option name="config-descriptor:metadata" key="parameter" value="not_secondary_user" />
     <option name="config-descriptor:metadata" key="mainline-param" value="com.google.android.uwb.apex" />
 
-    <object class="com.android.tradefed.testtype.suite.module.DeviceFeatureModuleController"
-            type="module_controller">
-        <option name="required-feature" value="android.hardware.uwb" />
-    </object>
 
     <device name="device1">
         <target_preparer class="com.android.tradefed.targetprep.suite.SuiteApkInstaller">
-            <option name="test-file-name" value="generic_ranging_snippet.apk" />
+            <option name="test-file-name" value="ranging_snippet.apk" />
+        </target_preparer>
+        <target_preparer class="com.android.tradefed.targetprep.suite.SuiteApkInstaller">
+            <option name="test-file-name" value="uwb_snippet.apk" />
+        </target_preparer>
+        <target_preparer class="com.android.tradefed.targetprep.suite.SuiteApkInstaller">
+            <option name="test-file-name" value="bluetooth_multi_devices_snippet.apk" />
         </target_preparer>
         <target_preparer class="com.android.tradefed.targetprep.RunCommandTargetPreparer">
             <option name="run-command" value="input keyevent KEYCODE_WAKEUP" />
@@ -38,7 +40,13 @@
     </device>
     <device name="device2">
         <target_preparer class="com.android.tradefed.targetprep.suite.SuiteApkInstaller">
-            <option name="test-file-name" value="generic_ranging_snippet.apk" />
+            <option name="test-file-name" value="ranging_snippet.apk" />
+        </target_preparer>
+        <target_preparer class="com.android.tradefed.targetprep.suite.SuiteApkInstaller">
+            <option name="test-file-name" value="uwb_snippet.apk" />
+        </target_preparer>
+        <target_preparer class="com.android.tradefed.targetprep.suite.SuiteApkInstaller">
+            <option name="test-file-name" value="bluetooth_multi_devices_snippet.apk" />
         </target_preparer>
         <target_preparer class="com.android.tradefed.targetprep.RunCommandTargetPreparer">
             <option name="run-command" value="input keyevent KEYCODE_WAKEUP" />
@@ -48,7 +56,7 @@
 
     <test class="com.android.tradefed.testtype.mobly.MoblyBinaryHostTest">
         <!-- The mobly-par-file-name should match the module name -->
-        <option name="mobly-par-file-name" value="MultiDeviceRangingTestCase_Uwb" />
+        <option name="mobly-par-file-name" value="MultiDeviceRangingTestCases" />
         <!-- Timeout limit in milliseconds for all test cases of the python binary -->
         <option name="mobly-test-timeout" value="1800000" />
     </test>
diff --git a/ranging/tests/multidevices/RangingManagerTests/ranging_manager_tests.py b/ranging/tests/multidevices/RangingManagerTests/ranging_manager_tests.py
new file mode 100644
index 00000000..4f431962
--- /dev/null
+++ b/ranging/tests/multidevices/RangingManagerTests/ranging_manager_tests.py
@@ -0,0 +1,572 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+import sys
+import time
+from typing import Set
+from lib import cs
+from lib import ranging_base_test
+from lib import rssi
+from lib import rtt
+from lib import utils
+from lib import uwb
+from lib.params import *
+from lib.ranging_decorator import *
+from mobly import asserts
+from mobly import config_parser
+from mobly import suite_runner
+
+
+_TEST_CASES = (
+    "test_one_to_one_uwb_ranging",
+    "test_one_to_one_uwb_ranging_provisioned_sts",
+    "test_one_to_one_uwb_ranging_disable_range_data_ntf",
+    "test_one_to_one_rtt_ranging",
+    "test_one_to_one_ble_rssi_ranging",
+    "test_one_to_one_ble_cs_ranging",
+)
+
+SERVICE_UUID = "0000fffb-0000-1000-8000-00805f9b34fc"
+
+class RangingManagerTest(ranging_base_test.RangingBaseTest):
+  """Tests for UWB Ranging APIs.
+
+  Attributes:
+
+  android_devices: list of android device objects.
+  """
+
+  def __init__(self, configs: config_parser.TestRunConfig):
+    """Init method for the test class.
+
+    Args:
+
+    configs: A config_parser.TestRunConfig object.
+    """
+    super().__init__(configs)
+    self.tests = _TEST_CASES
+
+  def setup_class(self):
+    super().setup_class()
+    self.devices = [RangingDecorator(ad) for ad in self.android_devices]
+    self.initiator, self.responder = self.devices
+
+    self.initiator.uwb_address = [1, 2]
+    self.responder.uwb_address = [3, 4]
+
+  def setup_test(self):
+    super().setup_test()
+    for device in self.devices:
+      utils.set_airplane_mode(device.ad, state=False)
+      if device.is_ranging_technology_supported(RangingTechnology.UWB):
+        utils.set_uwb_state_and_verify(device.ad, state=True)
+      utils.set_snippet_foreground_state(device.ad, isForeground=True)
+      utils.set_screen_state(device.ad, on=True)
+
+  def teardown_test(self):
+    super().teardown_test()
+    for device in self.devices:
+      device.clear_ranging_sessions()
+
+  ### Helpers ###
+
+  def _start_mutual_ranging_and_assert_started(
+      self,
+      session_handle: str,
+      initiator_preference: RangingPreference,
+      responder_preference: RangingPreference,
+      technologies: Set[RangingTechnology],
+  ):
+    """Starts one-to-one ranging session between initiator and responder.
+
+    Args:
+        session_id: id to use for the ranging session.
+    """
+    self.initiator.start_ranging_and_assert_opened(
+        session_handle, initiator_preference
+    )
+    if responder_preference is not None:
+        self.responder.start_ranging_and_assert_opened(
+            session_handle, responder_preference
+        )
+
+    asserts.assert_true(
+        self.initiator.verify_received_data_from_peer_using_technologies(
+            session_handle,
+            self.responder.id,
+            technologies,
+        ),
+        f"Initiator did not find responder",
+    )
+    if responder_preference is not None:
+        asserts.assert_true(
+            self.responder.verify_received_data_from_peer_using_technologies(
+                session_handle,
+                self.initiator.id,
+                technologies,
+            ),
+            f"Responder did not find initiator",
+        )
+
+  def _reset_bt_state(self):
+    utils.reset_bt_state(self.initiator.ad)
+    utils.reset_bt_state(self.responder.ad)
+
+
+  def _ble_connect(self):
+    """Create BLE GATT connection between initiator and responder.
+
+    """
+    # Start and advertise regular server
+    self.responder.ad.bluetooth.createAndAdvertiseServer(SERVICE_UUID)
+    # Connect to the advertisement
+    self.responder.bt_addr = self.initiator.ad.bluetooth.connectGatt(SERVICE_UUID)
+    asserts.assert_true(self.responder.bt_addr, "Server not connected")
+    # Check the target UUID is present
+    asserts.assert_true(self.initiator.ad.bluetooth.containsService(SERVICE_UUID), "Service not found")
+    connected_devices = self.responder.ad.bluetooth.getConnectedDevices()
+    asserts.assert_true(connected_devices, "No clients found connected to server")
+    self.initiator.bt_addr = connected_devices[0]
+
+  def _ble_disconnect(self):
+    asserts.assert_true(
+        self.initiator.ad.bluetooth.connectGatt(SERVICE_UUID), "Server not disconnected")
+
+  def _ble_bond(self):
+    """Create BLE GATT connection and bonding between initiator and responder.
+
+    """
+    # Start and advertise regular server
+    self.responder.ad.bluetooth.createAndAdvertiseServer(SERVICE_UUID)
+    oob_data = self.responder.ad.bluetooth.generateServerLocalOobData()
+    asserts.assert_true(oob_data, "OOB data not generated")
+    # Connect to the advertisement using OOB data generated on responder.
+    self.responder.bt_addr = self.initiator.ad.bluetooth.createBondOob(SERVICE_UUID, oob_data)
+    # Check the target UUID is present
+    asserts.assert_true(self.initiator.ad.bluetooth.containsService(SERVICE_UUID), "Service not found")
+    asserts.assert_true(self.responder.bt_addr, "Server not bonded")
+    connected_devices = self.responder.ad.bluetooth.getConnectedDevices()
+    asserts.assert_true(connected_devices, "No clients found connected to server")
+    self.initiator.bt_addr = connected_devices[0]
+
+  def _ble_unbond(self):
+    asserts.assert_true(
+        self.initiator.ad.bluetooth.removeBond(SERVICE_UUID), "Server not unbonded")
+
+  ### Test Cases ###
+
+  def test_one_to_one_uwb_ranging(self):
+    """Verifies uwb ranging with peer device, devices range for 10 seconds."""
+    SESSION_HANDLE = str(uuid4())
+    UWB_SESSION_ID = 5
+    TECHNOLOGIES = {RangingTechnology.UWB}
+
+    asserts.skip_if(
+        not self.responder.is_ranging_technology_supported(RangingTechnology.UWB),
+        f"UWB not supported by responder",
+    )
+    asserts.skip_if(
+        not self.initiator.is_ranging_technology_supported(RangingTechnology.UWB),
+        f"UWB not supported by initiator",
+    )
+
+    initiator_preference = RangingPreference(
+        device_role=DeviceRole.INITIATOR,
+        ranging_params=RawInitiatorRangingParams(
+            peer_params=[
+                DeviceParams(
+                    peer_id=self.responder.id,
+                    uwb_params=uwb.UwbRangingParams(
+                        session_id=UWB_SESSION_ID,
+                        config_id=uwb.ConfigId.UNICAST_DS_TWR,
+                        device_address=self.initiator.uwb_address,
+                        peer_address=self.responder.uwb_address,
+                    ),
+                )
+            ],
+        ),
+    )
+
+    responder_preference = RangingPreference(
+        device_role=DeviceRole.RESPONDER,
+        ranging_params=RawResponderRangingParams(
+            peer_params=DeviceParams(
+                peer_id=self.initiator.id,
+                uwb_params=uwb.UwbRangingParams(
+                    session_id=UWB_SESSION_ID,
+                    config_id=uwb.ConfigId.UNICAST_DS_TWR,
+                    device_address=self.responder.uwb_address,
+                    peer_address=self.initiator.uwb_address,
+                ),
+            ),
+        ),
+    )
+
+    self._start_mutual_ranging_and_assert_started(
+        SESSION_HANDLE,
+        initiator_preference,
+        responder_preference,
+        TECHNOLOGIES,
+    )
+
+    time.sleep(10)
+
+    asserts.assert_true(
+        self.initiator.verify_received_data_from_peer_using_technologies(
+            SESSION_HANDLE, self.responder.id, TECHNOLOGIES
+        ),
+        "Initiator did not find responder",
+    )
+    asserts.assert_true(
+        self.responder.verify_received_data_from_peer_using_technologies(
+            SESSION_HANDLE,
+            self.initiator.id,
+            TECHNOLOGIES,
+        ),
+        "Responder did not find initiator",
+    )
+
+    self.initiator.stop_ranging_and_assert_closed(SESSION_HANDLE)
+    self.responder.stop_ranging_and_assert_closed(SESSION_HANDLE)
+
+  def test_one_to_one_uwb_ranging_provisioned_sts(self):
+    """Verifies uwb ranging with peer device using provisioned sts"""
+    SESSION_HANDLE = str(uuid4())
+    UWB_SESSION_ID = 5
+    TECHNOLOGIES = {RangingTechnology.UWB}
+
+    asserts.skip_if(
+        not self.responder.is_ranging_technology_supported(RangingTechnology.UWB),
+        f"UWB not supported by responder",
+    )
+    asserts.skip_if(
+      not self.initiator.is_ranging_technology_supported(RangingTechnology.UWB),
+      f"UWB not supported by initiator",
+  )
+
+    initiator_preference = RangingPreference(
+        device_role=DeviceRole.INITIATOR,
+        ranging_params=RawInitiatorRangingParams(
+            peer_params=[
+                DeviceParams(
+                    peer_id=self.responder.id,
+                    uwb_params=uwb.UwbRangingParams(
+                        session_id=UWB_SESSION_ID,
+                        config_id=uwb.ConfigId.PROVISIONED_UNICAST_DS_TWR,
+                        device_address=self.initiator.uwb_address,
+                        peer_address=self.responder.uwb_address,
+                    ),
+                )
+            ],
+        ),
+    )
+
+    responder_preference = RangingPreference(
+        device_role=DeviceRole.RESPONDER,
+        ranging_params=RawResponderRangingParams(
+            peer_params=DeviceParams(
+                peer_id=self.initiator.id,
+                uwb_params=uwb.UwbRangingParams(
+                    session_id=UWB_SESSION_ID,
+                    config_id=uwb.ConfigId.PROVISIONED_UNICAST_DS_TWR,
+                    device_address=self.responder.uwb_address,
+                    peer_address=self.initiator.uwb_address,
+                ),
+            ),
+        ),
+    )
+
+    self._start_mutual_ranging_and_assert_started(
+        SESSION_HANDLE, initiator_preference, responder_preference, TECHNOLOGIES
+    )
+
+    self.initiator.stop_ranging_and_assert_closed(SESSION_HANDLE)
+    self.responder.stop_ranging_and_assert_closed(SESSION_HANDLE)
+
+  def test_one_to_one_uwb_ranging_disable_range_data_ntf(self):
+    """Verifies device does not receive range data after disabling range data notifications"""
+    SESSION_HANDLE = str(uuid4())
+    UWB_SESSION_ID = 5
+    asserts.skip_if(
+        not self.responder.is_ranging_technology_supported(RangingTechnology.UWB),
+        f"UWB not supported by responder",
+    )
+    asserts.skip_if(
+        not self.initiator.is_ranging_technology_supported(RangingTechnology.UWB),
+        f"UWB not supported by initiator",
+    )
+    initiator_preference = RangingPreference(
+        device_role=DeviceRole.INITIATOR,
+        ranging_params=RawInitiatorRangingParams(
+            peer_params=[
+                DeviceParams(
+                    peer_id=self.responder.id,
+                    uwb_params=uwb.UwbRangingParams(
+                        session_id=UWB_SESSION_ID,
+                        config_id=uwb.ConfigId.UNICAST_DS_TWR,
+                        device_address=self.initiator.uwb_address,
+                        peer_address=self.responder.uwb_address,
+                    ),
+                )
+            ],
+        ),
+        enable_range_data_notifications=False,
+    )
+
+    responder_preference = RangingPreference(
+        device_role=DeviceRole.RESPONDER,
+        ranging_params=RawResponderRangingParams(
+            peer_params=DeviceParams(
+                peer_id=self.initiator.id,
+                uwb_params=uwb.UwbRangingParams(
+                    session_id=UWB_SESSION_ID,
+                    config_id=uwb.ConfigId.UNICAST_DS_TWR,
+                    device_address=self.responder.uwb_address,
+                    peer_address=self.initiator.uwb_address,
+                ),
+            ),
+        ),
+        enable_range_data_notifications=True,
+    )
+
+    self.initiator.start_ranging_and_assert_opened(
+        SESSION_HANDLE, initiator_preference
+    )
+    self.responder.start_ranging_and_assert_opened(
+        SESSION_HANDLE, responder_preference
+    )
+
+    asserts.assert_false(
+        self.initiator.verify_received_data_from_peer(
+            SESSION_HANDLE, self.responder.id
+        ),
+        "Initiator found responder but initiator has range data"
+        " notifications disabled",
+    )
+    asserts.assert_true(
+        self.responder.verify_received_data_from_peer(
+            SESSION_HANDLE, self.initiator.id
+        ),
+        "Responder did not find initiator but responder has range data"
+        " notifications enabled",
+    )
+
+    self.initiator.stop_ranging_and_assert_closed(SESSION_HANDLE)
+    self.responder.stop_ranging_and_assert_closed(SESSION_HANDLE)
+
+  def test_one_to_one_rtt_ranging(self):
+    """Verifies uwb ranging with peer device, devices range for 10 seconds."""
+    SESSION_HANDLE = str(uuid4())
+    TECHNOLOGIES = {RangingTechnology.WIFI_RTT}
+
+    asserts.skip_if(
+        not self.responder.is_ranging_technology_supported(RangingTechnology.WIFI_RTT),
+        f"Wifi nan rtt not supported by responder",
+    )
+    asserts.skip_if(
+        not self.initiator.is_ranging_technology_supported(RangingTechnology.WIFI_RTT),
+        f"Wifi nan rtt not supported by initiator",
+    )
+
+    initiator_preference = RangingPreference(
+        device_role=DeviceRole.INITIATOR,
+        ranging_params=RawInitiatorRangingParams(
+            peer_params=[
+                DeviceParams(
+                    peer_id=self.responder.id,
+                    rtt_params=rtt.RttRangingParams(
+                        service_name="test_service_name1",
+                    ),
+                )
+            ],
+        ),
+    )
+
+    responder_preference = RangingPreference(
+        device_role=DeviceRole.RESPONDER,
+        ranging_params=RawResponderRangingParams(
+            peer_params=DeviceParams(
+                peer_id=self.initiator.id,
+                rtt_params=rtt.RttRangingParams(
+                    service_name="test_service_name1",
+                ),
+            ),
+        ),
+    )
+
+    # Should be able to call _start_mutual_ranging_and_assert_started once we get consistent data.
+    self.initiator.start_ranging_and_assert_opened(
+        SESSION_HANDLE, initiator_preference
+    )
+    self.responder.start_ranging_and_assert_opened(
+        SESSION_HANDLE, responder_preference
+    )
+
+    time.sleep(10)
+    asserts.assert_true(
+        self.initiator.verify_received_data_from_peer_using_technologies(
+            SESSION_HANDLE, self.responder.id, TECHNOLOGIES
+        ),
+        "Initiator did not find responder",
+    )
+
+    # Enable when this is supported.
+    # asserts.assert_true(
+    #     self.responder.verify_peer_found_with_technologies(
+    #         SESSION_HANDLE,
+    #         self.initiator.id,
+    #         TECHNOLOGIES,
+    #     ),
+    #     "Responder did not find initiator",
+    # )
+
+    self.initiator.stop_ranging_and_assert_closed(SESSION_HANDLE)
+    self.responder.stop_ranging_and_assert_closed(SESSION_HANDLE)
+
+  def test_one_to_one_ble_rssi_ranging(self):
+    """Verifies cs ranging with peer device, devices range for 10 seconds."""
+    SESSION_HANDLE = str(uuid4())
+    TECHNOLOGIES = {RangingTechnology.BLE_RSSI}
+
+    asserts.skip_if(
+        not self.responder.is_ranging_technology_supported(RangingTechnology.BLE_RSSI),
+        f"BLE RSSI not supported by responder",
+    )
+    asserts.skip_if(
+        not self.initiator.is_ranging_technology_supported(RangingTechnology.BLE_RSSI),
+        f"BLE RSSI not supported by initiator",
+    )
+    self._reset_bt_state()
+
+    self._ble_connect()
+
+    initiator_preference = RangingPreference(
+        device_role=DeviceRole.INITIATOR,
+        ranging_params=RawInitiatorRangingParams(
+            peer_params=[
+                DeviceParams(
+                    peer_id=self.responder.id,
+                    rssi_params=rssi.BleRssiRangingParams(
+                      peer_address=self.responder.bt_addr,
+                    ),
+                )
+            ],
+        ),
+    )
+
+    responder_preference = RangingPreference(
+        device_role=DeviceRole.RESPONDER,
+        ranging_params=RawResponderRangingParams(
+            peer_params=DeviceParams(
+                peer_id=self.initiator.id,
+                rssi_params=rssi.BleRssiRangingParams(
+                  peer_address=self.initiator.bt_addr,
+                ),
+            ),
+        ),
+    )
+
+    try:
+      self._start_mutual_ranging_and_assert_started(
+          SESSION_HANDLE,
+          initiator_preference,
+          responder_preference,
+          TECHNOLOGIES,
+      )
+
+      time.sleep(10)
+
+      asserts.assert_true(
+          self.initiator.verify_received_data_from_peer_using_technologies(
+              SESSION_HANDLE,
+              self.responder.id,
+              TECHNOLOGIES
+          ),
+          "Initiator did not find responder",
+      )
+      asserts.assert_true(
+          self.responder.verify_received_data_from_peer_using_technologies(
+              SESSION_HANDLE,
+              self.initiator.id,
+              TECHNOLOGIES,
+          ),
+          "Responder did not find initiator",
+      )
+    finally:
+      self.initiator.stop_ranging_and_assert_closed(SESSION_HANDLE)
+      self.responder.stop_ranging_and_assert_closed(SESSION_HANDLE)
+
+      self._ble_disconnect()
+
+  def test_one_to_one_ble_cs_ranging(self):
+    """
+    Verifies cs ranging with peer device, devices range for 10 seconds.
+    This test is only one way since we don't test if responder also can simultaneously get the data.
+    """
+    SESSION_HANDLE = str(uuid4())
+    TECHNOLOGIES = {RangingTechnology.BLE_CS}
+
+    asserts.skip_if(
+        not self.responder.is_ranging_technology_supported(RangingTechnology.BLE_CS),
+        f"BLE_CS not supported by responder",
+    )
+    asserts.skip_if(
+        not self.initiator.is_ranging_technology_supported(RangingTechnology.BLE_CS),
+        f"BLE CS not supported by initiator",
+    )
+    self._reset_bt_state()
+
+    self._ble_bond()
+
+    initiator_preference = RangingPreference(
+        device_role=DeviceRole.INITIATOR,
+        ranging_params=RawInitiatorRangingParams(
+            peer_params=[
+                DeviceParams(
+                    peer_id=self.responder.id,
+                    cs_params=cs.CsRangingParams(
+                      peer_address=self.responder.bt_addr,
+                    ),
+                )
+            ],
+        ),
+    )
+
+    try:
+      self._start_mutual_ranging_and_assert_started(
+          SESSION_HANDLE,
+          initiator_preference,
+          None,
+          TECHNOLOGIES,
+      )
+
+      time.sleep(10)
+
+      asserts.assert_true(
+          self.initiator.verify_received_data_from_peer_using_technologies(
+              SESSION_HANDLE,
+              self.responder.id,
+              TECHNOLOGIES
+          ),
+          "Initiator did not find responder",
+      )
+    finally:
+      self.initiator.stop_ranging_and_assert_closed(SESSION_HANDLE)
+
+      self._ble_unbond()
+
+if __name__ == "__main__":
+  if "--" in sys.argv:
+    index = sys.argv.index("--")
+    sys.argv = sys.argv[:1] + sys.argv[index + 1 :]
+  suite_runner.run_suite([RangingManagerTest])
diff --git a/ranging/tests/multidevices/lib/cs.py b/ranging/tests/multidevices/lib/cs.py
new file mode 100644
index 00000000..18fc71a9
--- /dev/null
+++ b/ranging/tests/multidevices/lib/cs.py
@@ -0,0 +1,22 @@
+"""Class for CS ranging parameters for testing."""
+
+import dataclasses
+from enum import IntEnum
+from typing import List
+
+class RangingUpdateRate(IntEnum):
+  AUTOMATIC = 1
+  INFREQUENT = 2
+  FREQUENT = 3
+
+class SecurityLevel(IntEnum):
+  LEVEL_1 = 1
+  LEVEL_4 = 4
+
+@dataclasses.dataclass(kw_only=True)
+class CsRangingParams:
+  """Class for CS ranging parameters."""
+
+  peer_address: List[int]
+  ranging_update_rate: RangingUpdateRate = RangingUpdateRate.AUTOMATIC
+  security_level: SecurityLevel = SecurityLevel.LEVEL_1
diff --git a/ranging/tests/multidevices/lib/params.py b/ranging/tests/multidevices/lib/params.py
new file mode 100644
index 00000000..3023be26
--- /dev/null
+++ b/ranging/tests/multidevices/lib/params.py
@@ -0,0 +1,59 @@
+from abc import ABC, abstractmethod
+import dataclasses
+from enum import IntEnum
+from typing import List, Optional
+from lib.cs import CsRangingParams
+from lib.rtt import RttRangingParams
+from lib.uwb import UwbRangingParams
+from lib.rssi import BleRssiRangingParams
+
+
+class DeviceRole(IntEnum):
+  RESPONDER = 0
+  INITIATOR = 1
+
+
+class RangingSessionType(IntEnum):
+  RAW = 0
+  OOB = 1
+
+
+@dataclasses.dataclass(kw_only=True, frozen=True)
+class DeviceParams:
+  peer_id: str
+  uwb_params: Optional[UwbRangingParams] = None
+  cs_params: Optional[CsRangingParams] = None
+  rtt_params: Optional[RttRangingParams] = None
+  rssi_params: Optional[BleRssiRangingParams] = None
+
+
+@dataclasses.dataclass(kw_only=True, frozen=True)
+class RangingParams(ABC):
+  session_type: RangingSessionType
+
+
+@dataclasses.dataclass(kw_only=True, frozen=True)
+class RawInitiatorRangingParams(RangingParams):
+  session_type: RangingSessionType = RangingSessionType.RAW
+  peer_params: List[DeviceParams]
+
+
+@dataclasses.dataclass(kw_only=True, frozen=True)
+class RawResponderRangingParams(RangingParams):
+  session_type: RangingSessionType = RangingSessionType.RAW
+  peer_params: DeviceParams
+
+
+@dataclasses.dataclass(kw_only=True, frozen=True)
+class SensorFusionParams:
+  is_sensor_fusion_enabled: bool = True
+
+
+@dataclasses.dataclass(kw_only=True, frozen=True)
+class RangingPreference:
+  device_role: DeviceRole
+  ranging_params: RangingParams
+  sensor_fusion_params: SensorFusionParams = dataclasses.field(
+      default_factory=SensorFusionParams
+  )
+  enable_range_data_notifications: bool = True
diff --git a/generic_ranging/tests/multidevices/lib/ranging_base_test.py b/ranging/tests/multidevices/lib/ranging_base_test.py
similarity index 71%
rename from generic_ranging/tests/multidevices/lib/ranging_base_test.py
rename to ranging/tests/multidevices/lib/ranging_base_test.py
index 9811b5b0..51d61db7 100644
--- a/generic_ranging/tests/multidevices/lib/ranging_base_test.py
+++ b/ranging/tests/multidevices/lib/ranging_base_test.py
@@ -15,11 +15,11 @@
 
 import re
 
+from lib import utils
 from mobly import base_test
-from mobly import records
 from mobly import test_runner
 from mobly.controllers import android_device
-from test_utils import uwb_test_utils
+
 
 RELEASE_ID_REGEX = re.compile(r"\w+\.\d+\.\d+")
 
@@ -34,8 +34,10 @@ class RangingBaseTest(base_test.BaseTestClass):
         android_device, min_number=2
     )
     for ad in self.android_devices:
-      ad.load_snippet("ranging", "multidevices.snippet.ranging")
-      uwb_test_utils.initialize_uwb_country_code_if_necessary(ad)
+      ad.load_snippet("ranging", "com.google.snippet.ranging")
+      utils.initialize_uwb_country_code_if_necessary(ad)
+      ad.load_snippet("uwb", "com.google.snippet.uwb")
+      ad.load_snippet("bluetooth", "com.google.snippet.bluetooth")
 
   def setup_test(self):
     super().setup_test()
@@ -54,6 +56,17 @@ class RangingBaseTest(base_test.BaseTestClass):
   def teardown_class(self):
     super().teardown_class()
 
+  def on_fail(self, record):
+    test_name = record.test_name
+    # Single device test
+    for count, ad in enumerate(self.android_devices):
+      device_name = "initiator" if not count else "responder"
+      test_device_name = test_name + "_" + device_name
+      ad.take_bug_report(
+          test_name=test_device_name,
+          destination=self.current_test_info.output_path,
+      )
+
 
 if __name__ == "__main__":
   test_runner.main()
diff --git a/ranging/tests/multidevices/lib/ranging_decorator.py b/ranging/tests/multidevices/lib/ranging_decorator.py
new file mode 100644
index 00000000..50c3eef1
--- /dev/null
+++ b/ranging/tests/multidevices/lib/ranging_decorator.py
@@ -0,0 +1,164 @@
+import copy
+import dataclasses
+from enum import IntEnum, StrEnum
+from typing import Set
+from uuid import uuid4
+from lib.params import RangingPreference
+from mobly.controllers import android_device
+
+
+CALLBACK_WAIT_TIME_SEC = 5
+
+
+class RangingTechnology(IntEnum):
+  UWB = 0
+  BLE_CS = 1
+  WIFI_RTT = 2
+  BLE_RSSI = 3
+
+
+class Event(StrEnum):
+  OPENED = "OPENED"
+  OPEN_FAILED = "OPEN_FAILED"
+  STARTED = "STARTED"
+  DATA = "DATA"
+  STOPPED = "STOPPED"
+  CLOSED = "CLOSED"
+
+
+class RangingDecorator:
+
+  def __init__(self, ad: android_device.AndroidDevice):
+    """Initialize the ranging device.
+
+    Args:
+        ad: android device object
+    """
+    self.id = str(uuid4())
+    self.ad = ad
+    self._event_handlers = {}
+    self.log = self.ad.log
+    self.uwb_address = None
+    self.bt_addr = None
+
+  def start_ranging_and_assert_opened(
+      self, session_handle: str, preference: RangingPreference
+  ):
+    """Start ranging with the specified preference and wait for onStarted event.
+
+    Throws:
+      CallbackHandlerTimeoutError if ranging does not successfully start.
+    """
+    handler = self.ad.ranging.startRanging(
+        session_handle, dataclasses.asdict(preference)
+    )
+    self._event_handlers[session_handle] = handler
+    self.assert_ranging_event_received(session_handle, Event.OPENED)
+
+  def is_ranging_technology_supported(self, ranging_technology : RangingTechnology) -> bool:
+
+    """Checks whether a specific ranging technology is supported by the device"""
+    return self.ad.ranging.isTechnologySupported(ranging_technology)
+
+
+  def stop_ranging_and_assert_closed(self, session_handle: str):
+    """Stop ranging and wait for onStopped event.
+
+    Throws:
+      CallbackHandlerTimeoutError if ranging was not successfully stopped.
+    """
+    self.ad.ranging.stopRanging(session_handle)
+    self.assert_ranging_event_received(session_handle, Event.CLOSED)
+    self._event_handlers.pop(session_handle)
+
+  def assert_ranging_event_received(
+      self,
+      session_handle: str,
+      event: Event,
+      timeout_s: int = CALLBACK_WAIT_TIME_SEC,
+  ):
+    """Asserts that the expected event is received before a timeout.
+
+    Args:
+      session_handle: identifier for the ranging session.
+      event: expected ranging event.
+      timeout_s: timeout in seconds.
+
+    Throws:
+      CallbackHandlerTimeoutError if the expected event was not received.
+    """
+    handler = self._event_handlers[session_handle]
+    handler.waitAndGet(event, timeout=timeout_s)
+
+  def verify_received_data_from_peer_using_technologies(
+      self,
+      session_handle: str,
+      peer_id: str,
+      technologies: Set[RangingTechnology],
+      timeout_s: int = CALLBACK_WAIT_TIME_SEC,
+  ) -> bool:
+    """Verifies that the peer sends us data from all provided technologies before a timeout.
+
+    Args:
+      session_handle: unique identifier for the ranging session.
+      peer_id: UUID of the peer.
+      technologies: set of ranging technologies over which we want to receive
+        data.
+      timeout_s: timeout in seconds.
+
+    Returns:
+        True if peer was found, False otherwise
+    """
+    remaining_technologies = copy.deepcopy(technologies)
+
+    def predicate(event):
+      peer = event.data["peer"]
+      technology = event.data["technology"]
+
+      if peer == peer_id and technology in copy.deepcopy(
+          remaining_technologies
+      ):
+        remaining_technologies.remove(technology)
+
+      return not bool(remaining_technologies)
+
+    handler = self._event_handlers[session_handle]
+    try:
+      handler.waitForEvent(Event.DATA, predicate, timeout=timeout_s)
+      return True
+    except Exception:
+      return False
+
+  def verify_received_data_from_peer(
+      self,
+      session_handle: str,
+      peer_id: str,
+      timeout_s: int = CALLBACK_WAIT_TIME_SEC,
+  ) -> bool:
+    """Verifies that the peer sends us data using any technology before a timeout.
+
+    Args:
+      session_handle: unique identifier for the ranging session.
+      peer_id: UUID of the peer.
+      timeout_s: timeout in seconds.
+
+    Returns:
+        True if peer received data, False otherwise
+    """
+
+    def predicate(event):
+      return event.data["peer"] == peer_id
+
+    handler = self._event_handlers[session_handle]
+    try:
+      handler.waitForEvent(Event.DATA, predicate, timeout=timeout_s)
+      return True
+    except Exception:
+      return False
+
+  def clear_ranging_sessions(self):
+    """Stop all ranging sessions and clear callback events"""
+    for session_handle in self._event_handlers.keys():
+      self.ad.ranging.stopRanging(session_handle)
+
+    self._event_handlers.clear()
diff --git a/ranging/tests/multidevices/lib/rssi.py b/ranging/tests/multidevices/lib/rssi.py
new file mode 100644
index 00000000..9574f17f
--- /dev/null
+++ b/ranging/tests/multidevices/lib/rssi.py
@@ -0,0 +1,19 @@
+"""Class for Ble Rssi ranging parameters for testing."""
+
+import dataclasses
+from enum import IntEnum
+from typing import List
+
+
+class RangingUpdateRate(IntEnum):
+    AUTOMATIC = 1
+    INFREQUENT = 2
+    FREQUENT = 3
+
+
+@dataclasses.dataclass(kw_only=True)
+class BleRssiRangingParams:
+  """Class for Uwb ranging parameters."""
+
+  peer_address: List[int]
+  ranging_update_rate: RangingUpdateRate = RangingUpdateRate.AUTOMATIC
\ No newline at end of file
diff --git a/ranging/tests/multidevices/lib/rtt.py b/ranging/tests/multidevices/lib/rtt.py
new file mode 100644
index 00000000..b7034b3b
--- /dev/null
+++ b/ranging/tests/multidevices/lib/rtt.py
@@ -0,0 +1,18 @@
+"""Class for Rtt ranging parameters for testing."""
+
+import dataclasses
+from enum import IntEnum
+
+
+class RangingUpdateRate(IntEnum):
+  AUTOMATIC = 1
+  INFREQUENT = 2
+  FREQUENT = 3
+
+
+@dataclasses.dataclass(kw_only=True)
+class RttRangingParams:
+  """Class for Uwb ranging parameters."""
+
+  service_name: str
+  ranging_update_rate: RangingUpdateRate = RangingUpdateRate.AUTOMATIC
diff --git a/ranging/tests/multidevices/lib/utils.py b/ranging/tests/multidevices/lib/utils.py
new file mode 100644
index 00000000..cd50e7ab
--- /dev/null
+++ b/ranging/tests/multidevices/lib/utils.py
@@ -0,0 +1,222 @@
+#  Copyright (C) 2024 The Android Open Source Project
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+"""Test utils for UWB."""
+
+import time
+from lib.ranging_decorator import RangingTechnology
+from mobly import asserts
+from mobly.controllers import android_device
+
+WAIT_TIME_SEC = 3
+
+
+def initialize_uwb_country_code_if_necessary(ad: android_device.AndroidDevice):
+  """Sets UWB country code to US if the device does not have it set.
+
+  Note: This intentionally relies on an unstable API (shell command) since we
+  don't want to expose an API that allows users to circumvent the UWB
+  regulatory requirements.
+
+  Args:
+    ad: android device object.
+    handler: callback handler.
+  """
+  # Wait to see if UWB state is reported as enabled. If not, this could be
+  # because the country code is not set. Try forcing the country code in that
+  # case.
+  if is_technology_enabled(ad, RangingTechnology.UWB, timeout_s=60):
+    return
+
+  try:
+    ad.adb.shell(["cmd", "uwb", "force-country-code", "enabled", "US"])
+  except ad.adb.AdbError:
+    ad.log.warning("Unable to force uwb country code")
+
+  # Unable to get UWB enabled even after setting country code, abort!
+  asserts.assert_true(
+      is_technology_enabled(ad, RangingTechnology.UWB, timeout_s=60),
+      "Uwb was not enabled after setting country code",
+  )
+
+def _is_technology_state(
+    ad: android_device.AndroidDevice,
+    technology: RangingTechnology,
+    state: bool,
+    timeout_s=WAIT_TIME_SEC,
+) -> bool:
+  """Checks if the provided technology becomes enabled/disabled
+
+  Args:
+
+  ad: android device object.
+  technology: to check for enablement.
+  state: bool, True for on, False for off.
+  timeout_s: how long to wait for enablement before failing, in seconds.
+  """
+  start_time = time.time()
+  while state != ad.ranging.isTechnologyEnabled(technology):
+    if time.time() - start_time > timeout_s:
+      return False
+  return True
+
+
+def is_technology_enabled(
+    ad: android_device.AndroidDevice,
+    technology: RangingTechnology,
+    timeout_s=WAIT_TIME_SEC,
+) -> bool:
+  """Checks if the provided technology becomes enabled
+
+  Args:
+
+  ad: android device object.
+  technology: to check for enablement.
+  timeout_s: how long to wait for enablement before failing, in seconds.
+  """
+  return _is_technology_state(ad, technology, True, timeout_s)
+
+
+def set_airplane_mode(ad: android_device.AndroidDevice, state: bool):
+  """Sets the airplane mode to the given state.
+
+  Args:
+    ad: android device object.
+    state: True for Airplane mode enabled, False for disabled.
+  """
+  ad.ranging.setAirplaneMode(state)
+  start_time = time.time()
+  while get_airplane_mode(ad) != state:
+    time.sleep(0.5)
+    if time.time() - start_time > WAIT_TIME_SEC:
+      asserts.fail(f"Failed to set airplane mode to: {state}")
+
+
+def get_airplane_mode(ad: android_device.AndroidDevice) -> bool:
+  """Gets the current airplane mode setting.
+
+  Args:
+    ad: android device object.
+
+  Returns:
+    True if airplane mode On, False for Off.
+  """
+  state = ad.adb.shell(["settings", "get", "global", "airplane_mode_on"])
+  return bool(int(state.decode().strip()))
+
+def set_uwb_state_and_verify(
+    ad: android_device.AndroidDevice,
+    state: bool
+):
+  """Sets UWB state to on or off and verifies it.
+
+  Args:
+    ad: android device object.
+    state: bool, True for UWB on, False for off.
+  """
+  failure_msg = "enabled" if state else "disabled"
+  ad.uwb.setUwbEnabled(state)
+  asserts.assert_true(_is_technology_state(ad, RangingTechnology.UWB, state, timeout_s=60),
+                      "Uwb is not %s" % failure_msg)
+
+def reset_bt_state(
+    ad: android_device.AndroidDevice
+):
+  """Reset BT state to off and then on before each test.
+
+  Args:
+    ad: android device object.
+  """
+  ad.bluetooth.disableBluetooth()
+  time.sleep(3)
+  asserts.assert_false(ad.bluetooth.isBluetoothOn(), 'Bluetooth did not stop')
+  ad.bluetooth.enableBluetooth()
+  time.sleep(3)
+  asserts.assert_true(ad.bluetooth.isBluetoothOn(), 'Bluetooth did not stop')
+  # Check for BLE RSSI or BLE CS availability
+  asserts.assert_true(_is_technology_state(ad, RangingTechnology.BLE_RSSI, True, timeout_s=60),
+                      "BT is not enabled in ranging API")
+  ad.bluetooth.reset()
+
+
+def set_bt_state_and_verify(
+    ad: android_device.AndroidDevice,
+    state: bool
+):
+  """Sets BT state to on or off and verifies it.
+
+  Args:
+    ad: android device object.
+    state: bool, True for BT on, False for off.
+  """
+  failure_msg = "enabled" if state else "disabled"
+  if state:
+    ad.bluetooth.enableBluetooth()
+  else:
+    ad.bluetooth.disableBluetooth()
+  time.sleep(3)
+  asserts.assert_equal(ad.bluetooth.isBluetoothOn(), state, 'Bluetooth did not stop')
+  # Check for BLE RSSI or BLE CS availability
+  asserts.assert_true(_is_technology_state(ad, RangingTechnology.BLE_RSSI, state, timeout_s=60),
+                      "BT is not %s in ranging API" % failure_msg)
+
+
+def set_screen_rotation_landscape(
+    ad: android_device.AndroidDevice, isLandscape: bool
+):
+  """Sets screen orientation to landscape or portrait mode.
+
+  Args:
+    ad: android device object.
+    isLandscape: True for landscape mode, False for potrait.
+  """
+  ad.adb.shell(["settings", "put", "system", "accelerometer_rotation", "0"])
+  ad.adb.shell([
+      "settings",
+      "put",
+      "system",
+      "user_rotation",
+      "1" if isLandscape else "0",
+  ])
+
+
+def set_snippet_foreground_state(
+    ad: android_device.AndroidDevice, isForeground: bool
+):
+  """Sets the snippet app's foreground/background state.
+
+  Args:
+    ad: android device object.
+    isForeground: True to move snippet to foreground, False for background.
+  """
+  ad.adb.shell([
+      "cmd",
+      "uwb",
+      "simulate-app-state-change",
+      "com.google.snippet.ranging",
+      "foreground" if isForeground else "background",
+  ])
+
+
+def set_screen_state(
+    ad: android_device.AndroidDevice, on: bool
+):
+  """Sets the device screen state on/off.
+
+  Args:
+    ad: android device object.
+    on: True for screen on, False for screen off.
+  """
+  ad.adb.shell([
+      "svc", "power", "stayon", "true" if on else "false",
+  ])
diff --git a/ranging/tests/multidevices/lib/uwb.py b/ranging/tests/multidevices/lib/uwb.py
new file mode 100644
index 00000000..687236e2
--- /dev/null
+++ b/ranging/tests/multidevices/lib/uwb.py
@@ -0,0 +1,42 @@
+"""Class for UWB ranging parameters for testing."""
+
+import dataclasses
+from enum import IntEnum
+from typing import List, Optional
+
+
+class ConfigId(IntEnum):
+  UNICAST_DS_TWR = 1
+  MULTICAST_DS_TWR = 2
+  PROVISIONED_UNICAST_DS_TWR = 4
+  PROVISIONED_MULTICAST_DS_TWR = 5
+  PROVISIONED_INDIVIDUAL_MULTICAST_DS_TWR = 7
+
+
+class RangingUpdateRate(IntEnum):
+  AUTOMATIC = 1
+  INFREQUENT = 2
+  FREQUENT = 3
+
+
+class SlotDuration(IntEnum):
+  MILLIS_1 = 1
+  MILLIS_2 = 2
+
+
+@dataclasses.dataclass(kw_only=True)
+class UwbRangingParams:
+  """Class for Uwb ranging parameters."""
+
+  session_id: int
+  sub_session_id: int = 0
+  config_id: ConfigId
+  device_address: List[int]
+  session_key_info: List[int] = dataclasses.field(
+      default_factory=lambda: [1, 2, 3, 4, 5, 6, 7, 8, 8, 7, 6, 5, 4, 3, 2, 1]
+  )
+  sub_session_key_info: Optional[List[int]] = None
+  peer_address: List[int]
+  ranging_update_rate: RangingUpdateRate = RangingUpdateRate.AUTOMATIC
+  slot_duration_ms: SlotDuration = SlotDuration.MILLIS_2
+  is_aoa_disabled: bool = False
diff --git a/generic_ranging/tests/multidevices/snippet/Android.bp b/ranging/tests/multidevices/snippet/Android.bp
similarity index 86%
rename from generic_ranging/tests/multidevices/snippet/Android.bp
rename to ranging/tests/multidevices/snippet/Android.bp
index 5da7ddc0..37ee2290 100644
--- a/generic_ranging/tests/multidevices/snippet/Android.bp
+++ b/ranging/tests/multidevices/snippet/Android.bp
@@ -18,10 +18,11 @@ package {
 }
 
 android_test {
-    name: "generic_ranging_snippet",
+    name: "ranging_snippet",
     sdk_version: "system_34",
     srcs: [
-        "GenericRangingSnippet.java",
+        "RangingSnippet.java",
+        "RangingPreferenceConverter.java",
     ],
     manifest: "AndroidManifest.xml",
     static_libs: [
@@ -31,8 +32,8 @@ android_test {
         "guava",
         "jsr330",
         "mobly-snippet-lib",
-        "generic_ranging",
-        "uwb_androidx_backend",
+        "ranging_flags_lib",
+        "framework-ranging.impl",
     ],
     min_sdk_version: "34",
 }
diff --git a/generic_ranging/tests/multidevices/snippet/AndroidManifest.xml b/ranging/tests/multidevices/snippet/AndroidManifest.xml
similarity index 79%
rename from generic_ranging/tests/multidevices/snippet/AndroidManifest.xml
rename to ranging/tests/multidevices/snippet/AndroidManifest.xml
index 80c6af23..9a638891 100644
--- a/generic_ranging/tests/multidevices/snippet/AndroidManifest.xml
+++ b/ranging/tests/multidevices/snippet/AndroidManifest.xml
@@ -15,7 +15,7 @@
   -->
 
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="multidevices.snippet.ranging">
+    package="com.google.snippet.ranging">
 
     <application>
         <!-- Add any classes that implement the Snippet interface as meta-data, whose
@@ -23,11 +23,14 @@
              of a snippet class -->
         <meta-data
             android:name="mobly-snippets"
-            android:value="multidevices.snippet.ranging.GenericRangingSnippet" />
+            android:value="com.google.snippet.ranging.RangingSnippet" />
+        <meta-data
+            android:name="mobly-object-converter"
+            android:value="com.google.snippet.ranging.RangingPreferenceConverter" />
     </application>
     <instrumentation
         android:name="com.google.android.mobly.snippet.SnippetRunner"
-        android:targetPackage="multidevices.snippet.ranging" />
+        android:targetPackage="com.google.snippet.ranging" />
 
     <uses-permission android:name="android.permissions.UWB_PRIVILEGED" />
     <!-- Add an instrumentation tag so that the app can be launched through an
@@ -35,4 +38,5 @@
          is derived from `AndroidJUnitRunner`, and is required to use the
          Mobly Snippet Lib. -->
     <uses-permission android:name="android.permission.UWB_RANGING" />
+    <uses-permission android:name="android.permission.RANGING" />
 </manifest>
diff --git a/ranging/tests/multidevices/snippet/RangingPreferenceConverter.java b/ranging/tests/multidevices/snippet/RangingPreferenceConverter.java
new file mode 100644
index 00000000..fb52a6b6
--- /dev/null
+++ b/ranging/tests/multidevices/snippet/RangingPreferenceConverter.java
@@ -0,0 +1,205 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.snippet.ranging;
+
+import static android.ranging.RangingPreference.DEVICE_ROLE_INITIATOR;
+import static android.ranging.uwb.UwbComplexChannel.UWB_CHANNEL_9;
+import static android.ranging.uwb.UwbComplexChannel.UWB_PREAMBLE_CODE_INDEX_11;
+
+import android.ranging.DataNotificationConfig;
+import android.ranging.RangingDevice;
+import android.ranging.RangingParams;
+import android.ranging.RangingPreference;
+import android.ranging.SensorFusionParams;
+import android.ranging.SessionConfiguration;
+import android.ranging.ble.cs.CsRangingParams;
+import android.ranging.ble.rssi.BleRssiRangingParams;
+import android.ranging.raw.RawInitiatorRangingParams;
+import android.ranging.raw.RawRangingDevice;
+import android.ranging.raw.RawResponderRangingParams;
+import android.ranging.uwb.UwbAddress;
+import android.ranging.uwb.UwbComplexChannel;
+import android.ranging.uwb.UwbRangingParams;
+import android.ranging.wifi.rtt.RttRangingParams;
+
+import com.google.android.mobly.snippet.SnippetObjectConverter;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.lang.reflect.Type;
+import java.util.UUID;
+
+public class RangingPreferenceConverter implements SnippetObjectConverter {
+
+    @Override
+    public JSONObject serialize(Object object) {
+        throw new UnsupportedOperationException("Not implemented");
+    }
+
+    @Override
+    public Object deserialize(JSONObject j, Type type) throws JSONException {
+        if (type != RangingPreference.class) return null;
+
+        return new RangingPreference.Builder(j.getInt("device_role"),
+                getRangingParams(j.getJSONObject("ranging_params"), j.getInt("device_role")))
+                .setSessionConfiguration(
+                        new SessionConfiguration.Builder()
+                                .setSensorFusionParameters(
+                                        getSensorFusionParams(
+                                                j.getJSONObject("sensor_fusion_params"))
+                                )
+                                .setDataNotificationConfig(
+                                        getDataNotificationConfig(
+                                                j.getBoolean("enable_range_data_notifications"))
+                                )
+                                .build()
+                )
+                .build();
+    }
+
+    private RangingParams getRangingParams(
+            JSONObject j, @RangingPreference.DeviceRole int role
+    ) throws JSONException {
+        RangingParams params;
+
+        if (j.getInt("session_type") == RangingParams.RANGING_SESSION_RAW) {
+            if (role == DEVICE_ROLE_INITIATOR) {
+                params = getRawInitiatorRangingParams(j);
+            } else {
+                params = getRawResponderRangingParams(j);
+            }
+        } else {
+            throw new UnsupportedOperationException("OOB ranging not implemented");
+        }
+
+        return params;
+    }
+
+    private RawInitiatorRangingParams getRawInitiatorRangingParams(
+            JSONObject j
+    ) throws JSONException {
+        RawInitiatorRangingParams.Builder builder = new RawInitiatorRangingParams.Builder();
+        JSONArray jPeerParams = j.getJSONArray("peer_params");
+        for (int i = 0; i < jPeerParams.length(); i++) {
+            builder.addRawRangingDevice(getRawRangingDevice(jPeerParams.getJSONObject(i)));
+        }
+        return builder.build();
+    }
+
+    private RawResponderRangingParams getRawResponderRangingParams(
+            JSONObject j
+    ) throws JSONException {
+        return new RawResponderRangingParams.Builder()
+                .setRawRangingDevice(getRawRangingDevice(j.getJSONObject("peer_params")))
+                .build();
+    }
+
+    private RawRangingDevice getRawRangingDevice(JSONObject j) throws JSONException {
+        RawRangingDevice.Builder builder = new RawRangingDevice.Builder();
+        builder.setRangingDevice(
+                new RangingDevice.Builder()
+                        .setUuid(UUID.fromString(j.getString("peer_id")))
+                        .build()
+        );
+        if (!j.isNull("uwb_params")) {
+            builder.setUwbRangingParams(getUwbParams(j.getJSONObject("uwb_params")));
+        }
+        if (!j.isNull("cs_params")) {
+            builder.setCsRangingParams(getCsParams(j.getJSONObject("cs_params")));
+        }
+        if (!j.isNull("rtt_params")) {
+            builder.setRttRangingParams(getRttParams(j.getJSONObject("rtt_params")));
+        }
+        if (!j.isNull("rssi_params")) {
+            builder.setBleRssiRangingParams(getBleRssiRangingParams(
+                    j.getJSONObject("rssi_params")));
+        }
+        return builder.build();
+    }
+
+    private UwbRangingParams getUwbParams(JSONObject j) throws JSONException {
+        UwbRangingParams.Builder builder = new UwbRangingParams.Builder(
+                j.getInt("session_id"),
+                j.getInt("config_id"),
+                UwbAddress.fromBytes(toBytes(j.getJSONArray("device_address"))),
+                UwbAddress.fromBytes(toBytes(j.getJSONArray("peer_address")))
+        );
+
+        builder.setSubSessionId(j.getInt("sub_session_id"))
+                .setSessionKeyInfo(toBytes(j.getJSONArray("session_key_info")))
+                .setComplexChannel(
+                        new UwbComplexChannel.Builder().setChannel(UWB_CHANNEL_9)
+                                .setPreambleIndex(UWB_PREAMBLE_CODE_INDEX_11).build())
+                .setRangingUpdateRate(j.getInt("ranging_update_rate"))
+                .setSlotDuration(j.getInt("slot_duration_ms"));
+
+        if (!j.isNull("sub_session_key_info")) {
+            builder.setSubSessionKeyInfo(toBytes(j.getJSONArray("sub_session_key_info")));
+        }
+        return builder.build();
+    }
+
+    private RttRangingParams getRttParams(JSONObject j) throws JSONException {
+        RttRangingParams.Builder builder = new RttRangingParams.Builder(
+                j.getString("service_name"));
+
+        return builder.setRangingUpdateRate(j.getInt("ranging_update_rate"))
+                .build();
+    }
+
+    private BleRssiRangingParams getBleRssiRangingParams(JSONObject j) throws JSONException {
+        return new BleRssiRangingParams.Builder(j.getString("peer_address"))
+                .setRangingUpdateRate(j.getInt("ranging_update_rate"))
+                .build();
+    }
+
+    private CsRangingParams getCsParams(JSONObject j) throws JSONException {
+        return new CsRangingParams.Builder(j.getString("peer_address"))
+                .setRangingUpdateRate(j.getInt("ranging_update_rate"))
+                .setSecurityLevel(j.getInt("security_level"))
+                .build();
+    }
+
+    private SensorFusionParams getSensorFusionParams(JSONObject j) throws JSONException {
+        return new SensorFusionParams.Builder()
+                .setSensorFusionEnabled(j.getBoolean("is_sensor_fusion_enabled"))
+                .build();
+    }
+
+    private DataNotificationConfig getDataNotificationConfig(boolean enableRangeDataNotifications) {
+        return new DataNotificationConfig.Builder()
+                .setNotificationConfigType(
+                        enableRangeDataNotifications
+                                ? DataNotificationConfig.ENABLE
+                                : DataNotificationConfig.DISABLE
+                )
+                .build();
+    }
+
+    private byte[] toBytes(JSONArray jArray) throws JSONException {
+        if (jArray == null) {
+            return null;
+        }
+        byte[] bArray = new byte[jArray.length()];
+        for (int i = 0; i < jArray.length(); i++) {
+            bArray[i] = (byte) jArray.getInt(i);
+        }
+        return bArray;
+    }
+}
diff --git a/ranging/tests/multidevices/snippet/RangingSnippet.java b/ranging/tests/multidevices/snippet/RangingSnippet.java
new file mode 100644
index 00000000..8b052300
--- /dev/null
+++ b/ranging/tests/multidevices/snippet/RangingSnippet.java
@@ -0,0 +1,233 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.snippet.ranging;
+
+import android.app.UiAutomation;
+import android.content.Context;
+import android.net.ConnectivityManager;
+import android.ranging.RangingCapabilities;
+import android.ranging.RangingData;
+import android.ranging.RangingDevice;
+import android.ranging.RangingManager;
+import android.ranging.RangingManager.RangingTechnology;
+import android.ranging.RangingPreference;
+import android.ranging.RangingSession;
+import android.util.Log;
+
+import androidx.annotation.NonNull;
+import androidx.test.platform.app.InstrumentationRegistry;
+
+import com.google.android.mobly.snippet.Snippet;
+import com.google.android.mobly.snippet.event.EventCache;
+import com.google.android.mobly.snippet.event.SnippetEvent;
+import com.google.android.mobly.snippet.rpc.AsyncRpc;
+import com.google.android.mobly.snippet.rpc.Rpc;
+
+import java.lang.reflect.Method;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+
+public class RangingSnippet implements Snippet {
+    private static final String TAG = "GenericRangingSnippet";
+
+    private final Context mContext;
+    private final RangingManager mRangingManager;
+    private final Executor mExecutor = Executors.newSingleThreadExecutor();
+    private final EventCache mEventCache = EventCache.getInstance();
+    private final ConnectivityManager mConnectivityManager;
+    private final ConcurrentMap<String, RangingSessionInfo> mSessions;
+    private final ConcurrentMap<Integer, Integer> mTechnologyAvailability;
+
+    public RangingSnippet() {
+        mContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
+        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
+        mRangingManager = mContext.getSystemService(RangingManager.class);
+
+        mSessions = new ConcurrentHashMap<>();
+        mTechnologyAvailability = new ConcurrentHashMap<>();
+        mRangingManager.registerCapabilitiesCallback(mExecutor, new AvailabilityListener());
+    }
+
+    private void adoptShellPermission() {
+        UiAutomation uia = InstrumentationRegistry.getInstrumentation().getUiAutomation();
+        uia.adoptShellPermissionIdentity();
+        try {
+            Class<?> cls = Class.forName("android.app.UiAutomation");
+            Method destroyMethod = cls.getDeclaredMethod("destroy");
+            destroyMethod.invoke(uia);
+        } catch (ReflectiveOperationException e) {
+            throw new IllegalStateException("Failed to cleanup ui automation", e);
+        }
+    }
+
+    private void dropShellPermission() throws Throwable {
+        UiAutomation uia = InstrumentationRegistry.getInstrumentation().getUiAutomation();
+        uia.dropShellPermissionIdentity();
+        try {
+            Class<?> cls = Class.forName("android.app.UiAutomation");
+            Method destroyMethod = cls.getDeclaredMethod("destroy");
+            destroyMethod.invoke(uia);
+        } catch (ReflectiveOperationException e) {
+            throw new IllegalStateException("Failed to cleanup ui automation", e);
+        }
+    }
+
+    private enum Event {
+        OPENED,
+        OPEN_FAILED,
+        STARTED,
+        DATA,
+        STOPPED,
+        CLOSED
+    }
+
+    private class RangingSessionCallback implements RangingSession.Callback {
+
+        private final String mCallbackId;
+
+        RangingSessionCallback(String callbackId) {
+            mCallbackId = callbackId;
+        }
+
+        @Override
+        public void onOpened() {
+            Log.d(TAG, "onOpened");
+            mEventCache.postEvent(new SnippetEvent(mCallbackId, Event.OPENED.toString()));
+        }
+
+        @Override
+        public void onOpenFailed(@Reason int reason) {
+            Log.d(TAG, "onOpenFailed");
+            mEventCache.postEvent(new SnippetEvent(mCallbackId, Event.OPEN_FAILED.toString()));
+        }
+
+        @Override
+        public void onStarted(@NonNull RangingDevice peer, @RangingTechnology int technology) {
+            Log.d(TAG, "onStarted");
+            SnippetEvent event = new SnippetEvent(mCallbackId, Event.STARTED.toString());
+            event.getData().putString("peer", peer.getUuid().toString());
+            event.getData().putInt("technology", technology);
+            mEventCache.postEvent(event);
+        }
+
+        @Override
+        public void onResults(@NonNull RangingDevice peer, @NonNull RangingData data) {
+            Log.d(TAG, "onData");
+            SnippetEvent event = new SnippetEvent(mCallbackId, Event.DATA.toString());
+            event.getData().putString("peer", peer.getUuid().toString());
+            event.getData().putInt("technology", data.getRangingTechnology());
+            mEventCache.postEvent(event);
+        }
+
+        @Override
+        public void onStopped(@NonNull RangingDevice peer, @RangingTechnology int technology) {
+            Log.d(TAG, "onStopped");
+            SnippetEvent event = new SnippetEvent(mCallbackId, Event.STOPPED.toString());
+            event.getData().putString("peer", peer.getUuid().toString());
+            event.getData().putInt("technology", technology);
+            mEventCache.postEvent(event);
+        }
+
+        @Override
+        public void onClosed(@Reason int reason) {
+            Log.d(TAG, "onClosed");
+            mEventCache.postEvent(new SnippetEvent(mCallbackId, Event.CLOSED.toString()));
+        }
+    }
+
+    private static class RangingSessionInfo {
+        private final RangingSession mSession;
+        private final RangingSessionCallback mCallback;
+
+        RangingSessionInfo(RangingSession session, RangingSessionCallback callback) {
+            mSession = session;
+            mCallback = callback;
+        }
+
+        public RangingSession getSession() {
+            return mSession;
+        }
+
+        public RangingSessionCallback getCallback() {
+            return mCallback;
+        }
+    }
+
+    private class AvailabilityListener implements RangingManager.RangingCapabilitiesCallback {
+        @Override
+        public void onRangingCapabilities(@NonNull RangingCapabilities capabilities) {
+            Map<Integer, Integer> availabilities = capabilities.getTechnologyAvailability();
+            mTechnologyAvailability.putAll(availabilities);
+        }
+    }
+
+
+    @AsyncRpc(description = "Start a ranging session")
+    public void startRanging(
+            String callbackId, String sessionHandle, RangingPreference preference
+    ) {
+        RangingSessionCallback callback = new RangingSessionCallback(callbackId);
+        RangingSession session = mRangingManager.createRangingSession(mExecutor, callback);
+        mSessions.put(sessionHandle, new RangingSessionInfo(session, callback));
+        session.start(preference);
+    }
+
+    @AsyncRpc(description = "Stop a ranging session")
+    public void stopRanging(String unused, String sessionHandle) {
+        RangingSessionInfo sessionInfo = mSessions.get(sessionHandle);
+        if (sessionInfo != null) {
+            sessionInfo.getSession().stop();
+            mSessions.remove(sessionHandle);
+        }
+    }
+
+    @Rpc(description = "Check whether the provided ranging technology is enabled")
+    public boolean isTechnologyEnabled(int technology) {
+        Integer availability = mTechnologyAvailability.get(technology);
+        return availability != null
+                && availability == RangingCapabilities.ENABLED;
+    }
+
+    @Rpc(description = "Check whether the provided ranging technology is supported")
+    public boolean isTechnologySupported(int technology) {
+        Integer availability = mTechnologyAvailability.get(technology);
+        return availability != null
+                && availability != RangingCapabilities.NOT_SUPPORTED;
+    }
+
+    @Rpc(description = "Set airplane mode")
+    public void setAirplaneMode(boolean enabled) throws Throwable {
+        runWithShellPermission(() -> mConnectivityManager.setAirplaneMode(enabled));
+    }
+
+    @Rpc(description = "Log info level message to device logcat")
+    public void logInfo(String message) {
+        Log.i(TAG, message);
+    }
+
+    public void runWithShellPermission(Runnable action) throws Throwable {
+        adoptShellPermission();
+        try {
+            action.run();
+        } finally {
+            dropShellPermission();
+        }
+    }
+}
diff --git a/generic_ranging/uwb_backend/Android.bp b/ranging/uwb_backend/Android.bp
similarity index 90%
rename from generic_ranging/uwb_backend/Android.bp
rename to ranging/uwb_backend/Android.bp
index e7ef3d7a..105f1666 100644
--- a/generic_ranging/uwb_backend/Android.bp
+++ b/ranging/uwb_backend/Android.bp
@@ -20,12 +20,11 @@ package {
 java_library {
     name: "ranging_uwb_backend",
     sdk_version: "system_UpsideDownCake",
-    min_sdk_version: "34",
+    min_sdk_version: "33",
     installable: false,
     srcs: [
         "src/**/*.java",
     ],
-    libs: ["android-support-annotations"],
     static_libs: [
         "androidx.annotation_annotation",
         "androidx.concurrent_concurrent-futures",
@@ -35,12 +34,13 @@ java_library {
         "guava",
     ],
     apex_available: [
+        "com.android.uwb",
         "com.android.tethering",
         "//apex_available:platform",
     ],
     visibility: [
         ":__subpackages__",
-        "//packages/modules/Uwb/generic_ranging:__subpackages__",
+        "//packages/modules/Uwb/ranging:__subpackages__",
         "//packages/modules/Connectivity/remoteauth:__subpackages__",
     ],
 }
diff --git a/generic_ranging/uwb_backend/AndroidManifest.xml b/ranging/uwb_backend/AndroidManifest.xml
similarity index 100%
rename from generic_ranging/uwb_backend/AndroidManifest.xml
rename to ranging/uwb_backend/AndroidManifest.xml
diff --git a/generic_ranging/uwb_backend/com.android.ranging.uwb.backend.xml b/ranging/uwb_backend/com.android.ranging.uwb.backend.xml
similarity index 100%
rename from generic_ranging/uwb_backend/com.android.ranging.uwb.backend.xml
rename to ranging/uwb_backend/com.android.ranging.uwb.backend.xml
diff --git a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/ConfigurationManager.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/ConfigurationManager.java
similarity index 73%
rename from generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/ConfigurationManager.java
rename to ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/ConfigurationManager.java
index 13cf3d36..097e07ec 100644
--- a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/ConfigurationManager.java
+++ b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/ConfigurationManager.java
@@ -16,18 +16,14 @@
 
 package com.android.ranging.uwb.backend.internal;
 
-import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_DL_TDOA_DT_TAG;
 import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_MULTICAST_DS_TWR;
-import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_MULTICAST_DS_TWR_NO_AOA;
 import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_PROVISIONED_INDIVIDUAL_MULTICAST_DS_TWR;
 import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_PROVISIONED_MULTICAST_DS_TWR;
 import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_PROVISIONED_UNICAST_DS_TWR;
-import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_AOA;
-import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_RESULT_REPORT_PHASE;
-import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_RESULT_REPORT_PHASE_HPRF;
+import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_PROVISIONED_UNICAST_DS_TWR_VERY_FAST;
 import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_UNICAST_DS_TWR;
-import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_UNICAST_DS_TWR_NO_AOA;
 import static com.android.ranging.uwb.backend.internal.Utils.STATIC_STS_SESSION_KEY_INFO_SIZE;
+import static com.android.ranging.uwb.backend.internal.Utils.SUPPORTED_HPRF_PREAMBLE_INDEX;
 import static com.android.ranging.uwb.backend.internal.Utils.VENDOR_ID_SIZE;
 import static com.android.ranging.uwb.backend.internal.Utils.getRangingTimingParams;
 
@@ -47,7 +43,6 @@ import static com.google.uwb.support.fira.FiraParams.RANGING_DEVICE_ROLE_RESPOND
 import static com.google.uwb.support.fira.FiraParams.RANGING_DEVICE_TYPE_CONTROLEE;
 import static com.google.uwb.support.fira.FiraParams.RANGING_DEVICE_TYPE_CONTROLLER;
 import static com.google.uwb.support.fira.FiraParams.RANGING_DEVICE_TYPE_DT_TAG;
-import static com.google.uwb.support.fira.FiraParams.RANGING_ROUND_USAGE_DL_TDOA;
 import static com.google.uwb.support.fira.FiraParams.RANGING_ROUND_USAGE_DS_TWR_DEFERRED_MODE;
 import static com.google.uwb.support.fira.FiraParams.RFRAME_CONFIG_SP1;
 import static com.google.uwb.support.fira.FiraParams.STS_CONFIG_PROVISIONED;
@@ -147,42 +142,6 @@ public final class ConfigurationManager {
                 });
 
         // ID_3 properties.
-        sConfigs.put(
-                CONFIG_UNICAST_DS_TWR_NO_AOA,
-                new UwbConfiguration() {
-
-                    @Override
-                    public int getConfigId() {
-                        return CONFIG_UNICAST_DS_TWR_NO_AOA;
-                    }
-
-                    @Override
-                    public int getMultiNodeMode() {
-                        return MULTI_NODE_MODE_UNICAST;
-                    }
-
-                    @Override
-                    public int getStsConfig() {
-                        return FiraParams.STS_CONFIG_STATIC;
-                    }
-
-                    @Override
-                    public int getAoaResultRequestMode() {
-                        return AOA_RESULT_REQUEST_MODE_NO_AOA_REPORT;
-                    }
-
-                    @Override
-                    public boolean isControllerTheInitiator() {
-                        return true;
-                    }
-
-                    @Override
-                    public int getRangingRoundUsage() {
-                        return RANGING_ROUND_USAGE_DS_TWR_DEFERRED_MODE;
-                    }
-                });
-
-        // ID_4 properties.
         sConfigs.put(
                 CONFIG_PROVISIONED_UNICAST_DS_TWR,
                 new UwbConfiguration() {
@@ -218,7 +177,7 @@ public final class ConfigurationManager {
                     }
                 });
 
-        // ID_5 properties.
+        // ID_4 properties.
         sConfigs.put(
                 CONFIG_PROVISIONED_MULTICAST_DS_TWR,
                 new UwbConfiguration() {
@@ -254,42 +213,7 @@ public final class ConfigurationManager {
                     }
                 });
 
-        // ID_6 properties.
-        sConfigs.put(
-                CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_AOA,
-                new UwbConfiguration() {
-                    @Override
-                    public int getConfigId() {
-                        return CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_AOA;
-                    }
-
-                    @Override
-                    public int getMultiNodeMode() {
-                        return MULTI_NODE_MODE_UNICAST;
-                    }
-
-                    @Override
-                    public int getStsConfig() {
-                        return STS_CONFIG_PROVISIONED;
-                    }
-
-                    @Override
-                    public int getAoaResultRequestMode() {
-                        return AOA_RESULT_REQUEST_MODE_NO_AOA_REPORT;
-                    }
-
-                    @Override
-                    public boolean isControllerTheInitiator() {
-                        return true;
-                    }
-
-                    @Override
-                    public int getRangingRoundUsage() {
-                        return RANGING_ROUND_USAGE_DS_TWR_DEFERRED_MODE;
-                    }
-                });
-
-        // ID_7 properties.
+        // ID_5 properties.
         sConfigs.put(
                 CONFIG_PROVISIONED_INDIVIDUAL_MULTICAST_DS_TWR,
                 new UwbConfiguration() {
@@ -325,122 +249,14 @@ public final class ConfigurationManager {
                     }
                 });
 
-        // ID_1001 properties.
-        sConfigs.put(
-                CONFIG_DL_TDOA_DT_TAG,
-                new UwbConfiguration() {
-
-                    @Override
-                    public int getConfigId() {
-                        return CONFIG_DL_TDOA_DT_TAG;
-                    }
-
-                    @Override
-                    public int getMultiNodeMode() {
-                        return MULTI_NODE_MODE_ONE_TO_MANY;
-                    }
-
-                    @Override
-                    public int getStsConfig() {
-                        return FiraParams.STS_CONFIG_STATIC;
-                    }
-
-                    @Override
-                    public int getAoaResultRequestMode() {
-                        return FiraParams.AOA_RESULT_REQUEST_MODE_REQ_AOA_RESULTS;
-                    }
-
-                    @Override
-                    public boolean isControllerTheInitiator() {
-                        return true;
-                    }
-
-                    @Override
-                    public int getRangingRoundUsage() {
-                        return RANGING_ROUND_USAGE_DL_TDOA;
-                    }
-                });
-
-        // ID_1000 properties.
-        sConfigs.put(
-                CONFIG_MULTICAST_DS_TWR_NO_AOA,
-                new UwbConfiguration() {
-
-                    @Override
-                    public int getConfigId() {
-                        return CONFIG_UNICAST_DS_TWR_NO_AOA;
-                    }
-
-                    @Override
-                    public int getMultiNodeMode() {
-                        return MULTI_NODE_MODE_ONE_TO_MANY;
-                    }
-
-                    @Override
-                    public int getStsConfig() {
-                        return FiraParams.STS_CONFIG_STATIC;
-                    }
-
-                    @Override
-                    public int getAoaResultRequestMode() {
-                        return AOA_RESULT_REQUEST_MODE_NO_AOA_REPORT;
-                    }
-
-                    @Override
-                    public boolean isControllerTheInitiator() {
-                        return true;
-                    }
-
-                    @Override
-                    public int getRangingRoundUsage() {
-                        return RANGING_ROUND_USAGE_DS_TWR_DEFERRED_MODE;
-                    }
-                });
-
-        // ID_1002 properties.
-        sConfigs.put(
-                CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_RESULT_REPORT_PHASE,
-                new UwbConfiguration() {
-
-                    @Override
-                    public int getConfigId() {
-                        return CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_RESULT_REPORT_PHASE;
-                    }
-
-                    @Override
-                    public int getMultiNodeMode() {
-                        return MULTI_NODE_MODE_UNICAST;
-                    }
-
-                    @Override
-                    public int getStsConfig() {
-                        return STS_CONFIG_PROVISIONED;
-                    }
-
-                    @Override
-                    public int getAoaResultRequestMode() {
-                        return FiraParams.AOA_RESULT_REQUEST_MODE_REQ_AOA_RESULTS;
-                    }
-
-                    @Override
-                    public boolean isControllerTheInitiator() {
-                        return true;
-                    }
-
-                    @Override
-                    public int getRangingRoundUsage() {
-                        return RANGING_ROUND_USAGE_DS_TWR_DEFERRED_MODE;
-                    }
-                });
-
-        // ID_1003 properties.
+        // ID_6 properties.
         sConfigs.put(
-                CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_RESULT_REPORT_PHASE_HPRF,
+                CONFIG_PROVISIONED_UNICAST_DS_TWR_VERY_FAST,
                 new UwbConfiguration() {
 
                     @Override
                     public int getConfigId() {
-                        return CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_RESULT_REPORT_PHASE_HPRF;
+                        return CONFIG_PROVISIONED_UNICAST_DS_TWR_VERY_FAST;
                     }
 
                     @Override
@@ -504,11 +320,6 @@ public final class ConfigurationManager {
                 break;
         }
 
-        // Remove this when we add support for ranging device type Dt-TAG.
-        if (configuration.getConfigId() == CONFIG_DL_TDOA_DT_TAG) {
-            deviceRole = RANGING_DEVICE_DT_TAG;
-        }
-
         FiraOpenSessionParams.Builder builder =
                 new FiraOpenSessionParams.Builder()
                         .setProtocolVersion(PROTOCOL_VERSION_1_1)
@@ -545,6 +356,7 @@ public final class ConfigurationManager {
                         .setInBandTerminationAttemptCount(3)
                         .setStsConfig(configuration.getStsConfig())
                         .setRangingErrorStreakTimeoutMs(10_000L)
+                        .setHasRangingResultReportMessage(false)
                         .setFilterType(FILTER_TYPE_NONE);
 
         if (configuration.getStsConfig() == FiraParams.STS_CONFIG_STATIC) {
@@ -583,18 +395,11 @@ public final class ConfigurationManager {
         } else {
             builder.setRframeConfig(RFRAME_CONFIG_SP1);
         }
-
-        if (configuration.getConfigId()
-                == CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_RESULT_REPORT_PHASE_HPRF) {
+        if (SUPPORTED_HPRF_PREAMBLE_INDEX.contains(rangingParameters.getComplexChannel()
+                .getPreambleIndex())) {
             builder.setPrfMode(PRF_MODE_HPRF);
         }
 
-        if (configuration.getConfigId() == CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_RESULT_REPORT_PHASE
-                || configuration.getConfigId()
-                    == CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_RESULT_REPORT_PHASE_HPRF) {
-            builder.setHasRangingResultReportMessage(false);
-        }
-
         return builder.build();
     }
 
diff --git a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/Conversions.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/Conversions.java
similarity index 92%
rename from generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/Conversions.java
rename to ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/Conversions.java
index 619a8829..d77c9216 100644
--- a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/Conversions.java
+++ b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/Conversions.java
@@ -29,6 +29,8 @@ import android.uwb.RangingSession;
 import androidx.annotation.Nullable;
 import androidx.annotation.RequiresApi;
 
+import com.google.uwb.support.fira.FiraOnControleeAddRemoveParams;
+
 import java.util.ArrayList;
 import java.util.List;
 
@@ -66,7 +68,8 @@ final class Conversions {
     static RangingPosition convertToPosition(android.uwb.RangingMeasurement measurement) {
         RangingMeasurement distance;
         DlTdoaMeasurement dlTdoaMeasurement = null;
-        if (isDlTdoaMeasurement(measurement)) {
+        if (Build.VERSION.SDK_INT >= VERSION_CODES.UPSIDE_DOWN_CAKE  &&
+                isDlTdoaMeasurement(measurement)) {
             com.google.uwb.support.dltdoa.DlTDoAMeasurement
                     dlTDoAMeasurement = com.google.uwb.support.dltdoa.DlTDoAMeasurement.fromBundle(
                     measurement.getRangingMeasurementMetadata());
@@ -144,7 +147,7 @@ final class Conversions {
     }
 
     @RangingSessionCallback.RangingSuspendedReason
-    static int convertReason(int reason) {
+    static int toRangingSuspendedReason(int reason) {
         if (reason == RangingSession.Callback.REASON_BAD_PARAMETERS) {
             return RangingSessionCallback.REASON_WRONG_PARAMETERS;
         }
@@ -172,6 +175,16 @@ final class Conversions {
         return RangingSessionCallback.REASON_UNKNOWN;
     }
 
+    @RangingSessionCallback.PeerDisconnectedReason
+    static int toPeerDisconnectedReason(@FiraOnControleeAddRemoveParams.Reason int reason) {
+        switch (reason) {
+            case FiraOnControleeAddRemoveParams.Reason.LOST_CONNECTION:
+                return RangingSessionCallback.PeerDisconnectedReason.SYSTEM_POLICY;
+            default:
+                return RangingSessionCallback.PeerDisconnectedReason.UNKNOWN;
+        }
+    }
+
     @UwbAvailabilityCallback.UwbStateChangeReason
     static int convertAdapterStateReason(int reason) {
         return switch (reason) {
diff --git a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/DlTdoaMeasurement.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/DlTdoaMeasurement.java
similarity index 100%
rename from generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/DlTdoaMeasurement.java
rename to ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/DlTdoaMeasurement.java
diff --git a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/Errors.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/Errors.java
similarity index 100%
rename from generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/Errors.java
rename to ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/Errors.java
diff --git a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/OpAsyncCallbackRunner.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/OpAsyncCallbackRunner.java
similarity index 100%
rename from generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/OpAsyncCallbackRunner.java
rename to ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/OpAsyncCallbackRunner.java
diff --git a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingCapabilities.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingCapabilities.java
similarity index 90%
rename from generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingCapabilities.java
rename to ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingCapabilities.java
index 2364f3cc..d5de477a 100644
--- a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingCapabilities.java
+++ b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingCapabilities.java
@@ -16,13 +16,10 @@
 
 package com.android.ranging.uwb.backend.internal;
 
-import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_DL_TDOA_DT_TAG;
 import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_MULTICAST_DS_TWR;
-import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_MULTICAST_DS_TWR_NO_AOA;
-import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_RESULT_REPORT_PHASE;
 import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_UNICAST_DS_TWR;
-import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_UNICAST_DS_TWR_NO_AOA;
 import static com.android.ranging.uwb.backend.internal.Utils.RANGE_DATA_NTF_ENABLE;
+import static com.android.ranging.uwb.backend.internal.Utils.SUPPORTED_BPRF_PREAMBLE_INDEX;
 
 import androidx.annotation.IntRange;
 
@@ -41,11 +38,7 @@ public class RangingCapabilities {
     public static final ImmutableList<Integer> FIRA_DEFAULT_SUPPORTED_CONFIG_IDS =
             ImmutableList.of(
                     CONFIG_UNICAST_DS_TWR,
-                    CONFIG_MULTICAST_DS_TWR,
-                    CONFIG_UNICAST_DS_TWR_NO_AOA,
-                    CONFIG_MULTICAST_DS_TWR_NO_AOA,
-                    CONFIG_DL_TDOA_DT_TAG,
-                    CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_RESULT_REPORT_PHASE);
+                    CONFIG_MULTICAST_DS_TWR);
     /** Ranging interval reconfigure is not supported if the system API doesn't provide. */
     public static final boolean DEFAULT_SUPPORTS_RANGING_INTERVAL_RECONFIGURE = false;
     /** Default supported slot duration if the system API doesn't provide it. */
@@ -66,6 +59,7 @@ public class RangingCapabilities {
     private final List<Integer> mSupportedConfigIds;
     private final List<Integer> mSupportedSlotDurations;
     private final List<Integer> mSupportedRangingUpdateRates;
+    private final List<Integer> mSupportedPreambleIndexes;
     private final boolean mHasBackgroundRangingSupport;
 
     public RangingCapabilities(
@@ -83,6 +77,7 @@ public class RangingCapabilities {
                 FIRA_DEFAULT_SUPPORTED_CONFIG_IDS,
                 DEFAULT_SUPPORTED_SLOT_DURATIONS,
                 DEFAULT_SUPPORTED_RANGING_UPDATE_RATE,
+                SUPPORTED_BPRF_PREAMBLE_INDEX,
                 false);
     }
 
@@ -97,6 +92,7 @@ public class RangingCapabilities {
             List<Integer> supportedConfigIds,
             ImmutableList<Integer> supportedSlotDurations,
             ImmutableList<Integer> supportedRangingUpdateRates,
+            ImmutableList<Integer> supportedPreambleIndexes,
             boolean hasBackgroundRangingSupport) {
         this.mSupportsDistance = supportsDistance;
         this.mSupportsAzimuthalAngle = supportsAzimuthalAngle;
@@ -108,6 +104,7 @@ public class RangingCapabilities {
         this.mSupportedConfigIds = supportedConfigIds;
         this.mSupportedSlotDurations = supportedSlotDurations;
         this.mSupportedRangingUpdateRates = supportedRangingUpdateRates;
+        this.mSupportedPreambleIndexes = supportedPreambleIndexes;
         this.mHasBackgroundRangingSupport = hasBackgroundRangingSupport;
     }
 
@@ -165,6 +162,9 @@ public class RangingCapabilities {
     public List<Integer> getSupportedRangingUpdateRates() {
         return mSupportedRangingUpdateRates;
     }
+    public List<Integer> getSupportedPreambleIndexes() {
+        return mSupportedPreambleIndexes;
+    }
 
     /** Whether background ranging is supported. */
     public boolean hasBackgroundRangingSupport() {
diff --git a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingControlee.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingControlee.java
similarity index 100%
rename from generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingControlee.java
rename to ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingControlee.java
diff --git a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingControleeParameters.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingControleeParameters.java
similarity index 100%
rename from generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingControleeParameters.java
rename to ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingControleeParameters.java
diff --git a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingController.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingController.java
similarity index 99%
rename from generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingController.java
rename to ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingController.java
index 8c226de9..c4638a3b 100644
--- a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingController.java
+++ b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingController.java
@@ -360,6 +360,11 @@ public class RangingController extends RangingDevice {
                         .toBundle());
     }
 
+    @Override
+    public synchronized void handlePeerDisconnected(UwbDevice peer) {
+        mDynamicallyAddedPeers.remove(peer.getAddress());
+    }
+
     /**
      * Reconfigures ranging interval for an ongoing session
      *
diff --git a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingDevice.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingDevice.java
similarity index 92%
rename from generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingDevice.java
rename to ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingDevice.java
index 0ecfdf67..9dd32411 100644
--- a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingDevice.java
+++ b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingDevice.java
@@ -45,6 +45,7 @@ import androidx.annotation.WorkerThread;
 
 import com.google.common.hash.Hashing;
 import com.google.uwb.support.dltdoa.DlTDoARangingRoundsUpdate;
+import com.google.uwb.support.fira.FiraOnControleeAddRemoveParams;
 import com.google.uwb.support.fira.FiraOpenSessionParams;
 import com.google.uwb.support.multichip.ChipInfoParams;
 
@@ -295,7 +296,7 @@ public abstract class RangingDevice {
             @Override
             public void onOpenFailed(int reason, PersistableBundle params) {
                 Log.i(TAG, String.format("Session open failed: reason %s", reason));
-                int suspendedReason = Conversions.convertReason(reason);
+                int suspendedReason = Conversions.toRangingSuspendedReason(reason);
                 if (suspendedReason == REASON_UNKNOWN) {
                     suspendedReason = REASON_FAILED_TO_START;
                 }
@@ -318,7 +319,7 @@ public abstract class RangingDevice {
             @Override
             public void onStartFailed(int reason, PersistableBundle params) {
 
-                int suspendedReason = Conversions.convertReason(reason);
+                int suspendedReason = Conversions.toRangingSuspendedReason(reason);
                 if (suspendedReason != REASON_WRONG_PARAMETERS) {
                     suspendedReason = REASON_FAILED_TO_START;
                 }
@@ -347,13 +348,16 @@ public abstract class RangingDevice {
             @WorkerThread
             @Override
             public void onStopped(int reason, PersistableBundle params) {
-                int suspendedReason = Conversions.convertReason(reason);
+                int suspendedReason = Conversions.toRangingSuspendedReason(reason);
                 UwbDevice device = getUwbDevice();
                 runOnBackendCallbackThread(
                         () -> {
                             mIsRanging.set(false);
                             callback.onRangingSuspended(device, suspendedReason);
                         });
+                if (mRangingSession != null) {
+                    mRangingSession.close();
+                }
                 if (suspendedReason == REASON_STOP_RANGING_CALLED
                         && mOpAsyncCallbackRunner.isActive()) {
                     mOpAsyncCallbackRunner.complete(true);
@@ -412,9 +416,24 @@ public abstract class RangingDevice {
             @WorkerThread
             @Override
             public void onControleeRemoved(PersistableBundle params) {
-                if (mOpAsyncCallbackRunner.isActive()) {
-                    mOpAsyncCallbackRunner.complete(true);
-                }
+                FiraOnControleeAddRemoveParams removalParams =
+                        FiraOnControleeAddRemoveParams.fromBundle(params);
+
+                runOnBackendCallbackThread(
+                        () -> {
+                            byte[] removedAddress = removalParams.getAddress().toBytes();
+                            UwbDevice removedDevice =
+                                    UwbDevice.createForAddress(
+                                            mUwbFeatureFlags.isReversedByteOrderFiraParams()
+                                                    ? Conversions.getReverseBytes(removedAddress)
+                                                    : removedAddress);
+
+                            handlePeerDisconnected(removedDevice);
+                            callback.onPeerDisconnected(
+                                    removedDevice, Conversions.toPeerDisconnectedReason(
+                                            removalParams.getReason()));
+                        });
+                mOpAsyncCallbackRunner.completeIfActive(true);
             }
 
             @WorkerThread
@@ -447,11 +466,7 @@ public abstract class RangingDevice {
     }
 
     private void printStartRangingParameters(PersistableBundle parameters) {
-        Log.i(TAG, "Opens UWB session with bundle parameters:");
-        for (String key : parameters.keySet()) {
-            Log.i(TAG, String.format(
-                    "UWB parameter: %s, value: %s", key, getString(parameters.get(key))));
-        }
+        Log.i(TAG, "Opens UWB session with bundle parameters: " + parameters.toString());
     }
 
     /**
@@ -499,7 +514,8 @@ public abstract class RangingDevice {
             return STATUS_OK;
         }
 
-        if (openSessionParams.getDeviceRole() == RANGING_DEVICE_DT_TAG) {
+        if (VERSION.SDK_INT >= VERSION_CODES.UPSIDE_DOWN_CAKE
+                && openSessionParams.getDeviceRole() == RANGING_DEVICE_DT_TAG) {
             // Setting default ranging rounds value.
             DlTDoARangingRoundsUpdate rangingRounds =
                     new DlTDoARangingRoundsUpdate.Builder()
@@ -600,13 +616,20 @@ public abstract class RangingDevice {
         return success && result != null && result;
     }
 
+    /**
+     * Called when a peer is disconnected from the ranging session.
+     *
+     * @param peer the peer that disconnected.
+     */
+    protected synchronized void handlePeerDisconnected(UwbDevice peer) {
+    }
 
     /**
      * Reconfigures range data notification for an ongoing session.
      *
      * @return STATUS_OK if reconfigure was successful.
-     *         UWB_RECONFIGURATION_FAILURE if reconfigure failed.
-     *         INVALID_API_CALL if ranging session is not active.
+     * UWB_RECONFIGURATION_FAILURE if reconfigure failed.
+     * INVALID_API_CALL if ranging session is not active.
      */
     public synchronized int reconfigureRangeDataNtfConfig(UwbRangeDataNtfConfig config) {
         if (!isAlive()) {
diff --git a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingMeasurement.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingMeasurement.java
similarity index 100%
rename from generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingMeasurement.java
rename to ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingMeasurement.java
diff --git a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingParameters.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingParameters.java
similarity index 100%
rename from generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingParameters.java
rename to ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingParameters.java
diff --git a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingPosition.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingPosition.java
similarity index 100%
rename from generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingPosition.java
rename to ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingPosition.java
diff --git a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingSessionCallback.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingSessionCallback.java
similarity index 81%
rename from generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingSessionCallback.java
rename to ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingSessionCallback.java
index 1152092d..2934b08c 100644
--- a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingSessionCallback.java
+++ b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingSessionCallback.java
@@ -30,6 +30,9 @@ public interface RangingSessionCallback {
     /** Callback when a session has been suspended. */
     void onRangingSuspended(UwbDevice device, @RangingSuspendedReason int reason);
 
+    /** Callback when a peer disconnects from the session. */
+    void onPeerDisconnected(UwbDevice peer, @PeerDisconnectedReason int reason);
+
     /** Reason why ranging was stopped. */
     @IntDef({
             REASON_UNKNOWN,
@@ -50,4 +53,14 @@ public interface RangingSessionCallback {
     int REASON_STOP_RANGING_CALLED = 4;
     int REASON_MAX_RANGING_ROUND_RETRY_REACHED = 5;
     int REASON_SYSTEM_POLICY = 6;
+
+    /** Reason why peer disconnected. */
+    @IntDef({
+            PeerDisconnectedReason.UNKNOWN,
+            PeerDisconnectedReason.SYSTEM_POLICY,
+    })
+    @interface PeerDisconnectedReason {
+        int UNKNOWN = 0;
+        int SYSTEM_POLICY = 1;
+    }
 }
diff --git a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingTimingParams.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingTimingParams.java
similarity index 100%
rename from generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingTimingParams.java
rename to ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/RangingTimingParams.java
diff --git a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/Utils.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/Utils.java
similarity index 75%
rename from generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/Utils.java
rename to ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/Utils.java
index af65c7df..a3ce196f 100644
--- a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/Utils.java
+++ b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/Utils.java
@@ -39,15 +39,10 @@ public final class Utils {
     @IntDef({
         CONFIG_UNICAST_DS_TWR,
         CONFIG_MULTICAST_DS_TWR,
-        CONFIG_UNICAST_DS_TWR_NO_AOA,
         CONFIG_PROVISIONED_UNICAST_DS_TWR,
         CONFIG_PROVISIONED_MULTICAST_DS_TWR,
-        CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_AOA,
         CONFIG_PROVISIONED_INDIVIDUAL_MULTICAST_DS_TWR,
-        CONFIG_MULTICAST_DS_TWR_NO_AOA,
-        CONFIG_DL_TDOA_DT_TAG,
-        CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_RESULT_REPORT_PHASE,
-        CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_RESULT_REPORT_PHASE_HPRF
+            CONFIG_PROVISIONED_UNICAST_DS_TWR_VERY_FAST,
     })
     public @interface UwbConfigId {}
 
@@ -61,35 +56,18 @@ public final class Utils {
 
     public static final int CONFIG_MULTICAST_DS_TWR = 2;
 
-    /** Same as {@code CONFIG_ID_1}, except Angle-of-arrival (AoA) data is not reported. */
-    public static final int CONFIG_UNICAST_DS_TWR_NO_AOA = 3;
-
     /** Same as {@code CONFIG_ID_1}, except P-STS security mode is enabled. */
-    public static final int CONFIG_PROVISIONED_UNICAST_DS_TWR = 4;
+    public static final int CONFIG_PROVISIONED_UNICAST_DS_TWR = 3;
 
     /** Same as {@code CONFIG_ID_2}, except P-STS security mode is enabled. */
-    public static final int CONFIG_PROVISIONED_MULTICAST_DS_TWR = 5;
-
-    /** Same as {@code CONFIG_ID_3}, except P-STS security mode is enabled. */
-    public static final int CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_AOA = 6;
+    public static final int CONFIG_PROVISIONED_MULTICAST_DS_TWR = 4;
 
     /** Same as {@code CONFIG_ID_2}, except P-STS individual controlee key mode is enabled. */
-    public static final int CONFIG_PROVISIONED_INDIVIDUAL_MULTICAST_DS_TWR = 7;
+    public static final int CONFIG_PROVISIONED_INDIVIDUAL_MULTICAST_DS_TWR = 5;
 
-    /** Same as {@code CONFIG_ID_3}, except not unicast @Hide */
-    public static final int CONFIG_MULTICAST_DS_TWR_NO_AOA = 1000;
+    /** Same as {@code CONFIG_ID_3}, except fast ranging interval is 96 milliseconds. */
+    public static final int CONFIG_PROVISIONED_UNICAST_DS_TWR_VERY_FAST = 6;
 
-    /** FiRa- defined Downlink-TDoA for DT-Tag ranging */
-    public static final int CONFIG_DL_TDOA_DT_TAG = 1001;
-
-    /**
-     * Same as {@code CONFIG_ID_4}, except result report phase is disabled, fast ranging interval 96
-     * ms, filtering disabled, @Hide
-     */
-    public static final int CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_RESULT_REPORT_PHASE = 1002;
-
-    /** Same as {@code CONFIG_ID_1002}, except PRF mode is HPRF, @Hide */
-    public static final int CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_RESULT_REPORT_PHASE_HPRF = 1003;
 
     @IntDef({
         INFREQUENT,
@@ -261,17 +239,6 @@ public final class Utils {
                         /* initiationTimeMs= */ 0,
                         /* hoppingEnabled= */ true));
 
-        setRangingTimingParams(
-                CONFIG_UNICAST_DS_TWR_NO_AOA,
-                new RangingTimingParams(
-                        /* rangingIntervalNormal= */ 200,
-                        /* rangingIntervalFast= */ 120,
-                        /* rangingIntervalInfrequent= */600,
-                        /* slotPerRangingRound= */ 20,
-                        /* slotDurationRstu= */ 2400,
-                        /* initiationTimeMs= */ 0,
-                        /* hoppingEnabled= */ true));
-
         setRangingTimingParams(
                 CONFIG_PROVISIONED_UNICAST_DS_TWR,
                 new RangingTimingParams(
@@ -294,17 +261,6 @@ public final class Utils {
                         /* initiationTimeMs= */ 0,
                         /* hoppingEnabled= */ true));
 
-        setRangingTimingParams(
-                CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_AOA,
-                new RangingTimingParams(
-                        /* rangingIntervalNormal= */ 200,
-                        /* rangingIntervalFast= */ 120,
-                        /* rangingIntervalInfrequent= */ 600,
-                        /* slotPerRangingRound= */ 20,
-                        /* slotDurationRstu= */ 2400,
-                        /* initiationTimeMs= */ 0,
-                        /* hoppingEnabled= */ true));
-
         setRangingTimingParams(
                 CONFIG_PROVISIONED_INDIVIDUAL_MULTICAST_DS_TWR,
                 new RangingTimingParams(
@@ -317,40 +273,7 @@ public final class Utils {
                         /* hoppingEnabled= */ true));
 
         setRangingTimingParams(
-                CONFIG_DL_TDOA_DT_TAG,
-                new RangingTimingParams(
-                        /* rangingIntervalNormal= */ 200,
-                        /* rangingIntervalFast= */ 120,
-                        /* rangingIntervalInfrequent= */ 600,
-                        /* slotPerRangingRound= */ 20,
-                        /* slotDurationRstu= */ 2400,
-                        /* initiationTimeMs= */ 0,
-                        /* hoppingEnabled= */ true));
-
-        setRangingTimingParams(
-                CONFIG_MULTICAST_DS_TWR_NO_AOA,
-                new RangingTimingParams(
-                        /* rangingIntervalNormal= */ 200,
-                        /* rangingIntervalFast= */ 120,
-                        /* rangingIntervalInfrequent= */ 600,
-                        /* slotPerRangingRound= */ 20,
-                        /* slotDurationRstu= */ 2400,
-                        /* initiationTimeMs= */ 0,
-                        /* hoppingEnabled= */ true));
-
-        setRangingTimingParams(
-                CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_RESULT_REPORT_PHASE,
-                new RangingTimingParams(
-                        /* rangingIntervalNormal= */ 240,
-                        /* rangingIntervalFast= */ 96,
-                        /* rangingIntervalInfrequent= */ 600,
-                        /* slotPerRangingRound= */ 6,
-                        /* slotDurationRstu= */ 2400,
-                        /* initiationTimeMs= */ 0,
-                        /* hoppingEnabled= */ true));
-
-        setRangingTimingParams(
-                CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_RESULT_REPORT_PHASE_HPRF,
+                CONFIG_PROVISIONED_UNICAST_DS_TWR_VERY_FAST,
                 new RangingTimingParams(
                         /* rangingIntervalNormal= */ 240,
                         /* rangingIntervalFast= */ 96,
diff --git a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbAddress.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbAddress.java
similarity index 100%
rename from generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbAddress.java
rename to ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbAddress.java
diff --git a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbAvailabilityCallback.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbAvailabilityCallback.java
similarity index 100%
rename from generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbAvailabilityCallback.java
rename to ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbAvailabilityCallback.java
diff --git a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbComplexChannel.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbComplexChannel.java
similarity index 100%
rename from generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbComplexChannel.java
rename to ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbComplexChannel.java
diff --git a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbConfiguration.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbConfiguration.java
similarity index 100%
rename from generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbConfiguration.java
rename to ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbConfiguration.java
diff --git a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbDevice.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbDevice.java
similarity index 100%
rename from generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbDevice.java
rename to ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbDevice.java
diff --git a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbFeatureFlags.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbFeatureFlags.java
similarity index 100%
rename from generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbFeatureFlags.java
rename to ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbFeatureFlags.java
diff --git a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbRangeDataNtfConfig.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbRangeDataNtfConfig.java
similarity index 100%
rename from generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbRangeDataNtfConfig.java
rename to ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbRangeDataNtfConfig.java
diff --git a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbServiceImpl.java b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbServiceImpl.java
similarity index 88%
rename from generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbServiceImpl.java
rename to ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbServiceImpl.java
index b53f90b4..96dd027c 100644
--- a/generic_ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbServiceImpl.java
+++ b/ranging/uwb_backend/src/com/android/ranging/uwb/backend/internal/UwbServiceImpl.java
@@ -22,17 +22,18 @@ import static android.uwb.UwbManager.AdapterStateCallback.STATE_DISABLED;
 import static com.android.ranging.uwb.backend.internal.RangingCapabilities.DEFAULT_SUPPORTED_RANGING_UPDATE_RATE;
 import static com.android.ranging.uwb.backend.internal.RangingCapabilities.DEFAULT_SUPPORTED_SLOT_DURATIONS;
 import static com.android.ranging.uwb.backend.internal.RangingCapabilities.FIRA_DEFAULT_SUPPORTED_CONFIG_IDS;
-import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_DL_TDOA_DT_TAG;
 import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_PROVISIONED_INDIVIDUAL_MULTICAST_DS_TWR;
 import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_PROVISIONED_MULTICAST_DS_TWR;
 import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_PROVISIONED_UNICAST_DS_TWR;
-import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_AOA;
-import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_RESULT_REPORT_PHASE_HPRF;
+import static com.android.ranging.uwb.backend.internal.Utils.CONFIG_PROVISIONED_UNICAST_DS_TWR_VERY_FAST;
 import static com.android.ranging.uwb.backend.internal.Utils.RANGE_DATA_NTF_ENABLE;
+import static com.android.ranging.uwb.backend.internal.Utils.SUPPORTED_BPRF_PREAMBLE_INDEX;
+import static com.android.ranging.uwb.backend.internal.Utils.SUPPORTED_HPRF_PREAMBLE_INDEX;
 import static com.android.ranging.uwb.backend.internal.UwbAvailabilityCallback.REASON_UNKNOWN;
 
 import static java.util.Objects.requireNonNull;
 
+import android.annotation.SuppressLint;
 import android.content.Context;
 import android.os.Build.VERSION;
 import android.os.Build.VERSION_CODES;
@@ -53,6 +54,7 @@ import java.util.EnumSet;
 import java.util.List;
 import java.util.Set;
 import java.util.TreeSet;
+import java.util.concurrent.Executor;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 
@@ -70,6 +72,7 @@ public class UwbServiceImpl {
     @NonNull
     private final UwbAvailabilityCallback mUwbAvailabilityCallback;
 
+    public static final UwbFeatureFlags FEATURE_FLAGS = new UwbFeatureFlags.Builder().build();
 
     /** A serial thread used to handle session callback */
     private final ExecutorService mSerialExecutor = Executors.newSingleThreadExecutor();
@@ -112,19 +115,17 @@ public class UwbServiceImpl {
     }
 
     /** Gets a Ranging Controller session with given context. */
-    public RangingController getController(Context context) {
+    public static RangingController getController(Context context, Executor executor) {
         UwbManager uwbManagerWithContext = context.getSystemService(UwbManager.class);
-        return new RangingController(
-                uwbManagerWithContext, mSerialExecutor, new OpAsyncCallbackRunner<>(),
-                mUwbFeatureFlags);
+        return new RangingController(uwbManagerWithContext, executor,
+                new OpAsyncCallbackRunner<>(), FEATURE_FLAGS);
     }
 
     /** Gets a Ranging Controlee session with given context. */
-    public RangingControlee getControlee(Context context) {
+    public static RangingControlee getControlee(Context context, Executor executor) {
         UwbManager uwbManagerWithContext = context.getSystemService(UwbManager.class);
-        return new RangingControlee(
-                uwbManagerWithContext, mSerialExecutor, new OpAsyncCallbackRunner<>(),
-                mUwbFeatureFlags);
+        return new RangingControlee(uwbManagerWithContext, executor,
+                new OpAsyncCallbackRunner<>(), FEATURE_FLAGS);
     }
 
     /** Returns multi-chip information. */
@@ -164,12 +165,17 @@ public class UwbServiceImpl {
     }
 
     /** Gets ranging capabilities of the device. */
+    @SuppressLint("NewApi")
     public RangingCapabilities getRangingCapabilities() {
         requireNonNull(mUwbManager);
         requireNonNull(mUwbFeatureFlags);
 
-        if (mUwbFeatureFlags.skipRangingCapabilitiesCheck()
-                && VERSION.SDK_INT < VERSION_CODES.TIRAMISU) {
+        PersistableBundle bundle = new PersistableBundle();
+        if (!mUwbFeatureFlags.skipRangingCapabilitiesCheck()
+                || VERSION.SDK_INT >= VERSION_CODES.TIRAMISU) {
+            bundle = mUwbManager.getSpecificationInfo();
+        }
+        if (bundle.isEmpty()) {
             return new RangingCapabilities(
                     /* supportsDistance= */ true,
                     mUwbFeatureFlags.hasAzimuthSupport(),
@@ -181,10 +187,10 @@ public class UwbServiceImpl {
                     FIRA_DEFAULT_SUPPORTED_CONFIG_IDS,
                     DEFAULT_SUPPORTED_SLOT_DURATIONS,
                     DEFAULT_SUPPORTED_RANGING_UPDATE_RATE,
+                    SUPPORTED_BPRF_PREAMBLE_INDEX,
                     /* hasBackgroundRangingSupport */ false);
         }
 
-        PersistableBundle bundle = mUwbManager.getSpecificationInfo();
         if (bundle.keySet().contains(FIRA_SPECIFICATION_BUNDLE_KEY)) {
             bundle = requireNonNull(bundle.getPersistableBundle(FIRA_SPECIFICATION_BUNDLE_KEY));
         }
@@ -219,22 +225,22 @@ public class UwbServiceImpl {
         if (stsCapabilityFlags.contains(FiraParams.StsCapabilityFlag.HAS_PROVISIONED_STS_SUPPORT)) {
             supportedConfigIds.add(CONFIG_PROVISIONED_UNICAST_DS_TWR);
             supportedConfigIds.add(CONFIG_PROVISIONED_MULTICAST_DS_TWR);
-            supportedConfigIds.add(CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_AOA);
         }
         if (stsCapabilityFlags.contains(FiraParams.StsCapabilityFlag
                 .HAS_PROVISIONED_STS_INDIVIDUAL_CONTROLEE_KEY_SUPPORT)) {
             supportedConfigIds.add(CONFIG_PROVISIONED_INDIVIDUAL_MULTICAST_DS_TWR);
         }
+        if (minRangingInterval <= 96) {
+            supportedConfigIds.add(CONFIG_PROVISIONED_UNICAST_DS_TWR_VERY_FAST);
+        }
         EnumSet<FiraParams.RangingRoundCapabilityFlag> rangingRoundCapabilityFlags =
                 specificationParams.getRangingRoundCapabilities();
-        if (rangingRoundCapabilityFlags.contains(FiraParams.RangingRoundCapabilityFlag
-                .HAS_OWR_DL_TDOA_SUPPORT)) {
-            supportedConfigIds.add(CONFIG_DL_TDOA_DT_TAG);
-        }
         EnumSet<FiraParams.PrfCapabilityFlag> prfModeCapabilityFlags =
                 specificationParams.getPrfCapabilities();
+
+        List<Integer> supportedPreambleIndexes = new ArrayList<>(SUPPORTED_BPRF_PREAMBLE_INDEX);
         if (prfModeCapabilityFlags.contains(FiraParams.PrfCapabilityFlag.HAS_HPRF_SUPPORT)) {
-            supportedConfigIds.add(CONFIG_PROVISIONED_UNICAST_DS_TWR_NO_RESULT_REPORT_PHASE_HPRF);
+            supportedPreambleIndexes.addAll(SUPPORTED_HPRF_PREAMBLE_INDEX);
         }
         int minSlotDurationUs = specificationParams.getMinSlotDurationUs();
         List<Integer> supportedSlotDurations = new ArrayList<>(Arrays.asList(Utils.DURATION_2_MS));
@@ -253,6 +259,7 @@ public class UwbServiceImpl {
                 ImmutableList.copyOf(supportedConfigIds),
                 ImmutableList.copyOf(supportedSlotDurations),
                 ImmutableList.copyOf(supportedRangingUpdateRates),
+                ImmutableList.copyOf(supportedPreambleIndexes),
                 specificationParams.hasBackgroundRangingSupport()
         );
     }
diff --git a/generic_ranging/uwb_backend/tests/Android.bp b/ranging/uwb_backend/tests/Android.bp
similarity index 100%
rename from generic_ranging/uwb_backend/tests/Android.bp
rename to ranging/uwb_backend/tests/Android.bp
diff --git a/generic_ranging/uwb_backend/tests/AndroidManifest.xml b/ranging/uwb_backend/tests/AndroidManifest.xml
similarity index 100%
rename from generic_ranging/uwb_backend/tests/AndroidManifest.xml
rename to ranging/uwb_backend/tests/AndroidManifest.xml
diff --git a/generic_ranging/uwb_backend/tests/AndroidTest.xml b/ranging/uwb_backend/tests/AndroidTest.xml
similarity index 100%
rename from generic_ranging/uwb_backend/tests/AndroidTest.xml
rename to ranging/uwb_backend/tests/AndroidTest.xml
diff --git a/generic_ranging/uwb_backend/tests/src/com/android/ranging/uwb/backend/internal/ConfigurationManagerTest.java b/ranging/uwb_backend/tests/src/com/android/ranging/uwb/backend/internal/ConfigurationManagerTest.java
similarity index 100%
rename from generic_ranging/uwb_backend/tests/src/com/android/ranging/uwb/backend/internal/ConfigurationManagerTest.java
rename to ranging/uwb_backend/tests/src/com/android/ranging/uwb/backend/internal/ConfigurationManagerTest.java
diff --git a/generic_ranging/uwb_backend/tests/src/com/android/ranging/uwb/backend/internal/RangingControleeTest.java b/ranging/uwb_backend/tests/src/com/android/ranging/uwb/backend/internal/RangingControleeTest.java
similarity index 100%
rename from generic_ranging/uwb_backend/tests/src/com/android/ranging/uwb/backend/internal/RangingControleeTest.java
rename to ranging/uwb_backend/tests/src/com/android/ranging/uwb/backend/internal/RangingControleeTest.java
diff --git a/generic_ranging/uwb_backend/tests/src/com/android/ranging/uwb/backend/internal/RangingControllerTest.java b/ranging/uwb_backend/tests/src/com/android/ranging/uwb/backend/internal/RangingControllerTest.java
similarity index 100%
rename from generic_ranging/uwb_backend/tests/src/com/android/ranging/uwb/backend/internal/RangingControllerTest.java
rename to ranging/uwb_backend/tests/src/com/android/ranging/uwb/backend/internal/RangingControllerTest.java
diff --git a/service/Android.bp b/service/Android.bp
index 3b715391..e6abd5e0 100644
--- a/service/Android.bp
+++ b/service/Android.bp
@@ -67,6 +67,7 @@ java_library {
         "com.uwb.support.oemextension",
         "com.uwb.support.dltdoa",
         "com.uwb.support.radar",
+        "com.uwb.support.rftest",
         "com.uwb.fusion",
         "guava",
         "modules-utils-shell-command-handler",
diff --git a/service/ServiceUwbResources/Android.bp b/service/ServiceUwbResources/Android.bp
index 238a23e4..d3b8ba62 100644
--- a/service/ServiceUwbResources/Android.bp
+++ b/service/ServiceUwbResources/Android.bp
@@ -34,6 +34,7 @@ android_app {
         "com.android.uwb",
     ],
     certificate: ":com.android.uwb.resources.certificate",
+    updatable: true,
 }
 
 android_app_certificate {
diff --git a/service/ServiceUwbResources/res/values/config.xml b/service/ServiceUwbResources/res/values/config.xml
index 9925fa8b..49ff69d8 100644
--- a/service/ServiceUwbResources/res/values/config.xml
+++ b/service/ServiceUwbResources/res/values/config.xml
@@ -232,4 +232,17 @@
     <!-- Whether or not the antenna operation mode shall be configured by the ANTENNA_MODE vendor
     config param. If false, the FiRa-specified AOA_RESULT_REQ param is used instead. -->
     <bool name = "is_antenna_mode_config_supported">false</bool>
+
+    <!-- List of MCC/MNC where OEM default country code is used as an override.
+    This is a array of MCC/MNC values, where each value is a 3-digit string (only MCC)
+    or a 5/6-digit string (MCC + MNC). -->
+    <string-array name="mcc_mcc_oem_override_list"/>
+
+    <!-- Whether two-byte ccc config id is supported. If true, the config id should be parsed as
+    a two byte little endian value. -->
+    <bool name = "ccc_two_byte_config_id_little_endian_supported">false</bool>
+
+    <!-- Whether when hopmode doesn't set, the hopmodekey shall be set randomly.
+    If false, never sets hopmodekey randomly-->
+    <bool name = "enable_random_hopmodekey">false</bool>
 </resources>
diff --git a/service/ServiceUwbResources/res/values/overlayable.xml b/service/ServiceUwbResources/res/values/overlayable.xml
index b44f405f..b662004f 100644
--- a/service/ServiceUwbResources/res/values/overlayable.xml
+++ b/service/ServiceUwbResources/res/values/overlayable.xml
@@ -57,6 +57,9 @@
             <item name="is_multicast_list_update_ntf_v2_supported" type="bool" />
             <item name="is_multicast_list_update_rsp_v2_supported" type="bool" />
             <item name="is_antenna_mode_config_supported" type="bool" />
+            <item name="mcc_mcc_oem_override_list" type="array" />
+            <item name="ccc_two_byte_config_id_little_endian_supported" type="bool" />
+            <item name="enable_random_hopmodekey" type="bool" />
           <!-- Params from config.xml that can be overlaid -->
 
           <!-- Params from strings.xml that can be overlaid -->
diff --git a/service/fusion_lib/Android.bp b/service/fusion_lib/Android.bp
index e4496236..dbcd7ae3 100644
--- a/service/fusion_lib/Android.bp
+++ b/service/fusion_lib/Android.bp
@@ -32,7 +32,7 @@ java_library {
     ],
     visibility: [
         "//packages/modules/Uwb/service:__subpackages__",
-        "//packages/modules/Uwb/generic_ranging:__subpackages__",
+        "//packages/modules/Uwb/ranging:__subpackages__",
     ],
     apex_available: [
         "com.android.uwb",
diff --git a/service/java/com/android/server/uwb/DeviceConfigFacade.java b/service/java/com/android/server/uwb/DeviceConfigFacade.java
index 6320a283..8b8871de 100644
--- a/service/java/com/android/server/uwb/DeviceConfigFacade.java
+++ b/service/java/com/android/server/uwb/DeviceConfigFacade.java
@@ -103,6 +103,8 @@ public class DeviceConfigFacade {
     private boolean mHwIdleTurnOffEnabled;
     private boolean mFusedCountryCodeProviderEnabled;
     private boolean mIsAntennaModeConfigSupported;
+    private String[] mMccMncOemOverrideList;
+    private boolean mIsRandomHopmodekeySupported;
 
     public DeviceConfigFacade(Handler handler, Context context) {
         mContext = context;
@@ -328,6 +330,13 @@ public class DeviceConfigFacade {
                 mContext.getResources().getBoolean(R.bool.is_antenna_mode_config_supported)
         );
 
+        // device config override with array is not supported, so just read the resource.
+        mMccMncOemOverrideList = mContext.getResources()
+                .getStringArray(R.array.mcc_mcc_oem_override_list);
+
+        mIsRandomHopmodekeySupported = mContext.getResources()
+                .getBoolean(R.bool.enable_random_hopmodekey);
+
         // A little parsing and cleanup:
         mFrontAzimuthRadiansPerSecond = (float) Math.toRadians(frontAzimuthDegreesPerSecond);
         mBackAzimuthRadiansPerSecond = (float) Math.toRadians(backAzimuthDegreesPerSecond);
@@ -644,4 +653,19 @@ public class DeviceConfigFacade {
      * Returns whether antenna mode configuration is supported or not.
      */
     public boolean isAntennaModeConfigSupported() { return mIsAntennaModeConfigSupported; }
+
+    /**
+     * Returns array of mcc/mnc where oem override country code should be used.
+     * Empty array means no override.
+     */
+    public String[] getMccMncOemOverrideList() {
+        return mMccMncOemOverrideList;
+    }
+
+     /**
+     * Returns whether random hopmodekey is supported or not.
+     */
+    public boolean isRandomHopmodekeySupported() {
+        return mIsRandomHopmodekeySupported;
+    }
 }
diff --git a/service/java/com/android/server/uwb/UwbConfigurationManager.java b/service/java/com/android/server/uwb/UwbConfigurationManager.java
index fe7076cb..d09efbd0 100644
--- a/service/java/com/android/server/uwb/UwbConfigurationManager.java
+++ b/service/java/com/android/server/uwb/UwbConfigurationManager.java
@@ -22,6 +22,7 @@ import com.android.server.uwb.data.UwbConfigStatusData;
 import com.android.server.uwb.data.UwbTlvData;
 import com.android.server.uwb.data.UwbUciConstants;
 import com.android.server.uwb.jni.NativeUwbManager;
+import com.android.server.uwb.params.RfTestEncoder;
 import com.android.server.uwb.params.TlvBuffer;
 import com.android.server.uwb.params.TlvDecoder;
 import com.android.server.uwb.params.TlvDecoderBuffer;
@@ -85,6 +86,39 @@ public class UwbConfigurationManager {
         return status;
     }
 
+    /**
+     * Set RF test app configurations.
+     */
+    public int setRfTestAppConfigurations(int sessionId, Params params, String chipId) {
+        int status = UwbUciConstants.STATUS_CODE_FAILED;
+        Log.d(TAG, "setRfTestAppConfigurations");
+        RfTestEncoder encoder = (RfTestEncoder) TlvEncoder.getEncoder(
+                params.getProtocolName(), mUwbInjector);
+        if (encoder == null) {
+            Log.d(TAG, "unsupported encoder protocol type");
+            return status;
+        }
+        TlvBuffer tlvBuffer = encoder.getRfTestTlvBuffer(params);
+
+        if (tlvBuffer.getNoOfParams() != 0) {
+            byte[] tlvByteArray = tlvBuffer.getByteArray();
+            UwbConfigStatusData appConfig = mNativeUwbManager.setRfTestAppConfigurations(sessionId,
+                    tlvBuffer.getNoOfParams(),
+                    tlvByteArray.length, tlvByteArray, chipId);
+            if (appConfig != null) {
+                Log.i(TAG, "setRfTestAppConfigurations respData: " + appConfig);
+                status = appConfig.getStatus();
+            } else {
+                Log.e(TAG, "appConfigList is null or size of appConfigList is zero");
+                status = UwbUciConstants.STATUS_CODE_FAILED;
+            }
+        } else {
+            Log.e(TAG, "tlvBuffer is empty");
+            status = UwbUciConstants.STATUS_CODE_FAILED;
+        }
+        return status;
+    }
+
     /**
      * Retrieve app configurations from UWBS.
      */
diff --git a/service/java/com/android/server/uwb/UwbCountryCode.java b/service/java/com/android/server/uwb/UwbCountryCode.java
index 165e594f..abe3fce6 100644
--- a/service/java/com/android/server/uwb/UwbCountryCode.java
+++ b/service/java/com/android/server/uwb/UwbCountryCode.java
@@ -56,6 +56,7 @@ import java.io.PrintWriter;
 import java.nio.charset.StandardCharsets;
 import java.time.LocalDateTime;
 import java.time.format.DateTimeFormatter;
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
@@ -131,6 +132,8 @@ public class UwbCountryCode {
     private String mCountryCodeUpdatedTimestamp = null;
     private String mWifiCountryTimestamp = null;
     private String mLocationCountryTimestamp = null;
+    private boolean mIsMccMncOemOverrideEnabled = false;
+    private final List<MccMnc> mMccMncOemOverrideList = new ArrayList<>();
 
     /**
      * Container class to store country code per sim slot.
@@ -189,6 +192,80 @@ public class UwbCountryCode {
         }
     }
 
+    private class MccMnc {
+        private final int mMcc;
+        private final int mMnc;
+        MccMnc(int mcc, int mnc) {
+            mMcc = mcc;
+            mMnc = mnc;
+        }
+        public int getMcc() {
+            return mMcc;
+        }
+        public int getMnc() {
+            return mMnc;
+        }
+    }
+
+    private void generateOemOverrideMccMncList() {
+        String[] mccMncOemOverrideList =
+            mUwbInjector.getDeviceConfigFacade().getMccMncOemOverrideList();
+        if (mccMncOemOverrideList == null) return;
+        for (String mccMnc : mccMncOemOverrideList) {
+            int mcc = -1;
+            int mnc = -1;
+            try {
+                mcc = Integer.valueOf(mccMnc.substring(0, 3));
+            } catch (Exception e) {
+                Log.e(TAG, "No mcc set", e);
+                continue;
+            }
+            try {
+                mnc = Integer.valueOf(mccMnc.substring(3));
+            } catch (Exception e) {
+                Log.d(TAG, "No mnc set", e);
+            }
+            mMccMncOemOverrideList.add(new MccMnc(mcc, mnc));
+        }
+    }
+
+    private boolean shouldOverrideCountryCodeForMccMncs() {
+        List<SubscriptionInfo> subscriptionInfoList =
+                mSubscriptionManager.getCompleteActiveSubscriptionInfoList();
+        if (subscriptionInfoList != null && !subscriptionInfoList.isEmpty()) {
+            for (SubscriptionInfo subscriptionInfo : subscriptionInfoList) {
+                if (shouldOverrideCountryCodeForMccMnc(
+                        subscriptionInfo.getMccString(), subscriptionInfo.getMncString())) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    private boolean shouldOverrideCountryCodeForMccMnc(String mccString, String mncString) {
+        if (TextUtils.isEmpty(mccString) || TextUtils.isEmpty(mncString)) return false;
+        try {
+            int mcc = Integer.valueOf(mccString);
+            int mnc = Integer.valueOf(mncString);
+            for (MccMnc mccMnc: mMccMncOemOverrideList) {
+                if (mccMnc.getMcc() == mcc) {
+                    if (mccMnc.getMnc() == -1) {
+                        Log.i(TAG, "Override MCC meets " + mccMnc.getMcc());
+                        return true;
+                    } else if (mccMnc.getMnc() == mnc) {
+                        Log.i(TAG, "Override MCC MNC meets "
+                                + mccMnc.getMcc() + ":" + mccMnc.getMnc());
+                        return true;
+                    }
+                }
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "failed in shouldOverrideCountryCodeForMccMnc", e);
+        }
+        return false;
+    }
+
     private void setCountryCodeFromGeocodingLocation(@Nullable Location location) {
         if (location == null) return;
         Geocoder.GeocodeListener geocodeListener = (List<Address> addresses) -> {
@@ -220,24 +297,44 @@ public class UwbCountryCode {
                     UwbSettingsStore.SETTINGS_CACHED_COUNTRY_CODE);
             if (isValid(cachedCountryCode)) mCachedCountryCode = cachedCountryCode;
         }
+        IntentFilter filter = new IntentFilter(TelephonyManager.ACTION_NETWORK_COUNTRY_CHANGED);
+        generateOemOverrideMccMncList();
+        if (!mMccMncOemOverrideList.isEmpty()) {
+            filter.addAction(TelephonyManager.ACTION_SIM_CARD_STATE_CHANGED);
+        }
         mContext.registerReceiver(
                 new BroadcastReceiver() {
                     @Override
                     public void onReceive(Context context, Intent intent) {
-                        int slotIdx = intent.getIntExtra(
-                                SubscriptionManager.EXTRA_SLOT_INDEX,
-                                LAST_SIM_SLOT_INDEX);
-                        String countryCode = intent.getStringExtra(
-                                TelephonyManager.EXTRA_NETWORK_COUNTRY);
-                        String lastKnownCountryCode = intent.getStringExtra(
-                                EXTRA_LAST_KNOWN_NETWORK_COUNTRY);
-                        Log.d(TAG, "Telephony Country code changed to: " + countryCode);
-                        setTelephonyCountryCodeAndLastKnownCountryCode(
-                                slotIdx, countryCode, lastKnownCountryCode);
+                        if (intent.getAction()
+                                .equals(TelephonyManager.ACTION_NETWORK_COUNTRY_CHANGED)) {
+                            int slotIdx = intent.getIntExtra(
+                                    SubscriptionManager.EXTRA_SLOT_INDEX,
+                                    LAST_SIM_SLOT_INDEX);
+                            String countryCode = intent.getStringExtra(
+                                    TelephonyManager.EXTRA_NETWORK_COUNTRY);
+                            String lastKnownCountryCode = intent.getStringExtra(
+                                    EXTRA_LAST_KNOWN_NETWORK_COUNTRY);
+                            Log.d(TAG, "Telephony Country code changed to: " + countryCode);
+                            setTelephonyCountryCodeAndLastKnownCountryCode(
+                                    slotIdx, countryCode, lastKnownCountryCode);
+                        } else if (intent.getAction()
+                                .equals(TelephonyManager.ACTION_SIM_CARD_STATE_CHANGED)) {
+                            if (!mMccMncOemOverrideList.isEmpty()) {
+                                boolean shouldOverrideCountryCodeForMccMnc =
+                                        shouldOverrideCountryCodeForMccMncs();
+                                if (mIsMccMncOemOverrideEnabled
+                                        != shouldOverrideCountryCodeForMccMnc) {
+                                    Log.i(TAG, "OEM override for mcc mnc changed");
+                                    mIsMccMncOemOverrideEnabled =
+                                            shouldOverrideCountryCodeForMccMnc;
+                                    setCountryCode(true);
+                                }
+                            }
+                        }
                     }
                 },
-                new IntentFilter(TelephonyManager.ACTION_NETWORK_COUNTRY_CHANGED),
-                null, mHandler);
+                filter, null, mHandler);
         try {
             if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI)) {
                 mContext.getSystemService(WifiManager.class)
@@ -449,6 +546,9 @@ public class UwbCountryCode {
         if (mOverrideCountryCode != null) {
             return mOverrideCountryCode;
         }
+        if (mIsMccMncOemOverrideEnabled) {
+            return mUwbInjector.getOemDefaultCountryCode();
+        }
         if (mTelephonyCountryCodeInfoPerSlot != null) {
             for (TelephonyCountryCodeSlotInfo telephonyCountryCodeInfoSlot :
                     mTelephonyCountryCodeInfoPerSlot.values()) {
diff --git a/service/java/com/android/server/uwb/UwbInjector.java b/service/java/com/android/server/uwb/UwbInjector.java
index 7a4baf16..3654d7aa 100644
--- a/service/java/com/android/server/uwb/UwbInjector.java
+++ b/service/java/com/android/server/uwb/UwbInjector.java
@@ -510,6 +510,12 @@ public class UwbInjector {
                         com.android.uwb.resources.R.bool.is_multicast_list_update_rsp_v2_supported);
     }
 
+    public boolean isCccSupportedTwoByteConfigIdLittleEndian() {
+        return mContext.getResources().getBoolean(
+                com.android.uwb.resources.R.bool.ccc_two_byte_config_id_little_endian_supported
+        );
+    }
+
     /**
      * Gets the configured pose source, which is reference counted. If there are no references
      * to the pose source, one will be created based on the device configuration. This may
diff --git a/service/java/com/android/server/uwb/UwbServiceCore.java b/service/java/com/android/server/uwb/UwbServiceCore.java
index 2b667f94..a8db6f6c 100644
--- a/service/java/com/android/server/uwb/UwbServiceCore.java
+++ b/service/java/com/android/server/uwb/UwbServiceCore.java
@@ -81,6 +81,9 @@ import com.google.uwb.support.oemextension.DeviceStatus;
 import com.google.uwb.support.profile.UuidBundleWrapper;
 import com.google.uwb.support.radar.RadarOpenSessionParams;
 import com.google.uwb.support.radar.RadarParams;
+import com.google.uwb.support.rftest.RfTestOpenSessionParams;
+import com.google.uwb.support.rftest.RfTestParams;
+import com.google.uwb.support.rftest.RfTestStartSessionParams;
 
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
@@ -89,6 +92,7 @@ import java.util.Map;
 import java.util.NoSuchElementException;
 import java.util.Objects;
 import java.util.Optional;
+import java.util.Random;
 import java.util.Set;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.FutureTask;
@@ -675,6 +679,15 @@ public class UwbServiceCore implements INativeUwbManager.DeviceNotification,
                     firaOpenSessionParams, rangingCallbacks, chipId);
         } else if (CccParams.isCorrectProtocol(params)) {
             CccOpenRangingParams cccOpenRangingParams = CccOpenRangingParams.fromBundle(params);
+            CccOpenRangingParams.Builder builder =
+                    new CccOpenRangingParams.Builder(CccOpenRangingParams.fromBundle(params));
+            if (mUwbInjector.getDeviceConfigFacade().isRandomHopmodekeySupported()
+                    && cccOpenRangingParams.getHoppingConfigMode()
+                            != CccParams.HOPPING_CONFIG_MODE_NONE
+                    && cccOpenRangingParams.getHopModeKey() == CccParams.HOP_MODE_KEY_UNSET) {
+                builder.setHopModeKey(new Random().nextInt());
+            }
+            cccOpenRangingParams = builder.build();
             sessionId = cccOpenRangingParams.getSessionId();
             sessionType = cccOpenRangingParams.getSessionType();
             mSessionManager.initSession(attributionSource, sessionHandle, sessionId,
@@ -683,6 +696,15 @@ public class UwbServiceCore implements INativeUwbManager.DeviceNotification,
         } else if (AliroParams.isCorrectProtocol(params)) {
             AliroOpenRangingParams aliroOpenRangingParams =
                     AliroOpenRangingParams.fromBundle(params);
+            AliroOpenRangingParams.Builder builder =
+                    new AliroOpenRangingParams.Builder(AliroOpenRangingParams.fromBundle(params));
+            if (mUwbInjector.getDeviceConfigFacade().isRandomHopmodekeySupported()
+                    && aliroOpenRangingParams.getHoppingConfigMode()
+                            != CccParams.HOPPING_CONFIG_MODE_NONE
+                    && aliroOpenRangingParams.getHopModeKey() == CccParams.HOP_MODE_KEY_UNSET) {
+                builder.setHopModeKey(new Random().nextInt());
+            }
+            aliroOpenRangingParams = builder.build();
             sessionId = aliroOpenRangingParams.getSessionId();
             sessionType = aliroOpenRangingParams.getSessionType();
             mSessionManager.initSession(attributionSource, sessionHandle, sessionId,
@@ -696,6 +718,14 @@ public class UwbServiceCore implements INativeUwbManager.DeviceNotification,
             mSessionManager.initSession(attributionSource, sessionHandle, sessionId,
                     (byte) sessionType, radarOpenSessionParams.getProtocolName(),
                     radarOpenSessionParams, rangingCallbacks, chipId);
+        } else if (RfTestParams.isCorrectProtocol(params)) {
+            RfTestOpenSessionParams rfTestOpenSessionParams =
+                    RfTestOpenSessionParams.fromBundle(params);
+            sessionId = rfTestOpenSessionParams.getSessionId();
+            sessionType = rfTestOpenSessionParams.getSessionType();
+            mSessionManager.initSession(attributionSource, sessionHandle, sessionId,
+                    (byte) sessionType, rfTestOpenSessionParams.getProtocolName(),
+                    rfTestOpenSessionParams, rangingCallbacks, chipId);
         } else {
             Log.e(TAG, "openRanging - Wrong parameters");
             try {
@@ -715,6 +745,8 @@ public class UwbServiceCore implements INativeUwbManager.DeviceNotification,
             startRangingParams = CccStartRangingParams.fromBundle(params);
         } else if (AliroParams.isCorrectProtocol(params)) {
             startRangingParams = AliroStartRangingParams.fromBundle(params);
+        } else if (RfTestParams.isCorrectProtocol(params)) {
+            startRangingParams = RfTestStartSessionParams.fromBundle(params);
         }
 
         if (mUwbInjector.getProfileManager().hasSession(sessionHandle)) {
@@ -1068,7 +1100,6 @@ public class UwbServiceCore implements INativeUwbManager.DeviceNotification,
                     break;
 
                 case TASK_DISABLE:
-                    mSessionManager.deinitAllSession();
                     handleDisable();
                     break;
 
@@ -1081,7 +1112,6 @@ public class UwbServiceCore implements INativeUwbManager.DeviceNotification,
                     break;
 
                 case TASK_RESTART:
-                    mSessionManager.deinitAllSession();
                     handleDisable();
                     handleEnable();
                     break;
@@ -1211,7 +1241,7 @@ public class UwbServiceCore implements INativeUwbManager.DeviceNotification,
                 synchronized (mUwbWakeLock) {
                     mUwbWakeLock.acquire();
                 }
-
+                mSessionManager.deInitAllSession();
                 if (!mNativeUwbManager.doDeinitialize()) {
                     Log.w(TAG, "Error disabling UWB");
                     mUwbMetrics.logUwbStateChangeEvent(false, false, false);
diff --git a/service/java/com/android/server/uwb/UwbSessionManager.java b/service/java/com/android/server/uwb/UwbSessionManager.java
index ba145b0c..eda3feb6 100644
--- a/service/java/com/android/server/uwb/UwbSessionManager.java
+++ b/service/java/com/android/server/uwb/UwbSessionManager.java
@@ -76,6 +76,7 @@ import com.android.server.uwb.jni.INativeUwbManager;
 import com.android.server.uwb.jni.NativeUwbManager;
 import com.android.server.uwb.params.TlvUtil;
 import com.android.server.uwb.proto.UwbStatsLog;
+import com.android.server.uwb.rftest.RfNotificationEvent;
 import com.android.server.uwb.util.ArrayUtils;
 import com.android.server.uwb.util.DataTypeConversionUtil;
 import com.android.server.uwb.util.LruList;
@@ -115,6 +116,9 @@ import com.google.uwb.support.generic.GenericSpecificationParams;
 import com.google.uwb.support.oemextension.AdvertisePointedTarget;
 import com.google.uwb.support.oemextension.SessionConfigParams;
 import com.google.uwb.support.oemextension.SessionStatus;
+import com.google.uwb.support.rftest.RfTestParams;
+import com.google.uwb.support.rftest.RfTestSessionStatus;
+import com.google.uwb.support.rftest.RfTestStartSessionParams;
 
 import java.io.Closeable;
 import java.io.FileDescriptor;
@@ -172,6 +176,10 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
     public static final int SESSION_SET_HUS_CONTROLEE_CONFIG = 10;
     @VisibleForTesting
     public static final int SESSION_DATA_TRANSFER_PHASE_CONFIG = 11;
+    @VisibleForTesting
+    public static final int SESSION_RF_TEST_CMD = 12;
+    @VisibleForTesting
+    public static final int SESSION_STOP_RF_TEST_SESSION = 13;
 
     // TODO: don't expose the internal field for testing.
     @VisibleForTesting
@@ -534,6 +542,17 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
         }
     }
 
+    @Override
+    public void onRfTestNotificationReceived(RfNotificationEvent rfNotificationEvent) {
+        UwbSession uwbSession = getUwbSession(RfTestParams.SESSION_ID_RFTEST);
+        if (uwbSession == null) {
+            Log.d(TAG, "UwbSession doesn't exist for SESSION_ID_RFTEST");
+            return;
+        }
+
+        mSessionNotificationManager.onRfTestNotificationReceived(uwbSession, rfNotificationEvent);
+    }
+
     @Override
     public void onSessionStatusNotificationReceived(long sessionId, int sessionToken,
             int state, int reasonCode) {
@@ -623,6 +642,13 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
         int status = mConfigurationManager.setAppConfigurations(uwbSession.getSessionId(),
                 uwbSession.getParams(), uwbSession.getChipId(),
                 getUwbsFiraProtocolVersion(uwbSession.getChipId()));
+
+        if (status == UwbUciConstants.STATUS_CODE_OK
+                && uwbSession.getProtocolName().equals(RfTestParams.PROTOCOL_NAME)) {
+            status = mConfigurationManager.setRfTestAppConfigurations(uwbSession.getSessionId(),
+                    uwbSession.getParams(), uwbSession.getChipId());
+        }
+
         if (status == UwbUciConstants.STATUS_CODE_OK
                 && mUwbInjector.getUwbServiceCore().isOemExtensionCbRegistered()) {
             try {
@@ -703,6 +729,12 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
             maxSessionsExceeded = !tryMakeSpaceForFiraSession(
                     uwbSession.getStackSessionPriority());
         }
+
+        if (!maxSessionsExceeded && getSessionCount() >= getMaxSupportedSessionCount(chipId)) {
+            maxSessionsExceeded = true;
+            Log.i(TAG, "Session count exceeds max supported Session count");
+        }
+
         if (maxSessionsExceeded) {
             rangingCallbacks.onRangingOpenFailed(sessionHandle,
                     RangingChangeReason.MAX_SESSIONS_REACHED,
@@ -823,6 +855,12 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
             } else if (uwbSession.getProtocolName().equals(FiraParams.PROTOCOL_NAME)) {
                 // Need to update session priority if it changed.
                 uwbSession.updateFiraParamsOnStartIfChanged();
+            } else if (uwbSession.getProtocolName().equals(RfTestParams.PROTOCOL_NAME)) {
+                if (params instanceof RfTestStartSessionParams) {
+                    uwbSession.setRfTestStartSessionParams((RfTestStartSessionParams) params);
+                    mEventTask.execute(SESSION_RF_TEST_CMD, uwbSession);
+                }
+                return;
             }
             mEventTask.execute(SESSION_START_RANGING, uwbSession);
         } else if (currentSessionState == UwbUciConstants.UWB_SESSION_STATE_ACTIVE) {
@@ -837,6 +875,95 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
         }
     }
 
+    private void handleRfTestCommand(UwbSession uwbSession) {
+        RfTestStartSessionParams params = uwbSession.getRfTestStartSessionParams();
+        // create task to send RF command
+        FutureTask<Integer> rfCommandTask = new FutureTask<>((Callable<Integer>) () -> {
+            int rfTestOperationType = params.getRfTestOperationType();
+            int status = UwbUciConstants.STATUS_CODE_FAILED;
+
+            synchronized (uwbSession.getWaitObj()) {
+                switch (rfTestOperationType) {
+                    case RfTestParams.TEST_PERIODIC_TX:
+                        status = mNativeUwbManager.testPeriodicTx(params.getPsduData(),
+                                uwbSession.getChipId());
+                        break;
+                    default:
+                        Log.i(TAG, "Unknown RF command: " + rfTestOperationType);
+                }
+
+                if (status != UwbUciConstants.STATUS_CODE_OK) {
+                    mSessionNotificationManager.onRangingStartFailed(uwbSession, status);
+                } else {
+                    uwbSession.getWaitObj().blockingWait();
+
+                    RfTestSessionStatus rfTestSessionStatus = new RfTestSessionStatus.Builder()
+                            .setRfTestOperationType(rfTestOperationType)
+                            .setStatusCode(status).build();
+                    mSessionNotificationManager.onRangingStarted(uwbSession,
+                            rfTestSessionStatus);
+                }
+            }
+            return status;
+        });
+
+        // Execute task
+        int status = UwbUciConstants.STATUS_CODE_FAILED;
+
+        try {
+            status = mUwbInjector.runTaskOnSingleThreadExecutor(rfCommandTask,
+                    IUwbAdapter.RF_TEST_OPERATION_THRESHOLD_MS);
+        } catch (TimeoutException e) {
+            Log.i(TAG, "Failed to send RF command: TIMEOUT");
+            mSessionNotificationManager.onRangingStartFailed(uwbSession, status);
+        } catch (InterruptedException | ExecutionException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private void handleStopRfTest(UwbSession uwbSession) {
+        Trace.beginSection("UWB#handleStopRfTest");
+        FutureTask<Integer> stopRfSessionTask = new FutureTask<>(
+                () -> {
+                    int status = UwbUciConstants.STATUS_CODE_FAILED;
+                    synchronized (uwbSession.getWaitObj()) {
+                        status = mNativeUwbManager.stopRfTest(uwbSession.getChipId());
+                        if (status != UwbUciConstants.STATUS_CODE_OK) {
+                            mSessionNotificationManager.onRangingStopFailed(uwbSession,
+                                    status);
+                            return status;
+                        }
+
+                        uwbSession.getWaitObj().blockingWait();
+                        // After stop rf test session command, UWBS will go to IDLE state
+                        if (uwbSession.getSessionState()
+                                == UwbUciConstants.UWB_SESSION_STATE_IDLE) {
+                            mSessionNotificationManager.onRangingStopped(uwbSession,
+                                    status);
+                        } else {
+                            status = UwbUciConstants.STATUS_CODE_FAILED;
+                            mSessionNotificationManager.onRangingStopFailed(uwbSession,
+                                    status);
+                        }
+                    }
+                    return status;
+                });
+
+
+        int status = UwbUciConstants.STATUS_CODE_FAILED;
+        try {
+            status = mUwbInjector.runTaskOnSingleThreadExecutor(stopRfSessionTask,
+                    IUwbAdapter.RF_TEST_OPERATION_THRESHOLD_MS);
+        } catch (TimeoutException e) {
+            Log.i(TAG, "Failed to Stop RF test - status : TIMEOUT");
+            mSessionNotificationManager.onRangingStopFailed(
+                    uwbSession, UwbUciConstants.STATUS_CODE_FAILED);
+        } catch (InterruptedException | ExecutionException e) {
+            e.printStackTrace();
+        }
+        Trace.endSection();
+    }
+
     private synchronized void stopRangingInternal(SessionHandle sessionHandle,
             boolean triggeredBySystemPolicy) {
         if (!isExistedSession(sessionHandle)) {
@@ -850,6 +977,24 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
 
         UwbSession uwbSession = getUwbSession(sessionId);
         int currentSessionState = getCurrentSessionState(sessionId);
+
+        //RF Test session
+        if (uwbSession.getProtocolName().equals(RfTestParams.PROTOCOL_NAME)) {
+            if (sessionId != RfTestParams.SESSION_ID_RFTEST) {
+                mSessionNotificationManager.onRangingStopped(uwbSession,
+                        UwbUciConstants.STATUS_CODE_REJECTED);
+            }
+
+            if (currentSessionState == UwbUciConstants.UWB_SESSION_STATE_ACTIVE) {
+                mEventTask.execute(SESSION_STOP_RF_TEST_SESSION, uwbSession);
+            } else {
+                mSessionNotificationManager.onRangingStopped(uwbSession,
+                        UwbUciConstants.STATUS_CODE_REJECTED);
+                Log.i(TAG, "RF session is not in ACTIVE state");
+            }
+            return;
+        }
+
         if (currentSessionState == UwbUciConstants.UWB_SESSION_STATE_ACTIVE) {
             mEventTask.execute(SESSION_STOP_RANGING, uwbSession, triggeredBySystemPolicy ? 1 : 0);
         } else if (currentSessionState == UwbUciConstants.UWB_SESSION_STATE_IDLE) {
@@ -1007,7 +1152,7 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
         }
     }
 
-    public synchronized void deinitAllSession() {
+    public synchronized void deInitAllSession() {
         Log.d(TAG, "deinitAllSession()");
         for (UwbSession uwbSession : mSessionTable.values()) {
             handleOnDeInit(uwbSession);
@@ -1105,6 +1250,15 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
         }
     }
 
+    /** Returns max supported session count possible on given chip. */
+    public long getMaxSupportedSessionCount(String chipId) {
+        GenericSpecificationParams params =
+                mUwbInjector.getUwbServiceCore().getCachedSpecificationParams(chipId);
+        return (params != null)
+                ? params.getMaxSupportedSessionCount()
+                : getMaxFiraSessionsNumber(chipId) + getMaxCccSessionsNumber(chipId);
+    }
+
     /** Gets the session with the lowest session priority among all sessions with given protocol. */
     public Optional<UwbSession> getSessionWithLowestPriorityByProtocol(String protocolName) {
         return mSessionTable.values().stream().filter(
@@ -1878,6 +2032,20 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
                     break;
                 }
 
+                case SESSION_RF_TEST_CMD: {
+                    Log.d(TAG, "SESSION_RF_TEST_CMD");
+                    UwbSession uwbSession = (UwbSession) msg.obj;
+                    handleRfTestCommand(uwbSession);
+                    break;
+                }
+
+                case SESSION_STOP_RF_TEST_SESSION: {
+                    Log.d(TAG, "SESSION_STOP_RF_TEST_SESSION");
+                    UwbSession uwbSession = (UwbSession) msg.obj;
+                    handleStopRfTest(uwbSession);
+                    break;
+                }
+
                 default: {
                     Log.d(TAG, "EventTask : Undefined Task");
                     break;
@@ -2535,7 +2703,7 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
                                 sendDataInfo.params);
                         return sendDataStatus;
                     }
-                    if (!isValidSendDataInfo(sendDataInfo)) {
+                    if (!isValidSendDataInfo(sendDataInfo, uwbSession.getChipId())) {
                         sendDataStatus = UwbUciConstants.STATUS_CODE_INVALID_PARAM;
                         mSessionNotificationManager.onDataSendFailed(
                                 uwbSession, sendDataInfo.remoteDeviceAddress, sendDataStatus,
@@ -2605,12 +2773,19 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
         return uwbSession != null && uwbSession.getSessionState() == UWB_SESSION_STATE_ACTIVE;
     }
 
-    private boolean isValidSendDataInfo(SendDataInfo sendDataInfo) {
-        if (sendDataInfo.data == null) {
-            return false;
-        }
+    /** Returns max length of data message possible on a given chip */
+    private int getMaxMessageSize(String chipId) {
+        GenericSpecificationParams params =
+                mUwbInjector.getUwbServiceCore().getCachedSpecificationParams(chipId);
+
+        return (params != null && params.getFiraSpecificationParams() != null)
+                ? params.getFiraSpecificationParams().getMaxMessageSize()
+                : 0;
+    }
 
-        if (sendDataInfo.remoteDeviceAddress == null) {
+    private boolean isValidSendDataInfo(SendDataInfo sendDataInfo, String chipId) {
+        if (sendDataInfo == null || sendDataInfo.data == null
+                || sendDataInfo.remoteDeviceAddress == null) {
             return false;
         }
 
@@ -2618,6 +2793,21 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
                 > UwbUciConstants.UWB_DEVICE_EXT_MAC_ADDRESS_LEN) {
             return false;
         }
+
+        final int fixedLength = FiraParams.SESSION_HANDLE_LEN
+                                + UwbUciConstants.UWB_DEVICE_EXT_MAC_ADDRESS_LEN
+                                + FiraParams.SEQUENCE_NUMBER_LENGTH
+                                + FiraParams.DATA_MSG_LENGTH;
+
+        int sendDataInfoLength = fixedLength + sendDataInfo.data.length;
+        int maxMessageSize = getMaxMessageSize(chipId);
+        if (sendDataInfoLength > maxMessageSize) {
+            Log.e(TAG, "SendDataInfo length:" + sendDataInfoLength
+                    + " exceeds max supported message size:" + maxMessageSize + " for chipId: "
+                    + chipId);
+            return false;
+        }
+
         return true;
     }
 
@@ -2728,6 +2918,9 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
         // Keeps track of all controlees in the session.
         public Map<UwbAddress, UwbControlee> mControlees;
 
+        // Keep track of RF Test start session params
+        private RfTestStartSessionParams mRfTestStartSessionParams = null;
+
         UwbSession(AttributionSource attributionSource, SessionHandle sessionHandle, int sessionId,
                 byte sessionType, String protocolName, Params params,
                 IUwbRangingCallbacks iUwbRangingCallbacks, String chipId) {
@@ -2990,7 +3183,8 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
          * @return The matching {@link UwbControlee}, or null if not found.
          */
         public UwbControlee getControlee(UwbAddress address) {
-            if (mControlees.isEmpty()) {
+            if (mControlees == null || mControlees.isEmpty()) {
+                Log.d(TAG, "Controlee list is null or empty");
                 return null;
             }
             UwbControlee result = mControlees.get(address);
@@ -3352,6 +3546,14 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
             this.mSessionState = state;
         }
 
+        public RfTestStartSessionParams getRfTestStartSessionParams() {
+            return this.mRfTestStartSessionParams;
+        }
+
+        public void setRfTestStartSessionParams(RfTestStartSessionParams params) {
+            this.mRfTestStartSessionParams = params;
+        }
+
         public int getStackSessionPriority() {
             return this.mStackSessionPriority;
         }
@@ -3444,7 +3646,11 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
                     Log.w(TAG, "Continuous errors or no ranging results detected for "
                             + mRangingErrorStreakTimeoutMs + " ms."
                             + " Stopping session");
-                    stopRangingInternal(mSessionHandle, true /* triggeredBySystemPolicy */);
+                    if (getSessionState() == UwbUciConstants.UWB_SESSION_STATE_ACTIVE) {
+                        stopRangingInternal(mSessionHandle, true /* triggeredBySystemPolicy */);
+                    } else {
+                        Log.i(TAG, "Session is not in an active state");
+                    }
                 };
                 Log.v(TAG, "Starting error timer for "
                         + mRangingErrorStreakTimeoutMs + " ms.");
@@ -3499,7 +3705,11 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
                         + address + " for " + mRangingErrorStreakTimeoutMs + " ms.");
                 if (mControlees.size() == 1) {
                     Log.w(TAG, "No active controlees, stopping session");
-                    stopRangingInternal(mSessionHandle, true /* triggeredBySystemPolicy */);
+                    if (getSessionState() == UwbUciConstants.UWB_SESSION_STATE_ACTIVE) {
+                        stopRangingInternal(mSessionHandle, true /* triggeredBySystemPolicy */);
+                    } else {
+                        Log.i(TAG, "Session is not in an active state");
+                    }
                 } else {
                     removeControleeDueToErrorStreakTimeout(address);
                 }
@@ -3542,7 +3752,11 @@ public class UwbSessionManager implements INativeUwbManager.SessionNotification,
                 mNonPrivilegedBgAppTimerListener = () -> {
                     Log.w(TAG, "Non-privileged app in background for longer than timeout - "
                             + " Stopping session");
-                    stopRangingInternal(mSessionHandle, true /* triggeredBySystemPolicy */);
+                    if (getSessionState() == UwbUciConstants.UWB_SESSION_STATE_ACTIVE) {
+                        stopRangingInternal(mSessionHandle, true /* triggeredBySystemPolicy */);
+                    } else {
+                        Log.i(TAG, "Session is not in an active state");
+                    }
                 };
                 mAlarmManager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP,
                         mUwbInjector.getElapsedSinceBootMillis()
diff --git a/service/java/com/android/server/uwb/UwbSessionNotificationHelper.java b/service/java/com/android/server/uwb/UwbSessionNotificationHelper.java
index 13ce1e2b..ea339730 100644
--- a/service/java/com/android/server/uwb/UwbSessionNotificationHelper.java
+++ b/service/java/com/android/server/uwb/UwbSessionNotificationHelper.java
@@ -39,6 +39,7 @@ public class UwbSessionNotificationHelper {
                 rangingChangeReason = RangingChangeReason.MAX_RR_RETRY_REACHED;
                 break;
             case UwbUciConstants.REASON_MAX_NUMBER_OF_MEASUREMENTS_REACHED:
+            case UwbUciConstants.REASON_SESSION_STOPPED_DUE_TO_MAX_STS_INDEX_VALUE:
                 rangingChangeReason = RangingChangeReason.REMOTE_REQUEST;
                 break;
             case UwbUciConstants.REASON_ERROR_INSUFFICIENT_SLOTS_PER_RR:
diff --git a/service/java/com/android/server/uwb/UwbSessionNotificationManager.java b/service/java/com/android/server/uwb/UwbSessionNotificationManager.java
index 220dbef6..a100d584 100644
--- a/service/java/com/android/server/uwb/UwbSessionNotificationManager.java
+++ b/service/java/com/android/server/uwb/UwbSessionNotificationManager.java
@@ -39,11 +39,13 @@ import com.android.server.uwb.data.UwbRangingData;
 import com.android.server.uwb.data.UwbTwoWayMeasurement;
 import com.android.server.uwb.data.UwbUciConstants;
 import com.android.server.uwb.params.TlvUtil;
+import com.android.server.uwb.rftest.RfNotificationEvent;
 import com.android.server.uwb.util.UwbUtil;
 
 import com.google.uwb.support.aliro.AliroParams;
 import com.google.uwb.support.aliro.AliroRangingReconfiguredParams;
 import com.google.uwb.support.base.Params;
+import com.google.uwb.support.ccc.CccOpenRangingParams;
 import com.google.uwb.support.ccc.CccParams;
 import com.google.uwb.support.ccc.CccRangingReconfiguredParams;
 import com.google.uwb.support.dltdoa.DlTDoAMeasurement;
@@ -52,9 +54,12 @@ import com.google.uwb.support.fira.FiraOnControleeAddRemoveParams;
 import com.google.uwb.support.fira.FiraOpenSessionParams;
 import com.google.uwb.support.fira.FiraParams;
 import com.google.uwb.support.oemextension.RangingReportMetadata;
+import com.google.uwb.support.oemextension.RfTestNotification;
 import com.google.uwb.support.radar.RadarData;
 import com.google.uwb.support.radar.RadarParams;
 import com.google.uwb.support.radar.RadarSweepData;
+import com.google.uwb.support.rftest.RfTestParams;
+import com.google.uwb.support.rftest.RfTestSessionStatus;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -161,15 +166,25 @@ public class UwbSessionNotificationManager {
         }
     }
 
-
     public void onRangingStartFailed(UwbSession uwbSession, int status) {
         SessionHandle sessionHandle = uwbSession.getSessionHandle();
         IUwbRangingCallbacks uwbRangingCallbacks = uwbSession.getIUwbRangingCallbacks();
         try {
-            uwbRangingCallbacks.onRangingStartFailed(sessionHandle,
-                    UwbSessionNotificationHelper.convertUciStatusToApiReasonCode(status),
-                    UwbSessionNotificationHelper.convertUciStatusToParam(
-                            uwbSession.getProtocolName(), status));
+            if (!uwbSession.getProtocolName().equals(RfTestParams.PROTOCOL_NAME)) {
+                uwbRangingCallbacks.onRangingStartFailed(sessionHandle,
+                        UwbSessionNotificationHelper.convertUciStatusToApiReasonCode(status),
+                        UwbSessionNotificationHelper.convertUciStatusToParam(
+                                uwbSession.getProtocolName(), status));
+            } else {
+                RfTestSessionStatus rfTestSessionStatus = new RfTestSessionStatus.Builder()
+                        .setRfTestOperationType(
+                            uwbSession.getRfTestStartSessionParams().getRfTestOperationType())
+                        .setStatusCode(status).build();
+
+                uwbRangingCallbacks.onRangingStartFailed(sessionHandle,
+                        UwbSessionNotificationHelper.convertUciStatusToApiReasonCode(status),
+                        rfTestSessionStatus.toBundle());
+            }
             Log.i(TAG, "IUwbRangingCallbacks - onRangingStartFailed");
         } catch (Exception e) {
             Log.e(TAG, "IUwbRangingCallbacks - onRangingStartFailed : Failed");
@@ -198,8 +213,11 @@ public class UwbSessionNotificationManager {
             PersistableBundle params)  {
         SessionHandle sessionHandle = uwbSession.getSessionHandle();
         IUwbRangingCallbacks uwbRangingCallbacks = uwbSession.getIUwbRangingCallbacks();
-        mUwbInjector.finishUwbRangingPermissionForDataDelivery(uwbSession.getAttributionSource());
-        uwbSession.setDataDeliveryPermissionCheckNeeded(true);
+        if (!uwbSession.getProtocolName().equals(RfTestParams.PROTOCOL_NAME)) {
+            mUwbInjector.finishUwbRangingPermissionForDataDelivery(
+                    uwbSession.getAttributionSource());
+            uwbSession.setDataDeliveryPermissionCheckNeeded(true);
+        }
         try {
             uwbRangingCallbacks.onRangingStopped(sessionHandle, reason, params);
             Log.i(TAG, "IUwbRangingCallbacks - onRangingStopped");
@@ -612,6 +630,52 @@ public class UwbSessionNotificationManager {
         }
     }
 
+    public void onRfTestNotificationReceived(UwbSession uwbSession,
+            RfNotificationEvent rfNotificationEvent) {
+        if (uwbSession == null || rfNotificationEvent == null) {
+            Log.e(TAG, "Invalid arguments: uwbSession or rfNotificationEvent is null");
+            return;
+        }
+
+        final SessionHandle sessionHandle = uwbSession.getSessionHandle();
+        final IUwbRangingCallbacks uwbRangingCallbacks = uwbSession.getIUwbRangingCallbacks();
+
+        // Placeholder object creation to satisfy the existing conditions in RangingMeasurement
+        final RangingMeasurement.Builder rangingMeasurementBuilder = buildRangingMeasurement(
+                new byte[] { 0x01, 0x02 }, rfNotificationEvent.getStatus(), 0x01, 0);
+
+        // Handle the OEM callback
+        if (mUwbInjector.getUwbServiceCore().isOemExtensionCbRegistered()) {
+            try {
+                RfTestNotification rfTestNotification = new RfTestNotification.Builder()
+                        .setRfTestOperationType(rfNotificationEvent.getOperationType())
+                        .setRfTestNtfData(rfNotificationEvent.getRawNotificationData())
+                        .build();
+
+                RangingReport.Builder rangingReportBuilder = new RangingReport.Builder()
+                        .addMeasurement(rangingMeasurementBuilder.build())
+                        .addRangingReportMetadata(rfTestNotification.toBundle());
+
+                mUwbInjector.getUwbServiceCore().getOemExtensionCallback()
+                        .onRangingReportReceived(rangingReportBuilder.build());
+            } catch (RemoteException e) {
+                Log.e(TAG, "Failed to send RF Test Notification via OEM callback", e);
+            }
+        }
+
+        String callbackMethodName = rfNotificationEvent.getClass().getSimpleName();
+        try {
+            RangingReport.Builder rangingReportBuilder = new RangingReport.Builder()
+                    .addMeasurement(rangingMeasurementBuilder.build())
+                    .addRangingReportMetadata(rfNotificationEvent.toBundle());
+
+            uwbRangingCallbacks.onRangingResult(sessionHandle, rangingReportBuilder.build());
+            Log.i(TAG, "Notification received for " + callbackMethodName);
+        } catch (Exception e) {
+            Log.e(TAG, "Failed to notify IUwbRangingCallbacks for " + callbackMethodName, e);
+        }
+    }
+
     /** Notify about new radar data message. */
     public void onRadarDataMessageReceived(UwbSession uwbSession, UwbRadarData radarData) {
         SessionHandle sessionHandle = uwbSession.getSessionHandle();
@@ -715,6 +779,9 @@ public class UwbSessionNotificationManager {
                     isDestAoaElevationEnabled = true;
                 }
             }
+        } else if (protocolName.equals(CccParams.PROTOCOL_NAME)) {
+            CccOpenRangingParams openSessionParams = (CccOpenRangingParams) sessionParams;
+            sessionId = openSessionParams.getSessionId();
         }
 
         // TODO(b/256734264): The unit tests are currently not checking for this field, as
diff --git a/service/java/com/android/server/uwb/UwbShellCommand.java b/service/java/com/android/server/uwb/UwbShellCommand.java
index 62875cb6..0aec8e1e 100644
--- a/service/java/com/android/server/uwb/UwbShellCommand.java
+++ b/service/java/com/android/server/uwb/UwbShellCommand.java
@@ -410,6 +410,10 @@ public class UwbShellCommand extends BasicShellCommandHandler {
 
         public void onHybridSessionControleeConfigurationFailed(SessionHandle sessionHandle,
                 int reason, PersistableBundle parameters) {}
+
+
+        public void onRfTestNotificationReceived(SessionHandle sessionHandle,
+                PersistableBundle parameters) {}
     }
 
 
@@ -465,7 +469,7 @@ public class UwbShellCommand extends BasicShellCommandHandler {
             if (option.equals("-i") || option.equals("--session-id")) {
                 builder.setSessionId(Integer.parseInt(getNextArgRequired()));
             }
-            if (option.equals("-c") || option.equals("--channel")) {
+            if (option.equals("-c") || option.equals("--channel-number")) {
                 builder.setChannelNumber(Integer.parseInt(getNextArgRequired()));
             }
             if (option.equals("-t") || option.equals("--device-type")) {
@@ -737,6 +741,27 @@ public class UwbShellCommand extends BasicShellCommandHandler {
                 }
                 builder.setSfdId(sfd_id);
             }
+            if (option.equals("--is-key-rotation-enabled")) {
+                boolean isKeyRotationEnabled =
+                        getNextArgRequiredTrueOrFalse("enabled", "disabled");
+                builder.setIsKeyRotationEnabled(isKeyRotationEnabled);
+            }
+            if (option.equals("--key-rotation-rate")) {
+                int keyRotationRate = Integer.parseInt(getNextArgRequired());
+                builder.setKeyRotationRate(keyRotationRate);
+            }
+            if (option.equals("--max-ranging-round-retries")) {
+                int maxRangingRoundRetries = Integer.parseInt(getNextArgRequired());
+                builder.setMaxRangingRoundRetries(maxRangingRoundRetries);
+            }
+            if (option.equals("--max-number-of-measurements")) {
+                int maxNumberOfMeasurements = Integer.parseInt(getNextArgRequired());
+                builder.setMaxNumberOfMeasurements(maxNumberOfMeasurements);
+            }
+            if (option.equals("--in-band-termination-attempt-count")) {
+                int inBandTerminationAttemptCount = Integer.parseInt(getNextArgRequired());
+                builder.setInBandTerminationAttemptCount(inBandTerminationAttemptCount);
+            }
             option = getNextOption();
         }
         if (aoaResultReqEnabled && interleavingEnabled) {
@@ -1005,7 +1030,7 @@ public class UwbShellCommand extends BasicShellCommandHandler {
                 new FiraRangingReconfigureParams.Builder();
         String option = getNextOption();
         while (option != null) {
-            if (option.equals("-a")) {
+            if (option.equals("-a") || option.equals("--action")) {
                 String action = getNextArgRequired();
                 if (action.equals("add")) {
                     builder.setAction(MULTICAST_LIST_UPDATE_ACTION_ADD);
@@ -1015,7 +1040,7 @@ public class UwbShellCommand extends BasicShellCommandHandler {
                     throw new IllegalArgumentException("Unexpected action " + action);
                 }
             }
-            if (option.equals("-d")) {
+            if (option.equals("-d") || option.equals("--dest-addresses")) {
                 String[] destAddressesString = getNextArgRequired().split(",");
                 List<UwbAddress> destAddresses = new ArrayList<>();
                 for (String destAddressString : destAddressesString) {
@@ -1026,7 +1051,7 @@ public class UwbShellCommand extends BasicShellCommandHandler {
                 }
                 builder.setAddressList(destAddresses.toArray(new UwbAddress[0]));
             }
-            if (option.equals("-s")) {
+            if (option.equals("-s") || option.equals("--sub-session-ids")) {
                 String[] subSessionIdsString = getNextArgRequired().split(",");
                 List<Integer> subSessionIds = new ArrayList<>();
                 for (String subSessionIdString : subSessionIdsString) {
@@ -1034,19 +1059,19 @@ public class UwbShellCommand extends BasicShellCommandHandler {
                 }
                 builder.setSubSessionIdList(subSessionIds.stream().mapToInt(s -> s).toArray());
             }
-            if (option.equals("-b")) {
+            if (option.equals("-b") || option.equals("--block-stride-length")) {
                 int blockStrideLength = Integer.parseInt(getNextArgRequired());
                 builder.setBlockStrideLength(blockStrideLength);
             }
-            if (option.equals("-c")) {
+            if (option.equals("-c") || option.equals("--range-data-ntf-config")) {
                 int rangeDataNtfConfig = Integer.parseInt(getNextArgRequired());
                 builder.setRangeDataNtfConfig(rangeDataNtfConfig);
             }
-            if (option.equals("-n")) {
+            if (option.equals("-n") || option.equals("--range-data-proximity-near")) {
                 int proximityNear = Integer.parseInt(getNextArgRequired());
                 builder.setRangeDataProximityNear(proximityNear);
             }
-            if (option.equals("-f")) {
+            if (option.equals("-f") || option.equals("--range-data-proximity-far")) {
                 int proximityFar = Integer.parseInt(getNextArgRequired());
                 builder.setRangeDataProximityFar(proximityFar);
             }
@@ -1097,45 +1122,63 @@ public class UwbShellCommand extends BasicShellCommandHandler {
         for (String option = getNextOption(); option != null; option = getNextOption()) {
             switch (option) {
                 case "-b":
+                case "--block":
                     shouldBlockCall = true;
                     break;
                 case "-i":
+                case "--session-id":
                     builder.setSessionId(Integer.parseInt(getNextArgRequired()));
                     break;
                 case "-c":
+                case "--channel-number":
                     builder.setChannelNumber(Integer.parseInt(getNextArgRequired()));
                     break;
+                case "-f":
+                case "--burst-period":
+                    builder.setBurstPeriod(Integer.parseInt(getNextArgRequired()));
+                    break;
                 case "-s":
+                case "--sweep-period":
                     builder.setSweepPeriod(Integer.parseInt(getNextArgRequired()));
                     break;
                 case "-u":
+                case "--sweeps-per-burst":
                     builder.setSweepsPerBurst(Integer.parseInt(getNextArgRequired()));
                     break;
                 case "-e":
+                case "--samples-per-sweep":
                     builder.setSamplesPerSweep(Integer.parseInt(getNextArgRequired()));
                     break;
                 case "-o":
+                case "--sweep-offset":
                     builder.setSweepOffset(Integer.parseInt(getNextArgRequired()));
                     break;
                 case "-r":
+                case "--rframe-config":
                     builder.setRframeConfig(Integer.parseInt(getNextArgRequired()));
                     break;
                 case "-t":
+                case "--preamble-duration":
                     builder.setPreambleDuration(Integer.parseInt(getNextArgRequired()));
                     break;
                 case "-d":
+                case "--preamble-code-index":
                     builder.setPreambleCodeIndex(Integer.parseInt(getNextArgRequired()));
                     break;
                 case "-x":
+                case "--session-priority":
                     builder.setSessionPriority(Integer.parseInt(getNextArgRequired()));
                     break;
                 case "-p":
+                case "--bits-per-sample":
                     builder.setBitsPerSample(Integer.parseInt(getNextArgRequired()));
                     break;
                 case "-m":
+                case "--prf-mode":
                     builder.setPrfMode(Integer.parseInt(getNextArgRequired()));
                     break;
                 case "-n":
+                case "--number-of-bursts":
                     builder.setNumberOfBursts(Integer.parseInt(getNextArgRequired()));
                     break;
             }
@@ -1392,16 +1435,16 @@ public class UwbShellCommand extends BasicShellCommandHandler {
                     byte diagramFrameReportsFlags = 0;
                     String option = getNextOption();
                     while (option != null) {
-                        if (option.equals("-r")) {
+                        if (option.equals("-r") || option.equals("--rssi")) {
                             diagramFrameReportsFlags |= RSSI_FLAG;
                         }
-                        if (option.equals("-a")) {
+                        if (option.equals("-a") || option.equals("--aoa")) {
                             diagramFrameReportsFlags |= AOA_FLAG;
                         }
-                        if (option.equals("-c")) {
+                        if (option.equals("-c") || option.equals("--cir")) {
                             diagramFrameReportsFlags |= CIR_FLAG;
                         }
-                        if (option.equals("-s")) {
+                        if (option.equals("-s") || option.equals("--segment-metrics")) {
                             diagramFrameReportsFlags |= SEGMENT_METRICS_FLAG;
                         }
                         option = getNextOption();
@@ -1483,91 +1526,99 @@ public class UwbShellCommand extends BasicShellCommandHandler {
         pw.println("    If 'hw_idle_turn_off_enabled' feature is enabled, vote for UWB on");
         pw.println("  disable-uwb-hw");
         pw.println("    If 'hw_idle_turn_off_enabled' feature is enabled, vote for UWB off");
-        pw.println("  start-fira-ranging-session"
-                + " [-b](blocking call)"
-                + " [-i <sessionId>](session-id)"
-                + " [-c <channel>](channel)"
-                + " [-t controller|controlee](device-type)"
-                + " [-r initiator|responder](device-role)"
-                + " [-a <deviceAddress>](device-address)"
-                + " [-d <destAddress-1, destAddress-2,...>](dest-addresses)"
-                + " [-m <unicast|one-to-many|many-to-many>](multi-node-mode)"
-                + " [-u ds-twr|ss-twr|ds-twr-non-deferred|ss-twr-non-deferred](round-usage)"
-                + " [-l <ranging-interval-ms>](ranging-interval-ms)"
-                + " [-s <slots-per-ranging-round>](slots-per-ranging-round)"
-                + " [-x <proximity-near-cm, proximity-far-cm>](range-data-ntf-proximity)"
-                + " [-R enabled|disabled](range-data-notification)"
-                + " [-z <numRangeMrmts, numAoaAzimuthMrmts, numAoaElevationMrmts>"
-                + "(interleaving-ratio)"
-                + " [-e none|enabled|azimuth-only|elevation-only](aoa-result-request)"
-                + " [-f <tof,azimuth,elevation,aoa-fom>(result-report-config)"
-                + " [-g <staticStsIV>(sts-iv: staticStsIV 6-bytes)"
-                + " [-v <staticStsVendorId>(vendor-id: staticStsVendorId 2-bytes)"
-                + " [-h <slot-duration-rstu>(slot-duration-rstu, default=2400)"
-                + " [-w enabled|disabled](has-result-report-phase)"
-                + " [-y enabled|disabled](hopping-mode, default = disabled)"
-                + " [-p <preamble-code-index>](preamble-code-index, default = 10)"
-                + " [-o static|provisioned](sts-config-type)"
-                + " [-n <sessionKey>](session-key 16 or 32 bytes)"
-                + " [-k <subSessionKey>](sub-session-key 16 or 32 bytes)"
-                + " [-j <errorStreakTimeoutMs>](error-streak-timeout-ms in millis, default=30000)"
-                + " [-q <sessionPriority>](session-priority 1-49 or 51-100)"
-                + " [-P bprf|hprf](prf-mode)"
-                + " [-D 6m81|7m80|27m2|31m2](psdu-data-rate)"
-                + " [-B 850k|6m81](bprf-phr-data-rate)"
-                + " [-A enabled|disabled](tx-adaptive-power, default = disabled)"
-                + " [-S <sfd_id>](sfd-id 0-4, default = 2)");
-        pw.println("    Starts a FIRA ranging session with the provided params."
+        pw.println("  start-fira-ranging-session\n"
+                + "    [-b blocking call](block)\n"
+                + "    [-i <sessionId>](session-id)\n"
+                + "    [-c <channel>](channel-number)\n"
+                + "    [-t controller|controlee](device-type)\n"
+                + "    [-r initiator|responder](device-role)\n"
+                + "    [-a <deviceAddress>](device-address)\n"
+                + "    [-d <destAddress-1, destAddress-2,...>](dest-addresses)\n"
+                + "    [-m <unicast|one-to-many|many-to-many>](multi-node-mode)\n"
+                + "    [-u ds-twr|ss-twr|ds-twr-non-deferred|ss-twr-non-deferred](round-usage)\n"
+                + "    [-l <ranging-interval-ms>](ranging-interval-ms)\n"
+                + "    [-s <slots-per-ranging-round>](slots-per-ranging-round)\n"
+                + "    [-x <proximity-near-cm, proximity-far-cm>](range-data-ntf-proximity)\n"
+                + "    [-R enabled|disabled](range-data-notification)\n"
+                + "    [-z <numRangeMrmts, numAoaAzimuthMrmts, numAoaElevationMrmts>"
+                + "(interleaving-ratio)\n"
+                + "    [-e none|enabled|azimuth-only|elevation-only](aoa-result-request)\n"
+                + "    [-f <tof,azimuth,elevation,aoa-fom>(result-report-config)\n"
+                + "    [-g <staticStsIV>(sts-iv: staticStsIV 6-bytes)\n"
+                + "    [-v <staticStsVendorId>(vendor-id: staticStsVendorId 2-bytes)\n"
+                + "    [-h <slot-duration-rstu>(slot-duration-rstu, default=2400)\n"
+                + "    [-w enabled|disabled](has-result-report-phase)\n"
+                + "    [-y enabled|disabled](hopping-mode, default = disabled)\n"
+                + "    [-p <preamble-code-index>](preamble-code-index, default = 10)\n"
+                + "    [-o static|provisioned](sts-config-type)\n"
+                + "    [-n <sessionKey>](session-key 16 or 32 bytes)\n"
+                + "    [-k <subSessionKey>](sub-session-key 16 or 32 bytes)\n"
+                + "    [-j <errorStreakTimeoutMs>]"
+                + "(error-streak-timeout-ms in millis, default=30000)\n"
+                + "    [-q <sessionPriority>](session-priority 1-49 or 51-100)\n"
+                + "    [-P bprf|hprf](prf-mode)\n"
+                + "    [-D 6m81|7m80|27m2|31m2](psdu-data-rate)\n"
+                + "    [-B 850k|6m81](bprf-phr-data-rate)\n"
+                + "    [-A enabled|disabled](tx-adaptive-power, default = disabled)\n"
+                + "    [-S <sfd_id>](sfd-id 0-4, default = 2)\n"
+                + "    [--is-key-rotation-enabled enabled|disabled]\n"
+                + "    [--key-rotation-rate <int>]\n"
+                + "    [--max-ranging-round-retries <int>]\n"
+                + "    [--max-number-of-measurements <int>]\n"
+                + "    [--in-band-termination-attempt-count <int>]\n"
+                + ""
+                + "    Starts a FIRA ranging session with the provided params."
                 + " Note: default behavior is to cache the latest ranging reports which can be"
                 + " retrieved using |get-ranging-session-reports|");
-        pw.println("  start-dl-tdoa-ranging-session"
-                        + " [-i <sessionId>](session-id)");
+        pw.println("  start-dl-tdoa-ranging-session\n"
+                        + "    [-i <sessionId>](session-id)");
         pw.println("    Starts a FIRA Dl-TDoA ranging session for DT-Tag");
-        pw.println("  start-ccc-ranging-session"
-                + " [-b](blocking call)"
-                + " Ranging reports will be displayed on screen)"
-                + " [-u 0|1](uwb-config)"
-                + " [-p <tx>,<rx>](pulse-shape-combo)"
-                + " [-i <sessionId>](session-id)"
-                + " [-r <ran_multiplier>](ran-multiplier)"
-                + " [-c <channel>](channel)"
-                + " [-m <num-chaps-per-slot>](num-chaps-per-slot)"
-                + " [-n <num-responder-nodes>](num-responder-nodes)"
-                + " [-o <num-slots-per-round>](num-slots-per-round)"
-                + " [-s <sync-code-index>](sync-code-index)"
-                + " [-h none|continuous|adaptive](hopping-config-mode)"
-                + " [-a default|aes](hopping-sequence)"
-                + " [-S <stsIndex>](sts-index)");
+        pw.println("  start-ccc-ranging-session\n"
+                + "    [-b](blocking call)"
+                + " Ranging reports will be displayed on screen)\n"
+                + "    [-u 0|1](uwb-config)\n"
+                + "    [-p <tx>,<rx>](pulse-shape-combo)\n"
+                + "    [-i <sessionId>](session-id)\n"
+                + "    [-r <ran_multiplier>](ran-multiplier)\n"
+                + "    [-c <channel>](channel)\n"
+                + "    [-m <num-chaps-per-slot>](num-chaps-per-slot)\n"
+                + "    [-n <num-responder-nodes>](num-responder-nodes)\n"
+                + "    [-o <num-slots-per-round>](num-slots-per-round)\n"
+                + "    [-s <sync-code-index>](sync-code-index)\n"
+                + "    [-h none|continuous|adaptive](hopping-config-mode)\n"
+                + "    [-a default|aes](hopping-sequence)\n"
+                + "    [-S <stsIndex>](sts-index)");
         pw.println("    Starts a CCC ranging session with the provided params."
                 + " Note: default behavior is to cache the latest ranging reports which can be"
                 + " retrieved using |get-ranging-session-reports|");
-        pw.println("  start-radar-session"
-                + " [-b](blocking call)"
-                + " Radar data will be displayed on screen)"
-                + " [-i <sessionId>](session-id)"
-                + " [-c <channel>](channel)"
-                + " [-s <sweepPeriod>](sweep-period)"
-                + " [-u <sweepsPerBurst>](sweeps-per-burst)"
-                + " [-e <samplesPerSweep>](samples-per-sweep)"
-                + " [-p <bitsPerSample>](bits-per-sample)"
-                + " [-o <sweepOffset>](sweep-offset)"
-                + " [-r <rframeConfig>](rframe-config)"
-                + " [-t <preambleDuration>](preamble-duration)"
-                + " [-d <preambleCodeIndex>](preamble-code-index)"
-                + " [-x  <sessionPriority>](session-priority)"
-                + " [-m <prfMode>](prf-mode)"
-                + " [-n <numberOfBursts>](number-of-bursts)");
+        pw.println("  start-radar-session\n"
+                + "    [-b](blocking call)"
+                + " Radar data will be displayed on screen)\n"
+                + "    [-i <sessionId>](session-id)\n"
+                + "    [-c <channel>](channel-number)\n"
+                + "    [-f <burstPeriod>](burst-period)\n"
+                + "    [-s <sweepPeriod>](sweep-period)\n"
+                + "    [-u <sweepsPerBurst>](sweeps-per-burst)\n"
+                + "    [-e <samplesPerSweep>](samples-per-sweep)\n"
+                + "    [-o <sweepOffset>](sweep-offset)\n"
+                + "    [-r <rframeConfig>](rframe-config)\n"
+                + "    [-t <preambleDuration>](preamble-duration)\n"
+                + "    [-d <preambleCodeIndex>](preamble-code-index)\n"
+                + "    [-x <sessionPriority>](session-priority)\n"
+                + "    [-p <bitsPerSample>](bits-per-sample)\n"
+                + "    [-m <prfMode>](prf-mode)\n"
+                + "    [-n <numberOfBursts>](number-of-bursts)");
         pw.println("    Starts a Radar session with the provided params defined in the radar UCI"
                 + "    spec.");
         pw.println("  reconfigure-fira-ranging-session"
-                + " <sessionId>"
-                + " [-a add|delete](action)"
-                + " [-d <destAddress-1, destAddress-2,...>](dest-addresses)"
-                + " [-s <subSessionId-1, subSessionId-2,...>](sub-sessionIds)"
-                + " [-b <block-striding>](block-striding)"
-                + " [-c <range-data-ntf-cfg>](range-data-ntf-cfg)"
-                + " [-n <proximity-near>(proximity-near)"
-                + " [-f <proximity-far>](proximity-far)");
+                + " <sessionId>\n"
+                + "    [-a add|delete](action)\n"
+                + "    [-d <destAddress-1, destAddress-2,...>](dest-addresses)\n"
+                + "    [-s <subSessionId-1, subSessionId-2,...>](sub-session-ids)\n"
+                + "    [-b <block-striding>](block-stride-length)\n"
+                + "    [-c <range-data-ntf-cfg>](range-data-ntf-cfg)\n"
+                + "    [-n <proximity-near>(range-data-proximity-near)\n"
+                + "    [-f <proximity-far>](range-data-proximity-far)");
         pw.println("  get-ranging-session-reports <sessionId>");
         pw.println("    Displays latest cached ranging reports for an ongoing ranging session");
         pw.println("  get-all-ranging-session-reports");
@@ -1582,11 +1633,11 @@ public class UwbShellCommand extends BasicShellCommandHandler {
         pw.println("    Stops all ongoing radar sessions");
         pw.println("  get-specification-info");
         pw.println("    Gets specification info from uwb chip");
-        pw.println("  enable-diagnostics-notification"
-                + " [-r](enable rssi)"
-                + " [-a](enable aoa)"
-                + " [-c](enable cir)"
-                + " [-s](enable segment metrics)");
+        pw.println("  enable-diagnostics-notification\n"
+                + "    [-r](enable rssi)\n"
+                + "    [-a](enable aoa)\n"
+                + "    [-c](enable cir)\n"
+                + "    [-s](enable segment-metrics)");
         pw.println("    Enable vendor diagnostics notification");
         pw.println("  disable-diagnostics-notification");
         pw.println("    Disable vendor diagnostics notification");
diff --git a/service/java/com/android/server/uwb/config/CapabilityParam.java b/service/java/com/android/server/uwb/config/CapabilityParam.java
index 135f981a..b3019a3c 100644
--- a/service/java/com/android/server/uwb/config/CapabilityParam.java
+++ b/service/java/com/android/server/uwb/config/CapabilityParam.java
@@ -153,6 +153,7 @@ public class CapabilityParam {
 
     public static final int CONTENTION_BASED_RANGING = 0x1;
     public static final int TIME_SCHEDULED_RANGING = 0x2;
+    public static final int HYBRID_SCHEDULED_RANGING = 0x4;
 
     public static final int CONSTRAINT_LENGTH_3 = 0x1;
     public static final int CONSTRAINT_LENGTH_7 = 0x2;
@@ -242,6 +243,8 @@ public class CapabilityParam {
     // Protocol Agnostic
     public static final int SUPPORTED_POWER_STATS_QUERY =
             UwbVendorCapabilityTlvTypes.SUPPORTED_POWER_STATS_QUERY;
+    public static final int SUPPORTED_MAX_SESSION_COUNT =
+            UwbVendorCapabilityTlvTypes.SUPPORTED_MAX_SESSION_COUNT;
 
     public static final int SUPPORTED_ANTENNA_MODES =
             UwbVendorCapabilityTlvTypes.SUPPORTED_ANTENNA_MODES;
diff --git a/service/java/com/android/server/uwb/config/ConfigParam.java b/service/java/com/android/server/uwb/config/ConfigParam.java
index c56a5325..15e3e2f8 100644
--- a/service/java/com/android/server/uwb/config/ConfigParam.java
+++ b/service/java/com/android/server/uwb/config/ConfigParam.java
@@ -158,6 +158,18 @@ public class ConfigParam {
     public static final int NUMBER_OF_BURSTS_KEY = NUMBER_OF_BURSTS;
     public static final int RADAR_DATA_TYPE_KEY = RADAR_DATA_TYPE;
 
+    //Rf test related config IDs
+    public static final int NUMBER_OF_PACKETS = 0x00;
+    public static final int T_GAP = 0x01;
+    public static final int T_START = 0x02;
+    public static final int T_WIN = 0x03;
+    public static final int RANDOMIZE_PSDU = 0x04;
+    public static final int PHR_RANGING_BIT = 0x05;
+    public static final int RMARKER_TX_START = 0x06;
+    public static final int RMARKER_RX_START = 0x07;
+    public static final int STS_INDEX_AUTO_INCR = 0x08;
+    public static final int STS_DETECT_BITMAP = 0x09;
+
     public static byte[] getTagBytes(int tagType) {
         int tagLength = 1;
         ByteBuffer buffer = ByteBuffer.allocate(Integer.BYTES).putInt(tagType);
diff --git a/service/java/com/android/server/uwb/data/UwbUciConstants.java b/service/java/com/android/server/uwb/data/UwbUciConstants.java
index a48fb913..2b179702 100644
--- a/service/java/com/android/server/uwb/data/UwbUciConstants.java
+++ b/service/java/com/android/server/uwb/data/UwbUciConstants.java
@@ -85,6 +85,7 @@ public class UwbUciConstants {
     public static final int REASON_ERROR_HUS_OTHERS = 0x29;
     public static final int REASON_ERROR_SESSION_KEY_NOT_FOUND = 0x2A;
     public static final int REASON_ERROR_SUB_SESSION_KEY_NOT_FOUND = 0x2B;
+    public static final int REASON_SESSION_STOPPED_DUE_TO_MAX_STS_INDEX_VALUE = 0xA2;
     /* Vendor Specific reason codes */
     public static final int REASON_REGULATION_UWB_OFF =
             UwbVendorReasonCodes.REASON_REGULATION_UWB_OFF;
diff --git a/service/java/com/android/server/uwb/jni/INativeUwbManager.java b/service/java/com/android/server/uwb/jni/INativeUwbManager.java
index d698c903..3eb9c61a 100644
--- a/service/java/com/android/server/uwb/jni/INativeUwbManager.java
+++ b/service/java/com/android/server/uwb/jni/INativeUwbManager.java
@@ -18,11 +18,7 @@ package com.android.server.uwb.jni;
 import com.android.server.uwb.data.UwbMulticastListUpdateStatus;
 import com.android.server.uwb.data.UwbRadarData;
 import com.android.server.uwb.data.UwbRangingData;
-
-/*import com.android.server.uwb.test.UwbTestLoopBackTestResult;
-import com.android.server.uwb.test.UwbTestPeriodicTxResult;
-import com.android.server.uwb.test.UwbTestRxPacketErrorRateResult;
-import com.android.server.uwb.test.UwbTestRxResult;*/
+import com.android.server.uwb.rftest.RfNotificationEvent;
 
 public interface INativeUwbManager {
     /**
@@ -97,6 +93,13 @@ public interface INativeUwbManager {
          */
         void onDataTransferPhaseConfigNotificationReceived(long sessionId,
                 int dataTransferPhaseConfigStatus);
+
+        /**
+         * Interface for receiving RF test notification events
+         *
+         * @param rfNotificationEvent  : Protocol specific notification params
+         */
+        void onRfTestNotificationReceived(RfNotificationEvent rfNotificationEvent);
     }
 
     interface DeviceNotification {
@@ -124,11 +127,4 @@ public interface INativeUwbManager {
          */
         void onVendorUciNotificationReceived(int gid, int oid, byte[] payload);
     }
-    /* Unused now */
-    /*interface RfTestNotification {
-        void onPeriodicTxDataNotificationReceived(UwbTestPeriodicTxResult periodicTxData);
-        void onPerRxDataNotificationReceived(UwbTestRxPacketErrorRateResult perRxData);
-        void onLoopBackTestDataNotificationReceived(UwbTestLoopBackTestResult uwbLoopBackData);
-        void onRxTestDataNotificationReceived(UwbTestRxResult rxData);
-    }*/
 }
diff --git a/service/java/com/android/server/uwb/jni/NativeUwbManager.java b/service/java/com/android/server/uwb/jni/NativeUwbManager.java
index 9a2370ca..90ed32e6 100644
--- a/service/java/com/android/server/uwb/jni/NativeUwbManager.java
+++ b/service/java/com/android/server/uwb/jni/NativeUwbManager.java
@@ -33,6 +33,7 @@ import com.android.server.uwb.data.UwbUciConstants;
 import com.android.server.uwb.data.UwbVendorUciResponse;
 import com.android.server.uwb.info.UwbPowerStats;
 import com.android.server.uwb.multchip.UwbMultichipData;
+import com.android.server.uwb.rftest.UwbTestPeriodicTxResult;
 
 import java.util.Arrays;
 import java.util.HashMap;
@@ -128,6 +129,14 @@ public class NativeUwbManager {
         mVendorListener.onVendorUciNotificationReceived(gid, oid, payload);
     }
 
+    /**
+     * RfTestPeriodicTx callback invoked via the JNI
+     */
+    public void onPeriodicTxDataNotificationReceived(UwbTestPeriodicTxResult periodicTx) {
+        Log.d(TAG, "onPeriodicTxDataNotificationReceived : " + periodicTx);
+        mSessionListener.onRfTestNotificationReceived(periodicTx);
+    }
+
     /**
      * Enable UWB hardware.
      *
@@ -300,6 +309,48 @@ public class NativeUwbManager {
         }
     }
 
+    /**
+     * set RF Test Configuration Parameters for the requested UWB Test session
+     *
+     * @param noOfParams        : The number (n) of APP Configuration Parameters
+     * @param appConfigParamLen : The length of APP Configuration Parameters
+     * @param appConfigParams   : APP Configuration Parameter
+     * @param chipId            : Identifier of UWB chip for multi-HAL devices
+     * @return : {@link UwbConfigStatusData} : Contains statuses for all cfg_id
+     */
+    public UwbConfigStatusData setRfTestAppConfigurations(int sessionId, int noOfParams,
+            int appConfigParamLen, byte[] appConfigParams, String chipId) {
+        synchronized (mNativeLock) {
+            return nativeSetRfTestAppConfigurations(sessionId, noOfParams, appConfigParamLen,
+                    appConfigParams, chipId);
+        }
+    }
+
+    /**
+     * Starts a Periodic Tx test
+     *
+     * @param psduData : PSDU data
+     * @param chipId   : Identifier of UWB chip for multi-HAL devices
+     * @return : {@link UwbUciConstants}  Status code
+     */
+    public byte testPeriodicTx(byte[] psduData, String chipId) {
+        synchronized (mNativeLock) {
+            return nativeTestPeriodicTx(psduData, chipId);
+        }
+    }
+
+    /*
+     * Stops the ongoing Rf test session.
+     *
+     * @param chipId    : Identifier of UWB chip for multi-HAL devices
+     * @return          : {@link UwbUciConstants}  Status code
+     */
+    public byte stopRfTest(String chipId) {
+        synchronized (mNativeLock) {
+            return nativeStopRfTest(chipId);
+        }
+    }
+
     /**
      * Set radar APP Configuration Parameters for the requested UWB radar session
      *
@@ -625,4 +676,11 @@ public class NativeUwbManager {
 
     private native byte nativeSetHybridSessionControleeConfigurations(int sessionId,
             int noOfPhases, byte[] phaseList, String chipId);
+
+    private native UwbConfigStatusData nativeSetRfTestAppConfigurations(int sessionId,
+            int noOfParams, int appConfigParamLen, byte[] appConfigParams, String chipId);
+
+    private native byte nativeTestPeriodicTx(byte[] psduData, String chipId);
+
+    private native byte nativeStopRfTest(String chipId);
 }
diff --git a/service/java/com/android/server/uwb/jni/NativeUwbRfTestManager.java b/service/java/com/android/server/uwb/jni/NativeUwbRfTestManager.java
deleted file mode 100644
index 7949323a..00000000
--- a/service/java/com/android/server/uwb/jni/NativeUwbRfTestManager.java
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* NativeUwbRfTestManager is unused now*/
-/*package com.android.server.uwb.jni;
-
-import android.util.Log;
-
-import com.android.server.uwb.test.UwbTestLoopBackTestResult;
-import com.android.server.uwb.test.UwbTestPeriodicTxResult;
-import com.android.server.uwb.test.UwbTestRxPacketErrorRateResult;
-import com.android.server.uwb.test.UwbTestRxResult;
-
-public class NativeUwbRfTestManager {
-    private static final String TAG = NativeUwbRfTestManager.class.getSimpleName();
-
-    protected INativeUwbManager.RfTestNotification mRfTestListener;
-
-    public NativeUwbRfTestManager() {
-        nativeInit();
-    }
-
-    public void setDeviceListener(INativeUwbManager.RfTestNotification rftestListener) {
-        mRfTestListener = rftestListener;
-    }
-
-    public void onPeriodicTxDataNotificationReceived(UwbTestPeriodicTxResult periodicTxTestResult) {
-        Log.d(TAG, "onPeriodicTxDataNotificationReceived : " + periodicTxTestResult);
-        mRfTestListener.onPeriodicTxDataNotificationReceived(periodicTxTestResult);
-    }
-
-    public void onPerRxDataNotificationReceived(UwbTestRxPacketErrorRateResult perRxTestResult) {
-        Log.d(TAG, "onPerRxDataNotificationReceived : " + perRxTestResult);
-        mRfTestListener.onPerRxDataNotificationReceived(perRxTestResult);
-    }
-
-    public void onLoopBackTestDataNotificationReceived(UwbTestLoopBackTestResult loopBackResult) {
-        Log.d(TAG, "onLoopBackTestDataNotificationReceived : " + loopBackResult);
-        mRfTestListener.onLoopBackTestDataNotificationReceived(loopBackResult);
-    }
-
-    public void onRxTestDataNotificationReceived(UwbTestRxResult rxTestResult) {
-        Log.d(TAG, "onRxTestDataNotificationReceived : " + rxTestResult);
-        mRfTestListener.onRxTestDataNotificationReceived(rxTestResult);
-    }
-
-    public synchronized byte[] setRfTestConfigurations(int sessionId, int noOfParams,
-            int testConfigParamLen, byte[] testConfigParams) {
-        return nativeSetTestConfigurations(
-                sessionId, noOfParams, testConfigParamLen, testConfigParams);
-    }
-
-    public synchronized byte[] getRfTestConfigurations(int sessionId, int noOfParams,
-            int testConfigParamLen, byte[] testConfigParams) {
-        return nativeGetTestConfigurations(
-                sessionId, noOfParams, testConfigParamLen, testConfigParams);
-    }
-
-    public synchronized byte startPeriodicTxTest(byte[] psduData) {
-        return nativeStartPeriodicTxTest(psduData);
-    }
-
-    public synchronized byte startPerRxTest(byte[] refPsduData) {
-        return nativeStartPerRxTest(refPsduData);
-    }
-
-    public synchronized byte startUwbLoopBackTest(byte[] psduData) {
-        return nativeStartUwbLoopBackTest(psduData);
-    }
-
-    public synchronized byte startRxTest() {
-        return nativeStartRxTest();
-    }
-
-    public synchronized byte stopRfTest() {
-        return nativeStopRfTest();
-    }
-
-    private native boolean nativeInit();
-    private native byte nativeStopRfTest();
-    private native byte nativeStartPerRxTest(byte[] refPsduData);
-    private native byte nativeStartPeriodicTxTest(byte[] psduData);
-    private native byte nativeStartUwbLoopBackTest(byte[] psduData);
-    private native byte nativeStartRxTest();
-    private native byte[] nativeSetTestConfigurations(int sessionId, int noOfParams,
-            int testConfigParamLen, byte[] testConfigParams);
-    private native byte[] nativeGetTestConfigurations(int sessionId, int noOfParams,
-            int testConfigParamLen, byte[] testConfigParams);
-}*/
diff --git a/service/java/com/android/server/uwb/params/AliroDecoder.java b/service/java/com/android/server/uwb/params/AliroDecoder.java
index 8d922f93..d7aab3b2 100644
--- a/service/java/com/android/server/uwb/params/AliroDecoder.java
+++ b/service/java/com/android/server/uwb/params/AliroDecoder.java
@@ -195,8 +195,14 @@ public class AliroDecoder extends TlvDecoder {
 
         try {
             byte[] prioritizedChannels = tlvs.getByteArray(CCC_PRIORITIZED_CHANNEL_LIST);
+            byte channels = tlvs.getByte(CCC_SUPPORTED_CHANNELS);
             for (byte prioritizedChannel : prioritizedChannels) {
-                builder.addChannel(prioritizedChannel);
+                if (isBitSet(channels, CCC_CHANNEL_5) && prioritizedChannel == UWB_CHANNEL_5) {
+                    builder.addChannel(prioritizedChannel);
+                }
+                if (isBitSet(channels, CCC_CHANNEL_9) && prioritizedChannel == UWB_CHANNEL_9) {
+                    builder.addChannel(prioritizedChannel);
+                }
             }
         } catch (IllegalArgumentException e) {
             Log.w(TAG, "CCC_PRIORITIZED_CHANNEL_LIST not found");
diff --git a/service/java/com/android/server/uwb/params/AliroEncoder.java b/service/java/com/android/server/uwb/params/AliroEncoder.java
index 98f7d6f8..9765d85b 100644
--- a/service/java/com/android/server/uwb/params/AliroEncoder.java
+++ b/service/java/com/android/server/uwb/params/AliroEncoder.java
@@ -113,6 +113,10 @@ public class AliroEncoder extends TlvEncoder {
         if (params.getStsIndex() != AliroParams.STS_INDEX_UNSET) {
             tlvBufferBuilder.putInt(ConfigParam.STS_INDEX, params.getStsIndex());
         }
+        if (params.getHoppingConfigMode() != AliroParams.HOPPING_CONFIG_MODE_NONE
+                && params.getHopModeKey() != AliroParams.HOP_MODE_KEY_UNSET) {
+            tlvBufferBuilder.putInt(ConfigParam.HOP_MODE_KEY, params.getHopModeKey());
+        }
         if (params.getAbsoluteInitiationTimeUs() > 0) {
             tlvBufferBuilder.putLong(ConfigParam.UWB_INITIATION_TIME,
                     params.getAbsoluteInitiationTimeUs());
diff --git a/service/java/com/android/server/uwb/params/CccDecoder.java b/service/java/com/android/server/uwb/params/CccDecoder.java
index 781f15ff..cd64e8bf 100644
--- a/service/java/com/android/server/uwb/params/CccDecoder.java
+++ b/service/java/com/android/server/uwb/params/CccDecoder.java
@@ -140,9 +140,21 @@ public class CccDecoder extends TlvDecoder {
             builder.addProtocolVersion(CccProtocolVersion.fromBytes(versions, i));
         }
         byte[] configs = tlvs.getByteArray(CCC_SUPPORTED_UWB_CONFIGS);
-        for (int i = 0; i < configs.length; i++) {
-            builder.addUwbConfig(configs[i]);
+        if (mUwbInjector.isCccSupportedTwoByteConfigIdLittleEndian()) {
+            if (configs.length % 2 != 0) {
+                throw new IllegalArgumentException("Invalid supported configs len "
+                        + versions.length);
+            }
+            for (int i = 0; i < configs.length; i += 2) {
+                int config = ((configs[i + 1] & 0xff) << 8) + (configs[i] & 0xff);
+                builder.addUwbConfig(config);
+            }
+        } else {
+            for (int i = 0; i < configs.length; i++) {
+                builder.addUwbConfig(configs[i]);
+            }
         }
+
         byte[] pulse_shape_combos = tlvs.getByteArray(CCC_SUPPORTED_PULSE_SHAPE_COMBOS);
         for (int i = 0; i < pulse_shape_combos.length; i++) {
             builder.addPulseShapeCombo(CccPulseShapeCombo.fromBytes(pulse_shape_combos, i));
@@ -201,8 +213,14 @@ public class CccDecoder extends TlvDecoder {
 
         try {
             byte[] prioritizedChannels = tlvs.getByteArray(CCC_PRIORITIZED_CHANNEL_LIST);
+            byte channels = tlvs.getByte(CCC_SUPPORTED_CHANNELS);
             for (byte prioritizedChannel : prioritizedChannels) {
-                builder.addChannel(prioritizedChannel);
+                if (isBitSet(channels, CCC_CHANNEL_5) && prioritizedChannel == UWB_CHANNEL_5) {
+                    builder.addChannel(prioritizedChannel);
+                }
+                if (isBitSet(channels, CCC_CHANNEL_9) && prioritizedChannel == UWB_CHANNEL_9) {
+                    builder.addChannel(prioritizedChannel);
+                }
             }
         } catch (IllegalArgumentException e) {
             Log.w(TAG, "CCC_PRIORITIZED_CHANNEL_LIST not found");
diff --git a/service/java/com/android/server/uwb/params/CccEncoder.java b/service/java/com/android/server/uwb/params/CccEncoder.java
index 9cfabdf3..0daa1c75 100644
--- a/service/java/com/android/server/uwb/params/CccEncoder.java
+++ b/service/java/com/android/server/uwb/params/CccEncoder.java
@@ -113,6 +113,10 @@ public class CccEncoder extends TlvEncoder {
         if (params.getStsIndex() != CccParams.STS_INDEX_UNSET) {
               tlvBufferBuilder.putInt(ConfigParam.STS_INDEX, params.getStsIndex());
         }
+        if (params.getHoppingConfigMode() != CccParams.HOPPING_CONFIG_MODE_NONE
+                && params.getHopModeKey() != CccParams.HOP_MODE_KEY_UNSET) {
+            tlvBufferBuilder.putInt(ConfigParam.HOP_MODE_KEY, params.getHopModeKey());
+        }
         if (params.getAbsoluteInitiationTimeUs() > 0) {
             tlvBufferBuilder.putLong(ConfigParam.UWB_INITIATION_TIME,
                     params.getAbsoluteInitiationTimeUs());
diff --git a/service/java/com/android/server/uwb/params/FiraDecoder.java b/service/java/com/android/server/uwb/params/FiraDecoder.java
index 9c405aff..4345b85c 100644
--- a/service/java/com/android/server/uwb/params/FiraDecoder.java
+++ b/service/java/com/android/server/uwb/params/FiraDecoder.java
@@ -49,6 +49,7 @@ import static com.android.server.uwb.config.CapabilityParam.DYNAMIC_STS_RESPONDE
 import static com.android.server.uwb.config.CapabilityParam.ESS_TWR_NON_DEFERRED;
 import static com.android.server.uwb.config.CapabilityParam.EXTENDED_MAC_ADDRESS;
 import static com.android.server.uwb.config.CapabilityParam.HOPPING_MODE;
+import static com.android.server.uwb.config.CapabilityParam.HYBRID_SCHEDULED_RANGING;
 import static com.android.server.uwb.config.CapabilityParam.INITIATOR;
 import static com.android.server.uwb.config.CapabilityParam.INTERVAL_BASED_SCHEDULING;
 import static com.android.server.uwb.config.CapabilityParam.MANY_TO_MANY;
@@ -558,9 +559,6 @@ public class FiraDecoder extends TlvDecoder {
             if (isBitSet(multiNodeUci, ONE_TO_MANY)) {
                 multiNodeFlag.add(MultiNodeCapabilityFlag.HAS_ONE_TO_MANY_SUPPORT);
             }
-            if (isBitSet(multiNodeUci, MANY_TO_MANY)) {
-                multiNodeFlag.add(MultiNodeCapabilityFlag.HAS_MANY_TO_MANY_SUPPORT);
-            }
             builder.setMultiNodeCapabilities(multiNodeFlag);
 
             byte rangingTimeStructUci = tlvs.getByte(SUPPORTED_RANGING_TIME_STRUCT_VER_2_0);
@@ -583,6 +581,10 @@ public class FiraDecoder extends TlvDecoder {
                 schedulingModeFlag.add(
                         SchedulingModeCapabilitiesFlag.HAS_TIME_SCHEDULED_RANGING_SUPPORT);
             }
+            if (isBitSet(schedulingModeUci, HYBRID_SCHEDULED_RANGING)) {
+                schedulingModeFlag.add(
+                        SchedulingModeCapabilitiesFlag.HAS_HYBRID_SCHEDULED_RANGING_SUPPORT);
+            }
             builder.setSchedulingModeCapabilities(schedulingModeFlag);
 
             byte ccConstraintLengthUci = tlvs.getByte(SUPPORTED_CC_CONSTRAINT_LENGTH_VER_2_0);
diff --git a/service/java/com/android/server/uwb/params/GenericDecoder.java b/service/java/com/android/server/uwb/params/GenericDecoder.java
index c85ccf84..b70b59f8 100644
--- a/service/java/com/android/server/uwb/params/GenericDecoder.java
+++ b/service/java/com/android/server/uwb/params/GenericDecoder.java
@@ -18,6 +18,7 @@ package com.android.server.uwb.params;
 
 import static com.android.server.uwb.config.CapabilityParam.SUPPORTED_ANTENNA_MODES;
 import static com.android.server.uwb.config.CapabilityParam.SUPPORTED_POWER_STATS_QUERY;
+import static com.android.server.uwb.config.CapabilityParam.SUPPORTED_MAX_SESSION_COUNT;
 
 import android.util.Log;
 
@@ -104,6 +105,14 @@ public class GenericDecoder extends TlvDecoder {
         } catch (IllegalArgumentException e) {
             // Do nothing. Mask is set to 0 by default in builder.
         }
+
+        try {
+            int maxSupportedSessionCount = tlvs.getInt(SUPPORTED_MAX_SESSION_COUNT);
+            builder.setMaxSupportedSessionCount(maxSupportedSessionCount);
+        } catch (IllegalArgumentException e) {
+            Log.w(TAG, "SUPPORTED_MAX_SESSION_COUNT not found");
+        }
+
         return builder.build();
     }
 }
diff --git a/service/java/com/android/server/uwb/params/RfTestEncoder.java b/service/java/com/android/server/uwb/params/RfTestEncoder.java
new file mode 100644
index 00000000..48150b27
--- /dev/null
+++ b/service/java/com/android/server/uwb/params/RfTestEncoder.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.uwb.params;
+
+import com.android.server.uwb.config.ConfigParam;
+
+import com.google.uwb.support.base.Params;
+import com.google.uwb.support.rftest.RfTestOpenSessionParams;
+import com.google.uwb.support.base.ProtocolVersion;
+import android.uwb.UwbAddress;
+
+import com.android.modules.utils.build.SdkLevel;
+
+/** RfTest encoder */
+public class RfTestEncoder extends TlvEncoder {
+    @Override
+    public TlvBuffer getTlvBuffer(final Params param, final ProtocolVersion protocolVersion) {
+        if (param instanceof RfTestOpenSessionParams) {
+            return getTlvBufferFromRfTestOpenSessionParams(param);
+        }
+        return null;
+    }
+
+    public TlvBuffer getRfTestTlvBuffer(final Params param) {
+        if (param instanceof RfTestOpenSessionParams) {
+            return getTlvBufferFromRfTestParams(param);
+        }
+        return null;
+    }
+
+    private TlvBuffer getTlvBufferFromRfTestParams(final Params param) {
+        RfTestOpenSessionParams params = (RfTestOpenSessionParams) param;
+
+        TlvBuffer.Builder tlvBufferBuilder = new TlvBuffer.Builder()
+                .putInt(ConfigParam.NUMBER_OF_PACKETS, params.getNumberOfPackets())
+                .putInt(ConfigParam.T_GAP, params.getTgap())
+                .putInt(ConfigParam.T_START, params.getTstart())
+                .putInt(ConfigParam.T_WIN, params.getTwin())
+                .putByte(ConfigParam.RANDOMIZE_PSDU, (byte) params.getRandomizePsdu())
+                .putByte(ConfigParam.PHR_RANGING_BIT, (byte) params.getPhrRangingBit())
+                .putInt(ConfigParam.RMARKER_TX_START, params.getRmarkerTxStart())
+                .putInt(ConfigParam.RMARKER_RX_START, params.getRmarkerRxStart())
+                .putByte(ConfigParam.STS_INDEX_AUTO_INCR, (byte) params.getStsIndexAutoIncr())
+                .putByte(ConfigParam.STS_DETECT_BITMAP, (byte) params.getStsDetectBitmap());
+
+        return tlvBufferBuilder.build();
+    }
+
+    private TlvBuffer getTlvBufferFromRfTestOpenSessionParams(final Params baseParam) {
+        RfTestOpenSessionParams params = (RfTestOpenSessionParams) baseParam;
+
+        TlvBuffer.Builder tlvBufferBuilder = new TlvBuffer.Builder()
+                .putByte(ConfigParam.CHANNEL_NUMBER, (byte) params.getChannelNumber())
+                .putByte(ConfigParam.NUMBER_OF_CONTROLEES,
+                        (byte) params.getDestAddressList().size())
+                .putByteArray(ConfigParam.DEVICE_MAC_ADDRESS, params.getDeviceAddress().size(),
+                    getComputedMacAddress(params.getDeviceAddress()))
+                .putShort(ConfigParam.SLOT_DURATION, (short) params.getSlotDurationRstu())
+                .putInt(ConfigParam.STS_INDEX, params.getStsIndex())
+                .putByte(ConfigParam.MAC_FCS_TYPE, (byte) params.getFcsType())
+                .putByte(ConfigParam.DEVICE_ROLE, (byte) params.getDeviceRole())
+                .putByte(ConfigParam.RFRAME_CONFIG, (byte) params.getRframeConfig())
+                .putByte(ConfigParam.PREAMBLE_CODE_INDEX, (byte) params.getPreambleCodeIndex())
+                .putByte(ConfigParam.SFD_ID, (byte) params.getSfdId())
+                .putByte(ConfigParam.PSDU_DATA_RATE, (byte) params.getPsduDataRate())
+                .putByte(ConfigParam.PREAMBLE_DURATION, (byte) params.getPreambleDuration())
+                .putByte(ConfigParam.PRF_MODE, (byte) params.getPrfMode())
+                .putByte(ConfigParam.NUMBER_OF_STS_SEGMENTS, (byte) params.getStsSegmentCount());
+        return tlvBufferBuilder.build();
+    }
+
+    private static byte[] getComputedMacAddress(final UwbAddress address) {
+        if (!SdkLevel.isAtLeastU()) {
+            return TlvUtil.getReverseBytes(address.toBytes());
+        }
+        return address.toBytes();
+    }
+}
diff --git a/service/java/com/android/server/uwb/params/TlvEncoder.java b/service/java/com/android/server/uwb/params/TlvEncoder.java
index febf1dc2..0e04fbb6 100644
--- a/service/java/com/android/server/uwb/params/TlvEncoder.java
+++ b/service/java/com/android/server/uwb/params/TlvEncoder.java
@@ -24,6 +24,7 @@ import com.google.uwb.support.base.ProtocolVersion;
 import com.google.uwb.support.ccc.CccParams;
 import com.google.uwb.support.fira.FiraParams;
 import com.google.uwb.support.radar.RadarParams;
+import com.google.uwb.support.rftest.RfTestParams;
 
 public abstract class TlvEncoder {
     /**
@@ -42,6 +43,9 @@ public abstract class TlvEncoder {
         if (protocolName.equals(RadarParams.PROTOCOL_NAME)) {
             return new RadarEncoder();
         }
+        if (protocolName.equals(RfTestParams.PROTOCOL_NAME)) {
+            return new RfTestEncoder();
+        }
         return null;
     }
 
diff --git a/service/java/com/android/server/uwb/rftest/RfNotificationEvent.java b/service/java/com/android/server/uwb/rftest/RfNotificationEvent.java
new file mode 100644
index 00000000..ab0bcb90
--- /dev/null
+++ b/service/java/com/android/server/uwb/rftest/RfNotificationEvent.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.uwb.rftest;
+
+import android.os.PersistableBundle;
+
+/**
+ * Interface representing a generic RF Notification event in UWB (Ultra-Wideband) testing.
+ * This interface provides methods to retrieve the raw notification data, status,
+ * operation type, and a conversion to a {@link PersistableBundle} for further processing.
+ *
+ * Implementations of this interface will represent specific types of RF test results
+ * and provide the relevant data and functionality required for handling UWB test notifications.
+ */
+public interface RfNotificationEvent {
+
+    /**
+     * Retrieves the raw notification data associated with this RF notification event.
+     *
+     * @return a byte array containing the raw notification data.
+     */
+    byte[] getRawNotificationData();
+
+    /**
+     * Retrieves the status of the RF notification event.
+     * The status typically indicates the result of the test operation.
+     *
+     * @return an integer representing the status of the RF notification event.
+     */
+    int getStatus();
+
+    /**
+     * Retrieves the operation type associated with this RF notification event.
+     * The operation type indicates the type of test being performed.
+     *
+     * @return an integer representing the RF test operation type.
+     */
+    int getOperationType();
+
+    /**
+     * Converts this RF notification event to a {@link PersistableBundle}.
+     * The bundle can be used for further processing or passing data to other components.
+     *
+     * @return a {@link PersistableBundle} containing the data of this RF notification event.
+     */
+    PersistableBundle toBundle();
+}
+
diff --git a/service/java/com/android/server/uwb/rftest/UwbTestPeriodicTxResult.java b/service/java/com/android/server/uwb/rftest/UwbTestPeriodicTxResult.java
new file mode 100644
index 00000000..312e9483
--- /dev/null
+++ b/service/java/com/android/server/uwb/rftest/UwbTestPeriodicTxResult.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.uwb.rftest;
+
+import android.os.PersistableBundle;
+
+import com.android.server.uwb.util.UwbUtil;
+
+import com.google.uwb.support.rftest.RfTestParams;
+import com.google.uwb.support.rftest.RfTestPeriodicTxResult;
+
+public class UwbTestPeriodicTxResult implements RfNotificationEvent {
+    private int mStatus;
+    private byte[] mRawNotificationData;
+
+    public UwbTestPeriodicTxResult(int status, byte[] rawNotificationData) {
+        this.mStatus = status;
+        this.mRawNotificationData = rawNotificationData;
+    }
+
+    @Override
+    public int getStatus() {
+        return mStatus;
+    }
+
+    @Override
+    public byte[] getRawNotificationData() {
+        return mRawNotificationData;
+    }
+
+    @Override
+    public int getOperationType() {
+        return RfTestParams.TEST_PERIODIC_TX;
+    }
+
+    @Override
+    public PersistableBundle toBundle() {
+        RfTestPeriodicTxResult.Builder periodicRxResult = new RfTestPeriodicTxResult.Builder()
+                .setOperationType(getOperationType())
+                .setStatus(mStatus);
+
+        return periodicRxResult.build().toBundle();
+    }
+
+    @Override
+    public String toString() {
+        return "UwbTestPeriodicTxResult { "
+                + " Status = " + mStatus
+                + ", RfOperationType = " + getOperationType()
+                + ", RawNotificationData = " + UwbUtil.toHexString(mRawNotificationData)
+                + '}';
+    }
+}
diff --git a/service/java/com/android/server/uwb/test/UwbTestLoopBackTestResult.java b/service/java/com/android/server/uwb/test/UwbTestLoopBackTestResult.java
deleted file mode 100644
index 42db4873..00000000
--- a/service/java/com/android/server/uwb/test/UwbTestLoopBackTestResult.java
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* UwbTestLoopBackTestResult is unused now*/
-/*package com.android.server.uwb.test;
-
-import com.android.server.uwb.util.UwbUtil;
-
-public class UwbTestLoopBackTestResult {
-    public int mStatus;
-    public  long mTxtsInt;
-    public  int mTxtsFrac;
-    public  long mRxtsInt;
-    public  int mRxtsFrac;
-    public  float mAoaAzimuth;
-    public  float mAoaElevation;
-    public  int mPhr;
-    public  byte[] mPsduData;
-
-    *//* Vendor Specific Data *//*
-    public byte[] mVendorExtnData;
-
-    public UwbTestLoopBackTestResult(int status, long txtsInt, int txtsFrac, long rxtsInt,
-            int rxtsFrac, int aoaAzimuth, int aoaElevation,  int phr, byte[] psduData,
-            byte[] vendorExtnData) {
-        *//* Vendor Specific data  *//*
-        this.mStatus = status;
-        this.mTxtsInt = txtsInt;
-        this.mTxtsFrac = txtsFrac;
-        this.mRxtsInt = rxtsInt;
-        this.mRxtsFrac = rxtsFrac;
-        this.mAoaAzimuth =
-                UwbUtil.convertQFormatToFloat(UwbUtil.twos_compliment(aoaAzimuth, 16), 9, 7);
-        this.mAoaElevation =
-                UwbUtil.convertQFormatToFloat(UwbUtil.twos_compliment(aoaElevation, 16), 9, 7);
-        this.mPhr = phr;
-        this.mPsduData = psduData;
-
-        *//* Vendor Specific Data *//*
-        this.mVendorExtnData = vendorExtnData;
-
-    }
-
-    public int getStatus() {
-        return mStatus;
-    }
-
-
-    public long getTxTsInt() {
-        return mTxtsInt;
-    }
-
-    public int getTxTsFrac() {
-        return mTxtsFrac;
-    }
-
-    public long getRxTsInt() {
-        return mRxtsInt;
-    }
-
-    public int getRxTsFrac() {
-        return mRxtsFrac;
-    }
-
-    public float getAoaAzimuth() {
-        return mAoaAzimuth;
-    }
-
-    public float getAoaElevation() {
-        return mAoaElevation;
-    }
-
-    public int getPhr() {
-        return mPhr;
-    }
-
-    public byte[] getPsduData() {
-        return mPsduData;
-    }
-
-    *//* Vendor Specific Data *//*
-
-    public byte[] getVendorExtnData() {
-        return mVendorExtnData;
-    }
-
-    @Override
-    public String toString() {
-        return " UwbTestLoopBackTestResult { "
-                + " Status = " + mStatus
-                + ", TxtsInt = " + mTxtsInt
-                + ", TxtsFrac = " + mTxtsFrac
-                + ", RxtsInt = " + mRxtsInt
-                + ", RxtsFrac = " + mRxtsFrac
-                + ", AoaAzimuth = " + mAoaAzimuth
-                + ", AoaElevation = " + mAoaElevation
-                + ", Phr = " + mPhr
-                + ", PsduData = " + UwbUtil.toHexString(mPsduData)
-                + *//* Vendor Specific Data *//*
-                ", VendorExtnData = " + UwbUtil.toHexString(mVendorExtnData)
-                + '}';
-    }
-}*/
diff --git a/service/java/com/android/server/uwb/test/UwbTestPeriodicTxResult.java b/service/java/com/android/server/uwb/test/UwbTestPeriodicTxResult.java
deleted file mode 100644
index bea32c83..00000000
--- a/service/java/com/android/server/uwb/test/UwbTestPeriodicTxResult.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* UwbTestPeriodicTxResult is unused now*/
-/*package com.android.server.uwb.test;
-
-public class UwbTestPeriodicTxResult {
-    public int mStatus;
-
-    public UwbTestPeriodicTxResult(int status) {
-        this.mStatus = status;
-    }
-
-    public int getStatus() {
-        return mStatus;
-    }
-
-    public void setStatus(int status) {
-        this.mStatus = status;
-    }
-
-    @Override
-    public String toString() {
-        return "UwbTestPeriodicTxResult { "
-                + " Status = " + mStatus
-                + '}';
-    }
-}*/
diff --git a/service/java/com/android/server/uwb/test/UwbTestRxPacketErrorRateResult.java b/service/java/com/android/server/uwb/test/UwbTestRxPacketErrorRateResult.java
deleted file mode 100644
index 636a7cbd..00000000
--- a/service/java/com/android/server/uwb/test/UwbTestRxPacketErrorRateResult.java
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* UwbTestRxPacketErrorRateResult is unused now*/
-/*package com.android.server.uwb.test;
-
-import com.android.server.uwb.util.UwbUtil;
-
-public class UwbTestRxPacketErrorRateResult {
-    public int mStatus;
-    public long mAttempts;
-    public long mAcqDetect;
-    public long mAcqReject;
-    public long mRxFail;
-    public long mSyncCirReady;
-    public long mSfdFail;
-    public long mSfdFound;
-    public long mPhrDecError;
-    public long mPhrBitError;
-    public long mPsduDecError;
-    public long mPsduBitError;
-    public long mStsFound;
-    public long mEof;
-    *//* Vendor Specific Data *//*
-    public byte[] mVendorExtnData;
-
-    public UwbTestRxPacketErrorRateResult(int status, long attempts, long acqDetect,
-            long acqReject, long rxFail, long syncCirReady, long sfdFail, long sfdFound,
-            long phrDecError, long phrBitError, long psduDecError, long psduBitError, long stsFound,
-            long eof, byte[] vendorExtnData) {
-        this.mStatus = status;
-        this.mAttempts = attempts;
-        this.mAcqDetect = acqDetect;
-        this.mAcqReject = acqReject;
-        this.mRxFail = rxFail;
-        this.mSyncCirReady = syncCirReady;
-        this.mSfdFail = sfdFail;
-        this.mSfdFound = sfdFound;
-        this.mPhrDecError = phrDecError;
-        this.mPhrBitError = phrBitError;
-        this.mPsduDecError = psduDecError;
-        this.mPsduBitError = psduBitError;
-        this.mStsFound = stsFound;
-        this.mEof = eof;
-
-        *//* Vendor Specific Data *//*
-        this.mVendorExtnData = vendorExtnData;
-    }
-
-    public int getStatus() {
-        return mStatus;
-    }
-
-    public long getAttempts() {
-        return mAttempts;
-    }
-
-    public long getAcqDetect() {
-        return mAcqDetect;
-    }
-
-    public long getAcqReject() {
-        return mAcqReject;
-    }
-
-    public long getRxFail() {
-        return mRxFail;
-    }
-
-    public long getSyncCirReady() {
-        return mSyncCirReady;
-    }
-
-    public long getSfdFail() {
-        return mSfdFail;
-    }
-
-    public long getSfdFound() {
-        return mSfdFound;
-    }
-
-    public long getPhrDecError() {
-        return mPhrDecError;
-    }
-
-    public long getPhrBitError() {
-        return mPhrBitError;
-    }
-
-    public long getPsduDecError() {
-        return mPsduDecError;
-    }
-
-    public long getPsduBitError() {
-        return mPsduBitError;
-    }
-
-    public long getStsFound() {
-        return mStsFound;
-    }
-
-    public long getEof() {
-        return mEof;
-    }
-
-    *//* Vendor Specific Data *//*
-
-    public byte[] getVendorExtnData() {
-        return mVendorExtnData;
-    }
-
-
-    @Override
-    public String toString() {
-        return " UwbTestRxPacketErrorRateResult { "
-                + " Status = " + mStatus
-                + ", Attempts = " + mAttempts
-                + ", AcqDetect = " + mAcqDetect
-                + ", AcqReject = " + mAcqReject
-                + ", RxFail = " + mRxFail
-                + ", SyncCirReady = " + mSyncCirReady
-                + ", SfdFail = " + mSfdFail
-                + ", SfdFound = " + mSfdFound
-                + ", PhrDecError = " + mPhrDecError
-                + ", PhrBitError = " + mPhrBitError
-                + ", PsduDecError = " + mPsduDecError
-                + ", PsduBitError = " + mPsduBitError
-                + ", StsFound = " + mStsFound
-                + ", Eof = " + mEof
-                + ", VendorExtnData = " + UwbUtil.toHexString(mVendorExtnData)
-                + '}';
-    }
-
-}*/
diff --git a/service/java/com/android/server/uwb/test/UwbTestRxResult.java b/service/java/com/android/server/uwb/test/UwbTestRxResult.java
deleted file mode 100644
index ab97eaeb..00000000
--- a/service/java/com/android/server/uwb/test/UwbTestRxResult.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright (C) 2021 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/* UwbTestRxResult is unused now*/
-/*package com.android.server.uwb.test;
-
-import com.android.server.uwb.util.UwbUtil;
-
-public class UwbTestRxResult {
-    public int mStatus;
-    public long mRxDoneTsInt;
-    public int mRxDoneTsFrac;
-    public float mAoaAzimuth;
-    public float mAoaElevation;
-    public int mToaGap;
-    public int mPhr;
-    public byte[] mPsduData;
-    public byte[] mVendorExtnData;
-
-    public UwbTestRxResult(int status, long rxDoneTsInt, int rxDoneTsFrac,
-            int aoaAzimuth, int aoaElevation, int toaGap, int phr, byte[] psduData,
-            byte[] vendorExtnData) {
-
-        this.mStatus = status;
-        this.mRxDoneTsInt = rxDoneTsInt;
-        this.mRxDoneTsFrac = rxDoneTsFrac;
-        this.mAoaAzimuth =
-                UwbUtil.convertQFormatToFloat(UwbUtil.twos_compliment(aoaAzimuth, 16), 9, 7);
-        this.mAoaElevation =
-                UwbUtil.convertQFormatToFloat(UwbUtil.twos_compliment(aoaElevation, 16), 9, 7);
-        this.mToaGap = toaGap;
-        this.mPhr = phr;
-        this.mPsduData = psduData;
-
-        *//* Vendor Specific Data *//*
-        this.mVendorExtnData = vendorExtnData;
-
-    }
-
-    public int getStatus() {
-        return mStatus;
-    }
-
-    public long getRxDoneTsInt() {
-        return mRxDoneTsInt;
-    }
-
-    public int getRxDoneTsFrac() {
-        return mRxDoneTsFrac;
-    }
-
-    public float getAoaAzimuth() {
-        return mAoaAzimuth;
-    }
-
-    public float getAoaElevation() {
-        return mAoaElevation;
-    }
-
-    public int getToaGap() {
-        return mToaGap;
-    }
-
-    public int getPhr() {
-        return mPhr;
-    }
-
-    public byte[] getPsduData() {
-        return mPsduData;
-    }
-
-    *//* Vendor Specific Data *//*
-
-    public byte[] getVendorExtnData() {
-        return mVendorExtnData;
-    }
-
-    @Override
-    public String toString() {
-        return " UwbTestRxResult { "
-                + " Status = " + mStatus
-                + ", RxDoneTsInt = " + mRxDoneTsInt
-                + ", RxDoneTsFrac = " + mRxDoneTsFrac
-                + ", AoaAzimuth = " + mAoaAzimuth
-                + ", AoaElevation = " + mAoaElevation
-                + ", ToaGap = " + mToaGap
-                + ", Phr = " + mPhr
-                + ", PsduData = " + UwbUtil.toHexString(mPsduData)
-                + ", VendorExtnData = " + UwbUtil.toHexString(mVendorExtnData)
-                + '}';
-    }
-}*/
diff --git a/service/proguard.flags b/service/proguard.flags
index a5643104..2fa07687 100644
--- a/service/proguard.flags
+++ b/service/proguard.flags
@@ -1,2 +1,3 @@
 -keep class com.android.server.uwb.data.** { public <methods>; }
--keep class com.android.server.uwb.info.** { public <methods>; }
\ No newline at end of file
+-keep class com.android.server.uwb.info.** { public <methods>; }
+-keep class com.android.server.uwb.rftest.** { public <methods>; }
\ No newline at end of file
diff --git a/service/support_lib/Android.bp b/service/support_lib/Android.bp
index 6b548aae..1504e46f 100644
--- a/service/support_lib/Android.bp
+++ b/service/support_lib/Android.bp
@@ -156,3 +156,15 @@ java_library {
         "com.uwb.support.fira",
     ],
 }
+
+java_library {
+    name: "com.uwb.support.rftest",
+    defaults: ["support-lib-uwb-common-defaults"],
+    srcs: [
+        "src/com/google/uwb/support/rftest/**/*.java",
+    ],
+    static_libs: [
+        "com.uwb.support.base",
+        "com.uwb.support.fira",
+    ],
+}
diff --git a/service/support_lib/src/com/google/uwb/support/aliro/AliroOpenRangingParams.java b/service/support_lib/src/com/google/uwb/support/aliro/AliroOpenRangingParams.java
index dc658899..bd1f0c38 100644
--- a/service/support_lib/src/com/google/uwb/support/aliro/AliroOpenRangingParams.java
+++ b/service/support_lib/src/com/google/uwb/support/aliro/AliroOpenRangingParams.java
@@ -57,6 +57,7 @@ public class AliroOpenRangingParams extends AliroParams {
     private static final String KEY_NUM_RESPONDER_NODES = "num_responder_nodes";
     private static final String KEY_NUM_SLOTS_PER_ROUND = "num_slots_per_round";
     private static final String KEY_SYNC_CODE_INDEX = "sync_code_index";
+    private static final String KEY_HOP_MODE_KEY = "hop_mode_key";
     private static final String KEY_HOPPING_CONFIG_MODE = "hopping_config_mode";
     private static final String KEY_HOPPING_SEQUENCE = "hopping_sequence";
     private static final String KEY_STS_INDEX = "sts_index";
@@ -85,6 +86,7 @@ public class AliroOpenRangingParams extends AliroParams {
     private final int mNumResponderNodes;
     private final int mNumSlotsPerRound;
     @SyncCodeIndex private final int mSyncCodeIndex;
+    private final int mHopModeKey;
     @HoppingConfigMode private final int mHoppingConfigMode;
     @HoppingSequence private final int mHoppingSequence;
     private final int mStsIndex;
@@ -116,6 +118,7 @@ public class AliroOpenRangingParams extends AliroParams {
             int numResponderNodes,
             int numSlotsPerRound,
             @SyncCodeIndex int syncCodeIndex,
+            int hopModeKey,
             @HoppingConfigMode int hoppingConfigMode,
             @HoppingSequence int hoppingSequence,
             int stsIndex,
@@ -139,6 +142,7 @@ public class AliroOpenRangingParams extends AliroParams {
         mNumResponderNodes = numResponderNodes;
         mNumSlotsPerRound = numSlotsPerRound;
         mSyncCodeIndex = syncCodeIndex;
+        mHopModeKey = hopModeKey;
         mHoppingConfigMode = hoppingConfigMode;
         mHoppingSequence = hoppingSequence;
         mStsIndex = stsIndex;
@@ -172,6 +176,7 @@ public class AliroOpenRangingParams extends AliroParams {
         bundle.putInt(KEY_NUM_RESPONDER_NODES, mNumResponderNodes);
         bundle.putInt(KEY_NUM_SLOTS_PER_ROUND, mNumSlotsPerRound);
         bundle.putInt(KEY_SYNC_CODE_INDEX, mSyncCodeIndex);
+        bundle.putInt(KEY_HOP_MODE_KEY, mHopModeKey);
         bundle.putInt(KEY_HOPPING_CONFIG_MODE, mHoppingConfigMode);
         bundle.putInt(KEY_HOPPING_SEQUENCE, mHoppingSequence);
         bundle.putInt(KEY_STS_INDEX, mStsIndex);
@@ -217,6 +222,7 @@ public class AliroOpenRangingParams extends AliroParams {
                 .setNumResponderNodes(bundle.getInt(KEY_NUM_RESPONDER_NODES))
                 .setNumSlotsPerRound(bundle.getInt(KEY_NUM_SLOTS_PER_ROUND))
                 .setSyncCodeIndex(bundle.getInt(KEY_SYNC_CODE_INDEX))
+                .setHopModeKey(bundle.getInt(KEY_HOP_MODE_KEY))
                 .setHoppingConfigMode(bundle.getInt(KEY_HOPPING_CONFIG_MODE))
                 .setHoppingSequence(bundle.getInt(KEY_HOPPING_SEQUENCE))
                 .setStsIndex(bundle.getInt(KEY_STS_INDEX))
@@ -294,6 +300,10 @@ public class AliroOpenRangingParams extends AliroParams {
         return mSyncCodeIndex;
     }
 
+    public int getHopModeKey() {
+        return mHopModeKey;
+    }
+
     @HoppingConfigMode
     public int getHoppingConfigMode() {
         return mHoppingConfigMode;
@@ -374,6 +384,7 @@ public class AliroOpenRangingParams extends AliroParams {
         private long mInitiationTimeMs = 0;
         private long mAbsoluteInitiationTimeUs = 0;
 
+        private int mHopModeKey = 0;
         /** ALIRO default: Ranging notification disabled. */
         @RangeDataNtfConfig private int mRangeDataNtfConfig = RANGE_DATA_NTF_CONFIG_DISABLE;
 
@@ -409,6 +420,7 @@ public class AliroOpenRangingParams extends AliroParams {
             mNumResponderNodes.set(builder.mNumResponderNodes.get());
             mNumSlotsPerRound.set(builder.mNumSlotsPerRound.get());
             mSyncCodeIndex.set(builder.mSyncCodeIndex.get());
+            mHopModeKey = builder.mHopModeKey;
             mHoppingConfigMode.set(builder.mHoppingConfigMode.get());
             mHoppingSequence.set(builder.mHoppingSequence.get());
             mStsIndex = builder.mStsIndex;
@@ -435,6 +447,7 @@ public class AliroOpenRangingParams extends AliroParams {
             mNumResponderNodes.set(params.mNumResponderNodes);
             mNumSlotsPerRound.set(params.mNumSlotsPerRound);
             mSyncCodeIndex.set(params.mSyncCodeIndex);
+            mHopModeKey = params.mHopModeKey;
             mHoppingConfigMode.set(params.mHoppingConfigMode);
             mHoppingSequence.set(params.mHoppingSequence);
             mRangeDataNtfConfig = params.mRangeDataNtfConfig;
@@ -496,6 +509,12 @@ public class AliroOpenRangingParams extends AliroParams {
             return this;
         }
 
+        /** Sets hop mode key. */
+        public Builder setHopModeKey(int hopModeKey) {
+            mHopModeKey = hopModeKey;
+            return this;
+        }
+
         public Builder setHoppingConfigMode(@HoppingConfigMode int hoppingConfigMode) {
             mHoppingConfigMode.set(hoppingConfigMode);
             return this;
@@ -654,6 +673,7 @@ public class AliroOpenRangingParams extends AliroParams {
                     mNumResponderNodes.get(),
                     mNumSlotsPerRound.get(),
                     mSyncCodeIndex.get(),
+                    mHopModeKey,
                     mHoppingConfigMode.get(),
                     mHoppingSequence.get(),
                     mStsIndex,
diff --git a/service/support_lib/src/com/google/uwb/support/aliro/AliroParams.java b/service/support_lib/src/com/google/uwb/support/aliro/AliroParams.java
index 62781b03..2690ad7d 100644
--- a/service/support_lib/src/com/google/uwb/support/aliro/AliroParams.java
+++ b/service/support_lib/src/com/google/uwb/support/aliro/AliroParams.java
@@ -246,4 +246,6 @@ public abstract class AliroParams extends Params {
     public static final long UWB_INITIATION_TIME_MS_UNSET = 0;
 
     public static final int STS_INDEX_UNSET = 0;
+
+    public static final int HOP_MODE_KEY_UNSET = 0;
 }
diff --git a/service/support_lib/src/com/google/uwb/support/ccc/CccOpenRangingParams.java b/service/support_lib/src/com/google/uwb/support/ccc/CccOpenRangingParams.java
index 95176358..6457eaee 100644
--- a/service/support_lib/src/com/google/uwb/support/ccc/CccOpenRangingParams.java
+++ b/service/support_lib/src/com/google/uwb/support/ccc/CccOpenRangingParams.java
@@ -59,6 +59,7 @@ public class CccOpenRangingParams extends CccParams {
     private static final String KEY_SYNC_CODE_INDEX = "sync_code_index";
     private static final String KEY_HOPPING_CONFIG_MODE = "hopping_config_mode";
     private static final String KEY_HOPPING_SEQUENCE = "hopping_sequence";
+    private static final String KEY_HOP_MODE_KEY = "hop_mode_key";
     private static final String KEY_STS_INDEX = "sts_index";
     private static final String KEY_INITIATION_TIME_MS = "initiation_time_ms";
     private static final String KEY_ABSOLUTE_INITIATION_TIME_US = "absolute_initiation_time_us";
@@ -95,6 +96,8 @@ public class CccOpenRangingParams extends CccParams {
     // FiRa 2.0: Absolute time in UWB time domain, as specified in CR-272 (in micro-seconds).
     private final long mAbsoluteInitiationTimeUs;
 
+    private final int mHopModeKey;
+
     // RANGE_DATA_NTF_CONFIG related fields.
     @RangeDataNtfConfig private final int mRangeDataNtfConfig;
     private final int mRangeDataNtfProximityNear;
@@ -116,6 +119,7 @@ public class CccOpenRangingParams extends CccParams {
             int numResponderNodes,
             int numSlotsPerRound,
             @SyncCodeIndex int syncCodeIndex,
+            int hopModeKey,
             @HoppingConfigMode int hoppingConfigMode,
             @HoppingSequence int hoppingSequence,
             int stsIndex,
@@ -134,6 +138,7 @@ public class CccOpenRangingParams extends CccParams {
         mSessionId = sessionId;
         mSessionType = sessionType;
         mRanMultiplier = ranMultiplier;
+        mHopModeKey = hopModeKey;
         mChannel = channel;
         mNumChapsPerSlot = numChapsPerSlot;
         mNumResponderNodes = numResponderNodes;
@@ -172,6 +177,7 @@ public class CccOpenRangingParams extends CccParams {
         bundle.putInt(KEY_NUM_RESPONDER_NODES, mNumResponderNodes);
         bundle.putInt(KEY_NUM_SLOTS_PER_ROUND, mNumSlotsPerRound);
         bundle.putInt(KEY_SYNC_CODE_INDEX, mSyncCodeIndex);
+        bundle.putInt(KEY_HOP_MODE_KEY, mHopModeKey);
         bundle.putInt(KEY_HOPPING_CONFIG_MODE, mHoppingConfigMode);
         bundle.putInt(KEY_HOPPING_SEQUENCE, mHoppingSequence);
         bundle.putInt(KEY_STS_INDEX, mStsIndex);
@@ -217,6 +223,7 @@ public class CccOpenRangingParams extends CccParams {
                 .setNumResponderNodes(bundle.getInt(KEY_NUM_RESPONDER_NODES))
                 .setNumSlotsPerRound(bundle.getInt(KEY_NUM_SLOTS_PER_ROUND))
                 .setSyncCodeIndex(bundle.getInt(KEY_SYNC_CODE_INDEX))
+                .setHopModeKey(bundle.getInt(KEY_HOP_MODE_KEY))
                 .setHoppingConfigMode(bundle.getInt(KEY_HOPPING_CONFIG_MODE))
                 .setHoppingSequence(bundle.getInt(KEY_HOPPING_SEQUENCE))
                 .setStsIndex(bundle.getInt(KEY_STS_INDEX))
@@ -294,6 +301,10 @@ public class CccOpenRangingParams extends CccParams {
         return mSyncCodeIndex;
     }
 
+    public int getHopModeKey() {
+        return mHopModeKey;
+    }
+
     @HoppingConfigMode
     public int getHoppingConfigMode() {
         return mHoppingConfigMode;
@@ -374,6 +385,8 @@ public class CccOpenRangingParams extends CccParams {
         private long mInitiationTimeMs = 0;
         private long mAbsoluteInitiationTimeUs = 0;
 
+        private int mHopModeKey = 0;
+
         /** CCC default: Ranging notification enabled. */
         @RangeDataNtfConfig private int mRangeDataNtfConfig = RANGE_DATA_NTF_CONFIG_DISABLE;
 
@@ -409,6 +422,7 @@ public class CccOpenRangingParams extends CccParams {
             mNumResponderNodes.set(builder.mNumResponderNodes.get());
             mNumSlotsPerRound.set(builder.mNumSlotsPerRound.get());
             mSyncCodeIndex.set(builder.mSyncCodeIndex.get());
+            mHopModeKey = builder.mHopModeKey;
             mHoppingConfigMode.set(builder.mHoppingConfigMode.get());
             mHoppingSequence.set(builder.mHoppingSequence.get());
             mStsIndex = builder.mStsIndex;
@@ -435,6 +449,7 @@ public class CccOpenRangingParams extends CccParams {
             mNumResponderNodes.set(params.mNumResponderNodes);
             mNumSlotsPerRound.set(params.mNumSlotsPerRound);
             mSyncCodeIndex.set(params.mSyncCodeIndex);
+            mHopModeKey = params.mHopModeKey;
             mHoppingConfigMode.set(params.mHoppingConfigMode);
             mHoppingSequence.set(params.mHoppingSequence);
             mRangeDataNtfConfig = params.mRangeDataNtfConfig;
@@ -496,6 +511,12 @@ public class CccOpenRangingParams extends CccParams {
             return this;
         }
 
+        /** Sets hop mode key. */
+        public Builder setHopModeKey(int hopModeKey) {
+            mHopModeKey = hopModeKey;
+            return this;
+        }
+
         public Builder setHoppingConfigMode(@HoppingConfigMode int hoppingConfigMode) {
             mHoppingConfigMode.set(hoppingConfigMode);
             return this;
@@ -654,6 +675,7 @@ public class CccOpenRangingParams extends CccParams {
                     mNumResponderNodes.get(),
                     mNumSlotsPerRound.get(),
                     mSyncCodeIndex.get(),
+                    mHopModeKey,
                     mHoppingConfigMode.get(),
                     mHoppingSequence.get(),
                     mStsIndex,
diff --git a/service/support_lib/src/com/google/uwb/support/ccc/CccParams.java b/service/support_lib/src/com/google/uwb/support/ccc/CccParams.java
index 70f78783..029f1385 100644
--- a/service/support_lib/src/com/google/uwb/support/ccc/CccParams.java
+++ b/service/support_lib/src/com/google/uwb/support/ccc/CccParams.java
@@ -242,4 +242,6 @@ public abstract class CccParams extends Params {
     public static final long UWB_INITIATION_TIME_MS_UNSET = 0;
 
     public static final int STS_INDEX_UNSET = 0;
+
+    public static final int HOP_MODE_KEY_UNSET = 0;
 }
diff --git a/service/support_lib/src/com/google/uwb/support/fira/FiraOpenSessionParams.java b/service/support_lib/src/com/google/uwb/support/fira/FiraOpenSessionParams.java
index d4ec5f08..0f34ac9f 100644
--- a/service/support_lib/src/com/google/uwb/support/fira/FiraOpenSessionParams.java
+++ b/service/support_lib/src/com/google/uwb/support/fira/FiraOpenSessionParams.java
@@ -29,9 +29,12 @@ import androidx.annotation.FloatRange;
 import androidx.annotation.IntRange;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
+import androidx.annotation.VisibleForTesting;
 
+import com.google.common.primitives.Longs;
 import com.google.uwb.support.base.RequiredParam;
 
+import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -1579,6 +1582,11 @@ public class FiraOpenSessionParams extends FiraParams {
             return this;
         }
 
+        /** @param sessionId must be non-negative and fit in 32 bit unsigned integer. */
+        public FiraOpenSessionParams.Builder setSessionId(long sessionId) {
+            return setSessionId(asUnsigned(sessionId));
+        }
+
         public FiraOpenSessionParams.Builder setSessionType(@SessionType int sessionType) {
             mSessionType = sessionType;
             return this;
@@ -1815,6 +1823,11 @@ public class FiraOpenSessionParams extends FiraParams {
             return this;
         }
 
+        /** @param subSessionId must be non-negative and fit in 32 bit unsigned integer. */
+        public FiraOpenSessionParams.Builder setSubSessionId(long subSessionId) {
+            return setSubSessionId(asUnsigned(subSessionId));
+        }
+
         public FiraOpenSessionParams.Builder setVendorId(@Nullable byte[] vendorId) {
             mVendorId = vendorId;
             return this;
@@ -2061,6 +2074,7 @@ public class FiraOpenSessionParams extends FiraParams {
             return this;
         }
 
+
         public FiraOpenSessionParams.Builder setSessionTimeBase(int referenceTimeBase,
                 int referenceSessionHandle, int sessionOffsetInMicroSecond) {
             mReferenceTimeBase = referenceTimeBase;
@@ -2069,6 +2083,16 @@ public class FiraOpenSessionParams extends FiraParams {
             return this;
         }
 
+        /**
+         * @param referenceSessionHandle must be non-negative and fit in 32 bit unsigned integer.
+         */
+        public FiraOpenSessionParams.Builder setSessionTimeBase(
+                int referenceTimeBase, long referenceSessionHandle,
+                int sessionOffsetInMicroSecond) {
+            return setSessionTimeBase(referenceTimeBase, asUnsigned(referenceSessionHandle),
+                    sessionOffsetInMicroSecond);
+        }
+
         public FiraOpenSessionParams.Builder setApplicationDataEndpoint(
                 int applicationDataEndpoint) {
             mApplicationDataEndpoint = applicationDataEndpoint;
@@ -2225,6 +2249,21 @@ public class FiraOpenSessionParams extends FiraParams {
             return false;
         }
 
+        /**
+         * Reinterprets the least significant 32 bits of the input as an unsigned integer and
+         * returns the result as a signed integer.
+         *
+         * @param x input treated as unsigned 32 bit integer.
+         * @return a (signed) integer interpretation of the input's underlying bytes.
+         */
+        @VisibleForTesting
+        public static int asUnsigned(long x) {
+            checkArgument(x >= 0, "Input was negative");
+            checkArgument(x < 1L << 32, "Input does not fit in an unsigned 32 bit integer");
+
+            return ByteBuffer.wrap(Longs.toByteArray(x)).getInt(4);
+        }
+
         public FiraOpenSessionParams build() {
             checkAddress();
             checkStsConfig();
diff --git a/service/support_lib/src/com/google/uwb/support/fira/FiraParams.java b/service/support_lib/src/com/google/uwb/support/fira/FiraParams.java
index 4558943b..124e6d4d 100644
--- a/service/support_lib/src/com/google/uwb/support/fira/FiraParams.java
+++ b/service/support_lib/src/com/google/uwb/support/fira/FiraParams.java
@@ -857,7 +857,8 @@ public abstract class FiraParams extends Params {
 
     public enum SchedulingModeCapabilitiesFlag implements FlagEnum {
         HAS_CONTENTION_BASED_RANGING_SUPPORT(1),
-        HAS_TIME_SCHEDULED_RANGING_SUPPORT(1 << 1);
+        HAS_TIME_SCHEDULED_RANGING_SUPPORT(1 << 1),
+        HAS_HYBRID_SCHEDULED_RANGING_SUPPORT(1 << 2);
 
         private final long mValue;
 
@@ -1145,6 +1146,8 @@ public abstract class FiraParams extends Params {
     public static final int SESSION_TIME_BASE_PARAM_LEN = 9;
     public static final int SESSION_HANDLE_LEN = 4;
     public static final int SESSION_OFFSET_TIME_LEN = 4;
+    public static final int SEQUENCE_NUMBER_LENGTH = 2;
+    public static final int DATA_MSG_LENGTH = 2;
 
     // Default value (Host as the both secure & non-secure endpoint).
     public static final int APPLICATION_DATA_ENDPOINT_DEFAULT = 0;
diff --git a/service/support_lib/src/com/google/uwb/support/fira/FiraSpecificationParams.java b/service/support_lib/src/com/google/uwb/support/fira/FiraSpecificationParams.java
index 8b6d9c6d..77afedcd 100644
--- a/service/support_lib/src/com/google/uwb/support/fira/FiraSpecificationParams.java
+++ b/service/support_lib/src/com/google/uwb/support/fira/FiraSpecificationParams.java
@@ -654,7 +654,8 @@ public class FiraSpecificationParams extends FiraParams {
         private EnumSet<SchedulingModeCapabilitiesFlag> mSchedulingModeCapabilities =
                 EnumSet.of(
                         SchedulingModeCapabilitiesFlag.HAS_CONTENTION_BASED_RANGING_SUPPORT,
-                        SchedulingModeCapabilitiesFlag.HAS_TIME_SCHEDULED_RANGING_SUPPORT);
+                        SchedulingModeCapabilitiesFlag.HAS_TIME_SCHEDULED_RANGING_SUPPORT,
+                        SchedulingModeCapabilitiesFlag.HAS_HYBRID_SCHEDULED_RANGING_SUPPORT);
 
         private EnumSet<CcConstraintLengthCapabilitiesFlag> mCcConstraintLengthCapabilities =
                 EnumSet.of(
diff --git a/service/support_lib/src/com/google/uwb/support/generic/GenericSpecificationParams.java b/service/support_lib/src/com/google/uwb/support/generic/GenericSpecificationParams.java
index 7da3dac2..2a568982 100644
--- a/service/support_lib/src/com/google/uwb/support/generic/GenericSpecificationParams.java
+++ b/service/support_lib/src/com/google/uwb/support/generic/GenericSpecificationParams.java
@@ -50,6 +50,7 @@ public class GenericSpecificationParams extends GenericParams {
     private final AliroSpecificationParams mAliroSpecificationParams;
     private final RadarSpecificationParams mRadarSpecificationParams;
     private final boolean mHasPowerStatsSupport;
+    private final int mMaxSupportedSessionCount;
     private final EnumSet<AntennaModeCapabilityFlag> mAntennaModeCapabilities;
 
     private static final String KEY_FIRA_SPECIFICATION_PARAMS = FiraParams.PROTOCOL_NAME;
@@ -58,6 +59,9 @@ public class GenericSpecificationParams extends GenericParams {
     private static final String KEY_RADAR_SPECIFICATION_PARAMS = RadarParams.PROTOCOL_NAME;
     private static final String KEY_POWER_STATS_QUERY_SUPPORT = "power_stats_query";
     private static final String KEY_SUPPORTED_ANTENNA_MODES = "supported_antenna_modes";
+    private static final String KEY_MAX_SUPPORTED_SESSION_COUNT = "max_supported_session_count";
+
+    public static final int DEFAULT_MAX_SUPPORTED_SESSIONS_COUNT = 5;
 
     private GenericSpecificationParams(Builder builder) {
         mFiraSpecificationParams = builder.mFiraSpecificationParams;
@@ -66,6 +70,7 @@ public class GenericSpecificationParams extends GenericParams {
         mRadarSpecificationParams = builder.mRadarSpecificationParams;
         mHasPowerStatsSupport = builder.mHasPowerStatsSupport;
         mAntennaModeCapabilities = builder.mAntennaModeCapabilities;
+        mMaxSupportedSessionCount = builder.mMaxSupportedSessionCount;
     }
 
     @Override
@@ -105,6 +110,10 @@ public class GenericSpecificationParams extends GenericParams {
         return mAntennaModeCapabilities;
     }
 
+    public int getMaxSupportedSessionCount() {
+        return mMaxSupportedSessionCount;
+    }
+
     public void setFiraSpecificationParams(FiraSpecificationParams params) {
         mFiraSpecificationParams = params;
     }
@@ -128,6 +137,7 @@ public class GenericSpecificationParams extends GenericParams {
         }
         bundle.putBoolean(KEY_POWER_STATS_QUERY_SUPPORT, mHasPowerStatsSupport);
         bundle.putInt(KEY_SUPPORTED_ANTENNA_MODES, FlagEnum.toInt(mAntennaModeCapabilities));
+        bundle.putInt(KEY_MAX_SUPPORTED_SESSION_COUNT, mMaxSupportedSessionCount);
         return bundle;
     }
 
@@ -146,6 +156,7 @@ public class GenericSpecificationParams extends GenericParams {
                 .setAntennaModeCapabilities(FlagEnum.toEnumSet(
                         bundle.getInt(KEY_SUPPORTED_ANTENNA_MODES, 0),
                         AntennaModeCapabilityFlag.values()))
+                .setMaxSupportedSessionCount(bundle.getInt(KEY_MAX_SUPPORTED_SESSION_COUNT))
                 .hasPowerStatsSupport(bundle.getBoolean(KEY_POWER_STATS_QUERY_SUPPORT));
 
         builder = builder.setFiraSpecificationParams(
@@ -183,6 +194,7 @@ public class GenericSpecificationParams extends GenericParams {
         private boolean mHasPowerStatsSupport = false;
         private EnumSet<AntennaModeCapabilityFlag> mAntennaModeCapabilities =
                 EnumSet.noneOf(AntennaModeCapabilityFlag.class);
+        private int mMaxSupportedSessionCount = DEFAULT_MAX_SUPPORTED_SESSIONS_COUNT;
 
         /**
          * Set FIRA specification params
@@ -237,6 +249,14 @@ public class GenericSpecificationParams extends GenericParams {
             return this;
         }
 
+        /**
+         * Sets the maximum supported session count
+         */
+        public Builder setMaxSupportedSessionCount(int value) {
+            mMaxSupportedSessionCount = value;
+            return this;
+        }
+
         /**
          * Build {@link GenericSpecificationParams}
          */
diff --git a/service/support_lib/src/com/google/uwb/support/oemextension/RfTestNotification.java b/service/support_lib/src/com/google/uwb/support/oemextension/RfTestNotification.java
new file mode 100644
index 00000000..07f6e583
--- /dev/null
+++ b/service/support_lib/src/com/google/uwb/support/oemextension/RfTestNotification.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.uwb.support.oemextension;
+
+import android.os.PersistableBundle;
+import android.uwb.UwbManager;
+
+import androidx.annotation.Nullable;
+
+import com.google.uwb.support.base.RequiredParam;
+
+/**
+ * RF test notification for oem extension callback
+*
+* <p> This is passed as a bundle to oem extension API
+* {@link UwbManager.UwbOemExtensionCallback#onRfTestNotificationReceived(PersistableBundle)}.
+*/
+public class RfTestNotification {
+    private static final int BUNDLE_VERSION_1 = 1;
+    private static final int BUNDLE_VERSION_CURRENT = BUNDLE_VERSION_1;
+
+    private final int mRfTestOperationType;
+    private final byte[] mRfTestNtfData;
+    public static final String KEY_BUNDLE_VERSION = "bundle_version";
+    public static final String RF_TEST_NTF_DATA = "rf_test_ntf_data";
+    private static final String KEY_RF_OPERATION_TYPE = "rf_operation_type";
+
+    public static int getBundleVersion() {
+        return BUNDLE_VERSION_CURRENT;
+    }
+
+    public byte[] getRfTestNtfData() {
+        return mRfTestNtfData;
+    }
+
+    /*
+     * RfTestParams.RfTestOperationType defined as part of RfTest support lib
+     * Possible values are:
+     * - TEST_PERIODIC_TX = 0
+     * - TEST_PER_RX = 1
+     * - TEST_RX = 2
+     * - TEST_LOOPBACK = 3
+     * - TEST_SS_TWR = 4
+     * - TEST_SR_RX = 5
+     *
+     * @return The RF test operation type.
+     */
+    public int getRfTestOperationType() {
+        return mRfTestOperationType;
+    }
+
+    private RfTestNotification(int rfTestOperationType, byte[] rfTestNtfData) {
+        mRfTestOperationType = rfTestOperationType;
+        mRfTestNtfData = rfTestNtfData;
+    }
+
+    @Nullable
+    private static int[] byteArrayToIntArray(@Nullable byte[] bytes) {
+        if (bytes == null) {
+            return null;
+        }
+        int[] values = new int[bytes.length];
+        for (int i = 0; i < values.length; i++) {
+            values[i] = (bytes[i]);
+        }
+        return values;
+    }
+
+    @Nullable
+    private static byte[] intArrayToByteArray(@Nullable int[] values) {
+        if (values == null) {
+            return null;
+        }
+        byte[] bytes = new byte[values.length];
+        for (int i = 0; i < values.length; i++) {
+            bytes[i] = (byte) values[i];
+        }
+        return bytes;
+    }
+
+    public PersistableBundle toBundle() {
+        PersistableBundle bundle = new PersistableBundle();
+        bundle.putInt(KEY_BUNDLE_VERSION, getBundleVersion());
+        bundle.putIntArray(RF_TEST_NTF_DATA, byteArrayToIntArray(mRfTestNtfData));
+        bundle.putInt(KEY_RF_OPERATION_TYPE, mRfTestOperationType);
+        return bundle;
+    }
+
+    public static RfTestNotification fromBundle(PersistableBundle bundle) {
+        switch (bundle.getInt(KEY_BUNDLE_VERSION)) {
+            case BUNDLE_VERSION_1:
+                return parseVersion1(bundle);
+            default:
+                throw new IllegalArgumentException("Invalid bundle version");
+        }
+    }
+
+    private static RfTestNotification parseVersion1(PersistableBundle bundle) {
+        return new RfTestNotification.Builder()
+                .setRfTestOperationType(bundle.getInt(KEY_RF_OPERATION_TYPE))
+                .setRfTestNtfData(intArrayToByteArray(bundle.getIntArray(RF_TEST_NTF_DATA)))
+                .build();
+    }
+
+    /** Builder */
+    public static class Builder {
+        private RequiredParam<Integer> mRfTestOperationType = new RequiredParam<Integer>();
+        private byte[] mRfTestNtfData = null;
+
+        public RfTestNotification.Builder setRfTestNtfData(byte[] rfTestNtfData) {
+            mRfTestNtfData = rfTestNtfData;
+            return this;
+        }
+
+        public Builder setRfTestOperationType(int rfTestOperationType) {
+            mRfTestOperationType.set(rfTestOperationType);
+            return this;
+        }
+
+        public RfTestNotification build() {
+            return new RfTestNotification(mRfTestOperationType.get(), mRfTestNtfData);
+        }
+    }
+}
diff --git a/service/support_lib/src/com/google/uwb/support/rftest/RfTestOpenSessionParams.java b/service/support_lib/src/com/google/uwb/support/rftest/RfTestOpenSessionParams.java
new file mode 100644
index 00000000..5d58e399
--- /dev/null
+++ b/service/support_lib/src/com/google/uwb/support/rftest/RfTestOpenSessionParams.java
@@ -0,0 +1,712 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.uwb.support.rftest;
+
+import static com.google.uwb.support.fira.FiraParams.MAC_FCS_TYPE_CRC_16;
+import static com.google.uwb.support.fira.FiraParams.MAX_NUMBER_OF_MEASUREMENTS_DEFAULT;
+import static com.google.uwb.support.fira.FiraParams.PREAMBLE_DURATION_T64_SYMBOLS;
+import static com.google.uwb.support.fira.FiraParams.PRF_MODE_BPRF;
+import static com.google.uwb.support.fira.FiraParams.PSDU_DATA_RATE_6M81;
+import static com.google.uwb.support.fira.FiraParams.RFRAME_CONFIG_SP3;
+import static com.google.uwb.support.fira.FiraParams.SFD_ID_VALUE_2;
+import static com.google.uwb.support.fira.FiraParams.STS_SEGMENT_COUNT_VALUE_1;
+import static com.google.uwb.support.fira.FiraParams.UWB_CHANNEL_9;
+import static com.google.uwb.support.fira.FiraParams.longToUwbAddress;
+import static com.google.uwb.support.fira.FiraParams.uwbAddressToLong;
+
+import android.os.PersistableBundle;
+import android.uwb.UwbAddress;
+import android.uwb.UwbManager;
+
+import androidx.annotation.NonNull;
+
+import com.google.uwb.support.base.RequiredParam;
+import com.google.uwb.support.fira.FiraParams.MacFcsType;
+import com.google.uwb.support.fira.FiraParams.PreambleDuration;
+import com.google.uwb.support.fira.FiraParams.PrfMode;
+import com.google.uwb.support.fira.FiraParams.PsduDataRate;
+import com.google.uwb.support.fira.FiraParams.RangingDeviceRole;
+import com.google.uwb.support.fira.FiraParams.RframeConfig;
+import com.google.uwb.support.fira.FiraParams.SfdIdValue;
+import com.google.uwb.support.fira.FiraParams.StsSegmentCountValue;
+import com.google.uwb.support.fira.FiraParams.UwbChannel;
+import com.google.uwb.support.fira.FiraParams.UwbPreambleCodeIndex;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * Defines parameters to open a Rftest session.
+ *
+ * <p>This is passed as a bundle to the service API {@link UwbManager#openRangingSession}.
+ */
+public class RfTestOpenSessionParams extends RfTestParams {
+    private static final int BUNDLE_VERSION_1 = 1;
+    private static final int BUNDLE_VERSION_CURRENT = BUNDLE_VERSION_1;
+    private static final String KEY_SESSION_ID = "session_id";
+    private static final String KEY_SESSION_TYPE = "session_type";
+    private static final String KEY_CHANNEL_NUMBER = "channel_number";
+    private static final String KEY_NUMBER_OF_CONTROLEES = "number_of_controlees";
+    private static final String KEY_DEVICE_ADDRESS = "device_address";
+    private static final String KEY_DEST_ADDRESS_LIST = "dest_address_list";
+    private static final String KEY_SLOT_DURATION_RSTU = "slot_duration";
+    private static final String KEY_STS_INDEX = "sts_index";
+    private static final String KEY_FCS_TYPE = "fcs_type";
+    private static final String KEY_DEVICE_ROLE = "device_role";
+    private static final String KEY_RFRAME_CONFIG = "rframe_config";
+    private static final String KEY_PREAMBLE_CODE_INDEX = "preamble_code_index";
+    private static final String KEY_SFD_ID = "sfd_id";
+    private static final String KEY_PSDU_DATA_RATE = "psdu_data_rate";
+    private static final String KEY_PREAMBLE_DURATION = "preamble_duration";
+    private static final String KEY_PRF_MODE = "prf_mode";
+    private static final String KEY_STS_SEGMENT_COUNT = "sts_segment_count";
+
+    // RF test specific params
+    private static final String KEY_NUMBER_OF_PACKETS = "number_of_packets";
+    private static final String KEY_T_GAP = "t_gap";
+    private static final String KEY_T_START = "t_start";
+    private static final String KEY_T_WIN = "t_win";
+    private static final String KEY_RANDOMIZE_PSDU = "randomize_psdu";
+    private static final String KEY_PHR_RANGING_BIT = "phr_ranging_bit";
+    private static final String KEY_RMARKER_TX_START = "rmarker_tx_start";
+    private static final String KEY_RMARKER_RX_START = "rmarker_rx_start";
+    private static final String KEY_STS_INDEX_AUTO_INCR = "sts_index_auto_incr";
+    private static final String KEY_STS_DETECT_BITMAP_EN = "sts_detect_bitmap_en";
+
+    @SessionId
+    private final int mSessionId;
+    @SessionType
+    private final int mSessionType;
+    @UwbChannel
+    private final int mUwbChannel;
+    private final int mNoOfControlee;
+    private final UwbAddress mDeviceAddress;
+    private final List<UwbAddress> mDestAddressList;
+    private final int mSlotDurationRstu;
+    private final int mStsIndex;
+    @MacFcsType
+    private final int mFcsType;
+    @RangingDeviceRole
+    private final int mDeviceRole;
+    @RframeConfig
+    private final int mRframeConfig;
+    private final int mPreambleCodeIndex;
+    @SfdIdValue
+    private final int mSfdId;
+    @PsduDataRate
+    private final int mPsduDataRate;
+    @PreambleDuration
+    private final int mPreambleDuration;
+    @PrfMode
+    private final int mPrfMode;
+    @StsSegmentCountValue
+    private final int mStsSegmentCount;
+
+    private final int mNoOfPackets;
+    private final int mTgap;
+    private final int mTstart;
+    private final int mTwin;
+    @RandomizePsdu
+    private final int mRandomizePsdu;
+    @PhrRangingBit
+    private final int mPhrRangingBit;
+    private final int mRmarkerTxStart;
+    private final int mRmarkerRxStart;
+    @StsIndexAutoIncr
+    private final int mStsIndexAutoIncr;
+    @StsDetectBitmap
+    private final int mStsDetectBitmap;
+
+    private RfTestOpenSessionParams(
+            int sessionId,
+            @SessionType int sessionType,
+            @UwbChannel int uwbChannel,
+            int noOfControlee,
+            UwbAddress deviceAddress,
+            List<UwbAddress> destAddressList,
+            int slotDurationRstu,
+            int stsIndex,
+            @MacFcsType int fcsType,
+            @RangingDeviceRole int deviceRole,
+            @RframeConfig int rframeConfig,
+            int preambleCodeIndex,
+            @SfdIdValue int sfdId,
+            @PsduDataRate int psduDataRate,
+            @PreambleDuration int preambleDuration,
+            @PrfMode int prfMode,
+            @StsSegmentCountValue int stsSegmentCount,
+            int noOfPackets,
+            int tGap,
+            int tStart,
+            int tWin,
+            @RandomizePsdu int randomizePsdu,
+            @PhrRangingBit int phrRangingBit,
+            int rmarketTxStart,
+            int rmakrkerRxStart,
+            @StsIndexAutoIncr int stsIndexAutoIncr,
+            @StsDetectBitmap int stsDetectBitmap) {
+        mSessionId = sessionId;
+        mSessionType = sessionType;
+        mUwbChannel = uwbChannel;
+        mNoOfControlee = noOfControlee;
+        mDeviceAddress = deviceAddress;
+        mDestAddressList = destAddressList;
+        mSlotDurationRstu = slotDurationRstu;
+        mStsIndex = stsIndex;
+        mFcsType = fcsType;
+        mDeviceRole = deviceRole;
+        mRframeConfig = rframeConfig;
+        mPreambleCodeIndex = preambleCodeIndex;
+        mSfdId = sfdId;
+        mPsduDataRate = psduDataRate;
+        mPreambleDuration = preambleDuration;
+        mPrfMode = prfMode;
+        mStsSegmentCount = stsSegmentCount;
+        mNoOfPackets = noOfPackets;
+        mTgap = tGap;
+        mTstart = tStart;
+        mTwin = tWin;
+        mRandomizePsdu = randomizePsdu;
+        mPhrRangingBit = phrRangingBit;
+        mRmarkerTxStart = rmarketTxStart;
+        mRmarkerRxStart = rmakrkerRxStart;
+        mStsIndexAutoIncr = stsIndexAutoIncr;
+        mStsDetectBitmap = stsDetectBitmap;
+    }
+
+    @Override
+    protected int getBundleVersion() {
+        return BUNDLE_VERSION_CURRENT;
+    }
+
+    @Override
+    public PersistableBundle toBundle() {
+        PersistableBundle bundle = super.toBundle();
+        bundle.putInt(KEY_SESSION_ID, mSessionId);
+        bundle.putInt(KEY_SESSION_TYPE, mSessionType);
+        bundle.putInt(KEY_CHANNEL_NUMBER, mUwbChannel);
+        bundle.putInt(KEY_NUMBER_OF_CONTROLEES, mNoOfControlee);
+        bundle.putLong(KEY_DEVICE_ADDRESS, uwbAddressToLong(mDeviceAddress));
+        if (mDestAddressList != null) {
+            long[] destAddressList = new long[mDestAddressList.size()];
+            int i = 0;
+            for (UwbAddress destAddress : mDestAddressList) {
+                destAddressList[i++] = uwbAddressToLong(destAddress);
+            }
+            bundle.putLongArray(KEY_DEST_ADDRESS_LIST, destAddressList);
+        }
+        bundle.putInt(KEY_SLOT_DURATION_RSTU, mSlotDurationRstu);
+        bundle.putInt(KEY_STS_INDEX, mStsIndex);
+        bundle.putInt(KEY_FCS_TYPE, mFcsType);
+        bundle.putInt(KEY_DEVICE_ROLE, mDeviceRole);
+        bundle.putInt(KEY_RFRAME_CONFIG, mRframeConfig);
+        bundle.putInt(KEY_PREAMBLE_CODE_INDEX, mPreambleCodeIndex);
+        bundle.putInt(KEY_SFD_ID, mSfdId);
+        bundle.putInt(KEY_PSDU_DATA_RATE, mPsduDataRate);
+        bundle.putInt(KEY_PREAMBLE_DURATION, mPreambleDuration);
+        bundle.putInt(KEY_PRF_MODE, mPrfMode);
+        bundle.putInt(KEY_STS_SEGMENT_COUNT, mStsSegmentCount);
+        bundle.putInt(KEY_NUMBER_OF_PACKETS, mNoOfPackets);
+        bundle.putInt(KEY_T_GAP, mTgap);
+        bundle.putInt(KEY_T_START, mTstart);
+        bundle.putInt(KEY_T_WIN, mTwin);
+        bundle.putInt(KEY_RANDOMIZE_PSDU, mRandomizePsdu);
+        bundle.putInt(KEY_PHR_RANGING_BIT, mPhrRangingBit);
+        bundle.putInt(KEY_RMARKER_TX_START, mRmarkerTxStart);
+        bundle.putInt(KEY_RMARKER_RX_START, mRmarkerRxStart);
+        bundle.putInt(KEY_STS_INDEX_AUTO_INCR, mStsIndexAutoIncr);
+        bundle.putInt(KEY_STS_DETECT_BITMAP_EN, mStsDetectBitmap);
+        return bundle;
+    }
+
+    /** Unpack the {@link PersistableBundle} to a {@link RfTestOpenSessionParams} */
+    public static RfTestOpenSessionParams fromBundle(PersistableBundle bundle) {
+        if (!isCorrectProtocol(bundle)) {
+            throw new IllegalArgumentException("Invalid protocol");
+        }
+
+        switch (getBundleVersion(bundle)) {
+            case BUNDLE_VERSION_1:
+                return parseBundleVersion1(bundle);
+
+            default:
+                throw new IllegalArgumentException("unknown bundle version");
+        }
+    }
+
+    private static RfTestOpenSessionParams parseBundleVersion1(PersistableBundle bundle) {
+
+        UwbAddress deviceAddress =
+                longToUwbAddress(bundle.getLong(KEY_DEVICE_ADDRESS), 2);
+        long[] destAddresses = bundle.getLongArray(KEY_DEST_ADDRESS_LIST);
+        List<UwbAddress> destAddressList = new ArrayList<>();
+        if (destAddresses != null) {
+            for (long address : destAddresses) {
+                destAddressList.add(longToUwbAddress(address, 2));
+            }
+        }
+        return new Builder()
+                .setChannelNumber(bundle.getInt(KEY_CHANNEL_NUMBER))
+                .setNumberOfControlee(bundle.getInt(KEY_NUMBER_OF_CONTROLEES))
+                .setDeviceAddress(deviceAddress)
+                .setDestAddressList(destAddressList)
+                .setSlotDurationRstu(bundle.getInt(KEY_SLOT_DURATION_RSTU))
+                .setStsIndex(bundle.getInt(KEY_STS_INDEX))
+                .setFcsType(bundle.getInt(KEY_FCS_TYPE))
+                .setDeviceRole(bundle.getInt(KEY_DEVICE_ROLE))
+                .setRframeConfig(bundle.getInt(KEY_RFRAME_CONFIG))
+                .setPreambleCodeIndex(bundle.getInt(KEY_PREAMBLE_CODE_INDEX))
+                .setSfdId(bundle.getInt(KEY_SFD_ID))
+                .setPsduDataRate(bundle.getInt(KEY_PSDU_DATA_RATE))
+                .setPreambleDuration(bundle.getInt(KEY_PREAMBLE_DURATION))
+                .setPrfMode(bundle.getInt(KEY_PRF_MODE))
+                .setStsSegmentCount(bundle.getInt(KEY_STS_SEGMENT_COUNT))
+                .setNumberOfPackets(bundle.getInt(KEY_NUMBER_OF_PACKETS))
+                .setTgap(bundle.getInt(KEY_T_GAP))
+                .setTstart(bundle.getInt(KEY_T_START))
+                .setTwin(bundle.getInt(KEY_T_WIN))
+                .setRandomizePsdu(bundle.getInt(KEY_RANDOMIZE_PSDU))
+                .setPhrRangingBit(bundle.getInt(KEY_PHR_RANGING_BIT))
+                .setRmarkerTxStart(bundle.getInt(KEY_RMARKER_TX_START))
+                .setRmarkerRxStart(bundle.getInt(KEY_RMARKER_RX_START))
+                .setStsIndexAutoIncr(bundle.getInt(KEY_STS_INDEX_AUTO_INCR))
+                .setStsDetectBitmap(bundle.getInt(KEY_STS_DETECT_BITMAP_EN))
+                .build();
+    }
+
+    public int getSessionId() {
+        return mSessionId;
+    }
+
+    @SessionType
+    public int getSessionType() {
+        return mSessionType;
+    }
+
+    @UwbChannel
+    public int getChannelNumber() {
+        return mUwbChannel;
+    }
+
+    public int getNoOfControlee() {
+        return mNoOfControlee;
+    }
+
+    public UwbAddress getDeviceAddress() {
+        return mDeviceAddress;
+    }
+
+    public List<UwbAddress> getDestAddressList() {
+        return mDestAddressList != null ? Collections.unmodifiableList(mDestAddressList) : null;
+    }
+
+    public int getSlotDurationRstu() {
+        return mSlotDurationRstu;
+    }
+
+    public int getStsIndex() {
+        return mStsIndex;
+    }
+
+    @MacFcsType
+    public int getFcsType() {
+        return mFcsType;
+    }
+
+    @RangingDeviceRole
+    public int getDeviceRole() {
+        return mDeviceRole;
+    }
+
+    @RframeConfig
+    public int getRframeConfig() {
+        return mRframeConfig;
+    }
+
+    @UwbPreambleCodeIndex
+    public int getPreambleCodeIndex() {
+        return mPreambleCodeIndex;
+    }
+
+    @SfdIdValue
+    public int getSfdId() {
+        return mSfdId;
+    }
+
+    @PsduDataRate
+    public int getPsduDataRate() {
+        return mPsduDataRate;
+    }
+
+    @PreambleDuration
+    public int getPreambleDuration() {
+        return mPreambleDuration;
+    }
+
+    @PrfMode
+    public int getPrfMode() {
+        return mPrfMode;
+    }
+
+    @StsSegmentCountValue
+    public int getStsSegmentCount() {
+        return mStsSegmentCount;
+    }
+
+    public int getNumberOfPackets() {
+        return mNoOfPackets;
+    }
+
+    public int getTgap() {
+        return mTgap;
+    }
+
+    public int getTstart() {
+        return mTstart;
+    }
+
+    public int getTwin() {
+        return mTwin;
+    }
+
+    @RandomizePsdu
+    public int getRandomizePsdu() {
+        return mRandomizePsdu;
+    }
+
+    @PhrRangingBit
+    public int getPhrRangingBit() {
+        return mPhrRangingBit;
+    }
+
+    public int getRmarkerTxStart() {
+        return mRmarkerTxStart;
+    }
+
+    public int getRmarkerRxStart() {
+        return mRmarkerRxStart;
+    }
+
+    @StsIndexAutoIncr
+    public int getStsIndexAutoIncr() {
+        return mStsIndexAutoIncr;
+    }
+
+    @StsDetectBitmap
+    public int getStsDetectBitmap() {
+        return mStsDetectBitmap;
+    }
+
+    /** Builder */
+    public static final class Builder {
+        private int mSessionId = 0x00000000;
+
+        @SessionType
+        private int mSessionType = RfTestParams.SESSION_TYPE_RFTEST;
+
+        /** UCI spec default: Channel 9, which is the only mandatory channel. */
+        @UwbChannel
+        private int mUwbChannel = UWB_CHANNEL_9;
+
+        private int mNoOfControlee = MAX_NUMBER_OF_MEASUREMENTS_DEFAULT;
+
+        private RequiredParam<UwbAddress> mDeviceAddress = new RequiredParam<UwbAddress>();
+
+        private List<UwbAddress> mDestAddressList = null;
+
+        /** UCI spec default: 2400 RSTU (2 ms). */
+        private int mSlotDurationRstu = 2400;
+
+        private int mStsIndex = 0;
+
+        /** UCI spec default: CRC-16 */
+        private @MacFcsType int mFcsType = MAC_FCS_TYPE_CRC_16;
+
+        private @RangingDeviceRole int mDeviceRole;
+
+        private @RframeConfig int mRframeConfig = RFRAME_CONFIG_SP3;
+
+        /** UCI spec default 10 */
+        private int mPreambleCodeIndex = 10;
+
+        /** UCI spec default 2, BPRF */
+        private @SfdIdValue int mSfdId = SFD_ID_VALUE_2;
+
+        /** UCI spec default 6.81 Mbps */
+        private @PsduDataRate int mPsduDataRate = PSDU_DATA_RATE_6M81;
+
+        /** UCI spec default 64 symbols */
+        private @PreambleDuration int mPreambleDuration = PREAMBLE_DURATION_T64_SYMBOLS;
+
+        /** UCI spec default BPRF */
+        private @PrfMode int mPrfMode = PRF_MODE_BPRF;
+
+        /** UCI spec default 1 STS segment */
+        private @StsSegmentCountValue int mStsSegmentCount = STS_SEGMENT_COUNT_VALUE_1;
+
+        /** UCI spec default 1000 */
+        private int mNoOfPackets = 1000;
+
+        /** UCI spec default 2000 */
+        private int mTgap = 2000;
+
+        /** UCI spec default 450 */
+        private int mTstart = 450;
+
+        /** UCI spec default 750 */
+        private int mTwin = 750;
+
+        /** UCI spec default no randomization */
+        private @RandomizePsdu int mRandomizePsdu = NO_RANDOMIZATION;
+
+        /** UCI spec default disable */
+        private @PhrRangingBit int mPhrRangingBit = DISABLE_PHR;
+
+        private RequiredParam<Integer> mRmarkerTxStart = new RequiredParam<Integer>();
+
+        private RequiredParam<Integer> mRmarkerRxStart = new RequiredParam<Integer>();
+
+        /** UCI spec default no increment */
+        private @StsIndexAutoIncr int mStsIndexAutoIncr = NO_AUTO_INCR;
+
+        /** UCI spec default don't report bitmap */
+        private @StsDetectBitmap int mStsDetectBitmap = NO_STS_DETECT_BITMAP;
+
+        public Builder() {
+        }
+
+        public Builder(@NonNull Builder builder) {
+            mSessionId = builder.mSessionId;
+            mSessionType = builder.mSessionType;
+            mUwbChannel = builder.mUwbChannel;
+            mNoOfControlee = builder.mNoOfControlee;
+            mDeviceAddress.set(builder.mDeviceAddress.get());
+            mDestAddressList = builder.mDestAddressList;
+            mSlotDurationRstu = builder.mSlotDurationRstu;
+            mStsIndex = builder.mStsIndex;
+            mFcsType = builder.mFcsType;
+            mDeviceRole = builder.mDeviceRole;
+            mRframeConfig = builder.mRframeConfig;
+            mPreambleCodeIndex = builder.mPreambleCodeIndex;
+            mSfdId = builder.mSfdId;
+            mPsduDataRate = builder.mPsduDataRate;
+            mPreambleDuration = builder.mPreambleDuration;
+            mPrfMode = builder.mPrfMode;
+            mStsSegmentCount = builder.mStsSegmentCount;
+            mNoOfPackets = builder.mNoOfPackets;
+            mTgap = builder.mTgap;
+            mTstart = builder.mTstart;
+            mTwin = builder.mTwin;
+            mRandomizePsdu = builder.mRandomizePsdu;
+            mPhrRangingBit = builder.mPhrRangingBit;
+            mRmarkerTxStart.set(builder.mRmarkerTxStart.get());
+            mRmarkerRxStart.set(builder.mRmarkerRxStart.get());
+            mStsIndexAutoIncr = builder.mStsIndexAutoIncr;
+            mStsDetectBitmap = builder.mStsDetectBitmap;
+        }
+
+        public Builder(@NonNull RfTestOpenSessionParams params) {
+            mSessionId = params.mSessionId;
+            mSessionType = params.mSessionType;
+            mUwbChannel = params.mUwbChannel;
+            mNoOfControlee = params.mNoOfControlee;
+            mDeviceAddress.set(params.mDeviceAddress);
+            mDestAddressList = params.mDestAddressList;
+            mSlotDurationRstu = params.mSlotDurationRstu;
+            mStsIndex = params.mStsIndex;
+            mFcsType = params.mFcsType;
+            mDeviceRole = params.mDeviceRole;
+            mRframeConfig = params.mRframeConfig;
+            mPreambleCodeIndex = params.mPreambleCodeIndex;
+            mSfdId = params.mSfdId;
+            mPsduDataRate = params.mPsduDataRate;
+            mPreambleDuration = params.mPreambleDuration;
+            mPrfMode = params.mPrfMode;
+            mStsSegmentCount = params.mStsSegmentCount;
+            mNoOfPackets = params.mNoOfPackets;
+            mTgap = params.mTgap;
+            mTstart = params.mTstart;
+            mTwin = params.mTwin;
+            mRandomizePsdu = params.mRandomizePsdu;
+            mPhrRangingBit = params.mPhrRangingBit;
+            mRmarkerTxStart.set(params.mRmarkerTxStart);
+            mRmarkerRxStart.set(params.mRmarkerRxStart);
+            mStsIndexAutoIncr = params.mStsIndexAutoIncr;
+            mStsDetectBitmap = params.mStsDetectBitmap;
+        }
+
+        public Builder setChannelNumber(@UwbChannel int channelNumber) {
+            mUwbChannel = channelNumber;
+            return this;
+        }
+
+        public Builder setNumberOfControlee(int noOfControlee) {
+            mNoOfControlee = noOfControlee;
+            return this;
+        }
+
+        public Builder setDeviceAddress(UwbAddress deviceAddress) {
+            mDeviceAddress.set(deviceAddress);
+            return this;
+        }
+
+        public Builder setDestAddressList(List<UwbAddress> destAddressList) {
+            mDestAddressList = destAddressList;
+            return this;
+        }
+
+        public Builder setSlotDurationRstu(int slotDurationRstu) {
+            mSlotDurationRstu = slotDurationRstu;
+            return this;
+        }
+
+        public Builder setStsIndex(int stsIndex) {
+            mStsIndex = stsIndex;
+            return this;
+        }
+
+        public Builder setFcsType(@MacFcsType int fcsType) {
+            mFcsType = fcsType;
+            return this;
+        }
+
+        public Builder setDeviceRole(@RangingDeviceRole int deviceRole) {
+            mDeviceRole = deviceRole;
+            return this;
+        }
+
+        public Builder setRframeConfig(@RframeConfig int rframeConfig) {
+            mRframeConfig = rframeConfig;
+            return this;
+        }
+
+        public Builder setPreambleCodeIndex(@UwbPreambleCodeIndex int preambleCodeIndex) {
+            mPreambleCodeIndex = preambleCodeIndex;
+            return this;
+        }
+
+        public Builder setSfdId(@SfdIdValue int sfdId) {
+            mSfdId = sfdId;
+            return this;
+        }
+
+        public Builder setPsduDataRate(@PsduDataRate int psduDataRate) {
+            mPsduDataRate = psduDataRate;
+            return this;
+        }
+
+        public Builder setPreambleDuration(@PreambleDuration int preambleDuration) {
+            mPreambleDuration = preambleDuration;
+            return this;
+        }
+
+        public Builder setPrfMode(@PrfMode int prfMode) {
+            mPrfMode = prfMode;
+            return this;
+        }
+
+        public Builder setStsSegmentCount(
+                @StsSegmentCountValue int stsSegmentCount) {
+            mStsSegmentCount = stsSegmentCount;
+            return this;
+        }
+
+        public Builder setNumberOfPackets(int noOfPackets) {
+            mNoOfPackets = noOfPackets;
+            return this;
+        }
+
+        public Builder setTgap(int tGap) {
+            mTgap = tGap;
+            return this;
+        }
+
+        public Builder setTstart(int tStart) {
+            mTstart = tStart;
+            return this;
+        }
+
+        public Builder setTwin(int tWin) {
+            mTwin = tWin;
+            return this;
+        }
+
+        public Builder setRandomizePsdu(@RandomizePsdu int randomizePsdu) {
+            mRandomizePsdu = randomizePsdu;
+            return this;
+        }
+
+        public Builder setPhrRangingBit(@PhrRangingBit int phrRangingBit) {
+            mPhrRangingBit = phrRangingBit;
+            return this;
+        }
+
+        public Builder setRmarkerTxStart(int rmarkerTxStart) {
+            mRmarkerTxStart.set(rmarkerTxStart);
+            return this;
+        }
+
+        public Builder setRmarkerRxStart(int rmarkerRxStart) {
+            mRmarkerRxStart.set(rmarkerRxStart);
+            return this;
+        }
+
+        public Builder setStsIndexAutoIncr(@StsIndexAutoIncr int stsIndexAutoIncr) {
+            mStsIndexAutoIncr = stsIndexAutoIncr;
+            return this;
+        }
+
+        public Builder setStsDetectBitmap(@StsDetectBitmap int stsDetectBitmap) {
+            mStsDetectBitmap = stsDetectBitmap;
+            return this;
+        }
+
+        /** Build {@link RfTestOpenSessionParams} */
+        public RfTestOpenSessionParams build() {
+            return new RfTestOpenSessionParams(
+                    mSessionId,
+                    mSessionType,
+                    mUwbChannel,
+                    mNoOfControlee,
+                    mDeviceAddress.get(),
+                    mDestAddressList,
+                    mSlotDurationRstu,
+                    mStsIndex,
+                    mFcsType,
+                    mDeviceRole,
+                    mRframeConfig,
+                    mPreambleCodeIndex,
+                    mSfdId,
+                    mPsduDataRate,
+                    mPreambleDuration,
+                    mPrfMode,
+                    mStsSegmentCount,
+                    mNoOfPackets,
+                    mTgap,
+                    mTstart,
+                    mTwin,
+                    mRandomizePsdu,
+                    mPhrRangingBit,
+                    mRmarkerTxStart.get(),
+                    mRmarkerRxStart.get(),
+                    mStsIndexAutoIncr,
+                    mStsDetectBitmap
+            );
+        }
+    }
+}
diff --git a/service/support_lib/src/com/google/uwb/support/rftest/RfTestParams.java b/service/support_lib/src/com/google/uwb/support/rftest/RfTestParams.java
new file mode 100644
index 00000000..9d1edc5e
--- /dev/null
+++ b/service/support_lib/src/com/google/uwb/support/rftest/RfTestParams.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.uwb.support.rftest;
+
+import android.os.PersistableBundle;
+
+import androidx.annotation.IntDef;
+import androidx.annotation.Nullable;
+
+import com.google.uwb.support.base.Params;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+/** Defines parameters for RF test operation */
+public abstract class RfTestParams extends Params {
+    public static final String PROTOCOL_NAME = "rftest";
+
+    @Override
+    public final String getProtocolName() {
+        return PROTOCOL_NAME;
+    }
+
+    /** Checks if the {@link PersistableBundle} is based on the rftest protocol. */
+    public static boolean isCorrectProtocol(PersistableBundle bundle) {
+        return isProtocol(bundle, PROTOCOL_NAME);
+    }
+
+    /** Checks if the protocolName is rftest . */
+    public static boolean isCorrectProtocol(String protocolName) {
+        return protocolName.equals(PROTOCOL_NAME);
+    }
+
+    /** Session Id */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef(value = {SESSION_ID_RFTEST})
+    public @interface SessionId {
+    }
+
+    public static final int SESSION_ID_RFTEST = 0x00;
+
+    /** Session Type */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef(value = {SESSION_TYPE_RFTEST})
+    public @interface SessionType {
+    }
+
+    public static final int SESSION_TYPE_RFTEST = 0xD0;
+
+    /** Randomized PSDU default value 0 */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef(
+            value = {
+                    NO_RANDOMIZATION,
+                    RANDOMIZE_PSDU,
+            })
+    public @interface RandomizePsdu {
+    }
+
+    public static final int NO_RANDOMIZATION = 0;
+    public static final int RANDOMIZE_PSDU = 1;
+
+    /** Ranging bit field default value 0 */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef(
+            value = {
+                    DISABLE_PHR,
+                    ENABLE_PHR,
+            })
+    public @interface PhrRangingBit {
+    }
+
+    public static final int DISABLE_PHR = 0;
+    public static final int ENABLE_PHR = 1;
+
+    /** STS INDEX increment default value 0 */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef(
+            value = {
+                    NO_AUTO_INCR,
+                    AUTO_INCR_STS_INDEX,
+            })
+    public @interface StsIndexAutoIncr {
+    }
+
+    public static final int NO_AUTO_INCR = 0;
+    public static final int AUTO_INCR_STS_INDEX = 1;
+
+    /** STS bitmap default value 0 */
+    @Retention(RetentionPolicy.SOURCE)
+    @IntDef(
+            value = {
+                    NO_STS_DETECT_BITMAP,
+                    REPORT_STS_DETECT_BITMAP,
+            })
+    public @interface StsDetectBitmap {
+    }
+
+    public static final int NO_STS_DETECT_BITMAP = 0;
+    public static final int REPORT_STS_DETECT_BITMAP = 1;
+
+    /** RF Test command */
+    @IntDef(
+            value = {
+                    TEST_PERIODIC_TX,
+                    TEST_PER_RX,
+                    TEST_RX,
+                    TEST_LOOPBACK,
+                    TEST_SS_TWR,
+                    TEST_SR_RX,
+            })
+    public @interface RfTestOperationType {
+    }
+
+    public static final int TEST_PERIODIC_TX = 0;
+    public static final int TEST_PER_RX = 1;
+    public static final int TEST_RX = 2;
+    public static final int TEST_LOOPBACK = 3;
+    public static final int TEST_SS_TWR = 4;
+    public static final int TEST_SR_RX = 5;
+
+    @Nullable
+    public static byte[] intArrayToByteArray(@Nullable int[] values) {
+        if (values == null) {
+            return null;
+        }
+        byte[] bytes = new byte[values.length];
+        for (int i = 0; i < values.length; i++) {
+            bytes[i] = (byte) values[i];
+        }
+        return bytes;
+    }
+
+    @Nullable
+    public static int[] byteArrayToIntArray(@Nullable byte[] bytes) {
+        if (bytes == null) {
+            return null;
+        }
+
+        int[] values = new int[bytes.length];
+        for (int i = 0; i < values.length; i++) {
+            values[i] = bytes[i];
+        }
+        return values;
+    }
+}
diff --git a/service/support_lib/src/com/google/uwb/support/rftest/RfTestPeriodicTxResult.java b/service/support_lib/src/com/google/uwb/support/rftest/RfTestPeriodicTxResult.java
new file mode 100644
index 00000000..02c0e85f
--- /dev/null
+++ b/service/support_lib/src/com/google/uwb/support/rftest/RfTestPeriodicTxResult.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.uwb.support.rftest;
+
+import com.google.uwb.support.base.RequiredParam;
+
+import android.os.PersistableBundle;
+
+public final class RfTestPeriodicTxResult  extends RfTestParams {
+    private static final int BUNDLE_VERSION_1 = 1;
+    private static final int BUNDLE_VERSION_CURRENT = BUNDLE_VERSION_1;
+    private static final String KEY_STATUS_CODE = "status_code";
+    private static final String KEY_RF_OPERATION_TYPE = "rf_operation_type";
+    private final int mRfTestOperationType;
+    private final int mStatus;
+
+    private RfTestPeriodicTxResult(int status, int rfTestOperationType) {
+        this.mStatus = status;
+        this.mRfTestOperationType = rfTestOperationType;
+    }
+
+    @Override
+    protected int getBundleVersion() {
+        return BUNDLE_VERSION_CURRENT;
+    }
+
+    @Override
+    public PersistableBundle toBundle() {
+        PersistableBundle bundle = super.toBundle();
+        bundle.putInt(KEY_STATUS_CODE, mStatus);
+        bundle.putInt(KEY_RF_OPERATION_TYPE, mRfTestOperationType);
+        return bundle;
+    }
+
+    /** Unpack the {@link PersistableBundle} to a {@link RfTestPeriodicTxResult} */
+    public static RfTestPeriodicTxResult fromBundle(PersistableBundle bundle) {
+        if (!isCorrectProtocol(bundle)) {
+            throw new IllegalArgumentException("Invalid protocol");
+        }
+
+        switch (getBundleVersion(bundle)) {
+            case BUNDLE_VERSION_1:
+                return parseBundleVersion1(bundle);
+
+            default:
+                throw new IllegalArgumentException("unknown bundle version");
+        }
+    }
+
+    private static RfTestPeriodicTxResult parseBundleVersion1(PersistableBundle bundle) {
+        RfTestPeriodicTxResult.Builder builder = new RfTestPeriodicTxResult.Builder()
+                .setStatus(bundle.getInt(KEY_STATUS_CODE))
+                .setOperationType(bundle.getInt(KEY_RF_OPERATION_TYPE));
+        return builder.build();
+    }
+
+    public int getStatus() {
+        return mStatus;
+    }
+
+    /*
+     * RfTestParams.RfTestOperationType defined as part of RfTest support lib
+     * Possible values are:
+     * - TEST_PERIODIC_TX = 0
+     * - TEST_PER_RX = 1
+     * - TEST_RX = 2
+     * - TEST_LOOPBACK = 3
+     * - TEST_SS_TWR = 4
+     * - TEST_SR_RX = 5
+     *
+     * @return The RF test operation type.
+     */
+    public int getRfTestOperationType() {
+        return mRfTestOperationType;
+    }
+
+    /**
+     * Builder for a {@link RfTestPeriodicTxResult} object.
+     */
+    public static final class Builder {
+        private RequiredParam<Integer> mRfTestOperationType = new RequiredParam<Integer>();
+        private int mStatus;
+
+        public Builder setStatus(int status) {
+            mStatus = status;
+            return this;
+        }
+
+        public Builder setOperationType(int rfTestOperationType) {
+            mRfTestOperationType.set(rfTestOperationType);
+            return this;
+        }
+
+        /**
+         * Build the {@link RfTestPeriodicTxResult} object
+         */
+        public RfTestPeriodicTxResult build() {
+            return new RfTestPeriodicTxResult(mStatus, mRfTestOperationType.get());
+        }
+    }
+}
diff --git a/service/support_lib/src/com/google/uwb/support/rftest/RfTestSessionStatus.java b/service/support_lib/src/com/google/uwb/support/rftest/RfTestSessionStatus.java
new file mode 100644
index 00000000..cb7adb92
--- /dev/null
+++ b/service/support_lib/src/com/google/uwb/support/rftest/RfTestSessionStatus.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.uwb.support.rftest;
+
+import android.os.PersistableBundle;
+
+import com.google.uwb.support.base.RequiredParam;
+import com.google.uwb.support.fira.FiraParams.StatusCode;
+import com.google.uwb.support.rftest.RfTestParams.RfTestOperationType;
+
+public class RfTestSessionStatus extends RfTestParams {
+    private static final int BUNDLE_VERSION_1 = 1;
+    private static final int BUNDLE_VERSION_CURRENT = BUNDLE_VERSION_1;
+
+    private static final String KEY_RF_OPERATION_TYPE = "rf_operation_type";
+    private static final String KEY_STATUS_CODE = "status_code";
+
+    /** FiRa status code defined in Table 32 */
+    @StatusCode
+    private final int mStatusCode;
+    @RfTestOperationType private final int mRfTestOperationType;
+
+    private RfTestSessionStatus(@RfTestOperationType int rfTestOperationType,
+            @StatusCode int statusCode) {
+        mRfTestOperationType = rfTestOperationType;
+        mStatusCode = statusCode;
+    }
+
+    @Override
+    protected int getBundleVersion() {
+        return BUNDLE_VERSION_CURRENT;
+    }
+
+    @RfTestOperationType
+    public int getRfTestOperationType() {
+        return mRfTestOperationType;
+    }
+
+    @StatusCode
+    public int getStatusCode() {
+        return mStatusCode;
+    }
+
+    @Override
+    public PersistableBundle toBundle() {
+        PersistableBundle bundle = super.toBundle();
+        bundle.putInt(KEY_RF_OPERATION_TYPE, mRfTestOperationType);
+        bundle.putInt(KEY_STATUS_CODE, mStatusCode);
+        return bundle;
+    }
+
+    public static RfTestSessionStatus fromBundle(PersistableBundle bundle) {
+        if (!isCorrectProtocol(bundle)) {
+            throw new IllegalArgumentException("Invalid protocol");
+        }
+
+        switch (getBundleVersion(bundle)) {
+            case BUNDLE_VERSION_1:
+                return parseVersion1(bundle);
+
+            default:
+                throw new IllegalArgumentException("Invalid bundle version");
+        }
+    }
+
+    private static RfTestSessionStatus parseVersion1(PersistableBundle bundle) {
+        return new RfTestSessionStatus.Builder()
+            .setRfTestOperationType(bundle.getInt(KEY_RF_OPERATION_TYPE))
+            .setStatusCode(bundle.getInt(KEY_STATUS_CODE)).build();
+    }
+
+    /** Builder */
+    public static class Builder {
+        @RfTestOperationType
+        private RequiredParam<Integer> mRfTestOperationType =
+                new RequiredParam<Integer>();
+        private final RequiredParam<Integer> mStatusCode = new RequiredParam<>();
+
+        public RfTestSessionStatus.Builder setRfTestOperationType(
+                @RfTestOperationType int rfTestOperationType) {
+            mRfTestOperationType.set(rfTestOperationType);
+            return this;
+        }
+
+        public RfTestSessionStatus.Builder setStatusCode(int statusCode) {
+            mStatusCode.set(statusCode);
+            return this;
+        }
+
+        public RfTestSessionStatus build() {
+            return new RfTestSessionStatus(mRfTestOperationType.get(), mStatusCode.get());
+        }
+    }
+}
diff --git a/service/support_lib/src/com/google/uwb/support/rftest/RfTestStartSessionParams.java b/service/support_lib/src/com/google/uwb/support/rftest/RfTestStartSessionParams.java
new file mode 100644
index 00000000..6cce86e0
--- /dev/null
+++ b/service/support_lib/src/com/google/uwb/support/rftest/RfTestStartSessionParams.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.uwb.support.rftest;
+
+import android.os.PersistableBundle;
+
+import androidx.annotation.NonNull;
+
+import com.google.uwb.support.base.RequiredParam;
+
+/**
+ * Defines parameters to open a Rftest session.
+ *
+ * <p>This is passed as a bundle to the service API {@link UwbSessionManager#start}.
+ */
+public class RfTestStartSessionParams extends RfTestParams {
+    private static final int BUNDLE_VERSION_1 = 1;
+    private static final int BUNDLE_VERSION_CURRENT = BUNDLE_VERSION_1;
+
+    private static final String KEY_RF_OPERATION_TYPE = "rf_operation_type";
+    private static final String KEY_PSDU_DATA = "psdu_data";
+
+    @RfTestOperationType private final int mRfTestOperationType;
+    private final byte[] mPsduData;
+
+    private RfTestStartSessionParams(
+            int rfTestOperationType,
+            byte[] psduData) {
+        mRfTestOperationType = rfTestOperationType;
+        mPsduData = psduData;
+    }
+
+    @Override
+    protected int getBundleVersion() {
+        return BUNDLE_VERSION_CURRENT;
+    }
+
+    @Override
+    public PersistableBundle toBundle() {
+        PersistableBundle bundle = super.toBundle();
+        bundle.putInt(KEY_RF_OPERATION_TYPE, mRfTestOperationType);
+        bundle.putIntArray(KEY_PSDU_DATA, RfTestParams.byteArrayToIntArray(mPsduData));
+        return bundle;
+    }
+
+    /** Unpack the {@link PersistableBundle} to a {@link RfTestStartSessionParams} */
+    public static RfTestStartSessionParams fromBundle(PersistableBundle bundle) {
+        if (!isCorrectProtocol(bundle)) {
+            throw new IllegalArgumentException("Invalid protocol");
+        }
+
+        switch (getBundleVersion(bundle)) {
+            case BUNDLE_VERSION_1:
+                return parseBundleVersion1(bundle);
+
+            default:
+                throw new IllegalArgumentException("unknown bundle version");
+        }
+    }
+
+    private static RfTestStartSessionParams parseBundleVersion1(PersistableBundle bundle) {
+
+        return new Builder()
+            .setRfTestOperationType(bundle.getInt(KEY_RF_OPERATION_TYPE))
+            .setPsduData(RfTestParams.intArrayToByteArray(bundle.getIntArray(KEY_PSDU_DATA)))
+            .build();
+    }
+
+    @RfTestOperationType
+    public int getRfTestOperationType() {
+        return mRfTestOperationType;
+    }
+
+    public byte[] getPsduData() {
+        return mPsduData;
+    }
+
+    /** Builder */
+    public static final class Builder {
+        @RfTestOperationType
+        private RequiredParam<Integer> mRfTestOperationType =
+                new RequiredParam<Integer>();
+
+        private byte[] mPsduData = new byte[0];
+
+        public Builder() {}
+
+        public Builder(@NonNull Builder builder) {
+            mRfTestOperationType.set(builder.mRfTestOperationType.get());
+            mPsduData = builder.mPsduData;
+        }
+
+        public Builder(@NonNull RfTestStartSessionParams params) {
+            mRfTestOperationType.set(params.mRfTestOperationType);
+            mPsduData = params.mPsduData;
+        }
+
+        public Builder setRfTestOperationType(@RfTestOperationType int rfTestOperationType) {
+            mRfTestOperationType.set(rfTestOperationType);
+            return this;
+        }
+
+        public Builder setPsduData(byte[] psduData) {
+            mPsduData = psduData;
+            return this;
+        }
+
+        /** Build {@link RfTestStartSessionParams} */
+        public RfTestStartSessionParams build() {
+            return new RfTestStartSessionParams(
+                mRfTestOperationType.get(),
+                mPsduData);
+        }
+    }
+}
diff --git a/service/support_lib/test/Android.bp b/service/support_lib/test/Android.bp
index d53f7566..d6dce260 100644
--- a/service/support_lib/test/Android.bp
+++ b/service/support_lib/test/Android.bp
@@ -13,6 +13,7 @@ android_test {
         "com.uwb.support.ccc",
         "com.uwb.support.fira",
         "com.uwb.support.radar",
+        "com.uwb.support.rftest",
         "com.uwb.support.generic",
         "com.uwb.support.multichip",
         "com.uwb.support.oemextension",
diff --git a/service/support_lib/test/DlTDoATests.java b/service/support_lib/test/DlTDoATests.java
index 05650036..8db6aea6 100644
--- a/service/support_lib/test/DlTDoATests.java
+++ b/service/support_lib/test/DlTDoATests.java
@@ -14,6 +14,8 @@
  * limitations under the License.
  */
 
+package com.google.uwb.support;
+
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 
diff --git a/service/support_lib/test/FiraTests.java b/service/support_lib/test/FiraTests.java
index 13fcbe07..1b44f153 100644
--- a/service/support_lib/test/FiraTests.java
+++ b/service/support_lib/test/FiraTests.java
@@ -47,6 +47,7 @@ import static com.google.uwb.support.fira.FiraParams.UL_TDOA_DEVICE_ID_16_BIT;
 
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.assertTrue;
 
 import android.os.PersistableBundle;
@@ -782,4 +783,18 @@ public class FiraTests {
         assertEquals(2, firaVersion.getMajor());
         assertEquals(1, firaVersion.getMinor());
     }
+
+    @Test
+    public void testAsUnsigned() {
+        assertEquals(-1, FiraOpenSessionParams.Builder.asUnsigned((1L << 32) - 1));
+        assertEquals(-2147483647, FiraOpenSessionParams.Builder.asUnsigned(0x80000001L));
+        assertEquals(0, FiraOpenSessionParams.Builder.asUnsigned(0L));
+
+        // Input must be positive.
+        assertThrows(IllegalArgumentException.class,
+                () -> FiraOpenSessionParams.Builder.asUnsigned(-1));
+        // Input must fit in 32 bit unsigned integer.
+        assertThrows(IllegalArgumentException.class,
+                () -> FiraOpenSessionParams.Builder.asUnsigned(1L << 32));
+    }
 }
diff --git a/service/support_lib/test/GenericTests.java b/service/support_lib/test/GenericTests.java
index 9ba97e98..0ed85519 100644
--- a/service/support_lib/test/GenericTests.java
+++ b/service/support_lib/test/GenericTests.java
@@ -163,12 +163,15 @@ public class GenericTests {
                         .build();
 
         boolean hasPowerStatsSupport = true;
+        int maxSupportedSessionCount =
+                GenericSpecificationParams.DEFAULT_MAX_SUPPORTED_SESSIONS_COUNT;
         GenericSpecificationParams genericSpecificationParams =
                 new GenericSpecificationParams.Builder()
                         .setFiraSpecificationParams(firaSpecificationParams)
                         .setCccSpecificationParams(cccSpecificationParams)
                         .setRadarSpecificationParams(radarSpecificationParams)
                         .hasPowerStatsSupport(hasPowerStatsSupport)
+                        .setMaxSupportedSessionCount(maxSupportedSessionCount)
                         .build();
         firaSpecificationParams = genericSpecificationParams.getFiraSpecificationParams();
         cccSpecificationParams = genericSpecificationParams.getCccSpecificationParams();
@@ -208,6 +211,8 @@ public class GenericTests {
         assertArrayEquals(cccSpecificationParams.getHoppingSequences().toArray(), hoppingSequences);
 
         assertEquals(hasPowerStatsSupport, genericSpecificationParams.hasPowerStatsSupport());
+        assertEquals(maxSupportedSessionCount,
+                genericSpecificationParams.getMaxSupportedSessionCount());
         assertEquals(radarSpecificationParams.getRadarCapabilities().size(), 1);
         assertTrue(
                 radarSpecificationParams
diff --git a/service/support_lib/test/RfTests.java b/service/support_lib/test/RfTests.java
new file mode 100644
index 00000000..dd8c5992
--- /dev/null
+++ b/service/support_lib/test/RfTests.java
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.uwb.support;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertThrows;
+
+import android.os.PersistableBundle;
+import android.uwb.UwbAddress;
+
+import androidx.test.runner.AndroidJUnit4;
+
+import com.google.uwb.support.rftest.RfTestOpenSessionParams;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import java.util.ArrayList;
+import java.util.List;
+
+@RunWith(AndroidJUnit4.class)
+public class RfTests {
+
+    private static final int UWB_CHANNEL = 5;
+    private static final int NO_OF_CONTROLEE = 3;
+    private static final UwbAddress DEVICE_ADDRESS =
+            UwbAddress.fromBytes(new byte[] {0x01, 0x02});
+    private static final List<UwbAddress> DEST_ADDRESS_LIST = new ArrayList<>();
+    private static final int SLOT_DURATION_RSTU = 100;
+    private static final int STS_INDEX = 2;
+    private static final int FCS_TYPE = 1;
+    private static final int DEVICE_ROLE = 0;
+    private static final int RFRAME_CONFIG = 2;
+    private static final int PREAMBLE_CODE_INDEX = 9;
+    private static final int SFD_ID = 5;
+    private static final int PSDU_DATA_RATE = 680;
+    private static final int PREAMBLE_DURATION = 64;
+    private static final int PRF_MODE = 4;
+    private static final int STS_SEGMENT_COUNT = 3;
+    private static final int NO_OF_PACKETS = 100;
+    private static final int TGAP = 2000;
+    private static final int TSTART = 100;
+    private static final int TWIN = 200;
+    private static final int RANDOMIZE_PSDU = 1;
+    private static final int PHR_RANGING_BIT = 1;
+    private static final int RMARKER_TX_START = 500;
+    private static final int RMARKER_RX_START = 600;
+    private static final int STS_INDEX_AUTO_INCR = 1;
+    private static final int STS_DETECT_BITMAP = 0x0F;
+
+    // String constants for bundle keys
+    private static final class BundleKeys {
+        static final String CHANNEL_NUMBER = "channel_number";
+        static final String NUMBER_OF_CONTROLEES = "number_of_controlees";
+        static final String DEVICE_ADDRESS = "device_address";
+        static final String SLOT_DURATION = "slot_duration";
+        static final String STS_INDEX = "sts_index";
+        static final String FCS_TYPE = "fcs_type";
+        static final String DEVICE_ROLE = "device_role";
+        static final String RFRAME_CONFIG = "rframe_config";
+        static final String PREAMBLE_CODE_INDEX = "preamble_code_index";
+        static final String SFD_ID = "sfd_id";
+        static final String PSDU_DATA_RATE = "psdu_data_rate";
+        static final String PREAMBLE_DURATION = "preamble_duration";
+        static final String PRF_MODE = "prf_mode";
+        static final String STS_SEGMENT_COUNT = "sts_segment_count";
+        static final String NUMBER_OF_PACKETS = "number_of_packets";
+        static final String TGAP = "t_gap";
+        static final String TSTART = "t_start";
+        static final String TWIN = "t_win";
+        static final String RANDOMIZE_PSDU = "randomize_psdu";
+        static final String PHR_RANGING_BIT = "phr_ranging_bit";
+        static final String RMARKER_TX_START = "rmarker_tx_start";
+        static final String RMARKER_RX_START = "rmarker_rx_start";
+        static final String STS_INDEX_AUTO_INCR = "sts_index_auto_incr";
+        static final String STS_DETECT_BITMAP = "sts_detect_bitmap_en";
+    }
+
+    @Before
+    public void setup() {
+        DEST_ADDRESS_LIST.add(DEVICE_ADDRESS);
+    }
+
+    @Test
+    public void testRfTestOpenSessionParams() {
+        RfTestOpenSessionParams.Builder originalBuilder = new RfTestOpenSessionParams.Builder()
+                .setChannelNumber(UWB_CHANNEL)
+                .setNumberOfControlee(NO_OF_CONTROLEE)
+                .setDeviceAddress(DEVICE_ADDRESS)
+                .setDestAddressList(DEST_ADDRESS_LIST)
+                .setSlotDurationRstu(SLOT_DURATION_RSTU)
+                .setStsIndex(STS_INDEX)
+                .setFcsType(FCS_TYPE)
+                .setDeviceRole(DEVICE_ROLE)
+                .setRframeConfig(RFRAME_CONFIG)
+                .setPreambleCodeIndex(PREAMBLE_CODE_INDEX)
+                .setSfdId(SFD_ID)
+                .setPsduDataRate(PSDU_DATA_RATE)
+                .setPreambleDuration(PREAMBLE_DURATION)
+                .setPrfMode(PRF_MODE)
+                .setStsSegmentCount(STS_SEGMENT_COUNT)
+                .setNumberOfPackets(NO_OF_PACKETS)
+                .setTgap(TGAP)
+                .setTstart(TSTART)
+                .setTwin(TWIN)
+                .setRandomizePsdu(RANDOMIZE_PSDU)
+                .setPhrRangingBit(PHR_RANGING_BIT)
+                .setRmarkerTxStart(RMARKER_TX_START)
+                .setRmarkerRxStart(RMARKER_RX_START)
+                .setStsIndexAutoIncr(STS_INDEX_AUTO_INCR)
+                .setStsDetectBitmap(STS_DETECT_BITMAP);
+
+        RfTestOpenSessionParams params = originalBuilder.build();
+        PersistableBundle bundle = params.toBundle();
+        RfTestOpenSessionParams newParams = RfTestOpenSessionParams.fromBundle(bundle);
+
+        //test Builder
+        verifyParams(params);
+        //test bundle
+        verifyParams(newParams);
+    }
+
+    @Test
+    public void testInvalidBundleThrowsException() {
+        PersistableBundle invalidBundle = new PersistableBundle();
+        invalidBundle.putInt("invalid_key", 123);
+
+        // Assert
+        assertThrows(IllegalArgumentException.class,
+                () -> RfTestOpenSessionParams.fromBundle(invalidBundle));
+    }
+
+    private void verifyParams(RfTestOpenSessionParams params) {
+        assertNotNull(params);
+        assertEquals(UWB_CHANNEL, params.getChannelNumber());
+        assertEquals(NO_OF_CONTROLEE, params.getNoOfControlee());
+        assertEquals(DEVICE_ADDRESS, params.getDeviceAddress());
+        assertEquals(DEST_ADDRESS_LIST, params.getDestAddressList());
+        assertEquals(SLOT_DURATION_RSTU, params.getSlotDurationRstu());
+        assertEquals(STS_INDEX, params.getStsIndex());
+        assertEquals(FCS_TYPE, params.getFcsType());
+        assertEquals(DEVICE_ROLE, params.getDeviceRole());
+        assertEquals(RFRAME_CONFIG, params.getRframeConfig());
+        assertEquals(PREAMBLE_CODE_INDEX, params.getPreambleCodeIndex());
+        assertEquals(SFD_ID, params.getSfdId());
+        assertEquals(PSDU_DATA_RATE, params.getPsduDataRate());
+        assertEquals(PREAMBLE_DURATION, params.getPreambleDuration());
+        assertEquals(PRF_MODE, params.getPrfMode());
+        assertEquals(STS_SEGMENT_COUNT, params.getStsSegmentCount());
+        assertEquals(NO_OF_PACKETS, params.getNumberOfPackets());
+        assertEquals(TGAP, params.getTgap());
+        assertEquals(TSTART, params.getTstart());
+        assertEquals(TWIN, params.getTwin());
+        assertEquals(RANDOMIZE_PSDU, params.getRandomizePsdu());
+        assertEquals(PHR_RANGING_BIT, params.getPhrRangingBit());
+        assertEquals(RMARKER_TX_START, params.getRmarkerTxStart());
+        assertEquals(RMARKER_RX_START, params.getRmarkerRxStart());
+        assertEquals(STS_INDEX_AUTO_INCR, params.getStsIndexAutoIncr());
+        assertEquals(STS_DETECT_BITMAP, params.getStsDetectBitmap());
+    }
+}
diff --git a/service/tests/src/com/android/server/uwb/UwbConfigurationManagerTest.java b/service/tests/src/com/android/server/uwb/UwbConfigurationManagerTest.java
index 6fb089a9..13e41bda 100644
--- a/service/tests/src/com/android/server/uwb/UwbConfigurationManagerTest.java
+++ b/service/tests/src/com/android/server/uwb/UwbConfigurationManagerTest.java
@@ -65,6 +65,7 @@ import com.google.uwb.support.fira.FiraParams;
 import com.google.uwb.support.fira.FiraProtocolVersion;
 import com.google.uwb.support.radar.RadarOpenSessionParams;
 import com.google.uwb.support.radar.RadarParams;
+import com.google.uwb.support.rftest.RfTestOpenSessionParams;
 
 import org.junit.Before;
 import org.junit.Test;
@@ -73,6 +74,7 @@ import org.mockito.Mock;
 import org.mockito.MockitoAnnotations;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 
 /**
@@ -114,6 +116,34 @@ public class UwbConfigurationManagerTest {
                     .setRadarDataType(RadarParams.RADAR_DATA_TYPE_RADAR_SWEEP_SAMPLES)
                     .build();
 
+    private static final RfTestOpenSessionParams TEST_RFTEST_OPEN_SESSION_PARAMS =
+            new RfTestOpenSessionParams.Builder()
+                .setChannelNumber(FiraParams.UWB_CHANNEL_5)
+                .setNumberOfControlee(1)
+                .setDeviceAddress(UwbAddress.fromBytes(new byte[] { 0x4, 0x6}))
+                .setDestAddressList(Arrays.asList(UwbAddress.fromBytes(new byte[] { 0x4, 0x6})))
+                .setSlotDurationRstu(2400)
+                .setStsIndex(0)
+                .setFcsType(0)
+                .setDeviceRole(1)
+                .setRframeConfig(FiraParams.RFRAME_CONFIG_SP3)
+                .setPreambleCodeIndex(90)
+                .setSfdId(2)
+                .setPsduDataRate(0)
+                .setPreambleDuration(0)
+                .setPrfMode(FiraParams.PRF_MODE_HPRF)
+                .setStsSegmentCount(1)
+                .setNumberOfPackets(1000)
+                .setTgap(2000)
+                .setTstart(450)
+                .setTwin(750)
+                .setRandomizePsdu(0)
+                .setPhrRangingBit(0)
+                .setRmarkerTxStart(0)
+                .setRmarkerRxStart(0)
+                .setStsIndexAutoIncr(0)
+                .setStsDetectBitmap(0)
+                .build();
     @Before
     public void setUp() throws Exception {
         MockitoAnnotations.initMocks(this);
@@ -199,6 +229,22 @@ public class UwbConfigurationManagerTest {
         verify(mNativeUwbManager).getCapsInfo(TEST_CHIP_ID);
     }
 
+    @Test
+    public void testSetRfTestAppConfigurations() throws Exception {
+        byte[] cfgStatus = {0x01, UwbUciConstants.STATUS_CODE_OK};
+        UwbConfigStatusData appConfig = new UwbConfigStatusData(UwbUciConstants.STATUS_CODE_OK,
+                1, cfgStatus);
+        when(mNativeUwbManager.setRfTestAppConfigurations(anyInt(), anyInt(), anyInt(),
+                any(byte[].class), anyString())).thenReturn(appConfig);
+
+        int status = mUwbConfigurationManager.setRfTestAppConfigurations(
+                mUwbSession.getSessionId(), TEST_RFTEST_OPEN_SESSION_PARAMS, TEST_CHIP_ID);
+
+        verify(mNativeUwbManager).setRfTestAppConfigurations(anyInt(), anyInt(), anyInt(),
+                any(byte[].class), eq(TEST_CHIP_ID));
+        assertEquals(UwbUciConstants.STATUS_CODE_OK, status);
+    }
+
     private FiraOpenSessionParams getFiraParams() {
         FiraProtocolVersion protocolVersion = FiraParams.PROTOCOL_VERSION_1_1;
         int sessionId = 10;
diff --git a/service/tests/src/com/android/server/uwb/UwbCountryCodeTest.java b/service/tests/src/com/android/server/uwb/UwbCountryCodeTest.java
index b3977425..89c83c7f 100644
--- a/service/tests/src/com/android/server/uwb/UwbCountryCodeTest.java
+++ b/service/tests/src/com/android/server/uwb/UwbCountryCodeTest.java
@@ -148,13 +148,23 @@ public class UwbCountryCodeTest {
                 .thenReturn(mLocationManager);
         when(mSubscriptionManager.getActiveSubscriptionInfoList()).thenReturn(List.of(
                 new SubscriptionInfo(
-                TEST_SUBSCRIPTION_ID, "", TEST_SLOT_IDX, "", "", 0, 0, "", 0, null, "", "", "",
-                        true /* isEmbedded */, null, "", 25, false, null, false, 0, 0, 0, null,
+                TEST_SUBSCRIPTION_ID, "", TEST_SLOT_IDX, "", "", 0, 0, "", 0, null, "901", "345",
+                        "", true /* isEmbedded */, null, "", 25, false, null, false, 0, 0, 0, null,
                         null, true, 0),
                 new SubscriptionInfo(
                         TEST_SUBSCRIPTION_ID_OTHER, "", TEST_SLOT_IDX_OTHER, "", "", 0, 0, "", 0,
-                        null, "", "", "", true /* isEmbedded */, null, "", 25, false, null, false,
-                        0, 0, 0, null, null, true, 0)
+                        null, "450", "08", "", true /* isEmbedded */, null, "", 25, false, null,
+                        false, 0, 0, 0, null, null, true, 0)
+        ));
+        when(mSubscriptionManager.getCompleteActiveSubscriptionInfoList()).thenReturn(List.of(
+                new SubscriptionInfo(
+                TEST_SUBSCRIPTION_ID, "", TEST_SLOT_IDX, "", "", 0, 0, "", 0, null, "901", "345",
+                        "", true /* isEmbedded */, null, "", 25, false, null, false, 0, 0, 0, null,
+                        null, true, 0),
+                new SubscriptionInfo(
+                        TEST_SUBSCRIPTION_ID_OTHER, "", TEST_SLOT_IDX_OTHER, "", "", 0, 0, "", 0,
+                        null, "450", "08", "", true /* isEmbedded */, null, "", 25, false, null,
+                        false, 0, 0, 0, null, null, true, 0)
         ));
         when(mContext.getPackageManager()).thenReturn(mPackageManager);
         when(mLocation.getLatitude()).thenReturn(0.0);
@@ -615,4 +625,20 @@ public class UwbCountryCodeTest {
 
         verify(mLocationManager).removeUpdates(mLocationListenerCaptor.capture());
     }
-}
+
+    @Test
+    public void testMccMncOemOverrideCountryCode() {
+        String[] mccMncList = new String[]{ "901", "45008", "45006" };
+        when(mUwbInjector.getOemDefaultCountryCode()).thenReturn(TEST_COUNTRY_CODE_OTHER);
+        when(mDeviceConfigFacade.getMccMncOemOverrideList()).thenReturn(mccMncList);
+        mUwbCountryCode.initialize();
+        clearInvocations(mNativeUwbManager, mListener);
+        verify(mContext).registerReceiver(
+                mTelephonyCountryCodeReceiverCaptor.capture(), any(), any(), any());
+        Intent intent = new Intent(TelephonyManager.ACTION_SIM_CARD_STATE_CHANGED);
+        mTelephonyCountryCodeReceiverCaptor.getValue().onReceive(mock(Context.class), intent);
+        verify(mNativeUwbManager).setCountryCode(
+                TEST_COUNTRY_CODE_OTHER.getBytes(StandardCharsets.UTF_8));
+        verify(mListener).onCountryCodeChanged(STATUS_CODE_OK, TEST_COUNTRY_CODE_OTHER);
+    }
+}
\ No newline at end of file
diff --git a/service/tests/src/com/android/server/uwb/UwbServiceCoreTest.java b/service/tests/src/com/android/server/uwb/UwbServiceCoreTest.java
index fc74f83d..2cf18b64 100644
--- a/service/tests/src/com/android/server/uwb/UwbServiceCoreTest.java
+++ b/service/tests/src/com/android/server/uwb/UwbServiceCoreTest.java
@@ -48,6 +48,7 @@ import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.ArgumentMatchers.argThat;
 import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.clearInvocations;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.mock;
@@ -117,6 +118,9 @@ import com.google.uwb.support.generic.GenericParams;
 import com.google.uwb.support.generic.GenericSpecificationParams;
 import com.google.uwb.support.radar.RadarOpenSessionParams;
 import com.google.uwb.support.radar.RadarParams;
+import com.google.uwb.support.rftest.RfTestOpenSessionParams;
+import com.google.uwb.support.rftest.RfTestParams;
+import com.google.uwb.support.rftest.RfTestStartSessionParams;
 
 import org.junit.After;
 import org.junit.Before;
@@ -227,6 +231,41 @@ public class UwbServiceCoreTest {
                         .setPrfMode(FiraParams.PRF_MODE_HPRF)
                         .setNumberOfBursts(1000)
                         .setRadarDataType(RadarParams.RADAR_DATA_TYPE_RADAR_SWEEP_SAMPLES);
+
+    private static final RfTestOpenSessionParams.Builder TEST_RFTEST_OPEN_SESSION_PARAMS =
+                            new RfTestOpenSessionParams.Builder()
+                            .setChannelNumber(FiraParams.UWB_CHANNEL_5)
+                            .setNumberOfControlee(1)
+                            .setDeviceAddress(UwbAddress.fromBytes(new byte[] { 0x4, 0x6}))
+                            .setDestAddressList(Arrays.asList(UwbAddress.fromBytes(
+                                    new byte[] { 0x4, 0x6})))
+                            .setSlotDurationRstu(2400)
+                            .setStsIndex(0)
+                            .setFcsType(0)
+                            .setDeviceRole(RANGING_DEVICE_ROLE_RESPONDER)
+                            .setRframeConfig(FiraParams.RFRAME_CONFIG_SP3)
+                            .setPreambleCodeIndex(90)
+                            .setSfdId(2)
+                            .setPsduDataRate(0)
+                            .setPreambleDuration(RadarParams.PREAMBLE_DURATION_T16384_SYMBOLS)
+                            .setPrfMode(FiraParams.PRF_MODE_HPRF)
+                            .setStsSegmentCount(1)
+                            .setNumberOfPackets(1000)
+                            .setTgap(2000)
+                            .setTstart(450)
+                            .setTwin(750)
+                            .setRandomizePsdu(0)
+                            .setPhrRangingBit(0)
+                            .setRmarkerTxStart(0)
+                            .setRmarkerRxStart(0)
+                            .setStsIndexAutoIncr(0)
+                            .setStsDetectBitmap(0);
+
+    private static final RfTestStartSessionParams.Builder TEST_RFTEST_START_SESSION_PARAMS =
+            new RfTestStartSessionParams.Builder()
+                    .setRfTestOperationType(RfTestParams.TEST_PERIODIC_TX)
+                    .setPsduData(new byte[] {});
+
     private static final UwbDeviceInfoResponse UWB_DEVICE_INFO_RESPONSE =
             new UwbDeviceInfoResponse(
                     UwbUciConstants.STATUS_CODE_OK,
@@ -408,6 +447,12 @@ public class UwbServiceCoreTest {
         mTestLooper.dispatchAll();
     }
 
+    private void requestHwEnabled(boolean isHwEnabled, AttributionSource attributionSource)
+            throws Exception {
+        mUwbServiceCore.requestHwEnabled(isHwEnabled, attributionSource, mock(IBinder.class));
+        mTestLooper.dispatchAll();
+    }
+
     @Test
     public void testGetSpecificationInfoSuccess() throws Exception {
         enableUwbWithCountryCodeChangedCallback();
@@ -775,6 +820,7 @@ public class UwbServiceCoreTest {
         // Disable UWB.
         disableUwb();
 
+        verify(mUwbSessionManager).deInitAllSession();
         verify(mNativeUwbManager).doDeinitialize();
         verify(mUwbMetrics).logUwbStateChangeEvent(false, true, false);
         verify(cb).onAdapterStateChanged(UwbManager.AdapterStateCallback.STATE_DISABLED,
@@ -820,6 +866,7 @@ public class UwbServiceCoreTest {
         mUwbServiceCore.setEnabled(false);
         mTestLooper.dispatchAll();
 
+        verify(mUwbSessionManager).deInitAllSession();
         verify(mNativeUwbManager).doDeinitialize();
         verify(mUwbWakeLock, times(1)).acquire();
         verify(mUwbWakeLock, times(2)).isHeld();
@@ -933,23 +980,24 @@ public class UwbServiceCoreTest {
         assertThat(mUwbServiceCore.getAdapterState())
                 .isEqualTo(AdapterState.STATE_ENABLED_INACTIVE);
 
-        clearInvocations(mNativeUwbManager, mUwbCountryCode, cb);
+        clearInvocations(mNativeUwbManager, mUwbCountryCode, cb, mUwbSessionManager);
 
         // Disable UWB.
         disableUwb();
 
+        verify(mUwbSessionManager).deInitAllSession();
         verify(mNativeUwbManager).doDeinitialize();
         verify(cb).onAdapterStateChanged(UwbManager.AdapterStateCallback.STATE_DISABLED,
                 StateChangeReason.SYSTEM_POLICY);
         verifyNoMoreInteractions(mUwbCountryCode);
         assertThat(mUwbServiceCore.getAdapterState()).isEqualTo(AdapterState.STATE_DISABLED);
 
-        clearInvocations(mNativeUwbManager, mUwbCountryCode, cb);
+        clearInvocations(mNativeUwbManager, mUwbCountryCode, cb, mUwbSessionManager);
 
         // Disable again. should be ignored.
         disableUwb();
 
-        verifyNoMoreInteractions(mNativeUwbManager, cb);
+        verifyNoMoreInteractions(mNativeUwbManager, cb, mUwbSessionManager);
         assertThat(mUwbServiceCore.getAdapterState()).isEqualTo(AdapterState.STATE_DISABLED);
     }
 
@@ -975,7 +1023,7 @@ public class UwbServiceCoreTest {
         verifyNoMoreInteractions(cb);
         assertThat(mUwbServiceCore.getAdapterState()).isEqualTo(AdapterState.STATE_DISABLED);
 
-        clearInvocations(mNativeUwbManager, mUwbCountryCode, cb);
+        clearInvocations(mNativeUwbManager, mUwbCountryCode, cb, mUwbSessionManager);
 
         // Later on, the onCountryCodeChanged() callback is invoked, with a valid country code.
         when(mUwbCountryCode.getCountryCode()).thenReturn(VALID_COUNTRY_CODE);
@@ -987,18 +1035,19 @@ public class UwbServiceCoreTest {
         assertThat(mUwbServiceCore.getAdapterState())
                 .isEqualTo(AdapterState.STATE_ENABLED_INACTIVE);
 
-        clearInvocations(mNativeUwbManager, mUwbCountryCode, cb);
+        clearInvocations(mNativeUwbManager, mUwbCountryCode, cb, mUwbSessionManager);
 
         // Disable UWB.
         disableUwb();
 
+        verify(mUwbSessionManager).deInitAllSession();
         verify(mNativeUwbManager).doDeinitialize();
         verify(cb).onAdapterStateChanged(UwbManager.AdapterStateCallback.STATE_DISABLED,
                 StateChangeReason.SYSTEM_POLICY);
         verifyNoMoreInteractions(cb);
         assertThat(mUwbServiceCore.getAdapterState()).isEqualTo(AdapterState.STATE_DISABLED);
 
-        clearInvocations(mNativeUwbManager, mUwbCountryCode, cb);
+        clearInvocations(mNativeUwbManager, mUwbCountryCode, cb, mUwbSessionManager);
 
         // Enable again (this time we get the onCountryCodeChanged() callback with a valid
         // country code as it's known).
@@ -1024,7 +1073,7 @@ public class UwbServiceCoreTest {
         mUwbServiceCore.registerAdapterStateCallbacks(cb);
         verify(cb).onAdapterStateChanged(UwbManager.AdapterStateCallback.STATE_DISABLED,
                 StateChangeReason.UNKNOWN);
-        clearInvocations(mNativeUwbManager, mUwbCountryCode, cb);
+        clearInvocations(mNativeUwbManager, mUwbCountryCode, cb, mUwbSessionManager);
 
         doAnswer(new Answer() {
             @Override
@@ -1045,6 +1094,7 @@ public class UwbServiceCoreTest {
 
         verify(mNativeUwbManager).doInitialize();
         verify(mUwbCountryCode).setCountryCode(anyBoolean());
+        verify(mUwbSessionManager).deInitAllSession();
         verify(mNativeUwbManager).doDeinitialize();
 
         // We expect one onAdapterStateChanged() call each, for the "UWB Enabled" and final
@@ -1190,6 +1240,39 @@ public class UwbServiceCoreTest {
         verifyNoMoreInteractions(mUwbSessionManager);
     }
 
+    @Test
+    public void testOpenRfTestSession() throws Exception {
+        enableUwbWithCountryCodeChangedCallback();
+
+        SessionHandle sessionHandle = mock(SessionHandle.class);
+        IUwbRangingCallbacks cb = mock(IUwbRangingCallbacks.class);
+        RfTestOpenSessionParams params = TEST_RFTEST_OPEN_SESSION_PARAMS.build();
+        AttributionSource attributionSource = TEST_ATTRIBUTION_SOURCE;
+        mUwbServiceCore.openRanging(
+                attributionSource, sessionHandle, cb, params.toBundle(), TEST_DEFAULT_CHIP_ID);
+
+        verify(mUwbSessionManager).initSession(
+                eq(attributionSource),
+                eq(sessionHandle), eq(params.getSessionId()), eq((byte) params.getSessionType()),
+                eq(RfTestParams.PROTOCOL_NAME),
+                argThat(p -> ((RfTestOpenSessionParams) p).getSessionId() == params.getSessionId()),
+                eq(cb), eq(TEST_DEFAULT_CHIP_ID));
+    }
+
+    @Test
+    public void testStartRfTest() throws Exception {
+        enableUwbWithCountryCodeChangedCallback();
+
+        SessionHandle sessionHandle = mock(SessionHandle.class);
+        RfTestStartSessionParams params = TEST_RFTEST_START_SESSION_PARAMS.build();
+        mUwbServiceCore.startRanging(sessionHandle, params.toBundle());
+
+        verify(mUwbSessionManager).startRanging(eq(sessionHandle),
+                argThat(p ->
+                ((RfTestStartSessionParams) p).getRfTestOperationType()
+                        == params.getRfTestOperationType()));
+    }
+
     @Test
     public void testStartAliroRanging() throws Exception {
         enableUwbWithCountryCodeChangedCallback();
@@ -1746,6 +1829,7 @@ public class UwbServiceCoreTest {
         mTestLooper.dispatchAll();
 
         // Verify UWB toggle off.
+        verify(mUwbSessionManager).deInitAllSession();
         verify(mNativeUwbManager).doDeinitialize();
         verify(cb).onAdapterStateChanged(UwbManager.AdapterStateCallback.STATE_DISABLED,
                 StateChangeReason.SYSTEM_POLICY);
@@ -1766,7 +1850,7 @@ public class UwbServiceCoreTest {
         mUwbServiceCore.registerAdapterStateCallbacks(cb);
         verify(cb).onAdapterStateChanged(UwbManager.AdapterStateCallback.STATE_DISABLED,
                 StateChangeReason.UNKNOWN);
-        clearInvocations(mNativeUwbManager, mUwbCountryCode, cb);
+        clearInvocations(mNativeUwbManager, mUwbCountryCode, cb, mUwbSessionManager);
 
         // UWB Adapter State will internally be Enabled, but we expect an AdapterState notification
         // with State DISABLED to be sent (as the country code is not valid).
@@ -1778,7 +1862,7 @@ public class UwbServiceCoreTest {
         assertThat(mUwbServiceCore.getAdapterState()).isEqualTo(AdapterState.STATE_DISABLED);
         verifyNoMoreInteractions(cb);
 
-        clearInvocations(mNativeUwbManager, mUwbCountryCode, cb);
+        clearInvocations(mNativeUwbManager, mUwbCountryCode, cb, mUwbSessionManager);
 
         // UWB Enable is expected to result in setting the country code; but that may fail and the
         // onCountryCode() callback is not invoked, as the country code is not valid.
@@ -1795,6 +1879,7 @@ public class UwbServiceCoreTest {
         // with the AdapterState remaining the same as before (STATE_DISABLED). The reason is
         // SYSTEM_POLICY for first notification (Uwb disable) and SYSTEM_REGULATION for the second
         // notification (Uwb enable), as the country code is invalid.
+        verify(mUwbSessionManager).deInitAllSession();
         verify(mNativeUwbManager).doDeinitialize();
         verify(mNativeUwbManager).doInitialize();
         verify(cb).onAdapterStateChanged(
@@ -2067,4 +2152,79 @@ public class UwbServiceCoreTest {
         }
         return paramsBuilder.build();
     }
+
+    @Test
+    public void testRequestHwEnabled_WhenUwbEnabled() throws Exception {
+        when(mDeviceConfigFacade.isHwIdleTurnOffEnabled()).thenReturn(true);
+
+        IUwbAdapterStateCallbacks cb = mock(IUwbAdapterStateCallbacks.class);
+        when(cb.asBinder()).thenReturn(mock(IBinder.class));
+        mUwbServiceCore.registerAdapterStateCallbacks(cb);
+        verify(cb).onAdapterStateChanged(UwbManager.AdapterStateCallback.STATE_DISABLED,
+                StateChangeReason.UNKNOWN);
+        clearInvocations(cb);
+
+        // Enable (with country code initially unknown, like at boot time).
+        enableUwbWithCountryCodeChangedCallback();
+        verify(cb).onAdapterStateChanged(eq(UwbManager.AdapterStateCallback.STATE_ENABLED_HW_IDLE),
+                anyInt());
+        clearInvocations(cb);
+
+        // Request HW enabled.
+        requestHwEnabled(true, TEST_ATTRIBUTION_SOURCE);
+
+        verify(mNativeUwbManager).doInitialize();
+        verify(mUwbMetrics).logUwbStateChangeEvent(true, true, false);
+        verify(mUwbCountryCode).setCountryCode(true);
+        verify(cb, atLeastOnce()).onAdapterStateChanged(
+                eq(UwbManager.AdapterStateCallback.STATE_ENABLED_INACTIVE),
+                anyInt());
+        verifyNoMoreInteractions(cb);
+        assertThat(mUwbServiceCore.getAdapterState())
+                .isEqualTo(AdapterState.STATE_ENABLED_INACTIVE);
+    }
+
+    @Test
+    public void testRequestHwEnabledThenHwDisabled_WhenUwbEnabled() throws Exception {
+        when(mDeviceConfigFacade.isHwIdleTurnOffEnabled()).thenReturn(true);
+
+        IUwbAdapterStateCallbacks cb = mock(IUwbAdapterStateCallbacks.class);
+        when(cb.asBinder()).thenReturn(mock(IBinder.class));
+        mUwbServiceCore.registerAdapterStateCallbacks(cb);
+        verify(cb).onAdapterStateChanged(UwbManager.AdapterStateCallback.STATE_DISABLED,
+                StateChangeReason.UNKNOWN);
+        clearInvocations(cb);
+
+        // Enable (with country code initially unknown, like at boot time).
+        enableUwbWithCountryCodeChangedCallback();
+        verify(cb).onAdapterStateChanged(eq(UwbManager.AdapterStateCallback.STATE_ENABLED_HW_IDLE),
+                anyInt());
+        clearInvocations(cb);
+
+        // Request HW enabled.
+        requestHwEnabled(true, TEST_ATTRIBUTION_SOURCE);
+
+        verify(mNativeUwbManager).doInitialize();
+        verify(mUwbMetrics).logUwbStateChangeEvent(true, true, false);
+        verify(mUwbCountryCode).setCountryCode(true);
+        verify(cb, atLeastOnce()).onAdapterStateChanged(
+                eq(UwbManager.AdapterStateCallback.STATE_ENABLED_INACTIVE),
+                anyInt());
+        verifyNoMoreInteractions(cb);
+        assertThat(mUwbServiceCore.getAdapterState())
+                .isEqualTo(AdapterState.STATE_ENABLED_INACTIVE);
+        clearInvocations(cb);
+
+        // Request HW disabled.
+        when(mNativeUwbManager.doDeinitialize()).thenReturn(true);
+        requestHwEnabled(false, TEST_ATTRIBUTION_SOURCE);
+
+        verify(mUwbSessionManager).deInitAllSession();
+        verify(mNativeUwbManager).doDeinitialize();
+        verify(mUwbMetrics).logUwbStateChangeEvent(false, true, false);
+        verify(cb, atLeastOnce()).onAdapterStateChanged(
+                eq(UwbManager.AdapterStateCallback.STATE_ENABLED_HW_IDLE),
+                anyInt());
+        assertThat(mUwbServiceCore.getAdapterState()).isEqualTo(AdapterState.STATE_ENABLED_HW_IDLE);
+    }
 }
diff --git a/service/tests/src/com/android/server/uwb/UwbSessionManagerTest.java b/service/tests/src/com/android/server/uwb/UwbSessionManagerTest.java
index 10868418..48e1e002 100644
--- a/service/tests/src/com/android/server/uwb/UwbSessionManagerTest.java
+++ b/service/tests/src/com/android/server/uwb/UwbSessionManagerTest.java
@@ -148,6 +148,8 @@ import com.google.uwb.support.fira.FiraSpecificationParams;
 import com.google.uwb.support.generic.GenericSpecificationParams;
 import com.google.uwb.support.radar.RadarOpenSessionParams;
 import com.google.uwb.support.radar.RadarParams;
+import com.google.uwb.support.rftest.RfTestParams;
+import com.google.uwb.support.rftest.RfTestStartSessionParams;
 
 import org.junit.After;
 import org.junit.Before;
@@ -211,6 +213,7 @@ public class UwbSessionManagerTest {
                     .setMinPhyVersionSupported(FIRA_VERSION_1_0)
                     .setMaxPhyVersionSupported(FIRA_VERSION_1_1)
                     .setSupportedChannels(List.of(9))
+                    .setMaxMessageSize(0xFF)
                     .setRangeDataNtfConfigCapabilities(
                             EnumSet.of(
                                         HAS_RANGE_DATA_NTF_CONFIG_DISABLE,
@@ -1038,6 +1041,23 @@ public class UwbSessionManagerTest {
         assertThat(mTestLooper.nextMessage()).isNull();
     }
 
+    @Test
+    public void initSession_maxSessionsExceeded() throws RemoteException {
+        doReturn(GenericSpecificationParams.DEFAULT_MAX_SUPPORTED_SESSIONS_COUNT)
+                .when(mUwbSessionManager).getSessionCount();
+        doReturn(false).when(mUwbSessionManager).isExistedSession(anyInt());
+        IUwbRangingCallbacks mockRangingCallbacks = mock(IUwbRangingCallbacks.class);
+
+        mUwbSessionManager.initSession(ATTRIBUTION_SOURCE, mock(SessionHandle.class),
+                TEST_SESSION_ID, TEST_SESSION_TYPE, FiraParams.PROTOCOL_NAME, mock(Params.class),
+                mockRangingCallbacks,
+                TEST_CHIP_ID);
+
+        verify(mockRangingCallbacks).onRangingOpenFailed(any(),
+                eq(RangingChangeReason.MAX_SESSIONS_REACHED), any());
+        assertThat(mTestLooper.nextMessage()).isNull();
+    }
+
     @Test
     public void initSession_UwbSession_RemoteException() throws RemoteException {
         doReturn(0).when(mUwbSessionManager).getSessionCount();
@@ -1384,6 +1404,42 @@ public class UwbSessionManagerTest {
                 .onRangingStartFailed(any(), eq(UwbUciConstants.STATUS_CODE_FAILED));
     }
 
+    @Test
+    public void startRfTest_currentSessionStateIdle() {
+        doReturn(true).when(mUwbSessionManager).isExistedSession(any());
+        doReturn(RfTestParams.SESSION_ID_RFTEST).when(mUwbSessionManager).getSessionId(any());
+        UwbSession uwbSession = mock(UwbSession.class);
+        when(uwbSession.getProtocolName()).thenReturn(RfTestParams.PROTOCOL_NAME);
+        doReturn(uwbSession).when(mUwbSessionManager).getUwbSession(anyInt());
+        doReturn(UwbUciConstants.UWB_SESSION_STATE_IDLE)
+                .when(mUwbSessionManager).getCurrentSessionState(anyInt());
+
+        RfTestStartSessionParams rfTestParams = mock(RfTestStartSessionParams.class);
+
+        mUwbSessionManager.startRanging(mock(SessionHandle.class), rfTestParams);
+
+        verify(uwbSession).setRfTestStartSessionParams(eq(rfTestParams));
+
+        assertThat(mTestLooper.nextMessage().what).isEqualTo(UwbSessionManager.SESSION_RF_TEST_CMD);
+    }
+
+    @Test
+    public void stopRfTest_currentSessionStateActive() {
+        UwbSession mockUwbSession = mock(UwbSession.class);
+
+        doReturn(true).when(mUwbSessionManager).isExistedSession(any());
+        doReturn(RfTestParams.SESSION_ID_RFTEST).when(mUwbSessionManager).getSessionId(any());
+        doReturn(mockUwbSession).when(mUwbSessionManager).getUwbSession(anyInt());
+        doReturn(UwbUciConstants.UWB_SESSION_STATE_ACTIVE)
+                .when(mUwbSessionManager).getCurrentSessionState(anyInt());
+        doReturn(RfTestParams.PROTOCOL_NAME).when(mockUwbSession).getProtocolName();
+
+        mUwbSessionManager.stopRanging(mock(SessionHandle.class));
+
+        assertThat(mTestLooper.nextMessage().what).isEqualTo(
+                UwbSessionManager.SESSION_STOP_RF_TEST_SESSION);
+    }
+
     @Test
     public void stopRanging_notExistedSession() {
         doReturn(false).when(mUwbSessionManager).isExistedSession(any());
@@ -1399,9 +1455,12 @@ public class UwbSessionManagerTest {
 
     @Test
     public void stopRanging_currentSessionStateActive() {
+        UwbSession mockUwbSession = mock(UwbSession.class);
+
         doReturn(true).when(mUwbSessionManager).isExistedSession(any());
         doReturn(TEST_SESSION_ID).when(mUwbSessionManager).getSessionId(any());
-        doReturn(mock(UwbSession.class)).when(mUwbSessionManager).getUwbSession(anyInt());
+        doReturn(mockUwbSession).when(mUwbSessionManager).getUwbSession(anyInt());
+        when(mockUwbSession.getProtocolName()).thenReturn(FiraParams.PROTOCOL_NAME);
         doReturn(UwbUciConstants.UWB_SESSION_STATE_ACTIVE)
                 .when(mUwbSessionManager).getCurrentSessionState(anyInt());
 
@@ -1438,9 +1497,12 @@ public class UwbSessionManagerTest {
 
     @Test
     public void stopRanging_currentSessionStateIdle() {
+        UwbSession mockUwbSession = mock(UwbSession.class);
+
         doReturn(true).when(mUwbSessionManager).isExistedSession(any());
         doReturn(TEST_SESSION_ID).when(mUwbSessionManager).getSessionId(any());
-        doReturn(mock(UwbSession.class)).when(mUwbSessionManager).getUwbSession(anyInt());
+        doReturn(mockUwbSession).when(mUwbSessionManager).getUwbSession(anyInt());
+        when(mockUwbSession.getProtocolName()).thenReturn(FiraParams.PROTOCOL_NAME);
         doReturn(UwbUciConstants.UWB_SESSION_STATE_IDLE)
                 .when(mUwbSessionManager).getCurrentSessionState(anyInt());
 
@@ -1452,9 +1514,12 @@ public class UwbSessionManagerTest {
 
     @Test
     public void stopRanging_currentSessionStateInvalid() {
+        UwbSession mockUwbSession = mock(UwbSession.class);
+
         doReturn(true).when(mUwbSessionManager).isExistedSession(any());
         doReturn(TEST_SESSION_ID).when(mUwbSessionManager).getSessionId(any());
-        doReturn(mock(UwbSession.class)).when(mUwbSessionManager).getUwbSession(anyInt());
+        doReturn(mockUwbSession).when(mUwbSessionManager).getUwbSession(anyInt());
+        when(mockUwbSession.getProtocolName()).thenReturn(FiraParams.PROTOCOL_NAME);
         doReturn(UwbUciConstants.UWB_SESSION_STATE_ERROR)
                 .when(mUwbSessionManager).getCurrentSessionState(anyInt());
 
@@ -2287,7 +2352,7 @@ public class UwbSessionManagerTest {
         assertThat(alarmListenerCaptor.getValue()).isNotNull();
 
         // Now fire the timer callback.
-        doReturn(UwbUciConstants.UWB_SESSION_STATE_ACTIVE,
+        doReturn(UwbUciConstants.UWB_SESSION_STATE_ACTIVE, UwbUciConstants.UWB_SESSION_STATE_ACTIVE,
                  UwbUciConstants.UWB_SESSION_STATE_IDLE).when(uwbSession).getSessionState();
         alarmListenerCaptor.getValue().onAlarm();
 
@@ -3177,8 +3242,8 @@ public class UwbSessionManagerTest {
         verify(mAlarmManager, never()).cancel(any(AlarmManager.OnAlarmListener.class));
 
         // set up for stop ranging
-        doReturn(UwbUciConstants.UWB_SESSION_STATE_ACTIVE, UwbUciConstants.UWB_SESSION_STATE_IDLE)
-                .when(uwbSession).getSessionState();
+        doReturn(UwbUciConstants.UWB_SESSION_STATE_ACTIVE, UwbUciConstants.UWB_SESSION_STATE_ACTIVE,
+                UwbUciConstants.UWB_SESSION_STATE_IDLE).when(uwbSession).getSessionState();
         when(mNativeUwbManager.stopRanging(eq(TEST_SESSION_ID), anyString()))
                 .thenReturn((byte) UwbUciConstants.STATUS_CODE_OK);
 
@@ -3220,8 +3285,8 @@ public class UwbSessionManagerTest {
         verify(mAlarmManager, never()).cancel(any(AlarmManager.OnAlarmListener.class));
 
         // set up for stop ranging
-        doReturn(UwbUciConstants.UWB_SESSION_STATE_ACTIVE, UwbUciConstants.UWB_SESSION_STATE_IDLE)
-                .when(uwbSession).getSessionState();
+        doReturn(UwbUciConstants.UWB_SESSION_STATE_ACTIVE, UwbUciConstants.UWB_SESSION_STATE_ACTIVE,
+                UwbUciConstants.UWB_SESSION_STATE_IDLE).when(uwbSession).getSessionState();
         when(mNativeUwbManager.stopRanging(eq(TEST_SESSION_ID), anyString()))
                 .thenReturn((byte) UwbUciConstants.STATUS_CODE_OK);
 
@@ -5410,7 +5475,7 @@ public class UwbSessionManagerTest {
     }
 
     @Test
-    public void deinitAllSession() {
+    public void deInitAllSession() {
         UwbSession mockUwbSession1 = mock(UwbSession.class);
         SessionHandle mockSessionHandle1 = mock(SessionHandle.class);
         when(mockUwbSession1.getSessionId()).thenReturn(TEST_SESSION_ID);
@@ -5428,7 +5493,7 @@ public class UwbSessionManagerTest {
         when(mockUwbSession2.getSessionHandle()).thenReturn(mockSessionHandle2);
         mUwbSessionManager.mSessionTable.put(mockSessionHandle2, mockUwbSession2);
 
-        mUwbSessionManager.deinitAllSession();
+        mUwbSessionManager.deInitAllSession();
 
         verify(mUwbSessionNotificationManager, times(2))
                 .onRangingClosedWithApiReasonCode(any(), eq(RangingChangeReason.SYSTEM_POLICY));
@@ -5469,7 +5534,7 @@ public class UwbSessionManagerTest {
         when(mNativeUwbManager.deInitSession(eq(TEST_SESSION_ID), anyString()))
                 .thenReturn((byte) UwbUciConstants.STATUS_CODE_OK);
 
-        mUwbSessionManager.deinitAllSession();
+        mUwbSessionManager.deInitAllSession();
         verify(mUwbSessionNotificationManager).onRangingClosedWithApiReasonCode(
                 eq(uwbSession), eq(RangingChangeReason.SYSTEM_POLICY));
         verify(mUwbMetrics).logRangingCloseEvent(
diff --git a/service/tests/src/com/android/server/uwb/UwbSessionNotificationManagerTest.java b/service/tests/src/com/android/server/uwb/UwbSessionNotificationManagerTest.java
index 7f99669d..2e4bd914 100644
--- a/service/tests/src/com/android/server/uwb/UwbSessionNotificationManagerTest.java
+++ b/service/tests/src/com/android/server/uwb/UwbSessionNotificationManagerTest.java
@@ -62,6 +62,7 @@ import androidx.test.runner.AndroidJUnit4;
 import com.android.server.uwb.data.UwbRadarData;
 import com.android.server.uwb.data.UwbRangingData;
 import com.android.server.uwb.data.UwbUciConstants;
+import com.android.server.uwb.rftest.UwbTestPeriodicTxResult;
 import com.android.uwb.flags.Flags;
 
 import com.google.uwb.support.fira.FiraOnControleeAddRemoveParams;
@@ -800,4 +801,15 @@ public class UwbSessionNotificationManagerTest {
                         == testUwbRadarDataAndRadarData.second.getSweepOffset()),
                 eq(new byte[] {}));
     }
+
+    @Test
+    public void testOnRfTestNotificationReceived() throws Exception {
+        UwbTestPeriodicTxResult periodicTxResult = new UwbTestPeriodicTxResult(0,
+                new byte[] { 0x00 });
+        mUwbSessionNotificationManager.onRfTestNotificationReceived(mUwbSession, periodicTxResult);
+
+        verify(mIOemExtensionCallback).onRangingReportReceived(any());
+
+        verify(mIUwbRangingCallbacks).onRangingResult(eq(mSessionHandle), any());
+    }
 }
diff --git a/service/tests/src/com/android/server/uwb/params/AliroDecoderTest.java b/service/tests/src/com/android/server/uwb/params/AliroDecoderTest.java
index f199e0c2..b4ff4bde 100644
--- a/service/tests/src/com/android/server/uwb/params/AliroDecoderTest.java
+++ b/service/tests/src/com/android/server/uwb/params/AliroDecoderTest.java
@@ -81,6 +81,7 @@ public class AliroDecoderTest {
             "a00111"
                     + "a10400000082"
                     + "a20168"
+                    + "a30103"
                     + "a4020102"
                     + "a50100"
                     + "a60112"
@@ -220,7 +221,7 @@ public class AliroDecoderTest {
         TlvDecoderBuffer tlvDecoderBuffer =
                 new TlvDecoderBuffer(
                         TEST_ALIRO_SPECIFICATION_TLV_DATA_PRIORITIZED_CHANNELS,
-                        TEST_ALIRO_SPECIFICATION_TLV_NUM_PARAMS);
+                        TEST_ALIRO_SPECIFICATION_TLV_DATA_UWBS_MAX_PPM_NUM_PARAMS);
         assertThat(tlvDecoderBuffer.parse()).isTrue();
 
         AliroSpecificationParams aliroSpecificationParams = mAliroDecoder.getParams(
diff --git a/service/tests/src/com/android/server/uwb/params/CccDecoderTest.java b/service/tests/src/com/android/server/uwb/params/CccDecoderTest.java
index e7693890..70c5261e 100644
--- a/service/tests/src/com/android/server/uwb/params/CccDecoderTest.java
+++ b/service/tests/src/com/android/server/uwb/params/CccDecoderTest.java
@@ -81,6 +81,7 @@ public class CccDecoderTest {
             "a00111"
                     + "a10400000082"
                     + "a20168"
+                    + "a30103"
                     + "a4020102"
                     + "a50100"
                     + "a60112"
@@ -216,7 +217,7 @@ public class CccDecoderTest {
         TlvDecoderBuffer tlvDecoderBuffer =
                 new TlvDecoderBuffer(
                         TEST_CCC_SPECIFICATION_TLV_DATA_PRIORITIZED_CHANNELS,
-                        TEST_CCC_SPECIFICATION_TLV_NUM_PARAMS);
+                        TEST_CCC_SPECIFICATION_TLV_DATA_UWBS_MAX_PPM_NUM_PARAMS);
         assertThat(tlvDecoderBuffer.parse()).isTrue();
 
         CccSpecificationParams cccSpecificationParams = mCccDecoder.getParams(
diff --git a/service/tests/src/com/android/server/uwb/params/GenericDecoderTest.java b/service/tests/src/com/android/server/uwb/params/GenericDecoderTest.java
index 000e46a8..e8092c01 100644
--- a/service/tests/src/com/android/server/uwb/params/GenericDecoderTest.java
+++ b/service/tests/src/com/android/server/uwb/params/GenericDecoderTest.java
@@ -67,14 +67,17 @@ public class GenericDecoderTest {
     private static final byte[] TEST_GENERIC_SPECIFICATION_TLV_DATA_VER_2 =
             UwbUtil.getByteArray("C00101" // SUPPORTED_POWER_STATS_QUERY
                             + "C10103" // ANTENNA MODE CAPABILITIES
+                            + "EB0408000000" // MAX SUPPORTED SESSION COUNT
                             + FiraDecoderTest.TEST_FIRA_SPECIFICATION_TLV_STRING_VER_2
                             + TEST_CCC_SPECIFICATION_TLV_DATA_STRING
                             + TEST_RADAR_SPECIFICATION_TLV_DATA_STRING);
-    private static final int TEST_GENERIC_SPECIFICATION_TLV_NUM_PARAMS_VER_2 = 2
+    private static final int TEST_GENERIC_SPECIFICATION_TLV_NUM_PARAMS_VER_2 = 3
             + TEST_FIRA_SPECIFICATION_TLV_NUM_PARAMS_VER_2
             + TEST_CCC_SPECIFICATION_TLV_NUM_PARAMS
             + TEST_RADAR_SPECIFICATION_TLV_NUM_PARAMS;
 
+    private static final int MAX_SUPPORTED_SESSION_COUNT = 8;
+
     @Mock private UwbInjector mUwbInjector;
     @Mock private DeviceConfigFacade mDeviceConfigFacade;
     @Mock private FeatureFlags mFeatureFlags;
@@ -106,6 +109,8 @@ public class GenericDecoderTest {
                            PROTOCOL_VERSION_1_1);
         assertThat(genericSpecificationParams.hasPowerStatsSupport()).isTrue();
         assertThat(genericSpecificationParams.getAntennaModeCapabilities()).isEmpty();
+        assertThat(genericSpecificationParams.getMaxSupportedSessionCount())
+                .isEqualTo(GenericSpecificationParams.DEFAULT_MAX_SUPPORTED_SESSIONS_COUNT);
         FiraDecoderTest.verifyFiraSpecificationVersion1(
                 genericSpecificationParams.getFiraSpecificationParams());
         CccDecoderTest.verifyCccSpecification(
@@ -127,6 +132,8 @@ public class GenericDecoderTest {
                             PROTOCOL_VERSION_1_1);
         assertThat(genericSpecificationParams.hasPowerStatsSupport()).isTrue();
         assertThat(genericSpecificationParams.getAntennaModeCapabilities()).isEmpty();
+        assertThat(genericSpecificationParams.getMaxSupportedSessionCount())
+                .isEqualTo(GenericSpecificationParams.DEFAULT_MAX_SUPPORTED_SESSIONS_COUNT);
         FiraDecoderTest.verifyFiraSpecificationVersion1(
                 genericSpecificationParams.getFiraSpecificationParams());
         CccDecoderTest.verifyCccSpecification(
@@ -150,6 +157,8 @@ public class GenericDecoderTest {
         assertThat(genericSpecificationParams.getAntennaModeCapabilities()).containsExactly(
                 GenericParams.AntennaModeCapabilityFlag.HAS_OMNI_MODE_SUPPORT,
                 GenericParams.AntennaModeCapabilityFlag.HAS_DIRECTIONAL_MODE_SUPPORT);
+        assertThat(genericSpecificationParams.getMaxSupportedSessionCount()).isEqualTo(
+                MAX_SUPPORTED_SESSION_COUNT);
         FiraDecoderTest.verifyFiraSpecificationVersion2(
                 genericSpecificationParams.getFiraSpecificationParams());
         CccDecoderTest.verifyCccSpecification(
@@ -173,6 +182,8 @@ public class GenericDecoderTest {
         assertThat(genericSpecificationParams.getAntennaModeCapabilities()).containsExactly(
                 GenericParams.AntennaModeCapabilityFlag.HAS_OMNI_MODE_SUPPORT,
                 GenericParams.AntennaModeCapabilityFlag.HAS_DIRECTIONAL_MODE_SUPPORT);
+        assertThat(genericSpecificationParams.getMaxSupportedSessionCount()).isEqualTo(
+                MAX_SUPPORTED_SESSION_COUNT);
         FiraDecoderTest.verifyFiraSpecificationVersion2(
                 genericSpecificationParams.getFiraSpecificationParams());
         CccDecoderTest.verifyCccSpecification(
@@ -196,6 +207,8 @@ public class GenericDecoderTest {
                             PROTOCOL_VERSION_1_1);
         assertThat(genericSpecificationParams.hasPowerStatsSupport()).isFalse();
         assertThat(genericSpecificationParams.getAntennaModeCapabilities()).isEmpty();
+        assertThat(genericSpecificationParams.getMaxSupportedSessionCount())
+                .isEqualTo(GenericSpecificationParams.DEFAULT_MAX_SUPPORTED_SESSIONS_COUNT);
         FiraDecoderTest.verifyFiraSpecificationVersion1(
                 genericSpecificationParams.getFiraSpecificationParams());
         RadarDecoderTest.verifyRadarSpecification(
@@ -218,6 +231,8 @@ public class GenericDecoderTest {
                 mGenericDecoder.getParams(tlvDecoderBuffer, GenericSpecificationParams.class,
                             PROTOCOL_VERSION_1_1);
         assertThat(genericSpecificationParams.hasPowerStatsSupport()).isFalse();
+        assertThat(genericSpecificationParams.getMaxSupportedSessionCount())
+                .isEqualTo(GenericSpecificationParams.DEFAULT_MAX_SUPPORTED_SESSIONS_COUNT);
         assertThat(genericSpecificationParams.getAntennaModeCapabilities()).isEmpty();
         CccDecoderTest.verifyCccSpecification(
                 genericSpecificationParams.getCccSpecificationParams());
@@ -242,6 +257,8 @@ public class GenericDecoderTest {
                             PROTOCOL_VERSION_1_1);
         assertThat(genericSpecificationParams.hasPowerStatsSupport()).isFalse();
         assertThat(genericSpecificationParams.getAntennaModeCapabilities()).isEmpty();
+        assertThat(genericSpecificationParams.getMaxSupportedSessionCount())
+                .isEqualTo(GenericSpecificationParams.DEFAULT_MAX_SUPPORTED_SESSIONS_COUNT);
         FiraDecoderTest.verifyFiraSpecificationVersion1(
                 genericSpecificationParams.getFiraSpecificationParams());
         CccDecoderTest.verifyCccSpecification(
diff --git a/service/tests/src/com/android/server/uwb/params/RfTestEncoderTest.java b/service/tests/src/com/android/server/uwb/params/RfTestEncoderTest.java
new file mode 100644
index 00000000..42cbdbd4
--- /dev/null
+++ b/service/tests/src/com/android/server/uwb/params/RfTestEncoderTest.java
@@ -0,0 +1,187 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.uwb.params;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.junit.Assume.assumeTrue;
+
+import android.platform.test.annotations.Presubmit;
+import android.test.suitebuilder.annotation.SmallTest;
+import android.uwb.UwbAddress;
+
+import androidx.test.runner.AndroidJUnit4;
+
+import com.android.modules.utils.build.SdkLevel;
+import com.android.server.uwb.UwbInjector;
+import com.android.server.uwb.util.UwbUtil;
+
+import com.google.uwb.support.fira.FiraParams;
+import com.google.uwb.support.fira.FiraProtocolVersion;
+import com.google.uwb.support.rftest.RfTestOpenSessionParams;
+import com.google.uwb.support.rftest.RfTestParams;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+
+import java.util.Arrays;
+
+/** Unit tests for {@link com.android.server.uwb.params.RfTestEncoder}. */
+@RunWith(AndroidJUnit4.class)
+@SmallTest
+@Presubmit
+public class RfTestEncoderTest {
+    private static final FiraProtocolVersion PROTOCOL_VERSION_DUMMY = new FiraProtocolVersion(0, 0);
+
+    private static final RfTestOpenSessionParams.Builder TEST_RFTEST_OPEN_SESSION_PARAMS =
+            new RfTestOpenSessionParams.Builder()
+                    .setChannelNumber(FiraParams.UWB_CHANNEL_5)
+                    .setNumberOfControlee(1)
+                    .setDeviceAddress(UwbAddress.fromBytes(new byte[]{0x4, 0x6}))
+                    .setDestAddressList(Arrays.asList(UwbAddress.fromBytes(new byte[]{0x4, 0x6})))
+                    .setSlotDurationRstu(2400)
+                    .setStsIndex(0)
+                    .setFcsType(0)
+                    .setDeviceRole(1)
+                    .setRframeConfig(FiraParams.RFRAME_CONFIG_SP3)
+                    .setPreambleCodeIndex(90)
+                    .setSfdId(2)
+                    .setPsduDataRate(0)
+                    .setPreambleDuration(0)
+                    .setPrfMode(FiraParams.PRF_MODE_HPRF)
+                    .setStsSegmentCount(1)
+                    .setNumberOfPackets(1000)
+                    .setTgap(2000)
+                    .setTstart(450)
+                    .setTwin(750)
+                    .setRandomizePsdu(0)
+                    .setPhrRangingBit(0)
+                    .setRmarkerTxStart(0)
+                    .setRmarkerRxStart(0)
+                    .setStsIndexAutoIncr(0)
+                    .setStsDetectBitmap(0);
+
+    private static final int TEST_RFTEST_OPEN_SESSION_PARAMS_TLV_NUMBER = 14;
+    private static final int TEST_RFTEST_PARAMS_TLV_NUMBER = 10;
+
+    private static final String CHANNEL_NUMBER_TLV = "040105";
+    private static final String NUMBER_OF_CONTROLEES_TLV = "050101";
+    private static final String DEVICE_MAC_ADDRESS_TLV = "06020406";
+    private static final String SLOT_DURATION_TLV = "08026009";
+    private static final String STS_INDEX_TLV = "0A0400000000";
+    private static final String MAC_FCS_TYPE_TLV = "0B0100";
+    private static final String DEVICE_ROLE_INITIATOR_TLV = "110101";
+    private static final String RFRAME_CONFIG_TLV = "120103";
+    private static final String PREAMBLE_CODE_INDEX_TLV = "14015A";
+    private static final String SFD_ID_TLV = "150102";
+    private static final String PSDU_DATA_RATE_TLV = "160100";
+    private static final String PREAMBLE_DURATION_TLV = "170100";
+    private static final String PRF_MODE_TLV = "1F0101";
+    private static final String NUMBER_OF_STS_SEGMENTS_TLV = "290101";
+
+    private static final byte[] TEST_RFTEST_OPEN_SESSION_PARAMS_TLV_DATA =
+            UwbUtil.getByteArray(CHANNEL_NUMBER_TLV
+                    + NUMBER_OF_CONTROLEES_TLV
+                    + DEVICE_MAC_ADDRESS_TLV
+                    + SLOT_DURATION_TLV
+                    + STS_INDEX_TLV
+                    + MAC_FCS_TYPE_TLV
+                    + DEVICE_ROLE_INITIATOR_TLV
+                    + RFRAME_CONFIG_TLV
+                    + PREAMBLE_CODE_INDEX_TLV
+                    + SFD_ID_TLV
+                    + PSDU_DATA_RATE_TLV
+                    + PREAMBLE_DURATION_TLV
+                    + PRF_MODE_TLV
+                    + NUMBER_OF_STS_SEGMENTS_TLV);
+
+    private static final String NUM_PACKETS = "000764000000280010";
+    private static final String T_GAP = "010180";
+    private static final String T_START = "020105";
+    private static final String T_WIN = "0302FFFF";
+    private static final String RANDOMIZE_PSDU = "040103";
+    private static final String PHR_RANGING_BIT = "050109";
+    private static final String RMARKER_TX_START = "06015a";
+    private static final String RMARKER_RX_START = "070163";
+    private static final String STS_INDEX_AUTO_INCR = "080100";
+    private static final String STS_DETECT_BITMAP_EN = "090101";
+
+    private static final byte[] TEST_RFTEST_PARAMS_TLV_DATA =
+            UwbUtil.getByteArray(NUM_PACKETS
+                    + T_GAP
+                    + T_START
+                    + T_WIN
+                    + RANDOMIZE_PSDU
+                    + PHR_RANGING_BIT
+                    + RMARKER_TX_START
+                    + RMARKER_RX_START
+                    + STS_INDEX_AUTO_INCR
+                    + STS_DETECT_BITMAP_EN);
+
+    @Mock
+    private UwbInjector mUwbInjector;
+    private final RfTestEncoder mRfTestEncoder = new RfTestEncoder();
+
+    private static void verifyRfTestOpenSessionParamsTlvBuffer(TlvBuffer tlvs) {
+        assertThat(tlvs.getNoOfParams()).isEqualTo(TEST_RFTEST_OPEN_SESSION_PARAMS_TLV_NUMBER);
+        assertThat(tlvs.getByteArray()).isEqualTo(TEST_RFTEST_OPEN_SESSION_PARAMS_TLV_DATA);
+    }
+
+    private static void verifyRfTestParamsTlvBuffer(TlvBuffer tlvs) {
+        assertThat(tlvs.getNoOfParams()).isEqualTo(TEST_RFTEST_PARAMS_TLV_NUMBER);
+        assertThat(tlvs.getByteArray()).isEqualTo(TEST_RFTEST_PARAMS_TLV_DATA);
+    }
+
+    @Test
+    public void testRfTestOpenSessionParamsViaTlvEncoder() throws Exception {
+        assumeTrue(SdkLevel.isAtLeastV());
+        RfTestOpenSessionParams params = TEST_RFTEST_OPEN_SESSION_PARAMS.build();
+
+        verifyRfTestOpenSessionParamsTlvBuffer(
+                TlvEncoder.getEncoder(RfTestParams.PROTOCOL_NAME, mUwbInjector).getTlvBuffer(params,
+                        PROTOCOL_VERSION_DUMMY));
+    }
+
+    @Test
+    public void testRfTestOpenSessionParams() throws Exception {
+        assumeTrue(SdkLevel.isAtLeastV());
+        RfTestOpenSessionParams params = TEST_RFTEST_OPEN_SESSION_PARAMS.build();
+
+        verifyRfTestOpenSessionParamsTlvBuffer(mRfTestEncoder.getTlvBuffer(params,
+                PROTOCOL_VERSION_DUMMY));
+    }
+
+    @Test
+    public void testRfTestParamsViaTlvEncoder() throws Exception {
+        assumeTrue(SdkLevel.isAtLeastV());
+        RfTestOpenSessionParams params = TEST_RFTEST_OPEN_SESSION_PARAMS.build();
+
+        verifyRfTestOpenSessionParamsTlvBuffer(
+                TlvEncoder.getEncoder(RfTestParams.PROTOCOL_NAME, mUwbInjector).getTlvBuffer(params,
+                        PROTOCOL_VERSION_DUMMY));
+    }
+
+    @Test
+    public void testRfTestParams() throws Exception {
+        assumeTrue(SdkLevel.isAtLeastV());
+        RfTestOpenSessionParams params = TEST_RFTEST_OPEN_SESSION_PARAMS.build();
+
+        verifyRfTestOpenSessionParamsTlvBuffer(mRfTestEncoder.getTlvBuffer(params,
+                PROTOCOL_VERSION_DUMMY));
+    }
+}
diff --git a/service/uci/jni/src/jclass_name.rs b/service/uci/jni/src/jclass_name.rs
index f8f6c102..1a228760 100644
--- a/service/uci/jni/src/jclass_name.rs
+++ b/service/uci/jni/src/jclass_name.rs
@@ -32,3 +32,5 @@ pub(crate) const UWB_DL_TDOA_MEASUREMENT_CLASS: &str =
     "com/android/server/uwb/data/UwbDlTDoAMeasurement";
 pub(crate) const UWB_RADAR_DATA_CLASS: &str = "com/android/server/uwb/data/UwbRadarData";
 pub(crate) const UWB_RADAR_SWEEP_DATA_CLASS: &str = "com/android/server/uwb/data/UwbRadarSweepData";
+pub(crate) const RFTEST_PERIODIC_TX_CLASS: &str =
+    "com/android/server/uwb/rftest/UwbTestPeriodicTxResult";
diff --git a/service/uci/jni/src/notification_manager_android.rs b/service/uci/jni/src/notification_manager_android.rs
index 50586d7c..9d33547d 100644
--- a/service/uci/jni/src/notification_manager_android.rs
+++ b/service/uci/jni/src/notification_manager_android.rs
@@ -15,7 +15,7 @@
 //! Implementation of NotificationManagerAndroid and its builder.
 
 use crate::jclass_name::{
-    MULTICAST_LIST_UPDATE_STATUS_CLASS, UWB_DL_TDOA_MEASUREMENT_CLASS,
+    MULTICAST_LIST_UPDATE_STATUS_CLASS, RFTEST_PERIODIC_TX_CLASS, UWB_DL_TDOA_MEASUREMENT_CLASS,
     UWB_OWR_AOA_MEASUREMENT_CLASS, UWB_RADAR_DATA_CLASS, UWB_RADAR_SWEEP_DATA_CLASS,
     UWB_RANGING_DATA_CLASS, UWB_TWO_WAY_MEASUREMENT_CLASS,
 };
@@ -34,7 +34,7 @@ use uwb_core::params::{ControleeStatusList, UwbAddress};
 use uwb_core::uci::uci_manager_sync::{NotificationManager, NotificationManagerBuilder};
 use uwb_core::uci::{
     CoreNotification, DataRcvNotification, RadarDataRcvNotification, RangingMeasurements,
-    SessionNotification, SessionRangeData,
+    RfTestNotification, SessionNotification, SessionRangeData,
 };
 use uwb_uci_packets::{
     radar_bytes_per_sample_value, ExtendedAddressDlTdoaRangingMeasurement,
@@ -1008,6 +1008,35 @@ impl NotificationManagerAndroid {
             ],
         )
     }
+
+    fn on_rf_periodic_tx_notification(
+        &mut self,
+        status: u8,
+        raw_notification_data: &[u8],
+    ) -> Result<JObject, JNIError> {
+        let raw_notification_jbytearray = self.env.byte_array_from_slice(raw_notification_data)?;
+        // Safety: raw_notification_jbytearray safely instantiated above.
+        let raw_notification_jobject = unsafe { JObject::from_raw(raw_notification_jbytearray) };
+
+        let periodic_tx_jclass = NotificationManagerAndroid::find_local_class(
+            &mut self.jclass_map,
+            &self.class_loader_obj,
+            &self.env,
+            RFTEST_PERIODIC_TX_CLASS,
+        )?;
+        let method_sig = "(L".to_owned() + RFTEST_PERIODIC_TX_CLASS + ";)V";
+
+        let periodic_tx_jobject = self.env.new_object(
+            periodic_tx_jclass,
+            "(I[B)V",
+            &[JValue::Int(status as i32), JValue::Object(raw_notification_jobject)],
+        )?;
+        self.cached_jni_call(
+            "onPeriodicTxDataNotificationReceived",
+            &method_sig,
+            &[jvalue::from(JValue::Object(periodic_tx_jobject))],
+        )
+    }
 }
 
 impl NotificationManager for NotificationManagerAndroid {
@@ -1362,6 +1391,24 @@ impl NotificationManager for NotificationManagerAndroid {
         })?;
         Ok(())
     }
+
+    fn on_rf_test_notification(
+        &mut self,
+        rf_test_notification: RfTestNotification,
+    ) -> UwbResult<()> {
+        debug!("UCI JNI: RF test notification callback.");
+        let env = *self.env;
+        env.with_local_frame(MAX_JAVA_OBJECTS_CAPACITY, || match rf_test_notification {
+            RfTestNotification::TestPeriodicTxNtf { status, raw_notification_data } => {
+                self.on_rf_periodic_tx_notification(u8::from(status), &raw_notification_data)
+            }
+        })
+        .map_err(|e| {
+            error!("on_rf_test_notification error: {:?}", e);
+            UwbError::ForeignFunctionInterface
+        })?;
+        Ok(())
+    }
 }
 pub(crate) struct NotificationManagerAndroidBuilder {
     pub chip_id: String,
diff --git a/service/uci/jni/src/uci_jni_android_new.rs b/service/uci/jni/src/uci_jni_android_new.rs
index e612d2af..bf8c0055 100644
--- a/service/uci/jni/src/uci_jni_android_new.rs
+++ b/service/uci/jni/src/uci_jni_android_new.rs
@@ -37,8 +37,9 @@ use log::{debug, error};
 use uwb_core::error::{Error, Result};
 use uwb_core::params::{
     AndroidRadarConfigResponse, AppConfigTlv, CountryCode, GetDeviceInfoResponse, PhaseList,
-    RadarConfigTlv, RawAppConfigTlv, RawUciMessage, SessionUpdateControllerMulticastResponse,
-    SessionUpdateDtTagRangingRoundsResponse, SetAppConfigResponse, UpdateTime,
+    RadarConfigTlv, RawAppConfigTlv, RawUciMessage, RfTestConfigResponse, RfTestConfigTlv,
+    SessionUpdateControllerMulticastResponse, SessionUpdateDtTagRangingRoundsResponse,
+    SetAppConfigResponse, UpdateTime,
 };
 use uwb_uci_packets::{
     AppConfigTlvType, CapTlv, Controlee, ControleePhaseList, Controlee_V2_0_16_Byte_Version,
@@ -478,6 +479,145 @@ fn native_set_app_configurations(
     uci_manager.session_set_app_config(session_id as u32, tlvs)
 }
 
+fn parse_rf_test_config_tlv_vec(
+    no_of_params: i32,
+    mut byte_array: &[u8],
+) -> Result<Vec<RfTestConfigTlv>> {
+    let mut parsed_tlvs_len = 0;
+    let received_tlvs_len = byte_array.len();
+    let mut tlvs = Vec::<RfTestConfigTlv>::new();
+    for _ in 0..no_of_params {
+        // The tlv consists of the type of payload in 1 byte, the length of payload as u8
+        // in 1 byte, and the payload.
+        const TLV_HEADER_SIZE: usize = 2;
+        let tlv = RfTestConfigTlv::parse(byte_array).map_err(|_| Error::BadParameters)?;
+        byte_array = byte_array.get(tlv.v.len() + TLV_HEADER_SIZE..).ok_or(Error::BadParameters)?;
+        parsed_tlvs_len += tlv.v.len() + TLV_HEADER_SIZE;
+        tlvs.push(tlv);
+    }
+    if parsed_tlvs_len != received_tlvs_len {
+        return Err(Error::BadParameters);
+    };
+    Ok(tlvs)
+}
+
+fn create_rf_test_config_response(
+    response: RfTestConfigResponse,
+    env: JNIEnv,
+) -> Result<jbyteArray> {
+    let uwb_config_status_class =
+        env.find_class(CONFIG_STATUS_DATA_CLASS).map_err(|_| Error::ForeignFunctionInterface)?;
+    let mut buf = Vec::<u8>::new();
+    for config_status in &response.config_status {
+        buf.push(u8::from(config_status.cfg_id));
+        buf.push(u8::from(config_status.status));
+    }
+    let config_status_jbytearray =
+        env.byte_array_from_slice(&buf).map_err(|_| Error::ForeignFunctionInterface)?;
+
+    // Safety: config_status_jbytearray is safely instantiated above.
+    let config_status_jobject = unsafe { JObject::from_raw(config_status_jbytearray) };
+    let config_status_jobject = env
+        .new_object(
+            uwb_config_status_class,
+            "(II[B)V",
+            &[
+                JValue::Int(i32::from(response.status)),
+                JValue::Int(response.config_status.len() as i32),
+                JValue::Object(config_status_jobject),
+            ],
+        )
+        .map_err(|_| Error::ForeignFunctionInterface)?;
+    Ok(*config_status_jobject)
+}
+
+/// Set Test configurations on a single UWB device. Return null JObject if failed.
+#[no_mangle]
+pub extern "system" fn Java_com_android_server_uwb_jni_NativeUwbManager_nativeSetRfTestAppConfigurations(
+    env: JNIEnv,
+    obj: JObject,
+    session_id: jint,
+    no_of_params: jint,
+    _rf_test_app_config_param_len: jint,
+    rf_test_app_config_params: jbyteArray,
+    chip_id: JString,
+) -> jbyteArray {
+    debug!("{}: enter", function_name!());
+    match option_result_helper(
+        native_set_rf_test_app_configurations(
+            env,
+            obj,
+            session_id,
+            no_of_params,
+            rf_test_app_config_params,
+            chip_id,
+        ),
+        function_name!(),
+    ) {
+        Some(config_response) => create_rf_test_config_response(config_response, env)
+            .inspect_err(|e| {
+                error!("{} failed with {:?}", function_name!(), &e);
+            })
+            .unwrap_or(*JObject::null()),
+        None => *JObject::null(),
+    }
+}
+
+fn native_set_rf_test_app_configurations(
+    env: JNIEnv,
+    obj: JObject,
+    session_id: jint,
+    no_of_params: jint,
+    app_config_params: jbyteArray,
+    chip_id: JString,
+) -> Result<RfTestConfigResponse> {
+    let uci_manager = Dispatcher::get_uci_manager(env, obj, chip_id)?;
+    let config_byte_array =
+        env.convert_byte_array(app_config_params).map_err(|_| Error::ForeignFunctionInterface)?;
+    let tlvs = parse_rf_test_config_tlv_vec(no_of_params, &config_byte_array)?;
+    uci_manager.session_set_rf_test_app_config(session_id as u32, tlvs)
+}
+
+/// Stop rf test session on a single UWB device. Return value defined by uci_packets.pdl
+#[no_mangle]
+pub extern "system" fn Java_com_android_server_uwb_jni_NativeUwbManager_nativeStopRfTest(
+    env: JNIEnv,
+    obj: JObject,
+    chip_id: JString,
+) -> jbyte {
+    debug!("{}: enter", function_name!());
+    byte_result_helper(native_stop_rf_test(env, obj, chip_id), function_name!())
+}
+
+fn native_stop_rf_test(env: JNIEnv, obj: JObject, chip_id: JString) -> Result<()> {
+    let uci_manager = Dispatcher::get_uci_manager(env, obj, chip_id)?;
+    uci_manager.stop_rf_test()
+}
+
+/// Test RF periodic tx test. Return value defined by uci_packets.pdl
+#[no_mangle]
+pub extern "system" fn Java_com_android_server_uwb_jni_NativeUwbManager_nativeTestPeriodicTx(
+    env: JNIEnv,
+    obj: JObject,
+    psdu_data: jbyteArray,
+    chip_id: JString,
+) -> jbyte {
+    debug!("{}: enter", function_name!());
+    byte_result_helper(native_rf_test_periodic_tx(env, obj, psdu_data, chip_id), function_name!())
+}
+
+fn native_rf_test_periodic_tx(
+    env: JNIEnv,
+    obj: JObject,
+    psdu_data: jbyteArray,
+    chip_id: JString,
+) -> Result<()> {
+    let uci_manager = Dispatcher::get_uci_manager(env, obj, chip_id)?;
+    let psdu_data_bytearray =
+        env.convert_byte_array(psdu_data).map_err(|_| Error::ForeignFunctionInterface)?;
+    uci_manager.rf_test_periodic_tx(psdu_data_bytearray)
+}
+
 /// Set radar app configurations on a single UWB device. Return null JObject if failed.
 #[no_mangle]
 pub extern "system" fn Java_com_android_server_uwb_jni_NativeUwbManager_nativeSetRadarAppConfigurations(
@@ -1621,6 +1761,13 @@ mod tests {
         ) -> Result<()> {
             Ok(())
         }
+
+        fn on_rf_test_notification(
+            &mut self,
+            _: uwb_core::uci::RfTestNotification,
+        ) -> std::result::Result<(), uwb_core::error::Error> {
+            Ok(())
+        }
     }
 
     struct NullNotificationManagerBuilder {}
diff --git a/tests/cts/hostsidetests/multidevices/uwb/Android.bp b/tests/cts/hostsidetests/multidevices/uwb/Android.bp
index bf49520d..128dffee 100644
--- a/tests/cts/hostsidetests/multidevices/uwb/Android.bp
+++ b/tests/cts/hostsidetests/multidevices/uwb/Android.bp
@@ -49,7 +49,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":uwb_snippet",
         "README.md",
@@ -71,7 +71,7 @@ python_test_host {
     test_options: {
         unit_test: false,
     },
-    data: [
+    device_common_data: [
         // Package the snippet with the mobly test
         ":uwb_snippet",
         "README.md",
diff --git a/tests/cts/hostsidetests/multidevices/uwb/FiraRangingTests/ranging_test.py b/tests/cts/hostsidetests/multidevices/uwb/FiraRangingTests/ranging_test.py
index 1499af02..11e2c1be 100644
--- a/tests/cts/hostsidetests/multidevices/uwb/FiraRangingTests/ranging_test.py
+++ b/tests/cts/hostsidetests/multidevices/uwb/FiraRangingTests/ranging_test.py
@@ -386,7 +386,7 @@ class RangingTest(uwb_base_test.UwbBaseTest):
     reconfigure_params = uwb_ranging_params.UwbRangingReconfigureParams(
         block_stride_length=block_stride_length)
     initiator.reconfigure_fira_ranging(reconfigure_params)
-    uwb_test_utils.verify_peer_found(initiator, peer_addr)
+    uwb_test_utils.verify_peer_found(initiator, peer_addr, 0, 10)
 
   def _verify_add_controlee_when_opened_ranging_with_no_controlee(
         self, initiator: uwb_ranging_decorator.UwbRangingDecorator,
@@ -811,8 +811,8 @@ class RangingTest(uwb_base_test.UwbBaseTest):
                                     self.responder_addr)
     self._verify_one_to_one_ranging_reconfigure_ranging_interval(
         self.initiator, self.block_stride_length, self.responder_addr)
-    self.responder.stop_ranging()
-    self.initiator.stop_ranging()
+    self.responder.stop_ranging(0, 10)
+    self.initiator.stop_ranging(0, 10)
 
   def test_ranging_nearby_share_profile_reconfigure_ranging_interval(self):
     """Verifies ranging for device nearby share with default profile."""
@@ -839,8 +839,8 @@ class RangingTest(uwb_base_test.UwbBaseTest):
                                     self.responder_addr)
     self._verify_one_to_one_ranging_reconfigure_ranging_interval(
         self.initiator, self.block_stride_length, self.responder_addr)
-    self.responder.stop_ranging()
-    self.initiator.stop_ranging()
+    self.responder.stop_ranging(0, 10)
+    self.initiator.stop_ranging(0, 10)
 
   def test_ranging_device_tracker_profile_ch9_pr12(self):
     """Verifies ranging with device tracker for channel 9 and preamble 12."""
diff --git a/tests/cts/hostsidetests/multidevices/uwb/lib/uwb_ranging_decorator.py b/tests/cts/hostsidetests/multidevices/uwb/lib/uwb_ranging_decorator.py
index d20eed3f..8ac7cd7d 100644
--- a/tests/cts/hostsidetests/multidevices/uwb/lib/uwb_ranging_decorator.py
+++ b/tests/cts/hostsidetests/multidevices/uwb/lib/uwb_ranging_decorator.py
@@ -242,14 +242,15 @@ class UwbRangingDecorator():
     except errors.ApiError as api_error:
       raise ValueError("Failed to get RSSI measurement.") from api_error
 
-  def stop_ranging(self, session: int = 0):
+  def stop_ranging(self, session: int = 0, timeout: int = STOP_CALLBACK_WAIT_TIME_SEC):
     """Stops UWB ranging session.
 
     Args:
       session: ranging session.
+      timeout: timeout for stop to complete.
     """
     self.ad.uwb.stopRangingSession(self._callback_keys[session])
-    self.verify_callback_received("Stopped", session, STOP_CALLBACK_WAIT_TIME_SEC)
+    self.verify_callback_received("Stopped", session, timeout)
 
   def close_ranging(self, session: int = 0):
     """Closes ranging session.
diff --git a/tests/cts/hostsidetests/multidevices/uwb/snippet/Android.bp b/tests/cts/hostsidetests/multidevices/uwb/snippet/Android.bp
index 44d4d030..bbfe1f71 100644
--- a/tests/cts/hostsidetests/multidevices/uwb/snippet/Android.bp
+++ b/tests/cts/hostsidetests/multidevices/uwb/snippet/Android.bp
@@ -19,9 +19,7 @@ package {
 
 android_test {
     name: "uwb_snippet",
-    // Enable system_35 when available
-    // sdk_version: "system_35",
-    sdk_version: "system_current",
+    sdk_version: "system_35",
     srcs: [
         "UwbManagerSnippet.java",
     ],
diff --git a/tests/cts/hostsidetests/multidevices/uwb/snippet/AndroidManifest.xml b/tests/cts/hostsidetests/multidevices/uwb/snippet/AndroidManifest.xml
index 3fb77441..83ae2ebb 100644
--- a/tests/cts/hostsidetests/multidevices/uwb/snippet/AndroidManifest.xml
+++ b/tests/cts/hostsidetests/multidevices/uwb/snippet/AndroidManifest.xml
@@ -3,7 +3,7 @@
     xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.google.snippet.uwb">
 
-  <uses-permission android:name="android.permissions.UWB_PRIVILEGED" />
+  <uses-permission android:name="android.permission.UWB_PRIVILEGED" />
   <uses-permission android:name="android.permission.UWB_RANGING" />
 
   <application>
diff --git a/tests/cts/hostsidetests/multidevices/uwb/snippet/UwbManagerSnippet.java b/tests/cts/hostsidetests/multidevices/uwb/snippet/UwbManagerSnippet.java
index 1aaf77dd..afc530ec 100644
--- a/tests/cts/hostsidetests/multidevices/uwb/snippet/UwbManagerSnippet.java
+++ b/tests/cts/hostsidetests/multidevices/uwb/snippet/UwbManagerSnippet.java
@@ -55,6 +55,7 @@ import java.util.List;
 import java.util.Set;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
+import java.util.function.Supplier;
 
 /** Snippet class exposing Android APIs for Uwb. */
 public class UwbManagerSnippet implements Snippet {
@@ -80,11 +81,10 @@ public class UwbManagerSnippet implements Snippet {
     private static HashMap<String, UwbAdapterStateCallback> sUwbAdapterStateCallbackMap =
             new HashMap<String, UwbAdapterStateCallback>();
 
-    public UwbManagerSnippet() throws Throwable {
+    public UwbManagerSnippet() {
         mContext = InstrumentationRegistry.getInstrumentation().getTargetContext();
         mUwbManager = mContext.getSystemService(UwbManager.class);
         mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
-        adoptShellPermission();
     }
 
     private enum Event {
@@ -202,6 +202,14 @@ public class UwbManagerSnippet implements Snippet {
             mEventCache.postEvent(event);
         }
 
+        private void handleEvent(Event e, int reason) {
+            Log.d(TAG + "RangingSessionCallback#handleEvent() for " + e.toString());
+            SnippetEvent event = new SnippetEvent(mId, "RangingSessionCallback");
+            event.getData().putString("rangingSessionEvent", e.toString());
+            event.getData().putInt("reasonCode", reason);
+            mEventCache.postEvent(event);
+        }
+
         @Override
         public void onOpened(RangingSession session) {
             Log.d(TAG + "RangingSessionCallback#onOpened() called");
@@ -214,7 +222,7 @@ public class UwbManagerSnippet implements Snippet {
             Log.d(TAG + "RangingSessionCallback#onOpenedFailed() called");
             Log.d(TAG + "OpenFailed reason " + String.valueOf(reason));
             persistableBundle = params;
-            handleEvent(Event.OpenFailed);
+            handleEvent(Event.OpenFailed, reason);
         }
 
         @Override
@@ -229,7 +237,7 @@ public class UwbManagerSnippet implements Snippet {
             Log.d(TAG + "RangingSessionCallback#onStartFailed() called");
             Log.d(TAG + "StartFailed reason " + String.valueOf(reason));
             persistableBundle = params;
-            handleEvent(Event.StartFailed);
+            handleEvent(Event.StartFailed, reason);
         }
 
         @Override
@@ -244,7 +252,7 @@ public class UwbManagerSnippet implements Snippet {
             Log.d(TAG + "RangingSessionCallback#onReconfigureFailed() called");
             Log.d(TAG + "ReconfigureFailed reason " + String.valueOf(reason));
             persistableBundle = params;
-            handleEvent(Event.ReconfigureFailed);
+            handleEvent(Event.ReconfigureFailed, reason);
         }
 
         @Override
@@ -252,7 +260,7 @@ public class UwbManagerSnippet implements Snippet {
             Log.d(TAG + "RangingSessionCallback#onStopped() called");
             Log.d(TAG + "Stopped reason " + String.valueOf(reason));
             persistableBundle = params;
-            handleEvent(Event.Stopped);
+            handleEvent(Event.Stopped, reason);
         }
 
         @Override
@@ -260,7 +268,7 @@ public class UwbManagerSnippet implements Snippet {
             Log.d(TAG + "RangingSessionCallback#onStopFailed() called");
             Log.d(TAG + "StopFailed reason " + String.valueOf(reason));
             persistableBundle = params;
-            handleEvent(Event.StopFailed);
+            handleEvent(Event.StopFailed, reason);
         }
 
         @Override
@@ -268,7 +276,7 @@ public class UwbManagerSnippet implements Snippet {
             Log.d(TAG + "RangingSessionCallback#onClosed() called");
             Log.d(TAG + "Closed reason " + String.valueOf(reason));
             persistableBundle = params;
-            handleEvent(Event.Closed);
+            handleEvent(Event.Closed, reason);
         }
 
         @Override
@@ -292,7 +300,7 @@ public class UwbManagerSnippet implements Snippet {
             Log.d(TAG + "RangingSessionCallback#onControleeAddFailed() called");
             Log.d(TAG + "ControleeAddFailed reason " + String.valueOf(reason));
             persistableBundle = params;
-            handleEvent(Event.ControleeAddFailed);
+            handleEvent(Event.ControleeAddFailed, reason);
 
         }
 
@@ -309,7 +317,7 @@ public class UwbManagerSnippet implements Snippet {
             Log.d(TAG + "RangingSessionCallback#onControleeRemoveFailed() called");
             Log.d(TAG + "ControleeRemoveFailed reason " + String.valueOf(reason));
             persistableBundle = params;
-            handleEvent(Event.ControleeRemoveFailed);
+            handleEvent(Event.ControleeRemoveFailed, reason);
         }
 
         @Override
@@ -324,7 +332,7 @@ public class UwbManagerSnippet implements Snippet {
             Log.d(TAG + "RangingSessionCallback#onPauseFailed() called");
             Log.d(TAG + "PauseFailed reason " + String.valueOf(reason));
             persistableBundle = params;
-            handleEvent(Event.PauseFailed);
+            handleEvent(Event.PauseFailed, reason);
         }
 
         @Override
@@ -339,7 +347,7 @@ public class UwbManagerSnippet implements Snippet {
             Log.d(TAG + "RangingSessionCallback#onResumeFailed() called");
             Log.d(TAG + "ResumeFailed reason " + String.valueOf(reason));
             persistableBundle = params;
-            handleEvent(Event.ResumeFailed);
+            handleEvent(Event.ResumeFailed, reason);
         }
 
         @Override
@@ -358,7 +366,7 @@ public class UwbManagerSnippet implements Snippet {
             Log.d(TAG + "DataSendFailed reason " + String.valueOf(reason));
             uwbAddress = getComputedMacAddress(remoteDeviceAddress);
             persistableBundle = params;
-            handleEvent(Event.DataSendFailed);
+            handleEvent(Event.DataSendFailed, reason);
         }
 
         @Override
@@ -378,7 +386,7 @@ public class UwbManagerSnippet implements Snippet {
             Log.d(TAG + "DataReceiveFailed reason " + String.valueOf(reason));
             uwbAddress = getComputedMacAddress(remoteDeviceAddress);
             persistableBundle = params;
-            handleEvent(Event.DataReceiveFailed);
+            handleEvent(Event.DataReceiveFailed, reason);
         }
 
         @Override
@@ -405,54 +413,56 @@ public class UwbManagerSnippet implements Snippet {
 
     /** Register uwb adapter state callback. */
     @AsyncRpc(description = "Register uwb adapter state callback")
-    public void registerUwbAdapterStateCallback(String callbackId, String key) {
+    public void registerUwbAdapterStateCallback(String callbackId, String key) throws Throwable {
         UwbAdapterStateCallback uwbAdapterStateCallback = new UwbAdapterStateCallback(callbackId);
         sUwbAdapterStateCallbackMap.put(key, uwbAdapterStateCallback);
-        mUwbManager.registerAdapterStateCallback(mExecutor, uwbAdapterStateCallback);
+        runWithShellPermission(() ->
+                mUwbManager.registerAdapterStateCallback(mExecutor, uwbAdapterStateCallback));
     }
 
     /** Unregister uwb adapter state callback. */
     @Rpc(description = "Unregister uwb adapter state callback.")
-    public void unregisterUwbAdapterStateCallback(String key) {
+    public void unregisterUwbAdapterStateCallback(String key) throws Throwable {
         UwbAdapterStateCallback uwbAdapterStateCallback = sUwbAdapterStateCallbackMap.get(key);
-        mUwbManager.unregisterAdapterStateCallback(uwbAdapterStateCallback);
+        runWithShellPermission(() ->
+                mUwbManager.unregisterAdapterStateCallback(uwbAdapterStateCallback));
         sUwbAdapterStateCallbackMap.remove(key);
     }
 
     /** Get UWB adapter state. */
     @Rpc(description = "Get Uwb adapter state")
-    public int getAdapterState() {
-        return mUwbManager.getAdapterState();
+    public int getAdapterState() throws Throwable {
+        return runWithShellPermission(() -> mUwbManager.getAdapterState());
     }
 
     /** Get the UWB state. */
     @Rpc(description = "Get Uwb state")
-    public boolean isUwbEnabled() {
-        return mUwbManager.isUwbEnabled();
+    public boolean isUwbEnabled() throws Throwable {
+        return runWithShellPermission(() -> mUwbManager.isUwbEnabled());
     }
 
     /** Set the UWB state. */
     @Rpc(description = "Set Uwb state")
-    public void setUwbEnabled(boolean enabled) {
-        mUwbManager.setUwbEnabled(enabled);
+    public void setUwbEnabled(boolean enabled) throws Throwable {
+        runWithShellPermission(() -> mUwbManager.setUwbEnabled(enabled));
     }
 
     /** Get the UWB hardware state. */
     @Rpc(description = "Get Uwb hardware state")
-    public boolean isUwbHwEnableRequested() {
-        return mUwbManager.isUwbHwEnableRequested();
+    public boolean isUwbHwEnableRequested() throws Throwable {
+        return runWithShellPermission(() -> mUwbManager.isUwbHwEnableRequested());
     }
 
     /** Set the UWB hardware state. */
     @Rpc(description = "Set Uwb hardware state")
-    public void requestUwbHwEnabled(boolean enabled) {
-        mUwbManager.requestUwbHwEnabled(enabled);
+    public void requestUwbHwEnabled(boolean enabled) throws Throwable {
+        runWithShellPermission(() -> mUwbManager.requestUwbHwEnabled(enabled));
     }
 
     /** Get UWB HW idle feature state. */
     @Rpc(description = "Get Uwb hardware idle feature state")
-    public boolean isUwbHwIdleTurnOffEnabled() {
-        return mUwbManager.isUwbHwIdleTurnOffEnabled();
+    public boolean isUwbHwIdleTurnOffEnabled() throws Throwable {
+        return runWithShellPermission(() -> mUwbManager.isUwbHwIdleTurnOffEnabled());
     }
 
     private byte[] convertJSONArrayToByteArray(JSONArray jArray) throws JSONException {
@@ -662,6 +672,9 @@ public class UwbManagerSnippet implements Snippet {
         if (j.has("maxRangingRoundRetries")) {
             builder.setMaxRangingRoundRetries(j.getInt("maxRangingRoundRetries"));
         }
+        if (j.has("maxNumberOfMeasurements")) {
+            builder.setMaxNumberOfMeasurements(j.getInt("maxNumberOfMeasurements"));
+        }
         if (j.has("sessionPriority")) {
             builder.setSessionPriority(j.getInt("sessionPriority"));
         }
@@ -712,6 +725,21 @@ public class UwbManagerSnippet implements Snippet {
         if (j.has("hasRangingResultReportMessage")) {
             builder.setHasRangingResultReportMessage(j.getBoolean("hasRangingResultReportMessage"));
         }
+        if (j.has("rangingErrorStreakTimeoutMs")) {
+            builder.setRangingErrorStreakTimeoutMs(j.getLong("rangingErrorStreakTimeoutMs"));
+        }
+        if (j.has("isKeyRotationEnabled")) {
+            builder.setIsKeyRotationEnabled(j.getBoolean("isKeyRotationEnabled"));
+        }
+        if (j.has("keyRotationRate")) {
+            builder.setKeyRotationRate(j.getInt("keyRotationRate"));
+        }
+        if (j.has("hasRangingResultReportMessage")) {
+            builder.setHasRangingResultReportMessage(j.getBoolean("hasRangingResultReportMessage"));
+        }
+        if (j.has("prfMode")) {
+            builder.setPrfMode(j.getInt("prfMode"));
+        }
 
         return builder.build();
     }
@@ -737,62 +765,76 @@ public class UwbManagerSnippet implements Snippet {
     /** Open FIRA UWB ranging session. */
     @AsyncRpc(description = "Open FIRA UWB ranging session")
     public void openFiraRangingSession(String callbackId, String key, JSONObject config)
-            throws JSONException {
+            throws Throwable {
         RangingSessionCallback rangingSessionCallback = new RangingSessionCallback(
                 callbackId, Event.EventAll.getType());
         FiraOpenSessionParams params = generateFiraOpenSessionParams(config);
-        mUwbManager.openRangingSession(params.toBundle(), mExecutor, rangingSessionCallback);
+        runWithShellPermission(() ->
+                mUwbManager.openRangingSession(
+                        params.toBundle(), mExecutor, rangingSessionCallback));
         sRangingSessionCallbackMap.put(key, rangingSessionCallback);
     }
 
     /** Open CCC UWB ranging session. */
     @AsyncRpc(description = "Open CCC UWB ranging session")
     public void openCccRangingSession(String callbackId, String key, JSONObject config)
-            throws JSONException {
+            throws Throwable {
         RangingSessionCallback rangingSessionCallback = new RangingSessionCallback(
                 callbackId, Event.EventAll.getType());
         CccOpenRangingParams params = generateCccOpenRangingParams(config);
-        mUwbManager.openRangingSession(params.toBundle(), mExecutor, rangingSessionCallback);
+        runWithShellPermission(() ->
+                mUwbManager.openRangingSession(
+                        params.toBundle(), mExecutor, rangingSessionCallback));
         sRangingSessionCallbackMap.put(key, rangingSessionCallback);
     }
 
     /** Start FIRA UWB ranging. */
     @Rpc(description = "Start FIRA UWB ranging")
-    public void startFiraRangingSession(String key) {
+    public void startFiraRangingSession(String key) throws Throwable {
         RangingSessionCallback rangingSessionCallback = sRangingSessionCallbackMap.get(key);
+        // Hold on to the shell permission until the session is stopped to get the ranging reports.
+        adoptShellPermission();
         rangingSessionCallback.rangingSession.start(new PersistableBundle());
     }
 
     /** Start CCC UWB ranging. */
     @Rpc(description = "Start CCC UWB ranging")
-    public void startCccRangingSession(String key, JSONObject config) throws JSONException {
+    public void startCccRangingSession(String key, JSONObject config) throws Throwable {
         RangingSessionCallback rangingSessionCallback = sRangingSessionCallbackMap.get(key);
         CccRangingStartedParams params = generateCccRangingStartedParams(config);
+        // Hold on to the shell permission until the session is stopped to get the ranging reports.
+        adoptShellPermission();
         rangingSessionCallback.rangingSession.start(params.toBundle());
     }
 
     /** Reconfigures FIRA UWB ranging session. */
     @Rpc(description = "Reconfigure FIRA UWB ranging session")
-    public void reconfigureFiraRangingSession(String key, JSONObject config) throws JSONException {
+    public void reconfigureFiraRangingSession(String key, JSONObject config) throws Throwable {
         RangingSessionCallback rangingSessionCallback = sRangingSessionCallbackMap.get(key);
         FiraRangingReconfigureParams params = generateFiraRangingReconfigureParams(config);
+        // Hold on to the shell permission until the session is stopped to get the ranging reports.
+        adoptShellPermission();
         rangingSessionCallback.rangingSession.reconfigure(params.toBundle());
     }
 
     /** Reconfigures FIRA UWB ranging session to add controlee. */
     @Rpc(description = "Reconfigure FIRA UWB ranging session to add controlee")
-    public void addControleeFiraRangingSession(String key, JSONObject config) throws JSONException {
+    public void addControleeFiraRangingSession(String key, JSONObject config) throws Throwable {
         RangingSessionCallback rangingSessionCallback = sRangingSessionCallbackMap.get(key);
         FiraControleeParams params = generateFiraControleeParams(config);
+        // Hold on to the shell permission until the session is stopped to get the ranging reports.
+        adoptShellPermission();
         rangingSessionCallback.rangingSession.addControlee(params.toBundle());
     }
 
     /** Reconfigures FIRA UWB ranging session to remove controlee. */
     @Rpc(description = "Reconfigure FIRA UWB ranging session to remove controlee")
     public void removeControleeFiraRangingSession(String key, JSONObject config)
-            throws JSONException {
+            throws Throwable {
         RangingSessionCallback rangingSessionCallback = sRangingSessionCallbackMap.get(key);
         FiraControleeParams params = generateFiraControleeParams(config);
+        // Hold on to the shell permission until the session is stopped to get the ranging reports.
+        adoptShellPermission();
         rangingSessionCallback.rangingSession.removeControlee(params.toBundle());
     }
 
@@ -850,17 +892,19 @@ public class UwbManagerSnippet implements Snippet {
 
     /** Stop UWB ranging. */
     @Rpc(description = "Stop UWB ranging")
-    public void stopRangingSession(String key) {
+    public void stopRangingSession(String key) throws Throwable {
         RangingSessionCallback rangingSessionCallback = sRangingSessionCallbackMap.get(key);
-        rangingSessionCallback.rangingSession.stop();
+        runWithShellPermission(() ->
+                rangingSessionCallback.rangingSession.stop());
     }
 
     /** Close UWB ranging session. */
     @Rpc(description = "Close UWB ranging session")
-    public void closeRangingSession(String key) {
+    public void closeRangingSession(String key) throws Throwable {
         RangingSessionCallback rangingSessionCallback = sRangingSessionCallbackMap.remove(key);
         if (rangingSessionCallback != null && rangingSessionCallback.rangingSession != null) {
-            rangingSessionCallback.rangingSession.close();
+            runWithShellPermission(() ->
+                    rangingSessionCallback.rangingSession.close());
         }
     }
 
@@ -881,14 +925,15 @@ public class UwbManagerSnippet implements Snippet {
 
     /** Get UWB specification info */
     @Rpc(description = "Get Uwb specification info")
-    public JSONObject getSpecificationInfo() throws JSONException {
-        return convertPersistableBundleToJson(mUwbManager.getSpecificationInfo());
+    public JSONObject getSpecificationInfo() throws Throwable {
+        return runWithShellPermission(() ->
+                       convertPersistableBundleToJson(mUwbManager.getSpecificationInfo()));
     }
 
     /** Set airplane mode to True or False */
     @Rpc(description = "Set airplane mode")
-    public void setAirplaneMode(Boolean enabled) {
-        mConnectivityManager.setAirplaneMode(enabled);
+    public void setAirplaneMode(Boolean enabled) throws Throwable {
+        runWithShellPermission(() -> mConnectivityManager.setAirplaneMode(enabled));
     }
 
     @Rpc(description = "Log info level message to device logcat")
@@ -899,7 +944,7 @@ public class UwbManagerSnippet implements Snippet {
     @Override
     public void shutdown() {}
 
-    private void adoptShellPermission() throws Throwable {
+    private void adoptShellPermission() {
         UiAutomation uia = InstrumentationRegistry.getInstrumentation().getUiAutomation();
         uia.adoptShellPermissionIdentity();
         try {
@@ -907,7 +952,19 @@ public class UwbManagerSnippet implements Snippet {
             Method destroyMethod = cls.getDeclaredMethod("destroy");
             destroyMethod.invoke(uia);
         } catch (ReflectiveOperationException e) {
-            throw new UwbManagerSnippetException("Failed to cleaup Ui Automation", e);
+            throw new IllegalStateException("Failed to cleaup Ui Automation", e);
+        }
+    }
+
+    private void dropShellPermission() {
+        UiAutomation uia = InstrumentationRegistry.getInstrumentation().getUiAutomation();
+        uia.dropShellPermissionIdentity();
+        try {
+            Class<?> cls = Class.forName("android.app.UiAutomation");
+            Method destroyMethod = cls.getDeclaredMethod("destroy");
+            destroyMethod.invoke(uia);
+        } catch (ReflectiveOperationException e) {
+            throw new IllegalStateException("Failed to cleaup Ui Automation", e);
         }
     }
 
@@ -931,4 +988,34 @@ public class UwbManagerSnippet implements Snippet {
         }
         return data;
     }
+
+    public void runWithShellPermission(Runnable action) throws Throwable {
+        adoptShellPermission();
+        try {
+            action.run();
+        } finally {
+            dropShellPermission();
+        }
+    }
+
+    public <T> T runWithShellPermission(ThrowingSupplier<T> action) throws Throwable {
+        adoptShellPermission();
+        try {
+            return action.get();
+        } finally {
+            dropShellPermission();
+        }
+    }
+
+    /**
+     * Similar to {@link Supplier} but has {@code throws Exception}.
+     *
+     * @param <T> type of the value produced
+     */
+    public interface ThrowingSupplier<T> {
+        /**
+         * Similar to {@link Supplier#get} but has {@code throws Exception}.
+         */
+        T get() throws Exception;
+    }
 }
diff --git a/tests/cts/hostsidetests/multidevices/uwb/test_utils/uwb_test_utils.py b/tests/cts/hostsidetests/multidevices/uwb/test_utils/uwb_test_utils.py
index c3799cc1..0bd419a7 100644
--- a/tests/cts/hostsidetests/multidevices/uwb/test_utils/uwb_test_utils.py
+++ b/tests/cts/hostsidetests/multidevices/uwb/test_utils/uwb_test_utils.py
@@ -89,18 +89,20 @@ def set_uwb_state_and_verify(
 
 
 def verify_peer_found(ranging_dut: uwb_ranging_decorator.UwbRangingDecorator,
-                      peer_addr: List[int], session: int = 0):
+                      peer_addr: List[int], session: int = 0,
+                      timeout: int = WAIT_TIME_SEC):
   """Verifies if the UWB peer is found.
 
   Args:
     ranging_dut: uwb ranging device.
     peer_addr: uwb peer device address.
     session: session id.
+    timeout: timeout for peer to be found.
   """
   ranging_dut.ad.log.info("Look for peer: %s" % peer_addr)
   start_time = time.time()
   while not ranging_dut.is_uwb_peer_found(peer_addr, session):
-    if time.time() - start_time > WAIT_TIME_SEC:
+    if time.time() - start_time > timeout:
       asserts.fail("UWB peer with address %s not found" % peer_addr)
   logging.info("Peer %s found in %s seconds", peer_addr,
                round(time.time() - start_time, 2))
diff --git a/tests/cts/tests/src/android/uwb/cts/UwbManagerTest.java b/tests/cts/tests/src/android/uwb/cts/UwbManagerTest.java
index 7386a1d1..d222a3e1 100644
--- a/tests/cts/tests/src/android/uwb/cts/UwbManagerTest.java
+++ b/tests/cts/tests/src/android/uwb/cts/UwbManagerTest.java
@@ -264,6 +264,32 @@ public class UwbManagerTest {
         }
     }
 
+    @Test
+    @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
+    @RequiresFlagsEnabled("com.android.uwb.flags.query_timestamp_micros")
+    public void testQueryUwbsTimestampMicros() {
+        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
+        try {
+            uiAutomation.adoptShellPermissionIdentity();
+            assertThat(mUwbManager.elapsedRealtimeResolutionNanos() >= 0L).isTrue();
+        } finally {
+            uiAutomation.dropShellPermissionIdentity();
+        }
+    }
+
+    @Test
+    @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
+    @RequiresFlagsEnabled("com.android.uwb.flags.query_timestamp_micros")
+    public void testQueryUwbsTimestampMicrosPrivileged() {
+        try {
+            mUwbManager.elapsedRealtimeResolutionNanos();
+            // should fail if the call was successful without UWB_PRIVILEGED permission.
+            fail();
+        } catch (SecurityException e) {
+            // pass
+            Log.i(TAG, "Failed with expected security exception: " + e);
+        }
+    }
 
     @Test
     @CddTest(requirements = {"7.3.13/C-1-1,C-1-2"})
@@ -1008,8 +1034,8 @@ public class UwbManagerTest {
                 .setDeviceType(FiraParams.RANGING_DEVICE_TYPE_CONTROLLER)
                 .setDeviceRole(FiraParams.RANGING_DEVICE_ROLE_INITIATOR)
                 .setMultiNodeMode(FiraParams.MULTI_NODE_MODE_UNICAST)
-                .setDeviceAddress(UwbAddress.fromBytes(new byte[] {0x5, 0x6}))
-                .setDestAddressList(List.of(UwbAddress.fromBytes(new byte[] {0x5, 0x7})));
+                .setDeviceAddress(UwbAddress.fromBytes(new byte[]{0x5, 0x6}))
+                .setDestAddressList(List.of(UwbAddress.fromBytes(new byte[]{0x5, 0x7})));
     }
 
     private interface VerifyRangingReportInterface {
@@ -1471,9 +1497,9 @@ public class UwbManagerTest {
     @CddTest(requirements = {"7.3.13/C-1-1,C-1-2,C-1-5"})
     public void testFiraPoseChanges() throws Exception {
         FiraPoseUpdateParams poseVQUpdate = new FiraPoseUpdateParams.Builder()
-                .setPose(new float[] {0, 0, 0, 0, 0, 0, 1}) // identity vector & quaternion
+                .setPose(new float[]{0, 0, 0, 0, 0, 0, 1}) // identity vector & quaternion
                 .build();
-        float[] identityMatrix = new float[] {
+        float[] identityMatrix = new float[]{
                 1.0f, 0.0f, 0.0f, 0.0f,
                 0.0f, 1.0f, 0.0f, 0.0f,
                 0.0f, 0.0f, 1.0f, 0.0f,
@@ -1512,17 +1538,17 @@ public class UwbManagerTest {
                     // Wrong number of values.
                     assertThrows(IllegalArgumentException.class,
                             () -> new FiraPoseUpdateParams.Builder()
-                                    .setPose(new float[] {5, 1})
+                                    .setPose(new float[]{5, 1})
                                     .build());
 
                     // Nonreal numbers.
                     assertThrows(IllegalArgumentException.class,
                             () -> new FiraPoseUpdateParams.Builder()
-                                    .setPose(new float[] {1, 2, 3, 4, 5, Float.NaN, 7})
+                                    .setPose(new float[]{1, 2, 3, 4, 5, Float.NaN, 7})
                                     .build());
                     assertThrows(IllegalArgumentException.class,
                             () -> new FiraPoseUpdateParams.Builder()
-                                    .setPose(new float[] {
+                                    .setPose(new float[]{
                                             Float.NEGATIVE_INFINITY, 2, 3, 4, 5, 6, 7})
                                     .build());
                 });
@@ -1533,7 +1559,7 @@ public class UwbManagerTest {
     @CddTest(requirements = {"7.3.13/C-1-1,C-1-2,C-1-5"})
     public void testFiraRangingPoseFailures() throws Exception {
         FiraPoseUpdateParams poseUpdateParams = new FiraPoseUpdateParams.Builder()
-                .setPose(new float[] {1, 2, 3, 4, 5, 6, 7})
+                .setPose(new float[]{1, 2, 3, 4, 5, 6, 7})
                 .build();
         FiraOpenSessionParams firaOpenSessionParams = makeOpenSessionBuilder()
                 .setFilterType(FiraParams.FILTER_TYPE_NONE)
@@ -1582,8 +1608,8 @@ public class UwbManagerTest {
                     countDownLatch = new CountDownLatch(1);
                     rangingSessionCallback.replaceResultCountDownLatch(countDownLatch);
                     assertThat(countDownLatch.await(
-                        firaOpenSessionParams.getRangingIntervalMs() + 10,
-                        TimeUnit.MILLISECONDS)).isTrue();
+                            firaOpenSessionParams.getRangingIntervalMs() + 10,
+                            TimeUnit.MILLISECONDS)).isTrue();
 
                     // Remove controlee
                     countDownLatch = new CountDownLatch(2);
@@ -2251,7 +2277,7 @@ public class UwbManagerTest {
                         .setAttributionTag(attributionTag)
                         .build()
         );
-        return  contextWithAttrTag.getSystemService(UwbManager.class);
+        return contextWithAttrTag.getSystemService(UwbManager.class);
     }
 
     // Should be invoked with shell permissions.
```

