```diff
diff --git a/.idea/misc.xml b/.idea/misc.xml
index 338bd4dbe..31b97053d 100644
--- a/.idea/misc.xml
+++ b/.idea/misc.xml
@@ -1,5 +1,8 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
+  <component name="Black">
+    <option name="sdkName" value="Python 3.11" />
+  </component>
   <component name="ExternalStorageConfigurationManager" enabled="true" />
   <component name="NullableNotNullManager">
     <option name="myDefaultNullable" value="org.jetbrains.annotations.Nullable" />
diff --git a/USAGE.md b/USAGE.md
index bb4fbd7ba..857e6b227 100644
--- a/USAGE.md
+++ b/USAGE.md
@@ -22,7 +22,7 @@ platform and AndroidX libraries.
 - Rewriting of nullness annotations to @RecentlyNull/NonNull (`--migrate-nullness`,
 `--force-convert-to-warning-nullability-annotations`) for SDK
 - Tracking @removed APIs (`--removed-api`)
-- DEX API signature generation (`signature-to-dex`) for for hidden API enforcement
+- DEX API signature generation (`signature-to-dex`) for hidden API enforcement
 - XML API signature generation (`--api-xml`) for CTS tests and test coverage infrastructure
 - Annotation include, exclude, rewrite, passthrough in stubs (`--include-annotations`, `--exclude-all-annotations`,
 `--pass-through-annotation`, `--exclude-annotation`)
diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index f8e1e0cbc..646fd2de9 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -1,6 +1,6 @@
 [versions]
 kotlin = "2.0.20"
-androidLint = "31.7.0-alpha09"
+androidLint = "31.8.0-alpha08"
 
 [libraries]
 androidGradlePlugin = { module = "com.android.tools.build:gradle", version = "8.7.0-alpha09" }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/CodePrinter.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/CodePrinter.kt
index 6d470b845..8c8affa3f 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/CodePrinter.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/CodePrinter.kt
@@ -19,6 +19,7 @@ package com.android.tools.metalava.model.psi
 import com.android.SdkConstants.DOT_CLASS
 import com.android.tools.lint.detector.api.ConstantEvaluator
 import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.FilterPredicate
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.canonicalizeFloatingPointString
 import com.android.tools.metalava.model.javaEscapeString
@@ -35,7 +36,6 @@ import com.intellij.psi.PsiLiteral
 import com.intellij.psi.PsiReference
 import com.intellij.psi.PsiTypeCastExpression
 import com.intellij.psi.PsiVariable
-import java.util.function.Predicate
 import org.jetbrains.kotlin.name.ClassId
 import org.jetbrains.kotlin.name.Name
 import org.jetbrains.uast.UAnnotation
@@ -70,7 +70,7 @@ class CodePrinter(
      */
     private val skipUnknown: Boolean = false,
     /** An optional filter to use to determine if we should emit a reference to an item */
-    private val filterReference: Predicate<Item>? = null
+    private val filterReference: FilterPredicate? = null
 ) {
     private fun warning(message: String, psiElement: PsiElement? = null) {
         reporter.report(Issues.INTERNAL_ERROR, psiElement, message)
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/Javadoc.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/Javadoc.kt
index 390f5c7b9..47b6730a0 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/Javadoc.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/Javadoc.kt
@@ -39,9 +39,6 @@ import com.intellij.psi.javadoc.PsiDocToken
  */
 internal const val INCLUDE_SAME_PACKAGE = true
 
-/** If documentation starts with hash, insert the implicit class? */
-internal const val PREPEND_LOCAL_CLASS = false
-
 /**
  * Whether we should report unresolved symbols. This is typically a bug in the documentation. It
  * looks like there are a LOT of mistakes right now, so I'm worried about turning this on since
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiAnnotationItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiAnnotationItem.kt
index d09ae4bdc..c929a59d7 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiAnnotationItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiAnnotationItem.kt
@@ -76,10 +76,6 @@ private constructor(
         return super.isNonNull()
     }
 
-    override val targets: Set<AnnotationTarget> by lazy {
-        codebase.annotationManager.computeTargets(this, codebase::resolveClass)
-    }
-
     companion object {
         private fun getAnnotationAttributes(
             codebase: PsiBasedCodebase,
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedClassResolver.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedClassResolver.kt
index a71e794a9..d62964487 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedClassResolver.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedClassResolver.kt
@@ -17,19 +17,17 @@
 package com.android.tools.metalava.model.psi
 
 import com.android.tools.lint.UastEnvironment
-import com.android.tools.metalava.model.AnnotationManager
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassResolver
+import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.source.SourceSet
-import com.android.tools.metalava.reporter.Reporter
 import com.intellij.psi.JavaPsiFacade
 import com.intellij.psi.search.GlobalSearchScope
 import java.io.File
 
 internal class PsiBasedClassResolver(
     uastEnvironment: UastEnvironment,
-    annotationManager: AnnotationManager,
-    reporter: Reporter,
+    config: Codebase.Config,
     allowReadingComments: Boolean,
 ) : ClassResolver {
     private val javaPsiFacade: JavaPsiFacade
@@ -47,14 +45,13 @@ internal class PsiBasedClassResolver(
                 PsiBasedCodebase(
                     location = File("classpath"),
                     description = "Codebase from classpath",
-                    annotationManager = annotationManager,
-                    reporter = reporter,
+                    config = config,
                     fromClasspath = true,
                     allowReadingComments = allowReadingComments,
                     assembler = assembler,
                 )
             }
-        assembler.initializeFromSources(SourceSet.empty())
+        assembler.initializeFromSources(SourceSet.empty(), apiPackages = null)
         classpathCodebase = assembler.codebase
     }
 
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedCodebase.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedCodebase.kt
index 58d5b46d9..ff7b501e0 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedCodebase.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiBasedCodebase.kt
@@ -16,15 +16,13 @@
 
 package com.android.tools.metalava.model.psi
 
-import com.android.tools.metalava.model.AnnotationManager
 import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassOrigin
+import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.Item
-import com.android.tools.metalava.model.MutableCodebase
 import com.android.tools.metalava.model.item.DefaultCodebase
-import com.android.tools.metalava.reporter.Reporter
 import com.intellij.openapi.project.Project
 import com.intellij.psi.PsiClass
 import com.intellij.psi.PsiField
@@ -49,8 +47,7 @@ const val METHOD_ESTIMATE = 1000
 internal class PsiBasedCodebase(
     location: File,
     description: String = "Unknown",
-    annotationManager: AnnotationManager,
-    override val reporter: Reporter,
+    config: Codebase.Config,
     val allowReadingComments: Boolean,
     val fromClasspath: Boolean = false,
     assembler: PsiCodebaseAssembler,
@@ -59,12 +56,11 @@ internal class PsiBasedCodebase(
         location = location,
         description = description,
         preFiltered = false,
-        annotationManager = annotationManager,
+        config = config,
         trustedApi = false,
         supportsDocumentation = true,
         assembler = assembler,
-    ),
-    MutableCodebase {
+    ) {
 
     internal val psiAssembler = assembler
 
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiClassItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiClassItem.kt
index edf87edd8..34fc38a62 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiClassItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiClassItem.kt
@@ -79,9 +79,10 @@ internal constructor(
     override fun createClassTypeItemForThis() =
         codebase.globalTypeItemFactory.getClassTypeForClass(this)
 
-    override fun getSourceFile(): SourceFile? {
+    override fun sourceFile(): SourceFile? {
         if (isNestedClass()) {
-            return null
+            // Retrieve the SourceFile from the top level class.
+            return containingClass()?.sourceFile()
         }
 
         val containingFile = psiClass.containingFile ?: return null
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiCodebaseAssembler.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiCodebaseAssembler.kt
index 199b724a5..765a3320b 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiCodebaseAssembler.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiCodebaseAssembler.kt
@@ -31,6 +31,7 @@ import com.android.tools.metalava.model.ConstructorItem
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.JAVA_PACKAGE_INFO
 import com.android.tools.metalava.model.MutableModifierList
+import com.android.tools.metalava.model.PackageFilter
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.TypeParameterScope
 import com.android.tools.metalava.model.VisibilityLevel
@@ -42,9 +43,11 @@ import com.android.tools.metalava.model.item.DefaultPackageItem
 import com.android.tools.metalava.model.item.MutablePackageDoc
 import com.android.tools.metalava.model.item.PackageDoc
 import com.android.tools.metalava.model.item.PackageDocs
+import com.android.tools.metalava.model.psi.PsiConstructorItem.Companion.isPrimaryConstructor
 import com.android.tools.metalava.model.source.SourceSet
 import com.android.tools.metalava.model.source.utils.gatherPackageJavadoc
 import com.android.tools.metalava.reporter.Issues
+import com.android.utils.associateByNotNull
 import com.intellij.openapi.application.ApplicationManager
 import com.intellij.openapi.project.Project
 import com.intellij.psi.JavaPsiFacade
@@ -62,6 +65,7 @@ import com.intellij.psi.PsiFile
 import com.intellij.psi.PsiImportStatement
 import com.intellij.psi.PsiJavaFile
 import com.intellij.psi.PsiManager
+import com.intellij.psi.PsiMethod
 import com.intellij.psi.PsiPackage
 import com.intellij.psi.PsiParameter
 import com.intellij.psi.PsiSubstitutor
@@ -79,18 +83,22 @@ import org.jetbrains.kotlin.analysis.api.types.KaTypeNullability
 import org.jetbrains.kotlin.asJava.classes.KtLightClassForFacade
 import org.jetbrains.kotlin.name.FqName
 import org.jetbrains.kotlin.name.JvmStandardClassIds
+import org.jetbrains.kotlin.psi.KtClassOrObject
+import org.jetbrains.kotlin.psi.KtDeclaration
 import org.jetbrains.kotlin.psi.KtFunction
 import org.jetbrains.kotlin.psi.KtParameter
 import org.jetbrains.kotlin.psi.KtProperty
 import org.jetbrains.kotlin.psi.KtPropertyAccessor
 import org.jetbrains.kotlin.psi.KtTypeReference
 import org.jetbrains.kotlin.psi.psiUtil.isPropertyParameter
+import org.jetbrains.kotlin.util.collectionUtils.filterIsInstanceAnd
 import org.jetbrains.uast.UClass
 import org.jetbrains.uast.UFile
 import org.jetbrains.uast.UMethod
 import org.jetbrains.uast.UParameter
 import org.jetbrains.uast.UastFacade
 import org.jetbrains.uast.kotlin.BaseKotlinUastResolveProviderService
+import org.jetbrains.uast.toUElement
 
 internal class PsiCodebaseAssembler(
     private val uastEnvironment: UastEnvironment,
@@ -288,6 +296,18 @@ internal class PsiCodebaseAssembler(
         // create methods
         for (psiMethod in psiMethods) {
             if (psiMethod.isConstructor) {
+                // Kotlin value class primary constructors must have exactly one parameter. If the
+                // parameter is optional, K1 generates an additional no-args constructor for Java.
+                // However, this constructor can't actually be called from Java, and the constructor
+                // with an optional arg is sufficient for Kotlin API tracking, so filter the no-args
+                // constructor out (this is consistent with K2).
+                if (
+                    classItem.modifiers.isValue() &&
+                        (psiMethod as UMethod).isPrimaryConstructor &&
+                        psiMethod.parameters.isEmpty()
+                )
+                    continue
+
                 val constructor =
                     PsiConstructorItem.create(
                         codebase,
@@ -302,6 +322,15 @@ internal class PsiCodebaseAssembler(
                 )
                 classItem.addConstructor(constructor)
             } else {
+                // With K1, value class property accessors are present as [PsiMethod]s and with K2
+                // they are not. These accessor methods can't actually be used from Java, so this
+                // forces the K2 behavior and filters them out for K1.
+                if (
+                    classItem.modifiers.isValue() && psiMethod.sourceElement is KtPropertyAccessor
+                ) {
+                    continue
+                }
+
                 val method =
                     PsiMethodItem.create(codebase, classItem, psiMethod, classTypeItemFactory)
                 if (!method.isEnumSyntheticMethod()) {
@@ -309,11 +338,34 @@ internal class PsiCodebaseAssembler(
                 }
             }
         }
+
+        // With K2, value class constructors are not present on the PsiClass (b/369846185#comment6)
+        // because they can't be used from Java code. They can still be found on the KtClass, and we
+        // track them for Kotlin source compatibility.
+        // Value classes must have a primary constructor, so if none of the constructors are primary
+        // this must be K2, and the primary constructor needs to be added.
+        val ktClass = (psiClass as? UClass)?.sourcePsi as? KtClassOrObject
+        if (classItem.modifiers.isValue() && classItem.constructors().none { it.isPrimary }) {
+            val ktConstructor = ktClass?.primaryConstructor?.toUElement() as? PsiMethod
+            if (ktConstructor != null) {
+                val primaryConstructor =
+                    PsiConstructorItem.create(
+                        codebase,
+                        classItem,
+                        ktConstructor,
+                        classTypeItemFactory
+                    )
+                classItem.addConstructor(primaryConstructor)
+            }
+        }
+
         // Note that this is dependent on the constructor filtering above. UAST sometimes
         // reports duplicate primary constructors, e.g.: the implicit no-arg constructor
+        // If the primary constructor has optional arguments, `isPrimary` will be true for all
+        // overloads, so there won't be one constructor selected as the class primary constructor.
         val constructors = classItem.constructors()
         constructors.singleOrNull { it.isPrimary }?.let { classItem.primaryConstructor = it }
-        val hasImplicitDefaultConstructor = hasImplicitDefaultConstructor(psiClass)
+        val hasImplicitDefaultConstructor = hasImplicitDefaultConstructor(classItem)
         if (hasImplicitDefaultConstructor) {
             assert(constructors.isEmpty())
             classItem.addConstructor(classItem.createDefaultConstructor())
@@ -326,11 +378,27 @@ internal class PsiCodebaseAssembler(
                 classItem.addField(fieldItem)
             }
         }
-        val methods = classItem.methods()
-        if (isKotlin && methods.isNotEmpty()) {
-            val getters = mutableMapOf<String, PsiMethodItem>()
-            val setters = mutableMapOf<String, PsiMethodItem>()
-            val backingFields = classItem.fields().associateBy({ it.name() }) { it as PsiFieldItem }
+
+        // Find all properties defined on the class
+        if (classItem.isKotlin()) {
+            // Collect all accessor methods, backing fields, and constructor parameters that could
+            // be associated with the class properties.
+            val accessors =
+                classItem.methods().filterIsInstanceAnd<PsiMethodItem> { it.isKotlinProperty() }
+            // Don't include data class component methods
+            val getters =
+                accessors
+                    .filter { it.parameters().isEmpty() && !it.name().startsWith("component") }
+                    .associateByNotNull { it.psiMethod.propertyForAccessor() }
+            val setters =
+                accessors
+                    .filter { it.parameters().size == 1 }
+                    .associateByNotNull { it.psiMethod.propertyForAccessor() }
+            val backingFields =
+                classItem
+                    .fields()
+                    .map { it as PsiFieldItem }
+                    .associateByNotNull { it.psi().sourceElement as? KtDeclaration }
             val constructorParameters =
                 classItem.primaryConstructor
                     ?.parameters()
@@ -339,42 +407,36 @@ internal class PsiCodebaseAssembler(
                     ?.associateBy { it.name() }
                     .orEmpty()
 
-            for (method in methods) {
-                if (method.isKotlinProperty()) {
-                    method as PsiMethodItem
-                    val name =
-                        when (val sourcePsi = method.sourcePsi) {
-                            is KtProperty -> sourcePsi.name
-                            is KtPropertyAccessor -> sourcePsi.property.name
-                            is KtParameter -> sourcePsi.name
-                            else -> null
-                        }
-                            ?: continue
-
-                    if (method.parameters().isEmpty()) {
-                        if (!method.name().startsWith("component")) {
-                            getters[name] = method
-                        }
-                    } else {
-                        setters[name] = method
-                    }
+            // Properties can either be declared directly as properties or as constructor params.
+            // For a file facade class containing top-level property definitions, the KtClass won't
+            // exist, so fall back to the properties underlying the getters and fields.
+            val allProperties =
+                if (ktClass != null) {
+                    ktClass.declarations.filterIsInstance<KtProperty>() +
+                        ktClass.primaryConstructor
+                            ?.valueParameters
+                            ?.filter { it.isPropertyParameter() }
+                            .orEmpty()
+                } else {
+                    (getters.keys + backingFields.keys).toSet()
                 }
-            }
 
-            for ((name, getter) in getters) {
-                val type = getter.returnType() as? PsiTypeItem ?: continue
-                val propertyItem =
+            for (propertyDeclaration in allProperties) {
+                val name = propertyDeclaration.name ?: continue
+                val property =
                     PsiPropertyItem.create(
                         codebase = codebase,
+                        ktDeclaration = propertyDeclaration,
                         containingClass = classItem,
+                        typeItemFactory = enclosingClassTypeItemFactory,
                         name = name,
-                        type = type,
-                        getter = getter,
-                        setter = setters[name],
+                        getter = getters[propertyDeclaration],
+                        setter = setters[propertyDeclaration],
                         constructorParameter = constructorParameters[name],
-                        backingField = backingFields[name]
+                        backingField = backingFields[propertyDeclaration],
                     )
-                classItem.addProperty(propertyItem)
+                        ?: continue
+                classItem.addProperty(property)
             }
         }
         // This actually gets all nested classes not just inner, i.e. non-static nested,
@@ -391,6 +453,16 @@ internal class PsiCodebaseAssembler(
         return classItem
     }
 
+    /** Returns the property or parameter declaration associated with the method, if one exists. */
+    private fun PsiMethod.propertyForAccessor(): KtDeclaration? {
+        return when (val sourceElement = sourceElement) {
+            is KtProperty -> sourceElement
+            is KtPropertyAccessor -> sourceElement.property
+            is KtParameter -> sourceElement
+            else -> null
+        }
+    }
+
     private fun hasExplicitRetention(
         modifiers: BaseModifierList,
         psiClass: PsiClass,
@@ -490,23 +562,21 @@ internal class PsiCodebaseAssembler(
         }
     }
 
-    private fun hasImplicitDefaultConstructor(psiClass: PsiClass): Boolean {
-        if (psiClass.name?.startsWith("-") == true) {
+    private fun hasImplicitDefaultConstructor(classItem: PsiClassItem): Boolean {
+        if (classItem.simpleName().startsWith("-")) {
             // Deliberately hidden; see examples like
             //     @file:JvmName("-ViewModelExtensions") // Hide from Java sources in the IDE.
             return false
         }
 
+        val psiClass = classItem.psiClass
         if (psiClass is UClass && psiClass.sourcePsi == null) {
             // Top level kt classes (FooKt for Foo.kt) do not have implicit default constructor
             return false
         }
 
-        val constructors = psiClass.constructors
-        return constructors.isEmpty() &&
-            !psiClass.isInterface &&
-            !psiClass.isAnnotationType &&
-            !psiClass.isEnum
+        val constructors = classItem.constructors()
+        return constructors.isEmpty() && classItem.isClass()
     }
 
     /**
@@ -827,7 +897,10 @@ internal class PsiCodebaseAssembler(
         }
     }
 
-    internal fun initializeFromSources(sourceSet: SourceSet) {
+    internal fun initializeFromSources(
+        sourceSet: SourceSet,
+        apiPackages: PackageFilter?,
+    ) {
         // Get the list of `PsiFile`s from the `SourceSet`.
         val psiFiles = Extractor.createUnitsForFiles(uastEnvironment.ideaProject, sourceSet.sources)
 
@@ -849,6 +922,12 @@ internal class PsiCodebaseAssembler(
 
         // Process the `PsiClass`es.
         for (psiClass in psiClasses) {
+            // If a package filter is supplied then ignore any classes that do not match it.
+            if (apiPackages != null) {
+                val packageName = getPackageName(psiClass)
+                if (!apiPackages.matches(packageName)) continue
+            }
+
             val classItem =
                 createPossibleApiClass(
                     psiClass,
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiConstructorItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiConstructorItem.kt
index 0d2e3df4c..1ffe9dd5b 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiConstructorItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiConstructorItem.kt
@@ -53,7 +53,7 @@ private constructor(
     typeParameterList: TypeParameterList,
     throwsTypes: List<ExceptionTypeItem>,
     implicitConstructor: Boolean = false,
-    override val isPrimary: Boolean = false
+    isPrimary: Boolean = false
 ) :
     DefaultConstructorItem(
         codebase = codebase,
@@ -70,6 +70,7 @@ private constructor(
         throwsTypes = throwsTypes,
         callableBodyFactory = { PsiCallableBody(it as PsiCallableItem) },
         implicitConstructor = implicitConstructor,
+        isPrimary = isPrimary,
     ),
     PsiCallableItem {
 
@@ -165,7 +166,12 @@ private constructor(
             return item
         }
 
-        private val UMethod.isPrimaryConstructor: Boolean
+        /**
+         * Whether the [UMethod] is the primary constructor of a Kotlin class. A primary constructor
+         * is declared in the class header, and all other constructors must delegate to it (see
+         * https://kotlinlang.org/docs/classes.html#constructors).
+         */
+        internal val UMethod.isPrimaryConstructor: Boolean
             get() = sourcePsi is KtPrimaryConstructor || sourcePsi is KtClassOrObject
     }
 }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiDefaultValue.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiDefaultValue.kt
index befae9ad6..d3ef319ac 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiDefaultValue.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiDefaultValue.kt
@@ -92,7 +92,9 @@ internal class PsiDefaultValue(private val item: PsiParameterItem) : DefaultValu
                             as? UExpression
                             ?: return INVALID_VALUE
                     val constant = defaultExpression.evaluate()
-                    return if (constant != null && constant !is Pair<*, *>) {
+                    return if (
+                        constant != null && (constant is String || constant.javaClass.isPrimitive)
+                    ) {
                         CodePrinter.constantToSource(constant)
                     } else {
                         // Expression: Compute from UAST rather than just using the source text
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiEnvironmentManager.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiEnvironmentManager.kt
index d21f12d45..b6f8645c9 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiEnvironmentManager.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiEnvironmentManager.kt
@@ -17,12 +17,10 @@
 package com.android.tools.metalava.model.psi
 
 import com.android.tools.lint.UastEnvironment
-import com.android.tools.metalava.model.AnnotationManager
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.ModelOptions
 import com.android.tools.metalava.model.source.EnvironmentManager
 import com.android.tools.metalava.model.source.SourceParser
-import com.android.tools.metalava.reporter.Reporter
 import com.intellij.core.CoreApplicationEnvironment
 import com.intellij.openapi.diagnostic.DefaultLogger
 import com.intellij.openapi.util.Disposer
@@ -128,8 +126,7 @@ class PsiEnvironmentManager(
     }
 
     override fun createSourceParser(
-        reporter: Reporter,
-        annotationManager: AnnotationManager,
+        codebaseConfig: Codebase.Config,
         javaLanguageLevel: String,
         kotlinLanguageLevel: String,
         modelOptions: ModelOptions,
@@ -139,8 +136,7 @@ class PsiEnvironmentManager(
     ): SourceParser {
         return PsiSourceParser(
             psiEnvironmentManager = this,
-            reporter = reporter,
-            annotationManager = annotationManager,
+            codebaseConfig = codebaseConfig,
             javaLanguageLevel = javaLanguageLevelFromString(javaLanguageLevel),
             kotlinLanguageLevel = kotlinLanguageVersionSettings(kotlinLanguageLevel),
             useK2Uast = modelOptions[PsiModelOptions.useK2Uast],
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiFileLocation.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiFileLocation.kt
index ba3b0b70d..4cac4d987 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiFileLocation.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiFileLocation.kt
@@ -34,13 +34,16 @@ import com.intellij.psi.PsiPackage
 import com.intellij.psi.PsiParameter
 import com.intellij.psi.impl.light.LightElement
 import java.nio.file.Path
+import org.jetbrains.kotlin.fileClasses.javaFileFacadeFqName
 import org.jetbrains.kotlin.psi.KtClass
+import org.jetbrains.kotlin.psi.KtFunction
 import org.jetbrains.kotlin.psi.KtModifierListOwner
 import org.jetbrains.kotlin.psi.KtProperty
 import org.jetbrains.kotlin.psi.psiUtil.containingClass
 import org.jetbrains.kotlin.psi.psiUtil.parameterIndex
 import org.jetbrains.uast.UClass
 import org.jetbrains.uast.UElement
+import org.jetbrains.uast.toUElement
 
 /** A [FileLocation] that wraps [psiElement] and computes the [path] and [line] number on demand. */
 class PsiFileLocation(private val psiElement: PsiElement) : FileLocation() {
@@ -208,13 +211,13 @@ class PsiFileLocation(private val psiElement: PsiElement) : FileLocation() {
                     }
                 }
                 is KtProperty -> {
-                    val containingClass = element.containingClass()
+                    val containingClass =
+                        element.containingClass()?.let { getElementId(it) }
+                        // If there is no containing class, find the file facade class because that
+                        // will be the containing class in the Codebase.
+                        ?: element.containingKtFile.javaFileFacadeFqName.asString()
                     val name = element.nameAsSafeName.asString()
-                    if (containingClass != null) {
-                        getElementId(containingClass) + "#" + name
-                    } else {
-                        name
-                    }
+                    "$containingClass#$name"
                 }
                 is PsiPackage -> element.qualifiedName
                 is PsiParameter -> {
@@ -225,6 +228,11 @@ class PsiFileLocation(private val psiElement: PsiElement) : FileLocation() {
                         "?"
                     }
                 }
+                is KtFunction -> {
+                    // Try converting this to the Java API view (as a PsiMethod)
+                    (element.toUElement()?.javaPsi as? PsiMethod)?.let { getElementId(it) }
+                        ?: element.toString()
+                }
                 else -> element.toString()
             }
         }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiItemDocumentation.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiItemDocumentation.kt
index b0f6d0bfe..f7012b85f 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiItemDocumentation.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiItemDocumentation.kt
@@ -68,7 +68,11 @@ internal class PsiItemDocumentation(
         return _text
     }
 
-    override fun duplicate(item: Item) = PsiItemDocumentation(item as PsiItem, psi, extraDocs)
+    override fun duplicate(item: Item) =
+        if (item is PsiItem) PsiItemDocumentation(item, psi, extraDocs)
+        else text.toItemDocumentationFactory()(item)
+
+    override fun snapshot(item: Item) = this
 
     override fun findTagDocumentation(tag: String, value: String?): String? {
         if (psi is PsiCompiledElement) {
@@ -127,19 +131,7 @@ internal class PsiItemDocumentation(
         }
 
         val assembler = item.codebase.psiAssembler
-        val comment =
-            try {
-                assembler.getComment(documentation, psi)
-            } catch (throwable: Throwable) {
-                // TODO: Get rid of line comments as documentation
-                // Invalid comment
-                if (documentation.startsWith("//") && documentation.contains("/**")) {
-                    return fullyQualifiedDocumentation(
-                        documentation.substring(documentation.indexOf("/**"))
-                    )
-                }
-                assembler.getComment(documentation, psi)
-            }
+        val comment = assembler.getComment(documentation, psi)
         return buildString(documentation.length) { expand(comment, this) }
     }
 
@@ -171,48 +163,16 @@ internal class PsiItemDocumentation(
             element is PsiDocToken -> {
                 assert(element.firstChild == null)
                 val text = element.text
-                // Auto-fix some docs in the framework which starts with R.styleable in @attr
-                if (text.startsWith("R.styleable#") && item.documentation.contains("@attr")) {
-                    sb.append("android.")
-                }
-
                 sb.append(text)
             }
             element is PsiDocMethodOrFieldRef -> {
                 val text = element.text
-                var resolved = element.reference?.resolve()
-
-                // Workaround: relative references doesn't work from a class item to its members
-                if (resolved == null && item is ClassItem) {
-                    // For some reason, resolving relative methods and field references at the root
-                    // level isn't working right.
-                    if (PREPEND_LOCAL_CLASS && text.startsWith("#")) {
-                        var end = text.indexOf('(')
-                        if (end == -1) {
-                            // definitely a field
-                            end = text.length
-                            val fieldName = text.substring(1, end)
-                            val field = item.findField(fieldName)
-                            if (field != null) {
-                                resolved = (field as? PsiFieldItem)?.psi()
-                            }
-                        }
-                        if (resolved == null) {
-                            val methodName = text.substring(1, end)
-                            resolved =
-                                (item as PsiClassItem)
-                                    .psi()
-                                    .findMethodsByName(methodName, true)
-                                    .firstOrNull()
-                        }
-                    }
-                }
-
+                val resolved = element.reference?.resolve()
                 if (resolved is PsiMember) {
                     val containingClass = resolved.containingClass
                     if (containingClass != null && !samePackage(containingClass)) {
                         val referenceText = element.reference?.element?.text ?: text
-                        if (!PREPEND_LOCAL_CLASS && referenceText.startsWith("#")) {
+                        if (referenceText.startsWith("#")) {
                             sb.append(text)
                             return
                         }
@@ -315,8 +275,8 @@ internal class PsiItemDocumentation(
         val reference = extractReference(element)
         val referenceText = reference?.element?.text ?: element.text
         val customLinkText = extractCustomLinkText(element)
-        val displayText = customLinkText?.text ?: referenceText
-        if (!PREPEND_LOCAL_CLASS && referenceText.startsWith("#")) {
+        val displayText = customLinkText?.text ?: referenceText.replaceFirst('#', '.')
+        if (referenceText.startsWith("#")) {
             val suffix = element.text
             if (suffix.contains("(") && suffix.contains(")")) {
                 expandArgumentList(element, suffix, sb)
@@ -369,32 +329,7 @@ internal class PsiItemDocumentation(
             }
         }
 
-        var resolved = reference?.resolve()
-        if (resolved == null && item is ClassItem) {
-            // For some reason, resolving relative methods and field references at the root
-            // level isn't working right.
-            if (PREPEND_LOCAL_CLASS && referenceText.startsWith("#")) {
-                var end = referenceText.indexOf('(')
-                if (end == -1) {
-                    // definitely a field
-                    end = referenceText.length
-                    val fieldName = referenceText.substring(1, end)
-                    val field = item.findField(fieldName)
-                    if (field != null) {
-                        resolved = (field as? PsiFieldItem)?.psi()
-                    }
-                }
-                if (resolved == null) {
-                    val methodName = referenceText.substring(1, end)
-                    resolved =
-                        (item as PsiClassItem)
-                            .psi()
-                            .findMethodsByName(methodName, true)
-                            .firstOrNull()
-                }
-            }
-        }
-
+        val resolved = reference?.resolve()
         if (resolved != null) {
             when (resolved) {
                 is PsiClass -> {
@@ -686,9 +621,11 @@ internal class PsiItemDocumentation(
             if (element is UElement) {
                 val comments = element.comments
                 if (comments.isNotEmpty()) {
-                    val sb = StringBuilder()
-                    comments.joinTo(buffer = sb, separator = "\n") { it.text }
-                    return sb.toString()
+                    return comments.firstNotNullOfOrNull {
+                        val text = it.text
+                        if (text.startsWith("/**")) text else null
+                    }
+                        ?: ""
                 } else {
                     // Temporary workaround: UAST seems to not return document nodes
                     // https://youtrack.jetbrains.com/issue/KT-22135
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiModifierItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiModifierItem.kt
index 8520b4e31..948b461d5 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiModifierItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiModifierItem.kt
@@ -57,6 +57,7 @@ import com.android.tools.metalava.model.isNullnessAnnotation
 import com.intellij.psi.PsiAnnotation
 import com.intellij.psi.PsiAnnotationMemberValue
 import com.intellij.psi.PsiArrayInitializerMemberValue
+import com.intellij.psi.PsiElement
 import com.intellij.psi.PsiField
 import com.intellij.psi.PsiMethod
 import com.intellij.psi.PsiModifier
@@ -71,6 +72,8 @@ import org.jetbrains.annotations.Nullable
 import org.jetbrains.kotlin.analysis.api.analyze
 import org.jetbrains.kotlin.analysis.api.symbols.KaSymbolVisibility
 import org.jetbrains.kotlin.asJava.elements.KtLightElement
+import org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget
+import org.jetbrains.kotlin.lexer.KtModifierKeywordToken
 import org.jetbrains.kotlin.lexer.KtTokens
 import org.jetbrains.kotlin.psi.KtAnnotated
 import org.jetbrains.kotlin.psi.KtDeclaration
@@ -79,11 +82,7 @@ import org.jetbrains.kotlin.psi.KtModifierList
 import org.jetbrains.kotlin.psi.KtModifierListOwner
 import org.jetbrains.kotlin.psi.KtNamedFunction
 import org.jetbrains.kotlin.psi.KtPropertyAccessor
-import org.jetbrains.kotlin.psi.psiUtil.hasActualModifier
-import org.jetbrains.kotlin.psi.psiUtil.hasExpectModifier
-import org.jetbrains.kotlin.psi.psiUtil.hasFunModifier
-import org.jetbrains.kotlin.psi.psiUtil.hasSuspendModifier
-import org.jetbrains.kotlin.psi.psiUtil.hasValueModifier
+import org.jetbrains.kotlin.psi.psiUtil.containingClass
 import org.jetbrains.kotlin.psi.psiUtil.visibilityModifier
 import org.jetbrains.uast.UAnnotated
 import org.jetbrains.uast.UAnnotation
@@ -91,6 +90,7 @@ import org.jetbrains.uast.UElement
 import org.jetbrains.uast.UMethod
 import org.jetbrains.uast.UVariable
 import org.jetbrains.uast.kotlin.KotlinUMethodWithFakeLightDelegateBase
+import org.jetbrains.uast.toUElement
 
 internal object PsiModifierItem {
     fun create(
@@ -121,6 +121,57 @@ internal object PsiModifierItem {
         return modifiers
     }
 
+    /**
+     * Creates modifiers for the property represented by [ktDeclaration]. If the [getter] exists, it
+     * is used to create the modifiers (along with annotations appearing directly on the property).
+     * If there is no getter, the kt modifiers are used.
+     */
+    fun createForProperty(
+        codebase: PsiBasedCodebase,
+        ktDeclaration: KtDeclaration,
+        getter: PsiMethodItem?,
+    ): MutableModifierList {
+        val modifiers =
+            if (getter != null) {
+                create(codebase, getter.psi())
+            } else {
+                val ktModifierList = ktDeclaration.modifierList
+                val visibilityFlags =
+                    visibilityFlags(
+                        psiModifierList = null,
+                        ktModifierList = ktModifierList,
+                        element = ktDeclaration,
+                        sourcePsi = ktDeclaration
+                    )
+                val kotlinFlags = kotlinFlags { token ->
+                    ktModifierList?.hasModifier(token) ?: ktDeclaration.hasModifier(token)
+                }
+                val javaFlags = javaFlagsForKotlinElement(ktDeclaration)
+                val flags = visibilityFlags or kotlinFlags or javaFlags
+                createMutableModifiers(flags, emptyList())
+            }
+
+        // Annotations whose target is property won't be bound to anywhere in LC/UAST, if the
+        // property doesn't need a backing field. Same for unspecified use-site target.
+        // Add all annotations applied to the property by examining source PSI directly.
+        for (ktAnnotationEntry in ktDeclaration.annotationEntries) {
+            val useSiteTarget = ktAnnotationEntry.useSiteTarget?.getAnnotationUseSiteTarget()
+            if (useSiteTarget == null || useSiteTarget == AnnotationUseSiteTarget.PROPERTY) {
+                val uAnnotation = ktAnnotationEntry.toUElement() as? UAnnotation ?: continue
+                val annotationItem = UAnnotationItem.create(codebase, uAnnotation)
+                if (annotationItem !in modifiers.annotations()) {
+                    modifiers.addAnnotation(annotationItem)
+                }
+            }
+        }
+
+        if (hasDeprecatedAnnotation(modifiers)) {
+            modifiers.setDeprecated(true)
+        }
+
+        return modifiers
+    }
+
     /** Determine whether nullness annotations need removing from [modifiers]. */
     private fun shouldRemoveNullnessAnnotations(
         modifiers: BaseModifierList,
@@ -203,11 +254,30 @@ internal object PsiModifierItem {
                 }
             }
         }
+
+        // Merge in the visibility flags.
+        val visibilityFlags = visibilityFlags(modifierList, ktModifierList, element, sourcePsi)
+        flags = flags or visibilityFlags
+
+        // Merge in kotlin flags
+        if (ktModifierList != null) {
+            flags = flags or kotlinFlags { token -> ktModifierList.hasModifier(token) }
+        }
+        return flags
+    }
+
+    /** Determine the element visibility, which can come from several sources. */
+    private fun visibilityFlags(
+        psiModifierList: PsiModifierList?,
+        ktModifierList: KtModifierList?,
+        element: PsiElement?,
+        sourcePsi: PsiElement?
+    ): Int {
         var visibilityFlags =
             when {
-                modifierList.hasModifierProperty(PsiModifier.PUBLIC) -> PUBLIC
-                modifierList.hasModifierProperty(PsiModifier.PROTECTED) -> PROTECTED
-                modifierList.hasModifierProperty(PsiModifier.PRIVATE) -> PRIVATE
+                psiModifierList?.hasModifierProperty(PsiModifier.PUBLIC) == true -> PUBLIC
+                psiModifierList?.hasModifierProperty(PsiModifier.PROTECTED) == true -> PROTECTED
+                psiModifierList?.hasModifierProperty(PsiModifier.PRIVATE) == true -> PRIVATE
                 ktModifierList != null ->
                     when {
                         ktModifierList.hasModifier(KtTokens.PRIVATE_KEYWORD) -> PRIVATE
@@ -225,6 +295,13 @@ internal object PsiModifierItem {
                         element.hasModifierProperty(PsiModifier.PRIVATE) -> PRIVATE
                         else -> PUBLIC
                     }
+                sourcePsi is KtModifierListOwner ->
+                    when {
+                        sourcePsi.hasModifier(KtTokens.PRIVATE_KEYWORD) -> PRIVATE
+                        sourcePsi.hasModifier(KtTokens.PROTECTED_KEYWORD) -> PROTECTED
+                        sourcePsi.hasModifier(KtTokens.INTERNAL_KEYWORD) -> INTERNAL
+                        else -> PUBLIC
+                    }
                 else -> PACKAGE_PRIVATE
             }
         if (ktModifierList != null) {
@@ -248,60 +325,22 @@ internal object PsiModifierItem {
                     }
                 }
             }
-            if (ktModifierList.hasModifier(KtTokens.VARARG_KEYWORD)) {
-                flags = flags or VARARG
-            }
-            if (ktModifierList.hasModifier(KtTokens.SEALED_KEYWORD)) {
-                flags = flags or SEALED
-            }
-            if (ktModifierList.hasModifier(KtTokens.INFIX_KEYWORD)) {
-                flags = flags or INFIX
-            }
-            if (ktModifierList.hasModifier(KtTokens.CONST_KEYWORD)) {
-                flags = flags or CONST
-            }
-            if (ktModifierList.hasModifier(KtTokens.OPERATOR_KEYWORD)) {
-                flags = flags or OPERATOR
-            }
-            if (ktModifierList.hasModifier(KtTokens.INLINE_KEYWORD)) {
-                flags = flags or INLINE
-
-                // Workaround for b/117565118:
-                val func = sourcePsi as? KtNamedFunction
-                if (
-                    func != null &&
-                        (func.typeParameterList?.text ?: "").contains(
-                            KtTokens.REIFIED_KEYWORD.value
-                        ) &&
-                        !ktModifierList.hasModifier(KtTokens.PRIVATE_KEYWORD) &&
-                        !ktModifierList.hasModifier(KtTokens.INTERNAL_KEYWORD)
-                ) {
-                    // Switch back from private to public
-                    visibilityFlags = PUBLIC
-                }
-            }
-            if (ktModifierList.hasValueModifier()) {
-                flags = flags or VALUE
-            }
-            if (ktModifierList.hasSuspendModifier()) {
-                flags = flags or SUSPEND
-            }
-            if (ktModifierList.hasModifier(KtTokens.COMPANION_KEYWORD)) {
-                flags = flags or COMPANION
-            }
-            if (ktModifierList.hasFunModifier()) {
-                flags = flags or FUN
-            }
-            if (ktModifierList.hasModifier(KtTokens.DATA_KEYWORD)) {
-                flags = flags or DATA
-            }
-            if (ktModifierList.hasExpectModifier()) {
-                flags = flags or EXPECT
-            }
-            if (ktModifierList.hasActualModifier()) {
-                flags = flags or ACTUAL
+        }
+
+        if (ktModifierList?.hasModifier(KtTokens.INLINE_KEYWORD) == true) {
+            // Workaround for b/117565118:
+            val func = sourcePsi as? KtNamedFunction
+            if (
+                func != null &&
+                    (func.typeParameterList?.text ?: "").contains(KtTokens.REIFIED_KEYWORD.value) &&
+                    !ktModifierList.hasModifier(KtTokens.PRIVATE_KEYWORD) &&
+                    !ktModifierList.hasModifier(KtTokens.INTERNAL_KEYWORD)
+            ) {
+                // Switch back from private to public
+                visibilityFlags = PUBLIC
             }
         }
+
         // Methods that are property accessors inherit visibility from the source element
         if (element is UMethod && (element.sourceElement is KtPropertyAccessor)) {
             val sourceElement = element.sourceElement
@@ -315,12 +354,79 @@ internal object PsiModifierItem {
             }
         }
 
-        // Merge in the visibility flags.
-        flags = flags or visibilityFlags
+        return visibilityFlags
+    }
 
+    /** Computes Kotlin-specific flags. */
+    private fun kotlinFlags(hasModifier: (KtModifierKeywordToken) -> Boolean): Int {
+        var flags = 0
+        if (hasModifier(KtTokens.VARARG_KEYWORD)) {
+            flags = flags or VARARG
+        }
+        if (hasModifier(KtTokens.SEALED_KEYWORD)) {
+            flags = flags or SEALED
+        }
+        if (hasModifier(KtTokens.INFIX_KEYWORD)) {
+            flags = flags or INFIX
+        }
+        if (hasModifier(KtTokens.CONST_KEYWORD)) {
+            flags = flags or CONST
+        }
+        if (hasModifier(KtTokens.OPERATOR_KEYWORD)) {
+            flags = flags or OPERATOR
+        }
+        if (hasModifier(KtTokens.INLINE_KEYWORD)) {
+            flags = flags or INLINE
+        }
+        if (hasModifier(KtTokens.VALUE_KEYWORD)) {
+            flags = flags or VALUE
+        }
+        if (hasModifier(KtTokens.SUSPEND_KEYWORD)) {
+            flags = flags or SUSPEND
+        }
+        if (hasModifier(KtTokens.COMPANION_KEYWORD)) {
+            flags = flags or COMPANION
+        }
+        if (hasModifier(KtTokens.FUN_KEYWORD)) {
+            flags = flags or FUN
+        }
+        if (hasModifier(KtTokens.DATA_KEYWORD)) {
+            flags = flags or DATA
+        }
+        if (hasModifier(KtTokens.EXPECT_KEYWORD)) {
+            flags = flags or EXPECT
+        }
+        if (hasModifier(KtTokens.ACTUAL_KEYWORD)) {
+            flags = flags or ACTUAL
+        }
         return flags
     }
 
+    /** Creates Java-equivalent flags for the Kotlin element. */
+    private fun javaFlagsForKotlinElement(ktDeclaration: KtDeclaration): Int {
+        return if (ktDeclaration.hasModifier(KtTokens.CONST_KEYWORD)) {
+            FINAL or STATIC
+        } else if (ktDeclaration.hasModifier(KtTokens.FINAL_KEYWORD)) {
+            FINAL
+        } else if (
+            ktDeclaration.hasModifier(KtTokens.ABSTRACT_KEYWORD) ||
+                ktDeclaration.containingClass()?.isAnnotation() == true
+        ) {
+            // Declarations with the abstract keyword are abstract, and so are annotation class
+            // properties.
+            ABSTRACT
+        } else if (
+            !ktDeclaration.hasModifier(KtTokens.OPEN_KEYWORD) &&
+                !ktDeclaration.hasModifier(KtTokens.OVERRIDE_KEYWORD) &&
+                ktDeclaration.containingClass()?.isInterface() != true
+        ) {
+            // Kotlin elements are final unless declared otherwise.
+            FINAL
+        } else {
+            0
+        }
+    }
+
     /**
      * Returns a list of the targets this annotation is defined to apply to, as qualified names
      * (e.g. "java.lang.annotation.ElementType.TYPE_USE").
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiPropertyItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiPropertyItem.kt
index fcb24124e..292c6a589 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiPropertyItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiPropertyItem.kt
@@ -26,16 +26,12 @@ import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.PropertyItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.item.DefaultPropertyItem
-import com.intellij.psi.PsiMethod
-import org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget
-import org.jetbrains.kotlin.psi.KtPropertyAccessor
-import org.jetbrains.uast.UAnnotation
-import org.jetbrains.uast.toUElement
+import org.jetbrains.kotlin.psi.KtDeclaration
 
 internal class PsiPropertyItem
 private constructor(
     override val codebase: PsiBasedCodebase,
-    private val psiMethod: PsiMethod,
+    private val ktDeclaration: KtDeclaration,
     modifiers: BaseModifierList,
     // This needs to be passed in because the documentation may come from the property, or it may
     // come from the getter method.
@@ -43,39 +39,46 @@ private constructor(
     name: String,
     containingClass: ClassItem,
     type: TypeItem,
-    override val getter: MethodItem,
-    override val setter: MethodItem?,
-    override val constructorParameter: ParameterItem?,
-    override val backingField: FieldItem?
+    getter: MethodItem?,
+    setter: MethodItem?,
+    constructorParameter: ParameterItem?,
+    backingField: FieldItem?
 ) :
     DefaultPropertyItem(
         codebase = codebase,
-        fileLocation = PsiFileLocation(psiMethod),
-        itemLanguage = psiMethod.itemLanguage,
+        fileLocation = PsiFileLocation(ktDeclaration),
+        itemLanguage = ktDeclaration.itemLanguage,
         modifiers = modifiers,
         documentationFactory = documentationFactory,
         variantSelectorsFactory = ApiVariantSelectors.MUTABLE_FACTORY,
         name = name,
         containingClass = containingClass,
         type = type,
+        getter = getter,
+        setter = setter,
+        constructorParameter = constructorParameter,
+        backingField = backingField,
     ),
     PropertyItem,
     PsiItem {
 
-    override fun psi() = psiMethod
+    override fun psi() = ktDeclaration
 
     companion object {
         /**
-         * Creates a new property item, given a [name], [type] and relationships to other items.
+         * Creates a new property item for the [ktDeclaration], given a [name] and relationships to
+         * other items.
          *
          * Kotlin's properties consist of up to four other declarations: Their accessor functions,
          * primary constructor parameter, and a backing field. These relationships are useful for
          * resolving documentation and exposing the model correctly in Kotlin stubs.
          *
-         * Metalava currently requires all properties to have a [getter]. It does not currently
-         * support private, `const val`, or [JvmField] properties. Mutable `var` properties usually
-         * have a [setter], but properties with a private default setter may use direct field access
-         * instead.
+         * Most properties have a [getter], but those that are available through field access in
+         * Java (e.g. `const val` and [JvmField] properties) or are not accessible from Java (e.g.
+         * private properties and non-constructor value class properties) do not.
+         *
+         * Mutable `var` properties usually have a [setter], but properties with a private default
+         * setter may use direct field access instead.
          *
          * Properties declared in the primary constructor of a class have an associated
          * [constructorParameter]. This relationship is important for resolving docs which may exist
@@ -86,51 +89,26 @@ private constructor(
          */
         internal fun create(
             codebase: PsiBasedCodebase,
+            ktDeclaration: KtDeclaration,
             containingClass: ClassItem,
+            typeItemFactory: PsiTypeItemFactory,
             name: String,
-            type: TypeItem,
-            getter: PsiMethodItem,
+            getter: PsiMethodItem?,
             setter: PsiMethodItem? = null,
             constructorParameter: PsiParameterItem? = null,
-            backingField: PsiFieldItem? = null
-        ): PsiPropertyItem {
-            val psiMethod = getter.psiMethod
-            // Get the appropriate element from which to retrieve the documentation.
-            val psiElement =
-                when (val sourcePsi = getter.sourcePsi) {
-                    is KtPropertyAccessor -> sourcePsi.property
-                    else -> sourcePsi ?: psiMethod
-                }
-            val modifiers = PsiModifierItem.create(codebase, psiMethod)
-            // Alas, annotations whose target is property won't be bound to anywhere in LC/UAST,
-            // if the property doesn't need a backing field. Same for unspecified use-site target.
-            // To preserve such annotations, our last resort is to examine source PSI directly.
-            if (backingField == null) {
-                val ktProperty = (getter.sourcePsi as? KtPropertyAccessor)?.property
-                val annotations =
-                    ktProperty?.annotationEntries?.mapNotNull {
-                        val useSiteTarget = it.useSiteTarget?.getAnnotationUseSiteTarget()
-                        if (
-                            useSiteTarget == null ||
-                                useSiteTarget == AnnotationUseSiteTarget.PROPERTY
-                        ) {
-                            it.toUElement() as? UAnnotation
-                        } else null
-                    }
-                annotations?.forEach { uAnnotation ->
-                    val annotationItem =
-                        UAnnotationItem.create(codebase, uAnnotation) ?: return@forEach
-                    if (annotationItem !in modifiers.annotations()) {
-                        modifiers.addAnnotation(annotationItem)
-                    }
-                }
-            }
+            backingField: PsiFieldItem? = null,
+        ): PsiPropertyItem? {
+            val type =
+                getter?.returnType()
+                    ?: typeItemFactory.getTypeForProperty(ktDeclaration) ?: return null
+            val modifiers = PsiModifierItem.createForProperty(codebase, ktDeclaration, getter)
+
             val property =
                 PsiPropertyItem(
                     codebase = codebase,
-                    psiMethod = psiMethod,
+                    ktDeclaration = ktDeclaration,
                     modifiers = modifiers,
-                    documentationFactory = PsiItemDocumentation.factory(psiElement, codebase),
+                    documentationFactory = PsiItemDocumentation.factory(ktDeclaration, codebase),
                     name = name,
                     containingClass = containingClass,
                     type = type,
@@ -139,7 +117,7 @@ private constructor(
                     constructorParameter = constructorParameter,
                     backingField = backingField
                 )
-            getter.property = property
+            getter?.property = property
             setter?.property = property
             constructorParameter?.property = property
             backingField?.property = property
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceFile.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceFile.kt
index 2e5ea6766..a66348209 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceFile.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceFile.kt
@@ -17,8 +17,8 @@
 package com.android.tools.metalava.model.psi
 
 import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.FilterPredicate
 import com.android.tools.metalava.model.Import
-import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.SourceFile
 import com.intellij.psi.PsiClass
 import com.intellij.psi.PsiClassOwner
@@ -31,7 +31,6 @@ import com.intellij.psi.PsiMethod
 import com.intellij.psi.PsiPackage
 import com.intellij.psi.PsiWhiteSpace
 import java.util.TreeSet
-import java.util.function.Predicate
 import org.jetbrains.kotlin.kdoc.psi.api.KDoc
 import org.jetbrains.kotlin.psi.KtFile
 import org.jetbrains.kotlin.psi.psiUtil.startOffset
@@ -87,7 +86,7 @@ internal class PsiSourceFile(
         return super.getHeaderComments()
     }
 
-    override fun getImports(predicate: Predicate<Item>): Collection<Import> {
+    override fun getImports(predicate: FilterPredicate): Collection<Import> {
         val imports = TreeSet<Import>(compareBy { it.pattern })
 
         if (file is PsiJavaFile) {
@@ -96,7 +95,7 @@ internal class PsiSourceFile(
                 for (importStatement in importList.importStatements) {
                     val resolved = importStatement.resolve() ?: continue
                     if (resolved is PsiClass) {
-                        val classItem = codebase.findClass(resolved) ?: continue
+                        val classItem = codebase.findOrCreateClass(resolved)
                         if (predicate.test(classItem)) {
                             imports.add(Import(classItem))
                         }
@@ -119,7 +118,7 @@ internal class PsiSourceFile(
                         }
                     } else if (resolved is PsiField) {
                         val classItem =
-                            codebase.findClass(resolved.containingClass ?: continue) ?: continue
+                            codebase.findOrCreateClass(resolved.containingClass ?: continue)
                         val fieldItem =
                             classItem.findField(
                                 resolved.name,
@@ -137,7 +136,7 @@ internal class PsiSourceFile(
             for (importDirective in file.importDirectives) {
                 val resolved = importDirective.reference?.resolve() ?: continue
                 if (resolved is PsiClass) {
-                    val classItem = codebase.findClass(resolved) ?: continue
+                    val classItem = codebase.findOrCreateClass(resolved)
                     if (predicate.test(classItem)) {
                         imports.add(Import(classItem))
                     }
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceParser.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceParser.kt
index 211dd337c..551dfce17 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceParser.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiSourceParser.kt
@@ -20,14 +20,12 @@ import com.android.SdkConstants
 import com.android.tools.lint.UastEnvironment
 import com.android.tools.lint.computeMetadata
 import com.android.tools.lint.detector.api.Project
-import com.android.tools.metalava.model.AnnotationManager
 import com.android.tools.metalava.model.ClassResolver
 import com.android.tools.metalava.model.Codebase
-import com.android.tools.metalava.model.noOpAnnotationManager
+import com.android.tools.metalava.model.PackageFilter
 import com.android.tools.metalava.model.source.DEFAULT_JAVA_LANGUAGE_LEVEL
 import com.android.tools.metalava.model.source.SourceParser
 import com.android.tools.metalava.model.source.SourceSet
-import com.android.tools.metalava.reporter.Reporter
 import com.intellij.pom.java.LanguageLevel
 import java.io.File
 import org.jetbrains.kotlin.config.ApiVersion
@@ -58,23 +56,23 @@ fun kotlinLanguageVersionSettings(value: String?): LanguageVersionSettings {
  */
 internal class PsiSourceParser(
     private val psiEnvironmentManager: PsiEnvironmentManager,
-    private val reporter: Reporter,
-    private val annotationManager: AnnotationManager = noOpAnnotationManager,
-    private val javaLanguageLevel: LanguageLevel = defaultJavaLanguageLevel,
-    private val kotlinLanguageLevel: LanguageVersionSettings = defaultKotlinLanguageLevel,
-    private val useK2Uast: Boolean = false,
+    private val codebaseConfig: Codebase.Config,
+    private val javaLanguageLevel: LanguageLevel,
+    private val kotlinLanguageLevel: LanguageVersionSettings,
+    private val useK2Uast: Boolean,
     private val allowReadingComments: Boolean,
-    private val jdkHome: File? = null,
-    private val projectDescription: File? = null,
+    private val jdkHome: File?,
+    private val projectDescription: File?,
 ) : SourceParser {
 
+    private val reporter = codebaseConfig.reporter
+
     override fun getClassResolver(classPath: List<File>): ClassResolver {
         val uastEnvironment = loadUastFromJars(classPath)
         return PsiBasedClassResolver(
             uastEnvironment,
-            annotationManager,
-            reporter,
-            allowReadingComments
+            codebaseConfig,
+            allowReadingComments,
         )
     }
 
@@ -89,12 +87,14 @@ internal class PsiSourceParser(
         commonSourceSet: SourceSet,
         description: String,
         classPath: List<File>,
+        apiPackages: PackageFilter?,
     ): Codebase {
         return parseAbsoluteSources(
             sourceSet.absoluteCopy().extractRoots(reporter),
             commonSourceSet.absoluteCopy().extractRoots(reporter),
             description,
-            classPath.map { it.absoluteFile }
+            classPath.map { it.absoluteFile },
+            apiPackages,
         )
     }
 
@@ -104,6 +104,7 @@ internal class PsiSourceParser(
         commonSourceSet: SourceSet,
         description: String,
         classpath: List<File>,
+        apiPackages: PackageFilter?,
     ): PsiBasedCodebase {
         val config = UastEnvironment.Configuration.create(useFirUast = useK2Uast)
         config.javaLanguageLevel = javaLanguageLevel
@@ -144,14 +145,13 @@ internal class PsiSourceParser(
                 PsiBasedCodebase(
                     location = rootDir,
                     description = description,
-                    annotationManager = annotationManager,
-                    reporter = reporter,
+                    config = codebaseConfig,
                     allowReadingComments = allowReadingComments,
                     assembler = it,
                 )
             }
 
-        assembler.initializeFromSources(sourceSet)
+        assembler.initializeFromSources(sourceSet, apiPackages)
         return assembler.codebase
     }
 
@@ -166,8 +166,7 @@ internal class PsiSourceParser(
                 PsiBasedCodebase(
                     location = apiJar,
                     description = "Codebase loaded from $apiJar",
-                    annotationManager = annotationManager,
-                    reporter = reporter,
+                    config = codebaseConfig,
                     allowReadingComments = allowReadingComments,
                     assembler = assembler,
                 )
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeItemFactory.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeItemFactory.kt
index 703188d77..8bb148731 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeItemFactory.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeItemFactory.kt
@@ -47,6 +47,7 @@ import org.jetbrains.kotlin.analysis.api.KaExperimentalApi
 import org.jetbrains.kotlin.analysis.api.types.KaClassType
 import org.jetbrains.kotlin.analysis.api.types.KaFunctionType
 import org.jetbrains.kotlin.analysis.api.types.KaTypeMappingMode
+import org.jetbrains.kotlin.psi.KtElement
 import org.jetbrains.kotlin.utils.addToStdlib.ifNotEmpty
 import org.jetbrains.uast.kotlin.isKotlin
 
@@ -147,6 +148,27 @@ internal class PsiTypeItemFactory(
         )
     }
 
+    /**
+     * Attempts to create a type for the [ktElement]. Returns null if the Kotlin type for the
+     * element could not be converted to a [PsiType]. This should only be used when the element has
+     * no [PsiElement] with a defined [PsiType].
+     */
+    @OptIn(KaExperimentalApi::class)
+    internal fun getTypeForProperty(
+        ktElement: KtElement,
+    ): PsiTypeItem? {
+        val kotlinTypeInfo = KotlinTypeInfo.fromContext(ktElement)
+        val psiType =
+            kotlinTypeInfo.analysisSession?.run {
+                kotlinTypeInfo.kaType?.asPsiType(
+                    ktElement,
+                    allowErrorTypes = false,
+                    mode = KaTypeMappingMode.DEFAULT_UAST
+                )
+            }
+        return psiType?.let { createTypeItem(it, kotlinTypeInfo, ContextNullability.none) }
+    }
+
     // PsiTypeItem factory methods
 
     /** Creates modifiers based on the annotations of the [type]. */
@@ -262,7 +284,9 @@ internal class PsiTypeItemFactory(
                 throw IllegalStateException(
                     "Invalid type in API surface: $psiType${
                     if (kotlinType != null) {
-                        " in file " + kotlinType.context.containingFile.name
+                        val location = PsiFileLocation.fromPsiElement(kotlinType.context)
+                        " for element ${location.baselineKey?.elementId()}" +
+                            " in file ${location.path}:${location.line}"
                     } else ""
                 }"
                 )
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeParameterItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeParameterItem.kt
index ff27d8254..da561c1b2 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeParameterItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/PsiTypeParameterItem.kt
@@ -17,7 +17,6 @@
 package com.android.tools.metalava.model.psi
 
 import com.android.tools.metalava.model.BaseModifierList
-import com.android.tools.metalava.model.TypeParameterItem
 import com.android.tools.metalava.model.VariableTypeItem
 import com.android.tools.metalava.model.item.DefaultTypeParameterItem
 import com.intellij.psi.PsiTypeParameter
@@ -28,34 +27,33 @@ import org.jetbrains.kotlin.psi.KtTypeParameter
 
 internal class PsiTypeParameterItem(
     override val codebase: PsiBasedCodebase,
-    private val psiClass: PsiTypeParameter,
+    private val psiTypeParameter: PsiTypeParameter,
     name: String,
     modifiers: BaseModifierList
 ) :
     DefaultTypeParameterItem(
         codebase = codebase,
-        itemLanguage = psiClass.itemLanguage,
         modifiers = modifiers,
         name = name,
-        isReified = isReified(psiClass)
-    ),
-    TypeParameterItem,
-    PsiItem {
-
-    override fun psi() = psiClass
+        isReified = isReified(psiTypeParameter),
+    ) {
+    fun psi() = psiTypeParameter
 
     override fun createVariableTypeItem(): VariableTypeItem {
         return codebase.globalTypeItemFactory.getVariableTypeForTypeParameter(this)
     }
 
     companion object {
-        fun create(codebase: PsiBasedCodebase, psiClass: PsiTypeParameter): PsiTypeParameterItem {
-            val simpleName = psiClass.name!!
-            val modifiers = PsiModifierItem.create(codebase, psiClass)
+        fun create(
+            codebase: PsiBasedCodebase,
+            psiTypeParameter: PsiTypeParameter,
+        ): PsiTypeParameterItem {
+            val simpleName = psiTypeParameter.name!!
+            val modifiers = PsiModifierItem.create(codebase, psiTypeParameter)
 
             return PsiTypeParameterItem(
                 codebase = codebase,
-                psiClass = psiClass,
+                psiTypeParameter = psiTypeParameter,
                 name = simpleName,
                 modifiers = modifiers
             )
diff --git a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/UAnnotationItem.kt b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/UAnnotationItem.kt
index 2375a677d..3ad3fe1e9 100644
--- a/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/UAnnotationItem.kt
+++ b/metalava-model-psi/src/main/java/com/android/tools/metalava/model/psi/UAnnotationItem.kt
@@ -78,10 +78,6 @@ private constructor(
         return super.isNonNull()
     }
 
-    override val targets: Set<AnnotationTarget> by lazy {
-        codebase.annotationManager.computeTargets(this, codebase::resolveClass)
-    }
-
     companion object {
         private fun getAnnotationAttributes(
             codebase: PsiBasedCodebase,
diff --git a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiAnnotationMixtureTest.kt b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiAnnotationMixtureTest.kt
index 3bda443d8..ef2b8b812 100644
--- a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiAnnotationMixtureTest.kt
+++ b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiAnnotationMixtureTest.kt
@@ -19,6 +19,7 @@ package com.android.tools.metalava.model.psi
 import com.android.tools.lint.checks.infrastructure.TestFile
 import com.android.tools.metalava.model.ClassTypeItem
 import com.android.tools.metalava.model.PrimitiveTypeItem
+import com.android.tools.metalava.model.noOpAnnotationManager
 import com.android.tools.metalava.model.testsuite.BaseModelTest
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
@@ -75,7 +76,15 @@ class PsiAnnotationMixtureTest : BaseModelTest() {
         annotationUsageSource: TestFile,
         annotationDefinitionSource: TestFile,
     ) {
-        runCodebaseTest(inputSet(annotationDefinitionSource, annotationUsageSource)) {
+        runCodebaseTest(
+            inputSet(annotationDefinitionSource, annotationUsageSource),
+            testFixture =
+                TestFixture(
+                    // Use the noOpAnnotationManager to avoid annotation name normalizing as the
+                    // annotation names are important for this test.
+                    annotationManager = noOpAnnotationManager,
+                ),
+        ) {
             val methods = codebase.assertClass("test.pkg.Foo").methods()
             assertThat(methods).hasSize(3)
 
diff --git a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiFileLocationTest.kt b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiFileLocationTest.kt
new file mode 100644
index 000000000..2960a2feb
--- /dev/null
+++ b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiFileLocationTest.kt
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.psi
+
+import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.testing.kotlin
+import kotlin.test.Test
+import kotlin.test.assertEquals
+
+class PsiFileLocationTest : BaseModelTest() {
+    /**
+     * Casts [item] to a [PsiItem] and gets the source psi of its underlying PsiElement. Generates a
+     * baseline key, checking that the element ID of that key matches [expectedKey].
+     */
+    private fun checkBaselineKeyFromSourcePsi(item: Item, expectedKey: String) {
+        val psi = (item as PsiItem).sourcePsi
+        val baselineKey = PsiFileLocation.getBaselineKey(psi)
+        assertEquals(expectedKey, baselineKey.elementId())
+    }
+
+    @Test
+    fun `Baseline key for top level KtProperty`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+                    val propertyInTestKt = 0
+                """
+            ),
+            kotlin(
+                """
+                    @file:JvmName("Foo")
+                    package test.pkg
+                    val propertyInFoo = 0
+                """
+            )
+        ) {
+            val testKtPropertyItem = codebase.assertClass("test.pkg.TestKt").properties().single()
+            checkBaselineKeyFromSourcePsi(testKtPropertyItem, "test.pkg.TestKt#propertyInTestKt")
+            val fooPropertyItem = codebase.assertClass("test.pkg.Foo").properties().single()
+            checkBaselineKeyFromSourcePsi(fooPropertyItem, "test.pkg.Foo#propertyInFoo")
+        }
+    }
+
+    @Test
+    fun `Baseline key for KtFunction`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+                    interface Foo {
+                        fun <T> String.foo(arg: List<T>): String
+                    }
+                """
+            )
+        ) {
+            val foo = codebase.assertClass("test.pkg.Foo").methods().single()
+            checkBaselineKeyFromSourcePsi(
+                foo,
+                "test.pkg.Foo#foo(java.lang.String, java.util.List<? extends T>)"
+            )
+        }
+    }
+}
diff --git a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiModifierItemTest.kt b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiModifierItemTest.kt
index 5d3d4eaee..5f8adbe96 100644
--- a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiModifierItemTest.kt
+++ b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiModifierItemTest.kt
@@ -17,6 +17,7 @@
 package com.android.tools.metalava.model.psi
 
 import com.android.tools.metalava.model.VisibilityLevel
+import com.android.tools.metalava.model.noOpAnnotationManager
 import com.android.tools.metalava.model.testsuite.BaseModelTest
 import com.android.tools.metalava.testing.KnownSourceFiles.jetbrainsNullableTypeUseSource
 import com.android.tools.metalava.testing.java
@@ -54,6 +55,12 @@ class PsiModifierItemTest : BaseModelTest() {
         runCodebaseTest(
             inputSet(javaSource, jetbrainsNullableTypeUseSource),
             inputSet(kotlinSource, jetbrainsNullableTypeUseSource),
+            testFixture =
+                TestFixture(
+                    // Use the noOpAnnotationManager to avoid annotation name normalizing as the
+                    // annotation names are important for this test.
+                    annotationManager = noOpAnnotationManager,
+                ),
         ) {
             val method = codebase.assertClass("test.pkg.Foo").methods().single()
             // For now, the nullability annotation needs to be attached to the method.
diff --git a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiParameterItemTest.kt b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiParameterItemTest.kt
index bd5745805..01fbba02a 100644
--- a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiParameterItemTest.kt
+++ b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiParameterItemTest.kt
@@ -77,7 +77,7 @@ class PsiParameterItemTest : BaseModelTest() {
         ) {
             // Expect classes are ignored by UAST/Kotlin light classes, verify we test actual
             // classes.
-            val actualFile = codebase.assertClass("ActualKt").getSourceFile()
+            val actualFile = codebase.assertClass("ActualKt").sourceFile()
 
             val functionItem = codebase.assertClass("ActualKt").methods().single()
             with(functionItem) {
@@ -96,7 +96,7 @@ class PsiParameterItemTest : BaseModelTest() {
             }
 
             val classItem = codebase.assertClass("Test")
-            assertEquals(actualFile, classItem.getSourceFile())
+            assertEquals(actualFile, classItem.sourceFile())
 
             val constructorItem = classItem.constructors().single()
             with(constructorItem) {
diff --git a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiSourceParserTest.kt b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiSourceParserTest.kt
index 9a5cfa196..18bd5255b 100644
--- a/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiSourceParserTest.kt
+++ b/metalava-model-psi/src/test/java/com/android/tools/metalava/model/psi/PsiSourceParserTest.kt
@@ -28,7 +28,6 @@ import com.android.tools.metalava.testing.TemporaryFolderOwner
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
 import java.io.File
-import java.io.PrintWriter
 import java.io.StringWriter
 import kotlin.test.assertEquals
 import org.junit.Rule
@@ -61,7 +60,7 @@ class PsiSourceParserTest : TemporaryFolderOwner, Assertions {
         projectDir = temporaryFolder.newFolder()
         PsiEnvironmentManager().use { environmentManager ->
             outputWriter = StringWriter()
-            reporter = BasicReporter(PrintWriter(outputWriter))
+            reporter = BasicReporter(outputWriter)
             val codebase =
                 createTestCodebase(
                     environmentManager,
@@ -81,14 +80,18 @@ class PsiSourceParserTest : TemporaryFolderOwner, Assertions {
     ): Codebase {
         return environmentManager
             .createSourceParser(
-                reporter,
-                noOpAnnotationManager,
+                codebaseConfig =
+                    Codebase.Config(
+                        annotationManager = noOpAnnotationManager,
+                        reporter = reporter,
+                    ),
             )
             .parseSources(
                 createSourceSet(sources, directory),
                 SourceSet.empty(),
                 description = "Test Codebase",
                 classPath = emptyList(),
+                apiPackages = null,
             )
     }
 
diff --git a/metalava-model-snapshot-testing/src/test/java/com/android/tools/metalava/model/snapshot/SnapshotCodebaseTransformer.kt b/metalava-model-snapshot-testing/src/test/java/com/android/tools/metalava/model/snapshot/SnapshotCodebaseTransformer.kt
index 0d716d81a..d59d6768b 100644
--- a/metalava-model-snapshot-testing/src/test/java/com/android/tools/metalava/model/snapshot/SnapshotCodebaseTransformer.kt
+++ b/metalava-model-snapshot-testing/src/test/java/com/android/tools/metalava/model/snapshot/SnapshotCodebaseTransformer.kt
@@ -25,8 +25,15 @@ import com.android.tools.metalava.model.testing.transformer.CodebaseTransformer
 class SnapshotCodebaseTransformer : CodebaseTransformer {
     override fun transform(codebase: Codebase): Codebase {
         val fragment =
-            CodebaseFragment(codebase, ::NonEmittableDelegatingVisitor)
-                .snapshotIncludingRevertedItems()
+            CodebaseFragment.create(
+                    codebase,
+                    // Copy every Item from the input.
+                    ::NonFilteringDelegatingVisitor,
+                )
+                .snapshotIncludingRevertedItems(
+                    // Allow references to any Item in the original.
+                    ::NonFilteringDelegatingVisitor,
+                )
         return fragment.codebase
     }
 }
diff --git a/metalava-model-snapshot-testing/src/test/resources/model-test-suite-baseline.txt b/metalava-model-snapshot-testing/src/test/resources/model-test-suite-baseline.txt
index 37dd64074..a5ae52c2c 100644
--- a/metalava-model-snapshot-testing/src/test/resources/model-test-suite-baseline.txt
+++ b/metalava-model-snapshot-testing/src/test/resources/model-test-suite-baseline.txt
@@ -1,9 +1,6 @@
 com.android.tools.metalava.model.testsuite.BootstrapSourceModelProviderTest
   210 Test Method exception list[psi,java,k1]
   210 Test Method exception list[psi,java,k2]
-  240 test documentations[psi,java,k1]
-  240 test documentations[psi,java,k2]
-  240 test documentations[turbine]
   260 - test doconly members[psi,java,k1]
   260 - test doconly members[psi,java,k2]
   260 - test doconly members[turbine]
@@ -60,6 +57,9 @@ com.android.tools.metalava.model.testsuite.codebase.CommonCodebaseTest
   Test getTopLevelClassesFromSource[psi,java,k2]
   Test getTopLevelClassesFromSource[turbine]
 
+com.android.tools.metalava.model.testsuite.documentation.CommonParameterizedDocumentationTest
+  Documentation fully qualified[turbine,doc comment with link - java]
+
 com.android.tools.metalava.model.testsuite.fielditem.CommonFieldItemTest
   Test implicit nullability of constant field initialized from @NonNull method[turbine]
 
@@ -118,8 +118,6 @@ com.android.tools.metalava.model.testsuite.typeitem.CommonTypeModifiersTest
   Test inner parameterized types with annotations[psi,java,k2]
   Test interface types[turbine]
   Test leading annotation on array type[turbine]
-  Test nullability of Kotlin properties and accessors[psi,kotlin,k1]
-  Test nullability of Kotlin properties and accessors[psi,kotlin,k2]
   Test nullability of outer classes[psi,java,k1]
   Test nullability of outer classes[psi,java,k2]
   Test nullability of varargs[psi,kotlin,k1]
diff --git a/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/EnvironmentManager.kt b/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/EnvironmentManager.kt
index 32eab5417..05cc7f765 100644
--- a/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/EnvironmentManager.kt
+++ b/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/EnvironmentManager.kt
@@ -16,10 +16,8 @@
 
 package com.android.tools.metalava.model.source
 
-import com.android.tools.metalava.model.AnnotationManager
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.ModelOptions
-import com.android.tools.metalava.reporter.Reporter
 import java.io.Closeable
 import java.io.File
 
@@ -34,9 +32,7 @@ interface EnvironmentManager : Closeable {
     /**
      * Create a [SourceParser] that can be used to create [Codebase] related objects.
      *
-     * @param reporter the [Reporter] to use for any issues found while processing the sources.
-     * @param annotationManager the [AnnotationManager] that determines how annotations will affect
-     *   any generated [Codebase]s.
+     * @param codebaseConfig the [Codebase.Config] to pass through to the created [Codebase]s.
      * @param javaLanguageLevel the java language level as a string, e.g. 1.8, 17, etc.
      * @param kotlinLanguageLevel the kotlin language level as a string, e.g. 1.8, etc.
      * @param modelOptions a set of model specific options provided by the caller.
@@ -44,8 +40,7 @@ interface EnvironmentManager : Closeable {
      * @param projectDescription Lint project model that can describe project structures in detail.
      */
     fun createSourceParser(
-        reporter: Reporter,
-        annotationManager: AnnotationManager,
+        codebaseConfig: Codebase.Config,
         javaLanguageLevel: String = DEFAULT_JAVA_LANGUAGE_LEVEL,
         kotlinLanguageLevel: String = DEFAULT_KOTLIN_LANGUAGE_LEVEL,
         modelOptions: ModelOptions = ModelOptions.empty,
diff --git a/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceParser.kt b/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceParser.kt
index 2ee201a83..7a8a053b3 100644
--- a/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceParser.kt
+++ b/metalava-model-source/src/main/java/com/android/tools/metalava/model/source/SourceParser.kt
@@ -18,6 +18,7 @@ package com.android.tools.metalava.model.source
 
 import com.android.tools.metalava.model.ClassResolver
 import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.PackageFilter
 import java.io.File
 
 /** Provides support for creating [Codebase] related objects from source files (including jars). */
@@ -38,6 +39,9 @@ interface SourceParser {
      * @param description the description to use for [Codebase.description].
      * @param classPath the possibly empty list of jar files which may provide additional classes
      *   referenced by the sources.
+     * @param apiPackages an optional [PackageFilter] that if specified will result in only
+     *   including the source classes that match the filter in the
+     *   [Codebase.getTopLevelClassesFromSource] list.
      *
      * "Common module" is the term used in Kotlin multi-platform projects where platform-agnostic
      * business logic and `expect` declarations are declared. (Counterparts, like platform-specific
@@ -51,6 +55,7 @@ interface SourceParser {
         commonSourceSet: SourceSet,
         description: String,
         classPath: List<File>,
+        apiPackages: PackageFilter?,
     ): Codebase
 
     /**
diff --git a/metalava-model-source/src/testFixtures/java/com/android/tools/metalava/model/source/SourceModelSuiteRunner.kt b/metalava-model-source/src/testFixtures/java/com/android/tools/metalava/model/source/SourceModelSuiteRunner.kt
index 3d0b4d7a6..6110ad6c3 100644
--- a/metalava-model-source/src/testFixtures/java/com/android/tools/metalava/model/source/SourceModelSuiteRunner.kt
+++ b/metalava-model-source/src/testFixtures/java/com/android/tools/metalava/model/source/SourceModelSuiteRunner.kt
@@ -17,18 +17,15 @@
 package com.android.tools.metalava.model.source
 
 import com.android.tools.metalava.model.Codebase
-import com.android.tools.metalava.model.noOpAnnotationManager
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.provider.InputFormat
 import com.android.tools.metalava.model.testing.transformer.CodebaseTransformer
 import com.android.tools.metalava.model.testsuite.ModelSuiteRunner
 import com.android.tools.metalava.model.testsuite.ModelSuiteRunner.SourceDir
 import com.android.tools.metalava.model.testsuite.ModelSuiteRunner.TestConfiguration
-import com.android.tools.metalava.reporter.BasicReporter
 import com.android.tools.metalava.testing.getAndroidJar
 import com.android.tools.metalava.testing.getKotlinStdlibPaths
 import java.io.File
-import java.io.PrintWriter
 
 /** A [ModelSuiteRunner] that is implemented using a [SourceModelProvider]. */
 class SourceModelSuiteRunner(private val sourceModelProvider: SourceModelProvider) :
@@ -77,11 +74,10 @@ class SourceModelSuiteRunner(private val sourceModelProvider: SourceModelProvide
         inputs: ModelSuiteRunner.TestInputs,
         classPath: List<File>,
     ): Codebase {
-        val reporter = BasicReporter(PrintWriter(System.err))
+        val testFixture = inputs.testFixture
         val sourceParser =
             environmentManager.createSourceParser(
-                reporter = reporter,
-                annotationManager = noOpAnnotationManager,
+                codebaseConfig = testFixture.codebaseConfig,
                 modelOptions = inputs.modelOptions,
             )
         return sourceParser.parseSources(
@@ -89,6 +85,7 @@ class SourceModelSuiteRunner(private val sourceModelProvider: SourceModelProvide
             sourceSet(inputs.commonSourceDir),
             description = "Test Codebase",
             classPath = classPath,
+            apiPackages = testFixture.apiPackages,
         )
     }
 
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BaseModelTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BaseModelTest.kt
index 163413319..db7a8cf1d 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BaseModelTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BaseModelTest.kt
@@ -18,8 +18,12 @@ package com.android.tools.metalava.model.testsuite
 
 import com.android.tools.lint.checks.infrastructure.TestFile
 import com.android.tools.lint.checks.infrastructure.TestFiles
+import com.android.tools.metalava.model.AnnotationManager
 import com.android.tools.metalava.model.Assertions
 import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.PackageFilter
+import com.android.tools.metalava.model.annotation.DefaultAnnotationManager
+import com.android.tools.metalava.model.api.surface.ApiSurfaces
 import com.android.tools.metalava.model.provider.InputFormat
 import com.android.tools.metalava.model.testing.CodebaseCreatorConfig
 import com.android.tools.metalava.model.testing.CodebaseCreatorConfigAware
@@ -150,6 +154,28 @@ abstract class BaseModelTest() :
         }
     }
 
+    /** Additional properties that affect the behavior of the test. */
+    data class TestFixture(
+        /** The [AnnotationManager] to use when creating a [Codebase]. */
+        val annotationManager: AnnotationManager = DefaultAnnotationManager(),
+
+        /**
+         * The optional [PackageFilter] that defines which packages can contribute to the API. If
+         * this is unspecified then all packages can contribute to the API.
+         */
+        val apiPackages: PackageFilter? = null,
+
+        /** The set of [ApiSurfaces] used in the test. */
+        val apiSurfaces: ApiSurfaces = ApiSurfaces.DEFAULT
+    ) {
+        /** The [Codebase.Config] to use when creating a [Codebase] to test. */
+        val codebaseConfig =
+            Codebase.Config(
+                annotationManager = annotationManager,
+                apiSurfaces = apiSurfaces,
+            )
+    }
+
     /**
      * Create a [Codebase] from one of the supplied [inputSets] and then run a test on that
      * [Codebase].
@@ -159,7 +185,8 @@ abstract class BaseModelTest() :
      */
     private fun createCodebaseFromInputSetAndRun(
         inputSets: Array<out InputSet>,
-        commonSourcesByInputFormat: Map<InputFormat, InputSet> = emptyMap(),
+        commonSourcesByInputFormat: Map<InputFormat, InputSet>,
+        testFixture: TestFixture,
         test: CodebaseContext.() -> Unit,
     ) {
         // Run the input set that matches the current inputFormat, if there is one.
@@ -182,6 +209,7 @@ abstract class BaseModelTest() :
                         mainSourceDir = mainSourceDir,
                         additionalMainSourceDir = additionalSourceDir,
                         commonSourceDir = commonSourceDir,
+                        testFixture = testFixture,
                     )
                 runner.createCodebaseAndRun(inputs) { codebase ->
                     val context = DefaultCodebaseContext(codebase, mainSourceDir.dir)
@@ -213,11 +241,13 @@ abstract class BaseModelTest() :
     fun runCodebaseTest(
         vararg sources: TestFile,
         commonSources: Array<TestFile> = emptyArray(),
+        testFixture: TestFixture = TestFixture(),
         test: CodebaseContext.() -> Unit,
     ) {
         runCodebaseTest(
             sources = testFilesToInputSets(sources),
             commonSources = testFilesToInputSets(commonSources),
+            testFixture = testFixture,
             test = test,
         )
     }
@@ -231,11 +261,13 @@ abstract class BaseModelTest() :
     fun runCodebaseTest(
         vararg sources: InputSet,
         commonSources: Array<InputSet> = emptyArray(),
+        testFixture: TestFixture = TestFixture(),
         test: CodebaseContext.() -> Unit,
     ) {
         runCodebaseTest(
             sources = sources,
             commonSourcesByInputFormat = commonSources.associateBy { it.inputFormat },
+            testFixture = testFixture,
             test = test,
         )
     }
@@ -249,11 +281,13 @@ abstract class BaseModelTest() :
     private fun runCodebaseTest(
         vararg sources: InputSet,
         commonSourcesByInputFormat: Map<InputFormat, InputSet> = emptyMap(),
+        testFixture: TestFixture,
         test: CodebaseContext.() -> Unit,
     ) {
         createCodebaseFromInputSetAndRun(
             inputSets = sources,
             commonSourcesByInputFormat = commonSourcesByInputFormat,
+            testFixture = testFixture,
             test = test,
         )
     }
@@ -268,12 +302,14 @@ abstract class BaseModelTest() :
     fun runSourceCodebaseTest(
         vararg sources: TestFile,
         commonSources: Array<TestFile> = emptyArray(),
+        testFixture: TestFixture = TestFixture(),
         test: CodebaseContext.() -> Unit,
     ) {
         runSourceCodebaseTest(
             sources = testFilesToInputSets(sources),
             commonSourcesByInputFormat =
                 testFilesToInputSets(commonSources).associateBy { it.inputFormat },
+            testFixture = testFixture,
             test = test,
         )
     }
@@ -287,11 +323,13 @@ abstract class BaseModelTest() :
     fun runSourceCodebaseTest(
         vararg sources: InputSet,
         commonSources: Array<InputSet> = emptyArray(),
+        testFixture: TestFixture = TestFixture(),
         test: CodebaseContext.() -> Unit,
     ) {
         runSourceCodebaseTest(
             sources = sources,
             commonSourcesByInputFormat = commonSources.associateBy { it.inputFormat },
+            testFixture = testFixture,
             test = test,
         )
     }
@@ -305,11 +343,13 @@ abstract class BaseModelTest() :
     private fun runSourceCodebaseTest(
         vararg sources: InputSet,
         commonSourcesByInputFormat: Map<InputFormat, InputSet>,
+        testFixture: TestFixture,
         test: CodebaseContext.() -> Unit,
     ) {
         createCodebaseFromInputSetAndRun(
             inputSets = sources,
             commonSourcesByInputFormat = commonSourcesByInputFormat,
+            testFixture = testFixture,
             test = test,
         )
     }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BootstrapSourceModelProviderTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BootstrapSourceModelProviderTest.kt
index 22b4731ad..13afa8732 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BootstrapSourceModelProviderTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/BootstrapSourceModelProviderTest.kt
@@ -21,6 +21,7 @@ import com.android.tools.metalava.model.ClassTypeItem
 import com.android.tools.metalava.model.DefaultAnnotationSingleAttributeValue
 import com.android.tools.metalava.model.PrimitiveTypeItem
 import com.android.tools.metalava.model.VariableTypeItem
+import com.android.tools.metalava.model.noOpAnnotationManager
 import com.android.tools.metalava.testing.java
 import com.google.common.truth.Truth.assertThat
 import kotlin.test.assertEquals
@@ -437,6 +438,12 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
                     """
                 ),
             ),
+            testFixture =
+                TestFixture(
+                    // Use the noOpAnnotationManager to avoid annotation name normalizing as the
+                    // annotation names are important for this test.
+                    annotationManager = noOpAnnotationManager,
+                ),
         ) {
             val classItem = codebase.assertClass("test.pkg.Test")
             val fieldItem = classItem.assertField("myString")
@@ -963,7 +970,11 @@ class BootstrapSourceModelProviderTest : BaseModelTest() {
                          */
                 """
                     .trimIndent()
-            assertEquals(null, innerClassItem.getSourceFile())
+            assertEquals(
+                sourceFile,
+                innerClassItem.sourceFile(),
+                message = "inner class sourceFile"
+            )
             assertEquals(headerComment, sourceFile.getHeaderComments())
             assertEquals(methodComment, methodItem.documentation.text)
             assertEquals("/** Class documentation */", classItem.documentation.text)
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonApiSurfacesTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonApiSurfacesTest.kt
new file mode 100644
index 000000000..539367d0f
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonApiSurfacesTest.kt
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite
+
+import com.android.tools.metalava.model.api.surface.ApiSurfaces
+import com.android.tools.metalava.model.api.surface.ApiVariantType
+import com.android.tools.metalava.testing.java
+import kotlin.test.assertEquals
+import kotlin.test.assertNull
+import org.junit.Test
+
+@Suppress("JavadocDeclaration")
+class CommonApiSurfacesTest : BaseModelTest() {
+
+    @Test
+    fun `Test Codebase apiSurfaces default`() {
+        runCodebaseTest(
+            signature(
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public class Test {
+                        ctor public Test();
+                      }
+                    }
+                """
+            ),
+            java(
+                """
+                    package test.pkg;
+
+                    public class Test {
+                        public Test() {}
+                    }
+                """
+            ),
+        ) {
+            val apiSurfaces = codebase.apiSurfaces
+            assertEquals("main", apiSurfaces.main.name, "main name")
+            assertNull(apiSurfaces.base, "base not expected")
+        }
+    }
+
+    @Test
+    fun `Test Codebase apiSurfaces with base`() {
+        val fixtureApiSurfaces = ApiSurfaces.create(needsBase = true)
+        runCodebaseTest(
+            signature(
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public class Test {
+                        ctor public Test();
+                      }
+                    }
+                """
+            ),
+            java(
+                """
+                    package test.pkg;
+
+                    public class Test {
+                        public Test() {}
+                    }
+                """
+            ),
+            testFixture =
+                TestFixture(
+                    apiSurfaces = fixtureApiSurfaces,
+                ),
+        ) {
+            val apiSurfaces = codebase.apiSurfaces
+            assertEquals("main", apiSurfaces.main.name, "main name")
+            assertEquals("base", apiSurfaces.base?.name, "base name")
+        }
+    }
+
+    @Test
+    fun `Test mutating selectedApiVariants`() {
+        runCodebaseTest(
+            signature(
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public class Test {
+                        ctor public Test();
+                      }
+                    }
+                """
+            ),
+            java(
+                """
+                    package test.pkg;
+
+                    public class Test {
+                        public Test() {}
+                    }
+                """
+            ),
+        ) {
+            val testClass = codebase.assertClass("test.pkg.Test")
+
+            // Make sure that the selectedApiVariants is empty.
+            testClass.mutateSelectedApiVariants { clear() }
+
+            assertEquals(
+                "ApiVariantSet[]",
+                testClass.selectedApiVariants.toString(),
+                "empty selectedApiVariants"
+            )
+
+            val mainStubsApiVariant = codebase.apiSurfaces.main.variantFor(ApiVariantType.DOC_ONLY)
+            testClass.mutateSelectedApiVariants { add(mainStubsApiVariant) }
+            assertEquals(
+                "ApiVariantSet[main(D)]",
+                testClass.selectedApiVariants.toString(),
+                "mutated selectedApiVariants"
+            )
+        }
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonApiVariantSelectorsTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonApiVariantSelectorsTest.kt
index 49f070058..411517084 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonApiVariantSelectorsTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonApiVariantSelectorsTest.kt
@@ -20,8 +20,8 @@ import com.android.tools.metalava.model.ApiVariantSelectors
 import com.android.tools.metalava.model.ApiVariantSelectors.TestableSelectorsState
 import com.android.tools.metalava.model.BaseItemVisitor
 import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.MemberItem
+import com.android.tools.metalava.model.SelectableItem
 import com.android.tools.metalava.model.Showability
 import com.android.tools.metalava.testing.java
 import kotlin.test.assertEquals
@@ -396,8 +396,13 @@ class CommonApiVariantSelectorsTest : BaseModelTest() {
 
             var count = 0
             pkgItem.accept(
-                object : BaseItemVisitor() {
-                    override fun visitItem(item: Item) {
+                object :
+                    BaseItemVisitor(
+                        // [ParameterItem]s are not [SelectableItem]s so there is no point in
+                        // visiting them.
+                        visitParameterItems = false,
+                    ) {
+                    override fun visitSelectableItem(item: SelectableItem) {
                         val name =
                             when (item) {
                                 is ClassItem -> item.simpleName()
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonParameterizedSelectedApiVariantsTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonParameterizedSelectedApiVariantsTest.kt
new file mode 100644
index 000000000..8b26616f7
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/CommonParameterizedSelectedApiVariantsTest.kt
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite
+
+import com.android.tools.metalava.model.SelectableItem
+import com.android.tools.metalava.model.api.surface.ApiSurfaces
+import com.android.tools.metalava.model.testing.surfaces.SelectedApiVariantsTestData
+import com.android.tools.metalava.model.testing.surfaces.selectedApiVariantsTestData
+import org.junit.Test
+import org.junit.runners.Parameterized
+
+/**
+ * Parameterized tests for [SelectableItem.selectedApiVariants] using data from
+ * [selectedApiVariantsTestData].
+ */
+class CommonParameterizedSelectedApiVariantsTest : BaseModelTest() {
+
+    @Parameterized.Parameter(0) lateinit var testData: SelectedApiVariantsTestData
+
+    companion object {
+        @JvmStatic @Parameterized.Parameters fun params() = selectedApiVariantsTestData
+    }
+
+    @Test
+    fun `Test selectedApiVariants`() {
+        val testFixture =
+            TestFixture(
+                apiSurfaces = ApiSurfaces.create(testData.needsBase),
+            )
+        runCodebaseTest(inputSet(testData.signatureFiles), testFixture = testFixture) {
+            codebase.assertSelectedApiVariants(testData.expectedSelectedApiVariants)
+        }
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/ModelSuiteRunner.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/ModelSuiteRunner.kt
index 87d037a84..a083db1b2 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/ModelSuiteRunner.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/ModelSuiteRunner.kt
@@ -80,6 +80,9 @@ interface ModelSuiteRunner : FilterableCodebaseCreator {
 
         /** The optional common sources. */
         val commonSourceDir: SourceDir?,
+
+        /** Additional information to provide to the test runner. */
+        val testFixture: BaseModelTest.TestFixture,
     )
 
     /**
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/annotationitem/CommonAnnotationItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/annotationitem/CommonAnnotationItemTest.kt
index abf13b939..c27cfa577 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/annotationitem/CommonAnnotationItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/annotationitem/CommonAnnotationItemTest.kt
@@ -16,9 +16,9 @@
 
 package com.android.tools.metalava.model.testsuite.annotationitem
 
+import com.android.tools.metalava.model.ANNOTATION_IN_ALL_STUBS
 import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.BaseItemVisitor
-import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.getAttributeValue
 import com.android.tools.metalava.model.getAttributeValues
@@ -55,7 +55,7 @@ val sameLine =
         """
     )
 
-/** Common tests for implementations of [ClassItem]. */
+/** Common tests for implementations of [AnnotationItem]. */
 class CommonAnnotationItemTest : BaseModelTest() {
 
     /** Check the location information of the various parts of [item]. */
@@ -66,7 +66,10 @@ class CommonAnnotationItemTest : BaseModelTest() {
         fun addDetails(fileLocation: FileLocation, description: String) {
             val line = fileLocation.line
             if (line == 0) return
-            details.add(line to description)
+            val detail = line to description
+            if (detail !in details) {
+                details.add(detail)
+            }
         }
 
         foo.accept(
@@ -148,7 +151,7 @@ class CommonAnnotationItemTest : BaseModelTest() {
                         @SameLine("Foo") class Foo {
                             @LineBefore("constructor")
                             @SameLine("constructor") constructor() {}
-                            @LineBefore("field")
+                            @LineBefore("field") @get:LineBefore("getter")
                             @SameLine("field") val field: Int
                             @LineBefore("method")
                             @SameLine("method") fun method(
@@ -169,6 +172,7 @@ class CommonAnnotationItemTest : BaseModelTest() {
                     5:constructor test.pkg.Foo()
                     6:@test.pkg.SameLine("constructor")
                     7:@test.pkg.LineBefore("field")
+                    7:@test.pkg.LineBefore("getter")
                     8:@test.pkg.SameLine("field")
                     8:field test.pkg.Foo.field
                     8:method test.pkg.Foo.getField()
@@ -1573,6 +1577,39 @@ class CommonAnnotationItemTest : BaseModelTest() {
         }
     }
 
+    @Test
+    fun `annotation targets - on source path`() {
+        runCodebaseTest(
+            inputSet(
+                java(
+                    """
+                        package test.pkg;
+                        @SourcePathAnnotation
+                        public class Test {
+                            private Test() {}
+                        }
+                    """
+                ),
+                sourcePathFiles =
+                    listOf(
+                        java(
+                            """
+                                package test.pkg;
+                                public @interface SourcePathAnnotation {}
+                            """
+                        ),
+                    ),
+            ),
+        ) {
+            val testClass = codebase.assertClass("test.pkg.Test")
+            val annotationItem = testClass.modifiers.annotations().single()
+
+            // Make sure that it correctly computes targets for an annotation class from the
+            // source path.
+            assertEquals(ANNOTATION_IN_ALL_STUBS, annotationItem.targets)
+        }
+    }
+
     inline fun <reified T : Any> AnnotationItem.assertAttributeValue(
         attributeName: String,
         expected: T
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonClassItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonClassItemTest.kt
index a98c39675..8470936ac 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonClassItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonClassItemTest.kt
@@ -19,9 +19,11 @@ package com.android.tools.metalava.model.testsuite.classitem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassOrigin
 import com.android.tools.metalava.model.ClassTypeItem
+import com.android.tools.metalava.model.PackageFilter
 import com.android.tools.metalava.model.TypeNullability
 import com.android.tools.metalava.model.TypeParameterItem
 import com.android.tools.metalava.model.VariableTypeItem
+import com.android.tools.metalava.model.testing.testTypeString
 import com.android.tools.metalava.model.testsuite.BaseModelTest
 import com.android.tools.metalava.testing.KnownSourceFiles.typeUseOnlyNonNullSource
 import com.android.tools.metalava.testing.KnownSourceFiles.typeUseOnlyNullableSource
@@ -30,7 +32,6 @@ import com.android.tools.metalava.testing.kotlin
 import com.google.common.truth.Truth.assertThat
 import com.google.common.truth.Truth.assertWithMessage
 import kotlin.test.assertEquals
-import kotlin.test.assertNotNull
 import kotlin.test.assertNull
 import kotlin.test.assertSame
 import kotlin.test.assertTrue
@@ -66,7 +67,6 @@ class CommonClassItemTest : BaseModelTest() {
             assertEquals("Test", testClass.fullName())
             assertEquals("test/pkg/Test", testClass.internalName())
             assertEquals("test.pkg.Test", testClass.qualifiedName())
-            assertEquals("test.pkg.Test", testClass.qualifiedNameWithDollarNestedClasses())
             assertEquals(1, testClass.constructors().size)
             assertEquals(emptyList(), testClass.methods())
             assertEquals(emptyList(), testClass.fields())
@@ -654,7 +654,7 @@ class CommonClassItemTest : BaseModelTest() {
             val superClassType = fooClass.superClassType()!!
             assertEquals(
                 "test.pkg.Generic<java.lang.String?,java.lang.Integer>",
-                superClassType.toTypeString(kotlinStyleNulls = true)
+                superClassType.testTypeString(kotlinStyleNulls = true)
             )
         }
     }
@@ -717,7 +717,7 @@ class CommonClassItemTest : BaseModelTest() {
             val superClassType = fooClass.interfaceTypes().single()
             assertEquals(
                 "test.pkg.Generic<java.lang.String?,java.lang.Integer>",
-                superClassType.toTypeString(kotlinStyleNulls = true)
+                superClassType.testTypeString(kotlinStyleNulls = true)
             )
         }
     }
@@ -758,6 +758,7 @@ class CommonClassItemTest : BaseModelTest() {
                     package test.pkg;
 
                     /**
+                     * @noinspection DeprecatedIsStillUsed
                      * @deprecated
                      */
                     public class Bar {}
@@ -765,8 +766,48 @@ class CommonClassItemTest : BaseModelTest() {
             ),
         ) {
             val barClass = codebase.assertClass("test.pkg.Bar")
-            assertEquals(true, barClass.originallyDeprecated)
-            assertEquals(true, barClass.effectivelyDeprecated)
+            barClass.assertExplicitlyDeprecated()
+        }
+    }
+
+    @Test
+    fun `Test class is not treated as deprecated by @deprecatedSince`() {
+        runCodebaseTest(
+            java(
+                """
+                    package test.pkg;
+
+                    /**
+                     * @deprecatedSince this should not be treated as deprecated.
+                     * @noinspection JavadocDeclaration, DeprecatedIsStillUsed
+                     */
+                    public class Bar {}
+                """
+            ),
+        ) {
+            val barClass = codebase.assertClass("test.pkg.Bar")
+            barClass.assertNotDeprecated()
+        }
+    }
+
+    @Test
+    fun `Test class is treated as deprecated if @deprecated comes after @deprecatedSince`() {
+        runCodebaseTest(
+            java(
+                """
+                    package test.pkg;
+
+                    /**
+                     * @deprecatedSince this should not be treated as deprecated.
+                     * @noinspection JavadocDeclaration, DeprecatedIsStillUsed
+                     * @deprecated Really deprecated
+                     */
+                    public class Bar {}
+                """
+            ),
+        ) {
+            val barClass = codebase.assertClass("test.pkg.Bar")
+            barClass.assertExplicitlyDeprecated()
         }
     }
 
@@ -786,6 +827,7 @@ class CommonClassItemTest : BaseModelTest() {
                 """
                     package test.pkg;
 
+                    /** @noinspection DeprecatedIsStillUsed */
                     @Deprecated
                     public class Bar {}
                 """
@@ -800,8 +842,7 @@ class CommonClassItemTest : BaseModelTest() {
             ),
         ) {
             val barClass = codebase.assertClass("test.pkg.Bar")
-            assertEquals(true, barClass.originallyDeprecated)
-            assertEquals(true, barClass.effectivelyDeprecated)
+            barClass.assertExplicitlyDeprecated()
         }
     }
 
@@ -833,8 +874,7 @@ class CommonClassItemTest : BaseModelTest() {
             ),
         ) {
             val barClass = codebase.assertClass("test.pkg.Bar")
-            assertEquals(false, barClass.originallyDeprecated)
-            assertEquals(false, barClass.effectivelyDeprecated)
+            barClass.assertNotDeprecated()
         }
     }
 
@@ -1400,7 +1440,7 @@ class CommonClassItemTest : BaseModelTest() {
 
                 val parameterType = inheritedMethod.parameters().single().type()
                 assertWithMessage("testing type of $name")
-                    .that(parameterType.toTypeString(kotlinStyleNulls = true))
+                    .that(parameterType.testTypeString(kotlinStyleNulls = true))
                     .isEqualTo(expectedTypes[name])
             }
         }
@@ -1454,7 +1494,7 @@ class CommonClassItemTest : BaseModelTest() {
                 val returnType = inheritedMethod.returnType()
                 val (expectedType, expectedNullability) = expectedTypesAndNullability[name]!!
                 assertWithMessage("testing type of $name")
-                    .that(returnType.toTypeString(kotlinStyleNulls = true))
+                    .that(returnType.testTypeString(kotlinStyleNulls = true))
                     .isEqualTo(expectedType)
 
                 assertWithMessage("testing type nullability of $name")
@@ -1739,8 +1779,43 @@ class CommonClassItemTest : BaseModelTest() {
                     ),
             )
         ) {
-            // Make sure that a class defined on the source class path can be resolved.
-            assertNotNull(codebase.resolveClass("test.pkg.SourcePathClass"))
+            // Make sure that a class defined on the source class path can be resolved but is not
+            // emitted.
+            codebase.assertResolvedClass("test.pkg.SourcePathClass")
+        }
+    }
+
+    @Test
+    fun `Test class excluded by package filter`() {
+        runCodebaseTest(
+            inputSet(
+                java(
+                    """
+                        package test.pkg;
+
+                        public class Test {
+                            private Test() {}
+                        }
+                    """
+                ),
+                java(
+                    """
+                        package test.excluded.pkg;
+
+                        public class Excluded {
+                            private Excluded() {}
+                        }
+                    """
+                ),
+            ),
+            testFixture =
+                TestFixture(
+                    apiPackages = PackageFilter.parse("test.pkg"),
+                ),
+        ) {
+            // Make sure that a class defined excluded by a package filter can be resolved but is
+            // not emitted.
+            codebase.assertResolvedClass("test.excluded.pkg.Excluded")
         }
     }
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonDataClassTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonDataClassTest.kt
index 83fbc6a88..72ec539d1 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonDataClassTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonDataClassTest.kt
@@ -19,6 +19,7 @@ package com.android.tools.metalava.model.testsuite.classitem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.RequiresCapabilities
+import com.android.tools.metalava.model.testing.testTypeString
 import com.android.tools.metalava.model.testsuite.BaseModelTest
 import com.android.tools.metalava.testing.kotlin
 import com.google.common.truth.Truth.assertThat
@@ -52,7 +53,7 @@ class CommonDataClassTest : BaseModelTest() {
 
             val fields =
                 fooClass.fields().joinToString(separator = "\n") {
-                    "${it.name()}: ${it.type().toTypeString(kotlinStyleNulls = true)}"
+                    "${it.name()}: ${it.type().testTypeString(kotlinStyleNulls = true)}"
                 }
             assertEquals(
                 """
@@ -170,7 +171,7 @@ class CommonDataClassTest : BaseModelTest() {
 
             val allMembers =
                 (fooClass.fields().asSequence().map {
-                        "${it.name()}: ${it.type().toTypeString(kotlinStyleNulls = true)}"
+                        "${it.name()}: ${it.type().testTypeString(kotlinStyleNulls = true)}"
                     } +
                         (fooClass.constructors().asSequence() + fooClass.methods().asSequence())
                             .map { it.kotlinLikeDescription() })
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonValueClassTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonValueClassTest.kt
new file mode 100644
index 000000000..e7953cbdc
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/classitem/CommonValueClassTest.kt
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.classitem
+
+import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.testing.kotlin
+import kotlin.test.assertEquals
+import kotlin.test.assertFalse
+import kotlin.test.assertNotNull
+import kotlin.test.assertNull
+import kotlin.test.assertTrue
+import org.junit.Test
+
+class CommonValueClassTest : BaseModelTest() {
+    @Test
+    fun `Constructor visibility`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+
+                    @JvmInline
+                    value class PublicConstructor(val value: Int)
+
+                    @JvmInline
+                    value class PrivateConstructor private constructor(val value: Int)
+                """
+            )
+        ) {
+            val publicConstructorClass = codebase.assertClass("test.pkg.PublicConstructor")
+            val publicConstructor = publicConstructorClass.constructors().single()
+            assertTrue(publicConstructor.isPrimary)
+            assertTrue(publicConstructor.modifiers.isPublic())
+
+            val publicConstructorProperty = publicConstructorClass.properties().single()
+            assertTrue(publicConstructorProperty.isPublic)
+            assertNotNull(publicConstructorProperty.constructorParameter)
+            assertNotNull(publicConstructorProperty.backingField)
+
+            val privateConstructorClass = codebase.assertClass("test.pkg.PrivateConstructor")
+            val privateConstructor = privateConstructorClass.constructors().single()
+            assertTrue(privateConstructor.isPrimary)
+            assertTrue(privateConstructor.modifiers.isPrivate())
+
+            val privateConstructorProperty = privateConstructorClass.properties().single()
+            // The constructor is private, but the property is public
+            assertTrue(privateConstructorProperty.isPublic)
+            assertNotNull(privateConstructorProperty.constructorParameter)
+            assertNotNull(privateConstructorProperty.backingField)
+        }
+    }
+
+    @Test
+    fun `Secondary constructor`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+                    @JvmInline
+                    value class ValueClass(val value: Int) {
+                        constructor(v1: Int, v2: Int) : this(v1 + v2)
+                    }
+                """
+            )
+        ) {
+            val valueClass = codebase.assertClass("test.pkg.ValueClass")
+            assertEquals(valueClass.constructors().size, 2)
+
+            val primaryConstructor = valueClass.assertConstructor("int")
+            assertTrue(primaryConstructor.isPrimary)
+            assertTrue(primaryConstructor.modifiers.isPublic())
+
+            val secondaryConstructor = valueClass.assertConstructor("int,int")
+            assertFalse(secondaryConstructor.isPrimary)
+            assertTrue(secondaryConstructor.modifiers.isPublic())
+        }
+    }
+
+    fun `Constructor with optional value`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                package test.pkg
+                @JvmInline
+                value class ValueClass(val value: Int = 0)
+            """
+            )
+        ) {
+            val valueClass = codebase.assertClass("test.pkg.ValueClass")
+            assertEquals(valueClass.constructors().size, 1, "Expected exactly one constructor")
+            assertNotNull(valueClass.primaryConstructor, "Expected a primary constructor")
+
+            val primaryConstructor = valueClass.constructors().single()
+            assertTrue(primaryConstructor.isPrimary, "Expected a primary constructor")
+            val param = primaryConstructor.parameters().single()
+            assertTrue(param.hasDefaultValue(), "Expected a default value")
+            assertEquals(param.defaultValue.value(), "0", "Expected a default value of 0")
+        }
+    }
+
+    @Test
+    fun `Property accessors`() {
+        // Value class property accessors for non-constructor properties can't be used from Java
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+                    @JvmInline
+                    value class ValueClass(val value: Int) {
+                        var noAccessors: Int
+                            get() = 0
+                            set(v: Int) {}
+                    }
+                """
+            )
+        ) {
+            val valueClass = codebase.assertClass("test.pkg.ValueClass")
+            val ctorProperty = valueClass.assertProperty("value")
+            assertNotNull(ctorProperty.getter)
+            assertNull(ctorProperty.setter)
+            assertNotNull(ctorProperty.constructorParameter)
+            assertNotNull(ctorProperty.backingField)
+
+            val noAccessorsProperty = valueClass.assertProperty("noAccessors")
+            assertNull(noAccessorsProperty.getter)
+            assertNull(noAccessorsProperty.setter)
+            assertNull(noAccessorsProperty.constructorParameter)
+            assertNull(noAccessorsProperty.backingField)
+        }
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/codebase/CommonCodebaseTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/codebase/CommonCodebaseTest.kt
index 2e9183e53..d5febf217 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/codebase/CommonCodebaseTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/codebase/CommonCodebaseTest.kt
@@ -20,6 +20,7 @@ import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.testsuite.BaseModelTest
 import com.android.tools.metalava.testing.java
 import kotlin.test.assertEquals
+import kotlin.test.assertSame
 import org.junit.Test
 
 /** Common tests for implementations of [MethodItem]. */
@@ -49,4 +50,23 @@ class CommonCodebaseTest : BaseModelTest() {
             assertEquals(listOf(codebase.assertClass("test.pkg.Outer")), classes)
         }
     }
+
+    @Test
+    fun `Test resolve nested class sets correct containing class`() {
+        runSourceCodebaseTest(
+            java(
+                """
+                    package test.pkg;
+
+                    public class Test {
+                        private Test() {}
+                    }
+                """
+            ),
+        ) {
+            val entryClass = codebase.assertResolvedClass("java.util.Map.Entry")
+            val mapClass = codebase.assertResolvedClass("java.util.Map")
+            assertSame(entryClass.containingClass(), mapClass)
+        }
+    }
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/constructoritem/CommonConstructorItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/constructoritem/CommonConstructorItemTest.kt
index c2d3763bb..49ce1d87a 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/constructoritem/CommonConstructorItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/constructoritem/CommonConstructorItemTest.kt
@@ -20,6 +20,8 @@ import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.testsuite.BaseModelTest
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
+import kotlin.test.assertFalse
+import kotlin.test.assertTrue
 import org.junit.Test
 
 /** Common tests for implementations of [MethodItem]. */
@@ -84,4 +86,24 @@ class CommonConstructorItemTest : BaseModelTest() {
             constructorType.assertReferencesTypeParameter(oTypeParameter)
         }
     }
+
+    @Test
+    fun `Test Kotlin primary constructor`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+                    class Foo(i: Int, s: String?) {
+                        constructor(i: Int) : this(i, null)
+                    }
+                """
+            )
+        ) {
+            val classItem = codebase.assertClass("test.pkg.Foo")
+            val primaryCtor = classItem.assertConstructor("int,java.lang.String")
+            assertTrue(primaryCtor.isPrimary, "primary constructor")
+            val secondaryCtor = classItem.assertConstructor("int")
+            assertFalse(secondaryCtor.isPrimary, "secondary constructor")
+        }
+    }
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/documentation/CommonParameterizedDocumentationTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/documentation/CommonParameterizedDocumentationTest.kt
new file mode 100644
index 000000000..de7e781bf
--- /dev/null
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/documentation/CommonParameterizedDocumentationTest.kt
@@ -0,0 +1,185 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testsuite.documentation
+
+import com.android.tools.metalava.model.ItemDocumentation
+import com.android.tools.metalava.model.provider.InputFormat
+import com.android.tools.metalava.model.testsuite.BaseModelTest
+import com.android.tools.metalava.testing.java
+import com.android.tools.metalava.testing.kotlin
+import java.util.EnumSet
+import kotlin.test.assertEquals
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TestRule
+import org.junit.runner.Description
+import org.junit.runners.Parameterized
+import org.junit.runners.model.Statement
+
+/** Common tests for implementations of [ItemDocumentation] */
+class CommonParameterizedDocumentationTest : BaseModelTest() {
+
+    @Parameterized.Parameter(0) lateinit var params: TestParams
+
+    data class TestParams(
+        val name: String,
+        val inputFormats: Set<InputFormat> = EnumSet.allOf(InputFormat::class.java),
+        val imports: List<String> = emptyList(),
+        val comment: String,
+        val expectedText: String = comment,
+        val expectedFullyQualified: String = expectedText,
+    ) {
+        fun skipForInputFormat(inputFormat: InputFormat?) = inputFormat !in inputFormats
+
+        override fun toString(): String {
+            return name
+        }
+    }
+
+    companion object {
+        private val javaOnly = EnumSet.of(InputFormat.JAVA)
+        private val kotlinOnly = EnumSet.of(InputFormat.KOTLIN)
+
+        private val params =
+            listOf(
+                TestParams(
+                    name = "inline comment",
+                    comment = "// inline comment",
+                    expectedText = "",
+                ),
+                TestParams(
+                    name = "inline comment - link tag",
+                    comment = "// inline comment - {@link}",
+                    expectedText = "",
+                ),
+                TestParams(
+                    name = "block comment",
+                    comment = "/* block comment */",
+                    expectedText = "",
+                ),
+                TestParams(
+                    name = "block comment - link tag",
+                    comment = "/* block comment - {@link} */",
+                    expectedText = "",
+                ),
+                TestParams(
+                    name = "doc comment - plain text",
+                    comment = "/** doc comment */",
+                ),
+                TestParams(
+                    name = "doc comment with link - java",
+                    inputFormats = javaOnly,
+                    imports = listOf("java.util.List"),
+                    comment = "/** {@link List} */",
+                    expectedFullyQualified = "/** {@link java.util.List List} */",
+                ),
+                TestParams(
+                    name = "doc comment with link - kotlin",
+                    inputFormats = kotlinOnly,
+                    imports = listOf("kotlin.random.Random"),
+                    comment = "/** {@link Random} */",
+                    // Doc comments in Kotlin are not fully qualified as that is only needed for
+                    // java stubs due to an issue with doclava. Kotlin stubs are not supported.
+                ),
+            )
+
+        @JvmStatic @Parameterized.Parameters fun params() = params
+    }
+
+    /**
+     * [TestRule] that ignores tests whose [TestParams] are not suitable for the current
+     * [inputFormat].
+     */
+    @get:Rule
+    val filter =
+        object : TestRule {
+            override fun apply(base: Statement, description: Description): Statement {
+                return object : Statement() {
+                    override fun evaluate() {
+                        if (params.skipForInputFormat(inputFormat)) return
+                        base.evaluate()
+                    }
+                }
+            }
+        }
+
+    private fun imports(): String =
+        if (params.imports.isEmpty()) ""
+        else {
+            val terminator = if (inputFormat == InputFormat.JAVA) ";" else "\n"
+            params.imports.joinToString { "                    import $it$terminator" }
+        }
+
+    @Test
+    fun `Documentation text`() {
+        runSourceCodebaseTest(
+            java(
+                """
+                    package test.pkg;
+                    ${imports()}
+                    ${params.comment}
+                    public class Test {
+                    }
+                """
+            ),
+            kotlin(
+                """
+                    package test.pkg
+                    ${imports()}
+
+                    ${params.comment}
+                    class Test
+                """
+            )
+        ) {
+            val testClass = codebase.assertClass("test.pkg.Test")
+            val documentation = testClass.documentation
+
+            assertEquals(params.expectedText, documentation.text)
+        }
+    }
+
+    @Test
+    fun `Documentation fully qualified`() {
+        runSourceCodebaseTest(
+            java(
+                """
+                    package test.pkg;
+                    ${imports()}
+
+                    ${params.comment}
+                    public class Test {
+                    }
+                """
+            ),
+            kotlin(
+                """
+                    package test.pkg
+                    ${imports()}
+
+                    ${params.comment}
+                    class Test
+                """
+            )
+        ) {
+            val testClass = codebase.assertClass("test.pkg.Test")
+            val documentation = testClass.documentation
+
+            assertEquals(params.expectedFullyQualified, documentation.fullyQualifiedDocumentation())
+        }
+    }
+}
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/CommonFieldItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/CommonFieldItemTest.kt
index ee5ebf76e..0782e9f79 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/CommonFieldItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/fielditem/CommonFieldItemTest.kt
@@ -17,6 +17,7 @@
 package com.android.tools.metalava.model.testsuite.fielditem
 
 import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.testing.testTypeString
 import com.android.tools.metalava.model.testsuite.BaseModelTest
 import com.android.tools.metalava.model.testsuite.assertHasNonNullNullability
 import com.android.tools.metalava.model.testsuite.assertHasNullableNullability
@@ -303,7 +304,7 @@ class CommonFieldItemTest : BaseModelTest() {
                 // Compare the kotlin style format of the field to ensure that only the outermost
                 // type is affected by the not-type-use nullability annotation.
                 assertWithMessage(name)
-                    .that(field.type().toTypeString(kotlinStyleNulls = true))
+                    .that(field.type().testTypeString(kotlinStyleNulls = true))
                     .isEqualTo(expectedType)
             }
         }
@@ -364,7 +365,7 @@ class CommonFieldItemTest : BaseModelTest() {
                 // Compare the kotlin style format of the field to ensure that only the outermost
                 // type is affected by the not-type-use nullability annotation.
                 assertWithMessage(name)
-                    .that(field.type().toTypeString(kotlinStyleNulls = true))
+                    .that(field.type().testTypeString(kotlinStyleNulls = true))
                     .isEqualTo(expectedType)
             }
         }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonParameterItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonParameterItemTest.kt
index e9bf32d69..a7905a7f5 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonParameterItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/methoditem/CommonParameterItemTest.kt
@@ -18,6 +18,7 @@ package com.android.tools.metalava.model.testsuite.methoditem
 
 import com.android.tools.metalava.model.ItemLanguage
 import com.android.tools.metalava.model.provider.InputFormat
+import com.android.tools.metalava.model.testing.testTypeString
 import com.android.tools.metalava.model.testsuite.BaseModelTest
 import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
@@ -310,7 +311,7 @@ class CommonParameterItemTest : BaseModelTest() {
                 // outermost type is affected by the not-type-use nullability annotation.
                 val type = method.parameters().single().type()
                 assertWithMessage(name)
-                    .that(type.toTypeString(kotlinStyleNulls = true))
+                    .that(type.testTypeString(kotlinStyleNulls = true))
                     .isEqualTo(expectedType)
             }
         }
@@ -372,7 +373,7 @@ class CommonParameterItemTest : BaseModelTest() {
                 // outermost type is affected by the not-type-use nullability annotation.
                 val type = method.parameters().single().type()
                 assertWithMessage(name)
-                    .that(type.toTypeString(kotlinStyleNulls = true))
+                    .that(type.testTypeString(kotlinStyleNulls = true))
                     .isEqualTo(expectedType)
             }
         }
@@ -429,7 +430,7 @@ class CommonParameterItemTest : BaseModelTest() {
                 // outermost type is affected by the not-type-use nullability annotation.
                 val type = method.parameters().single().type()
                 assertWithMessage(name)
-                    .that(type.toTypeString(kotlinStyleNulls = true))
+                    .that(type.testTypeString(kotlinStyleNulls = true))
                     .isEqualTo(expectedType)
             }
         }
@@ -480,7 +481,7 @@ class CommonParameterItemTest : BaseModelTest() {
                 val type = parameterItem.type()
                 val expectedType = expectedTypes[name]!!
                 assertWithMessage("$name type")
-                    .that(type.toTypeString(kotlinStyleNulls = true))
+                    .that(type.testTypeString(kotlinStyleNulls = true))
                     .isEqualTo(expectedType)
             }
         }
@@ -517,7 +518,7 @@ class CommonParameterItemTest : BaseModelTest() {
                 val type = parameterItem.type()
                 val expectedType = expectedTypes[name]!!
                 assertWithMessage(name)
-                    .that(type.toTypeString(kotlinStyleNulls = true))
+                    .that(type.testTypeString(kotlinStyleNulls = true))
                     .isEqualTo(expectedType)
             }
         }
@@ -554,7 +555,7 @@ class CommonParameterItemTest : BaseModelTest() {
                 val type = parameterItem.type()
                 val expectedType = expectedTypes[name]!!
                 assertWithMessage("$name type")
-                    .that(type.toTypeString(kotlinStyleNulls = true))
+                    .that(type.testTypeString(kotlinStyleNulls = true))
                     .isEqualTo(expectedType)
             }
         }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/packageitem/CommonPackageItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/packageitem/CommonPackageItemTest.kt
index e66376283..b0444ec53 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/packageitem/CommonPackageItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/packageitem/CommonPackageItemTest.kt
@@ -17,6 +17,7 @@
 package com.android.tools.metalava.model.testsuite.packageitem
 
 import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.noOpAnnotationManager
 import com.android.tools.metalava.model.testsuite.BaseModelTest
 import com.android.tools.metalava.testing.KnownSourceFiles.nonNullSource
 import com.android.tools.metalava.testing.html
@@ -134,6 +135,12 @@ class CommonPackageItemTest : BaseModelTest() {
                         .trimIndent()
                 ),
             ),
+            testFixture =
+                TestFixture(
+                    // Use the noOpAnnotationManager to avoid annotation name normalizing as the
+                    // annotation names are important for this test.
+                    annotationManager = noOpAnnotationManager,
+                ),
         ) {
             val packageItem = codebase.assertPackage("test.pkg")
             assertEquals(
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/propertyitem/CommonPropertyItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/propertyitem/CommonPropertyItemTest.kt
index c38bf6d31..8a1be415d 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/propertyitem/CommonPropertyItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/propertyitem/CommonPropertyItemTest.kt
@@ -17,6 +17,7 @@
 package com.android.tools.metalava.model.testsuite.propertyitem
 
 import com.android.tools.metalava.model.PropertyItem
+import com.android.tools.metalava.model.testing.testTypeString
 import com.android.tools.metalava.model.testsuite.BaseModelTest
 import com.android.tools.metalava.testing.kotlin
 import com.google.common.truth.Truth.assertThat
@@ -87,7 +88,7 @@ class CommonPropertyItemTest : BaseModelTest() {
             ),
         ) {
             val barClass = codebase.assertClass("test.pkg.Bar")
-            val property = barClass.properties().single()
+            val property = barClass.assertProperty("foo")
             val methods = barClass.methods()
             val getter = methods.single { it.name() == "getFoo" }
             val setter = methods.single { it.name() == "setFoo" }
@@ -148,7 +149,7 @@ class CommonPropertyItemTest : BaseModelTest() {
             assertThat(fieldItem.name()).isEqualTo("delegatingList\$delegate")
             val fieldType = fieldItem.type()
             fieldType.assertClassTypeItem {
-                assertThat(toTypeString(kotlinStyleNulls = true))
+                assertThat(testTypeString(kotlinStyleNulls = true))
                     .isEqualTo(
                         "kotlin.reflect.KProperty0<? extends java.util.List<? extends java.lang.String?>>"
                     )
@@ -158,7 +159,7 @@ class CommonPropertyItemTest : BaseModelTest() {
             assertThat(propertyItem.name()).isEqualTo("delegatingList")
             val propertyType = propertyItem.type()
             propertyType.assertClassTypeItem {
-                assertThat(toTypeString(kotlinStyleNulls = true))
+                assertThat(testTypeString(kotlinStyleNulls = true))
                     .isEqualTo("java.util.List<java.lang.String?>")
             }
         }
@@ -182,7 +183,7 @@ class CommonPropertyItemTest : BaseModelTest() {
             assertThat(fieldItem.name()).isEqualTo("delegatingList\$delegate")
             val fieldType = fieldItem.type()
             fieldType.assertClassTypeItem {
-                assertThat(toTypeString(kotlinStyleNulls = true))
+                assertThat(testTypeString(kotlinStyleNulls = true))
                     .isEqualTo(
                         "kotlin.reflect.KProperty0<? extends kotlin.jvm.functions.Function2<? super java.lang.Integer,? super java.lang.String?,? extends java.lang.Boolean>>"
                     )
@@ -192,7 +193,7 @@ class CommonPropertyItemTest : BaseModelTest() {
             assertThat(propertyItem.name()).isEqualTo("delegatingList")
             val propertyType = propertyItem.type()
             propertyType.assertClassTypeItem {
-                assertThat(toTypeString(kotlinStyleNulls = true))
+                assertThat(testTypeString(kotlinStyleNulls = true))
                     .isEqualTo(
                         "kotlin.jvm.functions.Function2<java.lang.Integer,java.lang.String?,java.lang.Boolean>"
                     )
@@ -216,7 +217,7 @@ class CommonPropertyItemTest : BaseModelTest() {
             val fooClass = codebase.assertClass("test.pkg.Foo")
             val propertyType = fooClass.properties().single().type()
             propertyType.assertClassTypeItem {
-                assertThat(toTypeString(kotlinStyleNulls = true)).isEqualTo("java.lang.String")
+                assertThat(testTypeString(kotlinStyleNulls = true)).isEqualTo("java.lang.String")
             }
 
             val getter = fooClass.methods().single()
@@ -241,7 +242,7 @@ class CommonPropertyItemTest : BaseModelTest() {
             val fooClass = codebase.assertClass("test.pkg.Foo")
             val propertyType = fooClass.properties().single().type()
             propertyType.assertClassTypeItem {
-                assertThat(toTypeString(kotlinStyleNulls = true)).isEqualTo("java.lang.String?")
+                assertThat(testTypeString(kotlinStyleNulls = true)).isEqualTo("java.lang.String?")
             }
 
             val getter = fooClass.methods().single()
@@ -266,7 +267,7 @@ class CommonPropertyItemTest : BaseModelTest() {
             val fooClass = codebase.assertClass("test.pkg.Foo")
             val propertyType = fooClass.properties().single().type()
             propertyType.assertClassTypeItem {
-                assertThat(toTypeString(kotlinStyleNulls = true))
+                assertThat(testTypeString(kotlinStyleNulls = true))
                     .isEqualTo("java.util.List<java.lang.String>")
             }
 
@@ -292,7 +293,7 @@ class CommonPropertyItemTest : BaseModelTest() {
             val fooClass = codebase.assertClass("test.pkg.Foo")
             val propertyType = fooClass.properties().single().type()
             propertyType.assertClassTypeItem {
-                assertThat(toTypeString(kotlinStyleNulls = true))
+                assertThat(testTypeString(kotlinStyleNulls = true))
                     .isEqualTo("java.util.List<java.lang.String?>")
             }
 
@@ -319,7 +320,7 @@ class CommonPropertyItemTest : BaseModelTest() {
             val fooClass = codebase.assertClass("test.pkg.Foo")
             val propertyType = fooClass.properties().single().type()
             propertyType.assertClassTypeItem {
-                assertThat(toTypeString(kotlinStyleNulls = true)).isEqualTo("java.lang.String")
+                assertThat(testTypeString(kotlinStyleNulls = true)).isEqualTo("java.lang.String")
             }
 
             val methods =
@@ -352,7 +353,7 @@ class CommonPropertyItemTest : BaseModelTest() {
             val fooClass = codebase.assertClass("test.pkg.Foo")
             val propertyType = fooClass.properties().single().type()
             propertyType.assertClassTypeItem {
-                assertThat(toTypeString(kotlinStyleNulls = true)).isEqualTo("java.lang.String?")
+                assertThat(testTypeString(kotlinStyleNulls = true)).isEqualTo("java.lang.String?")
             }
 
             val methods =
@@ -385,7 +386,7 @@ class CommonPropertyItemTest : BaseModelTest() {
             val fooClass = codebase.assertClass("test.pkg.Foo")
             val propertyType = fooClass.properties().single().type()
             propertyType.assertClassTypeItem {
-                assertThat(toTypeString(kotlinStyleNulls = true))
+                assertThat(testTypeString(kotlinStyleNulls = true))
                     .isEqualTo("java.util.List<java.lang.String>")
             }
 
@@ -419,7 +420,7 @@ class CommonPropertyItemTest : BaseModelTest() {
             val fooClass = codebase.assertClass("test.pkg.Foo")
             val propertyType = fooClass.properties().single().type()
             propertyType.assertClassTypeItem {
-                assertThat(toTypeString(kotlinStyleNulls = true))
+                assertThat(testTypeString(kotlinStyleNulls = true))
                     .isEqualTo("java.util.List<java.lang.String?>")
             }
 
@@ -537,4 +538,42 @@ class CommonPropertyItemTest : BaseModelTest() {
                 )
         }
     }
+
+    @Test
+    fun `Test companion property`() {
+        runCodebaseTest(
+            kotlin(
+                """
+                    package test.pkg
+                    class Foo {
+                        companion object {
+                            val value: Int = 0
+                            const val constant: Int = 1
+                            @JvmField val jvmField: Int = 2
+                        }
+                    }
+                """
+            )
+        ) {
+            val foo = codebase.assertClass("test.pkg.Foo")
+            assertThat(foo.methods()).isEmpty()
+            assertThat(foo.properties()).isEmpty()
+            foo.assertField("constant")
+            foo.assertField("jvmField")
+
+            val fooCompanion = codebase.assertClass("test.pkg.Foo.Companion")
+            assertThat(fooCompanion.fields()).isEmpty()
+            assertThat(fooCompanion.methods()).hasSize(1)
+            val valueGetterOnCompanion = fooCompanion.assertMethod("getValue", "")
+
+            assertThat(fooCompanion.properties()).hasSize(3)
+            val constantPropertyOnCompanion = fooCompanion.assertProperty("constant")
+            val jvmPropertyOnCompanion = fooCompanion.assertProperty("jvmField")
+            val valuePropertyOnCompanion = fooCompanion.assertProperty("value")
+
+            assertThat(jvmPropertyOnCompanion.getter).isNull()
+            assertThat(constantPropertyOnCompanion.getter).isNull()
+            assertThat(valuePropertyOnCompanion.getter).isEqualTo(valueGetterOnCompanion)
+        }
+    }
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/sourcefile/CommonSourceFileTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/sourcefile/CommonSourceFileTest.kt
index b8913ff80..f75594e16 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/sourcefile/CommonSourceFileTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/sourcefile/CommonSourceFileTest.kt
@@ -16,22 +16,18 @@
 
 package com.android.tools.metalava.model.testsuite.sourcefile
 
+import com.android.tools.metalava.model.FilterPredicate
 import com.android.tools.metalava.model.Import
-import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.SelectableItem
 import com.android.tools.metalava.model.testsuite.BaseModelTest
 import com.android.tools.metalava.testing.java
-import java.util.function.Predicate
 import kotlin.test.assertEquals
 import org.junit.Test
 
 /** Common tests for implementations of [SourceFile]. */
 class CommonSourceFileTest : BaseModelTest() {
-    internal class AlwaysTrue : Predicate<Item> {
-        override fun test(item: Item): Boolean = true
-    }
-
-    internal class FilterHidden : Predicate<Item> {
-        override fun test(item: Item): Boolean = !item.isHiddenOrRemoved()
+    internal class FilterHidden : FilterPredicate {
+        override fun test(item: SelectableItem): Boolean = !item.isHiddenOrRemoved()
     }
 
     @Test
@@ -99,27 +95,74 @@ class CommonSourceFileTest : BaseModelTest() {
             )
         ) {
             val classItem = codebase.assertClass("test.pkg.Test")
-            val classItem1 = codebase.assertClass("test.Test")
-            val innerClassItem = codebase.assertClass("test.Test.Inner")
-            val pkgItem = codebase.assertPackage("test.pkg1")
-            val sourceFile = classItem.getSourceFile()!!
+            val sourceFile = classItem.sourceFile()!!
 
+            // Create the Import objects that are expected.
+            val classItem1 = codebase.assertClass("test.Test")
             val classImport = Import(classItem1)
+
+            val innerClassItem = codebase.assertClass("test.Test.Inner")
             val innerClassImport = Import(innerClassItem)
+
+            val pkgItem = codebase.assertPackage("test.pkg1")
             val packageImport = Import(pkgItem)
 
             // Only class imports that are referenced in documentation are included.
             // The wildcard imports are always included (except for empty packages and packages from
             // classpath).
             // Method and Field imports don't seem to resolve and are not included.
+            val allImports = sourceFile.getImports()
             assertEquals(
                 setOf(classImport, innerClassImport, packageImport),
-                sourceFile.getImports(AlwaysTrue()),
+                allImports,
                 message = "unfiltered imports"
             )
 
-            val imports = sourceFile.getImports(FilterHidden())
-            assertEquals(setOf(packageImport), imports, message = "filtered hidden")
+            val notHiddenImports = sourceFile.getImports(FilterHidden())
+            assertEquals(setOf(packageImport), notHiddenImports, message = "filtered hidden")
+        }
+    }
+
+    @Test
+    fun `test sourcefile imports from classpath`() {
+        runSourceCodebaseTest(
+            inputSet(
+                java(
+                    """
+                        package test.pkg;
+
+                        import java.util.List;
+                        import java.util.Set;
+
+                        /** {@link List} {@link Set}*/
+                        public class Foo {
+                            public static List<String> LIST_FIELD;
+                            public static Set<String> SET_FIELD;
+                        }
+                    """
+                ),
+            )
+        ) {
+            val classItem = codebase.assertClass("test.pkg.Foo")
+            val sourceFile = classItem.sourceFile()!!
+
+            // Get the imports before resolving java.util.Set to see how the getImports(...) methods
+            // behave with unresolved classes.
+            val allImports = sourceFile.getImports()
+
+            // Create the Import objects that are expected.
+            val listClassItem = codebase.assertResolvedClass("java.util.List")
+            val listClassImport = Import(listClassItem)
+
+            val setClassItem = codebase.assertResolvedClass("java.util.Set")
+            val setClassImport = Import(setClassItem)
+
+            // Makes sure that classes from the classpath are included in the imports.
+            assertEquals(
+                setOf(listClassImport, setClassImport),
+                allImports,
+                message = "unfiltered imports"
+            )
         }
     }
 
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonLambdaTypeItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonLambdaTypeItemTest.kt
index 8add34e32..1f3047410 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonLambdaTypeItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonLambdaTypeItemTest.kt
@@ -16,6 +16,7 @@
 
 package com.android.tools.metalava.model.testsuite.typeitem
 
+import com.android.tools.metalava.model.testing.testTypeString
 import com.android.tools.metalava.model.testsuite.BaseModelTest
 import com.android.tools.metalava.testing.kotlin
 import com.google.common.truth.Truth.assertThat
@@ -312,16 +313,18 @@ class CommonLambdaTypeItemTest : BaseModelTest() {
             lambdaType.assertLambdaTypeItem {
                 // Verify that the default string representation of the lambda type is the same as
                 // the string representation of the extended class type.
-                assertThat(toTypeString(kotlinStyleNulls = true))
+                assertThat(testTypeString(kotlinStyleNulls = true))
                     .isEqualTo(
                         "kotlin.jvm.functions.Function2<java.lang.Integer,kotlin.coroutines.Continuation<? super java.lang.String?>,java.lang.Object?>"
                     )
 
                 assertThat(isSuspend).isTrue()
                 assertThat(receiverType).isNull()
-                assertThat(parameterTypes.joinToString { it.toTypeString(kotlinStyleNulls = true) })
+                assertThat(
+                        parameterTypes.joinToString { it.testTypeString(kotlinStyleNulls = true) }
+                    )
                     .isEqualTo("int, kotlin.coroutines.Continuation<? super java.lang.String?>")
-                assertThat(returnType.toTypeString(kotlinStyleNulls = true))
+                assertThat(returnType.testTypeString(kotlinStyleNulls = true))
                     .isEqualTo("java.lang.Object?")
             }
         }
@@ -345,16 +348,18 @@ class CommonLambdaTypeItemTest : BaseModelTest() {
             lambdaType.assertLambdaTypeItem {
                 // Verify that the default string representation of the lambda type is the same as
                 // the string representation of the extended class type.
-                assertThat(toTypeString(kotlinStyleNulls = true))
+                assertThat(testTypeString(kotlinStyleNulls = true))
                     .isEqualTo(
                         "kotlin.jvm.functions.Function3<java.lang.Number,java.lang.Integer,kotlin.coroutines.Continuation<? super java.lang.String?>,java.lang.Object?>"
                     )
 
                 assertThat(isSuspend).isTrue()
                 assertThat(receiverType.toString()).isEqualTo("java.lang.Number")
-                assertThat(parameterTypes.joinToString { it.toTypeString(kotlinStyleNulls = true) })
+                assertThat(
+                        parameterTypes.joinToString { it.testTypeString(kotlinStyleNulls = true) }
+                    )
                     .isEqualTo("int, kotlin.coroutines.Continuation<? super java.lang.String?>")
-                assertThat(returnType.toTypeString(kotlinStyleNulls = true))
+                assertThat(returnType.testTypeString(kotlinStyleNulls = true))
                     .isEqualTo("java.lang.Object?")
             }
         }
@@ -378,16 +383,18 @@ class CommonLambdaTypeItemTest : BaseModelTest() {
             lambdaType.assertLambdaTypeItem {
                 // Verify that the default string representation of the lambda type is the same as
                 // the string representation of the extended class type.
-                assertThat(toTypeString(kotlinStyleNulls = true))
+                assertThat(testTypeString(kotlinStyleNulls = true))
                     .isEqualTo(
                         "kotlin.jvm.functions.Function3<java.lang.Number,java.lang.Integer,kotlin.coroutines.Continuation<? super kotlin.Unit>,java.lang.Object?>"
                     )
 
                 assertThat(isSuspend).isTrue()
                 assertThat(receiverType.toString()).isEqualTo("java.lang.Number")
-                assertThat(parameterTypes.joinToString { it.toTypeString(kotlinStyleNulls = true) })
+                assertThat(
+                        parameterTypes.joinToString { it.testTypeString(kotlinStyleNulls = true) }
+                    )
                     .isEqualTo("int, kotlin.coroutines.Continuation<? super kotlin.Unit>")
-                assertThat(returnType.toTypeString(kotlinStyleNulls = true))
+                assertThat(returnType.testTypeString(kotlinStyleNulls = true))
                     .isEqualTo("java.lang.Object?")
             }
         }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeItemTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeItemTest.kt
index fd0a87e92..2e99c6541 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeItemTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeItemTest.kt
@@ -28,6 +28,7 @@ import com.android.tools.metalava.model.TypeModifiers
 import com.android.tools.metalava.model.VariableTypeItem
 import com.android.tools.metalava.model.WildcardTypeItem
 import com.android.tools.metalava.model.provider.InputFormat
+import com.android.tools.metalava.model.testing.testTypeString
 import com.android.tools.metalava.model.testsuite.BaseModelTest
 import com.android.tools.metalava.testing.KnownSourceFiles
 import com.android.tools.metalava.testing.java
@@ -1569,7 +1570,7 @@ class CommonTypeItemTest : BaseModelTest() {
                     val typeToTest = method.returnType()
 
                     fun TypeItem.typeInfo() =
-                        toTypeString(
+                        testTypeString(
                             annotations = true,
                             kotlinStyleNulls = true,
                         )
@@ -1742,7 +1743,7 @@ class CommonTypeItemTest : BaseModelTest() {
                     val typeToTest = method.returnType()
 
                     fun TypeItem.typeInfo() =
-                        toTypeString(
+                        testTypeString(
                             annotations = true,
                             kotlinStyleNulls = true,
                         )
@@ -1853,4 +1854,115 @@ class CommonTypeItemTest : BaseModelTest() {
             assertThat(interfaceType.hasTypeArguments()).isTrue()
         }
     }
+
+    @Test
+    fun `Test toSimpleType on varargs parameter`() {
+        runCodebaseTest(
+            java(
+                """
+                    package test.pkg;
+                    public interface Foo {
+                        void foo(String...p);
+                    }
+                """
+            ),
+            kotlin(
+                """
+                    package test.pkg
+                    interface Foo {
+                        fun foo(vararg p: String)
+                    }
+                """
+            ),
+            signature(
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public interface Foo {
+                        method public void foo(String...);
+                      }
+                    }
+                """
+            ),
+        ) {
+            val varargsType =
+                codebase.assertClass("test.pkg.Foo").methods().single().parameters().single().type()
+            assertThat(varargsType.toSimpleType()).isEqualTo("java.lang.String...")
+        }
+    }
+
+    @Test
+    fun `Test toSimpleType on varargs generic parameter`() {
+        runCodebaseTest(
+            java(
+                @Suppress("unchecked")
+                """
+                    package test.pkg;
+                    public interface Foo {
+                        void foo(Comparable<? super String>...p);
+                    }
+                """
+            ),
+            kotlin(
+                """
+                    package test.pkg
+                    interface Foo {
+                        fun foo(vararg p: Comparable<String>)
+                    }
+                """
+            ),
+            signature(
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public interface Foo {
+                        method public void foo(Comparable<? super String>...);
+                      }
+                    }
+                """
+            ),
+        ) {
+            val varargsType =
+                codebase.assertClass("test.pkg.Foo").methods().single().parameters().single().type()
+            assertThat(varargsType.toSimpleType())
+                .isEqualTo("Comparable<? super java.lang.String>...")
+        }
+    }
+
+    @Test
+    fun `Test toSimpleType on nested class`() {
+        runCodebaseTest(
+            java(
+                """
+                    package test.pkg;
+                    public interface Foo {
+                        void foo(Thread.UncaughtExceptionHandler p);
+                    }
+                """
+            ),
+            kotlin(
+                """
+                    package test.pkg
+                    interface Foo {
+                        fun foo(p: Thread.UncaughtExceptionHandler)
+                    }
+                """
+            ),
+            signature(
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public interface Foo {
+                        method public void foo(Thread.UncaughtExceptionHandler);
+                      }
+                    }
+                """
+            ),
+        ) {
+            val varargsType =
+                codebase.assertClass("test.pkg.Foo").methods().single().parameters().single().type()
+            assertThat(varargsType.toSimpleType())
+                .isEqualTo("java.lang.Thread.UncaughtExceptionHandler")
+        }
+    }
 }
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeModifiersTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeModifiersTest.kt
index b27b59976..a731431fd 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeModifiersTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeModifiersTest.kt
@@ -22,6 +22,7 @@ import com.android.tools.metalava.model.TypeModifiers
 import com.android.tools.metalava.model.TypeNullability.NONNULL
 import com.android.tools.metalava.model.TypeNullability.PLATFORM
 import com.android.tools.metalava.model.isNullnessAnnotation
+import com.android.tools.metalava.model.noOpAnnotationManager
 import com.android.tools.metalava.model.provider.InputFormat
 import com.android.tools.metalava.model.testsuite.BaseModelTest
 import com.android.tools.metalava.model.testsuite.assertHasNonNullNullability
@@ -75,8 +76,13 @@ class CommonTypeModifiersTest : BaseModelTest() {
                       }
                     }
                 """
-                    .trimIndent()
-            )
+            ),
+            testFixture =
+                TestFixture(
+                    // Use the noOpAnnotationManager to avoid annotation name normalizing as the
+                    // annotation names are important for this test.
+                    annotationManager = noOpAnnotationManager,
+                ),
         ) {
             val methods = codebase.assertClass("test.pkg.Foo").methods()
             assertThat(methods).hasSize(3)
@@ -203,7 +209,13 @@ class CommonTypeModifiersTest : BaseModelTest() {
                     @Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE)
                     annotation class A
                 """
-            )
+            ),
+            testFixture =
+                TestFixture(
+                    // Use the noOpAnnotationManager to avoid annotation name normalizing as the
+                    // annotation names are important for this test.
+                    annotationManager = noOpAnnotationManager,
+                ),
         ) {
             val methods = codebase.assertClass("test.pkg.Foo").methods()
             assertThat(methods).hasSize(3)
diff --git a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeStringTest.kt b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeStringTest.kt
index b5ce840e3..0a702dfae 100644
--- a/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeStringTest.kt
+++ b/metalava-model-testsuite/src/main/java/com/android/tools/metalava/model/testsuite/typeitem/CommonTypeStringTest.kt
@@ -18,9 +18,13 @@ package com.android.tools.metalava.model.testsuite.typeitem
 
 import com.android.tools.lint.checks.infrastructure.TestFile
 import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.FilterPredicate
 import com.android.tools.metalava.model.PrimitiveTypeItem
+import com.android.tools.metalava.model.StripJavaLangPrefix
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.TypeStringConfiguration
 import com.android.tools.metalava.model.isNullnessAnnotation
+import com.android.tools.metalava.model.noOpAnnotationManager
 import com.android.tools.metalava.model.testsuite.BaseModelTest
 import com.android.tools.metalava.model.typeUseAnnotationFilter
 import com.android.tools.metalava.testing.KnownSourceFiles.intRangeTypeUseSource
@@ -28,21 +32,25 @@ import com.android.tools.metalava.testing.KnownSourceFiles.libcoreNonNullSource
 import com.android.tools.metalava.testing.KnownSourceFiles.libcoreNullableSource
 import com.android.tools.metalava.testing.java
 import com.google.common.truth.Truth.assertThat
-import java.util.function.Predicate
 import org.junit.Test
 import org.junit.runners.Parameterized
 import org.junit.runners.Parameterized.Parameter
 
+typealias MethodToTest = TypeItem.(TypeStringConfiguration) -> String
+
 class CommonTypeStringTest : BaseModelTest() {
 
     data class TypeStringParameters(
         val name: String,
+        val methodToTest: MethodToTest = TO_TYPE_STRING_METHOD,
         val sourceType: String = name,
         val typeStringConfiguration: TypeStringConfiguration = TypeStringConfiguration(),
+        val filter: FilterPredicate? = null,
         val expectedTypeString: String = sourceType,
         val typeParameters: String? = null,
         val extraJavaSourceFiles: List<TestFile> = emptyList(),
-        val extraTextPackages: List<String> = emptyList()
+        val extraImports: String = "",
+        val extraTextPackages: List<String> = emptyList(),
     ) {
         override fun toString(): String {
             return name
@@ -86,17 +94,21 @@ class CommonTypeStringTest : BaseModelTest() {
                 configs: List<ConfigurationTestCase>,
                 typeParameters: String? = null,
                 extraJavaSourceFiles: List<TestFile> = emptyList(),
-                extraTextPackages: List<String> = emptyList()
+                extraImports: String = "",
+                extraTextPackages: List<String> = emptyList(),
             ): List<TypeStringParameters> {
                 return configs.map {
                     TypeStringParameters(
                         name = "$name - ${it.name}",
+                        methodToTest = it.methodToTest ?: TO_TYPE_STRING_METHOD,
                         sourceType = sourceType,
                         typeStringConfiguration = it.configuration,
+                        filter = it.filter,
                         expectedTypeString = it.expectedTypeString,
                         typeParameters = typeParameters,
                         extraJavaSourceFiles = extraJavaSourceFiles,
-                        extraTextPackages = extraTextPackages
+                        extraTextPackages = extraTextPackages,
+                        extraImports = extraImports,
                     )
                 }
             }
@@ -105,15 +117,10 @@ class CommonTypeStringTest : BaseModelTest() {
 
     data class ConfigurationTestCase(
         val name: String,
-        val configuration: TypeStringConfiguration,
-        val expectedTypeString: String
-    )
-
-    data class TypeStringConfiguration(
-        val annotations: Boolean = false,
-        val kotlinStyleNulls: Boolean = false,
-        val filter: Predicate<Item>? = null,
-        val spaceBetweenParameters: Boolean = false,
+        val methodToTest: MethodToTest? = null,
+        val configuration: TypeStringConfiguration = TypeStringConfiguration.DEFAULT,
+        val filter: FilterPredicate? = null,
+        val expectedTypeString: String,
     )
 
     /**
@@ -131,6 +138,7 @@ class CommonTypeStringTest : BaseModelTest() {
             java(
                 """
                 package test.pkg;
+                ${parameters.extraImports}
                 public class Foo {
                     public ${parameters.typeParameters.orEmpty()} void foo(${parameters.sourceType} arg) {}
                 }
@@ -160,22 +168,25 @@ class CommonTypeStringTest : BaseModelTest() {
 
     @Test
     fun `Type string`() {
-        runCodebaseTest(javaTestFiles(), signatureTestFile()) {
+        runCodebaseTest(
+            javaTestFiles(),
+            signatureTestFile(),
+            testFixture =
+                TestFixture(
+                    // Use the noOpAnnotationManager to avoid annotation name normalizing as the
+                    // annotation names are important for this test.
+                    annotationManager = noOpAnnotationManager,
+                ),
+        ) {
             val method = codebase.assertClass("test.pkg.Foo").methods().single()
             val param = method.parameters().single()
             val type =
                 param.type().let { unfilteredType ->
-                    val filter =
-                        parameters.typeStringConfiguration.filter ?: return@let unfilteredType
+                    val filter = parameters.filter ?: return@let unfilteredType
                     unfilteredType.transform(typeUseAnnotationFilter(filter))
                 }
-            val typeString =
-                type.toTypeString(
-                    annotations = parameters.typeStringConfiguration.annotations,
-                    kotlinStyleNulls = parameters.typeStringConfiguration.kotlinStyleNulls,
-                    spaceBetweenParameters =
-                        parameters.typeStringConfiguration.spaceBetweenParameters,
-                )
+            val methodToTest = parameters.methodToTest
+            val typeString = type.methodToTest(parameters.typeStringConfiguration)
             assertThat(typeString).isEqualTo(parameters.expectedTypeString)
         }
     }
@@ -212,6 +223,27 @@ class CommonTypeStringTest : BaseModelTest() {
                 }
             """
 
+        /**
+         * [MethodToTest] that calls [TypeItem.toTypeString] with a [TypeStringConfiguration] that
+         * is supplied.
+         */
+        private val TO_TYPE_STRING_METHOD: MethodToTest = { configuration ->
+            toTypeString(configuration)
+        }
+
+        /**
+         * [MethodToTest] that call [TypeItem.toCanonicalType].
+         *
+         * [TypeItem.toCanonicalType] does not take a [TypeStringConfiguration] so this makes sure
+         * that a test just provides the default configuration to avoid confusion.
+         */
+        private val TO_CANONICAL_TYPE: MethodToTest = { configuration ->
+            require(configuration.isDefault) {
+                "toCanonicalType does not use configuration so expects the default but found $configuration"
+            }
+            toCanonicalType()
+        }
+
         @JvmStatic @Parameterized.Parameters fun testCases() = testCases
 
         private val testCases =
@@ -441,6 +473,24 @@ class CommonTypeStringTest : BaseModelTest() {
                                     ),
                                 expectedTypeString = "java.lang.String?..."
                             ),
+                            ConfigurationTestCase(
+                                name = "treatVarargsAsArray",
+                                configuration =
+                                    TypeStringConfiguration(
+                                        treatVarargsAsArray = true,
+                                    ),
+                                expectedTypeString = "java.lang.String[]"
+                            ),
+                            ConfigurationTestCase(
+                                name = "treatVarargsAsArray and annotated",
+                                configuration =
+                                    TypeStringConfiguration(
+                                        annotations = true,
+                                        treatVarargsAsArray = true
+                                    ),
+                                expectedTypeString =
+                                    "java.lang.@libcore.util.Nullable String @libcore.util.NonNull []"
+                            ),
                         ),
                     extraJavaSourceFiles = listOf(libcoreNonNullSource, libcoreNullableSource),
                     extraTextPackages = listOf(libcoreTextPackage)
@@ -474,11 +524,58 @@ class CommonTypeStringTest : BaseModelTest() {
                                     ),
                                 expectedTypeString = "T"
                             ),
+                            ConfigurationTestCase(
+                                name = "toCanonicalType",
+                                methodToTest = TO_CANONICAL_TYPE,
+                                expectedTypeString = "T",
+                            ),
+                            ConfigurationTestCase(
+                                name = "eraseGenerics=true",
+                                configuration =
+                                    TypeStringConfiguration(
+                                        eraseGenerics = true,
+                                    ),
+                                expectedTypeString = "java.lang.Object",
+                            ),
+                            ConfigurationTestCase(
+                                name = "eraseGenerics=true and stripJavaLangPrefix=ALWAYS",
+                                configuration =
+                                    TypeStringConfiguration(
+                                        eraseGenerics = true,
+                                        stripJavaLangPrefix = StripJavaLangPrefix.ALWAYS,
+                                    ),
+                                expectedTypeString = "Object",
+                            ),
                         ),
                     typeParameters = "<T>",
                     extraJavaSourceFiles = listOf(libcoreNonNullSource),
                     extraTextPackages = listOf(libcoreTextPackage)
                 ) +
+                TypeStringParameters.fromConfigurations(
+                    name = "null annotated T",
+                    sourceType = "@libcore.util.NonNull T",
+                    configs =
+                        listOf(
+                            ConfigurationTestCase(
+                                name = "eraseGenerics=true",
+                                configuration =
+                                    TypeStringConfiguration(
+                                        eraseGenerics = true,
+                                    ),
+                                expectedTypeString = "java.lang.String",
+                            ),
+                            ConfigurationTestCase(
+                                name = "eraseGenerics=true and stripJavaLangPrefix=ALWAYS",
+                                configuration =
+                                    TypeStringConfiguration(
+                                        eraseGenerics = true,
+                                        stripJavaLangPrefix = StripJavaLangPrefix.ALWAYS,
+                                    ),
+                                expectedTypeString = "String",
+                            ),
+                        ),
+                    typeParameters = "<T extends java.lang.String>",
+                ) +
                 TypeStringParameters(
                     name = "super T comparable",
                     sourceType = "java.lang.Comparable<? super T>",
@@ -579,8 +676,8 @@ class CommonTypeStringTest : BaseModelTest() {
                                 configuration =
                                     TypeStringConfiguration(
                                         annotations = true,
-                                        filter = { false },
                                     ),
+                                filter = { false },
                                 expectedTypeString = "java.util.List<java.lang.Integer>"
                             ),
                             ConfigurationTestCase(
@@ -588,9 +685,9 @@ class CommonTypeStringTest : BaseModelTest() {
                                 configuration =
                                     TypeStringConfiguration(
                                         annotations = true,
-                                        filter = { false },
                                         kotlinStyleNulls = true
                                     ),
+                                filter = { false },
                                 expectedTypeString = "java.util.List<java.lang.Integer!>!"
                             ),
                             ConfigurationTestCase(
@@ -598,8 +695,8 @@ class CommonTypeStringTest : BaseModelTest() {
                                 configuration =
                                     TypeStringConfiguration(
                                         annotations = true,
-                                        filter = { true },
                                     ),
+                                filter = { true },
                                 expectedTypeString =
                                     "java.util.List<java.lang.@androidx.annotation.IntRange(from=5L, to=10L) Integer>"
                             )
@@ -662,7 +759,24 @@ class CommonTypeStringTest : BaseModelTest() {
                                 configuration = TypeStringConfiguration(kotlinStyleNulls = true),
                                 expectedTypeString =
                                     "test.pkg.Outer<java.lang.String?>.Inner<java.lang.Integer>?"
-                            )
+                            ),
+                            ConfigurationTestCase(
+                                name = "eraseGenerics",
+                                configuration =
+                                    TypeStringConfiguration(
+                                        eraseGenerics = true,
+                                    ),
+                                expectedTypeString = "test.pkg.Outer.Inner",
+                            ),
+                            ConfigurationTestCase(
+                                name = "nestedClassSeparator",
+                                configuration =
+                                    TypeStringConfiguration(
+                                        nestedClassSeparator = '@',
+                                    ),
+                                expectedTypeString =
+                                    "test.pkg.Outer<java.lang.String>@Inner<java.lang.Integer>",
+                            ),
                         ),
                     extraJavaSourceFiles =
                         listOf(
@@ -708,13 +822,13 @@ class CommonTypeStringTest : BaseModelTest() {
                             configuration =
                                 TypeStringConfiguration(
                                     annotations = true,
-                                    // Filter that removes nullness annotations
-                                    filter = {
-                                        (it as? ClassItem)?.qualifiedName()?.let { name ->
-                                            isNullnessAnnotation(name)
-                                        } != true
-                                    }
                                 ),
+                            // Filter that removes nullness annotations
+                            filter = {
+                                (it as? ClassItem)?.qualifiedName()?.let { name ->
+                                    isNullnessAnnotation(name)
+                                } != true
+                            },
                             expectedTypeString =
                                 "java.util.List<java.lang.@androidx.annotation.IntRange(from=5L, to=10L) Integer>"
                         ),
@@ -724,14 +838,14 @@ class CommonTypeStringTest : BaseModelTest() {
                                 TypeStringConfiguration(
                                     annotations = true,
                                     kotlinStyleNulls = true,
-                                    // Filter that removes nullness annotations, but Kotlin-nulls
-                                    // should still be present
-                                    filter = {
-                                        (it as? ClassItem)?.qualifiedName()?.let { name ->
-                                            isNullnessAnnotation(name)
-                                        } != true
-                                    }
                                 ),
+                            // Filter that removes nullness annotations, but Kotlin-nulls
+                            // should still be present
+                            filter = {
+                                (it as? ClassItem)?.qualifiedName()?.let { name ->
+                                    isNullnessAnnotation(name)
+                                } != true
+                            },
                             expectedTypeString =
                                 "java.util.List<java.lang.@androidx.annotation.IntRange(from=5L, to=10L) Integer?>!"
                         ),
@@ -827,6 +941,187 @@ class CommonTypeStringTest : BaseModelTest() {
                         ),
                     extraJavaSourceFiles = listOf(libcoreNullableSource),
                     extraTextPackages = listOf(libcoreTextPackage)
+                ) +
+                TypeStringParameters.fromConfigurations(
+                    name = "java.lang. prefix stripping",
+                    sourceType =
+                        "@libcore.util.Nullable Comparable<java.util.Map<@libcore.util.Nullable String,java.lang.annotation.Annotation>>",
+                    configs =
+                        listOf(
+                            ConfigurationTestCase(
+                                name = "default",
+                                configuration = TypeStringConfiguration(),
+                                expectedTypeString =
+                                    "java.lang.Comparable<java.util.Map<java.lang.String,java.lang.annotation.Annotation>>",
+                            ),
+                            ConfigurationTestCase(
+                                name = "strip legacy",
+                                configuration =
+                                    TypeStringConfiguration(
+                                        stripJavaLangPrefix = StripJavaLangPrefix.LEGACY,
+                                    ),
+                                expectedTypeString =
+                                    "Comparable<java.util.Map<java.lang.String,java.lang.annotation.Annotation>>",
+                            ),
+                            ConfigurationTestCase(
+                                name = "strip always",
+                                configuration =
+                                    TypeStringConfiguration(
+                                        stripJavaLangPrefix = StripJavaLangPrefix.ALWAYS,
+                                    ),
+                                expectedTypeString =
+                                    "Comparable<java.util.Map<String,java.lang.annotation.Annotation>>",
+                            ),
+                            ConfigurationTestCase(
+                                name = "strip always plus annotations",
+                                configuration =
+                                    TypeStringConfiguration(
+                                        annotations = true,
+                                        stripJavaLangPrefix = StripJavaLangPrefix.ALWAYS,
+                                    ),
+                                expectedTypeString =
+                                    "@libcore.util.Nullable Comparable<java.util.Map<@libcore.util.Nullable String,java.lang.annotation.Annotation>>",
+                            ),
+                            ConfigurationTestCase(
+                                name = "toCanonicalType",
+                                methodToTest = TO_CANONICAL_TYPE,
+                                expectedTypeString =
+                                    "Comparable<java.util.Map<String,java.lang.annotation.Annotation>>",
+                            ),
+                        ),
+                    extraJavaSourceFiles = listOf(libcoreNullableSource),
+                    extraTextPackages = listOf(libcoreTextPackage)
+                ) +
+                TypeStringParameters.fromConfigurations(
+                    name = "java.lang. prefix stripping varargs",
+                    sourceType = "java.lang.@IntRange(from=5L, to=10L) String...",
+                    extraJavaSourceFiles = listOf(intRangeTypeUseSource),
+                    extraImports = "import androidx.annotation.IntRange;",
+                    extraTextPackages = listOf(androidxTextPackage),
+                    configs =
+                        listOf(
+                            ConfigurationTestCase(
+                                name = "default",
+                                configuration = TypeStringConfiguration(),
+                                expectedTypeString = "java.lang.String...",
+                            ),
+                            ConfigurationTestCase(
+                                name = "default plus annotations",
+                                configuration =
+                                    TypeStringConfiguration(
+                                        annotations = true,
+                                    ),
+                                expectedTypeString =
+                                    "java.lang.@androidx.annotation.IntRange(from=5L, to=10L) String...",
+                            ),
+                            ConfigurationTestCase(
+                                name = "legacy",
+                                configuration =
+                                    TypeStringConfiguration(
+                                        stripJavaLangPrefix = StripJavaLangPrefix.LEGACY,
+                                    ),
+                                expectedTypeString = "java.lang.String...",
+                            ),
+                            ConfigurationTestCase(
+                                name = "legacy plus annotations",
+                                configuration =
+                                    TypeStringConfiguration(
+                                        annotations = true,
+                                        stripJavaLangPrefix = StripJavaLangPrefix.LEGACY,
+                                    ),
+                                expectedTypeString =
+                                    "java.lang.@androidx.annotation.IntRange(from=5L, to=10L) String...",
+                            ),
+                            ConfigurationTestCase(
+                                name = "always",
+                                configuration =
+                                    TypeStringConfiguration(
+                                        stripJavaLangPrefix = StripJavaLangPrefix.ALWAYS,
+                                    ),
+                                expectedTypeString = "String...",
+                            ),
+                            ConfigurationTestCase(
+                                name = "always plus annotations",
+                                configuration =
+                                    TypeStringConfiguration(
+                                        annotations = true,
+                                        stripJavaLangPrefix = StripJavaLangPrefix.ALWAYS,
+                                    ),
+                                expectedTypeString =
+                                    "@androidx.annotation.IntRange(from=5L, to=10L) String...",
+                            ),
+                            ConfigurationTestCase(
+                                name = "toCanonicalType",
+                                methodToTest = TO_CANONICAL_TYPE,
+                                expectedTypeString = "String[]",
+                            ),
+                        ),
+                ) +
+                TypeStringParameters.fromConfigurations(
+                    name = "java.lang. prefix stripping varargs generic",
+                    sourceType = "java.lang.Comparable<String>...",
+                    configs =
+                        listOf(
+                            ConfigurationTestCase(
+                                name = "default",
+                                configuration = TypeStringConfiguration(),
+                                expectedTypeString = "java.lang.Comparable<java.lang.String>...",
+                            ),
+                            ConfigurationTestCase(
+                                name = "legacy",
+                                configuration =
+                                    TypeStringConfiguration(
+                                        stripJavaLangPrefix = StripJavaLangPrefix.LEGACY,
+                                    ),
+                                expectedTypeString = "Comparable<java.lang.String>...",
+                            ),
+                            ConfigurationTestCase(
+                                name = "always",
+                                configuration =
+                                    TypeStringConfiguration(
+                                        stripJavaLangPrefix = StripJavaLangPrefix.ALWAYS,
+                                    ),
+                                expectedTypeString = "Comparable<String>...",
+                            ),
+                            ConfigurationTestCase(
+                                name = "toCanonicalType",
+                                methodToTest = TO_CANONICAL_TYPE,
+                                expectedTypeString = "Comparable<String>[]",
+                            ),
+                        ),
+                ) +
+                TypeStringParameters.fromConfigurations(
+                    name = "java.lang. prefix stripping nested class",
+                    sourceType = "java.lang.Thread.UncaughtExceptionHandler",
+                    configs =
+                        listOf(
+                            ConfigurationTestCase(
+                                name = "default",
+                                configuration = TypeStringConfiguration(),
+                                expectedTypeString = "java.lang.Thread.UncaughtExceptionHandler",
+                            ),
+                            ConfigurationTestCase(
+                                name = "legacy",
+                                configuration =
+                                    TypeStringConfiguration(
+                                        stripJavaLangPrefix = StripJavaLangPrefix.LEGACY,
+                                    ),
+                                expectedTypeString = "java.lang.Thread.UncaughtExceptionHandler",
+                            ),
+                            ConfigurationTestCase(
+                                name = "always",
+                                configuration =
+                                    TypeStringConfiguration(
+                                        stripJavaLangPrefix = StripJavaLangPrefix.ALWAYS,
+                                    ),
+                                expectedTypeString = "Thread.UncaughtExceptionHandler",
+                            ),
+                            ConfigurationTestCase(
+                                name = "toCanonicalType",
+                                methodToTest = TO_CANONICAL_TYPE,
+                                expectedTypeString = "Thread.UncaughtExceptionHandler",
+                            ),
+                        ),
                 )
     }
 }
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ApiFile.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ApiFile.kt
index 34282d5ea..8b689032d 100644
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ApiFile.kt
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/ApiFile.kt
@@ -19,7 +19,6 @@ import com.android.tools.metalava.model.ANDROIDX_NONNULL
 import com.android.tools.metalava.model.ANDROIDX_NULLABLE
 import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.AnnotationItem.Companion.unshortenAnnotation
-import com.android.tools.metalava.model.AnnotationManager
 import com.android.tools.metalava.model.ArrayTypeItem
 import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
@@ -43,12 +42,16 @@ import com.android.tools.metalava.model.MutableModifierList
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.PrimitiveTypeItem
 import com.android.tools.metalava.model.PrimitiveTypeItem.Primitive
+import com.android.tools.metalava.model.SelectableItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeNullability
 import com.android.tools.metalava.model.TypeParameterItem
 import com.android.tools.metalava.model.TypeParameterList
 import com.android.tools.metalava.model.TypeParameterListAndFactory
 import com.android.tools.metalava.model.VisibilityLevel
+import com.android.tools.metalava.model.api.surface.ApiSurfaces
+import com.android.tools.metalava.model.api.surface.ApiVariant
+import com.android.tools.metalava.model.api.surface.ApiVariantType
 import com.android.tools.metalava.model.createImmutableModifiers
 import com.android.tools.metalava.model.createMutableModifiers
 import com.android.tools.metalava.model.item.DefaultClassItem
@@ -59,7 +62,6 @@ import com.android.tools.metalava.model.item.DefaultValue
 import com.android.tools.metalava.model.item.MutablePackageDoc
 import com.android.tools.metalava.model.item.PackageDocs
 import com.android.tools.metalava.model.javaUnescapeString
-import com.android.tools.metalava.model.noOpAnnotationManager
 import com.android.tools.metalava.model.type.MethodFingerprint
 import com.android.tools.metalava.reporter.FileLocation
 import java.io.File
@@ -71,28 +73,122 @@ import java.util.IdentityHashMap
 import kotlin.text.Charsets.UTF_8
 
 /** Encapsulates information needed to process a signature file. */
-data class SignatureFile(
+sealed class SignatureFile {
     /** The underlying signature [File]. */
-    val file: File,
+    abstract val file: File
 
     /**
-     * Indicates whether [file] is for the current API surface, i.e. the one that is being created.
+     * Indicates whether [file] is for the main API surface, i.e. the one that is being created.
      *
      * This will be stored in [Item.emit].
      */
-    val forCurrentApiSurface: Boolean = true,
-) {
-    companion object {
-        /** Create a [SignatureFile] from a [File]. */
-        fun fromFile(file: File) = SignatureFile(file)
+    protected open val forMainApiSurface: Boolean
+        get() = true
+
+    /** The [ApiVariantType] of the signature files. */
+    protected open val apiVariantType: ApiVariantType
+        get() = ApiVariantType.CORE
+
+    /**
+     * Get the [ApiVariant] that this signature file represents.
+     *
+     * If [forMainApiSurface] is `false` then [apiSurfaces] must provide a non-null value for
+     * [ApiSurfaces.base]. An exception will be thrown if it is not.
+     *
+     * @param apiSurfaces the [ApiSurfaces] the returned [Codebase] is required to support.
+     */
+    fun apiVariantFor(apiSurfaces: ApiSurfaces): ApiVariant {
+        val apiSurface =
+            if (forMainApiSurface) apiSurfaces.main
+            else
+                apiSurfaces.base
+                    ?: error("$file expects a base API surface to be available but it is not")
+        return apiSurface.variantFor(apiVariantType)
+    }
 
-        /** Create a list of [SignatureFile]s from a list of [File]s. */
-        fun fromFiles(files: List<File>): List<SignatureFile> =
+    /** Read the contents of this signature file. */
+    abstract fun readContents(): String
+
+    companion object {
+        /** Create a list of [SignatureFile]s from a varargs array of [File]s. */
+        fun fromFiles(vararg files: File): List<SignatureFile> =
             files.map {
-                SignatureFile(
+                SignatureFileFromFile(
                     it,
                 )
             }
+
+        /**
+         * Create a list of [SignatureFile]s from a list of [File]s.
+         *
+         * @param files the list of [File]s.
+         * @param apiVariantTypeChooser A lambda that will be called with the [File] of each item in
+         *   [files] and whose return value will be stored in [SignatureFile.apiVariantType].
+         * @param forMainApiSurfacePredicate A predicate that will be called with the index and
+         *   [File] of each item in [files] and whose return value will be stored in
+         *   [SignatureFile.forMainApiSurface].
+         */
+        fun fromFiles(
+            files: List<File>,
+            apiVariantTypeChooser: (File) -> ApiVariantType = { ApiVariantType.CORE },
+            forMainApiSurfacePredicate: (Int, File) -> Boolean = { _, _ -> true },
+        ): List<SignatureFile> =
+            files.mapIndexed { index, file ->
+                SignatureFileFromFile(
+                    file,
+                    forMainApiSurface = forMainApiSurfacePredicate(index, file),
+                    apiVariantType = apiVariantTypeChooser(file),
+                )
+            }
+
+        /** Create a [SignatureFile] that wraps an [InputStream]. */
+        fun fromStream(filename: String, inputStream: InputStream): SignatureFile {
+            return SignatureFileFromStream(File(filename), inputStream)
+        }
+
+        /**
+         * Create a [SignatureFile] that wraps a [String].
+         *
+         * @param filename the name of the file, used for error reporting.
+         * @param contents the contents of the file, will be trimmed using [String.trimIndent].
+         */
+        fun fromText(filename: String, contents: String): SignatureFile {
+            return SignatureFileFromText(File(filename), contents.trimIndent())
+        }
+    }
+
+    /** A [SignatureFile] that will read the text from the [file]. */
+    private data class SignatureFileFromFile(
+        override val file: File,
+        override val forMainApiSurface: Boolean = true,
+        override val apiVariantType: ApiVariantType = ApiVariantType.CORE,
+    ) : SignatureFile() {
+        override fun readContents() =
+            try {
+                file.readText(UTF_8)
+            } catch (ex: IOException) {
+                throw ApiParseException(
+                    "Error reading API file",
+                    location = FileLocation.createLocation(file.toPath()),
+                    cause = ex
+                )
+            }
+    }
+
+    /** A [SignatureFile] that wraps an [InputStream]. */
+    private data class SignatureFileFromStream(
+        override val file: File,
+        val inputStream: InputStream,
+    ) : SignatureFile() {
+        override fun readContents() = inputStream.bufferedReader().readText()
+    }
+
+    /** A [SignatureFile] that wraps a [String]. */
+    private data class SignatureFileFromText(
+        override val file: File,
+        val contents: String,
+    ) : SignatureFile() {
+        override fun readContents() = contents
     }
 }
 
@@ -137,12 +233,11 @@ private constructor(
     lateinit var format: FileFormat
 
     /**
-     * Indicates whether the file currently being parsed is for the current API surface, i.e. the
-     * one that is being created.
+     * The [ApiVariant] which is defined within the current signature file being parsed.
      *
-     * See [SignatureFile.forCurrentApiSurface].
+     * Set in [parseApiSingleFile].
      */
-    private var forCurrentApiSurface: Boolean = true
+    private lateinit var apiVariant: ApiVariant
 
     /** Map from [ClassItem] to [TextTypeItemFactory]. */
     private val classToTypeItemFactory = IdentityHashMap<ClassItem, TextTypeItemFactory>()
@@ -158,22 +253,6 @@ private constructor(
             files: List<File>,
         ) = parseApi(SignatureFile.fromFiles(files))
 
-        /**
-         * Same as `parseApi(List<SignatureFile>, ...)`, but takes a single file for convenience.
-         *
-         * @param signatureFile input signature file
-         */
-        fun parseApi(
-            signatureFile: SignatureFile,
-            annotationManager: AnnotationManager,
-            description: String? = null,
-        ) =
-            parseApi(
-                signatureFiles = listOf(signatureFile),
-                annotationManager = annotationManager,
-                description = description,
-            )
-
         /**
          * Read API signature files into a [DefaultCodebase].
          *
@@ -185,7 +264,7 @@ private constructor(
          */
         fun parseApi(
             signatureFiles: List<SignatureFile>,
-            annotationManager: AnnotationManager = noOpAnnotationManager,
+            codebaseConfig: Codebase.Config = Codebase.Config.NOOP,
             description: String? = null,
             classResolver: ClassResolver? = null,
             formatForLegacyFiles: FileFormat? = null,
@@ -203,28 +282,21 @@ private constructor(
                 TextCodebaseAssembler.createAssembler(
                     location = signatureFiles[0].file,
                     description = actualDescription,
-                    annotationManager = annotationManager,
+                    codebaseConfig = codebaseConfig,
                     classResolver = classResolver,
                 )
             val parser = ApiFile(assembler, formatForLegacyFiles)
+            val apiSurfaces = codebaseConfig.apiSurfaces
             var first = true
             for (signatureFile in signatureFiles) {
                 val file = signatureFile.file
-                val apiText: String =
-                    try {
-                        file.readText(UTF_8)
-                    } catch (ex: IOException) {
-                        throw ApiParseException(
-                            "Error reading API file",
-                            location = FileLocation.createLocation(file.toPath()),
-                            cause = ex
-                        )
-                    }
+                val apiText = signatureFile.readContents()
+                val apiVariant = signatureFile.apiVariantFor(apiSurfaces)
                 parser.parseApiSingleFile(
                     appending = !first,
                     path = file.toPath(),
                     apiText = apiText,
-                    forCurrentApiSurface = signatureFile.forCurrentApiSurface,
+                    apiVariant = apiVariant,
                 )
                 first = false
             }
@@ -234,22 +306,6 @@ private constructor(
             return assembler.codebase
         }
 
-        /** <p>DO NOT MODIFY - used by com/android/gts/api/ApprovedApis.java */
-        @Deprecated("Exists only for external callers.")
-        @JvmStatic
-        @MetalavaApi
-        @Throws(ApiParseException::class)
-        fun parseApi(
-            filename: String,
-            apiText: String,
-            @Suppress("UNUSED_PARAMETER") kotlinStyleNulls: Boolean?,
-        ): Codebase {
-            return parseApi(
-                filename,
-                apiText,
-            )
-        }
-
         /**
          * Parse the API signature file from the [inputStream].
          *
@@ -260,34 +316,8 @@ private constructor(
         @MetalavaApi
         @Throws(ApiParseException::class)
         fun parseApi(filename: String, inputStream: InputStream): Codebase {
-            val apiText = inputStream.bufferedReader().readText()
-            return parseApi(filename, apiText)
-        }
-
-        /** Entry point for testing. Take a filename and content separately. */
-        fun parseApi(
-            filename: String,
-            apiText: String,
-            classResolver: ClassResolver? = null,
-            formatForLegacyFiles: FileFormat? = null,
-        ): Codebase {
-            val path = Path.of(filename)
-            val assembler =
-                TextCodebaseAssembler.createAssembler(
-                    location = path.toFile(),
-                    description = "Codebase loaded from $filename",
-                    annotationManager = noOpAnnotationManager,
-                    classResolver = classResolver,
-                )
-            val parser = ApiFile(assembler, formatForLegacyFiles)
-            parser.parseApiSingleFile(
-                appending = false,
-                path = path,
-                apiText = apiText,
-                forCurrentApiSurface = true,
-            )
-
-            return assembler.codebase
+            val signatureFile = SignatureFile.fromStream(filename, inputStream)
+            return parseApi(listOf(signatureFile))
         }
 
         /**
@@ -339,25 +369,36 @@ private constructor(
     }
 
     /**
-     * Mark this [Item] as being part of the current API surface, i.e. the one that is being
+     * Mark this [SelectableItem] as being part of the main API surface, i.e. the one that is being
      * created.
      *
-     * See [SignatureFile.forCurrentApiSurface].
+     * See [SignatureFile.forMainApiSurface].
      *
-     * This will set [Item.emit] to [forCurrentApiSurface] and should only be called on [Item]s
-     * which have been created from the current signature file.
+     * This will set [SelectableItem.emit] to [forMainApiSurface] and should only be called on
+     * [SelectableItem]s which have been created from the main signature file.
      */
-    private fun Item.markForCurrentApiSurface() {
-        emit = forCurrentApiSurface
+    private fun SelectableItem.markForMainApiSurface() {
+        emit = apiVariant.surface.isMain
+        markSelectedApiVariant()
     }
 
     /**
-     * It is only necessary to mark an existing class as being part of the current API surface, if
-     * it should be but is not already.
+     * Record that this [SelectableItem] was loaded from a signature file that contains
+     * [apiVariant].
+     */
+    private fun SelectableItem.markSelectedApiVariant() {
+        if (apiVariant !in selectedApiVariants) {
+            mutateSelectedApiVariants { add(apiVariant) }
+        }
+    }
+
+    /**
+     * It is only necessary to mark an existing class as being part of the main API surface, if it
+     * should be but is not already.
      *
-     * This will set [Item.emit] to `true` iff it was previously `false` and [forCurrentApiSurface]
-     * is `true`. That ensures that a class that is not in the current API surface can be included
-     * in it by another signature file, but once it is included it cannot be removed.
+     * This will set [Item.emit] to `true` iff it was previously `false` and [forMainApiSurface] is
+     * `true`. That ensures that a class that is not in the main API surface can be included in it
+     * by another signature file, but once it is included it cannot be removed.
      *
      * e.g. Imagine that there are two files, `public.txt` and `system.txt` where the second extends
      * the first. When generating the system API classes in the `public.txt` will not be considered
@@ -365,17 +406,22 @@ private constructor(
      * created in `public.txt`. While `public.txt` should come first this ensures the correct
      * behavior irrespective of the order.
      */
-    private fun ClassItem.markExistingClassForCurrentApiSurface() {
-        if (!emit && forCurrentApiSurface) {
-            markForCurrentApiSurface()
+    private fun ClassItem.markExistingClassForMainApiSurface() {
+        if (!emit && apiVariant.surface.isMain) {
+            markForMainApiSurface()
         }
+
+        // Always record the ApiVariants to which this belongs, even if this was previously loaded.
+        // This is safe because unlike `emit` which is Boolean the `selectedApiVariants` property is
+        // a set of ApiVariants and this just adds an ApiVariant.
+        markSelectedApiVariant()
     }
 
     private fun parseApiSingleFile(
         appending: Boolean,
         path: Path,
         apiText: String,
-        forCurrentApiSurface: Boolean = true,
+        apiVariant: ApiVariant,
     ) {
         // Parse the header of the signature file to determine the format. If the signature file is
         // empty then `parseHeader` will return null, so it will default to `FileFormat.V2`.
@@ -399,9 +445,8 @@ private constructor(
             }
         }
 
-        // Remember whether the file being parsed is for the current API surface, so that Items
-        // created from it can be marked correctly.
-        this.forCurrentApiSurface = forCurrentApiSurface
+        // Remember the API variant of the file being parsed.
+        this.apiVariant = apiVariant
 
         val tokenizer = Tokenizer(path, apiText.toCharArray())
         while (true) {
@@ -442,6 +487,9 @@ private constructor(
                 throw ApiParseException(e.message!!, tokenizer)
             }
 
+        // Make sure that the package records the ApiVariants to which it belongs.
+        pkg.markSelectedApiVariant()
+
         token = tokenizer.requireToken()
         if ("{" != token) {
             throw ApiParseException("expected '{' got $token", tokenizer)
@@ -607,7 +655,7 @@ private constructor(
                 superClassType = superClassType,
                 interfaceTypes = interfaceTypes.toList(),
             )
-        cl.markForCurrentApiSurface()
+        cl.markForMainApiSurface()
 
         // Store the [TypeItemFactory] for this [ClassItem] so it can be retrieved later in
         // [typeItemFactoryForClass].
@@ -670,8 +718,8 @@ private constructor(
         parseClassBody(tokenizer, existingClass, typeItemFactoryForClass(existingClass))
 
         // Although the class was first defined in a separate file it is being modified in the
-        // current file so that may include it in the current API surface.
-        existingClass.markExistingClassForCurrentApiSurface()
+        // current file so that may include it in the main API surface.
+        existingClass.markExistingClassForMainApiSurface()
 
         return true
     }
@@ -1009,7 +1057,7 @@ private constructor(
                 // on the API surface.
                 implicitConstructor = false,
             )
-        method.markForCurrentApiSurface()
+        method.markForMainApiSurface()
 
         if (!containingClass.constructors().contains(method)) {
             containingClass.addConstructor(method)
@@ -1122,7 +1170,7 @@ private constructor(
         // ensure that the resulting Codebase is consistent with the original source Codebase.
         if (method.isEnumSyntheticMethod()) return
 
-        method.markForCurrentApiSurface()
+        method.markForMainApiSurface()
 
         // If the method already exists in the class item because it was defined in a previous
         // signature file then replace it with this one, otherwise just add this method.
@@ -1197,7 +1245,7 @@ private constructor(
                 isEnumConstant = isEnumConstant,
                 fieldValue = fieldValue,
             )
-        field.markForCurrentApiSurface()
+        field.markForMainApiSurface()
         cl.addField(field)
     }
 
@@ -1430,7 +1478,7 @@ private constructor(
                 containingClass = cl,
                 type = type,
             )
-        property.markForCurrentApiSurface()
+        property.markForMainApiSurface()
         cl.addProperty(property)
     }
 
@@ -1738,8 +1786,6 @@ private constructor(
                     defaultValueFactory = { defaultValue },
                 )
 
-            parameter.markForCurrentApiSurface()
-
             return parameter
         }
     }
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/FileFormat.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/FileFormat.kt
index 18bccfe0c..8c69c27f4 100644
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/FileFormat.kt
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/FileFormat.kt
@@ -17,6 +17,7 @@
 package com.android.tools.metalava.model.text
 
 import com.android.tools.metalava.model.CallableItem
+import com.android.tools.metalava.model.StripJavaLangPrefix
 import com.android.tools.metalava.reporter.FileLocation
 import java.io.LineNumberReader
 import java.io.Reader
@@ -133,6 +134,12 @@ data class FileFormat(
      * sorting is by the full name (without the package) of the class.
      */
     val specifiedSortWholeExtendsList: Boolean? = null,
+
+    /**
+     * Indicates which of the possible approaches to `java.lang.` prefix stripping available in
+     * [StripJavaLangPrefix] is used when outputting types to signature files.
+     */
+    val specifiedStripJavaLangPrefix: StripJavaLangPrefix? = null
 ) {
     init {
         if (migrating != null && "[,\n]".toRegex().find(migrating) != null) {
@@ -188,6 +195,10 @@ data class FileFormat(
     val sortWholeExtendsList
         get() = effectiveValue({ specifiedSortWholeExtendsList }, default = false)
 
+    // This defaults to LEGACY but can be overridden on the command line.
+    val stripJavaLangPrefix
+        get() = effectiveValue({ specifiedStripJavaLangPrefix }, StripJavaLangPrefix.LEGACY)
+
     /** The base version of the file format. */
     enum class Version(
         /** The version number of this as a string, e.g. "3.0". */
@@ -711,6 +722,7 @@ data class FileFormat(
         var name: String? = null
         var overloadedMethodOrder: OverloadedMethodOrder? = null
         var sortWholeExtendsList: Boolean? = null
+        var stripJavaLangPrefix: StripJavaLangPrefix? = null
         var surface: String? = null
 
         fun build(): FileFormat {
@@ -731,6 +743,8 @@ data class FileFormat(
                         ?: base.specifiedOverloadedMethodOrder,
                 specifiedSortWholeExtendsList = sortWholeExtendsList
                         ?: base.specifiedSortWholeExtendsList,
+                specifiedStripJavaLangPrefix = stripJavaLangPrefix
+                        ?: base.specifiedStripJavaLangPrefix,
                 surface = surface ?: base.surface,
             )
         }
@@ -837,6 +851,14 @@ data class FileFormat(
 
             override fun stringFromFormat(format: FileFormat): String? =
                 format.specifiedSortWholeExtendsList?.let { yesNo(it) }
+        },
+        STRIP_JAVA_LANG_PREFIX(defaultable = true) {
+            override fun setFromString(builder: Builder, value: String) {
+                builder.stripJavaLangPrefix = enumFromString<StripJavaLangPrefix>(value)
+            }
+
+            override fun stringFromFormat(format: FileFormat): String? =
+                format.specifiedStripJavaLangPrefix?.stringFromEnum()
         };
 
         /** The property name in the [parseSpecifier] input. */
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextCodebaseAssembler.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextCodebaseAssembler.kt
index d8215cf92..1adb715f3 100644
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextCodebaseAssembler.kt
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextCodebaseAssembler.kt
@@ -16,11 +16,11 @@
 
 package com.android.tools.metalava.model.text
 
-import com.android.tools.metalava.model.AnnotationManager
 import com.android.tools.metalava.model.ApiVariantSelectors
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassResolver
 import com.android.tools.metalava.model.ClassTypeItem
+import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.ItemLanguage
 import com.android.tools.metalava.model.bestGuessAtFullName
@@ -31,9 +31,7 @@ import com.android.tools.metalava.model.item.DefaultCodebaseFactory
 import com.android.tools.metalava.model.item.DefaultItemFactory
 import com.android.tools.metalava.model.item.DefaultPackageItem
 import com.android.tools.metalava.model.item.PackageDocs
-import com.android.tools.metalava.reporter.BasicReporter
 import java.io.File
-import java.io.PrintWriter
 
 internal class TextCodebaseAssembler(
     codebaseFactory: DefaultCodebaseFactory,
@@ -185,21 +183,19 @@ internal class TextCodebaseAssembler(
         fun createAssembler(
             location: File,
             description: String,
-            annotationManager: AnnotationManager,
+            codebaseConfig: Codebase.Config,
             classResolver: ClassResolver?,
         ): TextCodebaseAssembler {
             val assembler =
                 TextCodebaseAssembler(
                     codebaseFactory = { assembler ->
-                        val reporter = BasicReporter(PrintWriter(System.err))
                         DefaultCodebase(
                             location = location,
                             description = description,
                             preFiltered = true,
-                            annotationManager = annotationManager,
+                            config = codebaseConfig,
                             trustedApi = true,
                             supportsDocumentation = false,
-                            reporter = reporter,
                             assembler = assembler,
                         )
                     },
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextCodebaseBuilder.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextCodebaseBuilder.kt
index af131ebf6..9fb4e2382 100644
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextCodebaseBuilder.kt
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextCodebaseBuilder.kt
@@ -16,7 +16,6 @@
 
 package com.android.tools.metalava.model.text
 
-import com.android.tools.metalava.model.AnnotationManager
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.ConstructorItem
@@ -37,14 +36,14 @@ class TextCodebaseBuilder private constructor(private val assembler: TextCodebas
         fun build(
             location: File,
             description: String,
-            annotationManager: AnnotationManager,
+            codebaseConfig: Codebase.Config,
             block: TextCodebaseBuilder.() -> Unit
         ): Codebase {
             val assembler =
                 TextCodebaseAssembler.createAssembler(
                     location = location,
                     description = description,
-                    annotationManager = annotationManager,
+                    codebaseConfig = codebaseConfig,
                     classResolver = null,
                 )
             val builder = TextCodebaseBuilder(assembler)
@@ -67,8 +66,19 @@ class TextCodebaseBuilder private constructor(private val assembler: TextCodebas
     }
 
     fun addClass(cls: ClassItem) {
-        val pkg = getOrAddPackage(cls.containingPackage().qualifiedName())
-        pkg.addTopClass(cls)
+        // Replicate some of the registration code from DefaultClassItem initialization block. This
+        // does not register classes correctly. e.g. It adds nested classes as top level classes in
+        // the package. While that is strictly speaking invalid it works for this which is only used
+        // to create a very short-lived Codebase that is written out to a JDiff file.
+        // TODO(b/369078254): Clean this up.
+        codebase.registerClass(cls as DefaultClassItem)
+        val containingPackage = getOrAddPackage(cls.containingPackage().qualifiedName())
+        containingPackage.addTopClass(cls)
+
+        // If the class is emittable then make sure its package is too.
+        if (cls.emit) {
+            containingPackage.emit = true
+        }
     }
 
     fun addConstructor(ctor: ConstructorItem) {
diff --git a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextTypeParser.kt b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextTypeParser.kt
index 81d1e9d2d..ae579c85d 100644
--- a/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextTypeParser.kt
+++ b/metalava-model-text/src/main/java/com/android/tools/metalava/model/text/TextTypeParser.kt
@@ -23,6 +23,7 @@ import com.android.tools.metalava.model.ClassTypeItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.DefaultAnnotationItem
 import com.android.tools.metalava.model.JAVA_LANG_OBJECT
+import com.android.tools.metalava.model.JAVA_LANG_PREFIX
 import com.android.tools.metalava.model.PrimitiveTypeItem
 import com.android.tools.metalava.model.ReferenceTypeItem
 import com.android.tools.metalava.model.TypeArgumentTypeItem
@@ -824,15 +825,12 @@ internal class TextTypeParser(val codebase: Codebase, val kotlinStyleNulls: Bool
             // package, all other types must be fully qualified. At this point it is not clear
             // whether the type used in the input type string was qualified or not as the package
             // has been prepended so this assumes that they all are just to be on the safe side.
-            // It is only for legacy reasons that all `java.lang` package prefixes are stripped
-            // when generating the API signature files. See b/324047248.
             val name = classType.qualifiedName
             if (!name.contains('.')) {
                 unqualifiedNames.add(name)
             } else {
-                val trimmed = TypeItem.stripJavaLangPrefix(name)
-                if (trimmed != name) {
-                    unqualifiedNames.add(trimmed)
+                if (classType.classNamePrefix == JAVA_LANG_PREFIX) {
+                    unqualifiedNames.add(classType.className)
                 }
             }
         }
diff --git a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/ApiFileTest.kt b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/ApiFileTest.kt
index 98ff9e70e..8cd7a4f1b 100644
--- a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/ApiFileTest.kt
+++ b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/ApiFileTest.kt
@@ -22,7 +22,9 @@ import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassKind
 import com.android.tools.metalava.model.ClassResolver
 import com.android.tools.metalava.model.Codebase
-import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.SelectableItem
+import com.android.tools.metalava.model.api.surface.ApiSurfaces
+import com.android.tools.metalava.model.noOpAnnotationManager
 import com.android.tools.metalava.testing.getAndroidJar
 import com.google.common.truth.Truth.assertThat
 import kotlin.test.assertEquals
@@ -217,8 +219,8 @@ class ApiFileTest : BaseTextCodebaseTest() {
                 "other.UnknownException",
                 "java.lang.Throwable",
             )
-        val codebase =
-            ApiFile.parseApi(
+        val signatureFile =
+            SignatureFile.fromText(
                 "api.txt",
                 """
                     // Signature format: 2.0
@@ -228,7 +230,11 @@ class ApiFileTest : BaseTextCodebaseTest() {
                         }
                     }
                 """
-                    .trimIndent(),
+            )
+
+        val codebase =
+            ApiFile.parseApi(
+                listOf(signatureFile),
                 classResolver = testClassResolver,
             )
 
@@ -481,7 +487,7 @@ class ApiFileTest : BaseTextCodebaseTest() {
     }
 
     @Test
-    fun `Test for current API surface`() {
+    fun `Test for main API surface`() {
         val testFiles =
             listOf(
                 signature(
@@ -525,17 +531,29 @@ class ApiFileTest : BaseTextCodebaseTest() {
 
         val files = testFiles.map { it.createFile(temporaryFolder.newFolder()) }
         val signatureFiles =
-            files.map { file ->
-                SignatureFile(file, forCurrentApiSurface = file.name == "current.txt")
-            }
+            SignatureFile.fromFiles(
+                files,
+                forMainApiSurfacePredicate = { _, file -> file.name == "current.txt" },
+            )
 
+        val apiSurfaces = ApiSurfaces.create(needsBase = true)
+        val codebaseConfig =
+            Codebase.Config(
+                annotationManager = noOpAnnotationManager,
+                apiSurfaces = apiSurfaces,
+            )
         val classResolver = ClassLoaderBasedClassResolver(getAndroidJar())
-        val codebase = ApiFile.parseApi(signatureFiles, classResolver = classResolver)
+        val codebase =
+            ApiFile.parseApi(
+                signatureFiles,
+                codebaseConfig = codebaseConfig,
+                classResolver = classResolver,
+            )
 
         val current = buildList {
             codebase.accept(
-                object : BaseItemVisitor() {
-                    override fun visitItem(item: Item) {
+                object : BaseItemVisitor(visitParameterItems = false) {
+                    override fun visitSelectableItem(item: SelectableItem) {
                         if (item.emit) {
                             add(item)
                         }
@@ -549,11 +567,8 @@ class ApiFileTest : BaseTextCodebaseTest() {
                 package test.pkg
                 class test.pkg.Foo
                 constructor test.pkg.Foo.Foo(int)
-                parameter currentCtorParameter
                 method test.pkg.Foo.extensibleMethod(int)
-                parameter parameter
                 method test.pkg.Foo.currentMethod(int)
-                parameter currentMethodParameter
                 field Foo.currentField
                 class test.pkg.Outer.Middle.Inner
                 method test.pkg.Outer.Middle.Inner.currentInnerMethod()
@@ -566,7 +581,8 @@ class ApiFileTest : BaseTextCodebaseTest() {
     class TestClassItem private constructor(delegate: ClassItem) : ClassItem by delegate {
         companion object {
             fun create(name: String): TestClassItem {
-                val codebase = ApiFile.parseApi("other.txt", "// Signature format: 2.0")
+                val signatureFile = SignatureFile.fromText("other.txt", "// Signature format: 2.0")
+                val codebase = ApiFile.parseApi(listOf(signatureFile))
                 val delegate = codebase.resolveClass(name)!!
                 return TestClassItem(delegate)
             }
diff --git a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/FileFormatTest.kt b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/FileFormatTest.kt
index 3632ffd05..bfb42abff 100644
--- a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/FileFormatTest.kt
+++ b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/FileFormatTest.kt
@@ -16,6 +16,7 @@
 
 package com.android.tools.metalava.model.text
 
+import com.android.tools.metalava.model.StripJavaLangPrefix
 import java.io.LineNumberReader
 import java.io.StringReader
 import java.nio.file.Path
@@ -29,6 +30,7 @@ val DEFAULTABLE_PROPERTY_NAMES =
         "add-additional-overrides",
         "overloaded-method-order",
         "sort-whole-extends-list",
+        "strip-java-lang-prefix",
     )
 
 val DEFAULTABLE_PROPERTIES = DEFAULTABLE_PROPERTY_NAMES.joinToString { "'$it'" }
@@ -459,6 +461,25 @@ class FileFormatTest {
         )
     }
 
+    @Test
+    fun `Check header and specifier (v5 + strip-java-lang-prefix=always)`() {
+        headerAndSpecifierTest(
+            header =
+                """
+                    // Signature format: 5.0
+                    // - migrating=test
+                    // - strip-java-lang-prefix=always
+
+                """,
+            specifier = "5.0:migrating=test,strip-java-lang-prefix=always",
+            format =
+                FileFormat.V5.copy(
+                    specifiedStripJavaLangPrefix = StripJavaLangPrefix.ALWAYS,
+                    migrating = "test",
+                ),
+        )
+    }
+
     @Test
     fun `Check header and specifier (v5 + language=java)`() {
         headerAndSpecifierTest(
diff --git a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/SignatureFileTest.kt b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/SignatureFileTest.kt
new file mode 100644
index 000000000..5a765cb26
--- /dev/null
+++ b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/SignatureFileTest.kt
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.text
+
+import com.android.tools.metalava.model.api.surface.ApiSurface
+import com.android.tools.metalava.model.api.surface.ApiSurfaces
+import com.android.tools.metalava.model.api.surface.ApiVariant
+import com.android.tools.metalava.model.api.surface.ApiVariantType
+import kotlin.test.Test
+import kotlin.test.assertEquals
+import kotlin.test.assertSame
+import org.junit.Assert.assertThrows
+
+class SignatureFileTest : BaseTextCodebaseTest() {
+
+    /** Get an empty [SignatureFile] for [path]. */
+    private fun signatureFile(path: String): SignatureFile {
+        val inputFile = signature(path, "").createFile(temporaryFolder.root)
+        return SignatureFile.forTest(listOf(inputFile))[0]
+    }
+
+    /**
+     * Check that the [ApiVariant] obtained from [apiSurfaces] for [path] has the expected
+     * [ApiVariant.surface] (as returned by [expectedVariantType]) and the expected [ApiVariantType]
+     * (as specified by [expectedVariantType]).
+     */
+    private fun checkApiVariantFor(
+        path: String,
+        expectedSurfaceGetter: (ApiSurfaces) -> ApiSurface,
+        expectedVariantType: ApiVariantType,
+        apiSurfaces: ApiSurfaces = ApiSurfaces.create(needsBase = true),
+    ) {
+        val signatureFile = signatureFile(path)
+        val apiVariant = signatureFile.apiVariantFor(apiSurfaces)
+        val expectedSurface = expectedSurfaceGetter(apiSurfaces)
+        assertSame(expectedSurface, apiVariant.surface, "expected matching surface")
+        assertSame(expectedVariantType, apiVariant.type, "expected matching type")
+    }
+
+    @Test
+    fun `Test apiVariantFor base-current`() {
+        checkApiVariantFor(
+            "base-current.txt",
+            { it.base!! },
+            ApiVariantType.CORE,
+        )
+    }
+
+    @Test
+    fun `Test apiVariantFor base-removed`() {
+        checkApiVariantFor(
+            "base-removed.txt",
+            { it.base!! },
+            ApiVariantType.REMOVED,
+        )
+    }
+
+    @Test
+    fun `Test apiVariantFor current`() {
+        checkApiVariantFor(
+            "current.txt",
+            { it.main },
+            ApiVariantType.CORE,
+        )
+    }
+
+    @Test
+    fun `Test apiVariantFor removed`() {
+        checkApiVariantFor(
+            "removed.txt",
+            { it.main },
+            ApiVariantType.REMOVED,
+        )
+    }
+
+    @Test
+    fun `Test apiVariantFor base-current input no base ApiSurface`() {
+        // Make sure that an error is thrown if the signature file requires a base ApiSurface but
+        // the apiSurfaces does not provide one.
+        val exception =
+            assertThrows(IllegalStateException::class.java) {
+                checkApiVariantFor(
+                    "base-removed.txt",
+                    { error("should not be called") },
+                    ApiVariantType.CORE,
+                    apiSurfaces = ApiSurfaces.DEFAULT,
+                )
+            }
+
+        val message = cleanupString(exception.message!!)
+        assertEquals(
+            "TESTROOT/base-removed.txt expects a base API surface to be available but it is not",
+            message
+        )
+    }
+}
diff --git a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextTypeParserCacheTest.kt b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextTypeParserCacheTest.kt
index d96798b81..61432ef7e 100644
--- a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextTypeParserCacheTest.kt
+++ b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextTypeParserCacheTest.kt
@@ -24,6 +24,7 @@ import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeParameterScope
 import com.android.tools.metalava.model.VariableTypeItem
 import com.android.tools.metalava.model.WildcardTypeItem
+import com.android.tools.metalava.model.testing.testTypeString
 import com.android.tools.metalava.testing.getAndroidTxt
 import com.google.common.truth.Truth.assertThat
 import com.google.common.truth.Truth.assertWithMessage
@@ -99,7 +100,7 @@ class TextTypeParserCacheTest : BaseTextCodebaseTest() {
         }
 
         ApiFile.parseApi(
-            listOf(SignatureFile.fromFile(testFile)),
+            SignatureFile.fromFiles(testFile),
             apiStatsConsumer = { stats ->
                 assertThat(stats)
                     .isEqualTo(
@@ -299,8 +300,8 @@ class TextTypeParserCacheTest : BaseTextCodebaseTest() {
             assertWithMessage(
                     "string representation of withAnno1.deepestComponent() and withAnno1TwoDims.deepestComponent()"
                 )
-                .that(withAnno1TwoDims.deepestComponent().toTypeString(annotations = true))
-                .isEqualTo(withAnno1.deepestComponent().toTypeString(annotations = true))
+                .that(withAnno1TwoDims.deepestComponent().testTypeString(annotations = true))
+                .isEqualTo(withAnno1.deepestComponent().testTypeString(annotations = true))
 
             // But they are different instances as types with annotations are not cached..
             assertWithMessage(
diff --git a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextTypeParserTest.kt b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextTypeParserTest.kt
index de0c8a90f..c5d666d13 100644
--- a/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextTypeParserTest.kt
+++ b/metalava-model-text/src/test/java/com/android/tools/metalava/model/text/TextTypeParserTest.kt
@@ -28,7 +28,11 @@ import org.junit.Assert
 import org.junit.Test
 
 class TextTypeParserTest : BaseTextCodebaseTest() {
-    private val typeParser = TextTypeParser(ApiFile.parseApi("test", ""))
+    private val typeParser = run {
+        val signatureFile = SignatureFile.fromText("test", "")
+        val codebase = ApiFile.parseApi(listOf(signatureFile))
+        TextTypeParser(codebase)
+    }
 
     private fun parseType(type: String) =
         typeParser.obtainTypeFromString(type, TypeParameterScope.empty)
diff --git a/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/FileFormatFixture.kt b/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/FileFormatFixture.kt
index 22cd66b12..6f39a2058 100644
--- a/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/FileFormatFixture.kt
+++ b/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/FileFormatFixture.kt
@@ -30,6 +30,7 @@ private val FILE_FORMAT_PROPERTY_NAMES =
         "name",
         "overloaded-method-order",
         "sort-whole-extends-list",
+        "strip-java-lang-prefix",
         "surface",
     )
 
diff --git a/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/TextModelSuiteRunner.kt b/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/TextModelSuiteRunner.kt
index 07451bf02..f87bec814 100644
--- a/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/TextModelSuiteRunner.kt
+++ b/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/TextModelSuiteRunner.kt
@@ -25,7 +25,6 @@ import com.android.tools.metalava.model.TypeParameterList
 import com.android.tools.metalava.model.VisibilityLevel
 import com.android.tools.metalava.model.createImmutableModifiers
 import com.android.tools.metalava.model.item.DefaultClassItem
-import com.android.tools.metalava.model.noOpAnnotationManager
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.provider.InputFormat
 import com.android.tools.metalava.model.testing.transformer.CodebaseTransformer
@@ -52,9 +51,17 @@ class TextModelSuiteRunner : ModelSuiteRunner {
             error("text model does not support common sources")
         }
 
-        val signatureFiles = SignatureFile.fromFiles(inputs.mainSourceDir.createFiles())
-        val resolver = ClassLoaderBasedClassResolver(getAndroidJar())
-        val codebase = ApiFile.parseApi(signatureFiles, classResolver = resolver)
+        val testFixture = inputs.testFixture
+        val codebaseConfig = testFixture.codebaseConfig
+
+        val signatureFiles = SignatureFile.forTest(inputs.mainSourceDir.createFiles())
+        val resolver = ClassLoaderBasedClassResolver(getAndroidJar(), codebaseConfig)
+        val codebase =
+            ApiFile.parseApi(
+                signatureFiles,
+                codebaseConfig = codebaseConfig,
+                classResolver = resolver,
+            )
 
         // If available, transform the codebase for testing, otherwise use the one provided.
         val transformedCodebase = CodebaseTransformer.transformIfAvailable(codebase)
@@ -77,14 +84,17 @@ class TextModelSuiteRunner : ModelSuiteRunner {
  * the [classLoader]. It is just a placeholder to indicate that it was found, although that may
  * change in the future.
  */
-class ClassLoaderBasedClassResolver(jar: File) : ClassResolver {
+class ClassLoaderBasedClassResolver(
+    jar: File,
+    codebaseConfig: Codebase.Config = Codebase.Config.NOOP,
+) : ClassResolver {
 
     private val assembler by
         lazy(LazyThreadSafetyMode.NONE) {
             TextCodebaseAssembler.createAssembler(
                 location = jar,
                 description = "Codebase for resolving classes in $jar for tests",
-                annotationManager = noOpAnnotationManager,
+                codebaseConfig = codebaseConfig,
                 classResolver = null,
             )
         }
diff --git a/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/TextTestUtils.kt b/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/TextTestUtils.kt
index 73387ffc6..26803500c 100644
--- a/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/TextTestUtils.kt
+++ b/metalava-model-text/src/testFixtures/java/com/android/tools/metalava/model/text/TextTestUtils.kt
@@ -16,6 +16,9 @@
 
 package com.android.tools.metalava.model.text
 
+import com.android.tools.metalava.model.api.surface.ApiSurfaces
+import com.android.tools.metalava.model.api.surface.ApiVariantType
+import java.io.File
 import org.junit.Assert.assertEquals
 
 /** Verify that two signature files match. */
@@ -41,3 +44,44 @@ fun prepareSignatureFileForTest(expectedApi: String, format: FileFormat): String
         .let { if (!it.startsWith(FileFormat.SIGNATURE_FORMAT_PREFIX)) header + it else it }
         .trim()
 }
+
+/**
+ * Get the [ApiVariantType] for a test signature file with [name].
+ *
+ * If it contains "removed" then it will be [ApiVariantType.REMOVED] else it will be
+ * [ApiVariantType.CORE].
+ */
+fun apiVariantTypeForTestSignatureFile(name: String) =
+    when {
+        name.contains("removed") -> ApiVariantType.REMOVED
+        else -> ApiVariantType.CORE
+    }
+
+/**
+ * Check if the test signature file with [name] is for the main API surface.
+ *
+ * If it contains "base" then it will return `false` as it is for the base API surface, otherwise it
+ * will return `true` as it is assumed it is for the main API surface.
+ */
+private fun isTestSignatureFileForMainApiSurface(name: String) =
+    when {
+        name.contains("base") -> false
+        else -> true
+    }
+
+/**
+ * Create a list of [SignatureFile]s from [files] suitable for testing.
+ *
+ * This extracts information from the file name as to the purpose of each [SignatureFile] as
+ * follows:
+ * * If the name contains `base` then it is assumed to be for the [ApiSurfaces.base], otherwise it
+ *   is assumed to be for [ApiSurfaces.main].
+ * * If the name contains `removed` then it is assumed to be for the [ApiVariantType.REMOVED],
+ *   otherwise it is assumed to be for [ApiVariantType.CORE].
+ */
+fun SignatureFile.Companion.forTest(files: List<File>) =
+    fromFiles(
+        files,
+        apiVariantTypeChooser = { file -> apiVariantTypeForTestSignatureFile(file.name) },
+        forMainApiSurfacePredicate = { _, file -> isTestSignatureFileForMainApiSurface(file.name) }
+    )
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineCodebaseInitialiser.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineCodebaseInitialiser.kt
index 542f06b61..e3566e5ea 100644
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineCodebaseInitialiser.kt
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineCodebaseInitialiser.kt
@@ -53,6 +53,7 @@ import com.android.tools.metalava.model.ModifierFlags.Companion.TRANSIENT
 import com.android.tools.metalava.model.ModifierFlags.Companion.VARARG
 import com.android.tools.metalava.model.ModifierFlags.Companion.VOLATILE
 import com.android.tools.metalava.model.MutableModifierList
+import com.android.tools.metalava.model.PackageFilter
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.TypeParameterList
 import com.android.tools.metalava.model.TypeParameterListAndFactory
@@ -180,7 +181,10 @@ internal class TurbineCodebaseInitialiser(
      * Then creates the packages, classes and their members, as well as sets up various class
      * hierarchies using the binder's output
      */
-    fun initialize(sourceSet: SourceSet) {
+    fun initialize(
+        sourceSet: SourceSet,
+        apiPackages: PackageFilter?,
+    ) {
         // Get the units from the source files provided on the command line.
         val commandLineSources = sourceSet.sources
         val sourceFiles = getSourceFiles(commandLineSources.asSequence())
@@ -306,7 +310,7 @@ internal class TurbineCodebaseInitialiser(
             }
 
         createAllPackages(packageDocs)
-        createAllClasses(commandLineSourceClasses)
+        createAllClasses(commandLineSourceClasses, apiPackages)
     }
 
     /**
@@ -441,7 +445,10 @@ internal class TurbineCodebaseInitialiser(
         codebase.packageTracker.createInitialPackages(packageDocs)
     }
 
-    private fun createAllClasses(sourceClassMap: Map<ClassSymbol, SourceTypeBoundClass>) {
+    private fun createAllClasses(
+        sourceClassMap: Map<ClassSymbol, SourceTypeBoundClass>,
+        apiPackages: PackageFilter?,
+    ) {
         // Iterate over all the classes in the sources.
         for ((classSymbol, sourceBoundClass) in sourceClassMap) {
             // Ignore nested classes, they will be created when the outer class is created.
@@ -454,6 +461,12 @@ internal class TurbineCodebaseInitialiser(
                 continue
             }
 
+            // If a package filter is supplied then ignore any classes that do not match it.
+            if (apiPackages != null) {
+                val packageName = classSymbol.dotSeparatedPackageName
+                if (!apiPackages.matches(packageName)) continue
+            }
+
             val classItem =
                 createTopLevelClassAndContents(
                     classSymbol = classSymbol,
@@ -606,6 +619,9 @@ internal class TurbineCodebaseInitialiser(
         return annotations?.any { it.qualifiedName == "java.lang.Deprecated" } ?: false
     }
 
+    private val ClassSymbol.dotSeparatedPackageName
+        get() = packageName().replace('/', '.')
+
     private fun createClass(
         classSymbol: ClassSymbol,
         typeBoundClass: TypeBoundClass = typeBoundClassForSymbol(classSymbol),
@@ -618,7 +634,7 @@ internal class TurbineCodebaseInitialiser(
         val isTopClass = typeBoundClass.owner() == null
 
         // Get the package item
-        val pkgName = classSymbol.packageName().replace('/', '.')
+        val pkgName = classSymbol.dotSeparatedPackageName
         val pkgItem = codebase.findOrCreatePackage(pkgName)
 
         // Create the sourcefile
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineEnvironmentManager.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineEnvironmentManager.kt
index f8853b7b6..a2ac4a41b 100644
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineEnvironmentManager.kt
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineEnvironmentManager.kt
@@ -16,19 +16,17 @@
 
 package com.android.tools.metalava.model.turbine
 
-import com.android.tools.metalava.model.AnnotationManager
+import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.ModelOptions
 import com.android.tools.metalava.model.source.EnvironmentManager
 import com.android.tools.metalava.model.source.SourceParser
-import com.android.tools.metalava.reporter.Reporter
 import java.io.File
 
 /** Manages the objects created when processing sources. */
 internal class TurbineEnvironmentManager() : EnvironmentManager {
 
     override fun createSourceParser(
-        reporter: Reporter,
-        annotationManager: AnnotationManager,
+        codebaseConfig: Codebase.Config,
         javaLanguageLevel: String,
         kotlinLanguageLevel: String,
         modelOptions: ModelOptions,
@@ -36,7 +34,7 @@ internal class TurbineEnvironmentManager() : EnvironmentManager {
         jdkHome: File?,
         projectDescription: File?,
     ): SourceParser {
-        return TurbineSourceParser(reporter, annotationManager, allowReadingComments)
+        return TurbineSourceParser(codebaseConfig, allowReadingComments)
     }
 
     // TODO (b/299217550 implement it)
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceFile.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceFile.kt
index 6c06597c2..5c6b9e620 100644
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceFile.kt
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceFile.kt
@@ -17,14 +17,13 @@
 package com.android.tools.metalava.model.turbine
 
 import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.FilterPredicate
 import com.android.tools.metalava.model.Import
-import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.SourceFile
 import com.android.tools.metalava.model.item.DefaultCodebase
 import com.google.turbine.diag.LineMap
 import com.google.turbine.tree.Tree.CompUnit
 import java.util.TreeSet
-import java.util.function.Predicate
 
 internal class TurbineSourceFile(
     val codebase: DefaultCodebase,
@@ -49,7 +48,7 @@ internal class TurbineSourceFile(
         return compUnit.hashCode()
     }
 
-    override fun getImports(predicate: Predicate<Item>): Collection<Import> {
+    override fun getImports(predicate: FilterPredicate): Collection<Import> {
         val imports = TreeSet<Import>(compareBy { it.pattern })
 
         for (import in compUnit.imports()) {
@@ -69,7 +68,7 @@ internal class TurbineSourceFile(
             }
             // Not static member import i.e. class import
             else if (!import.stat()) {
-                val classItem = codebase.findClass(resolvedName) ?: continue
+                val classItem = codebase.resolveClass(resolvedName) ?: continue
                 if (predicate.test(classItem)) {
                     imports.add(Import(classItem))
                 }
diff --git a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceParser.kt b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceParser.kt
index 979d73356..9a510a975 100644
--- a/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceParser.kt
+++ b/metalava-model-turbine/src/main/java/com/android/tools/metalava/model/turbine/TurbineSourceParser.kt
@@ -16,18 +16,16 @@
 
 package com.android.tools.metalava.model.turbine
 
-import com.android.tools.metalava.model.AnnotationManager
 import com.android.tools.metalava.model.ClassResolver
 import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.PackageFilter
 import com.android.tools.metalava.model.item.DefaultCodebase
 import com.android.tools.metalava.model.source.SourceParser
 import com.android.tools.metalava.model.source.SourceSet
-import com.android.tools.metalava.reporter.Reporter
 import java.io.File
 
 internal class TurbineSourceParser(
-    private val reporter: Reporter,
-    private val annotationManager: AnnotationManager,
+    private val codebaseConfig: Codebase.Config,
     private val allowReadingComments: Boolean
 ) : SourceParser {
 
@@ -43,6 +41,7 @@ internal class TurbineSourceParser(
         commonSourceSet: SourceSet,
         description: String,
         classPath: List<File>,
+        apiPackages: PackageFilter?,
     ): Codebase {
         val rootDir = sourceSet.sourcePath.firstOrNull() ?: File("").canonicalFile
 
@@ -53,10 +52,9 @@ internal class TurbineSourceParser(
                         location = rootDir,
                         description = description,
                         preFiltered = false,
-                        annotationManager = annotationManager,
+                        config = codebaseConfig,
                         trustedApi = false,
                         supportsDocumentation = true,
-                        reporter = reporter,
                         assembler = assembler,
                     )
                 },
@@ -65,7 +63,7 @@ internal class TurbineSourceParser(
             )
 
         // Initialize the codebase.
-        assembler.initialize(sourceSet)
+        assembler.initialize(sourceSet, apiPackages)
 
         // Return the newly created and initialized codebase.
         return assembler.codebase
diff --git a/metalava-model-turbine/src/test/resources/model-test-suite-baseline.txt b/metalava-model-turbine/src/test/resources/model-test-suite-baseline.txt
index 01d163436..03c5faec6 100644
--- a/metalava-model-turbine/src/test/resources/model-test-suite-baseline.txt
+++ b/metalava-model-turbine/src/test/resources/model-test-suite-baseline.txt
@@ -5,6 +5,9 @@ com.android.tools.metalava.model.testsuite.annotationitem.CommonAnnotationItemTe
 com.android.tools.metalava.model.testsuite.classitem.CommonDuplicateClassItemTest
   Test duplicate classes
 
+com.android.tools.metalava.model.testsuite.documentation.CommonParameterizedDocumentationTest
+  Documentation fully qualified[doc comment with link - java]
+
 com.android.tools.metalava.model.testsuite.fielditem.CommonFieldItemTest
   Test implicit nullability of constant field initialized from @NonNull method
 
diff --git a/metalava-model/build.gradle.kts b/metalava-model/build.gradle.kts
index fc3291fcf..bbf427d46 100644
--- a/metalava-model/build.gradle.kts
+++ b/metalava-model/build.gradle.kts
@@ -31,6 +31,7 @@ dependencies {
 
     testFixturesImplementation(project(":metalava-reporter"))
     testFixturesImplementation(project(":metalava-testing"))
+    testFixturesImplementation(libs.androidLintTests)
     testFixturesImplementation(libs.truth)
     testFixturesImplementation(libs.kotlinTest)
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/AndroidConstants.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/AndroidConstants.kt
index 8cc651b9d..10d767f5e 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/AndroidConstants.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/AndroidConstants.kt
@@ -21,13 +21,21 @@ const val ANDROID_INT_DEF = "android.annotation.IntDef"
 const val ANDROID_LONG_DEF = "android.annotation.LongDef"
 const val ANDROID_STRING_DEF = "android.annotation.StringDef"
 
+const val ANDROID_SYSTEM_API = "android.annotation.SystemApi"
+const val ANDROID_TEST_API = "android.annotation.TestApi"
+const val ANDROID_FLAGGED_API = "android.annotation.FlaggedApi"
+
 const val ANDROIDX_ANNOTATION_PREFIX = "androidx.annotation."
 const val ANDROIDX_INT_DEF = "androidx.annotation.IntDef"
 const val ANDROIDX_LONG_DEF = "androidx.annotation.LongDef"
 const val ANDROIDX_STRING_DEF = "androidx.annotation.StringDef"
 
+const val ANDROID_NULLABLE = "android.annotation.Nullable"
+const val ANDROID_NONNULL = "android.annotation.NonNull"
 const val ANDROIDX_NONNULL = "androidx.annotation.NonNull"
 const val ANDROIDX_NULLABLE = "androidx.annotation.Nullable"
+const val RECENTLY_NULLABLE = "androidx.annotation.RecentlyNullable"
+const val RECENTLY_NONNULL = "androidx.annotation.RecentlyNonNull"
 
 const val ANDROID_DEPRECATED_FOR_SDK = "android.annotation.DeprecatedForSdk"
 
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationInfo.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationInfo.kt
index b66e1f679..6bdc831df 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationInfo.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationInfo.kt
@@ -22,15 +22,11 @@ package com.android.tools.metalava.model
  * Instances of [AnnotationInfo] will be shared across [AnnotationItem]s that have the same
  * qualified name and (where applicable) the same attributes. That will allow the information in
  * [AnnotationInfo] to be computed once and then reused whenever needed.
- *
- * This class just sets the properties that can be determined simply by looking at the
- * [qualifiedName]. Any other properties are set to the default, usually `false`. Subclasses can
- * change that behavior.
  */
-open class AnnotationInfo(
-    /** The fully qualified and normalized name of the annotation class. */
-    val qualifiedName: String,
-) {
+interface AnnotationInfo {
+
+    /** The applicable targets for this annotation */
+    val targets: Set<AnnotationTarget>
 
     /**
      * Determines whether the annotation is nullability related.
@@ -38,24 +34,25 @@ open class AnnotationInfo(
      * If this is null then the annotation is not a nullability annotation, otherwise this
      * determines whether it is nullable or non-null.
      */
-    internal val typeNullability: TypeNullability? =
-        when {
-            isNullableAnnotation(qualifiedName) -> TypeNullability.NULLABLE
-            isNonNullAnnotation(qualifiedName) -> TypeNullability.NONNULL
-            else -> null
-        }
+    val typeNullability: TypeNullability?
 
     /**
      * Determines whether this annotation affects whether the annotated item is shown or hidden and
      * if so how.
      */
-    open val showability: Showability
-        get() = Showability.NO_EFFECT
+    val showability: Showability
 
-    open val suppressCompatibility: Boolean
-        get() = false
+    val suppressCompatibility: Boolean
 }
 
+/** Compute the [TypeNullability], if any, for the annotation with [qualifiedName]. */
+internal fun computeTypeNullability(qualifiedName: String): TypeNullability? =
+    when {
+        isNullableAnnotation(qualifiedName) -> TypeNullability.NULLABLE
+        isNonNullAnnotation(qualifiedName) -> TypeNullability.NONNULL
+        else -> null
+    }
+
 /**
  * The set of possible effects on whether an `Item` is part of an API.
  *
@@ -85,12 +82,12 @@ enum class ShowOrHide(private val show: Boolean?) {
          * If the [revertItem] is not null and `emit = true`, i.e. is for the API surface currently
          * being generated, then reverting will still show this item.
          */
-        override fun show(revertItem: Item?): Boolean {
+        override fun show(revertItem: SelectableItem?): Boolean {
             return revertItem != null && revertItem.emit
         }
 
         /** If the [revertItem] is null then reverting will hide this item. */
-        override fun hide(revertItem: Item?): Boolean {
+        override fun hide(revertItem: SelectableItem?): Boolean {
             return revertItem == null
         }
     },
@@ -103,7 +100,7 @@ enum class ShowOrHide(private val show: Boolean?) {
      *   reverted. This is only set for, and only has an effect on, [REVERT_UNSTABLE_API], see
      *   [REVERT_UNSTABLE_API.show] for details.
      */
-    open fun show(revertItem: Item?): Boolean = show == true
+    open fun show(revertItem: SelectableItem?): Boolean = show == true
 
     /**
      * Return true if this hides an `Item` from the API.
@@ -112,30 +109,31 @@ enum class ShowOrHide(private val show: Boolean?) {
      *   reverted. This is only set for, and only has an effect on, [REVERT_UNSTABLE_API], see
      *   [REVERT_UNSTABLE_API.show] for details.
      */
-    open fun hide(revertItem: Item?): Boolean = show == false
+    open fun hide(revertItem: SelectableItem?): Boolean = show == false
 
     /** Return the highest priority between this and another [ShowOrHide]. */
     fun highestPriority(other: ShowOrHide): ShowOrHide = maxOf(this, other)
 }
 
 /**
- * Determines how an annotation will affect whether [Item]s annotated with it are part of the API or
- * not and also determines whether an [Item] is part of the API or not.
+ * Determines how an annotation will affect whether [SelectableItem]s annotated with it are part of
+ * the API or not and also determines whether a [SelectableItem] is part of the API or not.
  */
 data class Showability(
     /**
-     * Determines whether an API [Item] is shown as part of the API or hidden from the API.
+     * Determines whether an API [SelectableItem] is shown as part of the API or hidden from the
+     * API.
      *
-     * If [ShowOrHide.show] is `true` then the annotated [Item] will be shown as part of the API.
-     * That is the case for annotations that match `--show-annotation`, or
+     * If [ShowOrHide.show] is `true` then the annotated [SelectableItem] will be shown as part of
+     * the API. That is the case for annotations that match `--show-annotation`, or
      * `--show-single-annotation`, but not `--show-for-stub-purposes-annotation`.
      *
-     * If [ShowOrHide.hide] is `true` then the annotated [Item] will NOT be shown as part of the
-     * API. That is the case for annotations that match `--hide-annotation`.
+     * If [ShowOrHide.hide] is `true` then the annotated [SelectableItem] will NOT be shown as part
+     * of the API. That is the case for annotations that match `--hide-annotation`.
      *
-     * If neither of the above is then this has no effect on whether an annotated [Item] will be
-     * shown or not, that decision will be determined by its container's [Showability.recursive]
-     * setting.
+     * If neither of the above is then this has no effect on whether an annotated [SelectableItem]
+     * will be shown or not, that decision will be determined by its container's
+     * [Showability.recursive] setting.
      */
     private val show: ShowOrHide,
 
@@ -166,7 +164,7 @@ data class Showability(
     private val forStubsOnly: ShowOrHide,
 
     /** The item to which this item should be reverted. Null if no such item exists. */
-    val revertItem: Item? = null,
+    val revertItem: SelectableItem? = null,
 ) {
     /**
      * Check whether the annotated item should be considered part of the API or not.
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationItem.kt
index 354a02cd3..f9fb82a40 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationItem.kt
@@ -394,14 +394,13 @@ protected constructor(
     attributesGetter: () -> List<AnnotationAttribute>,
 ) : AnnotationItem {
 
-    override val targets: Set<AnnotationTarget> by lazy {
-        codebase.annotationManager.computeTargets(this, codebase::findClass)
-    }
+    override val targets
+        get() = info.targets
 
     final override val attributes: List<AnnotationAttribute> by lazy(attributesGetter)
 
     /** Information that metalava has gathered about this annotation item. */
-    val info: AnnotationInfo by lazy { codebase.annotationManager.getAnnotationInfo(this) }
+    internal val info: AnnotationInfo by lazy { codebase.annotationManager.getAnnotationInfo(this) }
 
     override val typeNullability: TypeNullability?
         get() = info.typeNullability
@@ -441,6 +440,14 @@ protected constructor(
     override fun isShowabilityAnnotation(): Boolean = info.showability != Showability.NO_EFFECT
 
     override fun snapshot(targetCodebase: Codebase): AnnotationItem {
+        // Force the info property to be initialized which will cause the AnnotationInfo for
+        // annotations of the same class as this to be created based off this AnnotationItem and
+        // not the snapshot AnnotationItem. That is important because the AnnotationInfo
+        // properties depends on accessing information like the ApiVariantSelectors which is
+        // discarded when creating the snapshot. The snapshot AnnotationItem will retrieve the
+        // cached version of the AnnotationInfo from the AnnotationManager.
+        info
+
         return DefaultAnnotationItem(
             targetCodebase,
             fileLocation,
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationManager.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationManager.kt
index c712fd4b1..bcebd3886 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationManager.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/AnnotationManager.kt
@@ -38,12 +38,6 @@ interface AnnotationManager {
         target: AnnotationTarget = AnnotationTarget.SIGNATURE_FILE
     ): String?
 
-    /** Get the applicable targets for the annotation */
-    fun computeTargets(
-        annotation: AnnotationItem,
-        classFinder: (String) -> ClassItem?
-    ): Set<AnnotationTarget>
-
     /** Returns true if [annotationName] is the name of one of the show annotations. */
     fun isShowAnnotationName(annotationName: String): Boolean = false
 
@@ -55,14 +49,14 @@ interface AnnotationManager {
     fun hasAnyStubPurposesAnnotations(): Boolean = false
 
     /**
-     * Get the [Showability] for the supplied [Item].
+     * Get the [Showability] for the supplied [SelectableItem].
      *
      * This combines the [Showability] of all the annotations of this item and returns the result.
      *
      * If the annotations on the item conflict then this could throw an exception or report an error
      * as appropriate.
      */
-    fun getShowabilityForItem(item: Item): Showability = Showability.NO_EFFECT
+    fun getShowabilityForItem(item: SelectableItem): Showability = Showability.NO_EFFECT
 
     /**
      * Checks to see if the modifiers contain any hide annotations.
@@ -132,7 +126,7 @@ abstract class BaseAnnotationManager : AnnotationManager {
      * Note: it is safe to use `annotationItem.qualifiedName!!` as [AnnotationItem.qualifiedName] is
      * guaranteed not to be `null` when this method is called.
      */
-    protected abstract fun computeAnnotationInfo(annotationItem: AnnotationItem): AnnotationInfo
+    internal abstract fun computeAnnotationInfo(annotationItem: AnnotationItem): AnnotationInfo
 }
 
 /**
@@ -153,7 +147,7 @@ internal class NoOpAnnotationManager : BaseAnnotationManager() {
     }
 
     override fun computeAnnotationInfo(annotationItem: AnnotationItem): AnnotationInfo {
-        return AnnotationInfo(annotationItem.qualifiedName)
+        return NoOpAnnotationInfo(annotationItem.qualifiedName)
     }
 
     override fun normalizeInputName(qualifiedName: String?): String? {
@@ -164,12 +158,30 @@ internal class NoOpAnnotationManager : BaseAnnotationManager() {
         return qualifiedName
     }
 
-    override fun computeTargets(
-        annotation: AnnotationItem,
-        classFinder: (String) -> ClassItem?
-    ): Set<AnnotationTarget> = ANNOTATION_IN_ALL_STUBS
-
     override val typedefMode: TypedefMode = TypedefMode.NONE
 }
 
+/**
+ * [AnnotationInfo] implementation used by [NoOpAnnotationManager].
+ *
+ * This class just sets the properties that can be determined simply by looking at the
+ * [qualifiedName]. Any other properties are set to the default, usually `false`.
+ */
+internal class NoOpAnnotationInfo(
+    /** The fully qualified and normalized name of the annotation class. */
+    val qualifiedName: String,
+) : AnnotationInfo {
+
+    override val targets
+        get() = ANNOTATION_IN_ALL_STUBS
+
+    override val typeNullability = computeTypeNullability(qualifiedName)
+
+    override val showability
+        get() = Showability.NO_EFFECT
+
+    override val suppressCompatibility
+        get() = false
+}
+
 val noOpAnnotationManager: AnnotationManager = NoOpAnnotationManager()
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/BaseItemVisitor.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/BaseItemVisitor.kt
index 8146ed25f..fe03d3fb6 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/BaseItemVisitor.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/BaseItemVisitor.kt
@@ -23,53 +23,88 @@ open class BaseItemVisitor(
      * afterwards. Defaults to false.
      */
     val preserveClassNesting: Boolean = false,
+
+    /**
+     * Determines whether this will visit [ParameterItem]s or not.
+     *
+     * If this is `true` then [ParameterItem]s will be visited, and passed to [visitItem],
+     * [visitParameter] and [afterVisitItem] in that order. Otherwise, they will not be visited.
+     *
+     * Defaults to `true` as that is the safest option which avoids inadvertently ignoring them.
+     */
+    protected val visitParameterItems: Boolean = true,
 ) : ItemVisitor {
+    /** Calls [visitItem] before invoking [body] after which it calls [afterVisitItem]. */
+    protected inline fun <T : Item> wrapBodyWithCallsToVisitMethodsForItem(
+        item: T,
+        body: () -> Unit
+    ) {
+        visitItem(item)
+        body()
+        afterVisitItem(item)
+    }
+
+    /**
+     * Calls [visitItem], then [visitSelectableItem] before invoking [body] after which it calls
+     * [afterVisitSelectableItem] and finally [afterVisitItem].
+     */
+    protected inline fun <T : SelectableItem> wrapBodyWithCallsToVisitMethodsForSelectableItem(
+        item: T,
+        body: () -> Unit
+    ) {
+        wrapBodyWithCallsToVisitMethodsForItem(item) {
+            visitSelectableItem(item)
+            body()
+            afterVisitSelectableItem(item)
+        }
+    }
+
     override fun visit(cls: ClassItem) {
         if (skip(cls)) {
             return
         }
 
-        visitItem(cls)
-        visitClass(cls)
+        wrapBodyWithCallsToVisitMethodsForSelectableItem(cls) {
+            visitClass(cls)
 
-        for (constructor in cls.constructors()) {
-            constructor.accept(this)
-        }
+            for (constructor in cls.constructors()) {
+                constructor.accept(this)
+            }
 
-        for (method in cls.methods()) {
-            method.accept(this)
-        }
+            for (method in cls.methods()) {
+                method.accept(this)
+            }
 
-        for (property in cls.properties()) {
-            property.accept(this)
-        }
+            for (property in cls.properties()) {
+                property.accept(this)
+            }
 
-        if (cls.isEnum()) {
-            // In enums, visit the enum constants first, then the fields
-            for (field in cls.fields()) {
-                if (field.isEnumConstant()) {
-                    field.accept(this)
+            if (cls.isEnum()) {
+                // In enums, visit the enum constants first, then the fields
+                for (field in cls.fields()) {
+                    if (field.isEnumConstant()) {
+                        field.accept(this)
+                    }
                 }
-            }
-            for (field in cls.fields()) {
-                if (!field.isEnumConstant()) {
+                for (field in cls.fields()) {
+                    if (!field.isEnumConstant()) {
+                        field.accept(this)
+                    }
+                }
+            } else {
+                for (field in cls.fields()) {
                     field.accept(this)
                 }
             }
-        } else {
-            for (field in cls.fields()) {
-                field.accept(this)
-            }
-        }
 
-        if (preserveClassNesting) {
-            for (nestedCls in cls.nestedClasses()) {
-                nestedCls.accept(this)
-            }
-        } // otherwise done in visit(PackageItem)
+            if (preserveClassNesting) {
+                for (nestedCls in cls.nestedClasses()) {
+                    nestedCls.accept(this)
+                }
+            } // otherwise done in visit(PackageItem)
 
-        afterVisitClass(cls)
-        afterVisitItem(cls)
+            afterVisitClass(cls)
+        }
     }
 
     override fun visit(field: FieldItem) {
@@ -77,9 +112,7 @@ open class BaseItemVisitor(
             return
         }
 
-        visitItem(field)
-        visitField(field)
-        afterVisitItem(field)
+        wrapBodyWithCallsToVisitMethodsForSelectableItem(field) { visitField(field) }
     }
 
     override fun visit(constructor: ConstructorItem) {
@@ -98,17 +131,18 @@ open class BaseItemVisitor(
             return
         }
 
-        visitItem(callable)
-        visitCallable(callable)
+        wrapBodyWithCallsToVisitMethodsForSelectableItem(callable) {
+            visitCallable(callable)
 
-        // Call the specific visitX method for the CallableItem subclass.
-        dispatch(callable)
+            // Call the specific visitX method for the CallableItem subclass.
+            dispatch(callable)
 
-        for (parameter in callable.parameters()) {
-            parameter.accept(this)
+            if (visitParameterItems) {
+                for (parameter in callable.parameters()) {
+                    parameter.accept(this)
+                }
+            }
         }
-
-        afterVisitItem(callable)
     }
 
     /**
@@ -139,15 +173,15 @@ open class BaseItemVisitor(
             return
         }
 
-        visitItem(pkg)
-        visitPackage(pkg)
+        wrapBodyWithCallsToVisitMethodsForSelectableItem(pkg) {
+            visitPackage(pkg)
 
-        for (cls in packageClassesAsSequence(pkg)) {
-            cls.accept(this)
-        }
+            for (cls in packageClassesAsSequence(pkg)) {
+                cls.accept(this)
+            }
 
-        afterVisitPackage(pkg)
-        afterVisitItem(pkg)
+            afterVisitPackage(pkg)
+        }
     }
 
     override fun visit(parameter: ParameterItem) {
@@ -155,9 +189,7 @@ open class BaseItemVisitor(
             return
         }
 
-        visitItem(parameter)
-        visitParameter(parameter)
-        afterVisitItem(parameter)
+        wrapBodyWithCallsToVisitMethodsForItem(parameter) { visitParameter(parameter) }
     }
 
     override fun visit(property: PropertyItem) {
@@ -165,19 +197,26 @@ open class BaseItemVisitor(
             return
         }
 
-        visitItem(property)
-        visitProperty(property)
-        afterVisitItem(property)
+        wrapBodyWithCallsToVisitMethodsForSelectableItem(property) { visitProperty(property) }
     }
 
     open fun skip(item: Item): Boolean = false
 
     /**
-     * Visits the item. This is always called before other more specialized visit methods, such as
-     * [visitClass].
+     * Visits any [Item].
+     *
+     * This is always called BEFORE other more specialized visit methods, such as [visitClass].
      */
     open fun visitItem(item: Item) {}
 
+    /**
+     * Visits any [SelectableItem], i.e. everything for which [visitItem] is called except
+     * [ParameterItem]s.
+     *
+     * This is always called BEFORE other more specialized visit methods, such as [visitClass].
+     */
+    open fun visitSelectableItem(item: SelectableItem) {}
+
     open fun visitCodebase(codebase: Codebase) {}
 
     open fun visitPackage(pkg: PackageItem) {}
@@ -192,10 +231,24 @@ open class BaseItemVisitor(
 
     open fun visitField(field: FieldItem) {}
 
+    /** Visits a [ParameterItem]. */
     open fun visitParameter(parameter: ParameterItem) {}
 
     open fun visitProperty(property: PropertyItem) {}
 
+    /**
+     * Visits any [SelectableItem], i.e. everything for which [afterVisitItem] is called except
+     * [ParameterItem]s.
+     *
+     * This is always called AFTER other more specialized visit methods, such as [afterVisitClass].
+     */
+    open fun afterVisitSelectableItem(item: SelectableItem) {}
+
+    /**
+     * Visits any [Item], except for [TypeParameterItem].
+     *
+     * This is always called AFTER other more specialized visit methods, such as [afterVisitClass].
+     */
     open fun afterVisitItem(item: Item) {}
 
     open fun afterVisitCodebase(codebase: Codebase) {}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/CallableItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/CallableItem.kt
index ac6345f8c..db31e6476 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/CallableItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/CallableItem.kt
@@ -17,7 +17,6 @@
 package com.android.tools.metalava.model
 
 import java.util.Objects
-import java.util.function.Predicate
 
 /** Common to [MethodItem] and [ConstructorItem]. */
 @MetalavaApi
@@ -56,7 +55,7 @@ interface CallableItem : MemberItem, TypeParameterListOwner {
         return false
     }
 
-    fun filteredThrowsTypes(predicate: Predicate<Item>): Collection<ExceptionTypeItem> {
+    fun filteredThrowsTypes(predicate: FilterPredicate): Collection<ExceptionTypeItem> {
         if (throwsTypes().isEmpty()) {
             return emptyList()
         }
@@ -64,7 +63,7 @@ interface CallableItem : MemberItem, TypeParameterListOwner {
     }
 
     private fun filteredThrowsTypes(
-        predicate: Predicate<Item>,
+        predicate: FilterPredicate,
         throwsTypes: LinkedHashSet<ExceptionTypeItem>
     ): LinkedHashSet<ExceptionTypeItem> {
         for (exceptionType in throwsTypes()) {
@@ -201,7 +200,7 @@ interface CallableItem : MemberItem, TypeParameterListOwner {
      * Returns whether this callable has any types in its signature that does not match the given
      * filter.
      */
-    fun hasHiddenType(filterReference: Predicate<Item>): Boolean {
+    fun hasHiddenType(filterReference: FilterPredicate): Boolean {
         for (parameter in parameters()) {
             if (parameter.type().hasHiddenType(filterReference)) return true
         }
@@ -216,7 +215,7 @@ interface CallableItem : MemberItem, TypeParameterListOwner {
     }
 
     /** Checks if there is a reference to a hidden class anywhere in the type. */
-    private fun TypeItem.hasHiddenType(filterReference: Predicate<Item>): Boolean {
+    private fun TypeItem.hasHiddenType(filterReference: FilterPredicate): Boolean {
         return when (this) {
             is PrimitiveTypeItem -> false
             is ArrayTypeItem -> componentType.hasHiddenType(filterReference)
@@ -224,7 +223,12 @@ interface CallableItem : MemberItem, TypeParameterListOwner {
                 asClass()?.let { !filterReference.test(it) } == true ||
                     outerClassType?.hasHiddenType(filterReference) == true ||
                     arguments.any { it.hasHiddenType(filterReference) }
-            is VariableTypeItem -> !filterReference.test(asTypeParameter)
+            is VariableTypeItem ->
+                // There is no need to check if a type variable contains a reference to a hidden
+                // class as it is only a reference to a type parameter, and they are checked above
+                // to make sure that their type bounds do not contain a reference to a hidden
+                // class.
+                false
             is WildcardTypeItem ->
                 extendsBound?.hasHiddenType(filterReference) == true ||
                     superBound?.hasHiddenType(filterReference) == true
@@ -277,17 +281,6 @@ interface CallableItem : MemberItem, TypeParameterListOwner {
         val comparator: Comparator<CallableItem> = Comparator { o1, o2 ->
             compareCallables(o1, o2, false)
         }
-        val sourceOrderComparator: Comparator<CallableItem> = Comparator { o1, o2 ->
-            val delta = o1.sortingRank - o2.sortingRank
-            if (delta == 0) {
-                // Within a source file all the items will have unique sorting ranks, but since
-                // we copy methods in from hidden super classes it's possible for ranks to clash,
-                // and in that case we'll revert to a signature based comparison
-                comparator.compare(o1, o2)
-            } else {
-                delta
-            }
-        }
         val sourceOrderForOverloadedMethodsComparator: Comparator<CallableItem> =
             Comparator { o1, o2 ->
                 compareCallables(o1, o2, true)
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/ClassItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/ClassItem.kt
index 64b2c446f..fa0eff533 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/ClassItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/ClassItem.kt
@@ -16,8 +16,6 @@
 
 package com.android.tools.metalava.model
 
-import java.util.function.Predicate
-
 /**
  * Represents a {@link https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html Class}
  *
@@ -57,24 +55,6 @@ interface ClassItem : ClassContentItem, SelectableItem, TypeParameterListOwner {
     override val effectivelyDeprecated: Boolean
         get() = originallyDeprecated || containingClass()?.effectivelyDeprecated == true
 
-    /**
-     * The qualified name where nested classes use $ as a separator. In class foo.bar.Outer.Inner,
-     * this method will return foo.bar.Outer$Inner. (This is the name format used in ProGuard keep
-     * files for example.)
-     */
-    fun qualifiedNameWithDollarNestedClasses(): String {
-        var curr: ClassItem? = this
-        while (curr?.containingClass() != null) {
-            curr = curr.containingClass()
-        }
-
-        if (curr == null) {
-            return fullName().replace('.', '$')
-        }
-
-        return curr.containingPackage().qualifiedName() + "." + fullName().replace('.', '$')
-    }
-
     /** Returns the internal name of the class, as seen in bytecode */
     fun internalName(): String {
         var curr: ClassItem? = this
@@ -349,7 +329,7 @@ interface ClassItem : ClassContentItem, SelectableItem, TypeParameterListOwner {
      * Finds a method matching the given method that satisfies the given predicate, considering all
      * methods defined on this class and its super classes
      */
-    fun findPredicateMethodWithSuper(template: MethodItem, filter: Predicate<Item>?): MethodItem? {
+    fun findPredicateMethodWithSuper(template: MethodItem, filter: FilterPredicate?): MethodItem? {
         val method = findMethod(template, true, true)
         if (method == null) {
             return null
@@ -471,7 +451,7 @@ interface ClassItem : ClassContentItem, SelectableItem, TypeParameterListOwner {
     }
 
     /** Returns the corresponding source file, if any */
-    fun getSourceFile(): SourceFile?
+    fun sourceFile(): SourceFile?
 
     /** If this class is an annotation type, returns the retention of this class */
     fun getRetention(): AnnotationRetention
@@ -480,7 +460,7 @@ interface ClassItem : ClassContentItem, SelectableItem, TypeParameterListOwner {
      * Return superclass matching the given predicate. When a superclass doesn't match, we'll keep
      * crawling up the tree until we find someone who matches.
      */
-    fun filteredSuperclass(predicate: Predicate<Item>): ClassItem? {
+    fun filteredSuperclass(predicate: FilterPredicate): ClassItem? {
         val superClass = superClass() ?: return null
         return if (predicate.test(superClass)) {
             superClass
@@ -489,7 +469,7 @@ interface ClassItem : ClassContentItem, SelectableItem, TypeParameterListOwner {
         }
     }
 
-    fun filteredSuperClassType(predicate: Predicate<Item>): ClassTypeItem? {
+    fun filteredSuperClassType(predicate: FilterPredicate): ClassTypeItem? {
         var superClassType: ClassTypeItem? = superClassType() ?: return null
         var prev: ClassItem? = null
         while (superClassType != null) {
@@ -519,7 +499,7 @@ interface ClassItem : ClassContentItem, SelectableItem, TypeParameterListOwner {
      * matching method in an ancestor class.
      */
     fun filteredMethods(
-        predicate: Predicate<Item>,
+        predicate: FilterPredicate,
         includeSuperClassMethods: Boolean = false
     ): Collection<MethodItem> {
         val methods = LinkedHashSet<MethodItem>()
@@ -540,7 +520,7 @@ interface ClassItem : ClassContentItem, SelectableItem, TypeParameterListOwner {
     }
 
     /** Returns the constructors that match the given predicate */
-    fun filteredConstructors(predicate: Predicate<Item>): Sequence<ConstructorItem> {
+    fun filteredConstructors(predicate: FilterPredicate): Sequence<ConstructorItem> {
         return constructors().asSequence().filter { predicate.test(it) }
     }
 
@@ -548,7 +528,7 @@ interface ClassItem : ClassContentItem, SelectableItem, TypeParameterListOwner {
      * Return fields matching the given predicate. Also clones fields from ancestors that would
      * match had they been defined in this class.
      */
-    fun filteredFields(predicate: Predicate<Item>, showUnannotated: Boolean): List<FieldItem> {
+    fun filteredFields(predicate: FilterPredicate, showUnannotated: Boolean): List<FieldItem> {
         val fields = LinkedHashSet<FieldItem>()
         if (showUnannotated) {
             for (clazz in allInterfaces()) {
@@ -608,7 +588,7 @@ interface ClassItem : ClassContentItem, SelectableItem, TypeParameterListOwner {
         return list
     }
 
-    fun filteredInterfaceTypes(predicate: Predicate<Item>): Collection<ClassTypeItem> {
+    fun filteredInterfaceTypes(predicate: FilterPredicate): Collection<ClassTypeItem> {
         val interfaceTypes =
             filteredInterfaceTypes(
                 predicate,
@@ -621,7 +601,7 @@ interface ClassItem : ClassContentItem, SelectableItem, TypeParameterListOwner {
         return interfaceTypes
     }
 
-    fun allInterfaceTypes(predicate: Predicate<Item>): Collection<TypeItem> {
+    fun allInterfaceTypes(predicate: FilterPredicate): Collection<TypeItem> {
         val interfaceTypes =
             filteredInterfaceTypes(
                 predicate,
@@ -638,7 +618,7 @@ interface ClassItem : ClassContentItem, SelectableItem, TypeParameterListOwner {
     }
 
     private fun filteredInterfaceTypes(
-        predicate: Predicate<Item>,
+        predicate: FilterPredicate,
         types: LinkedHashSet<ClassTypeItem>,
         includeSelf: Boolean,
         includeParents: Boolean,
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/Codebase.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/Codebase.kt
index 444b14b9d..f10f7e38c 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/Codebase.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/Codebase.kt
@@ -16,7 +16,8 @@
 
 package com.android.tools.metalava.model
 
-import com.android.tools.metalava.model.item.DefaultClassItem
+import com.android.tools.metalava.model.api.surface.ApiSurfaces
+import com.android.tools.metalava.reporter.BasicReporter
 import com.android.tools.metalava.reporter.Reporter
 import java.io.File
 
@@ -34,12 +35,18 @@ interface Codebase {
      */
     val location: File
 
+    /** Configuration of this [Codebase], typically comes from the command line. */
+    val config: Config
+
     /** [Reporter] to which any issues found within the [Codebase] can be reported. */
     val reporter: Reporter
 
     /** The manager of annotations within this codebase. */
     val annotationManager: AnnotationManager
 
+    /** The [ApiSurfaces] that will be tracked in this [Codebase]. */
+    val apiSurfaces: ApiSurfaces
+
     /** The packages in the codebase (may include packages that are not included in the API) */
     fun getPackages(): PackageList
 
@@ -122,18 +129,30 @@ interface Codebase {
     fun isEmpty(): Boolean {
         return getPackages().packages.isEmpty()
     }
-}
-
-sealed class MinSdkVersion
 
-data class SetMinSdkVersion(val value: Int) : MinSdkVersion()
-
-object UnsetMinSdkVersion : MinSdkVersion()
-
-interface MutableCodebase : Codebase {
     /**
-     * Register the class by name, return `true` if the class was registered and `false` if it was
-     * not, i.e. because it is a duplicate.
+     * Contains configuration for [Codebase] that can, or at least could, come from command line
+     * options.
      */
-    fun registerClass(classItem: DefaultClassItem): Boolean
+    data class Config(
+        /** Determines how annotations will affect the [Codebase]. */
+        val annotationManager: AnnotationManager,
+
+        /** The [ApiSurfaces] that will be tracked in the [Codebase]. */
+        val apiSurfaces: ApiSurfaces = ApiSurfaces.DEFAULT,
+
+        /** The reporter to use for issues found during processing of the [Codebase]. */
+        val reporter: Reporter = BasicReporter.ERR,
+    ) {
+        companion object {
+            /**
+             * A [Config] containing a [noOpAnnotationManager], [ApiSurfaces.DEFAULT] and no
+             * reporter.
+             */
+            val NOOP =
+                Config(
+                    annotationManager = noOpAnnotationManager,
+                )
+        }
+    }
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/CodebaseFragment.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/CodebaseFragment.kt
index 41fa17099..38c570d79 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/CodebaseFragment.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/CodebaseFragment.kt
@@ -17,31 +17,85 @@
 package com.android.tools.metalava.model
 
 import com.android.tools.metalava.model.snapshot.CodebaseSnapshotTaker
-import com.android.tools.metalava.model.snapshot.NonEmittableDelegatingVisitor
+import com.android.tools.metalava.model.snapshot.EmittableDelegatingVisitor
 
 /**
- * Encapsulates [codebase] to visit and a [factory] that if given a [DelegatedVisitor] will return
- * an [ItemVisitor] that can be used to visit some fragment of the [codebase].
+ * Encapsulates [codebase] to visit and a [visitorFactory] that if given a [DelegatedVisitor] will
+ * return an [ItemVisitor] that can be used to visit some fragment of the [codebase].
  */
-class CodebaseFragment(
-    val codebase: Codebase,
-    private val factory: (DelegatedVisitor) -> ItemVisitor,
-) {
+abstract class CodebaseFragment private constructor() {
+
+    /** The [Codebase] whose fragment will be visited. */
+    abstract val codebase: Codebase
+
+    /**
+     * A factory for creating an [ItemVisitor] that delegates to a [DelegatedVisitor].
+     *
+     * The [ItemVisitor] is used to determine which parts of [codebase] are considered to be defined
+     * within and emitted from this fragment.
+     */
+    protected abstract val visitorFactory: (DelegatedVisitor) -> ItemVisitor
+
     /**
      * Create an [ItemVisitor] that will visit this fragment and delegate its contents to
      * [delegate].
      */
-    fun createVisitor(delegate: DelegatedVisitor) = factory(delegate)
+    fun createVisitor(delegate: DelegatedVisitor) = visitorFactory(delegate)
 
-    /** Take a snapshot of this [CodebaseFragment] and return a new [CodebaseFragment]. */
-    fun snapshotIncludingRevertedItems(): CodebaseFragment {
-        val snapshot = CodebaseSnapshotTaker.takeSnapshot(codebase, factory)
-        return CodebaseFragment(snapshot, ::NonEmittableDelegatingVisitor)
+    /**
+     * Return a [CodebaseFragment] that will take a snapshot of this [CodebaseFragment].
+     *
+     * @param referenceVisitorFactory a factory for creating an [ItemVisitor] that delegates to a
+     *   [DelegatedVisitor]. The [ItemVisitor] is used to determine which parts of [codebase] will
+     *   be referenced from within but not emitted from the snapshot.
+     */
+    fun snapshotIncludingRevertedItems(
+        referenceVisitorFactory: (DelegatedVisitor) -> ItemVisitor,
+    ): CodebaseFragment {
+        return LazyCodebaseFragment(
+            {
+                CodebaseSnapshotTaker.takeSnapshot(
+                    codebase,
+                    definitionVisitorFactory = visitorFactory,
+                    referenceVisitorFactory = referenceVisitorFactory,
+                )
+            },
+            ::EmittableDelegatingVisitor,
+        )
     }
 
     /** Visit this fragment, delegating to [delegate]. */
     fun accept(delegate: DelegatedVisitor) {
-        val visitor = createVisitor(delegate)
+        val visitor = visitorFactory(delegate)
         codebase.accept(visitor)
     }
+
+    companion object {
+        /**
+         * Create a [CodebaseFragment] from an existing [Codebase].
+         *
+         * @param factory a factory for creating an [ItemVisitor] that delegates to a
+         *   [DelegatedVisitor]. The [ItemVisitor] is used to determine which parts of [codebase]
+         *   are considered to be defined within and emitted from this fragment.
+         */
+        fun create(
+            codebase: Codebase,
+            factory: (DelegatedVisitor) -> ItemVisitor,
+        ): CodebaseFragment = ExistingCodebaseFragment(codebase, factory)
+    }
+
+    /** A [CodebaseFragment] of an existing [Codebase]. */
+    private class ExistingCodebaseFragment(
+        override val codebase: Codebase,
+        override val visitorFactory: (DelegatedVisitor) -> ItemVisitor,
+    ) : CodebaseFragment()
+
+    /** A [CodebaseFragment] of a [Codebase] that will be provided lazily. */
+    private class LazyCodebaseFragment(
+        codebaseProvider: () -> Codebase,
+        override val visitorFactory: (DelegatedVisitor) -> ItemVisitor,
+    ) : CodebaseFragment() {
+
+        override val codebase by lazy(LazyThreadSafetyMode.NONE) { codebaseProvider() }
+    }
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/ConstructorItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/ConstructorItem.kt
index fdd2f6cf3..d1768aa28 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/ConstructorItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/ConstructorItem.kt
@@ -46,7 +46,6 @@ interface ConstructorItem : CallableItem {
 
     /** True if this is the primary constructor in Kotlin. */
     val isPrimary: Boolean
-        get() = false
 
     /**
      * True if this is a [ConstructorItem] that was created implicitly by the compiler and so does
diff --git a/metalava/src/main/java/com/android/tools/metalava/FilterPredicate.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/FilterPredicate.kt
similarity index 54%
rename from metalava/src/main/java/com/android/tools/metalava/FilterPredicate.kt
rename to metalava-model/src/main/java/com/android/tools/metalava/model/FilterPredicate.kt
index bee5de793..73f60117b 100644
--- a/metalava/src/main/java/com/android/tools/metalava/FilterPredicate.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/FilterPredicate.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2020 The Android Open Source Project
+ * Copyright (C) 2024 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,19 +14,12 @@
  * limitations under the License.
  */
 
-package com.android.tools.metalava
+package com.android.tools.metalava.model
 
-import com.android.tools.metalava.model.Item
-import com.android.tools.metalava.model.MethodItem
 import java.util.function.Predicate
 
-class FilterPredicate(private val wrapped: Predicate<Item>) : Predicate<Item> {
-
-    override fun test(method: Item): Boolean {
-        return when {
-            wrapped.test(method) -> true
-            method is MethodItem -> method.findPredicateSuperMethod(wrapped) != null
-            else -> false
-        }
-    }
-}
+/**
+ * Type alias for [Predicate]s that are generally used to filter [SelectableItem]s that are defined
+ * in the API, or can be referenced from the API.
+ */
+typealias FilterPredicate = Predicate<SelectableItem>
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/Item.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/Item.kt
index c4f082d07..312a4edb8 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/Item.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/Item.kt
@@ -38,45 +38,8 @@ interface Item : Reportable {
     /** Return the modifiers of this class */
     @MetalavaApi val modifiers: ModifierList
 
-    /**
-     * Whether this element was originally hidden with @hide/@Hide. The [hidden] property tracks
-     * whether it is *actually* hidden, since elements can be unhidden via show annotations, etc.
-     *
-     * @see variantSelectors
-     */
-    val originallyHidden: Boolean
-
-    /**
-     * Whether this element has been hidden with @hide/@Hide (or after propagation, in some
-     * containing class/pkg)
-     *
-     * @see variantSelectors
-     */
-    val hidden: Boolean
-
-    /**
-     * Tracks the properties that determine whether this [Item] will be selected for each API
-     * variant.
-     *
-     * @see originallyHidden
-     * @see hidden
-     * @see removed
-     */
-    val variantSelectors: ApiVariantSelectors
-
-    /** Whether this element will be printed in the signature file */
-    var emit: Boolean
-
     fun parent(): SelectableItem?
 
-    /**
-     * Recursive check to see if this item or any of its parents (containing class, containing
-     * package) are hidden
-     */
-    fun hidden(): Boolean {
-        return hidden || parent()?.hidden() ?: false
-    }
-
     /**
      * Recursive check to see if compatibility checks should be suppressed for this item or any of
      * its parents (containing class, containing package).
@@ -86,14 +49,6 @@ interface Item : Reportable {
             parent()?.isCompatibilitySuppressed() ?: false
     }
 
-    /**
-     * Whether this element has been removed with @removed/@Remove (or after propagation, in some
-     * containing class)
-     *
-     * @see variantSelectors
-     */
-    val removed: Boolean
-
     /** True if this item has been marked deprecated. */
     val originallyDeprecated: Boolean
 
@@ -103,9 +58,6 @@ interface Item : Reportable {
      */
     val effectivelyDeprecated: Boolean
 
-    /** True if this item is either hidden or removed */
-    fun isHiddenOrRemoved(): Boolean = hidden || removed
-
     /** Visits this element using the given [visitor] */
     fun accept(visitor: ItemVisitor)
 
@@ -201,19 +153,6 @@ interface Item : Reportable {
      */
     fun isKotlin() = itemLanguage.isKotlin()
 
-    /** Determines whether this item will be shown as part of the API or not. */
-    val showability: Showability
-
-    /**
-     * Returns true if this item has any show annotations.
-     *
-     * See [Showability.show]
-     */
-    fun hasShowAnnotation(): Boolean = showability.show()
-
-    /** Returns true if this modifier list contains any hide annotations */
-    fun hasHideAnnotation(): Boolean = codebase.annotationManager.hasHideAnnotations(modifiers)
-
     /**
      * Returns true if this [Item]'s modifier list contains any suppress compatibility
      * meta-annotations.
@@ -229,18 +168,6 @@ interface Item : Reportable {
     fun hasSuppressCompatibilityMetaAnnotation(): Boolean =
         codebase.annotationManager.hasSuppressCompatibilityMetaAnnotations(modifiers)
 
-    fun sourceFile(): SourceFile? {
-        var curr: Item? = this
-        while (curr != null) {
-            if (curr is ClassItem && curr.isTopLevelClass()) {
-                return curr.getSourceFile()
-            }
-            curr = curr.parent()
-        }
-
-        return null
-    }
-
     override val fileLocation: FileLocation
         get() = FileLocation.UNKNOWN
 
@@ -452,12 +379,12 @@ interface Item : Reportable {
 }
 
 /** Base [Item] implementation that is common to all models. */
-abstract class AbstractItem(
+abstract class DefaultItem(
+    override val codebase: Codebase,
     final override val fileLocation: FileLocation,
     final override val itemLanguage: ItemLanguage,
     modifiers: BaseModifierList,
     documentationFactory: ItemDocumentationFactory,
-    variantSelectorsFactory: ApiVariantSelectorsFactory,
 ) : Item {
 
     /**
@@ -481,37 +408,11 @@ abstract class AbstractItem(
         private set
 
     init {
-        if (documentation.contains("@deprecated") && !modifiers.isDeprecated()) {
-            mutateModifiers { setDeprecated(true) }
+        if (!modifiers.isDeprecated() && documentation.hasTagSection("@deprecated")) {
+            @Suppress("LeakingThis") mutateModifiers { setDeprecated(true) }
         }
     }
 
-    /**
-     * Create a [ApiVariantSelectors] appropriate for this [Item].
-     *
-     * The leaking of `this` is safe as the implementations do not access anything that has not been
-     * initialized.
-     */
-    override val variantSelectors = @Suppress("LeakingThis") variantSelectorsFactory(this)
-
-    /**
-     * Manually delegate to [ApiVariantSelectors.originallyHidden] as property delegates are
-     * expensive.
-     */
-    final override val originallyHidden
-        get() = variantSelectors.originallyHidden
-
-    /** Manually delegate to [ApiVariantSelectors.hidden] as property delegates are expensive. */
-    final override val hidden
-        get() = variantSelectors.hidden
-
-    /** Manually delegate to [ApiVariantSelectors.removed] as property delegates are expensive. */
-    final override val removed: Boolean
-        get() = variantSelectors.removed
-
-    final override val showability: Showability
-        get() = variantSelectors.showability
-
     final override val sortingRank: Int = nextRank.getAndIncrement()
 
     final override val originallyDeprecated
@@ -540,10 +441,6 @@ abstract class AbstractItem(
     final override val isPrivate: Boolean
         get() = modifiers.isPrivate()
 
-    final override var emit =
-        // Do not emit expect declarations in APIs.
-        !modifiers.isExpect()
-
     companion object {
         private var nextRank = AtomicInteger()
     }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/ItemDocumentation.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/ItemDocumentation.kt
index a3c70ef7b..5523eb55b 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/ItemDocumentation.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/ItemDocumentation.kt
@@ -83,9 +83,38 @@ interface ItemDocumentation : CharSequence {
      * Otherwise, if it is "@return", add the comment to the return value. Otherwise, the
      * [tagSection] is taken to be the parameter name, and the comment added as parameter
      * documentation for the given parameter.
+     *
+     * @param tagSection if specified and not a parameter name then it is expected to start with
+     *   `@`, e.g. `@deprecated`, not `deprecated`.
      */
     fun appendDocumentation(comment: String, tagSection: String?)
 
+    /**
+     * Check to see whether this has the named tag section.
+     *
+     * @param tagSection the name of the tag section, including preceding `@`.
+     */
+    fun hasTagSection(tagSection: String): Boolean {
+        val length = text.length
+        var startIndex = 0
+
+        // Scan through the documentation looking for the tag section.
+        while (startIndex < length) {
+            // Find the position of the tag section starting with the supplied name.
+            val index = text.indexOf(tagSection, startIndex)
+            if (index == -1) return false
+
+            // If the tag section is at the end of the documentation or is followed by a whitespace
+            // then it matches.
+            val nextIndex = index + tagSection.length
+            if (text.length == nextIndex || Character.isWhitespace(text[nextIndex])) return true
+
+            // Else, continue scanning from the end of the tag section.
+            startIndex = nextIndex
+        }
+        return false
+    }
+
     /**
      * Looks up docs for the first instance of a specific javadoc tag having the (optionally)
      * provided value (e.g. parameter name).
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/MethodItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/MethodItem.kt
index 789a0e998..ba8bc799a 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/MethodItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/MethodItem.kt
@@ -16,8 +16,6 @@
 
 package com.android.tools.metalava.model
 
-import java.util.function.Predicate
-
 @MetalavaApi
 interface MethodItem : CallableItem, InheritableItem {
     /**
@@ -81,7 +79,7 @@ interface MethodItem : CallableItem, InheritableItem {
      */
     override fun duplicate(targetContainingClass: ClassItem): MethodItem
 
-    fun findPredicateSuperMethod(predicate: Predicate<Item>): MethodItem? {
+    fun findPredicateSuperMethod(predicate: FilterPredicate): MethodItem? {
         val superMethods = superMethods()
         for (method in superMethods) {
             if (predicate.test(method)) {
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/ModifierListWriter.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/ModifierListWriter.kt
index 97b9f09df..3b107e59b 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/ModifierListWriter.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/ModifierListWriter.kt
@@ -248,9 +248,6 @@ private constructor(
         if (item !is PackageItem) {
             val writeDeprecated =
                 when {
-                    // Do not write @Deprecated for a removed item unless it was explicitly marked
-                    // as deprecated.
-                    item.removed -> item.originallyDeprecated
                     // Do not write @Deprecated for a parameter unless it was explicitly marked
                     // as deprecated.
                     item is ParameterItem -> item.originallyDeprecated
diff --git a/metalava/src/main/java/com/android/tools/metalava/PackageFilter.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/PackageFilter.kt
similarity index 59%
rename from metalava/src/main/java/com/android/tools/metalava/PackageFilter.kt
rename to metalava-model/src/main/java/com/android/tools/metalava/model/PackageFilter.kt
index 25daa2cc6..e85bdde95 100644
--- a/metalava/src/main/java/com/android/tools/metalava/PackageFilter.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/PackageFilter.kt
@@ -1,32 +1,40 @@
-package com.android.tools.metalava
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model
 
-import com.android.tools.metalava.cli.common.MetalavaCliException
-import com.android.tools.metalava.model.PackageItem
 import java.io.File
 import java.util.function.Predicate
 
 /**
- * We permit a number of different styles:
+ * Checks to see if a package name matches a set of configured rules.
+ *
+ * This supports a number of rule styles:
  * - exact match (foo)
  * - prefix match (foo*, probably not intentional)
- * - subpackage match (foo.*)
- * - package and subpackage match (foo:foo.*)
+ * - package and subpackage match (foo.*)
  * - explicit addition (+foo.*)
  * - subtraction (+*:-foo.*)
  *
  * Real examples: args: "-stubpackages com.android.test.power ", args: "-stubpackages android.car*
  * ", args: "-stubpackages com.android.ahat:com.android.ahat.*", args:
  * "-force-convert-to-warning-nullability-annotations +*:-android.*:+android.icu.*:-dalvik.*
- *
- * Note that doclava does *not* include subpackages by default: -stubpackage foo will match only
- * foo, not foo.bar. Note also that "foo.*" will not match "foo", so doclava required you to supply
- * both: "foo:foo.*".
- *
- * In metalava we've changed that: it's not likely that you want to match any subpackage of foo but
- * not foo itself, so foo.* is taken to mean "foo" and "foo.*".
  */
 class PackageFilter {
-    val components: MutableList<PackageFilterComponent> = mutableListOf()
+    private val components: MutableList<PackageFilterComponent> = mutableListOf()
 
     fun matches(qualifiedName: String): Boolean {
         for (component in components.reversed()) {
@@ -37,16 +45,15 @@ class PackageFilter {
         return false
     }
 
-    fun addPackages(path: String) {
+    internal fun addPackages(path: String) {
         for (arg in path.split(File.pathSeparatorChar)) {
             val treatAsPositiveMatch = !arg.startsWith("-")
             val pkg = arg.removePrefix("-").removePrefix("+")
             val index = pkg.indexOf('*')
             if (index != -1) {
                 if (index < pkg.length - 1) {
-                    throw MetalavaCliException(
-                        stderr =
-                            "Wildcards in stub packages must be at the end of the package: $pkg)"
+                    throw IllegalStateException(
+                        "Wildcards in stub packages must be at the end of the package: $pkg"
                     )
                 }
                 val prefix = pkg.removeSuffix("*")
@@ -62,7 +69,7 @@ class PackageFilter {
         }
     }
 
-    fun add(predicate: Predicate<String>, treatAsPositiveMatch: Boolean) {
+    private fun add(predicate: Predicate<String>, treatAsPositiveMatch: Boolean) {
         components.add(PackageFilterComponent(predicate, treatAsPositiveMatch))
     }
 
@@ -79,20 +86,23 @@ class PackageFilter {
     }
 }
 
-class StringPrefixPredicate(private val acceptedPrefix: String) : Predicate<String> {
+internal class StringPrefixPredicate(private val acceptedPrefix: String) : Predicate<String> {
     override fun test(candidatePackage: String): Boolean {
         return candidatePackage.startsWith(acceptedPrefix)
     }
 }
 
-class StringEqualsPredicate(val acceptedPackage: String) : Predicate<String> {
+internal class StringEqualsPredicate(private val acceptedPackage: String) : Predicate<String> {
     override fun test(candidatePackage: String): Boolean {
         return candidatePackage == acceptedPackage
     }
 }
 
 /**
- * One element of a PackageFilter. Detects packages and either either includes or excludes them from
- * the filter
+ * One element of a PackageFilter. Detects packages and either includes or excludes them from the
+ * filter
  */
-class PackageFilterComponent(val filter: Predicate<String>, val treatAsPositiveMatch: Boolean)
+internal class PackageFilterComponent(
+    val filter: Predicate<String>,
+    val treatAsPositiveMatch: Boolean,
+)
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/SelectableItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/SelectableItem.kt
index 62d75f9c1..b2afa5ad3 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/SelectableItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/SelectableItem.kt
@@ -16,6 +16,10 @@
 
 package com.android.tools.metalava.model
 
+import com.android.tools.metalava.model.api.surface.ApiVariant
+import com.android.tools.metalava.model.api.surface.ApiVariantSet
+import com.android.tools.metalava.model.api.surface.MutableApiVariantSet
+
 /**
  * An [Item] that can be selected to be a part of an API in its own right.
  *
@@ -27,6 +31,83 @@ package com.android.tools.metalava.model
  * an indivisible part of the [ParameterItem.containingCallable].
  */
 interface SelectableItem : Item {
-    // At the moment this is a marker interface but over time more functionality related to
-    // selection will be migrated here, e.g. [Item.hidden] and related members.
+    /** The [ApiVariant]s for which this [Item] has been selected. */
+    var selectedApiVariants: ApiVariantSet
+
+    /**
+     * Mutate [selectedApiVariants].
+     *
+     * Provides a [MutableApiVariantSet] of the [selectedApiVariants] that can be modified by
+     * [mutator]. Once the mutator exits [selectedApiVariants] will be updated. The
+     * [MutableApiVariantSet] must not be accessed from outside [mutator].
+     */
+    fun mutateSelectedApiVariants(mutator: MutableApiVariantSet.() -> Unit)
+
+    /** Whether this element will be printed in the signature file */
+    var emit: Boolean
+
+    /**
+     * Whether this element was originally hidden with @hide/@Hide. The [hidden] property tracks
+     * whether it is *actually* hidden, since elements can be unhidden via show annotations, etc.
+     *
+     * @see variantSelectors
+     */
+    val originallyHidden: Boolean
+
+    /**
+     * Whether this element has been hidden with @hide/@Hide (or after propagation, in some
+     * containing class/pkg)
+     *
+     * @see variantSelectors
+     */
+    val hidden: Boolean
+
+    /**
+     * Tracks the properties that determine whether this [Item] will be selected for each API
+     * variant.
+     *
+     * @see originallyHidden
+     * @see hidden
+     * @see removed
+     */
+    val variantSelectors: ApiVariantSelectors
+
+    /**
+     * Recursive check to see if this item or any of its parents (containing class, containing
+     * package) are hidden
+     */
+    fun hidden(): Boolean {
+        return hidden || parent()?.hidden() ?: false
+    }
+
+    /**
+     * Whether this element has been removed with @removed/@Remove (or after propagation, in some
+     * containing class)
+     *
+     * @see variantSelectors
+     */
+    val removed: Boolean
+
+    /** True if this item is either hidden or removed */
+    fun isHiddenOrRemoved(): Boolean = hidden || removed
+
+    /** Determines whether this item will be shown as part of the API or not. */
+    val showability: Showability
+
+    /**
+     * Returns true if this item has any show annotations.
+     *
+     * See [Showability.show]
+     */
+    fun hasShowAnnotation(): Boolean = showability.show()
+
+    /** Returns true if this modifier list contains any hide annotations */
+    fun hasHideAnnotation(): Boolean = codebase.annotationManager.hasHideAnnotations(modifiers)
+
+    /** Override to specialize return type. */
+    override fun findCorrespondingItemIn(
+        codebase: Codebase,
+        superMethods: Boolean,
+        duplicate: Boolean,
+    ): SelectableItem?
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/SourceFile.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/SourceFile.kt
index cc22ee0e7..36ffb3880 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/SourceFile.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/SourceFile.kt
@@ -17,7 +17,6 @@
 package com.android.tools.metalava.model
 
 import java.util.TreeSet
-import java.util.function.Predicate
 
 /** Represents a Kotlin/Java source file */
 interface SourceFile {
@@ -30,7 +29,7 @@ interface SourceFile {
     fun getImports() = getImports { true }
 
     /** Get only those imports that reference [Item]s for which [predicate] returns `true`. */
-    fun getImports(predicate: Predicate<Item>): Collection<Import> = emptyList()
+    fun getImports(predicate: FilterPredicate): Collection<Import> = emptyList()
 
     /**
      * Compute set of import statements that are actually referenced from the documentation (we do
@@ -38,7 +37,7 @@ interface SourceFile {
      * some extras). This isn't a big problem since our code style forbids/discourages wildcards, so
      * it shows up in fewer places, but we need to handle it when it does -- such as in ojluni.
      */
-    fun filterImports(imports: TreeSet<Import>, predicate: Predicate<Item>): TreeSet<Import> {
+    fun filterImports(imports: TreeSet<Import>, predicate: FilterPredicate): TreeSet<Import> {
         // Create a map from the short name for the import to a list of the items imported. A
         // list is needed because classes and members could be imported with the same short
         // name.
@@ -54,6 +53,8 @@ interface SourceFile {
             cls.accept(
                 object : TraversingVisitor() {
                     override fun visitItem(item: Item): TraversalAction {
+                        if (item !is SelectableItem) return TraversalAction.SKIP_CHILDREN
+
                         // Do not let documentation on hidden items affect the imports.
                         if (!predicate.test(item)) {
                             // Just because an item like a class is hidden does not mean
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeItem.kt
index b4df2b079..08084da92 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeItem.kt
@@ -17,7 +17,6 @@
 package com.android.tools.metalava.model
 
 import java.util.Objects
-import java.util.function.Predicate
 
 /**
  * Whether metalava supports type use annotations. Note that you can't just turn this flag back on;
@@ -67,18 +66,10 @@ interface TypeItem {
     /**
      * Generates a string for this type.
      *
-     * @param annotations For a type like this: @Nullable java.util.List<@NonNull java.lang.String>,
-     *   [annotations] controls whether the annotations like @Nullable and @NonNull are included.
-     * @param kotlinStyleNulls Controls whether it should return "@Nullable List<String>" as
-     *   "List<String!>?".
-     * @param spaceBetweenParameters Controls whether there should be a space between class type
-     *   parameters, e.g. "java.util.Map<java.lang.Integer, java.lang.Number>" or
-     *   "java.util.Map<java.lang.Integer,java.lang.Number>".
+     * @see [TypeStringConfiguration] for information on the parameters.
      */
     fun toTypeString(
-        annotations: Boolean = false,
-        kotlinStyleNulls: Boolean = false,
-        spaceBetweenParameters: Boolean = false
+        configuration: TypeStringConfiguration = TypeStringConfiguration.DEFAULT
     ): String
 
     /**
@@ -98,26 +89,14 @@ interface TypeItem {
 
     fun asClass(): ClassItem?
 
-    fun toSimpleType(): String {
-        return stripJavaLangPrefix(toTypeString())
-    }
+    fun toSimpleType() = toTypeString(SIMPLE_TYPE_CONFIGURATION)
 
     /**
      * Helper methods to compare types, especially types from signature files with types from
      * parsing, which may have slightly different formats, e.g. varargs ("...") versus arrays
      * ("[]"), java.lang. prefixes removed in wildcard signatures, etc.
      */
-    fun toCanonicalType(): String {
-        var s = toTypeString()
-        while (s.contains(JAVA_LANG_PREFIX)) {
-            s = s.replace(JAVA_LANG_PREFIX, "")
-        }
-        if (s.contains("...")) {
-            s = s.replace("...", "[]")
-        }
-
-        return s
-    }
+    fun toCanonicalType() = toTypeString(CANONICAL_TYPE_CONFIGURATION)
 
     /**
      * Makes substitutions to the type based on the [typeParameterBindings]. For instance, if the
@@ -182,44 +161,24 @@ interface TypeItem {
     fun transform(transformer: TypeTransformer): TypeItem
 
     companion object {
+        /** [TypeStringConfiguration] for [toSimpleType] to pass to [toTypeString]. */
+        private val SIMPLE_TYPE_CONFIGURATION =
+            TypeStringConfiguration(stripJavaLangPrefix = StripJavaLangPrefix.LEGACY)
+
+        /** [TypeStringConfiguration] for [toCanonicalType] to pass to [toTypeString]. */
+        private val CANONICAL_TYPE_CONFIGURATION =
+            TypeStringConfiguration(
+                stripJavaLangPrefix = StripJavaLangPrefix.ALWAYS,
+                treatVarargsAsArray = true,
+            )
+
         /** Shortens types, if configured */
         fun shortenTypes(type: String): String {
             var cleaned = type
             if (cleaned.contains("@androidx.annotation.")) {
                 cleaned = cleaned.replace("@androidx.annotation.", "@")
             }
-            return stripJavaLangPrefix(cleaned)
-        }
-
-        /**
-         * Removes java.lang. prefixes from types, unless it's in a subpackage such as
-         * java.lang.reflect. For simplicity we may also leave nested classes in the java.lang
-         * package untouched.
-         *
-         * NOTE: We only remove this from the front of the type; e.g. we'll replace
-         * java.lang.Class<java.lang.String> with Class<java.lang.String>. This is because the
-         * signature parsing of types is not 100% accurate and we don't want to run into trouble
-         * with more complicated generic type signatures where we end up not mapping the simplified
-         * types back to the real fully qualified type names.
-         */
-        fun stripJavaLangPrefix(type: String): String {
-            if (type.startsWith(JAVA_LANG_PREFIX)) {
-                // Replacing java.lang is harder, since we don't want to operate in sub packages,
-                // e.g. java.lang.String -> String, but java.lang.reflect.Method -> unchanged
-                val start = JAVA_LANG_PREFIX.length
-                val end = type.length
-                for (index in start until end) {
-                    if (type[index] == '<') {
-                        return type.substring(start)
-                    } else if (type[index] == '.') {
-                        return type
-                    }
-                }
-
-                return type.substring(start)
-            }
-
-            return type
+            return cleaned
         }
 
         /**
@@ -360,6 +319,33 @@ interface TypeItem {
     }
 }
 
+/** Different ways of handling `java.lang.` prefix stripping in [TypeItem.toTypeString]. */
+enum class StripJavaLangPrefix {
+    /** Never strip java.lang. prefixes when */
+    NEVER,
+
+    /**
+     * Only strip java.lang. prefixes from the start of the type as long as they are not a generic
+     * varargs parameter.
+     *
+     * This is legacy behavior from when types were treated as strings.
+     */
+    LEGACY,
+
+    /**
+     * A special value that is only used internally within [TypeItem.toTypeString].
+     *
+     * If [LEGACY] was provided for a varargs type then [LEGACY] will be replaced by this when
+     * processing the [ArrayTypeItem] to indicate to the nested [ClassTypeItem] that it is a varargs
+     * parameter and to only strip the `java.lang.` prefix if it is at the start and is a generic
+     * type.
+     */
+    VARARGS,
+
+    /** Always strip java.lang. prefixes from the type. */
+    ALWAYS,
+}
+
 /**
  * A mapping from one class's type parameters to the types provided for those type parameters in a
  * possibly indirect subclass.
@@ -383,33 +369,30 @@ abstract class DefaultTypeItem(
 
     override fun toString(): String = toTypeString()
 
-    override fun toTypeString(
-        annotations: Boolean,
-        kotlinStyleNulls: Boolean,
-        spaceBetweenParameters: Boolean
-    ): String {
-        return toTypeString(
-            TypeStringConfiguration(annotations, kotlinStyleNulls, spaceBetweenParameters)
-        )
-    }
-
-    private fun toTypeString(configuration: TypeStringConfiguration): String {
+    override fun toTypeString(configuration: TypeStringConfiguration): String {
         // Cache the default type string. Other configurations are less likely to be reused.
         return if (configuration.isDefault) {
             if (!::cachedDefaultType.isInitialized) {
-                cachedDefaultType = buildString {
-                    appendTypeString(this@DefaultTypeItem, configuration)
-                }
+                cachedDefaultType = generateTypeString(configuration)
             }
             cachedDefaultType
         } else {
-            buildString { appendTypeString(this@DefaultTypeItem, configuration) }
+            generateTypeString(configuration)
         }
     }
 
+    /**
+     * Generate a string representation of this type based on [configuration].
+     *
+     * The returned value will be cached if the [configuration] is the default.
+     */
+    private fun generateTypeString(configuration: TypeStringConfiguration) = buildString {
+        appendTypeString(this@DefaultTypeItem, configuration)
+    }
+
     override fun toErasedTypeString(): String {
         if (!::cachedErasedType.isInitialized) {
-            cachedErasedType = buildString { appendErasedTypeString(this@DefaultTypeItem) }
+            cachedErasedType = toTypeString(ERASED_TYPE_STRING_CONFIGURATION)
         }
         return cachedErasedType
     }
@@ -427,22 +410,11 @@ abstract class DefaultTypeItem(
     override fun hashCode(): Int = hashCodeForType()
 
     companion object {
-        /**
-         * Configuration options for how to represent a type as a string.
-         *
-         * @param annotations Whether to include annotations on the type.
-         * @param kotlinStyleNulls Whether to represent nullability with Kotlin-style suffixes: `?`
-         *   for nullable, no suffix for non-null, and `!` for platform nullability. For example,
-         *   the Java type `@Nullable List<String>` would be represented as `List<String!>?`.
-         * @param spaceBetweenParameters Whether to include a space between class type params.
-         */
-        private data class TypeStringConfiguration(
-            val annotations: Boolean = false,
-            val kotlinStyleNulls: Boolean = false,
-            val spaceBetweenParameters: Boolean = false,
-        ) {
-            val isDefault = !annotations && !kotlinStyleNulls && !spaceBetweenParameters
-        }
+        private val ERASED_TYPE_STRING_CONFIGURATION =
+            TypeStringConfiguration(
+                eraseGenerics = true,
+                treatVarargsAsArray = true,
+            )
 
         private fun StringBuilder.appendTypeString(
             type: TypeItem,
@@ -457,6 +429,24 @@ abstract class DefaultTypeItem(
                     // Primitives must be non-null.
                 }
                 is ArrayTypeItem -> {
+                    // Get the nested configuration. This replaces StripJavaLangPrefix.LEGACY
+                    // with StripJavaLangPrefix.VARARGS for a varargs type to maintain the legacy
+                    // behavior of NOT stripping java.lang. prefix from varargs parameters unless it
+                    // has type arguments.
+                    val nestedConfiguration =
+                        if (
+                            type.isVarargs &&
+                                configuration.stripJavaLangPrefix == StripJavaLangPrefix.LEGACY
+                        ) {
+                            configuration.copy(stripJavaLangPrefix = StripJavaLangPrefix.VARARGS)
+                        } else configuration
+
+                    // Compute the outermost array suffix as that can differ if it is varargs. If
+                    // this is a varargs then it must be the outermost, otherwise the outermost is
+                    // not a varargs so they will all use the same suffix.
+                    val outermostArraySuffix =
+                        if (type.isVarargs && !configuration.treatVarargsAsArray) "..." else "[]"
+
                     // The ordering of array annotations means this can't just use a recursive
                     // approach for annotated multi-dimensional arrays, but it can if annotations
                     // aren't included.
@@ -470,16 +460,18 @@ abstract class DefaultTypeItem(
                         val suffixes = arrayModifiers.map { it.nullability.suffix }.reversed()
 
                         // Print the innermost component type.
-                        appendTypeString(deepComponentType, configuration)
+                        appendTypeString(deepComponentType, nestedConfiguration)
 
                         // Print modifiers from the outermost array type in, and the array suffixes.
                         arrayModifiers.zip(suffixes).forEachIndexed { index, (modifiers, suffix) ->
                             appendAnnotations(modifiers, configuration, leadingSpace = true)
-                            // Only the outermost array can be varargs.
-                            if (index < arrayModifiers.size - 1 || !type.isVarargs) {
-                                append("[]")
+                            // The array suffix can be different on the outermost array type. The
+                            // outermost is the last in the list.
+                            if (index == arrayModifiers.lastIndex) {
+                                append(outermostArraySuffix)
                             } else {
-                                append("...")
+                                // Only the outermost array can be varargs.
+                                append("[]")
                             }
                             if (configuration.kotlinStyleNulls) {
                                 append(suffix)
@@ -487,12 +479,8 @@ abstract class DefaultTypeItem(
                         }
                     } else {
                         // Non-annotated case: just recur to the component
-                        appendTypeString(type.componentType, configuration)
-                        if (type.isVarargs) {
-                            append("...")
-                        } else {
-                            append("[]")
-                        }
+                        appendTypeString(type.componentType, nestedConfiguration)
+                        append(outermostArraySuffix)
                         if (configuration.kotlinStyleNulls) {
                             append(type.modifiers.nullability.suffix)
                         }
@@ -500,23 +488,53 @@ abstract class DefaultTypeItem(
                 }
                 is ClassTypeItem -> {
                     if (type.outerClassType != null) {
-                        appendTypeString(type.outerClassType!!, configuration)
-                        append('.')
+                        // Legacy behavior for stripping java.lang. prefixes is to not strip them
+                        // from nested classes. This replicates that by replacing LEGACY with
+                        // NEVER in the configuration used to append the type string of the
+                        // outermost class which is responsible for stripping the prefix.
+                        val nestedConfiguration =
+                            if (configuration.stripJavaLangPrefix == StripJavaLangPrefix.LEGACY)
+                                configuration.copy(stripJavaLangPrefix = StripJavaLangPrefix.NEVER)
+                            else configuration
+                        appendTypeString(type.outerClassType!!, nestedConfiguration)
+                        append(configuration.nestedClassSeparator)
                         if (configuration.annotations) {
                             appendAnnotations(type.modifiers, configuration)
                         }
                         append(type.className)
                     } else {
+                        // Check to see whether a java.lang. prefix should be stripped from the type
+                        // name.
+                        val stripJavaLangPrefix =
+                            when (configuration.stripJavaLangPrefix) {
+                                StripJavaLangPrefix.ALWAYS -> true
+                                StripJavaLangPrefix.LEGACY ->
+                                    // This should only strip if this is at the start.
+                                    isEmpty()
+                                StripJavaLangPrefix.VARARGS ->
+                                    // This should only strip if this is at the start and is a
+                                    // generic type.
+                                    isEmpty() && type.hasTypeArguments()
+                                else -> false
+                            }
+
+                        // Get the class name prefix, i.e. the part before the class's simple name
+                        // where annotations can be placed. e.g. for java.lang.String the simple
+                        // name is `String` and the prefix is `java.lang.`.
+                        val classNamePrefix = type.classNamePrefix
+
+                        // Append the class name prefix unless it is `java.lang.` and `java.lang.`
+                        // prefixes should be stripped.
+                        if (!(stripJavaLangPrefix && classNamePrefix == JAVA_LANG_PREFIX)) {
+                            append(classNamePrefix)
+                        }
                         if (configuration.annotations) {
-                            append(type.qualifiedName.substringBeforeLast(type.className))
                             appendAnnotations(type.modifiers, configuration)
-                            append(type.className)
-                        } else {
-                            append(type.qualifiedName)
                         }
+                        append(type.className)
                     }
 
-                    if (type.arguments.isNotEmpty()) {
+                    if (!configuration.eraseGenerics && type.arguments.isNotEmpty()) {
                         append("<")
                         type.arguments.forEachIndexed { index, parameter ->
                             appendTypeString(parameter, configuration)
@@ -537,7 +555,21 @@ abstract class DefaultTypeItem(
                     if (configuration.annotations) {
                         appendAnnotations(type.modifiers, configuration)
                     }
-                    append(type.name)
+                    if (configuration.eraseGenerics) {
+                        // Replace the type variable with the bounds of the type parameter.
+                        val typeParameter = type.asTypeParameter
+                        typeParameter.asErasedType()?.let { boundsType ->
+                            appendTypeString(boundsType, configuration)
+                        }
+                        // No explicit bounds were provided so use the default of java.lang.Object.
+                        ?: if (configuration.stripJavaLangPrefix == StripJavaLangPrefix.ALWAYS) {
+                                append("Object")
+                            } else {
+                                append(JAVA_LANG_OBJECT)
+                            }
+                    } else {
+                        append(type.name)
+                    }
                     if (configuration.kotlinStyleNulls) {
                         append(type.modifiers.nullability.suffix)
                     }
@@ -621,24 +653,6 @@ abstract class DefaultTypeItem(
             }
         }
 
-        private fun StringBuilder.appendErasedTypeString(type: TypeItem) {
-            when (type) {
-                is PrimitiveTypeItem -> append(type.kind.primitiveName)
-                is ArrayTypeItem -> {
-                    appendErasedTypeString(type.componentType)
-                    append("[]")
-                }
-                is ClassTypeItem -> append(type.qualifiedName)
-                is VariableTypeItem ->
-                    type.asTypeParameter.asErasedType()?.let { appendErasedTypeString(it) }
-                        ?: append(JAVA_LANG_OBJECT)
-                else ->
-                    throw IllegalStateException(
-                        "should never visit $type of type ${type.javaClass} while generating erased type string"
-                    )
-            }
-        }
-
         // Copied from doclava1
         private fun toSlashFormat(typeName: String): String {
             var name = typeName
@@ -701,6 +715,45 @@ abstract class DefaultTypeItem(
     }
 }
 
+/**
+ * Configuration options for how to represent a type as a string.
+ *
+ * @param annotations Whether to include annotations on the type.
+ * @param eraseGenerics If `true` then type parameters are ignored and type variables are replaced
+ *   with the upper bound of the type parameter.
+ * @param kotlinStyleNulls Whether to represent nullability with Kotlin-style suffixes: `?` for
+ *   nullable, no suffix for non-null, and `!` for platform nullability. For example, the Java type
+ *   `@Nullable List<String>` would be represented as `List<String!>?`.
+ * @param nestedClassSeparator The character that is used to separate a nested class from its
+ *   containing class.
+ * @param spaceBetweenParameters Whether to include a space between class type params.
+ * @param stripJavaLangPrefix Controls how `java.lang.` prefixes are removed from the types.
+ * @param treatVarargsAsArray If `false` then a varargs type will use `...` to indicate that it is a
+ *   varargs type, otherwise it will use `[]` like a normal array.
+ */
+data class TypeStringConfiguration(
+    val annotations: Boolean = false,
+    val eraseGenerics: Boolean = false,
+    val kotlinStyleNulls: Boolean = false,
+    val nestedClassSeparator: Char = '.',
+    val spaceBetweenParameters: Boolean = false,
+    val stripJavaLangPrefix: StripJavaLangPrefix = StripJavaLangPrefix.NEVER,
+    val treatVarargsAsArray: Boolean = false,
+) {
+    /**
+     * Check to see if this matches [DEFAULT].
+     *
+     * This is computed lazily to avoid the comparison against [DEFAULT] being done while creating
+     * the instance to assign to [DEFAULT] at which point [DEFAULT] would be `null`.
+     */
+    val isDefault by lazy(LazyThreadSafetyMode.NONE) { this == DEFAULT }
+
+    companion object {
+        /** The default[TypeStringConfiguration]. */
+        val DEFAULT: TypeStringConfiguration = TypeStringConfiguration()
+    }
+}
+
 /**
  * The type for [ClassTypeItem.arguments].
  *
@@ -939,6 +992,21 @@ interface ClassTypeItem : TypeItem, BoundsTypeItem, ReferenceTypeItem, Exception
      */
     val className: String
 
+    /**
+     * Get the class name prefix, i.e. the part before [className] and after which type use
+     * annotations, if any will appear.
+     *
+     * e.g. for `java.lang.String`, [className] is `String` and the prefix is `java.lang.`. For
+     * `java.util.Map.Entry` [className] is `Entry` and the prefix is `java.util.Map.`.
+     *
+     * This is the value such that [classNamePrefix] + [className] == [qualifiedName].
+     */
+    val classNamePrefix: String
+        get() {
+            val classNamePrefixEnd = qualifiedName.length - className.length
+            return qualifiedName.substring(0, classNamePrefixEnd)
+        }
+
     override val erasedClass: ClassItem?
         get() = asClass()
 
@@ -1243,7 +1311,7 @@ interface WildcardTypeItem : TypeItem, TypeArgumentTypeItem {
  * when called against the [AnnotationItem]'s [ClassItem] return by [AnnotationItem.resolve]. If
  * that returns `null` then the [AnnotationItem] will be kept.
  */
-fun typeUseAnnotationFilter(filter: Predicate<Item>): TypeTransformer =
+fun typeUseAnnotationFilter(filter: FilterPredicate): TypeTransformer =
     object : BaseTypeTransformer() {
         override fun transform(modifiers: TypeModifiers): TypeModifiers {
             if (modifiers.annotations.isEmpty()) return modifiers
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterItem.kt
index 1a621b257..0a2042b62 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/TypeParameterItem.kt
@@ -17,16 +17,17 @@
 package com.android.tools.metalava.model
 
 @MetalavaApi
-interface TypeParameterItem : Item {
+interface TypeParameterItem {
+    val codebase: Codebase
+
+    /** Return the modifiers of this class */
+    @MetalavaApi val modifiers: ModifierList
 
     /** The name of the type parameter. */
     fun name(): String
 
     /** The [VariableTypeItem] representing the type of this type parameter. */
-    override fun type(): VariableTypeItem
-
-    override fun setType(type: TypeItem) =
-        error("Cannot call setType(TypeItem) on TypeParameterItem: $this")
+    fun type(): VariableTypeItem
 
     fun typeBounds(): List<BoundsTypeItem>
 
@@ -59,52 +60,15 @@ interface TypeParameterItem : Item {
                         append(" ")
                     }
                     first = false
-                    append(bound.toTypeString(spaceBetweenParameters = true))
+                    append(bound.toTypeString(SOURCE_TYPE_STRING_CONFIGURATION))
                 }
             }
         }
     }
 
-    override fun equalsToItem(other: Any?): Boolean {
-        if (this === other) return true
-        if (other !is TypeParameterItem) return false
-
-        return name() == other.name()
-    }
-
-    override fun hashCodeForItem(): Int {
-        return name().hashCode()
+    companion object {
+        /** [TypeStringConfiguration] for use by [toSource]. */
+        private val SOURCE_TYPE_STRING_CONFIGURATION =
+            TypeStringConfiguration(spaceBetweenParameters = true)
     }
-
-    override fun toStringForItem(): String =
-        if (typeBounds().isEmpty() && !isReified()) name()
-        else
-            buildString {
-                if (isReified()) append("reified ")
-                append(name())
-                if (typeBounds().isNotEmpty()) {
-                    append(" extends ")
-                    typeBounds().joinTo(this, " & ")
-                }
-            }
-
-    // Methods from [Item] that are not needed. They will be removed in a follow-up change.
-    override fun parent() = error("Not needed for TypeParameterItem")
-
-    override val effectivelyDeprecated: Boolean
-        get() = error("Not needed for TypeParameterItem")
-
-    override fun baselineElementId() = error("Not needed for TypeParameterItem")
-
-    override fun accept(visitor: ItemVisitor) = error("Not needed for TypeParameterItem")
-
-    override fun containingPackage() = error("Not needed for TypeParameterItem")
-
-    override fun containingClass() = error("Not needed for TypeParameterItem")
-
-    override fun findCorrespondingItemIn(
-        codebase: Codebase,
-        superMethods: Boolean,
-        duplicate: Boolean,
-    ) = error("Not needed for TypeParameterItem")
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/AnnotationFilter.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/AnnotationFilter.kt
similarity index 99%
rename from metalava/src/main/java/com/android/tools/metalava/AnnotationFilter.kt
rename to metalava-model/src/main/java/com/android/tools/metalava/model/annotation/AnnotationFilter.kt
index f12b268fa..cd35adc36 100644
--- a/metalava/src/main/java/com/android/tools/metalava/AnnotationFilter.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/AnnotationFilter.kt
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.android.tools.metalava
+package com.android.tools.metalava.model.annotation
 
 import com.android.tools.metalava.model.ANNOTATION_ATTR_VALUE
 import com.android.tools.metalava.model.AnnotationArrayAttributeValue
diff --git a/metalava/src/main/java/com/android/tools/metalava/DefaultAnnotationManager.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/DefaultAnnotationManager.kt
similarity index 91%
rename from metalava/src/main/java/com/android/tools/metalava/DefaultAnnotationManager.kt
rename to metalava-model/src/main/java/com/android/tools/metalava/model/annotation/DefaultAnnotationManager.kt
index 519bb3a8e..7499a2b00 100644
--- a/metalava/src/main/java/com/android/tools/metalava/DefaultAnnotationManager.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/annotation/DefaultAnnotationManager.kt
@@ -14,14 +14,18 @@
  * limitations under the License.
  */
 
-package com.android.tools.metalava
+package com.android.tools.metalava.model.annotation
 
-import com.android.tools.metalava.DefaultAnnotationManager.Config
 import com.android.tools.metalava.model.ANDROIDX_ANNOTATION_PREFIX
 import com.android.tools.metalava.model.ANDROIDX_NONNULL
 import com.android.tools.metalava.model.ANDROIDX_NULLABLE
 import com.android.tools.metalava.model.ANDROID_ANNOTATION_PREFIX
 import com.android.tools.metalava.model.ANDROID_DEPRECATED_FOR_SDK
+import com.android.tools.metalava.model.ANDROID_FLAGGED_API
+import com.android.tools.metalava.model.ANDROID_NONNULL
+import com.android.tools.metalava.model.ANDROID_NULLABLE
+import com.android.tools.metalava.model.ANDROID_SYSTEM_API
+import com.android.tools.metalava.model.ANDROID_TEST_API
 import com.android.tools.metalava.model.ANNOTATION_EXTERNAL
 import com.android.tools.metalava.model.ANNOTATION_EXTERNAL_ONLY
 import com.android.tools.metalava.model.ANNOTATION_IN_ALL_STUBS
@@ -35,20 +39,25 @@ import com.android.tools.metalava.model.AnnotationRetention
 import com.android.tools.metalava.model.AnnotationTarget
 import com.android.tools.metalava.model.BaseAnnotationManager
 import com.android.tools.metalava.model.ClassItem
+import com.android.tools.metalava.model.ClassOrigin
 import com.android.tools.metalava.model.Codebase
-import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.FilterPredicate
 import com.android.tools.metalava.model.JAVA_LANG_PREFIX
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.ModifierList
 import com.android.tools.metalava.model.NO_ANNOTATION_TARGETS
+import com.android.tools.metalava.model.RECENTLY_NONNULL
+import com.android.tools.metalava.model.RECENTLY_NULLABLE
 import com.android.tools.metalava.model.SUPPRESS_COMPATIBILITY_ANNOTATION
+import com.android.tools.metalava.model.SelectableItem
 import com.android.tools.metalava.model.ShowOrHide
 import com.android.tools.metalava.model.Showability
 import com.android.tools.metalava.model.TypedefMode
+import com.android.tools.metalava.model.annotation.DefaultAnnotationManager.Config
+import com.android.tools.metalava.model.computeTypeNullability
 import com.android.tools.metalava.model.hasAnnotation
 import com.android.tools.metalava.model.isNonNullAnnotation
 import com.android.tools.metalava.model.isNullableAnnotation
-import java.util.function.Predicate
 
 /** The type of lambda that can construct a key from an [AnnotationItem] */
 typealias KeyFactory = (annotationItem: AnnotationItem) -> String
@@ -66,11 +75,11 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
         val suppressCompatibilityMetaAnnotations: Set<String> = emptySet(),
         val excludeAnnotations: Set<String> = emptySet(),
         val typedefMode: TypedefMode = TypedefMode.NONE,
-        val apiPredicate: Predicate<Item> = Predicate { true },
+        val apiPredicate: FilterPredicate = FilterPredicate { true },
         /**
-         * Provider of a [List] of [Codebase] objects that will be used when reverting flagged APIs.
+         * Provider of an optional [Codebase] object that will be used when reverting flagged APIs.
          */
-        val previouslyReleasedCodebasesProvider: () -> List<Codebase> = { emptyList() },
+        val previouslyReleasedCodebaseProvider: () -> Codebase? = { null },
     )
 
     /**
@@ -134,7 +143,7 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
     }
 
     override fun computeAnnotationInfo(annotationItem: AnnotationItem): AnnotationInfo {
-        return LazyAnnotationInfo(config, annotationItem)
+        return LazyAnnotationInfo(this, config, annotationItem)
     }
 
     override fun normalizeInputName(qualifiedName: String?): String? {
@@ -329,11 +338,14 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
          ANNOTATION_EXTERNAL
         else ANNOTATION_EXTERNAL_ONLY
 
-    /** The applicable targets for this annotation */
-    override fun computeTargets(
-        annotation: AnnotationItem,
-        classFinder: (String) -> ClassItem?
-    ): Set<AnnotationTarget> {
+    /**
+     * The applicable targets for the [annotation].
+     *
+     * Care must be taken to ensure that this only accesses [AnnotationItem.qualifiedName] and
+     * [AnnotationItem.resolve]. In particular, it must NOT access the attributes. That is because
+     * the result must be identical for all [AnnotationItem] instances of an annotation class.
+     */
+    internal fun computeTargets(annotation: AnnotationItem): Set<AnnotationTarget> {
         val qualifiedName = annotation.qualifiedName
         if (config.passThroughAnnotations.contains(qualifiedName)) {
             return ANNOTATION_IN_ALL_STUBS
@@ -474,7 +486,7 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
 
         // See if the annotation is pointing to an annotation class that is part of the API; if
         // not, skip it.
-        val cls = classFinder(qualifiedName) ?: return NO_ANNOTATION_TARGETS
+        val cls = annotation.resolve() ?: return NO_ANNOTATION_TARGETS
         if (!config.apiPredicate.test(cls)) {
             if (config.typedefMode != TypedefMode.NONE) {
                 if (cls.modifiers.hasAnnotation(AnnotationItem::isTypeDefAnnotation)) {
@@ -530,7 +542,7 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
         return modifiers.hasAnnotation(AnnotationItem::isSuppressCompatibilityAnnotation)
     }
 
-    override fun getShowabilityForItem(item: Item): Showability {
+    override fun getShowabilityForItem(item: SelectableItem): Showability {
         // Iterates over the annotations on the item and computes the showability for the item by
         // combining the showability of each annotation. The basic rules are:
         // * `show=true` beats `show=false`
@@ -553,7 +565,14 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
             // If any of a method's super methods are part of a unstable API that needs to be
             // reverted then treat the method as if it is too.
             val revertUnstableApi =
-                item.superMethods().any { methodItem -> methodItem.showability.revertUnstableApi() }
+                item.superMethods().any { methodItem ->
+                    methodItem.showability.revertUnstableApi() &&
+                        // Ignore overridden methods that are not part of the API being generated if
+                        // there is no previously released API as that will always result in the
+                        // overriding method being removed which can cause problems.
+                        !(methodItem.origin != ClassOrigin.COMMAND_LINE &&
+                            previouslyReleasedCodebase == null)
+                }
             if (revertUnstableApi) {
                 itemShowability =
                     itemShowability.combineWith(LazyAnnotationInfo.REVERT_UNSTABLE_API)
@@ -606,26 +625,21 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
     }
 
     /**
-     * Local cache of the previously released codebases to avoid calling the provider for every
+     * Local cache of the previously released codebase to avoid calling the provider for every
      * affected item.
      */
-    private val previouslyReleasedCodebases by
-        lazy(LazyThreadSafetyMode.NONE) { config.previouslyReleasedCodebasesProvider() }
+    private val previouslyReleasedCodebase by
+        lazy(LazyThreadSafetyMode.NONE) { config.previouslyReleasedCodebaseProvider() }
 
     /**
      * Find the item to which [item] will be reverted.
      *
-     * Searches first the previously released API (if present) and then the previously released
-     * removed API (if present).
+     * Searches the previously released API (if available).
      */
-    private fun findRevertItem(item: Item): Item? {
-        for (oldCodebase in previouslyReleasedCodebases) {
-            item.findCorrespondingItemIn(oldCodebase)?.let {
-                return it
-            }
+    private fun findRevertItem(item: SelectableItem): SelectableItem? {
+        return previouslyReleasedCodebase?.let { codebase ->
+            item.findCorrespondingItemIn(codebase)
         }
-
-        return null
     }
 
     override val typedefMode: TypedefMode = config.typedefMode
@@ -638,12 +652,20 @@ class DefaultAnnotationManager(private val config: Config = Config()) : BaseAnno
  * The properties are initialized lazily to avoid doing more work than necessary.
  */
 private class LazyAnnotationInfo(
+    private val annotationManager: DefaultAnnotationManager,
     private val config: Config,
     private val annotationItem: AnnotationItem,
-) : AnnotationInfo(annotationItem.qualifiedName) {
+) : AnnotationInfo {
+
+    private val qualifiedName = annotationItem.qualifiedName
+
+    override val targets by
+        lazy(LazyThreadSafetyMode.NONE) { annotationManager.computeTargets(annotationItem) }
+
+    override val typeNullability = computeTypeNullability(qualifiedName)
 
     /** Compute lazily to avoid doing any more work than strictly necessary. */
-    override val showability: Showability by
+    override val showability by
         lazy(LazyThreadSafetyMode.NONE) {
             // The showAnnotations filter includes all the annotation patterns that are matched by
             // the first two filters plus 0 or more additional patterns. Excluding the patterns that
@@ -728,11 +750,10 @@ private class LazyAnnotationInfo(
     }
 
     /** Resolve the [AnnotationItem] to a [ClassItem] lazily. */
-    private val annotationClass: ClassItem? by
-        lazy(LazyThreadSafetyMode.NONE, annotationItem::resolve)
+    private val annotationClass by lazy(LazyThreadSafetyMode.NONE, annotationItem::resolve)
 
     /** Flag to detect whether the [checkResolvedAnnotationClass] is in a cycle. */
-    private var isCheckingResolvedAnnotationClass: Boolean = false
+    private var isCheckingResolvedAnnotationClass = false
 
     /**
      * Check to see whether the resolved annotation class matches the supplied predicate.
@@ -765,20 +786,10 @@ private class LazyAnnotationInfo(
      *
      * This is true if this annotation is
      */
-    override val suppressCompatibility: Boolean by
+    override val suppressCompatibility by
         lazy(LazyThreadSafetyMode.NONE) {
             qualifiedName == SUPPRESS_COMPATIBILITY_ANNOTATION_QUALIFIED ||
                 config.suppressCompatibilityMetaAnnotations.contains(qualifiedName) ||
                 checkResolvedAnnotationClass { it.hasSuppressCompatibilityMetaAnnotation() }
         }
 }
-
-/**
- * Get the actual item to use, this takes into account whether the item has been reverted.
- *
- * This casts the [Showability.revertItem] to the same type as this is called upon. That is safe as,
- * if set to a non-null value the [Showability.revertItem] will always point to an [Item] of the
- * same type.
- */
-val <reified T : Item> T.actualItem: T
-    inline get() = (showability.revertItem ?: this) as T
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/api/surface/ApiSurface.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/api/surface/ApiSurface.kt
new file mode 100644
index 000000000..b65d6a7c2
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/api/surface/ApiSurface.kt
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.api.surface
+
+/** A specific API surface. */
+sealed interface ApiSurface {
+    /** The set of [ApiSurface]s to which this belongs. */
+    val surfaces: ApiSurfaces
+
+    /** The name of the surface. */
+    val name: String
+
+    /** The optional [ApiSurface] that this extends. */
+    val extends: ApiSurface?
+
+    /** True if this is the main [ApiSurface] being generated. */
+    val isMain: Boolean
+
+    /** The list of [ApiVariant]s, in the same order as [ApiVariantType]s. */
+    val variants: List<ApiVariant>
+
+    /** The set of all [ApiVariant]s in this [ApiSurface]. */
+    val variantSet: ApiVariantSet
+
+    /** Get the [ApiVariant] for [ApiVariantType] in this [ApiSurface]. */
+    fun variantFor(type: ApiVariantType): ApiVariant
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/api/surface/ApiSurfaces.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/api/surface/ApiSurfaces.kt
new file mode 100644
index 000000000..6d1cf3acd
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/api/surface/ApiSurfaces.kt
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.api.surface
+
+/** The configured set of [ApiSurface]s. */
+sealed interface ApiSurfaces {
+    /**
+     * The list of all [ApiSurface]s.
+     *
+     * If [base] is set then it comes first; [main] is always last.
+     */
+    val all: List<ApiSurface>
+
+    /** The list of all possible [ApiVariant]s. */
+    val variants: List<ApiVariant>
+
+    /** The main [ApiSurface]. */
+    val main: ApiSurface
+
+    /** The optional base [ApiSurface]. */
+    val base: ApiSurface?
+
+    /** An immutable, empty set of variants. */
+    val emptyVariantSet: ApiVariantSet
+
+    companion object {
+        /**
+         * Create an [ApiSurfaces] instance.
+         *
+         * @param needsBase if `false` (the default) then the returned [ApiSurfaces.base] property
+         *   is null, otherwise it is an [ApiSurface] that the [ApiSurfaces.main] references in its
+         *   [ApiSurface.extends] property.
+         */
+        fun create(needsBase: Boolean = false): ApiSurfaces = DefaultApiSurfaces(needsBase)
+
+        /**
+         * A default set of [ApiSurface]s.
+         *
+         * Includes [main] but not [base].
+         */
+        val DEFAULT = create()
+    }
+
+    /** Default implementation of [ApiSurfaces]. */
+    private class DefaultApiSurfaces(needsBase: Boolean) : ApiSurfaces {
+
+        override val all: List<DefaultApiSurface>
+
+        override val base: DefaultApiSurface?
+
+        override val main: DefaultApiSurface
+
+        override val variants: List<ApiVariant>
+
+        init {
+            val surfaceList = mutableListOf<DefaultApiSurface>()
+
+            // The list of all ApiVariants belonging to this. Will be populated in the
+            // DefaultApiSurface initializer.
+            val allVariants = mutableListOf<ApiVariant>()
+
+            /**
+             * Create an [ApiSurface] with the specified [name] which has an optional [extends].
+             *
+             * Adds the created [ApiSurface] to [all].
+             */
+            fun createSurface(name: String, extends: DefaultApiSurface?) =
+                DefaultApiSurface(
+                        surfaces = this,
+                        name = name,
+                        extends = extends,
+                        allVariants = allVariants,
+                    )
+                    .also { surfaceList.add(it) }
+
+            base =
+                if (needsBase)
+                    createSurface(
+                        "base",
+                        extends = null,
+                    )
+                else null
+
+            main =
+                createSurface(
+                    "main",
+                    extends = base,
+                )
+
+            all = surfaceList.toList()
+            variants = allVariants.toList()
+        }
+
+        override val emptyVariantSet: ApiVariantSet = ApiVariantSet.emptySet(this)
+    }
+
+    /**
+     * Default implementation of [ApiSurface].
+     *
+     * @param allVariants the list of all [ApiVariant]s belonging to [surfaces]. This must be
+     *   initialised with all the [ApiVariant]s belonging to this [ApiSurface].
+     */
+    private class DefaultApiSurface(
+        override val surfaces: ApiSurfaces,
+        override val name: String,
+        override val extends: DefaultApiSurface?,
+        allVariants: MutableList<ApiVariant>,
+    ) : ApiSurface {
+
+        /**
+         * Create a list of [ApiVariant]s for this surface, one for each [ApiVariantType]. Each
+         * [ApiVariant] will add themselves to the `allVariants` list that contains all the
+         * [ApiVariant]s belong to [surfaces].
+         */
+        override val variants =
+            ApiVariantType.values().map { type -> ApiVariant(this, type, allVariants) }
+
+        override val variantSet =
+            // Create an ApiVariantSet that contains all ApiVariants in this surface.
+            ApiVariantSet.build(surfaces) {
+                for (variant in variants) {
+                    add(variant)
+                }
+            }
+
+        override fun variantFor(type: ApiVariantType): ApiVariant {
+            return variants[type.ordinal]
+        }
+
+        override val isMain = name == "main"
+
+        override fun toString(): String = "ApiSurface($name)"
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/api/surface/ApiVariant.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/api/surface/ApiVariant.kt
new file mode 100644
index 000000000..545cc84fb
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/api/surface/ApiVariant.kt
@@ -0,0 +1,194 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.api.surface
+
+/** An API variant of [type] for [surface] */
+class ApiVariant(
+    /** The [ApiSurface] of which this is a variant. */
+    val surface: ApiSurface,
+
+    /** The type of this variant. */
+    val type: ApiVariantType,
+
+    /**
+     * The list of all [ApiVariant]s belonging to the owning [ApiSurfaces].
+     *
+     * This must add itself to it.
+     */
+    allVariants: MutableList<ApiVariant>,
+) {
+    /**
+     * Bit mask for this, used within [ApiVariantSet].
+     *
+     * This must be unique across all [ApiVariant]s within `allVariants` so it computes the bit
+     * based on the current size of `allVariants` and then adds itself to the list ensuring that the
+     * next [ApiVariant] will use a different bit.
+     */
+    internal val bitMask: Int = 1 shl allVariants.size.also { allVariants.add(this) }
+
+    override fun toString(): String {
+        return "${surface.name}(${type.name})"
+    }
+}
+
+/**
+ * The base set of [ApiVariant]s.
+ *
+ * Provides common query only functionality for [ApiVariantSet] and [MutableApiVariantSet].
+ */
+sealed class BaseApiVariantSet(internal val apiSurfaces: ApiSurfaces) {
+    internal abstract val bits: Int
+
+    fun isEmpty() = bits == 0
+
+    fun isNotEmpty() = bits != 0
+
+    operator fun contains(variant: ApiVariant) = (bits and variant.bitMask) != 0
+
+    /** True if this set contains any of the variants from [surface]. */
+    fun containsAny(surface: ApiSurface) = containsAny(surface.variantSet)
+
+    /** True if this set contains any of the variants from [variantSet]. */
+    fun containsAny(variantSet: ApiVariantSet): Boolean {
+        require(apiSurfaces === variantSet.apiSurfaces) {
+            "Mismatch between ApiSurfaces, this set is for $apiSurfaces, other set is for ${variantSet.apiSurfaces}"
+        }
+        return (bits and variantSet.bits) != 0
+    }
+
+    /**
+     * Get a [MutableApiVariantSet] from this.
+     *
+     * This will return the object on which it is called if that is already mutable, otherwise it
+     * will create a separate mutable copy of this.
+     */
+    abstract fun toMutable(): MutableApiVariantSet
+
+    /**
+     * Get an immutable [ApiVariantSet] from this.
+     *
+     * This will return the object on which it is called if that is already immutable, otherwise it
+     * will create a separate immutable copy of this.
+     */
+    abstract fun toImmutable(): ApiVariantSet
+
+    override fun equals(other: Any?): Boolean {
+        if (this === other) return true
+        if (other !is BaseApiVariantSet) return false
+
+        if (apiSurfaces != other.apiSurfaces) return false
+        if (bits != other.bits) return false
+
+        return true
+    }
+
+    override fun hashCode(): Int {
+        var result = apiSurfaces.hashCode()
+        result = 31 * result + bits
+        return result
+    }
+
+    override fun toString(): String {
+        return buildString {
+            append("ApiVariantSet[")
+            var separator = ""
+            for (apiSurface in apiSurfaces.all) {
+                // If this set does not contain any variants from the ApiSurface then ignore it.
+                if (!this@BaseApiVariantSet.containsAny(apiSurface)) continue
+                append(separator)
+                separator = ","
+                append(apiSurface.name)
+                append("(")
+                for (variant in apiSurface.variants) {
+                    if (variant in this@BaseApiVariantSet) append(variant.type.shortCode)
+                }
+                append(")")
+            }
+            append("]")
+        }
+    }
+}
+
+/** An immutable set of [ApiVariant]s. */
+class ApiVariantSet(apiSurfaces: ApiSurfaces, override val bits: Int) :
+    BaseApiVariantSet(apiSurfaces) {
+
+    override fun toMutable() = MutableApiVariantSet(apiSurfaces, bits)
+
+    override fun toImmutable() = this
+
+    companion object {
+        internal fun emptySet(apiSurfaces: ApiSurfaces) = ApiVariantSet(apiSurfaces, 0)
+
+        /**
+         * Build an [ApiVariantSet].
+         *
+         * Creates a [MutableApiVariantSet], calls [lambda] to modify it and then calls
+         * [MutableApiVariantSet.toImmutable] to return an immutable [ApiVariantSet].
+         *
+         * @param apiSurfaces the [ApiSurfaces] whose [ApiVariant]s it will contain.
+         * @param lambda the lambda that will be passed a [MutableApiVariantSet] to modify.
+         */
+        fun build(apiSurfaces: ApiSurfaces, lambda: MutableApiVariantSet.() -> Unit) =
+            MutableApiVariantSet(apiSurfaces).apply(lambda).toImmutable()
+    }
+}
+
+/** A mutable set of [ApiVariant]s. */
+class MutableApiVariantSet
+internal constructor(apiSurfaces: ApiSurfaces, override var bits: Int = 0) :
+    BaseApiVariantSet(apiSurfaces) {
+
+    override fun toMutable() = this
+
+    override fun toImmutable() =
+        if (bits == 0) apiSurfaces.emptyVariantSet else ApiVariantSet(apiSurfaces, bits)
+
+    /**
+     * Add [variant] to this set.
+     *
+     * This has no effect if it is already a member.
+     */
+    fun add(variant: ApiVariant) {
+        bits = bits or variant.bitMask
+    }
+
+    /**
+     * Remove [variant] from this set.
+     *
+     * This has no effect if it was not a member.
+     */
+    fun remove(variant: ApiVariant) {
+        bits = bits and variant.bitMask.inv()
+    }
+
+    /** Clear the set. */
+    fun clear() {
+        bits = 0
+    }
+
+    companion object {
+
+        /** Create a [MutableApiVariantSet] for [apiSurfaces]. */
+        fun setOf(apiSurfaces: ApiSurfaces): MutableApiVariantSet {
+            // Make sure all the variant bits can fit into an Int.
+            if (apiSurfaces.variants.count() > 30)
+                error("Too many API variants to store in the set")
+            return MutableApiVariantSet(apiSurfaces, 0)
+        }
+    }
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/api/surface/ApiVariantType.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/api/surface/ApiVariantType.kt
new file mode 100644
index 000000000..6f075bc74
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/api/surface/ApiVariantType.kt
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.api.surface
+
+import com.android.tools.metalava.model.Item
+
+/**
+ * The types of API variants.
+ *
+ * Each of these refers to a different variant of the API, where each variant has a unique set of
+ * criteria that determines which [Item]s in the API are part of the variant. e.g. [DOC_ONLY] only
+ * includes [Item]s that have `@doconly` specified. The intent is that every traversal of the API,
+ * e.g. when generating output files, will just specify the set of variants that it needs to visit.
+ *
+ * e.g. When generating the public API it will visit [CORE] in [ApiSurfaces.main] and there will be
+ * no [ApiSurfaces.base]. When generating the system API delta it will also visit [CORE] in
+ * [ApiSurfaces.main] even though there will be an [ApiSurfaces.base] (which represents the public
+ * API).
+ *
+ * Similarly, when generate the removed public API it will visit [REMOVED] in [ApiSurfaces.main] and
+ * there will be no [ApiSurfaces.base]. When generating the system API delta it will also visit
+ * [REMOVED] in [ApiSurfaces.main] even though there will be an [ApiSurfaces.base] (which represents
+ * the public API).
+ *
+ * When generating the public stubs it will visit [CORE] in [ApiSurfaces.main]. However, when
+ * generating the system stubs (which have to include the public stubs) it will visit [CORE] in both
+ * [ApiSurfaces.main] and [ApiSurfaces.base].
+ *
+ * When generating documentation stubs it will visit the same set as for stubs plus [DOC_ONLY] for
+ * each of the [ApiSurface]s.
+ */
+enum class ApiVariantType(
+    /**
+     * Used in [ApiVariantSet.toString] to reduce the size of the string representation when
+     * debugging.
+     */
+    val shortCode: Char,
+) {
+    /** The core API that is used everywhere. */
+    CORE(shortCode = 'C'),
+
+    /** The removed API items. */
+    REMOVED(shortCode = 'R'),
+
+    /** Doc stub only items. */
+    DOC_ONLY(shortCode = 'D'),
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultClassItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultClassItem.kt
index 30efa6b7e..26e18ccf8 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultClassItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultClassItem.kt
@@ -28,7 +28,6 @@ import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.ItemDocumentationFactory
 import com.android.tools.metalava.model.ItemLanguage
 import com.android.tools.metalava.model.MethodItem
-import com.android.tools.metalava.model.MutableCodebase
 import com.android.tools.metalava.model.MutableModifierList
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.PropertyItem
@@ -39,7 +38,7 @@ import com.android.tools.metalava.model.type.DefaultResolvedClassTypeItem
 import com.android.tools.metalava.reporter.FileLocation
 
 open class DefaultClassItem(
-    codebase: MutableCodebase,
+    codebase: DefaultCodebase,
     fileLocation: FileLocation,
     itemLanguage: ItemLanguage,
     modifiers: BaseModifierList,
@@ -55,7 +54,7 @@ open class DefaultClassItem(
     private var superClassType: ClassTypeItem?,
     private var interfaceTypes: List<ClassTypeItem>,
 ) :
-    DefaultItem(
+    DefaultSelectableItem(
         codebase = codebase,
         fileLocation = fileLocation,
         itemLanguage = itemLanguage,
@@ -97,7 +96,8 @@ open class DefaultClassItem(
         }
     }
 
-    override fun getSourceFile() = source
+    /** If [source] is not set and this is a nested class then try the containing class. */
+    override fun sourceFile() = source ?: containingClass?.sourceFile()
 
     final override fun containingPackage(): PackageItem = containingPackage
 
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultCodebase.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultCodebase.kt
index e40c120ce..4c5ba3bda 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultCodebase.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultCodebase.kt
@@ -22,7 +22,7 @@ import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.DefaultAnnotationItem
 import com.android.tools.metalava.model.Item
-import com.android.tools.metalava.model.MutableCodebase
+import com.android.tools.metalava.model.api.surface.ApiSurfaces
 import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.reporter.Reporter
 import java.io.File
@@ -35,12 +35,15 @@ open class DefaultCodebase(
     final override var location: File,
     description: String,
     override val preFiltered: Boolean,
-    override val annotationManager: AnnotationManager,
+    final override val config: Codebase.Config,
     private val trustedApi: Boolean,
     private val supportsDocumentation: Boolean,
-    reporter: Reporter? = null,
     val assembler: CodebaseAssembler,
-) : MutableCodebase {
+) : Codebase {
+
+    final override val annotationManager: AnnotationManager = config.annotationManager
+
+    final override val apiSurfaces: ApiSurfaces = config.apiSurfaces
 
     final override var description: String = description
         private set
@@ -55,10 +58,7 @@ open class DefaultCodebase(
         description += " [disposed]"
     }
 
-    private val optionalReporter = reporter
-
-    override val reporter: Reporter
-        get() = optionalReporter ?: unsupported("reporter is not available")
+    override val reporter: Reporter = config.reporter
 
     /** Tracks [DefaultPackageItem] use in this [Codebase]. */
     val packageTracker = PackageTracker(assembler::createPackageItem)
@@ -123,8 +123,11 @@ open class DefaultCodebase(
     final override fun findClass(className: String): ClassItem? =
         findClassInCodebase(className) ?: externalClassesByName[className]
 
-    /** Register [DefaultClassItem] with this [Codebase]. */
-    final override fun registerClass(classItem: DefaultClassItem): Boolean {
+    /**
+     * Register the class by name, return `true` if the class was registered and `false` if it was
+     * not, i.e. because it is a duplicate.
+     */
+    fun registerClass(classItem: DefaultClassItem): Boolean {
         // Check for duplicates, ignore the class if it is a duplicate.
         val qualifiedName = classItem.qualifiedName()
         val existing = allClassesByName[qualifiedName]
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultConstructorItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultConstructorItem.kt
index 6591e64aa..aa070f033 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultConstructorItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultConstructorItem.kt
@@ -49,6 +49,7 @@ open class DefaultConstructorItem(
     throwsTypes: List<ExceptionTypeItem>,
     callableBodyFactory: CallableBodyFactory,
     private val implicitConstructor: Boolean,
+    override val isPrimary: Boolean = false,
 ) :
     DefaultCallableItem(
         codebase = codebase,
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultItem.kt
deleted file mode 100644
index a4d36402e..000000000
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultItem.kt
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.tools.metalava.model.item
-
-import com.android.tools.metalava.model.AbstractItem
-import com.android.tools.metalava.model.ApiVariantSelectorsFactory
-import com.android.tools.metalava.model.BaseModifierList
-import com.android.tools.metalava.model.Codebase
-import com.android.tools.metalava.model.ItemDocumentationFactory
-import com.android.tools.metalava.model.ItemLanguage
-import com.android.tools.metalava.reporter.FileLocation
-
-/**
- * Base class that is common to models that do not incorporate their underlying model, if any, into
- * their [Item] implementations.
- */
-abstract class DefaultItem(
-    override val codebase: Codebase,
-    fileLocation: FileLocation,
-    itemLanguage: ItemLanguage,
-    modifiers: BaseModifierList,
-    documentationFactory: ItemDocumentationFactory,
-    variantSelectorsFactory: ApiVariantSelectorsFactory,
-) :
-    AbstractItem(
-        fileLocation,
-        itemLanguage,
-        modifiers,
-        documentationFactory,
-        variantSelectorsFactory,
-    ) {}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultItemFactory.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultItemFactory.kt
index cca274519..cda2d6450 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultItemFactory.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultItemFactory.kt
@@ -127,6 +127,7 @@ class DefaultItemFactory(
         throwsTypes: List<ExceptionTypeItem>,
         callableBodyFactory: CallableBodyFactory = CallableBody.UNAVAILABLE_FACTORY,
         implicitConstructor: Boolean,
+        isPrimary: Boolean = false,
     ): ConstructorItem =
         DefaultConstructorItem(
             codebase,
@@ -143,6 +144,7 @@ class DefaultItemFactory(
             throwsTypes,
             callableBodyFactory,
             implicitConstructor,
+            isPrimary,
         )
 
     /** Create a [FieldItem]. */
@@ -237,6 +239,10 @@ class DefaultItemFactory(
         name: String,
         containingClass: ClassItem,
         type: TypeItem,
+        getter: MethodItem? = null,
+        setter: MethodItem? = null,
+        constructorParameter: ParameterItem? = null,
+        backingField: FieldItem? = null,
     ): PropertyItem =
         DefaultPropertyItem(
             codebase,
@@ -248,6 +254,10 @@ class DefaultItemFactory(
             name,
             containingClass,
             type,
+            getter,
+            setter,
+            constructorParameter,
+            backingField,
         )
 
     /**
@@ -266,7 +276,6 @@ class DefaultItemFactory(
     ) =
         DefaultTypeParameterItem(
             codebase,
-            defaultItemLanguage,
             modifiers,
             name,
             isReified,
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultMemberItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultMemberItem.kt
index 0566a1cfe..158740695 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultMemberItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultMemberItem.kt
@@ -35,7 +35,7 @@ abstract class DefaultMemberItem(
     private val name: String,
     private val containingClass: ClassItem,
 ) :
-    DefaultItem(
+    DefaultSelectableItem(
         codebase = codebase,
         fileLocation = fileLocation,
         itemLanguage = itemLanguage,
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPackageItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPackageItem.kt
index 2833fb0f6..645d92367 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPackageItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPackageItem.kt
@@ -36,7 +36,7 @@ open class DefaultPackageItem(
     val containingPackage: PackageItem?,
     override val overviewDocumentation: ResourceFile?,
 ) :
-    DefaultItem(
+    DefaultSelectableItem(
         codebase = codebase,
         fileLocation = fileLocation,
         itemLanguage = itemLanguage,
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultParameterItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultParameterItem.kt
index d4a447653..6ce0fdc38 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultParameterItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultParameterItem.kt
@@ -16,11 +16,11 @@
 
 package com.android.tools.metalava.model.item
 
-import com.android.tools.metalava.model.ApiVariantSelectors
 import com.android.tools.metalava.model.ArrayTypeItem
 import com.android.tools.metalava.model.BaseModifierList
 import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.DefaultItem
 import com.android.tools.metalava.model.ItemDocumentation
 import com.android.tools.metalava.model.ItemLanguage
 import com.android.tools.metalava.model.ParameterItem
@@ -46,7 +46,6 @@ open class DefaultParameterItem(
         itemLanguage = itemLanguage,
         modifiers = modifiers,
         documentationFactory = ItemDocumentation.NONE_FACTORY,
-        variantSelectorsFactory = ApiVariantSelectors.IMMUTABLE_FACTORY,
     ),
     ParameterItem {
 
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPropertyItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPropertyItem.kt
index 0f626bdff..5317bdf6d 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPropertyItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultPropertyItem.kt
@@ -20,8 +20,11 @@ import com.android.tools.metalava.model.ApiVariantSelectorsFactory
 import com.android.tools.metalava.model.BaseModifierList
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.ItemDocumentationFactory
 import com.android.tools.metalava.model.ItemLanguage
+import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.PropertyItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.reporter.FileLocation
@@ -36,6 +39,10 @@ open class DefaultPropertyItem(
     name: String,
     containingClass: ClassItem,
     private var type: TypeItem,
+    override val getter: MethodItem?,
+    override val setter: MethodItem?,
+    override val constructorParameter: ParameterItem?,
+    override val backingField: FieldItem?,
 ) :
     DefaultMemberItem(
         codebase,
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultSelectableItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultSelectableItem.kt
new file mode 100644
index 000000000..687ab8207
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultSelectableItem.kt
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.item
+
+import com.android.tools.metalava.model.ApiVariantSelectors
+import com.android.tools.metalava.model.ApiVariantSelectorsFactory
+import com.android.tools.metalava.model.BaseModifierList
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.DefaultItem
+import com.android.tools.metalava.model.ItemDocumentationFactory
+import com.android.tools.metalava.model.ItemLanguage
+import com.android.tools.metalava.model.SelectableItem
+import com.android.tools.metalava.model.Showability
+import com.android.tools.metalava.model.api.surface.ApiVariantSet
+import com.android.tools.metalava.model.api.surface.MutableApiVariantSet
+import com.android.tools.metalava.reporter.FileLocation
+
+abstract class DefaultSelectableItem(
+    codebase: Codebase,
+    fileLocation: FileLocation,
+    itemLanguage: ItemLanguage,
+    modifiers: BaseModifierList,
+    documentationFactory: ItemDocumentationFactory,
+    variantSelectorsFactory: ApiVariantSelectorsFactory,
+) :
+    DefaultItem(
+        codebase,
+        fileLocation,
+        itemLanguage,
+        modifiers,
+        documentationFactory,
+    ),
+    SelectableItem {
+
+    final override var selectedApiVariants: ApiVariantSet = codebase.apiSurfaces.emptyVariantSet
+
+    override fun mutateSelectedApiVariants(mutator: MutableApiVariantSet.() -> Unit) {
+        val mutable = selectedApiVariants.toMutable()
+        mutable.mutator()
+        selectedApiVariants = mutable.toImmutable()
+    }
+
+    final override var emit =
+        // Do not emit expect declarations in APIs.
+        !modifiers.isExpect()
+
+    /**
+     * Create an [ApiVariantSelectors] appropriate for this [SelectableItem].
+     *
+     * The leaking of `this` is safe as the implementations do not access anything that has not been
+     * initialized.
+     */
+    override val variantSelectors = @Suppress("LeakingThis") variantSelectorsFactory(this)
+
+    /**
+     * Manually delegate to [ApiVariantSelectors.originallyHidden] as property delegates are
+     * expensive.
+     */
+    final override val originallyHidden
+        get() = variantSelectors.originallyHidden
+
+    /** Manually delegate to [ApiVariantSelectors.hidden] as property delegates are expensive. */
+    final override val hidden
+        get() = variantSelectors.hidden
+
+    /** Manually delegate to [ApiVariantSelectors.removed] as property delegates are expensive. */
+    final override val removed: Boolean
+        get() = variantSelectors.removed
+
+    final override val showability: Showability
+        get() = variantSelectors.showability
+}
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultTypeParameterItem.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultTypeParameterItem.kt
index 7cd2fdaaa..65dbdd8d4 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultTypeParameterItem.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/item/DefaultTypeParameterItem.kt
@@ -16,35 +16,24 @@
 
 package com.android.tools.metalava.model.item
 
-import com.android.tools.metalava.model.ApiVariantSelectors
 import com.android.tools.metalava.model.BaseModifierList
 import com.android.tools.metalava.model.BoundsTypeItem
 import com.android.tools.metalava.model.Codebase
-import com.android.tools.metalava.model.ItemDocumentation
-import com.android.tools.metalava.model.ItemLanguage
+import com.android.tools.metalava.model.ModifierList
 import com.android.tools.metalava.model.TypeParameterItem
 import com.android.tools.metalava.model.VariableTypeItem
 import com.android.tools.metalava.model.type.DefaultTypeModifiers
 import com.android.tools.metalava.model.type.DefaultVariableTypeItem
-import com.android.tools.metalava.reporter.FileLocation
 
 /** A [TypeParameterItem] implementation suitable for use by multiple models. */
 open class DefaultTypeParameterItem(
-    codebase: Codebase,
-    itemLanguage: ItemLanguage,
+    override val codebase: Codebase,
     modifiers: BaseModifierList,
     private val name: String,
     private val isReified: Boolean,
-) :
-    DefaultItem(
-        codebase = codebase,
-        fileLocation = FileLocation.UNKNOWN,
-        itemLanguage = itemLanguage,
-        modifiers = modifiers,
-        documentationFactory = ItemDocumentation.NONE_FACTORY,
-        variantSelectorsFactory = ApiVariantSelectors.IMMUTABLE_FACTORY,
-    ),
-    TypeParameterItem {
+) : TypeParameterItem {
+
+    final override val modifiers: ModifierList = modifiers.toImmutable()
 
     final override fun name() = name
 
@@ -67,4 +56,27 @@ open class DefaultTypeParameterItem(
     final override fun typeBounds(): List<BoundsTypeItem> = bounds
 
     final override fun isReified(): Boolean = isReified
+
+    override fun equals(other: Any?): Boolean {
+        if (this === other) return true
+        if (other !is TypeParameterItem) return false
+
+        return name() == other.name()
+    }
+
+    override fun hashCode(): Int {
+        return name().hashCode()
+    }
+
+    override fun toString(): String =
+        if (typeBounds().isEmpty() && !isReified()) name()
+        else
+            buildString {
+                if (isReified()) append("reified ")
+                append(name())
+                if (typeBounds().isNotEmpty()) {
+                    append(" extends ")
+                    typeBounds().joinTo(this, " & ")
+                }
+            }
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/CodebaseSnapshotTaker.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/CodebaseSnapshotTaker.kt
index cb9f393a0..8d0bf0811 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/CodebaseSnapshotTaker.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/CodebaseSnapshotTaker.kt
@@ -34,48 +34,43 @@ import com.android.tools.metalava.model.ModifierList
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.PropertyItem
+import com.android.tools.metalava.model.SelectableItem
 import com.android.tools.metalava.model.Showability
 import com.android.tools.metalava.model.TypeItem
-import com.android.tools.metalava.model.TypeParameterItem
 import com.android.tools.metalava.model.TypeParameterList
 import com.android.tools.metalava.model.TypeParameterListAndFactory
 import com.android.tools.metalava.model.item.DefaultClassItem
 import com.android.tools.metalava.model.item.DefaultCodebase
 import com.android.tools.metalava.model.item.DefaultCodebaseAssembler
 import com.android.tools.metalava.model.item.DefaultItemFactory
-import com.android.tools.metalava.model.item.DefaultPackageItem
 import com.android.tools.metalava.model.item.DefaultTypeParameterItem
 import com.android.tools.metalava.model.item.MutablePackageDoc
 import com.android.tools.metalava.model.item.PackageDoc
 import com.android.tools.metalava.model.item.PackageDocs
 
-/** Stack of [SnapshotTypeItemFactory] */
-internal typealias TypeItemFactoryStack = ArrayList<SnapshotTypeItemFactory>
-
-/** Push new [SnapshotTypeItemFactory] onto the top of the stack. */
-internal fun TypeItemFactoryStack.push(factory: SnapshotTypeItemFactory) {
-    add(factory)
-}
-
-/** Pop [SnapshotTypeItemFactory] from the top of the stack. */
-internal fun TypeItemFactoryStack.pop() {
-    removeLast()
-}
-
 /** Constructs a [Codebase] by taking a snapshot of another [Codebase] that is being visited. */
-class CodebaseSnapshotTaker private constructor() : DefaultCodebaseAssembler(), DelegatedVisitor {
+class CodebaseSnapshotTaker
+private constructor(referenceVisitorFactory: (DelegatedVisitor) -> ItemVisitor) :
+    DefaultCodebaseAssembler(), DelegatedVisitor {
 
     /**
      * The [Codebase] that is under construction.
      *
      * Initialized in [visitCodebase].
      */
-    private lateinit var codebase: DefaultCodebase
+    private lateinit var snapshotCodebase: DefaultCodebase
+
+    /**
+     * The [ItemVisitor] to use in [createClassFromUnderlyingModel] to create a [ClassItem] that is
+     * not emitted as part of the snapshot but is included because it is referenced from a
+     * [ClassItem] that is emitted from the snapshot.
+     */
+    private val referenceVisitor = referenceVisitorFactory(this)
 
     override val itemFactory: DefaultItemFactory by
         lazy(LazyThreadSafetyMode.NONE) {
             DefaultItemFactory(
-                codebase,
+                snapshotCodebase,
                 // Snapshots currently only support java.
                 defaultItemLanguage = ItemLanguage.JAVA,
                 // Snapshots have already been separated by API surface variants, so they can use
@@ -92,46 +87,17 @@ class CodebaseSnapshotTaker private constructor() : DefaultCodebaseAssembler(),
     private lateinit var originalCodebase: Codebase
 
     private val globalTypeItemFactory by
-        lazy(LazyThreadSafetyMode.NONE) { SnapshotTypeItemFactory(codebase) }
-
-    /**
-     * Stack of [SnapshotTypeItemFactory] that contain information about the [TypeParameterItem]s
-     * that are in scope and can resolve a type variable reference to the parameter.
-     */
-    private val typeItemFactoryStack = TypeItemFactoryStack()
-
-    /** Get the current [SnapshotTypeItemFactory], i.e. the closest enclosing one. */
-    private val typeItemFactory
-        get() = typeItemFactoryStack.last()
-
-    /**
-     * The current [PackageItem], set in [visitPackage], cleared in [afterVisitPackage], relies on
-     * the [PackageItem]s being visited as a flat list, not a package hierarchy.
-     */
-    private var currentPackage: DefaultPackageItem? = null
-
-    /**
-     * The current [ClassItem], that forms a stack through the [ClassItem.containingClass].
-     *
-     * Set (pushed on the stack) in [visitClass]. Reset (popped off the stack) in [afterVisitClass].
-     */
-    private var currentClass: DefaultClassItem? = null
-
-    /** Take a snapshot of this [ModifierList] for [codebase]. */
-    private fun ModifierList.snapshot() = snapshot(codebase)
+        lazy(LazyThreadSafetyMode.NONE) { SnapshotTypeItemFactory(snapshotCodebase) }
 
-    /** General [TypeItem] specific snapshot. */
-    private fun TypeItem.snapshot() = typeItemFactory.getGeneralType(this)
-
-    /** [ClassTypeItem] specific snapshot. */
-    private fun ClassTypeItem.snapshot() = typeItemFactory.getGeneralType(this) as ClassTypeItem
+    /** Take a snapshot of this [ModifierList] for [snapshotCodebase]. */
+    private fun ModifierList.snapshot() = snapshot(snapshotCodebase)
 
     /**
      * Snapshots need to preserve class nesting when visiting otherwise [ClassItem.containingClass]
      * will not be initialized correctly.
      */
     override val requiresClassNesting: Boolean
-        get() = true
+        get() = false
 
     override fun visitCodebase(codebase: Codebase) {
         this.originalCodebase = codebase
@@ -140,20 +106,14 @@ class CodebaseSnapshotTaker private constructor() : DefaultCodebaseAssembler(),
                 location = codebase.location,
                 description = "snapshot of ${codebase.description}",
                 preFiltered = true,
-                annotationManager = codebase.annotationManager,
+                config = codebase.config,
                 trustedApi = true,
                 // Supports documentation if the copied codebase does.
                 supportsDocumentation = codebase.supportsDocumentation(),
-                reporter = codebase.reporter,
                 assembler = this,
             )
 
-        this.codebase = newCodebase
-        typeItemFactoryStack.push(globalTypeItemFactory)
-    }
-
-    override fun afterVisitCodebase(codebase: Codebase) {
-        typeItemFactoryStack.pop()
+        this.snapshotCodebase = newCodebase
     }
 
     /**
@@ -171,7 +131,14 @@ class CodebaseSnapshotTaker private constructor() : DefaultCodebaseAssembler(),
             )
             .let { PackageDocs(mapOf(it.qualifiedName to it)) }
 
-    override fun visitPackage(pkg: PackageItem) {
+    /** Get the [PackageItem] corresponding to this [PackageItem] in the snapshot codebase. */
+    private fun PackageItem.getSnapshotPackage(): PackageItem {
+        // Check to see if the package already exists to avoid unnecessarily creating PackageDocs.
+        val packageName = qualifiedName()
+        snapshotCodebase.findPackage(packageName)?.let {
+            return it
+        }
+
         // Get a PackageDocs that contains a PackageDoc that contains information extracted from the
         // PackageItem being visited. This is needed to ensure that the findOrCreatePackage(...)
         // call below will use the correct information when creating the package. As only a single
@@ -179,43 +146,12 @@ class CodebaseSnapshotTaker private constructor() : DefaultCodebaseAssembler(),
         // created a containing package that package would not have a PackageDocs and might be
         // incorrect. However, that should not be a problem as the packages are visited in order
         // such that a containing package is visited before any contained packages.
-        val packageDocs = packageDocsForPackageItem(pkg)
-        val packageName = pkg.qualifiedName()
-        val newPackage = codebase.findOrCreatePackage(packageName, packageDocs)
-        currentPackage = newPackage
+        val packageDocs = packageDocsForPackageItem(this)
+        val newPackageItem = snapshotCodebase.findOrCreatePackage(packageName, packageDocs)
+        newPackageItem.copySelectedApiVariants(this)
+        return newPackageItem
     }
 
-    override fun afterVisitPackage(pkg: PackageItem) {
-        currentPackage = null
-    }
-
-    /**
-     * Create a snapshot of this [TypeParameterList] and an associated [SnapshotTypeItemFactory].
-     *
-     * @param description the description to use when failing to resolve a type parameter by name.
-     */
-    private fun TypeParameterList.snapshot(description: String) =
-        if (this == TypeParameterList.NONE) TypeParameterListAndFactory(this, typeItemFactory)
-        else
-            DefaultTypeParameterList.createTypeParameterItemsAndFactory(
-                typeItemFactory,
-                description,
-                this,
-                { typeParameterItem ->
-                    DefaultTypeParameterItem(
-                        codebase = codebase,
-                        itemLanguage = typeParameterItem.itemLanguage,
-                        modifiers = typeParameterItem.modifiers.snapshot(),
-                        name = typeParameterItem.name(),
-                        isReified = typeParameterItem.isReified()
-                    )
-                },
-                // Create, set and return the [BoundsTypeItem] list.
-                { typeItemFactory, typeParameterItem ->
-                    typeParameterItem.typeBounds().map { typeItemFactory.getBoundsType(it) }
-                },
-            )
-
     /**
      * Take a snapshot of the documentation.
      *
@@ -248,26 +184,41 @@ class CodebaseSnapshotTaker private constructor() : DefaultCodebaseAssembler(),
         return { item -> documentation.snapshot(item).apply { removeDeprecatedSection() } }
     }
 
+    /** Get the [ClassItem] corresponding to this [ClassItem] in the [snapshotCodebase]. */
+    private fun ClassItem.getSnapshotClass(): DefaultClassItem =
+        snapshotCodebase.resolveClass(qualifiedName()) as DefaultClassItem
+
+    /** Copy [SelectableItem.selectedApiVariants] from [original] to this. */
+    private fun <T : SelectableItem> T.copySelectedApiVariants(original: T) {
+        selectedApiVariants = original.selectedApiVariants
+    }
+
     override fun visitClass(cls: ClassItem) {
         val classToSnapshot = cls.actualItemToSnapshot
 
+        // Get the snapshot of the containing package.
+        val containingPackage = cls.containingPackage().getSnapshotPackage()
+
+        // Get the snapshot of the containing class, if any.
+        val containingClass = cls.containingClass()?.getSnapshotClass()
+
         // Create a TypeParameterList and SnapshotTypeItemFactory for the class.
         val (typeParameterList, classTypeItemFactory) =
-            classToSnapshot.typeParameterList.snapshot("class ${classToSnapshot.qualifiedName()}")
-
-        // Push on the stack before resolving any types just in case they refer to a type parameter.
-        typeItemFactoryStack.push(classTypeItemFactory)
+            globalTypeItemFactory.from(containingClass).inScope {
+                classToSnapshot.typeParameterList.snapshot(
+                    "class ${classToSnapshot.qualifiedName()}"
+                )
+            }
 
         // Snapshot the super class type, if any.
         val snapshotSuperClassType =
             classToSnapshot.superClassType()?.let { superClassType ->
-                typeItemFactory.getSuperClassType(superClassType)
+                classTypeItemFactory.getSuperClassType(superClassType)
             }
         val snapshotInterfaceTypes =
-            classToSnapshot.interfaceTypes().map { typeItemFactory.getInterfaceType(it) }
+            classToSnapshot.interfaceTypes().map { classTypeItemFactory.getInterfaceType(it) }
 
-        val containingClass = currentClass
-        val containingPackage = currentPackage!!
+        // Create the class and register it in the codebase.
         val newClass =
             itemFactory.createClassItem(
                 fileLocation = classToSnapshot.fileLocation,
@@ -284,75 +235,29 @@ class CodebaseSnapshotTaker private constructor() : DefaultCodebaseAssembler(),
                 superClassType = snapshotSuperClassType,
                 interfaceTypes = snapshotInterfaceTypes,
             )
-
-        currentClass = newClass
-    }
-
-    override fun afterVisitClass(cls: ClassItem) {
-        currentClass = currentClass?.containingClass() as? DefaultClassItem
-        typeItemFactoryStack.pop()
-    }
-
-    /** Push this [SnapshotTypeItemFactory] in scope before executing [body] and pop afterwards. */
-    private inline fun SnapshotTypeItemFactory.inScope(body: () -> Unit) {
-        typeItemFactoryStack.push(this)
-        body()
-        typeItemFactoryStack.pop()
+        newClass.copySelectedApiVariants(classToSnapshot)
     }
 
-    /** Return a factory that will create a snapshot of this list of [ParameterItem]s. */
-    private fun List<ParameterItem>.snapshot(
-        containingCallable: CallableItem,
-        currentCallable: CallableItem
-    ): List<ParameterItem> {
-        return map { parameterItem ->
-            // Retrieve the public name immediately to remove any dependencies on this in the
-            // lambda passed to publicNameProvider.
-            val publicName = parameterItem.publicName()
-
-            // The parameter being snapshot may be from a previously released API, which may not
-            // track parameter names and so may have to auto-generate them. This code tries to avoid
-            // using the auto-generated names if possible. If the `publicName()` of the parameter
-            // being snapshot is not `null` then get its `name()` as that will either be set to the
-            // public name or another developer supplied name. Either way it will not be
-            // auto-generated. However, if its `publicName()` is `null` then its `name()` will be
-            // auto-generated so try and avoid that is possible. Instead, use the name of the
-            // corresponding parameter from `currentCallable` as that is more likely to have a
-            // developer supplied name, although it will be the same as `parameterItem` if
-            // `currentCallable` is not being reverted.
-            val name =
-                if (publicName != null) parameterItem.name()
-                else {
-                    val namedParameter = currentCallable.parameters()[parameterItem.parameterIndex]
-                    namedParameter.name()
-                }
-
-            itemFactory.createParameterItem(
-                fileLocation = parameterItem.fileLocation,
-                itemLanguage = parameterItem.itemLanguage,
-                modifiers = parameterItem.modifiers.snapshot(),
-                name = name,
-                publicNameProvider = { publicName },
-                containingCallable = containingCallable,
-                parameterIndex = parameterItem.parameterIndex,
-                type = parameterItem.type().snapshot(),
-                defaultValueFactory = parameterItem.defaultValue::snapshot,
-            )
-        }
-    }
+    /** Execute [body] within [SnapshotTypeItemFactoryContext]. */
+    private inline fun <T> SnapshotTypeItemFactory.inScope(
+        body: SnapshotTypeItemFactoryContext.() -> T
+    ) = SnapshotTypeItemFactoryContext(this).body()
 
     override fun visitConstructor(constructor: ConstructorItem) {
         val constructorToSnapshot = constructor.actualItemToSnapshot
 
+        val containingClass = constructor.containingClass().getSnapshotClass()
+
         // Create a TypeParameterList and SnapshotTypeItemFactory for the constructor.
         val (typeParameterList, constructorTypeItemFactory) =
-            constructorToSnapshot.typeParameterList.snapshot(constructorToSnapshot.describe())
+            globalTypeItemFactory.from(containingClass).inScope {
+                constructorToSnapshot.typeParameterList.snapshot(constructorToSnapshot.describe())
+            }
 
-        // Resolve any type parameters used in the constructor's parameter items within the scope of
-        // the constructor's SnapshotTypeItemFactory.
-        constructorTypeItemFactory.inScope {
-            val containingClass = currentClass!!
-            val newConstructor =
+        val newConstructor =
+            // Resolve any type parameters used in the constructor's return type and parameter items
+            // within the scope of the constructor's SnapshotTypeItemFactory.
+            constructorTypeItemFactory.inScope {
                 itemFactory.createConstructorItem(
                     fileLocation = constructorToSnapshot.fileLocation,
                     itemLanguage = constructorToSnapshot.itemLanguage,
@@ -372,24 +277,29 @@ class CodebaseSnapshotTaker private constructor() : DefaultCodebaseAssembler(),
                         },
                     callableBodyFactory = constructorToSnapshot.body::snapshot,
                     implicitConstructor = constructorToSnapshot.isImplicitConstructor(),
+                    isPrimary = constructorToSnapshot.isPrimary,
                 )
+            }
+        newConstructor.copySelectedApiVariants(constructorToSnapshot)
 
-            containingClass.addConstructor(newConstructor)
-        }
+        containingClass.addConstructor(newConstructor)
     }
 
     override fun visitMethod(method: MethodItem) {
         val methodToSnapshot = method.actualItemToSnapshot
 
+        val containingClass = method.containingClass().getSnapshotClass()
+
         // Create a TypeParameterList and SnapshotTypeItemFactory for the method.
         val (typeParameterList, methodTypeItemFactory) =
-            methodToSnapshot.typeParameterList.snapshot(methodToSnapshot.describe())
+            globalTypeItemFactory.from(containingClass).inScope {
+                methodToSnapshot.typeParameterList.snapshot(methodToSnapshot.describe())
+            }
 
-        // Resolve any type parameters used in the method's parameter items within the scope of
-        // the method's SnapshotTypeItemFactory.
-        methodTypeItemFactory.inScope {
-            val containingClass = currentClass!!
-            val newMethod =
+        val newMethod =
+            // Resolve any type parameters used in the method's return type and parameter items
+            // within the scope of the method's SnapshotTypeItemFactory.
+            methodTypeItemFactory.inScope {
                 itemFactory.createMethodItem(
                     fileLocation = methodToSnapshot.fileLocation,
                     itemLanguage = methodToSnapshot.itemLanguage,
@@ -407,27 +317,33 @@ class CodebaseSnapshotTaker private constructor() : DefaultCodebaseAssembler(),
                     callableBodyFactory = methodToSnapshot.body::snapshot,
                     annotationDefault = methodToSnapshot.defaultValue(),
                 )
+            }
+        newMethod.copySelectedApiVariants(methodToSnapshot)
 
-            containingClass.addMethod(newMethod)
-        }
+        containingClass.addMethod(newMethod)
     }
 
     override fun visitField(field: FieldItem) {
         val fieldToSnapshot = field.actualItemToSnapshot
 
-        val containingClass = currentClass!!
+        val containingClass = field.containingClass().getSnapshotClass()
         val newField =
-            itemFactory.createFieldItem(
-                fileLocation = fieldToSnapshot.fileLocation,
-                itemLanguage = fieldToSnapshot.itemLanguage,
-                modifiers = fieldToSnapshot.modifiers.snapshot(),
-                documentationFactory = snapshotDocumentation(fieldToSnapshot, field),
-                name = fieldToSnapshot.name(),
-                containingClass = containingClass,
-                type = fieldToSnapshot.type().snapshot(),
-                isEnumConstant = fieldToSnapshot.isEnumConstant(),
-                fieldValue = fieldToSnapshot.fieldValue?.snapshot(),
-            )
+            // Resolve any type parameters used in the field's type within the scope of the
+            // containing class's SnapshotTypeItemFactory.
+            globalTypeItemFactory.from(containingClass).inScope {
+                itemFactory.createFieldItem(
+                    fileLocation = fieldToSnapshot.fileLocation,
+                    itemLanguage = fieldToSnapshot.itemLanguage,
+                    modifiers = fieldToSnapshot.modifiers.snapshot(),
+                    documentationFactory = snapshotDocumentation(fieldToSnapshot, field),
+                    name = fieldToSnapshot.name(),
+                    containingClass = containingClass,
+                    type = fieldToSnapshot.type().snapshot(),
+                    isEnumConstant = fieldToSnapshot.isEnumConstant(),
+                    fieldValue = fieldToSnapshot.fieldValue?.snapshot(),
+                )
+            }
+        newField.copySelectedApiVariants(fieldToSnapshot)
 
         containingClass.addField(newField)
     }
@@ -435,60 +351,159 @@ class CodebaseSnapshotTaker private constructor() : DefaultCodebaseAssembler(),
     override fun visitProperty(property: PropertyItem) {
         val propertyToSnapshot = property.actualItemToSnapshot
 
-        val containingClass = currentClass!!
+        val containingClass = property.containingClass().getSnapshotClass()
         val newProperty =
-            itemFactory.createPropertyItem(
-                fileLocation = propertyToSnapshot.fileLocation,
-                itemLanguage = propertyToSnapshot.itemLanguage,
-                modifiers = propertyToSnapshot.modifiers.snapshot(),
-                documentationFactory = snapshotDocumentation(propertyToSnapshot, property),
-                name = propertyToSnapshot.name(),
-                containingClass = containingClass,
-                type = propertyToSnapshot.type().snapshot(),
-            )
+            // Resolve any type parameters used in the property's type within the scope of the
+            // containing class's SnapshotTypeItemFactory.
+            globalTypeItemFactory.from(containingClass).inScope {
+                itemFactory.createPropertyItem(
+                    fileLocation = propertyToSnapshot.fileLocation,
+                    itemLanguage = propertyToSnapshot.itemLanguage,
+                    modifiers = propertyToSnapshot.modifiers.snapshot(),
+                    documentationFactory = snapshotDocumentation(propertyToSnapshot, property),
+                    name = propertyToSnapshot.name(),
+                    containingClass = containingClass,
+                    type = propertyToSnapshot.type().snapshot(),
+                    getter = property.getter,
+                    setter = property.setter,
+                    constructorParameter = property.constructorParameter,
+                    backingField = property.backingField,
+                )
+            }
+        newProperty.copySelectedApiVariants(propertyToSnapshot)
 
         containingClass.addProperty(newProperty)
     }
 
-    /**
-     * Take a snapshot of [qualifiedName].
-     *
-     * TODO(b/353737744): Handle resolving nested classes.
-     */
+    /** Take a snapshot of [qualifiedName]. */
     override fun createClassFromUnderlyingModel(qualifiedName: String): ClassItem? {
         // Resolve the class in the original codebase, if possible.
         val originalClass = originalCodebase.resolveClass(qualifiedName) ?: return null
 
-        // Take a snapshot of the class, that should add a new class to the snapshot codebase.
-        val visitor = NonFilteringDelegatingVisitor(this)
-        val originalPackage = originalClass.containingPackage()
-
-        // Set up the state for taking a snapshot of a class.
-        typeItemFactoryStack.push(globalTypeItemFactory)
-        visitPackage(originalPackage)
-        originalClass.accept(visitor)
-        afterVisitPackage(originalPackage)
-        typeItemFactoryStack.pop()
+        // Take a snapshot of a class that is referenced from, but not defined within, the snapshot.
+        originalClass.accept(referenceVisitor)
 
         // Find the newly added class.
-        return codebase.findClass(originalClass.qualifiedName())!!
+        val classItem =
+            snapshotCodebase.findClass(originalClass.qualifiedName())
+                ?: error("Could not snapshot class $qualifiedName")
+
+        // Any class that is created only when resolving references is by definition not part of the
+        // codebase and so will not be emitted.
+        classItem.emit = false
+
+        return classItem
     }
 
     companion object {
-        /** Take a snapshot of [codebase]. */
+        /**
+         * Take a snapshot of [codebase].
+         *
+         * @param definitionVisitorFactory a factory for creating an [ItemVisitor] that delegates to
+         *   a [DelegatedVisitor]. The [ItemVisitor] is used to determine which parts of [codebase]
+         *   will be defined within and emitted from the snapshot.
+         * @param referenceVisitorFactory a factory for creating an [ItemVisitor] that delegates to
+         *   a [DelegatedVisitor]. The [ItemVisitor] is used to determine which parts of [codebase]
+         *   will be referenced from within but not emitted from the snapshot.
+         */
         fun takeSnapshot(
             codebase: Codebase,
-            visitorFactory: (DelegatedVisitor) -> ItemVisitor = ::NonEmittableDelegatingVisitor,
+            definitionVisitorFactory: (DelegatedVisitor) -> ItemVisitor,
+            referenceVisitorFactory: (DelegatedVisitor) -> ItemVisitor,
         ): Codebase {
-            // Create a snapshot taker that will construct the snapshot.
-            val taker = CodebaseSnapshotTaker()
+            // Create a snapshot taker that will construct the snapshot. Pass in the
+            // referenceVisitorFactory so it can create the reference visitor for use in creating
+            // Items that are referenced from the snapshot.
+            val taker = CodebaseSnapshotTaker(referenceVisitorFactory)
 
-            // Wrap it in a visitor and visit the codebase.
-            val visitor = visitorFactory(taker)
-            codebase.accept(visitor)
+            // Wrap it in a visitor that will determine which Items are defined in the snapshot and
+            // then apply that visitor to the input codebase.
+            val definitionVisitor = definitionVisitorFactory(taker)
+            codebase.accept(definitionVisitor)
 
             // Return the constructed snapshot.
-            return taker.codebase
+            return taker.snapshotCodebase
+        }
+    }
+
+    /** Encapsulates state and methods needed to take a snapshot of [TypeItem]s. */
+    internal inner class SnapshotTypeItemFactoryContext(
+        val typeItemFactory: SnapshotTypeItemFactory
+    ) {
+        /**
+         * Create a snapshot of this [TypeParameterList] and an associated
+         * [SnapshotTypeItemFactory].
+         *
+         * @param description the description to use when failing to resolve a type parameter by
+         *   name.
+         */
+        internal fun TypeParameterList.snapshot(description: String) =
+            if (this == TypeParameterList.NONE) TypeParameterListAndFactory(this, typeItemFactory)
+            else
+                DefaultTypeParameterList.createTypeParameterItemsAndFactory(
+                    typeItemFactory,
+                    description,
+                    this,
+                    { typeParameterItem ->
+                        DefaultTypeParameterItem(
+                            codebase = snapshotCodebase,
+                            modifiers = typeParameterItem.modifiers.snapshot(),
+                            name = typeParameterItem.name(),
+                            isReified = typeParameterItem.isReified()
+                        )
+                    },
+                    // Create, set and return the [BoundsTypeItem] list.
+                    { typeItemFactory, typeParameterItem ->
+                        typeParameterItem.typeBounds().map { typeItemFactory.getBoundsType(it) }
+                    },
+                )
+        /** General [TypeItem] specific snapshot. */
+        internal fun TypeItem.snapshot() = typeItemFactory.getGeneralType(this)
+
+        /** [ClassTypeItem] specific snapshot. */
+        internal fun ClassTypeItem.snapshot() =
+            typeItemFactory.getGeneralType(this) as ClassTypeItem
+
+        /** Create a snapshot of this list of [ParameterItem]s. */
+        internal fun List<ParameterItem>.snapshot(
+            containingCallable: CallableItem,
+            currentCallable: CallableItem
+        ): List<ParameterItem> {
+            return map { parameterItem ->
+                // Retrieve the public name immediately to remove any dependencies on this in the
+                // lambda passed to publicNameProvider.
+                val publicName = parameterItem.publicName()
+
+                // The parameter being snapshot may be from a previously released API, which may not
+                // track parameter names and so may have to auto-generate them. This code tries to
+                // avoid using the auto-generated names if possible. If the `publicName()` of the
+                // parameter being snapshot is not `null` then get its `name()` as that will either
+                // be set to the public name or another developer supplied name. Either way it will
+                // not be auto-generated. However, if its `publicName()` is `null` then its `name()`
+                // will be auto-generated so try and avoid that is possible. Instead, use the name
+                // of the corresponding parameter from `currentCallable` as that is more likely to
+                // have a developer supplied name, although it will be the same as `parameterItem`
+                // if `currentCallable` is not being reverted.
+                val name =
+                    if (publicName != null) parameterItem.name()
+                    else {
+                        val namedParameter =
+                            currentCallable.parameters()[parameterItem.parameterIndex]
+                        namedParameter.name()
+                    }
+
+                itemFactory.createParameterItem(
+                    fileLocation = parameterItem.fileLocation,
+                    itemLanguage = parameterItem.itemLanguage,
+                    modifiers = parameterItem.modifiers.snapshot(),
+                    name = name,
+                    publicNameProvider = { publicName },
+                    containingCallable = containingCallable,
+                    parameterIndex = parameterItem.parameterIndex,
+                    type = parameterItem.type().snapshot(),
+                    defaultValueFactory = parameterItem.defaultValue::snapshot,
+                )
+            }
         }
     }
 }
@@ -496,12 +511,12 @@ class CodebaseSnapshotTaker private constructor() : DefaultCodebaseAssembler(),
 /**
  * Get the actual item to snapshot, this takes into account whether the item has been reverted.
  *
- * The [Showability.revertItem] is only set to a non-null value if changes to this [Item] have been
- * reverted AND this [Item] existed in the previously released API.
+ * The [Showability.revertItem] is only set to a non-null value if changes to this [SelectableItem]
+ * have been reverted AND this [SelectableItem] existed in the previously released API.
  *
  * This casts the [Showability.revertItem] to the same type as this is called upon. That is safe as,
- * if set to a non-null value the [Showability.revertItem] will always point to an [Item] of the
- * same type.
+ * if set to a non-null value the [Showability.revertItem] will always point to a [SelectableItem]
+ * of the same type.
  */
-val <reified T : Item> T.actualItemToSnapshot: T
+private val <reified T : SelectableItem> T.actualItemToSnapshot: T
     inline get() = (showability.revertItem ?: this) as T
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/NonEmittableDelegatingVisitor.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/EmittableDelegatingVisitor.kt
similarity index 78%
rename from metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/NonEmittableDelegatingVisitor.kt
rename to metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/EmittableDelegatingVisitor.kt
index 9f9f62f9a..892a54fe9 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/NonEmittableDelegatingVisitor.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/EmittableDelegatingVisitor.kt
@@ -19,18 +19,18 @@ package com.android.tools.metalava.model.snapshot
 import com.android.tools.metalava.model.BaseItemVisitor
 import com.android.tools.metalava.model.DelegatedVisitor
 import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.SelectableItem
 
 /**
- * A [BaseItemVisitor] that will delegate to [delegate] but skip [Item]s whose [Item.emit] property
- * is `false`.
+ * A [BaseItemVisitor] that will delegate to [delegate] only for [Item]'s whose [emit] is `true`.
  *
  * Preserves class nesting as required by the [delegate]'s [DelegatedVisitor.requiresClassNesting]
  * property.
  */
-class NonEmittableDelegatingVisitor(private val delegate: DelegatedVisitor) :
+class EmittableDelegatingVisitor(private val delegate: DelegatedVisitor) :
     NonFilteringDelegatingVisitor(delegate) {
 
     override fun skip(item: Item): Boolean {
-        return !item.emit
+        return item !is SelectableItem || !item.emit
     }
 }
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/NonFilteringDelegatingVisitor.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/NonFilteringDelegatingVisitor.kt
index 84b2aac30..6949e1846 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/NonFilteringDelegatingVisitor.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/NonFilteringDelegatingVisitor.kt
@@ -33,7 +33,11 @@ import com.android.tools.metalava.model.PropertyItem
  * property.
  */
 open class NonFilteringDelegatingVisitor(private val delegate: DelegatedVisitor) :
-    BaseItemVisitor(preserveClassNesting = delegate.requiresClassNesting) {
+    BaseItemVisitor(
+        preserveClassNesting = delegate.requiresClassNesting,
+        // [DelegatedVisitor] does not support visiting parameters.
+        visitParameterItems = false,
+    ) {
 
     override fun visitCodebase(codebase: Codebase) {
         delegate.visitCodebase(codebase)
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/SnapshotTypeItemFactory.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/SnapshotTypeItemFactory.kt
index 08fa8a06f..6c945f635 100644
--- a/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/SnapshotTypeItemFactory.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/snapshot/SnapshotTypeItemFactory.kt
@@ -17,6 +17,7 @@
 package com.android.tools.metalava.model.snapshot
 
 import com.android.tools.metalava.model.ArrayTypeItem
+import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassTypeItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.LambdaTypeItem
@@ -48,6 +49,12 @@ internal class SnapshotTypeItemFactory(
     typeParameterScope: TypeParameterScope = TypeParameterScope.empty,
 ) : DefaultTypeItemFactory<TypeItem, SnapshotTypeItemFactory>(typeParameterScope), TypeTransformer {
 
+    /** Construct a [SnapshotTypeItemFactory] suitable for creating types within [classItem]. */
+    fun from(classItem: ClassItem?): SnapshotTypeItemFactory {
+        val scope = TypeParameterScope.from(classItem)
+        return if (scope.isEmpty()) this else SnapshotTypeItemFactory(codebase, scope)
+    }
+
     override fun self() = this
 
     override fun createNestedFactory(scope: TypeParameterScope) =
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/ApiFilters.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/ApiFilters.kt
new file mode 100644
index 000000000..f41f2efd0
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/ApiFilters.kt
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.visitors
+
+import com.android.tools.metalava.model.FilterPredicate
+import com.android.tools.metalava.model.Item
+
+/** Encapsulates filters needed by [ApiVisitor]. */
+class ApiFilters(
+    /** Returns `true` for [Item]s that should be defined in the API and emitted as part of it. */
+    val emit: FilterPredicate,
+
+    /**
+     * Returns `true` for [Item]s that can be referenced from the API, this is a super set of
+     * [Item]s that can be emitted.
+     */
+    val reference: FilterPredicate,
+)
diff --git a/metalava/src/main/java/com/android/tools/metalava/ApiPredicate.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/ApiPredicate.kt
similarity index 93%
rename from metalava/src/main/java/com/android/tools/metalava/ApiPredicate.kt
rename to metalava-model/src/main/java/com/android/tools/metalava/model/visitors/ApiPredicate.kt
index 207cef4c2..a403c9ec2 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ApiPredicate.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/ApiPredicate.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2020 The Android Open Source Project
+ * Copyright (C) 2024 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,17 +14,16 @@
  * limitations under the License.
  */
 
-package com.android.tools.metalava
+package com.android.tools.metalava.model.visitors
 
 import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.ClassContentItem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassOrigin
-import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.FilterPredicate
 import com.android.tools.metalava.model.MemberItem
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.SelectableItem
-import java.util.function.Predicate
 
 /**
  * Predicate that decides if the given member should be considered part of an API surface area. To
@@ -56,8 +55,8 @@ class ApiPredicate(
     private val includeApisForStubPurposes: Boolean = true,
 
     /** Configuration that may be provided by command line options. */
-    private val config: Config = @Suppress("DEPRECATION") options.apiPredicateConfig,
-) : Predicate<Item> {
+    private val config: Config,
+) : FilterPredicate {
 
     /**
      * Contains configuration for [ApiPredicate] that can, or at least could, come from command line
@@ -83,20 +82,13 @@ class ApiPredicate(
         val addAdditionalOverrides: Boolean = false,
     )
 
-    override fun test(item: Item): Boolean {
+    override fun test(item: SelectableItem): Boolean {
         // non-class, i.e., (literally) member declaration w/o emit flag, e.g., due to `expect`
         // Some [ClassItem], e.g., JvmInline, java.lang.* classes, may not set the emit flag.
         if (item !is ClassItem && !item.emit) {
             return false
         }
 
-        // If the item is not individually selectable (i.e. ParameterItem and TypeParameterItem)
-        // then whether it is included will always be determined by its owner. If it got to this
-        // point the chances are that its owner was selected, so just assume this is too.
-        if (item !is SelectableItem) {
-            return true
-        }
-
         if (
             !config.allowClassesFromClasspath &&
                 item is ClassContentItem &&
@@ -230,7 +222,7 @@ class ApiPredicate(
         CURRENT
     }
 
-    /** Get the API to which this [Item] belongs, according to the annotations. */
+    /** Get the API to which this [SelectableItem] belongs, according to the annotations. */
     private fun SelectableItem.apiMembership(): ApiMembership {
         // If the item has a "show" annotation, then return whether it *only* has a "for stubs"
         // show annotation or not.
diff --git a/metalava/src/main/java/com/android/tools/metalava/ApiType.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/ApiType.kt
similarity index 61%
rename from metalava/src/main/java/com/android/tools/metalava/ApiType.kt
rename to metalava-model/src/main/java/com/android/tools/metalava/model/visitors/ApiType.kt
index 3af9ae21d..9aa700dc1 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ApiType.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/ApiType.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2018 The Android Open Source Project
+ * Copyright (C) 2024 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,17 +14,16 @@
  * limitations under the License.
  */
 
-package com.android.tools.metalava
+package com.android.tools.metalava.model.visitors
 
-import com.android.tools.metalava.model.Item
-import java.util.function.Predicate
+import com.android.tools.metalava.model.FilterPredicate
 
 /** Types of APIs emitted (or parsed etc.) */
 enum class ApiType(val flagName: String, val displayName: String = flagName) {
     /** The public API */
     PUBLIC_API("api", "public") {
 
-        override fun getNonElidingFilter(apiPredicateConfig: ApiPredicate.Config): Predicate<Item> {
+        override fun getNonElidingFilter(apiPredicateConfig: ApiPredicate.Config): FilterPredicate {
             // This filter is for API signature files, where we don't need the "for stub purposes"
             // APIs.
             return ApiPredicate(
@@ -33,7 +32,7 @@ enum class ApiType(val flagName: String, val displayName: String = flagName) {
             )
         }
 
-        override fun getReferenceFilter(apiPredicateConfig: ApiPredicate.Config): Predicate<Item> {
+        override fun getReferenceFilter(apiPredicateConfig: ApiPredicate.Config): FilterPredicate {
             return ApiPredicate(config = apiPredicateConfig.copy(ignoreShown = true))
         }
     },
@@ -41,7 +40,7 @@ enum class ApiType(val flagName: String, val displayName: String = flagName) {
     /** The API that has been removed */
     REMOVED("removed", "removed") {
 
-        override fun getNonElidingFilter(apiPredicateConfig: ApiPredicate.Config): Predicate<Item> {
+        override fun getNonElidingFilter(apiPredicateConfig: ApiPredicate.Config): FilterPredicate {
             // This filter is for API signature files, where we don't need the "for stub purposes"
             // APIs.
             return ApiPredicate(
@@ -51,7 +50,7 @@ enum class ApiType(val flagName: String, val displayName: String = flagName) {
             )
         }
 
-        override fun getReferenceFilter(apiPredicateConfig: ApiPredicate.Config): Predicate<Item> {
+        override fun getReferenceFilter(apiPredicateConfig: ApiPredicate.Config): FilterPredicate {
             return ApiPredicate(
                 ignoreRemoved = true,
                 config = apiPredicateConfig.copy(ignoreShown = true),
@@ -62,35 +61,38 @@ enum class ApiType(val flagName: String, val displayName: String = flagName) {
     /** Everything */
     ALL("all", "all") {
 
-        override fun getNonElidingFilter(apiPredicateConfig: ApiPredicate.Config): Predicate<Item> {
-            return Predicate { it.emit }
+        override fun getNonElidingFilter(apiPredicateConfig: ApiPredicate.Config): FilterPredicate {
+            return FilterPredicate { it.emit }
         }
 
-        override fun getEmitFilter(apiPredicateConfig: ApiPredicate.Config): Predicate<Item> {
-            return Predicate { it.emit }
+        override fun getEmitFilter(apiPredicateConfig: ApiPredicate.Config): FilterPredicate {
+            return FilterPredicate { it.emit }
         }
 
-        override fun getReferenceFilter(apiPredicateConfig: ApiPredicate.Config): Predicate<Item> {
-            return Predicate { true }
+        override fun getReferenceFilter(apiPredicateConfig: ApiPredicate.Config): FilterPredicate {
+            return FilterPredicate { true }
         }
     };
 
-    abstract fun getNonElidingFilter(apiPredicateConfig: ApiPredicate.Config): Predicate<Item>
+    protected abstract fun getNonElidingFilter(
+        apiPredicateConfig: ApiPredicate.Config
+    ): FilterPredicate
 
-    open fun getEmitFilter(apiPredicateConfig: ApiPredicate.Config): Predicate<Item> {
-        val nonElidingFilter = FilterPredicate(getNonElidingFilter(apiPredicateConfig))
+    open fun getEmitFilter(apiPredicateConfig: ApiPredicate.Config): FilterPredicate {
+        val nonElidingFilter =
+            MatchOverridingMethodPredicate(getNonElidingFilter(apiPredicateConfig))
         val referenceFilter = getReferenceFilter(apiPredicateConfig)
         return nonElidingFilter.and(elidingPredicate(referenceFilter, apiPredicateConfig))
     }
 
-    abstract fun getReferenceFilter(apiPredicateConfig: ApiPredicate.Config): Predicate<Item>
+    abstract fun getReferenceFilter(apiPredicateConfig: ApiPredicate.Config): FilterPredicate
 
     /**
      * Create an [ElidingPredicate] that wraps [wrappedPredicate] and uses information from the
      * [apiPredicateConfig].
      */
     protected fun elidingPredicate(
-        wrappedPredicate: Predicate<Item>,
+        wrappedPredicate: FilterPredicate,
         apiPredicateConfig: ApiPredicate.Config
     ) =
         ElidingPredicate(
@@ -98,5 +100,30 @@ enum class ApiType(val flagName: String, val displayName: String = flagName) {
             addAdditionalOverrides = apiPredicateConfig.addAdditionalOverrides,
         )
 
+    /**
+     * Get the [ApiFilters] for this [ApiType] that uses information from [apiPredicateConfig] to
+     * customize their behavior.
+     *
+     * The returned [ApiFilters.emit] will elide methods overrides that match the overridden method.
+     */
+    fun getApiFilters(apiPredicateConfig: ApiPredicate.Config) =
+        ApiFilters(
+            emit = getEmitFilter(apiPredicateConfig),
+            reference = getReferenceFilter(apiPredicateConfig),
+        )
+
+    /**
+     * Get the [ApiFilters] for this [ApiType] that uses information from [apiPredicateConfig] to
+     * customize their behavior.
+     *
+     * The returned [ApiFilters.emit] will NOT elide methods overrides that match the overridden
+     * method.
+     */
+    fun getNonElidingApiFilters(apiPredicateConfig: ApiPredicate.Config) =
+        ApiFilters(
+            emit = getNonElidingFilter(apiPredicateConfig),
+            reference = getReferenceFilter(apiPredicateConfig),
+        )
+
     override fun toString(): String = displayName
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/model/visitors/ApiVisitor.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/ApiVisitor.kt
similarity index 66%
rename from metalava/src/main/java/com/android/tools/metalava/model/visitors/ApiVisitor.kt
rename to metalava-model/src/main/java/com/android/tools/metalava/model/visitors/ApiVisitor.kt
index fb491a322..ed3726130 100644
--- a/metalava/src/main/java/com/android/tools/metalava/model/visitors/ApiVisitor.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/ApiVisitor.kt
@@ -16,38 +16,30 @@
 
 package com.android.tools.metalava.model.visitors
 
-import com.android.tools.metalava.ApiPredicate
-import com.android.tools.metalava.PackageFilter
 import com.android.tools.metalava.model.BaseItemVisitor
 import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.FieldItem
-import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.ItemVisitor
 import com.android.tools.metalava.model.MemberItem
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.PropertyItem
-import java.util.function.Predicate
 
 open class ApiVisitor(
-    /**
-     * Whether nested classes should be visited "inside" a class; when this property is true, nested
-     * classes are visited before the [#afterVisitClass] method is called; when false, it's done
-     * afterwards. Defaults to false.
-     */
+    /** @see BaseItemVisitor.preserveClassNesting */
     preserveClassNesting: Boolean = false,
 
+    /** @see BaseItemVisitor.visitParameterItems */
+    visitParameterItems: Boolean = true,
+
     /** Whether to include inherited fields too */
-    val inlineInheritedFields: Boolean = true,
+    private val inlineInheritedFields: Boolean = true,
 
     /** Comparator to sort callables with. */
-    val callableComparator: Comparator<CallableItem> = CallableItem.comparator,
+    private val callableComparator: Comparator<CallableItem> = CallableItem.comparator,
 
-    /** The filter to use to determine if we should emit an item */
-    val filterEmit: Predicate<Item>,
-
-    /** The filter to use to determine if we should emit a reference to an item */
-    val filterReference: Predicate<Item>,
+    /** The filters to use to determine what parts of the API will be visited. */
+    private val apiFilters: ApiFilters,
 
     /**
      * Whether this visitor should visit elements that have not been annotated with one of the
@@ -55,82 +47,50 @@ open class ApiVisitor(
      * files sometimes sets this to false so the signature file only contains the "diff" of the
      * annotated API relative to the base API.
      */
-    val showUnannotated: Boolean = true,
-
-    /** Configuration that may come from the command line. */
-    config: Config,
-) : BaseItemVisitor(preserveClassNesting) {
-
-    private val packageFilter: PackageFilter? = config.packageFilter
-
-    /**
-     * Contains configuration for [ApiVisitor] that can, or at least could, come from command line
-     * options.
-     */
-    data class Config(
-        val packageFilter: PackageFilter? = null,
-
-        /** Configuration for any [ApiPredicate] instances this needs to create. */
-        val apiPredicateConfig: ApiPredicate.Config = ApiPredicate.Config()
-    )
+    protected val showUnannotated: Boolean = true,
+) : BaseItemVisitor(preserveClassNesting, visitParameterItems) {
 
     constructor(
-        /**
-         * Whether nested classes should be visited "inside" a class; when this property is true,
-         * nested classes are visited before the [#afterVisitClass] method is called; when false,
-         * it's done afterwards. Defaults to false.
-         */
-        preserveClassNesting: Boolean = false,
-
-        /** Whether to ignore APIs with annotations in the --show-annotations list */
-        ignoreShown: Boolean = true,
-
-        /** Whether to match APIs marked for removal instead of the normal API */
-        remove: Boolean = false,
-
-        /** Comparator to sort callables with. */
-        callableComparator: Comparator<CallableItem> = CallableItem.comparator,
-
-        /**
-         * The filter to use to determine if we should emit an item. If null, the default value is
-         * an [ApiPredicate] based on the values of [remove], [includeApisForStubPurposes],
-         * [config], and [ignoreShown].
-         */
-        filterEmit: Predicate<Item>? = null,
-
-        /**
-         * The filter to use to determine if we should emit a reference to an item. If null, the
-         * default value is an [ApiPredicate] based on the values of [remove] and [config].
-         */
-        filterReference: Predicate<Item>? = null,
-
-        /**
-         * Whether to include "for stub purposes" APIs.
-         *
-         * See [ApiPredicate.includeOnlyForStubPurposes]
-         */
-        includeApisForStubPurposes: Boolean = true,
+        /** @see BaseItemVisitor.visitParameterItems */
+        visitParameterItems: Boolean = true,
 
         /** Configuration that may come from the command line. */
-        config: Config,
+        apiPredicateConfig: ApiPredicate.Config,
     ) : this(
-        preserveClassNesting = preserveClassNesting,
-        inlineInheritedFields = true,
-        callableComparator = callableComparator,
-        filterEmit = filterEmit
-                ?: ApiPredicate(
-                    matchRemoved = remove,
-                    includeApisForStubPurposes = includeApisForStubPurposes,
-                    config = config.apiPredicateConfig.copy(ignoreShown = ignoreShown),
-                ),
-        filterReference = filterReference
-                ?: ApiPredicate(
-                    ignoreRemoved = remove,
-                    config = config.apiPredicateConfig.copy(ignoreShown = true),
-                ),
-        config = config,
+        visitParameterItems = visitParameterItems,
+        apiFilters = defaultFilters(apiPredicateConfig),
     )
 
+    /** The filter to use to determine if we should emit an item */
+    protected val filterEmit = apiFilters.emit
+
+    /** The filter to use to determine if we should emit a reference to an item */
+    protected val filterReference = apiFilters.reference
+
+    companion object {
+        /** Get the default [ApiFilters] to use with [ApiVisitor]. */
+        fun defaultFilters(
+            apiPredicateConfig: ApiPredicate.Config,
+        ): ApiFilters {
+            return ApiFilters(
+                emit = defaultEmitFilter(apiPredicateConfig),
+                reference =
+                    ApiPredicate(
+                        ignoreRemoved = false,
+                        config = apiPredicateConfig.copy(ignoreShown = true),
+                    ),
+            )
+        }
+
+        /** Get the default emit filter to use with [ApiVisitor]. */
+        fun defaultEmitFilter(apiPredicateConfig: ApiPredicate.Config) =
+            ApiPredicate(
+                matchRemoved = false,
+                includeApisForStubPurposes = true,
+                config = apiPredicateConfig.copy(ignoreShown = true),
+            )
+    }
+
     /**
      * Visit a [List] of [ClassItem]s after sorting it into order defined by
      * [ClassItem.classNameSorter].
@@ -169,13 +129,13 @@ open class ApiVisitor(
         // If none of the classes in this package will be visited them ignore the package entirely.
         if (classesToVisitDirectly.isEmpty()) return
 
-        visitItem(pkg)
-        visitPackage(pkg)
+        wrapBodyWithCallsToVisitMethodsForSelectableItem(pkg) {
+            visitPackage(pkg)
 
-        visitClassList(classesToVisitDirectly)
+            visitClassList(classesToVisitDirectly)
 
-        afterVisitPackage(pkg)
-        afterVisitItem(pkg)
+            afterVisitPackage(pkg)
+        }
     }
 
     /** @return Whether this class is generally one that we want to recurse into */
@@ -183,9 +143,6 @@ open class ApiVisitor(
         if (skip(cls)) {
             return false
         }
-        if (packageFilter != null && !packageFilter.matches(cls.containingPackage())) {
-            return false
-        }
 
         return cls.emit
     }
@@ -306,31 +263,31 @@ open class ApiVisitor(
             visitWrappedClassAndFilteredMembers()
         }
 
-        internal fun visitWrappedClassAndFilteredMembers() {
-            visitItem(cls)
-            visitClass(cls)
+        fun visitWrappedClassAndFilteredMembers() {
+            wrapBodyWithCallsToVisitMethodsForSelectableItem(cls) {
+                visitClass(cls)
 
-            for (constructor in constructors) {
-                constructor.accept(this@ApiVisitor)
-            }
+                for (constructor in constructors) {
+                    constructor.accept(this@ApiVisitor)
+                }
 
-            for (method in methods) {
-                method.accept(this@ApiVisitor)
-            }
+                for (method in methods) {
+                    method.accept(this@ApiVisitor)
+                }
 
-            for (property in properties) {
-                property.accept(this@ApiVisitor)
-            }
-            for (field in fields) {
-                field.accept(this@ApiVisitor)
-            }
+                for (property in properties) {
+                    property.accept(this@ApiVisitor)
+                }
+                for (field in fields) {
+                    field.accept(this@ApiVisitor)
+                }
 
-            if (preserveClassNesting) { // otherwise done in visit(PackageItem)
-                visitClassList(cls.nestedClasses().mapNotNull { getVisitCandidateIfNeeded(it) })
-            }
+                if (preserveClassNesting) { // otherwise done in visit(PackageItem)
+                    visitClassList(cls.nestedClasses().mapNotNull { getVisitCandidateIfNeeded(it) })
+                }
 
-            afterVisitClass(cls)
-            afterVisitItem(cls)
+                afterVisitClass(cls)
+            }
         }
     }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/ElidingPredicate.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/ElidingPredicate.kt
similarity index 78%
rename from metalava/src/main/java/com/android/tools/metalava/ElidingPredicate.kt
rename to metalava-model/src/main/java/com/android/tools/metalava/model/visitors/ElidingPredicate.kt
index 39dfe4c21..16036a2d8 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ElidingPredicate.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/ElidingPredicate.kt
@@ -14,39 +14,39 @@
  * limitations under the License.
  */
 
-package com.android.tools.metalava
+package com.android.tools.metalava.model.visitors
 
-import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.FilterPredicate
 import com.android.tools.metalava.model.MethodItem
-import java.util.function.Predicate
+import com.android.tools.metalava.model.SelectableItem
 
 /**
  * Filter that will elide exact duplicate methods that are already included in another
  * superclass/interfaces.
  */
 class ElidingPredicate(
-    private val wrapped: Predicate<Item>,
+    private val wrapped: FilterPredicate,
 
     /** Whether overriding methods essential for compiling the stubs should be elided or not. */
     private val addAdditionalOverrides: Boolean,
-) : Predicate<Item> {
+) : FilterPredicate {
 
     // Returning true means we are keeping this item
     // i.e. when this returns false, we are eliding the item
-    override fun test(method: Item): Boolean {
+    override fun test(item: SelectableItem): Boolean {
         // This method should be included, but if it's an exact duplicate
         // override then we can elide it.
-        return if (method is MethodItem) {
+        return if (item is MethodItem) {
             val differentSuper =
-                method.findPredicateSuperMethod(
+                item.findPredicateSuperMethod(
                     // This predicate returns true if
                     // the potential super method has same signature
-                    Predicate { maybeEqualSuperMethod ->
+                    FilterPredicate { maybeEqualSuperMethod ->
                         // We're looking for included and perfect signature
                         wrapped.test(maybeEqualSuperMethod) &&
                             maybeEqualSuperMethod is MethodItem &&
                             MethodItem.sameSignature(
-                                method,
+                                item,
                                 maybeEqualSuperMethod,
                                 addAdditionalOverrides = addAdditionalOverrides,
                             )
@@ -54,7 +54,7 @@ class ElidingPredicate(
                 )
 
             val doNotElideForAdditionalOverridePurpose =
-                addAdditionalOverrides && method.isRequiredOverridingMethodForTextStub()
+                addAdditionalOverrides && item.isRequiredOverridingMethodForTextStub()
 
             differentSuper == null || doNotElideForAdditionalOverridePurpose
         } else {
diff --git a/metalava/src/main/java/com/android/tools/metalava/model/visitors/FilteringApiVisitor.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/FilteringApiVisitor.kt
similarity index 96%
rename from metalava/src/main/java/com/android/tools/metalava/model/visitors/FilteringApiVisitor.kt
rename to metalava-model/src/main/java/com/android/tools/metalava/model/visitors/FilteringApiVisitor.kt
index 03f5c5d84..140eea313 100644
--- a/metalava/src/main/java/com/android/tools/metalava/model/visitors/FilteringApiVisitor.kt
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/FilteringApiVisitor.kt
@@ -34,7 +34,6 @@ import com.android.tools.metalava.model.SourceFile
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeTransformer
 import com.android.tools.metalava.model.typeUseAnnotationFilter
-import java.util.function.Predicate
 
 /**
  * An [ApiVisitor] that filters the input and forwards it to the [delegate] [ItemVisitor].
@@ -75,21 +74,21 @@ class FilteringApiVisitor(
      * This is mutually exclusive with [interfaceListSorter].
      */
     private val interfaceListComparator: Comparator<TypeItem>? = null,
-    filterEmit: Predicate<Item>,
-    filterReference: Predicate<Item>,
+    apiFilters: ApiFilters,
     private val preFiltered: Boolean,
     private val filterSuperClassType: Boolean = true,
     showUnannotated: Boolean = true,
-    config: Config,
+    private val ignoreEmit: Boolean = false,
 ) :
     ApiVisitor(
         preserveClassNesting = delegate.requiresClassNesting,
+        // Only `SelectableItem`s can be filtered separately, i.e. `ParameterItem`s will be included
+        // if and only if their containing method is included.
+        visitParameterItems = false,
         inlineInheritedFields = inlineInheritedFields,
         callableComparator = callableComparator,
-        filterEmit = filterEmit,
-        filterReference = filterReference,
+        apiFilters = apiFilters,
         showUnannotated = showUnannotated,
-        config = config,
     ),
     ItemVisitor {
 
@@ -125,6 +124,10 @@ class FilteringApiVisitor(
     /** The current [ClassItem] being visited, */
     private var currentClassItem: FilteringClassItem? = null
 
+    override fun include(cls: ClassItem): Boolean {
+        return ignoreEmit || cls.emit
+    }
+
     override fun visitClass(cls: ClassItem) {
         // Switch the current class, if any, to be a containing class.
         containingClassStack.addLast(currentClassItem)
@@ -183,7 +186,7 @@ class FilteringApiVisitor(
         val delegate: ClassItem,
     ) : ClassItem by delegate {
 
-        override fun getSourceFile() = delegate.getSourceFile()?.let { FilteringSourceFile(it) }
+        override fun sourceFile() = delegate.sourceFile()?.let { FilteringSourceFile(it) }
 
         override fun superClass() = superClassType()?.asClass()
 
diff --git a/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/MatchOverridingMethodPredicate.kt b/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/MatchOverridingMethodPredicate.kt
new file mode 100644
index 000000000..02a9da6b4
--- /dev/null
+++ b/metalava-model/src/main/java/com/android/tools/metalava/model/visitors/MatchOverridingMethodPredicate.kt
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.visitors
+
+import com.android.tools.metalava.model.FilterPredicate
+import com.android.tools.metalava.model.MethodItem
+import com.android.tools.metalava.model.SelectableItem
+
+/**
+ * A [FilterPredicate] that will match a [SelectableItem] if [wrapped] matches it, or it is a
+ * [MethodItem] and [wrapped] matches any of its super methods.
+ *
+ * In other words this will match any [SelectableItem] that is matched by [wrapped] and any
+ * [MethodItem] that overrides a method which is matched by [wrapped].
+ */
+class MatchOverridingMethodPredicate(private val wrapped: FilterPredicate) : FilterPredicate {
+
+    override fun test(item: SelectableItem): Boolean {
+        return when {
+            wrapped.test(item) -> true
+            item is MethodItem -> item.findPredicateSuperMethod(wrapped) != null
+            else -> false
+        }
+    }
+}
diff --git a/metalava-model/src/test/java/com/android/tools/metalava/model/DefaultAnnotationItemTest.kt b/metalava-model/src/test/java/com/android/tools/metalava/model/DefaultAnnotationItemTest.kt
index 235306597..8e6df976e 100644
--- a/metalava-model/src/test/java/com/android/tools/metalava/model/DefaultAnnotationItemTest.kt
+++ b/metalava-model/src/test/java/com/android/tools/metalava/model/DefaultAnnotationItemTest.kt
@@ -32,7 +32,7 @@ class DefaultAnnotationItemTest {
             location = File("").canonicalFile,
             description = "",
             preFiltered = false,
-            annotationManager = noOpAnnotationManager,
+            config = Codebase.Config.NOOP,
             trustedApi = false,
             supportsDocumentation = false,
             assembler =
diff --git a/metalava/src/test/java/com/android/tools/metalava/PackageFilterTest.kt b/metalava-model/src/test/java/com/android/tools/metalava/model/PackageFilterTest.kt
similarity index 97%
rename from metalava/src/test/java/com/android/tools/metalava/PackageFilterTest.kt
rename to metalava-model/src/test/java/com/android/tools/metalava/model/PackageFilterTest.kt
index 356501751..a9b50fe6a 100644
--- a/metalava/src/test/java/com/android/tools/metalava/PackageFilterTest.kt
+++ b/metalava-model/src/test/java/com/android/tools/metalava/model/PackageFilterTest.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2018 The Android Open Source Project
+ * Copyright (C) 2024 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.android.tools.metalava
+package com.android.tools.metalava.model
 
 import com.google.common.truth.Truth.assertThat
 import org.junit.Test
diff --git a/metalava-model/src/test/java/com/android/tools/metalava/model/TypeItemTest.kt b/metalava-model/src/test/java/com/android/tools/metalava/model/TypeItemTest.kt
index 4469e804c..3f6ceab7e 100644
--- a/metalava-model/src/test/java/com/android/tools/metalava/model/TypeItemTest.kt
+++ b/metalava-model/src/test/java/com/android/tools/metalava/model/TypeItemTest.kt
@@ -21,13 +21,8 @@ import org.junit.Test
 
 class TypeItemTest {
     @Test
-    fun test() {
+    fun `test shortenTypes`() {
         assertThat(TypeItem.shortenTypes("@androidx.annotation.Nullable")).isEqualTo("@Nullable")
-        assertThat(TypeItem.shortenTypes(JAVA_LANG_STRING)).isEqualTo("String")
-        assertThat(TypeItem.shortenTypes("java.lang.reflect.Method"))
-            .isEqualTo("java.lang.reflect.Method")
-        assertThat(TypeItem.shortenTypes("java.util.List<java.lang.String>"))
-            .isEqualTo("java.util.List<java.lang.String>")
         assertThat(
                 TypeItem.shortenTypes(
                     "java.util.List<@androidx.annotation.NonNull java.lang.String>"
diff --git a/metalava-model/src/test/java/com/android/tools/metalava/model/TypeStringConfigurationTest.kt b/metalava-model/src/test/java/com/android/tools/metalava/model/TypeStringConfigurationTest.kt
new file mode 100644
index 000000000..0ca9c44f9
--- /dev/null
+++ b/metalava-model/src/test/java/com/android/tools/metalava/model/TypeStringConfigurationTest.kt
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model
+
+import kotlin.test.assertFalse
+import org.junit.Assert.assertTrue
+import org.junit.Test
+
+class TypeStringConfigurationTest {
+    @Test
+    fun `Test isDefault on DEFAULT`() {
+        // Make sure that isDefault is `true` on DEFAULT.
+        assertTrue(TypeStringConfiguration.DEFAULT.isDefault)
+    }
+
+    @Test
+    fun `Test isDefault on TypeStringConfiguration()`() {
+        assertTrue(TypeStringConfiguration().isDefault)
+    }
+
+    @Test
+    fun `Test isDefault on TypeStringConfiguration(annotations=true)`() {
+        assertFalse(TypeStringConfiguration(annotations = true).isDefault)
+    }
+}
diff --git a/metalava-model/src/test/java/com/android/tools/metalava/model/api/surface/ApiVariantSetTest.kt b/metalava-model/src/test/java/com/android/tools/metalava/model/api/surface/ApiVariantSetTest.kt
new file mode 100644
index 000000000..a9c6ad7d3
--- /dev/null
+++ b/metalava-model/src/test/java/com/android/tools/metalava/model/api/surface/ApiVariantSetTest.kt
@@ -0,0 +1,149 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.api.surface
+
+import kotlin.test.assertEquals
+import kotlin.test.assertFalse
+import kotlin.test.assertNotEquals
+import kotlin.test.assertSame
+import kotlin.test.assertTrue
+import org.junit.FixMethodOrder
+import org.junit.Test
+import org.junit.runners.MethodSorters
+
+@FixMethodOrder(MethodSorters.NAME_ASCENDING)
+class ApiVariantSetTest {
+    private val apiSurfaces = ApiSurfaces.create(needsBase = true)
+
+    private val main = apiSurfaces.main
+    private val base = apiSurfaces.base!!
+
+    @Test
+    fun `Test creation`() {
+        val mutable = MutableApiVariantSet.setOf(apiSurfaces)
+
+        assertTrue(mutable.isEmpty(), "isEmpty")
+        assertFalse(mutable.isNotEmpty(), "isNotEmpty")
+
+        for (variant in apiSurfaces.variants) {
+            assertFalse(mutable.contains(variant), "contains($variant)")
+        }
+
+        assertEquals("ApiVariantSet[]", mutable.toString(), "empty set")
+    }
+
+    @Test
+    fun `Test mutations`() {
+        val mutable = MutableApiVariantSet.setOf(apiSurfaces)
+
+        val mainCore = main.variantFor(ApiVariantType.CORE)
+        val baseRemoved = base.variantFor(ApiVariantType.REMOVED)
+
+        mutable.add(mainCore)
+
+        assertEquals("ApiVariantSet[main(C)]", mutable.toString())
+        assertTrue(mainCore in mutable, "main(C) should contain main(CORE)")
+        assertFalse(baseRemoved in mutable, "main(C) should not contain base(REMOVED)")
+        assertTrue(mutable.containsAny(main), "main(C) should contain something from main")
+        assertFalse(mutable.containsAny(base), "main(C) should not contain anything from base")
+
+        mutable.add(baseRemoved)
+
+        assertEquals("ApiVariantSet[base(R),main(C)]", mutable.toString())
+        assertTrue(mainCore in mutable, "base(R),main(C) should contain main(CORE)")
+        assertTrue(baseRemoved in mutable, "base(R),main(C) should contain base(REMOVED)")
+        assertTrue(mutable.containsAny(main), "base(R),main(C) should contain something from main")
+        assertTrue(mutable.containsAny(base), "base(R),main(C) should contain something from base")
+
+        mutable.remove(mainCore)
+
+        assertEquals("ApiVariantSet[base(R)]", mutable.toString())
+        assertFalse(mainCore in mutable, "base(R),main(C) should not contain main(CORE)")
+        assertTrue(baseRemoved in mutable, "base(R),main(C) should contain base(REMOVED)")
+        assertFalse(
+            mutable.containsAny(main),
+            "base(R),main(C) should not contain anything from main"
+        )
+        assertTrue(mutable.containsAny(base), "base(R),main(C) should contain something from base")
+    }
+
+    @Test
+    fun `Test clear`() {
+        val mutable = MutableApiVariantSet.setOf(apiSurfaces)
+
+        val mainCore = main.variantFor(ApiVariantType.CORE)
+        val baseCore = base.variantFor(ApiVariantType.CORE)
+
+        mutable.add(mainCore)
+        mutable.add(baseCore)
+
+        assertFalse(mutable.isEmpty(), "expected not empty before clear")
+        mutable.clear()
+        assertTrue(mutable.isEmpty(), "expected empty before clear")
+    }
+
+    @Test
+    fun `Test mutable and immutable`() {
+        val mutable = MutableApiVariantSet.setOf(apiSurfaces)
+
+        val mainCore = main.variantFor(ApiVariantType.CORE)
+        val baseCore = base.variantFor(ApiVariantType.CORE)
+
+        mutable.add(mainCore)
+        mutable.add(baseCore)
+
+        // Explicit type is needed to ensure correct type inference.
+        val immutable: BaseApiVariantSet = mutable.toImmutable()
+        assertEquals(mutable, immutable, "mutable and immutable set should be equal")
+        assertEquals(
+            mutable.hashCode(),
+            immutable.hashCode(),
+            "mutable and immutable set hashCode should be equal"
+        )
+
+        mutable.remove(mainCore)
+
+        assertNotEquals(mutable, immutable, "mutable and immutable set should not be equal")
+        assertNotEquals(
+            mutable.hashCode(),
+            immutable.hashCode(),
+            "mutable and immutable set hashCode should not be equal"
+        )
+
+        val anotherImmutable: BaseApiVariantSet = mutable.toImmutable()
+
+        assertNotEquals(
+            anotherImmutable,
+            immutable,
+            "anotherImmutable and immutable set should not be equal"
+        )
+        assertNotEquals(
+            anotherImmutable.hashCode(),
+            immutable.hashCode(),
+            "anotherImmutable and immutable set hashCode should not be equal"
+        )
+    }
+
+    @Test
+    fun `Test empty variant set`() {
+        val empty = apiSurfaces.emptyVariantSet
+        assertEquals(empty.toString(), "ApiVariantSet[]", "empty toString")
+
+        val mutable = MutableApiVariantSet.setOf(apiSurfaces)
+        assertSame(empty, mutable.toImmutable(), "empty mutable to immutable")
+    }
+}
diff --git a/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/Assertions.kt b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/Assertions.kt
index 642068236..3fa92d242 100644
--- a/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/Assertions.kt
+++ b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/Assertions.kt
@@ -16,6 +16,7 @@
 
 package com.android.tools.metalava.model
 
+import com.android.tools.metalava.model.testing.testTypeString
 import com.google.common.truth.Truth.assertThat
 import kotlin.test.assertEquals
 import kotlin.test.assertIs
@@ -66,6 +67,35 @@ interface Assertions {
         return packageItem
     }
 
+    /**
+     * Return a dump of the state of [SelectableItem.selectedApiVariants] across this [Codebase].
+     */
+    private fun Codebase.dumpSelectedApiVariants() = buildString {
+        accept(
+            object :
+                BaseItemVisitor(
+                    preserveClassNesting = true,
+                ) {
+                private var indent = ""
+
+                override fun visitSelectableItem(item: SelectableItem) {
+                    append("$indent${item.describe()} - ${item.selectedApiVariants}\n")
+                    indent += "  "
+                }
+
+                override fun afterVisitSelectableItem(item: SelectableItem) {
+                    indent = indent.substring(2)
+                }
+            }
+        )
+    }
+
+    /** Assert that the [dumpSelectedApiVariants] matches [expected]. */
+    fun Codebase.assertSelectedApiVariants(expected: String, message: String? = null) {
+        val actual = dumpSelectedApiVariants()
+        assertEquals(expected.trimIndent(), actual.trimEnd(), message)
+    }
+
     /** Get the field from the [ClassItem], failing if it does not exist. */
     fun ClassItem.assertField(fieldName: String): FieldItem {
         val fieldItem = findField(fieldName)
@@ -158,10 +188,10 @@ interface Assertions {
         append(name())
         append("(")
         parameters().joinTo(this) {
-            "${it.name()}: ${it.type().toTypeString(kotlinStyleNulls = true)}"
+            "${it.name()}: ${it.type().testTypeString(kotlinStyleNulls = true)}"
         }
         append("): ")
-        append(returnType().toTypeString(kotlinStyleNulls = true))
+        append(returnType().testTypeString(kotlinStyleNulls = true))
     }
 
     /** Get the list of fully qualified annotation names associated with the [TypeItem]. */
diff --git a/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/testing/TestableTypeItem.kt b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/testing/TestableTypeItem.kt
new file mode 100644
index 000000000..796848b3e
--- /dev/null
+++ b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/testing/TestableTypeItem.kt
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testing
+
+import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.TypeStringConfiguration
+
+/**
+ * The default [TypeStringConfiguration] that [testTypeString] uses to obtain the defaults for its
+ * parameters to avoid duplicating them.
+ */
+private val DEFAULT = TypeStringConfiguration.DEFAULT
+
+/**
+ * Convenience method to simplify testing.
+ *
+ * @see [TypeStringConfiguration] for information on the parameters.
+ */
+fun TypeItem.testTypeString(
+    annotations: Boolean = DEFAULT.annotations,
+    kotlinStyleNulls: Boolean = DEFAULT.kotlinStyleNulls,
+): String =
+    toTypeString(
+        TypeStringConfiguration(
+            annotations = annotations,
+            kotlinStyleNulls = kotlinStyleNulls,
+        )
+    )
diff --git a/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/testing/surfaces/SelectedApiVariantsTestData.kt b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/testing/surfaces/SelectedApiVariantsTestData.kt
new file mode 100644
index 000000000..c2d1d608f
--- /dev/null
+++ b/metalava-model/src/testFixtures/java/com/android/tools/metalava/model/testing/surfaces/SelectedApiVariantsTestData.kt
@@ -0,0 +1,228 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.model.testing.surfaces
+
+import com.android.tools.lint.checks.infrastructure.TestFile
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.SelectableItem
+import com.android.tools.metalava.testing.KnownSourceFiles
+import com.android.tools.metalava.testing.java
+import com.android.tools.metalava.testing.signature
+
+/** Encapsulates information about a [SelectableItem.selectedApiVariants] related test. */
+data class SelectedApiVariantsTestData(
+    /** The name of the test. */
+    val name: String,
+
+    /**
+     * A list of signature files, such that a signature file that is a delta on top of another comes
+     * after the one it extends.
+     */
+    val signatureFiles: List<TestFile>,
+
+    /**
+     * Java source files that contain a definition of the API provided in the signature files.
+     *
+     * These must be backwardly compatible with the API defined in [signatureFiles].
+     */
+    val javaSourceFiles: List<TestFile>,
+
+    /**
+     * The expected status of the [SelectableItem.selectedApiVariants] in the [Codebase] loaded from
+     * [signatureFiles].
+     */
+    val expectedSelectedApiVariants: String,
+) {
+    val needsBase = signatureFiles.any { it.targetRelativePath.contains("base") }
+
+    override fun toString() = name
+}
+
+/**
+ * A list of [SelectedApiVariantsTestData] used in `metalava-model-testsuite` and `metalava` tests.
+ *
+ * This is provided because the testsuite and main metalava command have slightly different paths in
+ * the handling of signature files. The testsuite tests check the behavior of the setting of
+ * [SelectableItem.selectedApiVariants] when loading signature files in a test environment, the main
+ * metalava tests will check the behavior when loading signature files for a previously released
+ * API. Using the same test data for both simplifies maintenance.
+ */
+// Suppress issues in javadoc in the tests, e.g. unknown `@removed` tag.
+@Suppress("JavadocDeclaration")
+val selectedApiVariantsTestData =
+    listOf(
+        // A test for public and removed signature files.
+        SelectedApiVariantsTestData(
+            name = "public and removed",
+            signatureFiles =
+                listOf(
+                    signature(
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Test {
+                                ctor public Test();
+                                field public int field;
+                                method public void foo(int);
+                              }
+                              public static class Test.Nested {
+                                ctor public Test.Nested();
+                              }
+                            }
+                        """
+                    ),
+                    signature(
+                        "removed.txt",
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Test {
+                                field public int removed;
+                              }
+                              public static class Test.Removed {
+                                ctor public Test.Removed();
+                              }
+                            }
+                        """
+                    ),
+                ),
+            javaSourceFiles =
+                listOf(
+                    java(
+                        """
+                            package test.pkg;
+
+                            public class Test {
+                                public int field;
+                                /** @removed */
+                                public int removed;
+                                public void foo(int p) {}
+                                public static class Nested {
+                                }
+                                /** @removed */
+                                public static class Removed {
+                                }
+                            }
+                        """
+                    ),
+                ),
+            expectedSelectedApiVariants =
+                """
+                    package test.pkg - ApiVariantSet[main(CR)]
+                      class test.pkg.Test - ApiVariantSet[main(CR)]
+                        constructor test.pkg.Test() - ApiVariantSet[main(C)]
+                        method test.pkg.Test.foo(int) - ApiVariantSet[main(C)]
+                        field test.pkg.Test.field - ApiVariantSet[main(C)]
+                        field test.pkg.Test.removed - ApiVariantSet[main(R)]
+                        class test.pkg.Test.Nested - ApiVariantSet[main(C)]
+                          constructor test.pkg.Test.Nested() - ApiVariantSet[main(C)]
+                        class test.pkg.Test.Removed - ApiVariantSet[main(R)]
+                          constructor test.pkg.Test.Removed() - ApiVariantSet[main(R)]
+                """,
+        ),
+        // A test consisting of a base and extending API.
+        SelectedApiVariantsTestData(
+            name = "base",
+            signatureFiles =
+                listOf(
+                    signature(
+                        "base.txt",
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Base {
+                                ctor public Base();
+                                field public int baseField;
+                                method public void baseMethod(int);
+                              }
+                              public class Test {
+                                ctor public Test();
+                                field public int baseField;
+                                method public void baseMethod(int);
+                              }
+                            }
+                        """
+                    ),
+                    signature(
+                        """
+                            // Signature format: 2.0
+                            package test.pkg {
+                              public class Test {
+                                field public int field;
+                                method public void method(int);
+                              }
+                              public static class Test.Nested {
+                                ctor public Test.Nested();
+                              }
+                            }
+                        """
+                    ),
+                ),
+            javaSourceFiles =
+                listOf(
+                    KnownSourceFiles.systemApiSource,
+                    java(
+                        """
+                            package test.pkg;
+
+                            public class Base {
+                                public int baseField;
+                                public void baseMethod(int p) {}
+                            }
+                        """
+                    ),
+                    java(
+                        """
+                            package test.pkg;
+
+                            import android.annotation.SystemApi;
+
+                            public class Test {
+                                /** @hide */
+                                @SystemApi
+                                public int field;
+
+                                /** @hide */
+                                @SystemApi
+                                public void method(int p) {}
+
+                                /** @hide */
+                                @SystemApi
+                                public static class Nested {
+                                }
+                            }
+                        """
+                    ),
+                ),
+            expectedSelectedApiVariants =
+                """
+                    package test.pkg - ApiVariantSet[base(C),main(C)]
+                      class test.pkg.Base - ApiVariantSet[base(C)]
+                        constructor test.pkg.Base() - ApiVariantSet[base(C)]
+                        method test.pkg.Base.baseMethod(int) - ApiVariantSet[base(C)]
+                        field test.pkg.Base.baseField - ApiVariantSet[base(C)]
+                      class test.pkg.Test - ApiVariantSet[base(C),main(C)]
+                        constructor test.pkg.Test() - ApiVariantSet[base(C)]
+                        method test.pkg.Test.baseMethod(int) - ApiVariantSet[base(C)]
+                        method test.pkg.Test.method(int) - ApiVariantSet[main(C)]
+                        field test.pkg.Test.baseField - ApiVariantSet[base(C)]
+                        field test.pkg.Test.field - ApiVariantSet[main(C)]
+                        class test.pkg.Test.Nested - ApiVariantSet[main(C)]
+                          constructor test.pkg.Test.Nested() - ApiVariantSet[main(C)]
+                """,
+        )
+    )
diff --git a/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Issues.kt b/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Issues.kt
index 2b973e080..9a0416bbf 100644
--- a/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Issues.kt
+++ b/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Issues.kt
@@ -239,6 +239,7 @@ object Issues {
     val FLAGGED_API_LITERAL by Issue(Severity.WARNING_ERROR_WHEN_NEW, Category.API_LINT)
     val GETTER_SETTER_NULLABILITY by Issue(Severity.WARNING_ERROR_WHEN_NEW, Category.API_LINT)
     val CONDITIONAL_REQUIRES_PERMISSION_NOT_EXPLAINED by Issue(Severity.HIDDEN, Category.API_LINT)
+    val VALUE_CLASS_DEFINITION by Issue(Severity.ERROR, Category.API_LINT)
 
     fun findIssueById(id: String?): Issue? {
         return nameToIssue[id]
diff --git a/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Reporter.kt b/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Reporter.kt
index 191560616..3451a77d8 100644
--- a/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Reporter.kt
+++ b/metalava-reporter/src/main/java/com/android/tools/metalava/reporter/Reporter.kt
@@ -17,7 +17,9 @@
 package com.android.tools.metalava.reporter
 
 import java.io.File
+import java.io.OutputStream
 import java.io.PrintWriter
+import java.io.Writer
 
 interface Reporter {
 
@@ -107,6 +109,10 @@ interface Reporter {
  * the supplied [PrintWriter].
  */
 class BasicReporter(private val stderr: PrintWriter) : Reporter {
+    constructor(writer: Writer) : this(PrintWriter(writer))
+
+    constructor(outputStream: OutputStream) : this(PrintWriter(outputStream))
+
     override fun report(
         id: Issues.Issue,
         reportable: Reportable?,
@@ -141,4 +147,8 @@ class BasicReporter(private val stderr: PrintWriter) : Reporter {
         reportable: Reportable?,
         message: String?
     ): Boolean = false
+
+    companion object {
+        val ERR = BasicReporter(System.err)
+    }
 }
diff --git a/metalava-testing/src/main/java/com/android/tools/metalava/testing/KnownSourceFiles.kt b/metalava-testing/src/main/java/com/android/tools/metalava/testing/KnownSourceFiles.kt
index bb923051d..e8a705743 100644
--- a/metalava-testing/src/main/java/com/android/tools/metalava/testing/KnownSourceFiles.kt
+++ b/metalava-testing/src/main/java/com/android/tools/metalava/testing/KnownSourceFiles.kt
@@ -204,4 +204,44 @@ object KnownSourceFiles {
                 }
             """
         )
+
+    val systemApiSource: TestFile =
+        TestFiles.java(
+            """
+                package android.annotation;
+                import static java.lang.annotation.ElementType.*;
+                import java.lang.annotation.*;
+                @Target({TYPE, FIELD, METHOD, CONSTRUCTOR, ANNOTATION_TYPE, PACKAGE})
+                @Retention(RetentionPolicy.SOURCE)
+                public @interface SystemApi {
+                    enum Client {
+                        /**
+                         * Specifies that the intended clients of a SystemApi are privileged apps.
+                         * This is the default value for {@link #client}.
+                         */
+                        PRIVILEGED_APPS,
+
+                        /**
+                         * Specifies that the intended clients of a SystemApi are used by classes in
+                         * <pre>BOOTCLASSPATH</pre> in mainline modules. Mainline modules can also expose
+                         * this type of system APIs too when they're used only by the non-updatable
+                         * platform code.
+                         */
+                        MODULE_LIBRARIES,
+
+                        /**
+                         * Specifies that the system API is available only in the system server process.
+                         * Use this to expose APIs from code loaded by the system server process <em>but</em>
+                         * not in <pre>BOOTCLASSPATH</pre>.
+                         */
+                        SYSTEM_SERVER
+                    }
+
+                    /**
+                     * The intended client of this SystemAPI.
+                     */
+                    Client client() default android.annotation.SystemApi.Client.PRIVILEGED_APPS;
+                }
+            """
+        )
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/AndroidApiChecks.kt b/metalava/src/main/java/com/android/tools/metalava/AndroidApiChecks.kt
index 70925b4e0..03c0b02c8 100644
--- a/metalava/src/main/java/com/android/tools/metalava/AndroidApiChecks.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/AndroidApiChecks.kt
@@ -24,6 +24,7 @@ import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.ParameterItem
+import com.android.tools.metalava.model.SelectableItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.visitors.ApiVisitor
 import com.android.tools.metalava.reporter.Issues
@@ -49,11 +50,13 @@ class AndroidApiChecks(val reporter: Reporter) {
         packageItem.accept(
             object :
                 ApiVisitor(
-                    // Sort by source order such that warnings follow source line number order
-                    callableComparator = CallableItem.sourceOrderComparator,
-                    config = @Suppress("DEPRECATION") options.apiVisitorConfig,
+                    apiPredicateConfig = @Suppress("DEPRECATION") options.apiPredicateConfig,
                 ) {
-                override fun visitItem(item: Item) {
+
+                override fun visitSelectableItem(item: SelectableItem) {
+                    // TODOs are only checked on [Item]s with documentation and [ParameterItem]s
+                    // do not have any. Documentation for parameters is stored within the containing
+                    // callable in @param sections.
                     checkTodos(item)
                 }
 
diff --git a/metalava/src/main/java/com/android/tools/metalava/AnnotationsMerger.kt b/metalava/src/main/java/com/android/tools/metalava/AnnotationsMerger.kt
index 316539bab..8418ac314 100644
--- a/metalava/src/main/java/com/android/tools/metalava/AnnotationsMerger.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/AnnotationsMerger.kt
@@ -46,6 +46,7 @@ import com.android.tools.metalava.model.ANDROIDX_INT_DEF
 import com.android.tools.metalava.model.ANDROIDX_NONNULL
 import com.android.tools.metalava.model.ANDROIDX_NULLABLE
 import com.android.tools.metalava.model.ANDROIDX_STRING_DEF
+import com.android.tools.metalava.model.ANDROID_FLAGGED_API
 import com.android.tools.metalava.model.ANNOTATION_VALUE_TRUE
 import com.android.tools.metalava.model.AnnotationAttribute
 import com.android.tools.metalava.model.AnnotationItem
@@ -55,6 +56,7 @@ import com.android.tools.metalava.model.DefaultAnnotationAttribute
 import com.android.tools.metalava.model.DefaultAnnotationItem
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.PackageItem
+import com.android.tools.metalava.model.SelectableItem
 import com.android.tools.metalava.model.TraversingVisitor
 import com.android.tools.metalava.model.TypeNullability
 import com.android.tools.metalava.model.source.SourceParser
@@ -136,7 +138,8 @@ class AnnotationsMerger(
                         SourceSet(javaStubFiles, roots),
                         SourceSet.empty(),
                         "Codebase loaded from stubs",
-                        classPath = options.classpath
+                        classPath = options.classpath,
+                        apiPackages = options.apiPackages,
                     )
                 mergeJavaStubsCodebase(javaStubsCodebase)
             }
@@ -242,8 +245,8 @@ class AnnotationsMerger(
         try {
             val signatureCodebase =
                 ApiFile.parseApi(
-                    SignatureFile.fromFile(file),
-                    codebase.annotationManager,
+                    SignatureFile.fromFiles(file),
+                    codebase.config,
                     "Signature files for annotation merger: loaded from $file"
                 )
             mergeQualifierAnnotationsFromCodebase(signatureCodebase)
@@ -268,7 +271,7 @@ class AnnotationsMerger(
     private fun mergeQualifierAnnotationsFromCodebase(externalCodebase: Codebase) {
         val visitor =
             object : ComparisonVisitor() {
-                override fun compare(old: Item, new: Item) {
+                override fun compareItems(old: Item, new: Item) {
                     val itemAnnotations = old.modifiers.annotations()
                     mergeQualifierAnnotations(itemAnnotations, new)
                     old.type()?.let {
@@ -279,7 +282,7 @@ class AnnotationsMerger(
                     }
                 }
 
-                override fun removed(old: Item, from: Item?) {
+                override fun removedItem(old: SelectableItem, from: SelectableItem?) {
                     // Do not report missing items if there are no annotations to copy.
                     if (old.modifiers.annotations().isEmpty()) {
                         old.type()?.let { typeItem ->
@@ -296,10 +299,7 @@ class AnnotationsMerger(
                 }
             }
 
-        CodebaseComparator(
-                apiVisitorConfig = @Suppress("DEPRECATION") options.apiVisitorConfig,
-            )
-            .compare(visitor, externalCodebase, codebase)
+        CodebaseComparator().compare(visitor, externalCodebase, codebase)
     }
 
     private fun mergeInclusionAnnotationsFromCodebase(externalCodebase: Codebase) {
@@ -611,10 +611,9 @@ class AnnotationsMerger(
                         // Attempt to sort in reflection order
                         if (!found && reflectionFields != null) {
                             val filterEmit =
-                                ApiVisitor(
-                                        config = @Suppress("DEPRECATION") options.apiVisitorConfig,
-                                    )
-                                    .filterEmit
+                                ApiVisitor.defaultEmitFilter(
+                                    @Suppress("DEPRECATION") options.apiPredicateConfig,
+                                )
 
                             // Attempt with reflection
                             var first = true
diff --git a/metalava/src/main/java/com/android/tools/metalava/ApiAnalyzer.kt b/metalava/src/main/java/com/android/tools/metalava/ApiAnalyzer.kt
index 8ef4b30c8..9139295c6 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ApiAnalyzer.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/ApiAnalyzer.kt
@@ -21,6 +21,7 @@ import com.android.tools.metalava.manifest.emptyManifest
 import com.android.tools.metalava.model.ANDROIDX_REQUIRES_PERMISSION
 import com.android.tools.metalava.model.ANDROID_ANNOTATION_PREFIX
 import com.android.tools.metalava.model.ANDROID_DEPRECATED_FOR_SDK
+import com.android.tools.metalava.model.ANDROID_SYSTEM_API
 import com.android.tools.metalava.model.ANNOTATION_ATTR_VALUE
 import com.android.tools.metalava.model.AnnotationAttributeValue
 import com.android.tools.metalava.model.AnnotationItem
@@ -32,10 +33,10 @@ import com.android.tools.metalava.model.ClassOrigin
 import com.android.tools.metalava.model.ClassTypeItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.FilterPredicate
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.JAVA_LANG_DEPRECATED
 import com.android.tools.metalava.model.MethodItem
-import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.PackageList
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.PropertyItem
@@ -43,13 +44,14 @@ import com.android.tools.metalava.model.SelectableItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeParameterList
 import com.android.tools.metalava.model.VariableTypeItem
+import com.android.tools.metalava.model.annotation.AnnotationFilter
 import com.android.tools.metalava.model.source.SourceParser
+import com.android.tools.metalava.model.visitors.ApiPredicate
 import com.android.tools.metalava.model.visitors.ApiVisitor
 import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.reporter.Reporter
 import java.io.File
 import java.util.Locale
-import java.util.function.Predicate
 
 /**
  * The [ApiAnalyzer] is responsible for walking over the various classes and members and compute
@@ -119,7 +121,7 @@ class ApiAnalyzer(
     // Warn about @DefaultValue("null"); they probably meant @DefaultNull
     // Supplying default parameter in override is not allowed!
 
-    fun generateInheritedStubs(filterEmit: Predicate<Item>, filterReference: Predicate<Item>) {
+    fun generateInheritedStubs(filterEmit: FilterPredicate, filterReference: FilterPredicate) {
         // When analyzing libraries we may discover some new classes during traversal; these aren't
         // part of the API but may be super classes or interfaces; these will then be added into the
         // package class lists, which could trigger a concurrent modification, so create a snapshot
@@ -132,8 +134,8 @@ class ApiAnalyzer(
 
     private fun generateInheritedStubs(
         cls: ClassItem,
-        filterEmit: Predicate<Item>,
-        filterReference: Predicate<Item>,
+        filterEmit: FilterPredicate,
+        filterReference: FilterPredicate,
         visited: MutableSet<ClassItem>,
     ) {
         // If it is not a class, i.e. an interface, etc., then return.
@@ -167,7 +169,7 @@ class ApiAnalyzer(
     private fun addInheritedInterfacesFrom(
         cls: ClassItem,
         hiddenSuperClasses: Sequence<ClassItem>,
-        filterReference: Predicate<Item>
+        filterReference: FilterPredicate
     ) {
         var interfaceTypes: MutableList<ClassTypeItem>? = null
         var interfaceTypeClasses: MutableList<ClassItem>? = null
@@ -209,8 +211,8 @@ class ApiAnalyzer(
         cls: ClassItem,
         hiddenSuperClasses: Sequence<ClassItem>,
         superClasses: Sequence<ClassItem>,
-        filterEmit: Predicate<Item>,
-        filterReference: Predicate<Item>
+        filterEmit: FilterPredicate,
+        filterReference: FilterPredicate
     ) {
         // Also generate stubs for any methods we would have inherited from abstract parents
         // All methods from super classes that (1) aren't overridden in this class already, and
@@ -394,22 +396,14 @@ class ApiAnalyzer(
         // level classes and then propagate them, and removed status, down onto the nested classes
         // and members.
         val visitor =
-            object : BaseItemVisitor(preserveClassNesting = true) {
-
-                override fun visitPackage(pkg: PackageItem) {
-                    pkg.variantSelectors.inheritInto()
-                }
-
-                override fun visitClass(cls: ClassItem) {
-                    cls.variantSelectors.inheritInto()
-                }
-
-                override fun visitCallable(callable: CallableItem) {
-                    callable.variantSelectors.inheritInto()
-                }
-
-                override fun visitField(field: FieldItem) {
-                    field.variantSelectors.inheritInto()
+            object :
+                BaseItemVisitor(
+                    preserveClassNesting = true,
+                    // Only SelectableItems can have variantSelectors.
+                    visitParameterItems = false,
+                ) {
+                override fun visitSelectableItem(item: SelectableItem) {
+                    item.variantSelectors.inheritInto()
                 }
             }
 
@@ -518,20 +512,21 @@ class ApiAnalyzer(
         codebase.accept(
             object :
                 ApiVisitor(
-                    config = @Suppress("DEPRECATION") options.apiVisitorConfig,
+                    apiPredicateConfig = @Suppress("DEPRECATION") options.apiPredicateConfig,
                 ) {
                 override fun visitParameter(parameter: ParameterItem) {
                     checkTypeReferencesHidden(parameter, parameter.type())
                 }
 
-                override fun visitItem(item: Item) {
-                    // None of the checks in this apply to [ParameterItem]. The deprecation checks
-                    // do not apply as there is no way to provide an `@deprecation` tag in Javadoc
-                    // for parameters. The unhidden showability annotation check
-                    // ('UnhiddemSystemApi`) does not apply as you cannot annotation a
-                    // [ParameterItem] with a showability annotation.
-                    if (item is ParameterItem) return
-
+                /**
+                 * Visit all [SelectableItem]s, i.e. all [Item]s apart from [ParameterItem]s.
+                 *
+                 * None of the checks in this apply to [ParameterItem]. The deprecation checks do
+                 * not apply as there is no way to provide an `@deprecation` tag in Javadoc for
+                 * parameters. The unhidden showability annotation check ('UnhiddemSystemApi`) does
+                 * not apply as you cannot annotate a [ParameterItem] with a showability annotation.
+                 */
+                override fun visitSelectableItem(item: SelectableItem) {
                     if (
                         item.originallyDeprecated &&
                             !item.documentationContainsDeprecated() &&
@@ -558,7 +553,7 @@ class ApiAnalyzer(
                         val deprecatedForSdk =
                             item.modifiers.findAnnotation(ANDROID_DEPRECATED_FOR_SDK)
                         if (deprecatedForSdk != null) {
-                            if (item.documentation.contains("@deprecated")) {
+                            if (item.documentation.hasTagSection("@deprecated")) {
                                 reporter.report(
                                     Issues.DEPRECATION_MISMATCH,
                                     item,
@@ -742,7 +737,7 @@ class ApiAnalyzer(
 
     private fun cantStripThis(
         cl: ClassItem,
-        filter: Predicate<Item>,
+        filter: FilterPredicate,
         notStrippable: MutableSet<ClassItem>,
         from: Item,
         usage: String
@@ -767,16 +762,16 @@ class ApiAnalyzer(
             return
         }
 
-        // cant strip any public fields or their generics
+        // can't strip any public fields or their generics
         for (field in cl.fields()) {
             if (!filter.test(field)) {
                 continue
             }
             cantStripThis(field.type(), field, filter, notStrippable, "in field type")
         }
-        // cant strip any of the type's generics
+        // can't strip any of the type's generics
         cantStripThis(cl.typeParameterList, filter, notStrippable, cl)
-        // cant strip any of the annotation elements
+        // can't strip any of the annotation elements
         // cantStripThis(cl.annotationElements(), notStrippable);
         // take care of methods
         cantStripThis(cl.methods(), filter, notStrippable)
@@ -835,7 +830,7 @@ class ApiAnalyzer(
 
     private fun cantStripThis(
         callables: List<CallableItem>,
-        filter: Predicate<Item>,
+        filter: FilterPredicate,
         notStrippable: MutableSet<ClassItem>,
     ) {
         // for each callable, blow open the parameters, throws and return types. also blow open
@@ -865,7 +860,7 @@ class ApiAnalyzer(
 
     private fun cantStripThis(
         typeParameterList: TypeParameterList,
-        filter: Predicate<Item>,
+        filter: FilterPredicate,
         notStrippable: MutableSet<ClassItem>,
         context: Item
     ) {
@@ -879,7 +874,7 @@ class ApiAnalyzer(
     private fun cantStripThis(
         type: TypeItem,
         context: Item,
-        filter: Predicate<Item>,
+        filter: FilterPredicate,
         notStrippable: MutableSet<ClassItem>,
         usage: String,
     ) {
diff --git a/metalava/src/main/java/com/android/tools/metalava/ApiLevelsGenerationOptions.kt b/metalava/src/main/java/com/android/tools/metalava/ApiLevelsGenerationOptions.kt
new file mode 100644
index 000000000..eeeab7e1d
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/ApiLevelsGenerationOptions.kt
@@ -0,0 +1,519 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava
+
+import com.android.tools.metalava.apilevels.ApiGenerator
+import com.android.tools.metalava.apilevels.ApiJsonPrinter
+import com.android.tools.metalava.apilevels.ApiVersion
+import com.android.tools.metalava.apilevels.ApiXmlPrinter
+import com.android.tools.metalava.apilevels.GenerateApiVersionsFromVersionedApisConfig
+import com.android.tools.metalava.apilevels.GenerateXmlConfig
+import com.android.tools.metalava.apilevels.VersionedSignatureApi
+import com.android.tools.metalava.apilevels.VersionedSourceApi
+import com.android.tools.metalava.cli.common.EarlyOptions
+import com.android.tools.metalava.cli.common.ExecutionEnvironment
+import com.android.tools.metalava.cli.common.MetalavaCliException
+import com.android.tools.metalava.cli.common.SignatureFileLoader
+import com.android.tools.metalava.cli.common.existingDir
+import com.android.tools.metalava.cli.common.existingFile
+import com.android.tools.metalava.cli.common.fileForPathInner
+import com.android.tools.metalava.cli.common.map
+import com.android.tools.metalava.cli.common.newFile
+import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.CodebaseFragment
+import com.github.ajalt.clikt.parameters.groups.OptionGroup
+import com.github.ajalt.clikt.parameters.options.default
+import com.github.ajalt.clikt.parameters.options.flag
+import com.github.ajalt.clikt.parameters.options.multiple
+import com.github.ajalt.clikt.parameters.options.option
+import com.github.ajalt.clikt.parameters.options.split
+import com.github.ajalt.clikt.parameters.options.validate
+import com.github.ajalt.clikt.parameters.types.int
+import java.io.File
+import java.io.IOException
+
+// XML API version related arguments.
+const val ARG_GENERATE_API_LEVELS = "--generate-api-levels"
+
+const val ARG_REMOVE_MISSING_CLASS_REFERENCES_IN_API_LEVELS =
+    "--remove-missing-class-references-in-api-levels"
+
+const val ARG_CURRENT_VERSION = "--current-version"
+const val ARG_FIRST_VERSION = "--first-version"
+const val ARG_CURRENT_CODENAME = "--current-codename"
+
+const val ARG_ANDROID_JAR_PATTERN = "--android-jar-pattern"
+
+const val ARG_SDK_JAR_ROOT = "--sdk-extensions-root"
+const val ARG_SDK_INFO_FILE = "--sdk-extensions-info"
+
+// JSON API version related arguments
+const val ARG_GENERATE_API_VERSION_HISTORY = "--generate-api-version-history"
+const val ARG_API_VERSION_SIGNATURE_FILES = "--api-version-signature-files"
+const val ARG_API_VERSION_NAMES = "--api-version-names"
+
+class ApiLevelsGenerationOptions(
+    private val executionEnvironment: ExecutionEnvironment = ExecutionEnvironment(),
+    private val earlyOptions: EarlyOptions = EarlyOptions(),
+) :
+    OptionGroup(
+        name = "Api Levels Generation",
+        help =
+            """
+                Options controlling the API levels file, e.g. `api-versions.xml` file.
+            """
+                .trimIndent()
+    ) {
+    /** API level XML file to generate. */
+    val generateApiLevelXml: File? by
+        option(
+                ARG_GENERATE_API_LEVELS,
+                metavar = "<xmlfile>",
+                help =
+                    """
+                        Reads android.jar SDK files and generates an XML file recording the API
+                        level for each class, method and field
+                    """
+                        .trimIndent(),
+            )
+            .newFile()
+
+    /** Whether references to missing classes should be removed from the api levels file. */
+    private val removeMissingClassReferencesInApiLevels: Boolean by
+        option(
+                ARG_REMOVE_MISSING_CLASS_REFERENCES_IN_API_LEVELS,
+                help =
+                    """
+                        Removes references to missing classes when generating the API levels XML
+                        file. This can happen when generating the XML file for the non-updatable
+                        portions of the module-lib sdk, as those non-updatable portions can
+                        reference classes that are part of an updatable apex.
+                    """
+                        .trimIndent(),
+            )
+            .flag()
+
+    /**
+     * The first api level of the codebase; typically 1 but can be higher for example for the System
+     * API.
+     */
+    private val firstApiLevel: Int by
+        option(
+                ARG_FIRST_VERSION,
+                metavar = "<numeric-version>",
+                help =
+                    """
+                        Sets the first API level to generate an API database from.
+                    """
+                        .trimIndent()
+            )
+            .int()
+            .default(1)
+
+    /**
+     * The last api level.
+     *
+     * This is one more than [currentApiLevel] if this is a developer preview build.
+     */
+    private val lastApiLevel
+        get() = currentApiLevel + if (isDeveloperPreviewBuild) 1 else 0
+
+    /** The api level of the codebase, or null if not known/specified */
+    private val optionalCurrentApiLevel: Int? by
+        option(
+                ARG_CURRENT_VERSION,
+                metavar = "<numeric-version>",
+                help =
+                    """
+                        Sets the current API level of the current source code. Must be greater than
+                        or equal to 27.
+                    """
+                        .trimIndent(),
+            )
+            .int()
+            .validate {
+                if (it <= 26) {
+                    throw MetalavaCliException("Suspicious currentApi=$it, expected at least 27")
+                }
+            }
+
+    /**
+     * Get the current API level.
+     *
+     * This must only be called if needed as it will fail if [ARG_CURRENT_VERSION] has not been
+     * specified.
+     */
+    private val currentApiLevel: Int
+        get() =
+            optionalCurrentApiLevel
+                ?: throw MetalavaCliException(
+                    stderr = "$ARG_GENERATE_API_LEVELS requires $ARG_CURRENT_VERSION"
+                )
+
+    /**
+     * The codename of the codebase: non-null string if this is a developer preview build, null if
+     * this is a release build.
+     */
+    private val currentCodeName: String? by
+        option(
+                ARG_CURRENT_CODENAME,
+                metavar = "<version-codename>",
+                help =
+                    """
+                        Sets the code name for the current source code.
+                    """
+                        .trimIndent(),
+            )
+            .map { if (it == "REL") null else it }
+
+    /** True if [currentCodeName] is specified, false otherwise. */
+    private val isDeveloperPreviewBuild
+        get() = currentCodeName != null
+
+    /** The list of patterns used to find matching jars in the set of files visible to Metalava. */
+    private val androidJarPatterns: List<String> by
+        option(
+                ARG_ANDROID_JAR_PATTERN,
+                metavar = "<android-jar-pattern>",
+                help =
+                    """
+                        Pattern to use to locate Android JAR files. Each pattern must contain a %
+                        character that will be replaced with each API level that is being included
+                        and if the result is an existing jar file then it will be taken as the
+                        definition of the API at that level.
+                    """
+                        .trimIndent(),
+            )
+            .multiple(default = emptyList())
+            .map {
+                buildList {
+                    addAll(it)
+                    // Fallbacks
+                    add("prebuilts/tools/common/api-versions/android-%/android.jar")
+                    add("prebuilts/sdk/%/public/android.jar")
+                }
+            }
+
+    /** Directory of prebuilt extension SDK jars that contribute to the API */
+    private val sdkJarRoot: File? by
+        option(
+                ARG_SDK_JAR_ROOT,
+                metavar = "<sdk-jar-root>",
+                help =
+                    """
+                        Points to root of prebuilt extension SDK jars, if any. This directory is
+                        expected to contain snapshots of historical extension SDK versions in the
+                        form of stub jars. The paths should be on the format
+                        \"<int>/public/<module-name>.jar\", where <int> corresponds to the extension
+                        SDK version, and <module-name> to the name of the mainline module.
+                    """
+                        .trimIndent(),
+            )
+            .existingDir()
+            .validate { checkSdkJarRootAndSdkInfoFile() }
+
+    /**
+     * Rules to filter out some extension SDK APIs from the API, and assign extensions to the APIs
+     * that are kept
+     */
+    private val sdkInfoFile: File? by
+        option(
+                ARG_SDK_INFO_FILE,
+                metavar = "<sdk-info-file>",
+                help =
+                    """
+                        Points to map of extension SDK APIs to include, if any. The file is a plain
+                        text file and describes, per extension SDK, what APIs from that extension
+                        to include in the file created via $ARG_GENERATE_API_LEVELS. The format of
+                        each line is one of the following:
+                        \"<module-name> <pattern> <ext-name> [<ext-name> [...]]\", where
+                        <module-name> is the name of the mainline module this line refers to,
+                        <pattern> is a common Java name prefix of the APIs this line refers to, and
+                        <ext-name> is a list of extension SDK names in which these SDKs first
+                        appeared, or \"<ext-name> <ext-id> <type>\", where <ext-name> is the name of
+                        an SDK, <ext-id> its numerical ID and <type> is one of \"platform\" (the
+                        Android platform SDK), \"platform-ext\" (an extension to the Android
+                        platform SDK), \"standalone\" (a separate SDK). Fields are separated by
+                        whitespace. A mainline module may be listed multiple times.
+                        The special pattern \"*\" refers to all APIs in the given mainline module.
+                        Lines beginning with # are comments.
+                    """
+                        .trimIndent(),
+            )
+            .existingFile()
+            .validate { checkSdkJarRootAndSdkInfoFile() }
+
+    /**
+     * Check the [sdkJarRoot] and [sdkInfoFile] to make sure that if one is specified they are both
+     * specified
+     *
+     * This is called if either of those is set to a non-null value so all this needs to do is make
+     * sure that neither are `null`.
+     */
+    private fun checkSdkJarRootAndSdkInfoFile() {
+        if ((sdkJarRoot == null) || (sdkInfoFile == null)) {
+            throw MetalavaCliException(
+                stderr = "$ARG_SDK_JAR_ROOT and $ARG_SDK_INFO_FILE must both be supplied"
+            )
+        }
+    }
+
+    /**
+     * Get label for [level].
+     *
+     * If a codename has been specified and [level] is greater than the current API level (which
+     * defaults to `-1` when not set) then use the codename as the label, otherwise use the number
+     * itself.
+     */
+    fun getApiLevelLabel(level: Int): String {
+        val codename = currentCodeName
+        val current = optionalCurrentApiLevel
+        return if (current == null || codename == null || level <= current) level.toString()
+        else codename
+    }
+
+    /**
+     * Check whether [level] should be included in documentation.
+     *
+     * If [isDeveloperPreviewBuild] is `true` then allow any API level as the documentation is not
+     * going to be published outside Android, so it is safe to include all API levels, including the
+     * next one.
+     *
+     * If no [currentApiLevel] has been provided then allow any API level as there is no way to
+     * determine whether the API level is a future API or not.
+     *
+     * Otherwise, it is a release build so ignore any API levels after the current one.
+     */
+    fun includeApiLevelInDocumentation(level: Int): Boolean {
+        if (isDeveloperPreviewBuild) return true
+        val current = optionalCurrentApiLevel ?: return true
+        return level <= current
+    }
+
+    /**
+     * The list of jar files from which the API levels file will be populated. One for each API
+     * level, indexed by API level, starting from 1. The 0th element plus any element less than
+     * [firstApiLevel] is a placeholder that is an invalid file and should not be used.
+     */
+    private val apiLevelJars
+        get() = findAndroidJars()
+
+    /** Find an android stub jar that matches the given criteria. */
+    private fun findAndroidJars(): List<File> {
+        val apiLevelFiles = mutableListOf<File>()
+        // api level 0: placeholder, should not be processed.
+        // (This is here because we want the array index to match
+        // the API level)
+        val element = File("not an api: the starting API index is $firstApiLevel")
+        for (i in 0 until firstApiLevel) {
+            apiLevelFiles.add(element)
+        }
+
+        // Get all the android.jar. They are in platforms-#
+        for (apiLevel in firstApiLevel.rangeTo(lastApiLevel)) {
+            try {
+                val jar = getAndroidJarFile(apiLevel, androidJarPatterns)
+                if (jar == null || !jar.isFile) {
+                    verbosePrint { "Last API level found: ${apiLevel - 1}" }
+
+                    if (apiLevel < 28) {
+                        // Clearly something is wrong with the patterns; this should result in a
+                        // build error
+                        throw MetalavaCliException(
+                            stderr =
+                                "Could not find android.jar for API level $apiLevel; the " +
+                                    "$ARG_ANDROID_JAR_PATTERN set might be invalid see:" +
+                                    " ${androidJarPatterns.joinToString()} (the last two entries are defaults)"
+                        )
+                    }
+
+                    break
+                }
+
+                verbosePrint { "Found API $apiLevel at ${jar.path}" }
+
+                apiLevelFiles.add(jar)
+            } catch (e: IOException) {
+                e.printStackTrace()
+            }
+        }
+
+        return apiLevelFiles.toList()
+    }
+
+    /** Print string returned by [message] if verbose output has been requested. */
+    private inline fun verbosePrint(message: () -> String) {
+        if (earlyOptions.verbosity.verbose) {
+            executionEnvironment.stdout.println(message())
+        }
+    }
+
+    private fun getAndroidJarFile(apiLevel: Int, patterns: List<String>): File? {
+        return patterns
+            .map { fileForPathInner(it.replace("%", apiLevel.toString())) }
+            .firstOrNull { it.isFile }
+    }
+
+    private val sdkExtensionsArguments
+        get() =
+            if (sdkJarRoot != null && sdkInfoFile != null) {
+                ApiGenerator.SdkExtensionsArguments(
+                    sdkJarRoot!!,
+                    sdkInfoFile!!,
+                )
+            } else {
+                null
+            }
+
+    val generateXmlConfig
+        get() =
+            generateApiLevelXml?.let { outputFile ->
+                GenerateXmlConfig(
+                    apiLevels = apiLevelJars,
+                    firstApiLevel = firstApiLevel,
+                    currentSdkVersion = ApiVersion.fromLevel(currentApiLevel),
+                    isDeveloperPreviewBuild = isDeveloperPreviewBuild,
+                    outputFile = outputFile,
+                    sdkExtensionsArguments = sdkExtensionsArguments,
+                    removeMissingClasses = removeMissingClassReferencesInApiLevels,
+                )
+            }
+
+    /** API version history file to generate */
+    private val generateApiVersionHistory by
+        option(
+                ARG_GENERATE_API_VERSION_HISTORY,
+                metavar = "<output-file>",
+                help =
+                    """
+                        Reads API signature files and generates a JSON or XML file depending on the
+                        extension, which must be one of `json` or `xml` respectively. The JSON file
+                        will record the API version in which each class, method, and field. was
+                        added in and (if applicable) deprecated in. The XML file will include that
+                        information and more but will be optimized to exclude information from
+                        class members which is the same as the containing class.
+                    """
+                        .trimIndent(),
+            )
+            .newFile()
+
+    /**
+     * Ordered list of signatures for each past API version, when generating
+     * [generateApiVersionHistory].
+     */
+    private val apiVersionSignatureFiles by
+        option(
+                ARG_API_VERSION_SIGNATURE_FILES,
+                metavar = "<files>",
+                help =
+                    """
+                        An ordered list of text API signature files. The oldest API version should
+                        be first, the newest last. This should not include a signature file for the
+                        current API version, which will be parsed from the provided source files.
+                        Not required to generate API version JSON if the current version is the only
+                        version.
+                    """
+                        .trimIndent(),
+            )
+            .existingFile()
+            .split(File.pathSeparator)
+
+    /**
+     * The names of the API versions in [apiVersionSignatureFiles], in the same order, and the name
+     * of the current API version
+     */
+    private val apiVersionNames by
+        option(
+                ARG_API_VERSION_NAMES,
+                metavar = "<api-versions>",
+                help =
+                    """
+                        An ordered list of strings with the names to use for the API versions from
+                        $ARG_API_VERSION_SIGNATURE_FILES, and the name of the current API version.
+                        Required for $ARG_GENERATE_API_VERSION_HISTORY.
+                    """
+                        .trimIndent()
+            )
+            .split(" ")
+
+    /**
+     * Construct the [GenerateApiVersionsFromVersionedApisConfig] from the options.
+     *
+     * If no relevant command line options were provided then this will return `null`, otherwise it
+     * will validate the options and if all is well construct and return a
+     * [GenerateApiVersionsFromVersionedApisConfig] object.
+     *
+     * @param signatureFileLoader used for loading [Codebase]s from signature files.
+     * @param codebaseFragmentProvider provides access to the [CodebaseFragment] for the API defined
+     *   in the sources. This will only be called if a [GenerateApiVersionsFromVersionedApisConfig]
+     *   needs to be created.
+     */
+    fun fromSignatureFilesConfig(
+        signatureFileLoader: SignatureFileLoader,
+        codebaseFragmentProvider: () -> CodebaseFragment,
+    ): GenerateApiVersionsFromVersionedApisConfig? {
+        // apiVersionNames will include the current version but apiVersionSignatureFiles will not,
+        // so there should be 1 more name than signature file (or both can be null)
+        val numVersionNames = apiVersionNames?.size ?: 0
+        val numVersionFiles = apiVersionSignatureFiles?.size ?: 0
+        if (numVersionNames != 0 && numVersionNames != numVersionFiles + 1) {
+            throw MetalavaCliException(
+                "$ARG_API_VERSION_NAMES must have one more version than $ARG_API_VERSION_SIGNATURE_FILES to include the current version name"
+            )
+        }
+
+        val apiVersionsFile = generateApiVersionHistory
+        val apiVersionNames = apiVersionNames
+        return if (apiVersionsFile != null && apiVersionNames != null) {
+            // The signature files can be null if the current version is the only version
+            val pastApiVersions = apiVersionSignatureFiles ?: emptyList()
+
+            val allVersions = apiVersionNames.map { ApiVersion.fromString(it) }
+
+            val sourceVersion = allVersions.last()
+
+            // Combine the `pastApiVersions` and `apiVersionNames` into a list of
+            // `VersionedSignatureApi`s.
+            val versionedApis = buildList {
+                pastApiVersions.mapIndexedTo(this) { index, file ->
+                    VersionedSignatureApi(signatureFileLoader, file, allVersions[index])
+                }
+                // Add a VersionedSourceApi for the source code.
+                val codebaseFragment = codebaseFragmentProvider()
+                add(VersionedSourceApi(codebaseFragment, sourceVersion))
+            }
+
+            val printer =
+                when (val extension = apiVersionsFile.extension) {
+                    "xml" -> ApiXmlPrinter(null, 1, allVersions)
+                    "json" -> ApiJsonPrinter()
+                    else ->
+                        error(
+                            "unexpected extension for $apiVersionsFile, expected 'xml', or 'json' got '$extension'"
+                        )
+                }
+
+            GenerateApiVersionsFromVersionedApisConfig(
+                versionedApis = versionedApis,
+                outputFile = apiVersionsFile,
+                printer = printer,
+            )
+        } else {
+            null
+        }
+    }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/ApiSelectionOptions.kt b/metalava/src/main/java/com/android/tools/metalava/ApiSelectionOptions.kt
index 9783fdfda..1374ce700 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ApiSelectionOptions.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/ApiSelectionOptions.kt
@@ -16,6 +16,7 @@
 
 package com.android.tools.metalava
 
+import com.android.tools.metalava.model.annotation.AnnotationFilter
 import com.github.ajalt.clikt.parameters.groups.OptionGroup
 import com.github.ajalt.clikt.parameters.options.multiple
 import com.github.ajalt.clikt.parameters.options.option
diff --git a/metalava/src/main/java/com/android/tools/metalava/ComparisonVisitor.kt b/metalava/src/main/java/com/android/tools/metalava/ComparisonVisitor.kt
index 644aa4077..5d194499f 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ComparisonVisitor.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/ComparisonVisitor.kt
@@ -16,79 +16,76 @@
 
 package com.android.tools.metalava
 
-import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.ConstructorItem
 import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.FilterPredicate
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.MergedCodebase
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.PropertyItem
+import com.android.tools.metalava.model.SelectableItem
+import com.android.tools.metalava.model.visitors.ApiFilters
 import com.android.tools.metalava.model.visitors.ApiVisitor
-import java.util.function.Predicate
 
 /**
  * Visitor which visits all items in two matching codebases and matches up the items and invokes
- * [compare] on each pair, or [added] or [removed] when items are not matched
+ * [compareItems] on each pair, or [addedItem] or [removedItem] when items are not matched
  */
 open class ComparisonVisitor {
-    open fun compare(old: Item, new: Item) {}
+    open fun compareItems(old: Item, new: Item) {}
 
-    open fun added(new: Item) {}
+    open fun addedItem(new: SelectableItem) {}
 
-    open fun removed(old: Item, from: Item?) {}
+    open fun removedItem(old: SelectableItem, from: SelectableItem?) {}
 
-    open fun compare(old: PackageItem, new: PackageItem) {}
+    open fun comparePackageItems(old: PackageItem, new: PackageItem) {}
 
-    open fun compare(old: ClassItem, new: ClassItem) {}
+    open fun compareClassItems(old: ClassItem, new: ClassItem) {}
 
-    open fun compare(old: CallableItem, new: CallableItem) {}
+    open fun compareCallableItems(old: CallableItem, new: CallableItem) {}
 
-    open fun compare(old: ConstructorItem, new: ConstructorItem) {}
+    open fun compareConstructorItems(old: ConstructorItem, new: ConstructorItem) {}
 
-    open fun compare(old: MethodItem, new: MethodItem) {}
+    open fun compareMethodItems(old: MethodItem, new: MethodItem) {}
 
-    open fun compare(old: FieldItem, new: FieldItem) {}
+    open fun compareFieldItems(old: FieldItem, new: FieldItem) {}
 
-    open fun compare(old: PropertyItem, new: PropertyItem) {}
+    open fun comparePropertyItems(old: PropertyItem, new: PropertyItem) {}
 
-    open fun compare(old: ParameterItem, new: ParameterItem) {}
+    open fun compareParameterItems(old: ParameterItem, new: ParameterItem) {}
 
-    open fun added(new: PackageItem) {}
+    open fun addedPackageItem(new: PackageItem) {}
 
-    open fun added(new: ClassItem) {}
+    open fun addedClassItem(new: ClassItem) {}
 
-    open fun added(new: CallableItem) {}
+    open fun addedCallableItem(new: CallableItem) {}
 
-    open fun added(new: ConstructorItem) {}
+    open fun addedConstructorItem(new: ConstructorItem) {}
 
-    open fun added(new: MethodItem) {}
+    open fun addedMethodItem(new: MethodItem) {}
 
-    open fun added(new: FieldItem) {}
+    open fun addedFieldItem(new: FieldItem) {}
 
-    open fun added(new: PropertyItem) {}
+    open fun addedPropertyItem(new: PropertyItem) {}
 
-    open fun added(new: ParameterItem) {}
+    open fun removedPackageItem(old: PackageItem, from: PackageItem?) {}
 
-    open fun removed(old: PackageItem, from: Item?) {}
+    open fun removedClassItem(old: ClassItem, from: SelectableItem) {}
 
-    open fun removed(old: ClassItem, from: Item?) {}
+    open fun removedCallableItem(old: CallableItem, from: ClassItem) {}
 
-    open fun removed(old: CallableItem, from: ClassItem?) {}
+    open fun removedConstructorItem(old: ConstructorItem, from: ClassItem) {}
 
-    open fun removed(old: ConstructorItem, from: ClassItem?) {}
+    open fun removedMethodItem(old: MethodItem, from: ClassItem) {}
 
-    open fun removed(old: MethodItem, from: ClassItem?) {}
+    open fun removedFieldItem(old: FieldItem, from: ClassItem) {}
 
-    open fun removed(old: FieldItem, from: ClassItem?) {}
-
-    open fun removed(old: PropertyItem, from: ClassItem?) {}
-
-    open fun removed(old: ParameterItem, from: MethodItem?) {}
+    open fun removedPropertyItem(old: PropertyItem, from: ClassItem) {}
 }
 
 /** Simple stack type built on top of an [ArrayList]. */
@@ -102,9 +99,7 @@ private fun <E> Stack<E>.pop(): E = removeAt(lastIndex)
 
 private fun <E> Stack<E>.peek(): E = last()
 
-class CodebaseComparator(
-    private val apiVisitorConfig: ApiVisitor.Config,
-) {
+class CodebaseComparator {
     /**
      * Visits this codebase and compares it with another codebase, informing the visitors about the
      * correlations and differences that it finds
@@ -113,7 +108,7 @@ class CodebaseComparator(
         visitor: ComparisonVisitor,
         old: Codebase,
         new: Codebase,
-        filter: Predicate<Item>? = null
+        filter: FilterPredicate? = null
     ) {
         // Algorithm: build up two trees (by nesting level); then visit the
         // two trees
@@ -132,7 +127,7 @@ class CodebaseComparator(
         visitor: ComparisonVisitor,
         old: MergedCodebase,
         new: MergedCodebase,
-        filter: Predicate<Item>? = null
+        filter: FilterPredicate? = null
     ) {
         // Algorithm: build up two trees (by nesting level); then visit the
         // two trees
@@ -151,9 +146,9 @@ class CodebaseComparator(
         visitor: ComparisonVisitor,
         oldList: List<ItemTree>,
         newList: List<ItemTree>,
-        newParent: Item?,
-        oldParent: Item?,
-        filter: Predicate<Item>?
+        newParent: SelectableItem?,
+        oldParent: SelectableItem?,
+        filter: FilterPredicate?
     ) {
         // Debugging tip: You can print out a tree like this: ItemTree.prettyPrint(list)
         var index1 = 0
@@ -179,8 +174,6 @@ class CodebaseComparator(
                                     new,
                                     oldParent,
                                     visitor,
-                                    newTree,
-                                    filter
                                 )
                             }
                         }
@@ -189,10 +182,9 @@ class CodebaseComparator(
                             if (old.emit) {
                                 dispatchToRemovedOrCompareIfItemWasMoved(
                                     old,
-                                    oldTree,
                                     visitor,
                                     newParent,
-                                    filter
+                                    filter,
                                 )
                             }
                         }
@@ -205,18 +197,15 @@ class CodebaseComparator(
                                         new,
                                         oldParent,
                                         visitor,
-                                        newTree,
-                                        filter
                                     )
                                 }
                             } else {
                                 if (old.emit) {
                                     dispatchToRemovedOrCompareIfItemWasMoved(
                                         old,
-                                        oldTree,
                                         visitor,
                                         newParent,
-                                        filter
+                                        filter,
                                     )
                                 }
                             }
@@ -242,10 +231,9 @@ class CodebaseComparator(
                         val old = oldTree.item()
                         dispatchToRemovedOrCompareIfItemWasMoved(
                             old,
-                            oldTree,
                             visitor,
                             newParent,
-                            filter
+                            filter,
                         )
                     }
                 }
@@ -255,7 +243,7 @@ class CodebaseComparator(
                     val newTree = newList[index2++]
                     val new = newTree.item()
 
-                    dispatchToAddedOrCompareIfItemWasMoved(new, oldParent, visitor, newTree, filter)
+                    dispatchToAddedOrCompareIfItemWasMoved(new, oldParent, visitor)
                 }
             } else {
                 break
@@ -263,16 +251,33 @@ class CodebaseComparator(
         }
     }
 
+    /**
+     * Dispatch calls to [ComparisonVisitor.compareParameterItems] for each pair of [ParameterItem]s
+     * in [oldParameters] and [newParameters].
+     *
+     * The [oldParameters] and [newParameters] are guaranteed to have the same number of parameters
+     * as they come from two [MethodItem]s that compare equal according to [comparator].
+     */
+    private fun dispatchCompareParameters(
+        visitor: ComparisonVisitor,
+        oldParameters: List<ParameterItem>,
+        newParameters: List<ParameterItem>,
+    ) {
+        require(oldParameters.size == newParameters.size)
+        for ((oldParameter, newParameter) in oldParameters.zip(newParameters)) {
+            visitor.compareItems(oldParameter, newParameter)
+            visitor.compareParameterItems(oldParameter, newParameter)
+        }
+    }
+
     /**
      * Checks to see whether [new] has actually been added or if it was just moved from elsewhere
      * and dispatch to the appropriate method.
      */
     private fun dispatchToAddedOrCompareIfItemWasMoved(
-        new: Item,
-        oldParent: Item?,
+        new: SelectableItem,
+        oldParent: SelectableItem?,
         visitor: ComparisonVisitor,
-        newTree: ItemTree,
-        filter: Predicate<Item>?
     ) {
         // If it's a method, we may not have added a new method,
         // we may simply have inherited it previously and overriding
@@ -293,45 +298,39 @@ class CodebaseComparator(
 
         if (inherited != null) {
             dispatchToCompare(visitor, inherited, new)
-            // Compare the children (recurse)
-            if (inherited.parameters().isNotEmpty()) {
-                val parameters = inherited.parameters().map { ItemTree(it) }.toList()
-                compare(visitor, parameters, newTree.children, newTree.item(), inherited, filter)
-            }
         } else {
             dispatchToAdded(visitor, new)
         }
     }
 
     /** Dispatch to the [Item] specific `added(...)` method. */
-    private fun dispatchToAdded(visitor: ComparisonVisitor, item: Item) {
-        visitor.added(item)
+    private fun dispatchToAdded(visitor: ComparisonVisitor, item: SelectableItem) {
+        visitor.addedItem(item)
 
         if (item is CallableItem) {
-            visitor.added(item)
+            visitor.addedCallableItem(item)
         }
 
         when (item) {
-            is PackageItem -> visitor.added(item)
-            is ClassItem -> visitor.added(item)
-            is ConstructorItem -> visitor.added(item)
-            is MethodItem -> visitor.added(item)
-            is FieldItem -> visitor.added(item)
-            is ParameterItem -> visitor.added(item)
-            is PropertyItem -> visitor.added(item)
+            is PackageItem -> visitor.addedPackageItem(item)
+            is ClassItem -> visitor.addedClassItem(item)
+            is ConstructorItem -> visitor.addedConstructorItem(item)
+            is MethodItem -> visitor.addedMethodItem(item)
+            is FieldItem -> visitor.addedFieldItem(item)
+            is PropertyItem -> visitor.addedPropertyItem(item)
+            else -> error("unexpected addition of $item")
         }
     }
 
     /**
-     * Checks to see whether [new] has actually been removed or if it was just moved from elsewhere
+     * Checks to see whether [old] has actually been removed or if it was just moved from elsewhere
      * and dispatch to the appropriate method.
      */
     private fun dispatchToRemovedOrCompareIfItemWasMoved(
-        old: Item,
-        oldTree: ItemTree,
+        old: SelectableItem,
         visitor: ComparisonVisitor,
-        newParent: Item?,
-        filter: Predicate<Item>?
+        newParent: SelectableItem?,
+        filter: FilterPredicate?
     ) {
         // If it's a method, we may not have removed the method, we may have simply
         // removed an override and are now inheriting the method from a superclass.
@@ -353,18 +352,6 @@ class CodebaseComparator(
 
         if (inheritedMethod != null) {
             dispatchToCompare(visitor, old, inheritedMethod)
-            // Compare the children (recurse)
-            if (inheritedMethod.parameters().isNotEmpty()) {
-                val parameters = inheritedMethod.parameters().map { ItemTree(it) }.toList()
-                compare(
-                    visitor,
-                    oldTree.children,
-                    parameters,
-                    oldTree.item(),
-                    inheritedMethod,
-                    filter
-                )
-            }
             return
         }
 
@@ -395,44 +382,58 @@ class CodebaseComparator(
     }
 
     /** Dispatch to the [Item] specific `removed(...)` method. */
-    private fun dispatchToRemoved(visitor: ComparisonVisitor, item: Item, from: Item?) {
-        visitor.removed(item, from)
+    private fun dispatchToRemoved(
+        visitor: ComparisonVisitor,
+        item: SelectableItem,
+        from: SelectableItem?
+    ) {
+        visitor.removedItem(item, from)
 
         if (item is CallableItem) {
-            visitor.removed(item, from as ClassItem?)
+            visitor.removedCallableItem(item, from as ClassItem)
         }
 
         when (item) {
-            is PackageItem -> visitor.removed(item, from)
-            is ClassItem -> visitor.removed(item, from)
-            is ConstructorItem -> visitor.removed(item, from as ClassItem?)
-            is MethodItem -> visitor.removed(item, from as ClassItem?)
-            is FieldItem -> visitor.removed(item, from as ClassItem?)
-            is ParameterItem -> visitor.removed(item, from as MethodItem?)
-            is PropertyItem -> visitor.removed(item, from as ClassItem?)
+            is PackageItem -> visitor.removedPackageItem(item, from as PackageItem?)
+            is ClassItem -> visitor.removedClassItem(item, from as SelectableItem)
+            is ConstructorItem -> visitor.removedConstructorItem(item, from as ClassItem)
+            is MethodItem -> visitor.removedMethodItem(item, from as ClassItem)
+            is FieldItem -> visitor.removedFieldItem(item, from as ClassItem)
+            is PropertyItem -> visitor.removedPropertyItem(item, from as ClassItem)
+            else -> error("unexpected removal of $item")
         }
     }
 
     /** Dispatch to the [Item] specific `compare(...)` method. */
-    private fun dispatchToCompare(visitor: ComparisonVisitor, old: Item, new: Item) {
-        visitor.compare(old, new)
+    private fun dispatchToCompare(
+        visitor: ComparisonVisitor,
+        old: SelectableItem,
+        new: SelectableItem
+    ) {
+        visitor.compareItems(old, new)
 
         if (old is CallableItem) {
-            visitor.compare(old, new as CallableItem)
+            visitor.compareCallableItems(old, new as CallableItem)
         }
 
         when (old) {
-            is PackageItem -> visitor.compare(old, new as PackageItem)
-            is ClassItem -> visitor.compare(old, new as ClassItem)
-            is ConstructorItem -> visitor.compare(old, new as ConstructorItem)
-            is MethodItem -> visitor.compare(old, new as MethodItem)
-            is FieldItem -> visitor.compare(old, new as FieldItem)
-            is ParameterItem -> visitor.compare(old, new as ParameterItem)
-            is PropertyItem -> visitor.compare(old, new as PropertyItem)
+            is PackageItem -> visitor.comparePackageItems(old, new as PackageItem)
+            is ClassItem -> visitor.compareClassItems(old, new as ClassItem)
+            is ConstructorItem -> visitor.compareConstructorItems(old, new as ConstructorItem)
+            is MethodItem -> visitor.compareMethodItems(old, new as MethodItem)
+            is FieldItem -> visitor.compareFieldItems(old, new as FieldItem)
+            is PropertyItem -> visitor.comparePropertyItems(old, new as PropertyItem)
+            else -> error("unexpected comparison of $old and $new")
+        }
+
+        // If this is comparing two [CallableItem]s then compare their [ParameterItem]s too.
+        if (old is CallableItem) {
+            dispatchCompareParameters(visitor, old.parameters(), (new as CallableItem).parameters())
         }
     }
 
-    private fun compare(item1: Item, item2: Item): Int = comparator.compare(item1, item2)
+    private fun compare(item1: SelectableItem, item2: SelectableItem): Int =
+        comparator.compare(item1, item2)
 
     companion object {
         /** Sorting rank for types */
@@ -443,14 +444,12 @@ class CodebaseComparator(
                 is MethodItem -> 2
                 is FieldItem -> 3
                 is ClassItem -> 4
-                is ParameterItem -> 5
-                is AnnotationItem -> 6
-                is PropertyItem -> 7
-                else -> 8
+                is PropertyItem -> 5
+                else -> error("Unexpected item $item of ${item.javaClass}")
             }
         }
 
-        val comparator: Comparator<Item> = Comparator { item1, item2 ->
+        val comparator: Comparator<SelectableItem> = Comparator { item1, item2 ->
             val typeSort = typeRank(item1) - typeRank(item2)
             when {
                 typeSort != 0 -> typeSort
@@ -538,18 +537,10 @@ class CodebaseComparator(
                         is FieldItem -> {
                             item1.name().compareTo((item2 as FieldItem).name())
                         }
-                        is ParameterItem -> {
-                            item1.parameterIndex.compareTo((item2 as ParameterItem).parameterIndex)
-                        }
-                        is AnnotationItem -> {
-                            item1.qualifiedName.compareTo((item2 as AnnotationItem).qualifiedName)
-                        }
                         is PropertyItem -> {
                             item1.name().compareTo((item2 as PropertyItem).name())
                         }
-                        else -> {
-                            error("Unexpected item type ${item1.javaClass}")
-                        }
+                        else -> error("Unexpected item $item1 of ${item1.javaClass}")
                     }
             }
         }
@@ -600,18 +591,18 @@ class CodebaseComparator(
 
     private fun createTree(
         codebase: MergedCodebase,
-        filter: Predicate<Item>? = null
+        filter: FilterPredicate? = null
     ): List<ItemTree> {
         return createTree(codebase.children, filter)
     }
 
-    private fun createTree(codebase: Codebase, filter: Predicate<Item>? = null): List<ItemTree> {
+    private fun createTree(codebase: Codebase, filter: FilterPredicate? = null): List<ItemTree> {
         return createTree(listOf(codebase), filter)
     }
 
     private fun createTree(
         codebases: List<Codebase>,
-        filter: Predicate<Item>? = null
+        filter: FilterPredicate? = null
     ): List<ItemTree> {
         val stack = Stack<ItemTree>()
         val root = ItemTree(null)
@@ -619,14 +610,17 @@ class CodebaseComparator(
 
         for (codebase in codebases) {
             val acceptAll = codebase.preFiltered || filter == null
-            val predicate = if (acceptAll) Predicate { true } else filter!!
+            val predicate = if (acceptAll) FilterPredicate { true } else filter!!
+            val apiFilters = ApiFilters(emit = predicate, reference = predicate)
             codebase.accept(
                 object :
                     ApiVisitor(
                         preserveClassNesting = true,
+                        // Do not visit [ParameterItem]s, as they will be compared in
+                        // [dispatchToCompare].
+                        visitParameterItems = false,
                         inlineInheritedFields = true,
-                        filterEmit = predicate,
-                        filterReference = predicate,
+                        apiFilters = apiFilters,
                         // Whenever a caller passes arguments of "--show-annotation 'SomeAnnotation'
                         // --check-compatibility:api:released $oldApi",
                         // really what they mean is:
@@ -641,9 +635,15 @@ class CodebaseComparator(
                         // So, when doing compatibility checking we want to consider public APIs
                         // even if the caller didn't explicitly pass --show-unannotated
                         showUnannotated = true,
-                        config = apiVisitorConfig,
                     ) {
-                    override fun visitItem(item: Item) {
+
+                    /**
+                     * Construct an [ItemTree] for [item] and push it onto the stack.
+                     *
+                     * This will not be called for [ParameterItem]s as it is not a [SelectableItem]
+                     * and they are compared when comparing callables in [dispatchToCompare].
+                     */
+                    override fun visitSelectableItem(item: SelectableItem) {
                         val node = ItemTree(item)
                         val parent = stack.peek()
                         parent.children += node
@@ -654,7 +654,14 @@ class CodebaseComparator(
                     override fun include(cls: ClassItem): Boolean =
                         if (acceptAll) true else super.include(cls)
 
-                    override fun afterVisitItem(item: Item) {
+                    /**
+                     * Pop the [ItemTree] for [item] constructed in [visitSelectableItem] off the
+                     * stack.
+                     *
+                     * This will not be called for [ParameterItem]s as it is not a [SelectableItem]
+                     * and they are compared when comparing callables in [dispatchToCompare].
+                     */
+                    override fun afterVisitSelectableItem(item: SelectableItem) {
                         stack.pop()
                     }
                 }
@@ -671,10 +678,10 @@ class CodebaseComparator(
         return root.children
     }
 
-    data class ItemTree(val item: Item?) : Comparable<ItemTree> {
+    data class ItemTree(val item: SelectableItem?) : Comparable<ItemTree> {
         val children: MutableList<ItemTree> = mutableListOf()
 
-        fun item(): Item =
+        fun item(): SelectableItem =
             item!! // Only the root note can be null, and this method should never be called on it
 
         override fun compareTo(other: ItemTree): Int {
diff --git a/metalava/src/main/java/com/android/tools/metalava/Constants.kt b/metalava/src/main/java/com/android/tools/metalava/Constants.kt
index b919a23b0..bec9dab46 100644
--- a/metalava/src/main/java/com/android/tools/metalava/Constants.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/Constants.kt
@@ -18,13 +18,6 @@ package com.android.tools.metalava
 
 const val ORG_JETBRAINS_ANNOTATIONS_PREFIX = "org.jetbrains.annotations."
 const val ORG_INTELLIJ_LANG_ANNOTATIONS_PREFIX = "org.intellij.lang.annotations."
-const val ANDROID_SYSTEM_API = "android.annotation.SystemApi"
-const val ANDROID_TEST_API = "android.annotation.TestApi"
-const val ANDROID_FLAGGED_API = "android.annotation.FlaggedApi"
-const val RECENTLY_NULLABLE = "androidx.annotation.RecentlyNullable"
-const val RECENTLY_NONNULL = "androidx.annotation.RecentlyNonNull"
-const val ANDROID_NULLABLE = "android.annotation.Nullable"
-const val ANDROID_NONNULL = "android.annotation.NonNull"
 const val ANDROID_SDK_CONSTANT = "android.annotation.SdkConstant"
 
 const val ENV_VAR_METALAVA_DUMP_ARGV = "METALAVA_DUMP_ARGV"
diff --git a/metalava/src/main/java/com/android/tools/metalava/ConvertJarsToSignatureFiles.kt b/metalava/src/main/java/com/android/tools/metalava/ConvertJarsToSignatureFiles.kt
index 3432dbb3e..a9031f11d 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ConvertJarsToSignatureFiles.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/ConvertJarsToSignatureFiles.kt
@@ -17,23 +17,26 @@
 package com.android.tools.metalava
 
 import com.android.SdkConstants
-import com.android.tools.metalava.cli.common.SignatureFileLoader
+import com.android.tools.metalava.cli.common.DefaultSignatureFileLoader
 import com.android.tools.metalava.model.ANDROIDX_NONNULL
 import com.android.tools.metalava.model.ANDROIDX_NULLABLE
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.FilterPredicate
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.SUPPORT_TYPE_USE_ANNOTATIONS
+import com.android.tools.metalava.model.annotation.DefaultAnnotationManager
 import com.android.tools.metalava.model.text.FileFormat
 import com.android.tools.metalava.model.text.SignatureFile
+import com.android.tools.metalava.model.visitors.ApiPredicate
+import com.android.tools.metalava.model.visitors.ApiType
 import com.android.tools.metalava.model.visitors.ApiVisitor
 import java.io.File
 import java.io.IOException
 import java.io.PrintWriter
-import java.util.function.Predicate
 import java.util.zip.ZipFile
 import org.objectweb.asm.ClassReader
 import org.objectweb.asm.Opcodes
@@ -73,7 +76,11 @@ class ConvertJarsToSignatureFiles(
             progressTracker.progress("Writing signature files $signatureFile for $apiJar")
 
             val annotationManager = DefaultAnnotationManager()
-            val signatureFileLoader = SignatureFileLoader(annotationManager = annotationManager)
+            val codebaseConfig =
+                Codebase.Config(
+                    annotationManager = annotationManager,
+                )
+            val signatureFileLoader = DefaultSignatureFileLoader(codebaseConfig)
 
             val jarCodebase = jarCodebaseLoader.loadFromJarFile(apiJar)
 
@@ -84,7 +91,7 @@ class ConvertJarsToSignatureFiles(
                 jarCodebase.accept(
                     object :
                         ApiVisitor(
-                            config = ApiVisitor.Config(),
+                            apiPredicateConfig = ApiPredicate.Config(),
                         ) {
                         override fun visitItem(item: Item) {
                             unmarkRecent(item)
@@ -121,17 +128,16 @@ class ConvertJarsToSignatureFiles(
             // javap. So as another fallback, read from the existing signature files:
             if (oldApiFile.isFile) {
                 try {
-                    val oldCodebase = signatureFileLoader.load(SignatureFile.fromFile(oldApiFile))
+                    val oldCodebase = signatureFileLoader.load(SignatureFile.fromFiles(oldApiFile))
                     val visitor =
                         object : ComparisonVisitor() {
-                            override fun compare(old: Item, new: Item) {
+                            override fun compareItems(old: Item, new: Item) {
                                 if (old.originallyDeprecated && old !is PackageItem) {
                                     new.deprecateIfRequired("previous signature file for $old")
                                 }
                             }
                         }
-                    CodebaseComparator(apiVisitorConfig = ApiVisitor.Config())
-                        .compare(visitor, oldCodebase, jarCodebase, null)
+                    CodebaseComparator().compare(visitor, oldCodebase, jarCodebase, null)
                 } catch (e: Exception) {
                     throw IllegalStateException("Could not load $oldApiFile: ${e.message}", e)
                 }
@@ -150,7 +156,7 @@ class ConvertJarsToSignatureFiles(
                     apiType = ApiType.PUBLIC_API,
                     preFiltered = jarCodebase.preFiltered,
                     showUnannotated = false,
-                    apiVisitorConfig = ApiVisitor.Config()
+                    apiPredicateConfig = ApiPredicate.Config()
                 )
             }
 
@@ -251,12 +257,12 @@ class ConvertJarsToSignatureFiles(
     }
 
     companion object {
-        val MATCH_ALL: Predicate<Item> = Predicate { true }
+        val MATCH_ALL: FilterPredicate = FilterPredicate { true }
     }
 }
 
 /** Finds the given class by JVM owner */
-private fun Codebase.findClassByOwner(owner: String, apiFilter: Predicate<Item>): ClassItem? {
+private fun Codebase.findClassByOwner(owner: String, apiFilter: FilterPredicate): ClassItem? {
     val className = owner.replace('/', '.').replace('$', '.')
     val cls = findClass(className)
     return if (cls != null && apiFilter.test(cls)) {
@@ -266,14 +272,14 @@ private fun Codebase.findClassByOwner(owner: String, apiFilter: Predicate<Item>)
     }
 }
 
-private fun Codebase.findClass(node: ClassNode, apiFilter: Predicate<Item>): ClassItem? {
+private fun Codebase.findClass(node: ClassNode, apiFilter: FilterPredicate): ClassItem? {
     return findClassByOwner(node.name, apiFilter)
 }
 
 private fun Codebase.findMethod(
     classNode: ClassNode,
     node: MethodNode,
-    apiFilter: Predicate<Item>
+    apiFilter: FilterPredicate
 ): MethodItem? {
     val cls = findClass(classNode, apiFilter) ?: return null
     val types = Type.getArgumentTypes(node.desc)
@@ -302,7 +308,7 @@ private fun Codebase.findMethod(
 private fun Codebase.findField(
     classNode: ClassNode,
     node: FieldNode,
-    apiFilter: Predicate<Item>
+    apiFilter: FilterPredicate
 ): FieldItem? {
     val cls = findClass(classNode, apiFilter) ?: return null
     val field = cls.findField(node.name + 2)
diff --git a/metalava/src/main/java/com/android/tools/metalava/Driver.kt b/metalava/src/main/java/com/android/tools/metalava/Driver.kt
index 15bf58aee..876cdc4f9 100644
--- a/metalava/src/main/java/com/android/tools/metalava/Driver.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/Driver.kt
@@ -21,11 +21,11 @@ import com.android.SdkConstants.DOT_JAR
 import com.android.SdkConstants.DOT_TXT
 import com.android.tools.metalava.apilevels.ApiGenerator
 import com.android.tools.metalava.cli.common.ActionContext
+import com.android.tools.metalava.cli.common.CheckerContext
 import com.android.tools.metalava.cli.common.EarlyOptions
 import com.android.tools.metalava.cli.common.ExecutionEnvironment
 import com.android.tools.metalava.cli.common.MetalavaCliException
 import com.android.tools.metalava.cli.common.MetalavaCommand
-import com.android.tools.metalava.cli.common.SignatureFileLoader
 import com.android.tools.metalava.cli.common.VersionCommand
 import com.android.tools.metalava.cli.common.commonOptions
 import com.android.tools.metalava.cli.compatibility.CompatibilityCheckOptions.CheckRequest
@@ -43,15 +43,23 @@ import com.android.tools.metalava.model.ClassResolver
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.CodebaseFragment
 import com.android.tools.metalava.model.DelegatedVisitor
+import com.android.tools.metalava.model.FilterPredicate
 import com.android.tools.metalava.model.ItemVisitor
 import com.android.tools.metalava.model.ModelOptions
+import com.android.tools.metalava.model.PackageFilter
 import com.android.tools.metalava.model.psi.PsiModelOptions
+import com.android.tools.metalava.model.snapshot.NonFilteringDelegatingVisitor
 import com.android.tools.metalava.model.source.EnvironmentManager
 import com.android.tools.metalava.model.source.SourceParser
 import com.android.tools.metalava.model.source.SourceSet
 import com.android.tools.metalava.model.text.ApiClassResolution
 import com.android.tools.metalava.model.text.SignatureFile
+import com.android.tools.metalava.model.visitors.ApiFilters
+import com.android.tools.metalava.model.visitors.ApiPredicate
+import com.android.tools.metalava.model.visitors.ApiType
+import com.android.tools.metalava.model.visitors.ApiVisitor
 import com.android.tools.metalava.model.visitors.FilteringApiVisitor
+import com.android.tools.metalava.model.visitors.MatchOverridingMethodPredicate
 import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.stub.StubConstructorManager
 import com.android.tools.metalava.stub.StubWriter
@@ -64,7 +72,6 @@ import java.io.PrintWriter
 import java.io.StringWriter
 import java.util.Arrays
 import java.util.concurrent.TimeUnit.SECONDS
-import java.util.function.Predicate
 import kotlin.system.exitProcess
 
 const val PROGRAM_NAME = "metalava"
@@ -131,7 +138,7 @@ internal fun processFlags(
 
     val reporter = options.reporter
 
-    val annotationManager = options.annotationManager
+    val codebaseConfig = options.codebaseConfig
     val modelOptions =
         // If the option was specified on the command line then use [ModelOptions] created from
         // that.
@@ -147,8 +154,7 @@ internal fun processFlags(
             ?: ModelOptions.empty
     val sourceParser =
         environmentManager.createSourceParser(
-            reporter = reporter,
-            annotationManager = annotationManager,
+            codebaseConfig = codebaseConfig,
             javaLanguageLevel = options.javaLanguageLevelAsString,
             kotlinLanguageLevel = options.kotlinLanguageLevelAsString,
             modelOptions = modelOptions,
@@ -185,8 +191,8 @@ internal fun processFlags(
                         "Inconsistent input file types: The first file is of $DOT_TXT, but detected different extension in ${it.path}"
                     )
                 }
-            val signatureFileLoader = SignatureFileLoader(annotationManager)
-            signatureFileLoader.loadFiles(
+            val signatureFileLoader = options.signatureFileLoader
+            signatureFileLoader.load(
                 SignatureFile.fromFiles(sources),
                 classResolverProvider.classResolver,
             )
@@ -198,6 +204,14 @@ internal fun processFlags(
             return
         }
 
+    // If provided by a test, run some additional checks on the internal state of this.
+    executionEnvironment.testEnvironment?.let { testEnvironment ->
+        testEnvironment.postAnalysisChecker?.let { function ->
+            val context = CheckerContext(options, codebase)
+            context.function()
+        }
+    }
+
     progressTracker.progress(
         "$PROGRAM_NAME analyzed API in ${stopwatch.elapsed(SECONDS)} seconds\n"
     )
@@ -207,37 +221,35 @@ internal fun processFlags(
         actionContext.subtractApi(signatureFileCache, codebase, it)
     }
 
-    val androidApiLevelXml = options.generateApiLevelXml
-    val apiLevelJars = options.apiLevelJars
-    val apiGenerator = ApiGenerator(signatureFileCache)
-    if (androidApiLevelXml != null && apiLevelJars != null) {
-        assert(options.currentApiLevel != -1)
-
+    val generateXmlConfig = options.apiLevelsGenerationOptions.generateXmlConfig
+    val apiGenerator = ApiGenerator()
+    if (generateXmlConfig != null) {
         progressTracker.progress(
-            "Generating API levels XML descriptor file, ${androidApiLevelXml.name}: "
+            "Generating API levels XML descriptor file, ${generateXmlConfig.outputFile.name}: "
         )
-        val sdkJarRoot = options.sdkJarRoot
-        val sdkInfoFile = options.sdkInfoFile
-        val sdkExtArgs: ApiGenerator.SdkExtensionsArguments? =
-            if (sdkJarRoot != null && sdkInfoFile != null) {
-                ApiGenerator.SdkExtensionsArguments(
-                    sdkJarRoot,
-                    sdkInfoFile,
-                    options.latestReleasedSdkExtension
+        var codebaseFragment =
+            CodebaseFragment.create(codebase) { delegatedVisitor ->
+                FilteringApiVisitor(
+                    delegate = delegatedVisitor,
+                    apiFilters = ApiVisitor.defaultFilters(options.apiPredicateConfig),
+                    preFiltered = false,
                 )
-            } else {
-                null
             }
-        apiGenerator.generateXml(
-            apiLevelJars,
-            options.firstApiLevel,
-            options.currentApiLevel,
-            options.isDeveloperPreviewBuild(),
-            androidApiLevelXml,
-            codebase,
-            sdkExtArgs,
-            options.removeMissingClassesInApiLevels
-        )
+
+        // If reverting some changes then create a snapshot that combines the items from the sources
+        // for any un-reverted changes and items from the previously released API for any reverted
+        // changes.
+        if (options.revertAnnotations.isNotEmpty()) {
+            codebaseFragment =
+                codebaseFragment.snapshotIncludingRevertedItems(
+                    // Allow references to any of the ClassItems in the original Codebase. This
+                    // should not be a problem for api-versions.xml files as they only refer to them
+                    // by name and do not care about their contents.
+                    referenceVisitorFactory = ::NonFilteringDelegatingVisitor,
+                )
+        }
+
+        apiGenerator.generateXml(codebaseFragment, generateXmlConfig)
     }
 
     if (options.docStubsDir != null || options.enhanceDocumentation) {
@@ -245,7 +257,15 @@ internal fun processFlags(
             error("Codebase does not support documentation, so it cannot be enhanced.")
         }
         progressTracker.progress("Enhancing docs: ")
-        val docAnalyzer = DocAnalyzer(executionEnvironment, codebase, reporter)
+        val docAnalyzer =
+            DocAnalyzer(
+                executionEnvironment,
+                codebase,
+                reporter,
+                options.apiLevelLabelProvider,
+                options.includeApiLevelInDocumentation,
+                options.apiPredicateConfig,
+            )
         docAnalyzer.enhance()
         val applyApiLevelsXml = options.applyApiLevelsXml
         if (applyApiLevelsXml != null) {
@@ -254,27 +274,34 @@ internal fun processFlags(
         }
     }
 
-    val apiVersionsJson = options.generateApiVersionsJson
-    val apiVersionNames = options.apiVersionNames
-    if (apiVersionsJson != null && apiVersionNames != null) {
-        progressTracker.progress(
-            "Generating API version history JSON file, ${apiVersionsJson.name}: "
+    options.apiLevelsGenerationOptions
+        .fromSignatureFilesConfig(
+            // Do not use a cache here as each file loaded is only loaded once and the created
+            // Codebase is discarded immediately after use so caching just uses memory for no
+            // performance benefit.
+            options.signatureFileLoader,
+            // Provide a CodebaseFragment from the sources that will be included in the generated
+            // version history.
+            codebaseFragmentProvider = {
+                val apiType = ApiType.PUBLIC_API
+                val apiFilters = apiType.getApiFilters(options.apiPredicateConfig)
+
+                CodebaseFragment.create(codebase) { delegatedVisitor ->
+                    FilteringApiVisitor(
+                        delegate = delegatedVisitor,
+                        apiFilters = apiFilters,
+                        preFiltered = false,
+                    )
+                }
+            }
         )
+        ?.let { config ->
+            progressTracker.progress(
+                "Generating API version history ${config.printer} file, ${config.outputFile.name}: "
+            )
 
-        val apiType = ApiType.PUBLIC_API
-        val apiEmit = apiType.getEmitFilter(options.apiPredicateConfig)
-        val apiReference = apiType.getReferenceFilter(options.apiPredicateConfig)
-
-        apiGenerator.generateJson(
-            // The signature files can be null if the current version is the only version
-            options.apiVersionSignatureFiles ?: emptyList(),
-            codebase,
-            apiVersionsJson,
-            apiVersionNames,
-            apiEmit,
-            apiReference
-        )
-    }
+            apiGenerator.generateFromVersionedApis(config)
+        }
 
     // Generate the documentation stubs *before* we migrate nullness information.
     options.docStubsDir?.let {
@@ -290,18 +317,31 @@ internal fun processFlags(
     // files
     options.apiFile?.let { apiFile ->
         val fileFormat = options.signatureFileFormat
-        val codebaseFragment =
-            CodebaseFragment(codebase) { delegate ->
+        var codebaseFragment =
+            CodebaseFragment.create(codebase) { delegate ->
                 createFilteringVisitorForSignatures(
                     delegate = delegate,
                     fileFormat = fileFormat,
                     apiType = ApiType.PUBLIC_API,
                     preFiltered = codebase.preFiltered,
                     showUnannotated = options.showUnannotated,
-                    apiVisitorConfig = options.apiVisitorConfig,
+                    apiPredicateConfig = options.apiPredicateConfig,
                 )
             }
 
+        // If reverting some changes then create a snapshot that combines the items from the sources
+        // for any un-reverted changes and items from the previously released API for any reverted
+        // changes.
+        if (options.revertAnnotations.isNotEmpty()) {
+            codebaseFragment =
+                codebaseFragment.snapshotIncludingRevertedItems(
+                    // Allow references to any of the ClassItems in the original Codebase. This
+                    // should not be a problem for signature files as they only refer to them by
+                    // name and do not care about their contents.
+                    referenceVisitorFactory = ::NonFilteringDelegatingVisitor,
+                )
+        }
+
         createReportFile(progressTracker, codebaseFragment, apiFile, "API") { printWriter ->
             SignatureWriter(
                 writer = printWriter,
@@ -312,18 +352,31 @@ internal fun processFlags(
 
     options.removedApiFile?.let { apiFile ->
         val fileFormat = options.signatureFileFormat
-        val codebaseFragment =
-            CodebaseFragment(codebase) { delegate ->
+        var codebaseFragment =
+            CodebaseFragment.create(codebase) { delegate ->
                 createFilteringVisitorForSignatures(
                     delegate = delegate,
                     fileFormat = fileFormat,
                     apiType = ApiType.REMOVED,
                     preFiltered = false,
                     showUnannotated = options.showUnannotated,
-                    apiVisitorConfig = options.apiVisitorConfig,
+                    apiPredicateConfig = options.apiPredicateConfig,
                 )
             }
 
+        // If reverting some changes then create a snapshot that combines the items from the sources
+        // for any un-reverted changes and items from the previously released API for any reverted
+        // changes.
+        if (options.revertAnnotations.isNotEmpty()) {
+            codebaseFragment =
+                codebaseFragment.snapshotIncludingRevertedItems(
+                    // Allow references to any of the ClassItems in the original Codebase. This
+                    // should not be a problem for signature files as they only refer to them by
+                    // name and do not care about their contents.
+                    referenceVisitorFactory = ::NonFilteringDelegatingVisitor,
+                )
+        }
+
         createReportFile(
             progressTracker,
             codebaseFragment,
@@ -340,18 +393,18 @@ internal fun processFlags(
     }
 
     options.proguard?.let { proguard ->
-        val apiPredicateConfigIgnoreShown = options.apiPredicateConfig.copy(ignoreShown = true)
+        val apiPredicateConfig = options.apiPredicateConfig
+        val apiPredicateConfigIgnoreShown = apiPredicateConfig.copy(ignoreShown = true)
         val apiReferenceIgnoreShown = ApiPredicate(config = apiPredicateConfigIgnoreShown)
-        val apiEmit = FilterPredicate(ApiPredicate())
+        val apiEmit = MatchOverridingMethodPredicate(ApiPredicate(config = apiPredicateConfig))
+        val apiFilters = ApiFilters(emit = apiEmit, reference = apiReferenceIgnoreShown)
         createReportFile(progressTracker, codebase, proguard, "Proguard file") { printWriter ->
             ProguardWriter(printWriter).let { proguardWriter ->
                 FilteringApiVisitor(
                     proguardWriter,
                     inlineInheritedFields = true,
-                    filterEmit = apiEmit,
-                    filterReference = apiReferenceIgnoreShown,
+                    apiFilters = apiFilters,
                     preFiltered = codebase.preFiltered,
-                    config = options.apiVisitorConfig,
                 )
             }
         }
@@ -369,10 +422,7 @@ internal fun processFlags(
     val previouslyReleasedApi = options.migrateNullsFrom
     if (previouslyReleasedApi != null) {
         val previous =
-            previouslyReleasedApi.load(
-                jarLoader = { jarFile -> actionContext.loadFromJarFile(jarFile) },
-                signatureFileLoader = { signatureFiles -> signatureFileCache.load(signatureFiles) }
-            )
+            previouslyReleasedApi.load { signatureFiles -> signatureFileCache.load(signatureFiles) }
 
         // If configured, checks for newly added nullness information compared
         // to the previous stable API and marks the newly annotated elements
@@ -417,7 +467,7 @@ private fun ActionContext.subtractApi(
     val oldCodebase =
         when {
             path.endsWith(DOT_TXT) ->
-                signatureFileCache.load(SignatureFile.fromFile(subtractApiFile))
+                signatureFileCache.load(SignatureFile.fromFiles(subtractApiFile))
             path.endsWith(DOT_JAR) -> loadFromJarFile(subtractApiFile)
             else ->
                 throw MetalavaCliException(
@@ -426,12 +476,10 @@ private fun ActionContext.subtractApi(
         }
 
     @Suppress("DEPRECATION")
-    CodebaseComparator(
-            apiVisitorConfig = @Suppress("DEPRECATION") options.apiVisitorConfig,
-        )
+    CodebaseComparator()
         .compare(
             object : ComparisonVisitor() {
-                override fun compare(old: ClassItem, new: ClassItem) {
+                override fun compareClassItems(old: ClassItem, new: ClassItem) {
                     new.emit = false
                 }
             },
@@ -477,12 +525,9 @@ private fun ActionContext.checkCompatibility(
     }
 
     val oldCodebase =
-        check.previouslyReleasedApi.load(
-            jarLoader = { jarFile -> loadFromJarFile(jarFile) },
-            signatureFileLoader = { signatureFiles ->
-                signatureFileCache.load(signatureFiles, classResolverProvider.classResolver)
-            }
-        )
+        check.previouslyReleasedApi.load { signatureFiles ->
+            signatureFileCache.load(signatureFiles, classResolverProvider.classResolver)
+        }
 
     // If configured, compares the new API with the previous API and reports
     // any incompatibilities.
@@ -586,6 +631,7 @@ private fun ActionContext.loadFromSources(
             commonSourceSet,
             "Codebase loaded from source folders",
             classPath = options.classpath,
+            apiPackages = options.apiPackages,
         )
 
     progressTracker.progress("Analyzing API: ")
@@ -627,19 +673,16 @@ private fun ActionContext.loadFromSources(
 
         // See if we should provide a previous codebase to provide a delta from?
         val previouslyReleasedApi =
-            apiLintOptions.previouslyReleasedApi?.load(
-                jarLoader = { jarFile -> loadFromJarFile(jarFile) },
-                signatureFileLoader = { signatureFiles ->
-                    signatureFileCache.load(signatureFiles, classResolverProvider.classResolver)
-                }
-            )
+            apiLintOptions.previouslyReleasedApi?.load { signatureFiles ->
+                signatureFileCache.load(signatureFiles, classResolverProvider.classResolver)
+            }
 
         ApiLint.check(
             codebase,
             previouslyReleasedApi,
             reporter,
             options.manifest,
-            options.apiVisitorConfig,
+            options.apiPredicateConfig,
         )
         progressTracker.progress(
             "$PROGRAM_NAME ran api-lint in ${localTimer.elapsed(SECONDS)} seconds"
@@ -722,20 +765,37 @@ private fun createStubFiles(
             }
         }
 
-    val codebaseFragment =
-        CodebaseFragment(codebase) { delegate ->
+    var codebaseFragment =
+        CodebaseFragment.create(codebase) { delegate ->
             createFilteringVisitorForStubs(
                 delegate = delegate,
                 docStubs = docStubs,
                 preFiltered = codebase.preFiltered,
-                apiVisitorConfig = options.apiVisitorConfig,
+                apiPredicateConfig = options.apiPredicateConfig,
             )
         }
 
+    // If reverting some changes then create a snapshot that combines the items from the sources for
+    // any un-reverted changes and items from the previously released API for any reverted changes.
+    if (options.revertAnnotations.isNotEmpty()) {
+        codebaseFragment =
+            codebaseFragment.snapshotIncludingRevertedItems(
+                referenceVisitorFactory = { delegate ->
+                    createFilteringVisitorForStubs(
+                        delegate = delegate,
+                        docStubs = docStubs,
+                        preFiltered = codebase.preFiltered,
+                        apiPredicateConfig = options.apiPredicateConfig,
+                        ignoreEmit = true,
+                    )
+                },
+            )
+    }
+
     // Add additional constructors needed by the stubs.
     val filterEmit =
         if (codebaseFragment.codebase.preFiltered) {
-            Predicate { true }
+            FilterPredicate { true }
         } else {
             val apiPredicateConfigIgnoreShown = options.apiPredicateConfig.copy(ignoreShown = true)
             ApiPredicate(ignoreRemoved = false, config = apiPredicateConfigIgnoreShown)
diff --git a/metalava/src/main/java/com/android/tools/metalava/ExtractAnnotations.kt b/metalava/src/main/java/com/android/tools/metalava/ExtractAnnotations.kt
index b2ce5ac25..470ce7dff 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ExtractAnnotations.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/ExtractAnnotations.kt
@@ -67,7 +67,7 @@ class ExtractAnnotations(
     private val outputFile: File,
 ) :
     ApiVisitor(
-        config = @Suppress("DEPRECATION") options.apiVisitorConfig,
+        apiPredicateConfig = @Suppress("DEPRECATION") options.apiPredicateConfig,
     ) {
     // Used linked hash map for order such that we always emit parameters after their surrounding
     // method etc
diff --git a/metalava/src/main/java/com/android/tools/metalava/JDiffXmlWriter.kt b/metalava/src/main/java/com/android/tools/metalava/JDiffXmlWriter.kt
index 9ad3d0886..91e0e0960 100644
--- a/metalava/src/main/java/com/android/tools/metalava/JDiffXmlWriter.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/JDiffXmlWriter.kt
@@ -31,11 +31,11 @@ import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.PropertyItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.psi.CodePrinter
+import com.android.tools.metalava.model.visitors.ApiFilters
 import com.android.tools.metalava.model.visitors.ApiVisitor
 import com.android.tools.metalava.model.visitors.FilteringApiVisitor
 import com.android.utils.XmlUtils
 import java.io.PrintWriter
-import java.util.function.Predicate
 
 /**
  * Writes out an XML format in the JDiff schema: See $ANDROID/external/jdiff/src/api.xsd (though
@@ -300,8 +300,7 @@ class JDiffXmlWriter(
      * [JDiffXmlWriter] instance.
      */
     fun createFilteringVisitor(
-        filterEmit: Predicate<Item>,
-        filterReference: Predicate<Item>,
+        apiFilters: ApiFilters,
         preFiltered: Boolean,
         showUnannotated: Boolean,
         filterSuperClassType: Boolean = true,
@@ -310,11 +309,9 @@ class JDiffXmlWriter(
             this,
             inlineInheritedFields = true,
             interfaceListComparator = TypeItem.totalComparator,
-            filterEmit = filterEmit,
-            filterReference = filterReference,
+            apiFilters = apiFilters,
             preFiltered = preFiltered,
             filterSuperClassType = filterSuperClassType,
             showUnannotated = showUnannotated,
-            config = ApiVisitor.Config(),
         )
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/JarCodebaseLoader.kt b/metalava/src/main/java/com/android/tools/metalava/JarCodebaseLoader.kt
index fb818a238..60f35131f 100644
--- a/metalava/src/main/java/com/android/tools/metalava/JarCodebaseLoader.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/JarCodebaseLoader.kt
@@ -18,9 +18,11 @@ package com.android.tools.metalava
 
 import com.android.tools.metalava.cli.common.ExecutionEnvironment
 import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.annotation.DefaultAnnotationManager
 import com.android.tools.metalava.model.source.EnvironmentManager
 import com.android.tools.metalava.model.source.SourceModelProvider
 import com.android.tools.metalava.model.source.SourceParser
+import com.android.tools.metalava.model.visitors.ApiPredicate
 import com.android.tools.metalava.reporter.Reporter
 import java.io.Closeable
 import java.io.File
@@ -119,11 +121,15 @@ private constructor(
                 )
 
             val annotationManager = DefaultAnnotationManager()
+            val codebaseConfig =
+                Codebase.Config(
+                    annotationManager = annotationManager,
+                    reporter = reporter,
+                )
 
             val sourceParser =
                 environmentManager.createSourceParser(
-                    reporter,
-                    annotationManager,
+                    codebaseConfig,
                 )
 
             val jarLoader =
diff --git a/metalava/src/main/java/com/android/tools/metalava/JarToJDiffCommand.kt b/metalava/src/main/java/com/android/tools/metalava/JarToJDiffCommand.kt
index 9a9d7ae1d..69468a620 100644
--- a/metalava/src/main/java/com/android/tools/metalava/JarToJDiffCommand.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/JarToJDiffCommand.kt
@@ -22,6 +22,8 @@ import com.android.tools.metalava.cli.common.existingFile
 import com.android.tools.metalava.cli.common.newFile
 import com.android.tools.metalava.cli.common.progressTracker
 import com.android.tools.metalava.cli.common.stderr
+import com.android.tools.metalava.model.visitors.ApiPredicate
+import com.android.tools.metalava.model.visitors.ApiType
 import com.android.tools.metalava.reporter.BasicReporter
 import com.github.ajalt.clikt.parameters.arguments.argument
 
@@ -76,16 +78,14 @@ class JarToJDiffCommand :
 
                 val apiType = ApiType.PUBLIC_API
                 val apiPredicateConfig = ApiPredicate.Config()
-                val apiEmit = apiType.getEmitFilter(apiPredicateConfig)
-                val apiReference = apiType.getReferenceFilter(apiPredicateConfig)
+                val apiFilters = apiType.getApiFilters(apiPredicateConfig)
 
                 createReportFile(progressTracker, codebase, xmlFile, "JDiff File") { printWriter ->
                     JDiffXmlWriter(
                             writer = printWriter,
                         )
                         .createFilteringVisitor(
-                            filterEmit = apiEmit,
-                            filterReference = apiReference,
+                            apiFilters = apiFilters,
                             preFiltered = false,
                             showUnannotated = false,
                         )
diff --git a/metalava/src/main/java/com/android/tools/metalava/KotlinInteropChecks.kt b/metalava/src/main/java/com/android/tools/metalava/KotlinInteropChecks.kt
index 022cb6f15..20fac6c74 100644
--- a/metalava/src/main/java/com/android/tools/metalava/KotlinInteropChecks.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/KotlinInteropChecks.kt
@@ -16,6 +16,7 @@
 
 package com.android.tools.metalava
 
+import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.MethodItem
@@ -54,6 +55,12 @@ class KotlinInteropChecks(val reporter: Reporter) {
         }
     }
 
+    fun checkClass(cls: ClassItem, isKotlin: Boolean = cls.isKotlin()) {
+        if (isKotlin) {
+            disallowValueClasses(cls)
+        }
+    }
+
     private fun ensureExceptionsDocumented(method: MethodItem) {
         if (!method.isKotlin()) {
             return
@@ -270,6 +277,16 @@ class KotlinInteropChecks(val reporter: Reporter) {
         return parameter.isSamCompatibleOrKotlinLambda()
     }
 
+    private fun disallowValueClasses(cls: ClassItem) {
+        if (cls.modifiers.isValue()) {
+            reporter.report(
+                Issues.VALUE_CLASS_DEFINITION,
+                cls,
+                "Value classes should not be public in APIs targeting Java clients."
+            )
+        }
+    }
+
     private fun isKotlinHardKeyword(keyword: String): Boolean {
         // From
         // https://github.com/JetBrains/kotlin/blob/master/core/descriptors/src/org/jetbrains/kotlin/renderer/KeywordStringsGenerated.java
diff --git a/metalava/src/main/java/com/android/tools/metalava/MainCommand.kt b/metalava/src/main/java/com/android/tools/metalava/MainCommand.kt
index ec39b95e7..ecbc728d6 100644
--- a/metalava/src/main/java/com/android/tools/metalava/MainCommand.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/MainCommand.kt
@@ -130,12 +130,20 @@ class MainCommand(
     /** Stub generation options. */
     private val stubGenerationOptions by StubGenerationOptions()
 
+    /** Api levels generation options. */
+    private val apiLevelsGenerationOptions by
+        ApiLevelsGenerationOptions(
+            executionEnvironment = executionEnvironment,
+            earlyOptions = commonOptions,
+        )
+
     /**
      * Add [Options] (an [OptionGroup]) so that any Clikt defined properties will be processed by
      * Clikt.
      */
     internal val optionGroup by
         Options(
+            executionEnvironment = executionEnvironment,
             commonOptions = commonOptions,
             sourceOptions = sourceOptions,
             issueReportingOptions = issueReportingOptions,
@@ -146,6 +154,7 @@ class MainCommand(
             signatureFileOptions = signatureFileOptions,
             signatureFormatOptions = signatureFormatOptions,
             stubGenerationOptions = stubGenerationOptions,
+            apiLevelsGenerationOptions = apiLevelsGenerationOptions,
         )
 
     override fun run() {
@@ -175,7 +184,7 @@ class MainCommand(
         val remainingArgs = flags.toTypedArray()
 
         // Parse any remaining arguments
-        optionGroup.parse(executionEnvironment, remainingArgs)
+        optionGroup.parse(remainingArgs)
 
         // Update the global options.
         @Suppress("DEPRECATION")
diff --git a/metalava/src/main/java/com/android/tools/metalava/MarkPackagesAsRecent.kt b/metalava/src/main/java/com/android/tools/metalava/MarkPackagesAsRecent.kt
index 423ee8ba5..466469e9f 100644
--- a/metalava/src/main/java/com/android/tools/metalava/MarkPackagesAsRecent.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/MarkPackagesAsRecent.kt
@@ -18,6 +18,9 @@ package com.android.tools.metalava
 
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.PackageFilter
+import com.android.tools.metalava.model.visitors.ApiFilters
+import com.android.tools.metalava.model.visitors.ApiPredicate
 import com.android.tools.metalava.model.visitors.ApiVisitor
 
 /**
@@ -28,9 +31,7 @@ import com.android.tools.metalava.model.visitors.ApiVisitor
  */
 class MarkPackagesAsRecent(val filter: PackageFilter) :
     ApiVisitor(
-        filterEmit = apiPredicate(),
-        filterReference = apiPredicate(),
-        config = @Suppress("DEPRECATION") options.apiVisitorConfig,
+        apiFilters = apiFilters(),
     ) {
     override fun include(cls: ClassItem): Boolean {
         return filter.matches(cls.containingPackage())
@@ -44,3 +45,5 @@ class MarkPackagesAsRecent(val filter: PackageFilter) :
 @Suppress("DEPRECATION")
 private fun apiPredicate() =
     ApiPredicate(config = options.apiPredicateConfig.copy(ignoreShown = true))
+
+private fun apiFilters() = apiPredicate().let { ApiFilters(emit = it, reference = it) }
diff --git a/metalava/src/main/java/com/android/tools/metalava/NullabilityAnnotationsValidator.kt b/metalava/src/main/java/com/android/tools/metalava/NullabilityAnnotationsValidator.kt
index c79760dc5..c02d952c7 100644
--- a/metalava/src/main/java/com/android/tools/metalava/NullabilityAnnotationsValidator.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/NullabilityAnnotationsValidator.kt
@@ -97,7 +97,7 @@ class NullabilityAnnotationsValidator(
             topLevelClass.accept(
                 object :
                     ApiVisitor(
-                        config = @Suppress("DEPRECATION") options.apiVisitorConfig,
+                        apiPredicateConfig = @Suppress("DEPRECATION") options.apiPredicateConfig,
                     ) {
 
                     override fun visitMethod(method: MethodItem) {
diff --git a/metalava/src/main/java/com/android/tools/metalava/NullnessMigration.kt b/metalava/src/main/java/com/android/tools/metalava/NullnessMigration.kt
index c76d18e9a..33f7402a2 100644
--- a/metalava/src/main/java/com/android/tools/metalava/NullnessMigration.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/NullnessMigration.kt
@@ -22,6 +22,8 @@ import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.ParameterItem
+import com.android.tools.metalava.model.RECENTLY_NONNULL
+import com.android.tools.metalava.model.RECENTLY_NULLABLE
 import com.android.tools.metalava.model.SUPPORT_TYPE_USE_ANNOTATIONS
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.findAnnotation
@@ -36,7 +38,7 @@ import com.android.tools.metalava.model.hasAnnotation
  *   {@code @NonNull List<@Nullable String>} to {@code @NonNull List<@NonNull String>} is forbidden.
  */
 class NullnessMigration : ComparisonVisitor() {
-    override fun compare(old: Item, new: Item) {
+    override fun compareItems(old: Item, new: Item) {
         if (hasNullnessInformation(new) && !hasNullnessInformation(old)) {
             new.markRecent()
         }
@@ -46,7 +48,7 @@ class NullnessMigration : ComparisonVisitor() {
     // having nullness annotations: those APIs are themselves new, so there's no reason
     // to mark the nullness contract as migration (warning- rather than error-severity)
 
-    override fun compare(old: CallableItem, new: CallableItem) {
+    override fun compareCallableItems(old: CallableItem, new: CallableItem) {
         @Suppress("ConstantConditionIf")
         if (SUPPORT_TYPE_USE_ANNOTATIONS) {
             val newType = new.returnType()
@@ -55,7 +57,7 @@ class NullnessMigration : ComparisonVisitor() {
         }
     }
 
-    override fun compare(old: FieldItem, new: FieldItem) {
+    override fun compareFieldItems(old: FieldItem, new: FieldItem) {
         @Suppress("ConstantConditionIf")
         if (SUPPORT_TYPE_USE_ANNOTATIONS) {
             val newType = new.type()
@@ -64,7 +66,7 @@ class NullnessMigration : ComparisonVisitor() {
         }
     }
 
-    override fun compare(old: ParameterItem, new: ParameterItem) {
+    override fun compareParameterItems(old: ParameterItem, new: ParameterItem) {
         @Suppress("ConstantConditionIf")
         if (SUPPORT_TYPE_USE_ANNOTATIONS) {
             val newType = new.type()
@@ -93,10 +95,7 @@ class NullnessMigration : ComparisonVisitor() {
 
     companion object {
         fun migrateNulls(codebase: Codebase, previous: Codebase) {
-            CodebaseComparator(
-                    apiVisitorConfig = @Suppress("DEPRECATION") options.apiVisitorConfig,
-                )
-                .compare(NullnessMigration(), previous, codebase)
+            CodebaseComparator().compare(NullnessMigration(), previous, codebase)
         }
 
         fun hasNullnessInformation(item: Item): Boolean {
diff --git a/metalava/src/main/java/com/android/tools/metalava/Options.kt b/metalava/src/main/java/com/android/tools/metalava/Options.kt
index df7b7a9f6..d6c7cdf2b 100644
--- a/metalava/src/main/java/com/android/tools/metalava/Options.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/Options.kt
@@ -20,6 +20,7 @@ import com.android.SdkConstants
 import com.android.SdkConstants.FN_FRAMEWORK_LIBRARY
 import com.android.tools.lint.detector.api.isJdkFolder
 import com.android.tools.metalava.cli.common.CommonOptions
+import com.android.tools.metalava.cli.common.DefaultSignatureFileLoader
 import com.android.tools.metalava.cli.common.ExecutionEnvironment
 import com.android.tools.metalava.cli.common.IssueReportingOptions
 import com.android.tools.metalava.cli.common.MetalavaCliException
@@ -36,25 +37,31 @@ import com.android.tools.metalava.cli.common.stringToExistingDir
 import com.android.tools.metalava.cli.common.stringToExistingFile
 import com.android.tools.metalava.cli.common.stringToNewDir
 import com.android.tools.metalava.cli.common.stringToNewFile
-import com.android.tools.metalava.cli.compatibility.ARG_CHECK_COMPATIBILITY_API_RELEASED
-import com.android.tools.metalava.cli.compatibility.ARG_CHECK_COMPATIBILITY_REMOVED_RELEASED
 import com.android.tools.metalava.cli.compatibility.CompatibilityCheckOptions
 import com.android.tools.metalava.cli.compatibility.CompatibilityCheckOptions.CheckRequest
 import com.android.tools.metalava.cli.lint.ApiLintOptions
 import com.android.tools.metalava.cli.signature.SignatureFormatOptions
 import com.android.tools.metalava.config.ConfigParser
+import com.android.tools.metalava.doc.ApiLevelFilter
+import com.android.tools.metalava.doc.ApiLevelLabelProvider
 import com.android.tools.metalava.manifest.Manifest
 import com.android.tools.metalava.manifest.emptyManifest
 import com.android.tools.metalava.model.AnnotationManager
+import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.PackageFilter
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.TypedefMode
+import com.android.tools.metalava.model.annotation.AnnotationFilterBuilder
+import com.android.tools.metalava.model.annotation.DefaultAnnotationManager
+import com.android.tools.metalava.model.api.surface.ApiSurfaces
 import com.android.tools.metalava.model.source.DEFAULT_JAVA_LANGUAGE_LEVEL
 import com.android.tools.metalava.model.source.DEFAULT_KOTLIN_LANGUAGE_LEVEL
 import com.android.tools.metalava.model.text.ApiClassResolution
-import com.android.tools.metalava.model.visitors.ApiVisitor
+import com.android.tools.metalava.model.visitors.ApiPredicate
 import com.android.tools.metalava.reporter.Baseline
 import com.android.tools.metalava.reporter.DefaultReporter
+import com.android.tools.metalava.reporter.IssueConfiguration
 import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.reporter.Reportable
 import com.android.tools.metalava.reporter.Reporter
@@ -69,9 +76,7 @@ import com.github.ajalt.clikt.parameters.options.option
 import com.github.ajalt.clikt.parameters.options.unique
 import com.github.ajalt.clikt.parameters.types.choice
 import com.github.ajalt.clikt.parameters.types.file
-import com.github.ajalt.clikt.parameters.types.int
 import java.io.File
-import java.io.IOException
 import java.io.PrintWriter
 import java.io.StringWriter
 import java.util.Optional
@@ -168,17 +173,6 @@ const val ARG_REVERT_ANNOTATION = "--revert-annotation"
 const val ARG_SUPPRESS_COMPATIBILITY_META_ANNOTATION = "--suppress-compatibility-meta-annotation"
 const val ARG_SHOW_UNANNOTATED = "--show-unannotated"
 const val ARG_APPLY_API_LEVELS = "--apply-api-levels"
-const val ARG_GENERATE_API_LEVELS = "--generate-api-levels"
-const val ARG_REMOVE_MISSING_CLASS_REFERENCES_IN_API_LEVELS =
-    "--remove-missing-class-references-in-api-levels"
-const val ARG_ANDROID_JAR_PATTERN = "--android-jar-pattern"
-const val ARG_CURRENT_VERSION = "--current-version"
-const val ARG_FIRST_VERSION = "--first-version"
-const val ARG_CURRENT_CODENAME = "--current-codename"
-const val ARG_CURRENT_JAR = "--current-jar"
-const val ARG_GENERATE_API_VERSION_HISTORY = "--generate-api-version-history"
-const val ARG_API_VERSION_SIGNATURE_FILES = "--api-version-signature-files"
-const val ARG_API_VERSION_NAMES = "--api-version-names"
 const val ARG_JAVA_SOURCE = "--java-source"
 const val ARG_KOTLIN_SOURCE = "--kotlin-source"
 const val ARG_SDK_HOME = "--sdk-home"
@@ -187,19 +181,17 @@ const val ARG_COMPILE_SDK_VERSION = "--compile-sdk-version"
 const val ARG_INCLUDE_SOURCE_RETENTION = "--include-source-retention"
 const val ARG_PASS_THROUGH_ANNOTATION = "--pass-through-annotation"
 const val ARG_EXCLUDE_ANNOTATION = "--exclude-annotation"
-const val ARG_STUB_PACKAGES = "--stub-packages"
 const val ARG_DELETE_EMPTY_REMOVED_SIGNATURES = "--delete-empty-removed-signatures"
 const val ARG_SUBTRACT_API = "--subtract-api"
 const val ARG_TYPEDEFS_IN_SIGNATURES = "--typedefs-in-signatures"
 const val ARG_IGNORE_CLASSES_ON_CLASSPATH = "--ignore-classes-on-classpath"
-const val ARG_SDK_JAR_ROOT = "--sdk-extensions-root"
-const val ARG_SDK_INFO_FILE = "--sdk-extensions-info"
 const val ARG_USE_K2_UAST = "--Xuse-k2-uast"
 const val ARG_PROJECT = "--project"
 const val ARG_SOURCE_MODEL_PROVIDER = "--source-model-provider"
 const val ARG_CONFIG_FILE = "--config-file"
 
 class Options(
+    private val executionEnvironment: ExecutionEnvironment = ExecutionEnvironment(),
     private val commonOptions: CommonOptions = CommonOptions(),
     private val sourceOptions: SourceOptions = SourceOptions(),
     private val issueReportingOptions: IssueReportingOptions =
@@ -211,10 +203,9 @@ class Options(
     signatureFileOptions: SignatureFileOptions = SignatureFileOptions(),
     signatureFormatOptions: SignatureFormatOptions = SignatureFormatOptions(),
     stubGenerationOptions: StubGenerationOptions = StubGenerationOptions(),
+    internal val apiLevelsGenerationOptions: ApiLevelsGenerationOptions =
+        ApiLevelsGenerationOptions(),
 ) : OptionGroup() {
-    /** Execution environment; initialized in [parse]. */
-    private lateinit var executionEnvironment: ExecutionEnvironment
-
     /** Writer to direct output to. */
     val stdout: PrintWriter
         get() = executionEnvironment.stdout
@@ -293,7 +284,7 @@ class Options(
      * (Copyright notices are not affected by this, they are always included. Documentation stubs
      * (--doc-stubs) are not affected.)
      */
-    var includeDocumentationInStubs = true
+    private var includeDocumentationInStubs = true
 
     /**
      * Enhance documentation in various ways, for example auto-generating documentation based on
@@ -323,7 +314,7 @@ class Options(
     /** Lint project description that describes project's module structure in details */
     var projectDescription: File? = null
 
-    val configFiles by
+    private val configFiles by
         option(
                 ARG_CONFIG_FILE,
                 help =
@@ -358,17 +349,51 @@ class Options(
      */
     var showUnannotated = false
 
-    /** Packages to include (if null, include all) */
-    private var stubPackages: PackageFilter? = null
+    val apiSurfaces by
+        lazy(LazyThreadSafetyMode.NONE) {
+            ApiSurfaces.create(
+                // A base API surface is needed if and only if the main API surface being generated
+                // extends another API surface. That is not currently explicitly specified on the
+                // command line so has to be inferred from the existing arguments. There are four
+                // main supported cases:
+                //
+                // * Public which does not extend another API surface so does not need a base. This
+                //   happens by default unless one or more `--show*annotation` options were
+                //   specified. In that case it behaves as if `--show-unannotated` was specified.
+                //
+                // * Restricted API in AndroidX which is basically public + other and does not need
+                //   a base. This happens when `--show-unannotated` was provided (the public part)
+                //   as well as `--show-annotation RestrictTo(...)` (the other part).
+                //
+                // * System delta on public in Android build. This happens when --show-unannotated
+                //   was not specified (so the public part is not included in signature files at
+                //   least) but `--show-annotation SystemApi` was.
+                //
+                // * Test API delta on system (or similar) in Android build. This happens when
+                //   `--show-unannotated` was not specified (so the public part is not included),
+                //   `--show-for-stub-purposes-only SystemApi` was (so system API is included in the
+                //   stubs but not the signature files) and `--show-annotation TestApi` was.
+                //
+                // There are other combinations of the `--show*` options which are not used, and it
+                // is not clear whether they make any sense so this does not cover them.
+                //
+                // This does not need a base if --show-unannotated was specified, or it defaulted to
+                // behaving as if it was.
+                needsBase = !showUnannotated,
+            )
+        }
+
+    /** Packages to include in the API (if null, include all) */
+    val apiPackages: PackageFilter? by sourceOptions::apiPackages
 
     /**
      * An optional [Reportable] predicate that will ignore issues from (i.e. return false for)
-     * [Item]s that do not match the [stubPackages] filter. If no [stubPackages] filter is provided
+     * [Item]s that do not match the [apiPackages] filter. If no [apiPackages] filter is provided
      * then this will be `null`.
      */
     private val reportableFilter: Predicate<Reportable>? by
         lazy(LazyThreadSafetyMode.NONE) {
-            stubPackages?.let { packageFilter ->
+            apiPackages?.let { packageFilter ->
                 Predicate { reportable ->
                     // If we are only emitting some packages (--stub-packages), don't report
                     // issues from other packages
@@ -386,12 +411,12 @@ class Options(
         get() = executionEnvironment.testEnvironment?.skipEmitPackages ?: emptyList()
 
     /** Annotations to hide */
-    val hideAnnotations by lazy(hideAnnotationsBuilder::build)
+    private val hideAnnotations by lazy(hideAnnotationsBuilder::build)
 
     /** Annotations to revert */
     val revertAnnotations by lazy(revertAnnotationsBuilder::build)
 
-    val annotationManager: AnnotationManager by lazy {
+    private val annotationManager: AnnotationManager by lazy {
         DefaultAnnotationManager(
             DefaultAnnotationManager.Config(
                 passThroughAnnotations = passThroughAnnotations,
@@ -405,14 +430,29 @@ class Options(
                 excludeAnnotations = excludeAnnotations,
                 typedefMode = typedefMode,
                 apiPredicate = ApiPredicate(config = apiPredicateConfig),
-                previouslyReleasedCodebasesProvider = {
-                    compatibilityCheckOptions.previouslyReleasedCodebases(signatureFileCache)
-                },
+                previouslyReleasedCodebaseProvider = { previouslyReleasedCodebase },
             )
         )
     }
 
-    internal val signatureFileCache by lazy { SignatureFileCache(annotationManager) }
+    /** Make this available for testing purposes. */
+    internal val previouslyReleasedCodebase
+        get() = compatibilityCheckOptions.previouslyReleasedCodebase(signatureFileCache)
+
+    internal val codebaseConfig by
+        lazy(LazyThreadSafetyMode.NONE) {
+            Codebase.Config(
+                annotationManager = annotationManager,
+                apiSurfaces = apiSurfaces,
+                reporter = reporter,
+            )
+        }
+
+    internal val signatureFileLoader by
+        lazy(LazyThreadSafetyMode.NONE) { DefaultSignatureFileLoader(codebaseConfig) }
+
+    internal val signatureFileCache by
+        lazy(LazyThreadSafetyMode.NONE) { SignatureFileCache(signatureFileLoader) }
 
     /** Meta-annotations for which annotated APIs should not be checked for compatibility. */
     private val suppressCompatibilityMetaAnnotations by
@@ -440,14 +480,6 @@ class Options(
      */
     private var allowClassesFromClasspath = true
 
-    /** The configuration options for the [ApiVisitor] class. */
-    val apiVisitorConfig by lazy {
-        ApiVisitor.Config(
-            packageFilter = stubPackages,
-            apiPredicateConfig = apiPredicateConfig,
-        )
-    }
-
     /** The configuration options for the [ApiAnalyzer] class. */
     val apiAnalyzerConfig by lazy {
         ApiAnalyzer.Config(
@@ -501,7 +533,7 @@ class Options(
     var docStubsDir: File? = null
 
     /** Whether code compiled from Kotlin should be emitted as .kt stubs instead of .java stubs */
-    var kotlinStubs = false
+    private var kotlinStubs = false
 
     /** Proguard Keep list file to write */
     var proguard: File? = null
@@ -510,9 +542,6 @@ class Options(
     val removedApiFile by signatureFileOptions::removedApiFile
     val signatureFileFormat by signatureFormatOptions::fileFormat
 
-    /** Like [apiFile], but with JDiff xml format. */
-    var apiXmlFile: File? = null
-
     /** Path to directory to write SDK values to */
     var sdkValueDir: File? = null
 
@@ -566,7 +595,7 @@ class Options(
                 PreviouslyReleasedApi.optionalPreviouslyReleasedApi(
                     ARG_MIGRATE_NULLNESS,
                     it,
-                    onlyUseLastForCurrentApiSurface = false
+                    onlyUseLastForMainApiSurface = false
                 )
             }
 
@@ -580,69 +609,14 @@ class Options(
     private var mergeQualifierAnnotations: List<File> = mutableMergeQualifierAnnotations
     private var mergeInclusionAnnotations: List<File> = mutableMergeInclusionAnnotations
 
-    /** mapping from API level to android.jar files, if computing API levels */
-    var apiLevelJars: Array<File>? = null
+    val apiLevelLabelProvider: ApiLevelLabelProvider = apiLevelsGenerationOptions::getApiLevelLabel
 
-    /** The api level of the codebase, or -1 if not known/specified */
-    var currentApiLevel = -1
-
-    /**
-     * The first api level of the codebase; typically 1 but can be higher for example for the System
-     * API.
-     */
-    var firstApiLevel = 1
-
-    /**
-     * The codename of the codebase: non-null string if this is a developer preview build, null if
-     * this is a release build.
-     */
-    var currentCodeName: String? = null
-
-    /** API level XML file to generate */
-    var generateApiLevelXml: File? = null
-
-    /** Whether references to missing classes should be removed from the api levels file. */
-    var removeMissingClassesInApiLevels: Boolean = false
+    val includeApiLevelInDocumentation: ApiLevelFilter =
+        apiLevelsGenerationOptions::includeApiLevelInDocumentation
 
     /** Reads API XML file to apply into documentation */
     var applyApiLevelsXml: File? = null
 
-    /** Directory of prebuilt extension SDK jars that contribute to the API */
-    var sdkJarRoot: File? = null
-
-    /**
-     * Rules to filter out some extension SDK APIs from the API, and assign extensions to the APIs
-     * that are kept
-     */
-    var sdkInfoFile: File? = null
-
-    /**
-     * The latest publicly released SDK extension version. When generating docs for d.android.com,
-     * the SDK extensions that have been finalized but not yet publicly released should be excluded
-     * from the docs.
-     *
-     * If null, the docs will include all SDK extensions.
-     */
-    val latestReleasedSdkExtension by
-        option(
-                "--hide-sdk-extensions-newer-than",
-                help =
-                    "Ignore SDK extensions version INT and above. Used to exclude finalized but not yet released SDK extensions."
-            )
-            .int()
-
-    /** API version history JSON file to generate */
-    var generateApiVersionsJson: File? = null
-
-    /** Ordered list of signatures for each past API version, if generating an API version JSON */
-    var apiVersionSignatureFiles: List<File>? = null
-
-    /**
-     * The names of the API versions in [apiVersionSignatureFiles], in the same order, and the name
-     * of the current API version
-     */
-    var apiVersionNames: List<String>? = null
-
     /** Whether to include the signature file format version header in removed signature files */
     val includeSignatureFormatVersionRemoved: EmitFileHeader
         get() =
@@ -661,14 +635,6 @@ class Options(
     lateinit var reporter: Reporter
         private set
 
-    /**
-     * [Reporter] for "check-compatibility:*:released". (i.e. [ARG_CHECK_COMPATIBILITY_API_RELEASED]
-     * and [ARG_CHECK_COMPATIBILITY_REMOVED_RELEASED]).
-     *
-     * Initialized in [parse].
-     */
-    private lateinit var reporterCompatibilityReleased: Reporter
-
     internal var allReporters: List<DefaultReporter> = emptyList()
 
     /** If generating a removed signature file, and it is empty, delete it */
@@ -729,15 +695,7 @@ class Options(
                     .trimIndent()
             )
 
-    fun parse(
-        executionEnvironment: ExecutionEnvironment,
-        args: Array<String>,
-    ) {
-        this.executionEnvironment = executionEnvironment
-
-        var androidJarPatterns: MutableList<String>? = null
-        var currentJar: File? = null
-
+    fun parse(args: Array<String>) {
         var index = 0
         while (index < args.size) {
             when (val arg = args[index]) {
@@ -802,17 +760,6 @@ class Options(
                     annotations.split(",").forEach { path -> mutableExcludeAnnotations.add(path) }
                 }
                 ARG_PROGUARD -> proguard = stringToNewFile(getValue(args, ++index))
-                ARG_STUB_PACKAGES -> {
-                    val packages = getValue(args, ++index)
-                    val filter =
-                        stubPackages
-                            ?: run {
-                                val newFilter = PackageFilter()
-                                stubPackages = newFilter
-                                newFilter
-                            }
-                    filter.addPackages(packages)
-                }
                 ARG_IGNORE_CLASSES_ON_CLASSPATH -> {
                     allowClassesFromClasspath = false
                 }
@@ -821,42 +768,9 @@ class Options(
                     externalAnnotations = stringToNewFile(getValue(args, ++index))
 
                 // Extracting API levels
-                ARG_ANDROID_JAR_PATTERN -> {
-                    val list =
-                        androidJarPatterns
-                            ?: run {
-                                val list = arrayListOf<String>()
-                                androidJarPatterns = list
-                                list
-                            }
-                    list.add(getValue(args, ++index))
-                }
-                ARG_CURRENT_VERSION -> {
-                    currentApiLevel = Integer.parseInt(getValue(args, ++index))
-                    if (currentApiLevel <= 26) {
-                        throw MetalavaCliException(
-                            "Suspicious currentApi=$currentApiLevel, expected at least 27"
-                        )
-                    }
-                }
-                ARG_FIRST_VERSION -> {
-                    firstApiLevel = Integer.parseInt(getValue(args, ++index))
-                }
-                ARG_CURRENT_CODENAME -> {
-                    val codeName = getValue(args, ++index)
-                    if (codeName != "REL") {
-                        currentCodeName = codeName
-                    }
-                }
-                ARG_CURRENT_JAR -> {
-                    currentJar = stringToExistingFile(getValue(args, ++index))
-                }
-                ARG_GENERATE_API_LEVELS -> {
-                    generateApiLevelXml = stringToNewFile(getValue(args, ++index))
-                }
                 ARG_APPLY_API_LEVELS -> {
                     applyApiLevelsXml =
-                        if (args.contains(ARG_GENERATE_API_LEVELS)) {
+                        if (apiLevelsGenerationOptions.generateApiLevelXml != null) {
                             // If generating the API file at the same time, it doesn't have
                             // to already exist
                             stringToNewFile(getValue(args, ++index))
@@ -864,17 +778,6 @@ class Options(
                             stringToExistingFile(getValue(args, ++index))
                         }
                 }
-                ARG_REMOVE_MISSING_CLASS_REFERENCES_IN_API_LEVELS ->
-                    removeMissingClassesInApiLevels = true
-                ARG_GENERATE_API_VERSION_HISTORY -> {
-                    generateApiVersionsJson = stringToNewFile(getValue(args, ++index))
-                }
-                ARG_API_VERSION_SIGNATURE_FILES -> {
-                    apiVersionSignatureFiles = stringToExistingFiles(getValue(args, ++index))
-                }
-                ARG_API_VERSION_NAMES -> {
-                    apiVersionNames = getValue(args, ++index).split(' ')
-                }
                 ARG_JAVA_SOURCE -> {
                     val value = getValue(args, ++index)
                     javaLanguageLevelAsString = value
@@ -896,12 +799,6 @@ class Options(
                 ARG_PROJECT -> {
                     projectDescription = stringToExistingFile(getValue(args, ++index))
                 }
-                ARG_SDK_JAR_ROOT -> {
-                    sdkJarRoot = stringToExistingDir(getValue(args, ++index))
-                }
-                ARG_SDK_INFO_FILE -> {
-                    sdkInfoFile = stringToExistingFile(getValue(args, ++index))
-                }
                 "--temp-folder" -> {
                     tempFolder = stringToNewOrExistingDir(getValue(args, ++index))
                 }
@@ -927,46 +824,6 @@ class Options(
             ++index
         }
 
-        if (generateApiLevelXml != null) {
-            if (currentApiLevel == -1) {
-                throw MetalavaCliException(
-                    stderr = "$ARG_GENERATE_API_LEVELS requires $ARG_CURRENT_VERSION"
-                )
-            }
-
-            // <String> is redundant here but while IDE (with newer type inference engine
-            // understands that) the current 1.3.x compiler does not
-            @Suppress("RemoveExplicitTypeArguments")
-            val patterns = androidJarPatterns ?: run { mutableListOf<String>() }
-            // Fallbacks
-            patterns.add("prebuilts/tools/common/api-versions/android-%/android.jar")
-            patterns.add("prebuilts/sdk/%/public/android.jar")
-            apiLevelJars =
-                findAndroidJars(
-                    args,
-                    patterns,
-                    firstApiLevel,
-                    currentApiLevel + if (isDeveloperPreviewBuild()) 1 else 0,
-                    currentJar
-                )
-        }
-
-        if ((sdkJarRoot == null) != (sdkInfoFile == null)) {
-            throw MetalavaCliException(
-                stderr = "$ARG_SDK_JAR_ROOT and $ARG_SDK_INFO_FILE must both be supplied"
-            )
-        }
-
-        // apiVersionNames will include the current version but apiVersionSignatureFiles will not,
-        // so there should be 1 more name than signature file (or both can be null)
-        val numVersionNames = apiVersionNames?.size ?: 0
-        val numVersionFiles = apiVersionSignatureFiles?.size ?: 0
-        if (numVersionNames != 0 && numVersionNames != numVersionFiles + 1) {
-            throw MetalavaCliException(
-                "$ARG_API_VERSION_NAMES must have one more version than $ARG_API_VERSION_SIGNATURE_FILES to include the current version name"
-            )
-        }
-
         // If the caller has not explicitly requested that unannotated classes and
         // members should be shown in the output then only show them if no annotations were
         // provided.
@@ -1049,8 +906,6 @@ class Options(
             config = issueReportingOptions.reporterConfig,
         )
 
-    fun isDeveloperPreviewBuild(): Boolean = currentCodeName != null
-
     /** Update the classpath to insert android.jar or JDK classpath elements if necessary */
     private fun updateClassPath() {
         val sdkHome = sdkHome
@@ -1083,80 +938,6 @@ class Options(
         }
     }
 
-    /**
-     * Find an android stub jar that matches the given criteria.
-     *
-     * Note because the default baseline file is not explicitly set in the command line, this file
-     * would trigger a --strict-input-files violation. To avoid that, use
-     * --strict-input-files-exempt to exempt the jar directory.
-     */
-    private fun findAndroidJars(
-        args: Array<String>,
-        androidJarPatterns: List<String>,
-        minApi: Int,
-        currentApiLevel: Int,
-        currentJar: File?
-    ): Array<File> {
-        val apiLevelFiles = mutableListOf<File>()
-        // api level 0: placeholder, should not be processed.
-        // (This is here because we want the array index to match
-        // the API level)
-        val element = File("not an api: the starting API index is $minApi")
-        for (i in 0 until minApi) {
-            apiLevelFiles.add(element)
-        }
-
-        // Get all the android.jar. They are in platforms-#
-        for (apiLevel in minApi.rangeTo(currentApiLevel)) {
-            try {
-                var jar: File? = null
-                if (apiLevel == currentApiLevel) {
-                    jar = currentJar
-                }
-                if (jar == null) {
-                    jar = getAndroidJarFile(apiLevel, androidJarPatterns)
-                }
-                if (jar == null || !jar.isFile) {
-                    if (verbose) {
-                        stdout.println("Last API level found: ${apiLevel - 1}")
-                    }
-
-                    if (apiLevel < 28) {
-                        // Clearly something is wrong with the patterns; this should result in a
-                        // build error
-                        val argList = mutableListOf<String>()
-                        args.forEachIndexed { index, arg ->
-                            if (arg == ARG_ANDROID_JAR_PATTERN) {
-                                argList.add(args[index + 1])
-                            }
-                        }
-                        throw MetalavaCliException(
-                            stderr =
-                                "Could not find android.jar for API level $apiLevel; the " +
-                                    "$ARG_ANDROID_JAR_PATTERN set might be invalid: ${argList.joinToString()}"
-                        )
-                    }
-
-                    break
-                }
-                if (verbose) {
-                    stdout.println("Found API $apiLevel at ${jar.path}")
-                }
-                apiLevelFiles.add(jar)
-            } catch (e: IOException) {
-                e.printStackTrace()
-            }
-        }
-
-        return apiLevelFiles.toTypedArray()
-    }
-
-    private fun getAndroidJarFile(apiLevel: Int, patterns: List<String>): File? {
-        return patterns
-            .map { fileForPathInner(it.replace("%", apiLevel.toString())) }
-            .firstOrNull { it.isFile }
-    }
-
     private fun getValue(args: Array<String>, index: Int): String {
         if (index >= args.size) {
             throw MetalavaCliException("Missing argument for ${args[index - 1]}")
@@ -1281,12 +1062,6 @@ object OptionsHelp {
                 "Use the given API level",
                 "$ARG_JDK_HOME <dir>",
                 "If set, add the Java APIs from the given JDK to the classpath",
-                "$ARG_STUB_PACKAGES <package-list>",
-                "List of packages (separated by ${File.pathSeparator}) which will " +
-                    "be used to filter out irrelevant code. If specified, only code in these packages will be " +
-                    "included in signature files, stubs, etc. (This is not limited to just the stubs; the name " +
-                    "is historical.) You can also use \".*\" at the end to match subpackages, so `foo.*` will " +
-                    "match both `foo` and `foo.bar`.",
                 "$ARG_SUBTRACT_API <api file>",
                 "Subtracts the API in the given signature or jar file from the " +
                     "current API being emitted via $ARG_API, $ARG_STUBS, $ARG_DOC_STUBS, etc. " +
@@ -1343,64 +1118,6 @@ object OptionsHelp {
                 "Reads an XML file containing API level descriptions " +
                     "and merges the information into the documentation",
                 "",
-                "Extracting API Levels:",
-                "$ARG_GENERATE_API_LEVELS <xmlfile>",
-                "Reads android.jar SDK files and generates an XML file recording " +
-                    "the API level for each class, method and field",
-                ARG_REMOVE_MISSING_CLASS_REFERENCES_IN_API_LEVELS,
-                "Removes references to missing classes when generating the API levels XML file. " +
-                    "This can happen when generating the XML file for the non-updatable portions of " +
-                    "the module-lib sdk, as those non-updatable portions can reference classes that are " +
-                    "part of an updatable apex.",
-                "$ARG_ANDROID_JAR_PATTERN <pattern>",
-                "Patterns to use to locate Android JAR files. The default " +
-                    "is \$ANDROID_HOME/platforms/android-%/android.jar.",
-                ARG_FIRST_VERSION,
-                "Sets the first API level to generate an API database from; usually 1",
-                ARG_CURRENT_VERSION,
-                "Sets the current API level of the current source code",
-                ARG_CURRENT_CODENAME,
-                "Sets the code name for the current source code",
-                ARG_CURRENT_JAR,
-                "Points to the current API jar, if any",
-                ARG_SDK_JAR_ROOT,
-                "Points to root of prebuilt extension SDK jars, if any. This directory is expected to " +
-                    "contain snapshots of historical extension SDK versions in the form of stub jars. " +
-                    "The paths should be on the format \"<int>/public/<module-name>.jar\", where <int> " +
-                    "corresponds to the extension SDK version, and <module-name> to the name of the mainline module.",
-                ARG_SDK_INFO_FILE,
-                "Points to map of extension SDK APIs to include, if any. The file is a plain text file " +
-                    "and describes, per extension SDK, what APIs from that extension to include in the " +
-                    "file created via $ARG_GENERATE_API_LEVELS. The format of each line is one of the following: " +
-                    "\"<module-name> <pattern> <ext-name> [<ext-name> [...]]\", where <module-name> is the " +
-                    "name of the mainline module this line refers to, <pattern> is a common Java name prefix " +
-                    "of the APIs this line refers to, and <ext-name> is a list of extension SDK names " +
-                    "in which these SDKs first appeared, or \"<ext-name> <ext-id> <type>\", where " +
-                    "<ext-name> is the name of an SDK, " +
-                    "<ext-id> its numerical ID and <type> is one of " +
-                    "\"platform\" (the Android platform SDK), " +
-                    "\"platform-ext\" (an extension to the Android platform SDK), " +
-                    "\"standalone\" (a separate SDK). " +
-                    "Fields are separated by whitespace. " +
-                    "A mainline module may be listed multiple times. " +
-                    "The special pattern \"*\" refers to all APIs in the given mainline module. " +
-                    "Lines beginning with # are comments.",
-                "",
-                "Generating API version history:",
-                "$ARG_GENERATE_API_VERSION_HISTORY <jsonfile>",
-                "Reads API signature files and generates a JSON file recording the API version each " +
-                    "class, method, and field was added in and (if applicable) deprecated in. " +
-                    "Required to generate API version JSON.",
-                "$ARG_API_VERSION_SIGNATURE_FILES <files>",
-                "An ordered list of text API signature files. The oldest API version should be " +
-                    "first, the newest last. This should not include a signature file for the " +
-                    "current API version, which will be parsed from the provided source files. Not " +
-                    "required to generate API version JSON if the current version is the only version.",
-                "$ARG_API_VERSION_NAMES <strings>",
-                "An ordered list of strings with the names to use for the API versions from " +
-                    "$ARG_API_VERSION_SIGNATURE_FILES, and the name of the current API version. " +
-                    "Required to generate API version JSON.",
-                "",
                 "Environment Variables:",
                 ENV_VAR_METALAVA_DUMP_ARGV,
                 "Set to true to have metalava emit all the arguments it was invoked with. " +
diff --git a/metalava/src/main/java/com/android/tools/metalava/ProguardWriter.kt b/metalava/src/main/java/com/android/tools/metalava/ProguardWriter.kt
index 6dc259930..ec3d31a7e 100644
--- a/metalava/src/main/java/com/android/tools/metalava/ProguardWriter.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/ProguardWriter.kt
@@ -16,7 +16,6 @@
 
 package com.android.tools.metalava
 
-import com.android.tools.metalava.model.ArrayTypeItem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ConstructorItem
 import com.android.tools.metalava.model.DelegatedVisitor
@@ -24,6 +23,7 @@ import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.TypeItem
+import com.android.tools.metalava.model.TypeStringConfiguration
 import com.android.tools.metalava.model.VisibilityLevel
 import java.io.PrintWriter
 
@@ -33,7 +33,7 @@ class ProguardWriter(
 
     override fun visitClass(cls: ClassItem) {
         writer.print("-keep class ")
-        writer.print(cls.qualifiedNameWithDollarNestedClasses())
+        writer.print(getCleanTypeName(cls.type()))
         writer.print(" {\n")
     }
 
@@ -117,9 +117,15 @@ class ProguardWriter(
     }
 
     private fun getCleanTypeName(t: TypeItem?): String {
-        t ?: return ""
-        if (t is ArrayTypeItem) return getCleanTypeName(t.componentType) + "[]"
-        val cls = t.asClass() ?: return t.toCanonicalType()
-        return cls.qualifiedNameWithDollarNestedClasses()
+        return t?.toTypeString(PROGUARD_TYPE_STRING_CONFIGURATION) ?: ""
+    }
+
+    companion object {
+        private val PROGUARD_TYPE_STRING_CONFIGURATION =
+            TypeStringConfiguration(
+                eraseGenerics = true,
+                nestedClassSeparator = '$',
+                treatVarargsAsArray = true,
+            )
     }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/SdkExtension.kt b/metalava/src/main/java/com/android/tools/metalava/SdkExtension.kt
new file mode 100644
index 000000000..591a82489
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/SdkExtension.kt
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tools.metalava
+
+import com.android.tools.metalava.apilevels.ApiVersion
+
+/**
+ * ID and aliases for a given SDK extension.
+ *
+ * An SDK extension has an [id] corresponding to an Android dessert release that it extends, e.g.
+ * the T extension has an [id] of 33.
+ *
+ * @param id: numerical ID of the extension SDK, primarily used in generated artifacts and consumed
+ *   by tools
+ * @param shortname: short name for the SDK, primarily used in configuration files
+ * @param name: human-readable name for the SDK; used in the official documentation
+ * @param reference: Java symbol in the Android SDK with the same numerical value as the id, using a
+ *   JVM signature like syntax: "some/clazz$INNER$FIELD"
+ */
+sealed class SdkExtension
+private constructor(
+    val id: Int,
+    val shortname: String,
+    val name: String,
+    val reference: String,
+) {
+    /**
+     * Check to see whether this SDK extension supersedes the Android SDK version
+     * [androidSdkVersion].
+     *
+     * A dessert based extension supersedes an Android SDK version if it is based on that version or
+     * earlier.
+     *
+     * A dessert independent extension will always supersede an Android SDK version.
+     *
+     * @param androidSdkVersion the version of the Android SDK in which an API element was added.
+     */
+    abstract fun supersedesAndroidSdkVersion(androidSdkVersion: ApiVersion): Boolean
+
+    init {
+        require(id >= 1) { "SDK extensions cannot have an id less than 1 but it is $id" }
+    }
+
+    companion object {
+        /**
+         * Create an [SdkExtension] from the attributes that appear in sdk-extension-info.xml and
+         * api-versions.xml files.
+         *
+         * If [id] is greater than or equal to [DESSERT_RELEASE_INDEPENDENT_SDK_BASE] then the
+         * [SdkExtension] is independent of the Android SDK version, otherwise [id] is the base SDK
+         * version of the extension.
+         */
+        fun fromXmlAttributes(id: Int, shortname: String, name: String, reference: String) =
+            if (id >= DESSERT_RELEASE_INDEPENDENT_SDK_BASE)
+                DessertReleaseIndependentSdkExtension(id, shortname, name, reference)
+            else DessertReleaseBasedSdkExtension(id, shortname, name, reference)
+
+        /**
+         * The base of dessert release independent SDKs.
+         *
+         * A dessert release independent SDK is one which is not coupled to the Android dessert
+         * release numbering. Any SDK greater than or equal to this is not comparable to either each
+         * other, or to the Android dessert release. e.g. `1000000` is not the same as, later than,
+         * or earlier than SDK 31. Similarly, `1000001` is not the same as, later than, or earlier
+         * then `1000000`.
+         */
+        private const val DESSERT_RELEASE_INDEPENDENT_SDK_BASE = 1000000
+    }
+
+    /**
+     * An [SdkExtension] that is based on a specific version of the Android Sdk.
+     *
+     * The [id] is the major version of the Android SDK on which this is based.
+     */
+    private class DessertReleaseBasedSdkExtension(
+        id: Int,
+        shortname: String,
+        name: String,
+        reference: String,
+    ) : SdkExtension(id, shortname, name, reference) {
+
+        /**
+         * The base [ApiVersion] of this extension. This the version of the Android SDK to which
+         * this extension applies.
+         */
+        private val baseSdkVersion = ApiVersion.fromLevel(id)
+
+        override fun supersedesAndroidSdkVersion(androidSdkVersion: ApiVersion) =
+            baseSdkVersion <= androidSdkVersion
+    }
+
+    /** An [SdkExtension] that is independent of an Android SDK version. */
+    private class DessertReleaseIndependentSdkExtension(
+        id: Int,
+        shortname: String,
+        name: String,
+        reference: String,
+    ) : SdkExtension(id, shortname, name, reference) {
+        override fun supersedesAndroidSdkVersion(androidSdkVersion: ApiVersion) = true
+    }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/SdkFileWriter.kt b/metalava/src/main/java/com/android/tools/metalava/SdkFileWriter.kt
index ceb2e2158..005e64bda 100644
--- a/metalava/src/main/java/com/android/tools/metalava/SdkFileWriter.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/SdkFileWriter.kt
@@ -264,7 +264,6 @@ class SdkFileWriter(val codebase: Codebase, private val outputDir: File) {
      * @param prefix the prefix to put at the beginning of the line.
      * @throws IOException
      */
-    @Throws(IOException::class)
     private fun writeClass(writer: BufferedWriter, clazz: ClassItem, prefix: Char) {
         writer.append(prefix).append(clazz.qualifiedName())
         for (superClass in clazz.allSuperClasses()) {
diff --git a/metalava/src/main/java/com/android/tools/metalava/SdkIdentifier.kt b/metalava/src/main/java/com/android/tools/metalava/SdkIdentifier.kt
deleted file mode 100644
index ae9a85747..000000000
--- a/metalava/src/main/java/com/android/tools/metalava/SdkIdentifier.kt
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.android.tools.metalava
-
-/**
- * ID and aliases for a given SDK.
- *
- * SDKs include the Android SDK and SDK extensions (e.g. the T extensions).
- *
- * @param id: numerical ID of the SDK, primarily used in generated artifacts and consumed by tools
- * @param shortname: short name for the SDK, primarily used in configuration files
- * @param name: human readable name for the SDK; used in the official documentation
- * @param reference: Java symbol in the Android SDK with the same numerical value as the id, using a
- *   JVM signature like syntax: "some/clazz$INNER$FIELD"
- */
-data class SdkIdentifier(
-    val id: Int,
-    val shortname: String,
-    val name: String,
-    val reference: String
-)
diff --git a/metalava/src/main/java/com/android/tools/metalava/SignatureFileCache.kt b/metalava/src/main/java/com/android/tools/metalava/SignatureFileCache.kt
index 9c776ae4f..214c8d015 100644
--- a/metalava/src/main/java/com/android/tools/metalava/SignatureFileCache.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/SignatureFileCache.kt
@@ -17,7 +17,6 @@
 package com.android.tools.metalava
 
 import com.android.tools.metalava.cli.common.SignatureFileLoader
-import com.android.tools.metalava.model.AnnotationManager
 import com.android.tools.metalava.model.ClassResolver
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.text.SignatureFile
@@ -28,17 +27,17 @@ private data class CacheKey(
 )
 
 /** Loads signature files, caching them for reuse where appropriate. */
-class SignatureFileCache(annotationManager: AnnotationManager) {
-    private val signatureFileLoader = SignatureFileLoader(annotationManager)
+class SignatureFileCache(private val signatureFileLoader: SignatureFileLoader) :
+    SignatureFileLoader {
     private val map = mutableMapOf<CacheKey, Codebase>()
 
-    fun load(signatureFile: SignatureFile, classResolver: ClassResolver? = null): Codebase =
-        load(listOf(signatureFile), classResolver)
-
-    fun load(signatureFiles: List<SignatureFile>, classResolver: ClassResolver? = null): Codebase {
+    override fun load(
+        signatureFiles: List<SignatureFile>,
+        classResolver: ClassResolver?,
+    ): Codebase {
         val key = CacheKey(signatureFiles, classResolver)
         return map.computeIfAbsent(key) { k ->
-            signatureFileLoader.loadFiles(k.signatureFiles, k.classResolver).apply {
+            signatureFileLoader.load(k.signatureFiles, k.classResolver).apply {
                 // Freeze the classes before caching to avoid any changes being made to cached and
                 // potentially shared objects.
                 freezeClasses()
diff --git a/metalava/src/main/java/com/android/tools/metalava/SignatureWriter.kt b/metalava/src/main/java/com/android/tools/metalava/SignatureWriter.kt
index 274380da7..0d5e0886f 100644
--- a/metalava/src/main/java/com/android/tools/metalava/SignatureWriter.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/SignatureWriter.kt
@@ -28,9 +28,13 @@ import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.ModifierListWriter
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.PropertyItem
+import com.android.tools.metalava.model.StripJavaLangPrefix
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeParameterList
+import com.android.tools.metalava.model.TypeStringConfiguration
 import com.android.tools.metalava.model.text.FileFormat
+import com.android.tools.metalava.model.visitors.ApiPredicate
+import com.android.tools.metalava.model.visitors.ApiType
 import com.android.tools.metalava.model.visitors.ApiVisitor
 import com.android.tools.metalava.model.visitors.FilteringApiVisitor
 import java.io.PrintWriter
@@ -189,7 +193,7 @@ class SignatureWriter(
     }
 
     private fun writeModifiers(item: Item) {
-        modifierListWriter.write(item.actualItem)
+        modifierListWriter.write(item)
     }
 
     private fun writeSuperClassStatement(cls: ClassItem) {
@@ -205,14 +209,24 @@ class SignatureWriter(
         writeExtendsOrImplementsType(superClassType)
     }
 
+    /**
+     * Legacy [TypeStringConfiguration] when writing super types in [writeExtendsOrImplementsType].
+     */
+    private val legacySuperTypeStringConfiguration =
+        TypeStringConfiguration(
+            annotations = fileFormat.includeTypeUseAnnotations,
+            kotlinStyleNulls = fileFormat.kotlinStyleNulls,
+        )
+
     private fun writeExtendsOrImplementsType(typeItem: TypeItem) {
-        val superClassString =
-            typeItem.toTypeString(
-                annotations = fileFormat.includeTypeUseAnnotations,
-                kotlinStyleNulls = fileFormat.kotlinStyleNulls,
-            )
         write(" ")
-        write(superClassString)
+
+        if (fileFormat.stripJavaLangPrefix != StripJavaLangPrefix.LEGACY) {
+            writeType(typeItem)
+        } else {
+            val superClassString = typeItem.toTypeString(legacySuperTypeStringConfiguration)
+            write(superClassString)
+        }
     }
 
     private fun writeInterfaceList(cls: ClassItem) {
@@ -286,16 +300,20 @@ class SignatureWriter(
         write(")")
     }
 
+    /** [TypeStringConfiguration] for use when writing types in [writeType]. */
+    private val typeStringConfiguration =
+        TypeStringConfiguration(
+            annotations = fileFormat.includeTypeUseAnnotations,
+            kotlinStyleNulls = fileFormat.kotlinStyleNulls,
+            stripJavaLangPrefix = fileFormat.stripJavaLangPrefix,
+        )
+
     private fun writeType(type: TypeItem?) {
         type ?: return
 
-        var typeString =
-            type.toTypeString(
-                annotations = fileFormat.includeTypeUseAnnotations,
-                kotlinStyleNulls = fileFormat.kotlinStyleNulls,
-            )
+        var typeString = type.toTypeString(typeStringConfiguration)
 
-        // Strip java.lang. prefix
+        // Strip androidx.annotation. prefix from annotations.
         typeString = TypeItem.shortenTypes(typeString)
 
         write(typeString)
@@ -309,7 +327,8 @@ class SignatureWriter(
                 if (i > 0) {
                     write(", ")
                 }
-                write(type.toTypeString())
+                if (fileFormat.stripJavaLangPrefix != StripJavaLangPrefix.LEGACY) writeType(type)
+                else write(type.toTypeString())
             }
         }
     }
@@ -376,10 +395,9 @@ fun createFilteringVisitorForSignatures(
     apiType: ApiType,
     preFiltered: Boolean,
     showUnannotated: Boolean,
-    apiVisitorConfig: ApiVisitor.Config,
+    apiPredicateConfig: ApiPredicate.Config,
 ): ApiVisitor {
-    val filterEmit = apiType.getEmitFilter(apiVisitorConfig.apiPredicateConfig)
-    val filterReference = apiType.getReferenceFilter(apiVisitorConfig.apiPredicateConfig)
+    val apiFilters = apiType.getApiFilters(apiPredicateConfig)
 
     val (interfaceListSorter, interfaceListComparator) =
         if (fileFormat.sortWholeExtendsList) Pair(null, TypeItem.totalComparator)
@@ -390,10 +408,8 @@ fun createFilteringVisitorForSignatures(
         callableComparator = fileFormat.overloadedMethodOrder.comparator,
         interfaceListSorter = interfaceListSorter,
         interfaceListComparator = interfaceListComparator,
-        filterEmit = filterEmit,
-        filterReference = filterReference,
+        apiFilters = apiFilters,
         preFiltered = preFiltered,
         showUnannotated = showUnannotated,
-        config = apiVisitorConfig,
     )
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/StubGenerationOptions.kt b/metalava/src/main/java/com/android/tools/metalava/StubGenerationOptions.kt
index 237a540d9..fe1df0e31 100644
--- a/metalava/src/main/java/com/android/tools/metalava/StubGenerationOptions.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/StubGenerationOptions.kt
@@ -17,6 +17,7 @@
 package com.android.tools.metalava
 
 import com.android.tools.metalava.cli.common.newDir
+import com.android.tools.metalava.model.PackageFilter
 import com.github.ajalt.clikt.parameters.groups.OptionGroup
 import com.github.ajalt.clikt.parameters.options.convert
 import com.github.ajalt.clikt.parameters.options.flag
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/AddApisFromCodebase.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/AddApisFromCodebase.kt
index 861b6224e..993817452 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/AddApisFromCodebase.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/AddApisFromCodebase.kt
@@ -16,37 +16,32 @@
 
 package com.android.tools.metalava.apilevels
 
-import com.android.tools.metalava.actualItem
 import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
-import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.CodebaseFragment
+import com.android.tools.metalava.model.ConstructorItem
+import com.android.tools.metalava.model.DelegatedVisitor
 import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.Item
-import com.android.tools.metalava.model.visitors.ApiVisitor
-import com.android.tools.metalava.options
-import java.util.function.Predicate
+import com.android.tools.metalava.model.MethodItem
 
 /**
- * Visits the API codebase and inserts into the [Api] the classes, methods and fields. If
- * [providedFilterEmit] and [providedFilterReference] are non-null, they are used to determine which
- * [Item]s should be added to the [api]. Otherwise, the [ApiVisitor] default filters are used.
+ * Visits the API codebase and inserts into the [Api] the classes, methods and fields.
+ *
+ * The [Item]s to be visited is determined by the [codebaseFragment].
  */
 fun addApisFromCodebase(
     api: Api,
-    apiLevel: Int,
-    codebase: Codebase,
+    apiVersion: ApiVersion,
+    codebaseFragment: CodebaseFragment,
     useInternalNames: Boolean,
-    providedFilterEmit: Predicate<Item>? = null,
-    providedFilterReference: Predicate<Item>? = null
 ) {
-    codebase.accept(
-        object :
-            ApiVisitor(
-                preserveClassNesting = false,
-                filterEmit = providedFilterEmit,
-                filterReference = providedFilterReference,
-                config = @Suppress("DEPRECATION") options.apiVisitorConfig,
-            ) {
+    // Keep track of the versions added to this api.
+    api.update(apiVersion)
+
+    val delegatedVisitor =
+        object : DelegatedVisitor {
+            val updater = ApiElement.Updater.forApiVersion(apiVersion)
 
             var currentClass: ApiClass? = null
 
@@ -54,81 +49,35 @@ fun addApisFromCodebase(
                 currentClass = null
             }
 
-            /**
-             * Get the value of [Item.originallyDeprecated] from the [Item.actualItem], i.e. the
-             * item that would actually be written out.
-             */
-            private val Item.actualDeprecated
-                get() = actualItem.effectivelyDeprecated
-
             override fun visitClass(cls: ClassItem) {
-                val newClass = api.addClass(cls.nameInApi(), apiLevel, cls.actualDeprecated)
+                val newClass = api.updateClass(cls.nameInApi(), updater, cls.effectivelyDeprecated)
                 currentClass = newClass
 
                 if (cls.isClass()) {
-                    // The jar files historically contain package private parents instead of
-                    // the real API so we need to correct the data we've already read in
-
-                    val filteredSuperClass = cls.filteredSuperclass(filterReference)
                     val superClass = cls.superClass()
-                    if (filteredSuperClass != superClass && filteredSuperClass != null) {
-                        val existing = newClass.superClasses.firstOrNull()?.name
-                        val superName = superClass?.nameInApi()
-                        if (existing == superName) {
-                            // The bytecode used to point to the old hidden super class. Point
-                            // to the real one (that the signature files referenced) instead.
-                            val removed = superName?.let { newClass.removeSuperClass(it) }
-                            val since = removed?.since ?: apiLevel
-                            val entry =
-                                newClass.addSuperClass(filteredSuperClass.nameInApi(), since)
-                            // Show that it's also seen here
-                            entry.update(apiLevel)
-
-                            // Also inherit the interfaces from that API level, unless it was added
-                            // later
-                            val superClassEntry = api.findClass(superName)
-                            if (superClassEntry != null) {
-                                for (interfaceType in
-                                    superClass!!.filteredInterfaceTypes(filterReference)) {
-                                    val interfaceClass = interfaceType.asClass() ?: return
-                                    var mergedSince = since
-                                    val interfaceName = interfaceClass.nameInApi()
-                                    for (itf in superClassEntry.interfaces) {
-                                        val currentInterface = itf.name
-                                        if (interfaceName == currentInterface) {
-                                            mergedSince = itf.since
-                                            break
-                                        }
-                                    }
-                                    newClass.addInterface(interfaceClass.nameInApi(), mergedSince)
-                                }
-                            }
-                        } else {
-                            newClass.addSuperClass(filteredSuperClass.nameInApi(), apiLevel)
-                        }
-                    } else if (superClass != null) {
-                        newClass.addSuperClass(superClass.nameInApi(), apiLevel)
+                    if (superClass != null) {
+                        newClass.updateSuperClass(superClass.nameInApi(), updater)
                     }
                 } else if (cls.isInterface()) {
                     val superClass = cls.superClass()
                     if (superClass != null && !superClass.isJavaLangObject()) {
-                        newClass.addInterface(superClass.nameInApi(), apiLevel)
+                        newClass.updateInterface(superClass.nameInApi(), updater)
                     }
                 } else if (cls.isEnum()) {
                     // Implicit super class; match convention from bytecode
                     if (newClass.name != enumClass) {
-                        newClass.addSuperClass(enumClass, apiLevel)
+                        newClass.updateSuperClass(enumClass, updater)
                     }
 
                     // Mimic doclava enum methods
                     enumMethodNames(newClass.name).forEach { name ->
-                        newClass.addMethod(name, apiLevel, false)
+                        newClass.updateMethod(name, updater, false)
                     }
                 } else if (cls.isAnnotationType()) {
                     // Implicit super class; match convention from bytecode
                     if (newClass.name != annotationClass) {
-                        newClass.addSuperClass(objectClass, apiLevel)
-                        newClass.addInterface(annotationClass, apiLevel)
+                        newClass.updateSuperClass(objectClass, updater)
+                        newClass.updateInterface(annotationClass, updater)
                     }
                 }
 
@@ -144,30 +93,41 @@ fun addApisFromCodebase(
                 // previously extend object and now extends something else.
                 if (
                     (cls.isClass() || cls.isInterface()) &&
-                        newClass.superClasses.size == 1 &&
-                        newClass.superClasses[0].name == objectClass
+                        newClass.superClasses.singleOrNull()?.name == objectClass
                 ) {
-                    newClass.addSuperClass(objectClass, apiLevel)
+                    newClass.updateSuperClass(objectClass, updater)
                 }
 
-                for (interfaceType in cls.filteredInterfaceTypes(filterReference)) {
+                for (interfaceType in cls.interfaceTypes()) {
                     val interfaceClass = interfaceType.asClass() ?: return
-                    newClass.addInterface(interfaceClass.nameInApi(), apiLevel)
+                    newClass.updateInterface(interfaceClass.nameInApi(), updater)
                 }
             }
 
-            override fun visitCallable(callable: CallableItem) {
+            private fun visitCallable(callable: CallableItem) {
                 if (callable.isPrivate || callable.isPackagePrivate) {
                     return
                 }
-                currentClass?.addMethod(callable.nameInApi(), apiLevel, callable.actualDeprecated)
+                currentClass?.updateMethod(
+                    callable.nameInApi(),
+                    updater,
+                    callable.effectivelyDeprecated
+                )
+            }
+
+            override fun visitConstructor(constructor: ConstructorItem) {
+                visitCallable(constructor)
+            }
+
+            override fun visitMethod(method: MethodItem) {
+                visitCallable(method)
             }
 
             override fun visitField(field: FieldItem) {
                 if (field.isPrivate || field.isPackagePrivate) {
                     return
                 }
-                currentClass?.addField(field.nameInApi(), apiLevel, field.actualDeprecated)
+                currentClass?.updateField(field.nameInApi(), updater, field.effectivelyDeprecated)
             }
 
             /** The name of the field in this [Api], based on [useInternalNames] */
@@ -222,7 +182,8 @@ fun addApisFromCodebase(
                 }
             }
         }
-    )
+
+    codebaseFragment.accept(delegatedVisitor)
 }
 
 /**
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/Api.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/Api.kt
index 5ebd04cce..f492f7860 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/Api.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/Api.kt
@@ -15,58 +15,58 @@
  */
 package com.android.tools.metalava.apilevels
 
-import com.android.tools.metalava.SdkIdentifier
-import java.io.PrintStream
 import java.util.Collections
 import java.util.TreeMap
 import java.util.TreeSet
 
 /** Represents the whole Android API. */
-class Api(private val mMin: Int) : ApiElement("Android API") {
+class Api : ParentApiElement {
+    /**
+     * This has to behave as if it exists since before any specific version (so that every class
+     * always specifies its `since` attribute.
+     */
+    override val since: ApiVersion = ApiVersion.LOWEST
+
+    override var lastPresentIn = since
+        private set
+
+    override val sdks: String? = null
+
+    override val deprecatedIn: ApiVersion? = null
+
     private val mClasses: MutableMap<String, ApiClass> = HashMap()
 
     /**
-     * Prints the whole API definition to a stream.
+     * Updates this with information for a specific API version.
      *
-     * @param stream the stream to print the XML elements to
+     * @param apiVersion an API version that this contains.
      */
-    fun print(stream: PrintStream, sdkIdentifiers: Set<SdkIdentifier>) {
-        stream.print("<api version=\"3\"")
-        if (mMin > 1) {
-            stream.print(" min=\"$mMin\"")
-        }
-        stream.println(">")
-        for ((id, shortname, name, reference) in sdkIdentifiers) {
-            stream.println(
-                String.format(
-                    "\t<sdk id=\"%d\" shortname=\"%s\" name=\"%s\" reference=\"%s\"/>",
-                    id,
-                    shortname,
-                    name,
-                    reference
-                )
-            )
+    fun update(apiVersion: ApiVersion) {
+        // Track the last version added to this.
+        if (lastPresentIn < apiVersion) {
+            lastPresentIn = apiVersion
         }
-        print(mClasses.values, "class", "\t", stream)
-        printClosingTag("api", "", stream)
     }
 
+    override fun toString() = "Android Api"
+
     /**
-     * Adds or updates a class.
+     * Updates the [ApiClass] for the class called [name], creating and adding one if necessary.
      *
      * @param name the name of the class
-     * @param version an API version in which the class existed
+     * @param updater the [ApiElement.Updater] that will update the element with information about
+     *   the version to which it belongs.
      * @param deprecated whether the class was deprecated in the API version
      * @return the newly created or a previously existed class
      */
-    fun addClass(name: String, version: Int, deprecated: Boolean): ApiClass {
-        var classElement = mClasses[name]
-        if (classElement == null) {
-            classElement = ApiClass(name, version, deprecated)
-            mClasses[name] = classElement
-        } else {
-            classElement.update(version, deprecated)
-        }
+    fun updateClass(
+        name: String,
+        updater: ApiElement.Updater,
+        deprecated: Boolean,
+    ): ApiClass {
+        val existing = mClasses[name]
+        val classElement = existing ?: ApiClass(name).apply { mClasses[name] = this }
+        updater.update(classElement, deprecated)
         return classElement
     }
 
@@ -90,24 +90,46 @@ class Api(private val mMin: Int) : ApiElement("Android API") {
     }
 
     private fun backfillSdkExtensions() {
-        // SdkExtensions.getExtensionVersion was added in 30/R, but was a SystemApi
-        // to avoid publishing the versioning API publicly before there was any
-        // valid use for it.
-        // getAllExtensionsVersions was added as part of 31/S
-        // The class and its APIs were made public between S and T, but we pretend
-        // here like it was always public, for maximum backward compatibility.
+        val sdk30 = ApiVersion.fromLevel(30)
+        val sdk31 = ApiVersion.fromLevel(31)
+        val sdk33 = ApiVersion.fromLevel(33)
         val sdkExtensions = findClass("android/os/ext/SdkExtensions")
-        if (sdkExtensions != null && sdkExtensions.since != 30 && sdkExtensions.since != 33) {
+        if (sdkExtensions != null && sdkExtensions.since != sdk30 && sdkExtensions.since != sdk33) {
             throw AssertionError("Received unexpected historical data")
-        } else if (sdkExtensions == null || sdkExtensions.since == 30) {
-            // This is the system API db (30), or module-lib/system-server dbs (null)
-            // They don't need patching.
+        } else if (sdkExtensions == null) {
+            // This is the module-lib/system-server dbs (null) and so don't need patching.
             return
+        } else if (sdkExtensions.since == sdk30) {
+            // This is the system API db (30). The class does not need patching but the members do.
+            // Drop through.
+        } else {
+            // The class was added in 30/R, but was a SystemApi to avoid publishing the versioning
+            // API publicly before there was any valid use for it. It was made public between S and
+            // T, but we pretend here like it was always public, for maximum backward compatibility.
+            sdkExtensions.update(sdk30, false)
         }
-        sdkExtensions.update(30, false)
-        sdkExtensions.addSuperClass("java/lang/Object", 30)
-        sdkExtensions.getMethod("getExtensionVersion(I)I")!!.update(30, false)
-        sdkExtensions.getMethod("getAllExtensionVersions()Ljava/util/Map;")!!.update(31, false)
+
+        val sdk30Updater = ApiElement.Updater.forApiVersion(sdk30)
+        val sdk31Updater = ApiElement.Updater.forApiVersion(sdk31)
+
+        // Remove the sdks attribute from the extends for public and system.
+        sdkExtensions.updateSuperClass("java/lang/Object", sdk30Updater).apply {
+            // Pretend this was not added in any extension.
+            clearSdkExtensionInfo()
+        }
+
+        // getExtensionVersion was added in 30/R along with the class, and just like the class we
+        // pretend it was always public.
+        sdkExtensions.updateMethod("getExtensionVersion(I)I", sdk30Updater, false)
+
+        // getAllExtensionsVersions was added as part of 31/S SystemApi. Just like for the class
+        // we pretend it was always public.
+        sdkExtensions
+            .updateMethod("getAllExtensionVersions()Ljava/util/Map;", sdk31Updater, false)
+            .apply {
+                // Pretend this was not added in any extension.
+                clearSdkExtensionInfo()
+            }
     }
 
     /**
@@ -117,25 +139,24 @@ class Api(private val mMin: Int) : ApiElement("Android API") {
      * that have interfaces, we check up the inheritance chain to see if it has already been
      * introduced in a super class at an earlier API level.
      */
-    fun removeImplicitInterfaces() {
+    private fun removeImplicitInterfaces() {
         for (classElement in mClasses.values) {
             classElement.removeImplicitInterfaces(mClasses)
         }
     }
 
     /** @see ApiClass.removeOverridingMethods */
-    fun removeOverridingMethods() {
+    private fun removeOverridingMethods() {
         for (classElement in mClasses.values) {
             classElement.removeOverridingMethods(mClasses)
         }
     }
 
-    fun inlineFromHiddenSuperClasses() {
+    private fun inlineFromHiddenSuperClasses() {
         val hidden: MutableMap<String, ApiClass> = HashMap()
         for (classElement in mClasses.values) {
-            if (
-                classElement.hiddenUntil < 0
-            ) { // hidden in the .jar files? (mMax==codebase, -1: jar files)
+            if (classElement.alwaysHidden) {
+                // hidden in the .jar files? (mMax==codebase, -1: jar files)
                 hidden[classElement.name] = classElement
             }
         }
@@ -144,7 +165,7 @@ class Api(private val mMin: Int) : ApiElement("Android API") {
         }
     }
 
-    fun prunePackagePrivateClasses() {
+    private fun prunePackagePrivateClasses() {
         for (cls in mClasses.values) {
             cls.removeHiddenSuperClasses(mClasses)
         }
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiClass.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiClass.kt
index a4b4cbd3a..fd39c4ecc 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiClass.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiClass.kt
@@ -16,39 +16,57 @@
 package com.android.tools.metalava.apilevels
 
 import com.google.common.collect.Iterables
-import java.io.PrintStream
 import java.util.concurrent.ConcurrentHashMap
-import kotlin.math.abs
-import kotlin.math.min
 
 /**
  * Represents a class or an interface and its methods/fields. This is used to write the simplified
  * XML file containing all the public API.
  */
-class ApiClass(name: String, version: Int, deprecated: Boolean) :
-    ApiElement(name, version, deprecated) {
-    private val mSuperClasses: MutableList<ApiElement> = ArrayList()
-    private val mInterfaces: MutableList<ApiElement> = ArrayList()
+class ApiClass(name: String) : ApiElement(name) {
+
+    private val mSuperClasses = mutableMapOf<String, ApiElement>()
+    private val mInterfaces = mutableMapOf<String, ApiElement>()
+
+    /** If `true`, never seen as public. */
+    var alwaysHidden = false // Package private class?
+    private val mFields = ConcurrentHashMap<String, ApiElement>()
+    private val mMethods = ConcurrentHashMap<String, ApiElement>()
 
     /**
-     * If negative, never seen as public. The absolute value is the last api level it is seen as
-     * hidden in. E.g. "-5" means a class that was hidden in api levels 1-5, then it was deleted,
-     * and "8" means a class that was hidden in api levels 1-8 then made public in 9.
+     * Updates the [ApiElement] for field with [name], creating and adding one if necessary.
+     *
+     * @param name the name of the field.
+     * @param updater the [ApiElement.Updater] that will update the element with information about
+     *   the version to which it belongs.
+     * @param deprecated the deprecated status.
      */
-    var hiddenUntil = 0 // Package private class?
-    private val mFields: MutableMap<String, ApiElement> = ConcurrentHashMap()
-    private val mMethods: MutableMap<String, ApiElement> = ConcurrentHashMap()
-
-    fun addField(name: String, version: Int, deprecated: Boolean): ApiElement {
-        return addToMap(mFields, name, version, deprecated)
+    fun updateField(
+        name: String,
+        updater: Updater,
+        deprecated: Boolean,
+    ): ApiElement {
+        return updateElementInMap(mFields, name, updater, deprecated)
     }
 
     val fields: Collection<ApiElement>
         get() = mFields.values
 
-    fun addMethod(name: String, version: Int, deprecated: Boolean): ApiElement {
+    /**
+     * Updates the [ApiElement] for method with [signature], creating and adding one if necessary.
+     *
+     * @param signature the signature of the method, which includes the name and parameter/return
+     *   types
+     * @param updater the [ApiElement.Updater] that will update the element with information about
+     *   the version to which it belongs.
+     * @param deprecated the deprecated status.
+     */
+    fun updateMethod(
+        signature: String,
+        updater: Updater,
+        deprecated: Boolean,
+    ): ApiElement {
         // Correct historical mistake in android.jar files
-        var correctedName = name
+        var correctedName = signature
         if (correctedName.endsWith(")Ljava/lang/AbstractStringBuilder;")) {
             correctedName =
                 correctedName.substring(
@@ -56,100 +74,66 @@ class ApiClass(name: String, version: Int, deprecated: Boolean) :
                     correctedName.length - ")Ljava/lang/AbstractStringBuilder;".length
                 ) + ")L" + this.name + ";"
         }
-        return addToMap(mMethods, correctedName, version, deprecated)
+        return updateElementInMap(mMethods, correctedName, updater, deprecated)
     }
 
     val methods: Collection<ApiElement>
         get() = mMethods.values
 
-    fun addSuperClass(superClass: String, since: Int): ApiElement {
-        return addToArray(mSuperClasses, superClass, since)
-    }
-
-    fun removeSuperClass(superClass: String): ApiElement? {
-        val entry = findByName(mSuperClasses, superClass)
-        if (entry != null) {
-            mSuperClasses.remove(entry)
-        }
-        return entry
-    }
-
-    val superClasses: List<ApiElement>
-        get() = mSuperClasses
-
-    fun updateHidden(api: Int, hidden: Boolean) {
-        hiddenUntil = if (hidden) -api else abs(api)
-    }
-
-    private fun alwaysHidden(): Boolean {
-        return hiddenUntil < 0
-    }
-
-    fun addInterface(interfaceClass: String, since: Int) {
-        addToArray(mInterfaces, interfaceClass, since)
+    /**
+     * Updates an element for [superClassType], creating and adding one if necessary.
+     *
+     * @param superClassType the name of the super class type.
+     * @param updater the [ApiElement.Updater] that will update the element with information about
+     *   the version to which it belongs.
+     */
+    fun updateSuperClass(superClassType: String, updater: Updater) =
+        updateElementInMap(
+            mSuperClasses,
+            superClassType,
+            updater,
+            // References to super classes can never be deprecated.
+            false,
+        )
+
+    val superClasses: Collection<ApiElement>
+        get() = mSuperClasses.values
+
+    fun updateHidden(hidden: Boolean) {
+        alwaysHidden = hidden
     }
 
-    val interfaces: List<ApiElement>
-        get() = mInterfaces
-
-    private fun addToMap(
+    /**
+     * Updates an element for [interfaceType], creating and adding one if necessary.
+     *
+     * @param interfaceType the interface type.
+     * @param updater the [ApiElement.Updater] that will update the element with information about
+     *   the version to which it belongs.
+     */
+    fun updateInterface(interfaceType: String, updater: Updater) =
+        updateElementInMap(
+            mInterfaces,
+            interfaceType,
+            updater,
+            // References to interfaces can never be deprecated.
+            false,
+        )
+
+    val interfaces: Collection<ApiElement>
+        get() = mInterfaces.values
+
+    private fun updateElementInMap(
         elements: MutableMap<String, ApiElement>,
         name: String,
-        version: Int,
-        deprecated: Boolean
+        updater: Updater,
+        deprecated: Boolean,
     ): ApiElement {
-        var element = elements[name]
-        if (element == null) {
-            element = ApiElement(name, version, deprecated)
-            elements[name] = element
-        } else {
-            element.update(version, deprecated)
-        }
+        val existing = elements[name]
+        val element = existing ?: ApiElement(name).apply { elements[name] = this }
+        updater.update(element, deprecated)
         return element
     }
 
-    private fun addToArray(
-        elements: MutableCollection<ApiElement>,
-        name: String,
-        version: Int
-    ): ApiElement {
-        var element = findByName(elements, name)
-        if (element == null) {
-            element = ApiElement(name, version)
-            elements.add(element)
-        } else {
-            element.update(version)
-        }
-        return element
-    }
-
-    private fun findByName(collection: Collection<ApiElement>, name: String): ApiElement? {
-        for (element in collection) {
-            if (element.name == name) {
-                return element
-            }
-        }
-        return null
-    }
-
-    override fun print(
-        tag: String?,
-        parentElement: ApiElement,
-        indent: String,
-        stream: PrintStream
-    ) {
-        if (hiddenUntil < 0) {
-            return
-        }
-        super.print(tag, false, parentElement, indent, stream)
-        val innerIndent = indent + '\t'
-        print(mSuperClasses, "extends", innerIndent, stream)
-        print(mInterfaces, "implements", innerIndent, stream)
-        print(mMethods.values, "method", innerIndent, stream)
-        print(mFields.values, "field", innerIndent, stream)
-        printClosingTag(tag, indent, stream)
-    }
-
     /**
      * Removes all interfaces that are also implemented by superclasses or extended by interfaces
      * this class implements.
@@ -160,10 +144,10 @@ class ApiClass(name: String, version: Int, deprecated: Boolean) :
         if (mInterfaces.isEmpty() || mSuperClasses.isEmpty()) {
             return
         }
-        val iterator = mInterfaces.iterator()
+        val iterator = mInterfaces.values.iterator()
         while (iterator.hasNext()) {
             val interfaceElement = iterator.next()
-            for (superClass in mSuperClasses) {
+            for (superClass in superClasses) {
                 if (superClass.introducedNotLaterThan(interfaceElement)) {
                     val cls = allClasses[superClass.name]
                     if (cls != null && cls.implementsInterface(interfaceElement, allClasses)) {
@@ -179,7 +163,7 @@ class ApiClass(name: String, version: Int, deprecated: Boolean) :
         interfaceElement: ApiElement,
         allClasses: Map<String, ApiClass>
     ): Boolean {
-        for (localInterface in mInterfaces) {
+        for (localInterface in interfaces) {
             if (localInterface.introducedNotLaterThan(interfaceElement)) {
                 if (interfaceElement.name == localInterface.name) {
                     return true
@@ -191,7 +175,7 @@ class ApiClass(name: String, version: Int, deprecated: Boolean) :
                 }
             }
         }
-        for (superClass in mSuperClasses) {
+        for (superClass in superClasses) {
             if (superClass.introducedNotLaterThan(interfaceElement)) {
                 val cls = allClasses[superClass.name]
                 if (cls != null && cls.implementsInterface(interfaceElement, allClasses)) {
@@ -246,7 +230,7 @@ class ApiClass(name: String, version: Int, deprecated: Boolean) :
         allClasses: Map<String, ApiClass>
     ): Boolean {
         // Check this class' parents.
-        for (parent in Iterables.concat(mSuperClasses, mInterfaces)) {
+        for (parent in Iterables.concat(superClasses, interfaces)) {
             // Only check the parent if it was a parent class at the introduction of the method.
             if (parent!!.introducedNotLaterThan(method)) {
                 val cls = allClasses[parent.name]
@@ -258,10 +242,6 @@ class ApiClass(name: String, version: Int, deprecated: Boolean) :
         return false
     }
 
-    override fun toString(): String {
-        return name
-    }
-
     private var haveInlined = false
 
     fun inlineFromHiddenSuperClasses(hidden: Map<String, ApiClass>) {
@@ -294,16 +274,16 @@ class ApiClass(name: String, version: Int, deprecated: Boolean) :
         // android.jar files)
         // remove these here and replace with the filtered super classes, updating API levels in the
         // process
-        val iterator = mSuperClasses.listIterator()
-        var min = Int.MAX_VALUE
+        val iterator = mSuperClasses.values.iterator()
+        var min = ApiVersion.HIGHEST
         while (iterator.hasNext()) {
             val next = iterator.next()
-            min = min(min, next.since)
+            min = minOf(min, next.since)
             val extendsClass = api[next.name]
-            if (extendsClass != null && extendsClass.alwaysHidden()) {
+            if (extendsClass != null && extendsClass.alwaysHidden) {
                 val since = extendsClass.since
                 iterator.remove()
-                for (other in mSuperClasses) {
+                for (other in superClasses) {
                     if (other.since >= since) {
                         other.update(min)
                     }
@@ -321,14 +301,14 @@ class ApiClass(name: String, version: Int, deprecated: Boolean) :
     // Connectivity apex, but being implemented by NrQosSessionAttributes from
     // frameworks/base/telephony.
     fun removeMissingClasses(api: Map<String, ApiClass>) {
-        val superClassIter = mSuperClasses.iterator()
+        val superClassIter = mSuperClasses.values.iterator()
         while (superClassIter.hasNext()) {
-            val scls = superClassIter.next()
-            if (!api.containsKey(scls.name)) {
+            val superClass = superClassIter.next()
+            if (!api.containsKey(superClass.name)) {
                 superClassIter.remove()
             }
         }
-        val interfacesIter = mInterfaces.iterator()
+        val interfacesIter = mInterfaces.values.iterator()
         while (interfacesIter.hasNext()) {
             val intf = interfacesIter.next()
             if (!api.containsKey(intf.name)) {
@@ -340,26 +320,16 @@ class ApiClass(name: String, version: Int, deprecated: Boolean) :
     // Returns the set of superclasses or interfaces are not present in the provided api map
     fun findMissingClasses(api: Map<String, ApiClass>): Set<ApiElement> {
         val result: MutableSet<ApiElement> = HashSet()
-        for (scls in mSuperClasses) {
-            if (!api.containsKey(scls.name)) {
-                result.add(scls)
+        for (superClass in superClasses) {
+            if (!api.containsKey(superClass.name)) {
+                result.add(superClass)
             }
         }
-        for (intf in mInterfaces) {
+        for (intf in interfaces) {
             if (!api.containsKey(intf.name)) {
                 result.add(intf)
             }
         }
         return result
     }
-
-    val fieldIterator: Iterator<ApiElement>
-        get() = mFields.values.iterator()
-
-    val methodIterator: Iterator<ApiElement>
-        get() = mMethods.values.iterator()
-
-    fun getMethod(name: String?): ApiElement? {
-        return mMethods[name]
-    }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiElement.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiElement.kt
index d351321d8..f122d9dd7 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiElement.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiElement.kt
@@ -15,20 +15,16 @@
  */
 package com.android.tools.metalava.apilevels
 
-import java.io.PrintStream
+/** Represents a parent of [ApiElement]. */
+interface ParentApiElement {
+    /** The API version this API was first introduced in. */
+    val since: ApiVersion
 
-/** Represents an API element, e.g. class, method or field. */
-open class ApiElement : Comparable<ApiElement> {
-    /** Returns the name of the API element. */
-    val name: String
-    /** The Android API level of this ApiElement. */
-    /** The Android platform SDK version this API was first introduced in. */
-    var since = 0
-        private set
-    /** The extension version of this ApiElement. */
-    /** The Android extension SDK version this API was first introduced in. */
-    var sinceExtension = NEVER
-        private set
+    /**
+     * The version in which this API last appeared, if this is not the latest API then it will be
+     * treated as having been removed in the next API version, i.e. [lastPresentIn] + 1.
+     */
+    val lastPresentIn: ApiVersion
 
     /**
      * The SDKs and their versions this API was first introduced in.
@@ -39,36 +35,48 @@ open class ApiElement : Comparable<ApiElement> {
      *
      * This field is a super-set of mSince, and if non-null/non-empty, should be preferred.
      */
-    private var mSdks: String? = null
-    var mainlineModule: String? = null
-        private set
+    val sdks: String?
+
+    /** The optional API level this element was deprecated in. */
+    val deprecatedIn: ApiVersion?
+}
+
+/**
+ * Represents an API element, e.g. class, method or field.
+ *
+ * @param name the name of the API element
+ */
+open class ApiElement(val name: String) : ParentApiElement, Comparable<ApiElement> {
 
     /**
-     * The API level this element was deprecated in, should only be used if [isDeprecated] is true.
+     * The Android API level of this ApiElement. i.e. The Android platform SDK version this API was
+     * first introduced in.
      */
-    var deprecatedIn = 0
+    final override lateinit var since: ApiVersion
         private set
 
-    private var mLastPresentIn = 0
-
     /**
-     * @param name the name of the API element
-     * @param version an API version for which the API element existed, or -1 if the class does not
-     *   yet exist in the Android SDK (only in extension SDKs)
-     * @param deprecated whether the API element was deprecated in the API version in question
+     * The extension version of this ApiElement. i.e. The Android extension SDK version this API was
+     * first introduced in.
      */
-    internal constructor(name: String, version: Int, deprecated: Boolean = false) {
-        this.name = name
-        since = version
-        mLastPresentIn = version
-        if (deprecated) {
-            deprecatedIn = version
-        }
-    }
+    var sinceExtension: ExtVersion? = null
+        private set
 
-    /** @param name the name of the API element */
-    internal constructor(name: String) {
-        this.name = name
+    final override var sdks: String? = null
+        private set
+
+    var mainlineModule: String? = null
+        private set
+
+    /** The optional API level this element was deprecated in. */
+    final override var deprecatedIn: ApiVersion? = null
+        private set
+
+    final override lateinit var lastPresentIn: ApiVersion
+        private set
+
+    override fun toString(): String {
+        return name
     }
 
     /**
@@ -84,197 +92,127 @@ open class ApiElement : Comparable<ApiElement> {
     /**
      * Updates the API element with information for a specific API version.
      *
-     * @param version an API version for which the API element existed
+     * @param apiVersion an API version for which the API element existed
      * @param deprecated whether the API element was deprecated in the API version in question
      */
-    fun update(version: Int, deprecated: Boolean) {
-        assert(version > 0)
-        if (since > version) {
-            since = version
+    fun update(apiVersion: ApiVersion, deprecated: Boolean = deprecatedIn != null) {
+        assert(apiVersion.isValid)
+        if (!::since.isInitialized || since > apiVersion) {
+            since = apiVersion
         }
-        if (mLastPresentIn < version) {
-            mLastPresentIn = version
+        if (!::lastPresentIn.isInitialized || lastPresentIn < apiVersion) {
+            lastPresentIn = apiVersion
         }
+        val deprecatedVersion = deprecatedIn
         if (deprecated) {
             // If it was not previously deprecated or was deprecated in a later version than this
             // one then deprecate it in this version.
-            if (deprecatedIn == 0 || deprecatedIn > version) {
-                deprecatedIn = version
+            if (deprecatedVersion == null || deprecatedVersion > apiVersion) {
+                deprecatedIn = apiVersion
             }
         } else {
             // If it was previously deprecated and was deprecated in an earlier version than this
             // one then treat it as being undeprecated.
-            if (deprecatedIn != 0 && deprecatedIn < version) {
-                deprecatedIn = 0
+            if (deprecatedVersion != null && deprecatedVersion < apiVersion) {
+                deprecatedIn = null
             }
         }
     }
 
     /**
-     * Updates the API element with information for a specific API version.
+     * Analogous to update(), but for extensions sdk versions.
      *
-     * @param version an API version for which the API element existed
+     * @param extVersion an extension SDK version for which the API element existed
      */
-    fun update(version: Int) {
-        update(version, isDeprecated)
+    fun updateExtension(extVersion: ExtVersion) {
+        assert(extVersion.isValid)
+        // Record the earliest extension in which this appeared.
+        if (sinceExtension == null || sinceExtension!! > extVersion) {
+            sinceExtension = extVersion
+        }
     }
 
     /**
-     * Analogous to update(), but for extensions sdk versions.
+     * Clears the sdk extension information from this [ApiElement].
      *
-     * @param version an extension SDK version for which the API element existed
+     * This is only intended for use by [Api.backfillSdkExtensions].
      */
-    fun updateExtension(version: Int) {
-        assert(version > 0)
-        if (sinceExtension > version) {
-            sinceExtension = version
-        }
+    fun clearSdkExtensionInfo() {
+        this.sinceExtension = null
+        this.sdks = null
     }
 
     fun updateSdks(sdks: String?) {
-        mSdks = sdks
+        this.sdks = sdks
     }
 
     fun updateMainlineModule(module: String?) {
         mainlineModule = module
     }
 
-    val isDeprecated: Boolean
-        /** Checks whether the API element is deprecated or not. */
-        get() = deprecatedIn != 0
-
-    /**
-     * Prints an XML representation of the element to a stream terminated by a line break.
-     * Attributes with values matching the parent API element are omitted.
-     *
-     * @param tag the tag of the XML element
-     * @param parentElement the parent API element
-     * @param indent the whitespace prefix to insert before the XML element
-     * @param stream the stream to print the XML element to
-     */
-    open fun print(tag: String?, parentElement: ApiElement, indent: String, stream: PrintStream) {
-        print(tag, true, parentElement, indent, stream)
-    }
-
-    /**
-     * Prints an XML representation of the element to a stream terminated by a line break.
-     * Attributes with values matching the parent API element are omitted.
-     *
-     * @param tag the tag of the XML element
-     * @param closeTag if true the XML element is terminated by "/>", otherwise the closing tag of
-     *   the element is not printed
-     * @param parentElement the parent API element
-     * @param indent the whitespace prefix to insert before the XML element
-     * @param stream the stream to print the XML element to
-     * @see .printClosingTag
-     */
-    fun print(
-        tag: String?,
-        closeTag: Boolean,
-        parentElement: ApiElement,
-        indent: String?,
-        stream: PrintStream
-    ) {
-        stream.print(indent)
-        stream.print('<')
-        stream.print(tag)
-        stream.print(" name=\"")
-        stream.print(encodeAttribute(name))
-        if (!isEmpty(mainlineModule) && !isEmpty(mSdks)) {
-            stream.print("\" module=\"")
-            stream.print(encodeAttribute(mainlineModule!!))
-        }
-        if (since > parentElement.since) {
-            stream.print("\" since=\"")
-            stream.print(since)
-        }
-        if (!isEmpty(mSdks) && mSdks != parentElement.mSdks) {
-            stream.print("\" sdks=\"")
-            stream.print(mSdks)
-        }
-        if (deprecatedIn != 0 && deprecatedIn != parentElement.deprecatedIn) {
-            stream.print("\" deprecated=\"")
-            stream.print(deprecatedIn)
-        }
-        if (mLastPresentIn < parentElement.mLastPresentIn) {
-            stream.print("\" removed=\"")
-            stream.print(mLastPresentIn + 1)
-        }
-        stream.print('"')
-        if (closeTag) {
-            stream.print('/')
-        }
-        stream.println('>')
-    }
-
-    private fun isEmpty(s: String?): Boolean {
-        return s.isNullOrEmpty()
-    }
-
-    /**
-     * Prints homogeneous XML elements to a stream. Each element is printed on a separate line.
-     * Attributes with values matching the parent API element are omitted.
-     *
-     * @param elements the elements to print
-     * @param tag the tag of the XML elements
-     * @param indent the whitespace prefix to insert before each XML element
-     * @param stream the stream to print the XML elements to
-     */
-    fun print(elements: Collection<ApiElement>, tag: String?, indent: String, stream: PrintStream) {
-        for (element in elements.sorted()) {
-            element.print(tag, this, indent, stream)
-        }
-    }
-
     override fun compareTo(other: ApiElement): Int {
         return name.compareTo(other.name)
     }
 
-    companion object {
-        const val NEVER = Int.MAX_VALUE
-
+    /**
+     * Encapsulates the process of updating an [ApiElement] to mark it as being included in a
+     * specific API version.
+     */
+    sealed interface Updater {
         /**
-         * Prints a closing tag of an XML element terminated by a line break.
+         * Updates the API element with information for a specific API version.
          *
-         * @param tag the tag of the element
-         * @param indent the whitespace prefix to insert before the closing tag
-         * @param stream the stream to print the XML element to
+         * @param apiElement the [ApiElement] to update.
+         * @param deprecated whether the API element was deprecated in the API version in question
          */
-        fun printClosingTag(tag: String?, indent: String?, stream: PrintStream) {
-            stream.print(indent)
-            stream.print("</")
-            stream.print(tag)
-            stream.println('>')
+        fun update(
+            apiElement: ApiElement,
+            deprecated: Boolean = apiElement.deprecatedIn != null,
+        )
+
+        /** Updates the [ApiElement] by calling [ApiElement.update]. */
+        private open class ApiVersionUpdater(private val apiVersion: ApiVersion) : Updater {
+            override fun update(apiElement: ApiElement, deprecated: Boolean) {
+                apiElement.update(apiVersion, deprecated)
+            }
         }
 
-        private fun encodeAttribute(attribute: String): String {
-            return buildString {
-                val n = attribute.length
-                // &, ", ' and < are illegal in attributes; see
-                // http://www.w3.org/TR/REC-xml/#NT-AttValue
-                // (' legal in a " string and " is legal in a ' string but here we'll stay on the
-                // safe
-                // side).
-                for (i in 0 until n) {
-                    when (val c = attribute[i]) {
-                        '"' -> {
-                            append("&quot;") // $NON-NLS-1$
-                        }
-                        '<' -> {
-                            append("&lt;") // $NON-NLS-1$
-                        }
-                        '\'' -> {
-                            append("&apos;") // $NON-NLS-1$
-                        }
-                        '&' -> {
-                            append("&amp;") // $NON-NLS-1$
-                        }
-                        else -> {
-                            append(c)
-                        }
-                    }
+        /**
+         * Extends [ApiVersionUpdater] to also update the [ApiElement.sinceExtension] and
+         * [ApiElement.mainlineModule] properties.
+         */
+        private class ExtensionUpdater(
+            nextSdkVersion: ApiVersion,
+            private val extVersion: ExtVersion,
+            private val module: String
+        ) : ApiVersionUpdater(nextSdkVersion) {
+            override fun update(apiElement: ApiElement, deprecated: Boolean) {
+                super.update(apiElement, deprecated)
+                apiElement.updateExtension(extVersion)
+                if (apiElement is ApiClass) {
+                    apiElement.updateMainlineModule(module)
                 }
             }
         }
+
+        companion object {
+            /** Create an [Updater] for [apiVersion]. */
+            fun forApiVersion(apiVersion: ApiVersion): Updater {
+                return ApiVersionUpdater(apiVersion)
+            }
+
+            fun forExtVersion(
+                nextSdkVersion: ApiVersion,
+                extVersion: ExtVersion,
+                module: String
+            ): Updater {
+                return ExtensionUpdater(nextSdkVersion, extVersion, module)
+            }
+        }
     }
 }
+
+operator fun ApiVersion?.compareTo(other: ApiVersion?): Int =
+    if (this == null) {
+        if (other == null) 0 else -1
+    } else if (other == null) +1 else this.compareTo(other)
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiGenerator.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiGenerator.kt
index 8c3afebc0..02bf4ce01 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiGenerator.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiGenerator.kt
@@ -15,128 +15,112 @@
  */
 package com.android.tools.metalava.apilevels
 
-import com.android.tools.metalava.SdkIdentifier
-import com.android.tools.metalava.SignatureFileCache
 import com.android.tools.metalava.apilevels.ApiToExtensionsMap.Companion.fromXml
 import com.android.tools.metalava.apilevels.ExtensionSdkJarReader.Companion.findExtensionSdkJarFiles
-import com.android.tools.metalava.model.Codebase
-import com.android.tools.metalava.model.Item
-import com.android.tools.metalava.model.text.SignatureFile
+import com.android.tools.metalava.model.CodebaseFragment
 import java.io.File
 import java.io.IOException
-import java.io.PrintStream
-import java.nio.charset.StandardCharsets
-import java.util.function.Predicate
 
 /**
  * Main class for command line command to convert the existing API XML/TXT files into diff-based
  * simple text files.
  */
-class ApiGenerator(private val signatureFileCache: SignatureFileCache) {
-    @Throws(IOException::class, IllegalArgumentException::class)
+class ApiGenerator {
+    /**
+     * Generates an XML API version history file based on the API surfaces of the versions provided.
+     *
+     * @param codebaseFragment A [CodebaseFragment] representing the current API surface.
+     * @param config Configuration provided from command line options.
+     */
     fun generateXml(
-        apiLevels: Array<File>,
-        firstApiLevel: Int,
-        currentApiLevel: Int,
-        isDeveloperPreviewBuild: Boolean,
-        outputFile: File,
-        codebase: Codebase,
-        sdkExtensionsArguments: SdkExtensionsArguments?,
-        removeMissingClasses: Boolean
+        codebaseFragment: CodebaseFragment,
+        config: GenerateXmlConfig,
     ): Boolean {
-        val notFinalizedApiLevel = currentApiLevel + 1
-        val api = createApiFromAndroidJars(apiLevels, firstApiLevel)
-        if (isDeveloperPreviewBuild || apiLevels.size - 1 < currentApiLevel) {
-            // Only include codebase if we don't have a prebuilt, finalized jar for it.
-            val apiLevel = if (isDeveloperPreviewBuild) notFinalizedApiLevel else currentApiLevel
-            addApisFromCodebase(api, apiLevel, codebase, true)
+        val apiLevels = config.apiLevels
+        val lastApiVersion = ApiVersion.fromLevel(apiLevels.size - 1)
+        val firstApiLevel = config.firstApiLevel
+        val currentSdkVersion = config.currentSdkVersion
+        val notFinalizedSdkVersion = currentSdkVersion + 1
+        val versionedApis =
+            (firstApiLevel until apiLevels.size).map { apiLevel ->
+                val jar = apiLevels[apiLevel]
+                val sdkVersion = ApiVersion.fromLevel(apiLevel)
+                VersionedJarApi(jar, sdkVersion)
+            }
+        val api = createApiFromVersionedApis(versionedApis)
+        val isDeveloperPreviewBuild = config.isDeveloperPreviewBuild
+
+        // Compute the version to use for the current codebase.
+        val codebaseSdkVersion =
+            when {
+                // The current codebase is a developer preview so use the next, in the process of
+                // being finalized version.
+                isDeveloperPreviewBuild -> notFinalizedSdkVersion
+
+                // There is no prebuilt, finalized jar matching the current API level so use the
+                // current codebase for the current API version.
+                lastApiVersion < currentSdkVersion -> currentSdkVersion
+
+                // Else do not include the current codebase.
+                else -> null
+            }
+
+        // Get a list of all versions, including the codebase version, if necessary.
+        val allVersions = buildList {
+            (firstApiLevel until apiLevels.size).mapTo(this) { ApiVersion.fromLevel(it) }
+            if (codebaseSdkVersion != null) add(codebaseSdkVersion)
         }
-        api.backfillHistoricalFixes()
-        var sdkIdentifiers = emptySet<SdkIdentifier>()
+
+        if (codebaseSdkVersion != null) {
+            addApisFromCodebase(api, codebaseSdkVersion, codebaseFragment, true)
+        }
+        var availableSdkExtensions: AvailableSdkExtensions? = null
+        val sdkExtensionsArguments = config.sdkExtensionsArguments
         if (sdkExtensionsArguments != null) {
-            sdkIdentifiers =
+            availableSdkExtensions =
                 processExtensionSdkApis(
                     api,
-                    notFinalizedApiLevel,
+                    notFinalizedSdkVersion,
                     sdkExtensionsArguments.sdkExtJarRoot,
                     sdkExtensionsArguments.sdkExtInfoFile,
-                    sdkExtensionsArguments.skipVersionsGreaterThan
                 )
         }
-        api.inlineFromHiddenSuperClasses()
-        api.removeImplicitInterfaces()
-        api.removeOverridingMethods()
-        api.prunePackagePrivateClasses()
-        if (removeMissingClasses) {
+        api.backfillHistoricalFixes()
+        api.clean()
+        if (config.removeMissingClasses) {
             api.removeMissingClasses()
         } else {
             api.verifyNoMissingClasses()
         }
-        return createApiLevelsXml(outputFile, api, sdkIdentifiers)
+        val printer = ApiXmlPrinter(availableSdkExtensions, firstApiLevel, allVersions)
+        return createApiLevelsFile(config.outputFile, printer, api)
     }
 
     /**
-     * Creates an [Api] from a list of past API signature files. In the generated [Api], the oldest
-     * API version will be represented as level 1, the next as level 2, etc.
+     * Creates an [Api] from a list of [VersionedApi]s.
      *
-     * @param previousApiFiles A list of API signature files, one for each version of the API, in
-     *   order from oldest to newest API version.
+     * @param versionedApis A list of [VersionedApi]s, one for each version of the API, in order
+     *   from oldest to newest API version.
      */
-    private fun createApiFromSignatureFiles(previousApiFiles: List<File>): Api {
-        // Starts at level 1 because 0 is not a valid API level.
-        var apiLevel = 1
-        val api = Api(apiLevel)
-        for (apiFile in previousApiFiles) {
-            val codebase: Codebase = signatureFileCache.load(SignatureFile.fromFile(apiFile))
-            addApisFromCodebase(api, apiLevel, codebase, false)
-            apiLevel += 1
+    private fun createApiFromVersionedApis(versionedApis: List<VersionedApi>): Api {
+        val api = Api()
+        for (versionedApi in versionedApis) {
+            versionedApi.updateApi(api)
         }
-        api.clean()
         return api
     }
 
     /**
      * Generates an API version history file based on the API surfaces of the versions provided.
      *
-     * @param pastApiVersions A list of API signature files, ordered from the oldest API version to
-     *   newest.
-     * @param currentApiVersion A codebase representing the current API surface.
-     * @param outputFile Path of the JSON file to write output to.
-     * @param apiVersionNames The names of the API versions, ordered starting from version 1. This
-     *   should include the names of all the [pastApiVersions], then the name of the
-     *   [currentApiVersion].
-     * @param filterEmit The filter to use to determine if an [Item] should be included in the API.
-     * @param filterReference The filter to use to determine if a reference to an [Item] should be
-     *   included in the API.
+     * @param config Configuration provided from command line options.
      */
-    fun generateJson(
-        pastApiVersions: List<File>,
-        currentApiVersion: Codebase,
-        outputFile: File,
-        apiVersionNames: List<String>,
-        filterEmit: Predicate<Item>,
-        filterReference: Predicate<Item>
+    fun generateFromVersionedApis(
+        config: GenerateApiVersionsFromVersionedApisConfig,
     ) {
-        val api = createApiFromSignatureFiles(pastApiVersions)
-        addApisFromCodebase(
-            api,
-            apiVersionNames.size,
-            currentApiVersion,
-            false,
-            filterEmit,
-            filterReference
-        )
-        val printer = ApiJsonPrinter(apiVersionNames)
-        printer.print(api, outputFile)
-    }
-
-    private fun createApiFromAndroidJars(apiLevels: Array<File>, firstApiLevel: Int): Api {
-        val api = Api(firstApiLevel)
-        for (apiLevel in firstApiLevel until apiLevels.size) {
-            val jar = apiLevels[apiLevel]
-            api.readAndroidJar(apiLevel, jar)
-        }
-        return api
+        val api = createApiFromVersionedApis(config.versionedApis)
+        api.clean()
+        createApiLevelsFile(config.outputFile, config.printer, api)
     }
 
     /**
@@ -150,24 +134,22 @@ class ApiGenerator(private val signatureFileCache: SignatureFileCache) {
      * which is what non-finalized APIs use.
      *
      * @param api the api to modify
-     * @param apiLevelNotInAndroidSdk fallback API level for APIs not in the Android SDK
+     * @param versionNotInAndroidSdk fallback API level for APIs not in the Android SDK
      * @param sdkJarRoot path to directory containing extension SDK jars (usually
      *   $ANDROID_ROOT/prebuilts/sdk/extensions)
-     * @param filterPath: path to the filter file. @see ApiToExtensionsMap
+     * @param filterPath path to the filter file. @see ApiToExtensionsMap
      * @throws IOException if the filter file can not be read
      * @throws IllegalArgumentException if an error is detected in the filter file, or if no jar
      *   files were found
      */
-    @Throws(IOException::class, IllegalArgumentException::class)
     private fun processExtensionSdkApis(
         api: Api,
-        apiLevelNotInAndroidSdk: Int,
+        versionNotInAndroidSdk: ApiVersion,
         sdkJarRoot: File,
         filterPath: File,
-        skipVersionsGreaterThan: Int?
-    ): Set<SdkIdentifier> {
+    ): AvailableSdkExtensions {
         val rules = filterPath.readText()
-        val map = findExtensionSdkJarFiles(sdkJarRoot, skipVersionsGreaterThan)
+        val map = findExtensionSdkJarFiles(sdkJarRoot)
         require(map.isNotEmpty()) { "no extension sdk jar files found in $sdkJarRoot" }
         val moduleMaps: MutableMap<String, ApiToExtensionsMap> = HashMap()
         for ((mainlineModule, value) in map) {
@@ -175,60 +157,57 @@ class ApiGenerator(private val signatureFileCache: SignatureFileCache) {
             if (moduleMap.isEmpty())
                 continue // TODO(b/259115852): remove this (though it is an optimization too).
             moduleMaps[mainlineModule] = moduleMap
-            for ((version, path) in value) {
-                api.readExtensionJar(version, mainlineModule, path, apiLevelNotInAndroidSdk)
+            for ((level, path) in value) {
+                val extVersion = ExtVersion.fromLevel(level)
+                api.readExtensionJar(extVersion, mainlineModule, path, versionNotInAndroidSdk)
             }
         }
         for (clazz in api.classes) {
             val module = clazz.mainlineModule ?: continue
-            val extensionsMap = moduleMaps[module]
-            var sdks =
-                extensionsMap!!.calculateSdksAttr(
+            val extensionsMap = moduleMaps[module]!!
+
+            /** Update the sdks on each [ApiElement] in [elements]. */
+            fun updateSdks(elements: Collection<ApiElement>) {
+                for (element in elements) {
+                    val sdks =
+                        extensionsMap.calculateSdksAttr(
+                            element.since,
+                            versionNotInAndroidSdk,
+                            extensionsMap.getExtensions(clazz, element),
+                            element.sinceExtension
+                        )
+                    element.updateSdks(sdks)
+                }
+            }
+
+            val sdks =
+                extensionsMap.calculateSdksAttr(
                     clazz.since,
-                    apiLevelNotInAndroidSdk,
+                    versionNotInAndroidSdk,
                     extensionsMap.getExtensions(clazz),
                     clazz.sinceExtension
                 )
             clazz.updateSdks(sdks)
-            var iter = clazz.fieldIterator
-            while (iter.hasNext()) {
-                val field = iter.next()
-                sdks =
-                    extensionsMap.calculateSdksAttr(
-                        field.since,
-                        apiLevelNotInAndroidSdk,
-                        extensionsMap.getExtensions(clazz, field),
-                        field.sinceExtension
-                    )
-                field.updateSdks(sdks)
-            }
-            iter = clazz.methodIterator
-            while (iter.hasNext()) {
-                val method = iter.next()
-                sdks =
-                    extensionsMap.calculateSdksAttr(
-                        method.since,
-                        apiLevelNotInAndroidSdk,
-                        extensionsMap.getExtensions(clazz, method),
-                        method.sinceExtension
-                    )
-                method.updateSdks(sdks)
-            }
+
+            updateSdks(clazz.superClasses)
+            updateSdks(clazz.interfaces)
+            updateSdks(clazz.fields)
+            updateSdks(clazz.methods)
         }
-        return fromXml("", rules).getSdkIdentifiers()
+        return fromXml("", rules).availableSdkExtensions
     }
 
     /**
-     * Creates the simplified diff-based API level.
+     * Creates a file containing the [api].
      *
      * @param outFile the output file
+     * @param printer the [ApiPrinter] to use to write the file.
      * @param api the api to write
-     * @param sdkIdentifiers SDKs referenced by the api
      */
-    private fun createApiLevelsXml(
+    private fun createApiLevelsFile(
         outFile: File,
+        printer: ApiPrinter,
         api: Api,
-        sdkIdentifiers: Set<SdkIdentifier>
     ): Boolean {
         val parentFile = outFile.parentFile
         if (!parentFile.exists()) {
@@ -239,10 +218,7 @@ class ApiGenerator(private val signatureFileCache: SignatureFileCache) {
             }
         }
         try {
-            PrintStream(outFile, StandardCharsets.UTF_8).use { stream ->
-                stream.println("<?xml version=\"1.0\" encoding=\"utf-8\"?>")
-                api.print(stream, sdkIdentifiers)
-            }
+            outFile.printWriter().use { writer -> printer.print(api, writer) }
         } catch (e: Exception) {
             e.printStackTrace()
             return false
@@ -253,6 +229,5 @@ class ApiGenerator(private val signatureFileCache: SignatureFileCache) {
     data class SdkExtensionsArguments(
         var sdkExtJarRoot: File,
         var sdkExtInfoFile: File,
-        var skipVersionsGreaterThan: Int?
     )
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiJsonPrinter.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiJsonPrinter.kt
index e9d78b3a4..5190cba38 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiJsonPrinter.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiJsonPrinter.kt
@@ -17,23 +17,18 @@
 package com.android.tools.metalava.apilevels
 
 import com.google.gson.GsonBuilder
-import java.io.File
-import java.io.PrintStream
+import java.io.PrintWriter
 
-/**
- * Handles converting an [Api] to a JSON version history file.
- *
- * @param apiVersionNames The names of the API versions, ordered starting from version 1.
- */
-internal class ApiJsonPrinter(private val apiVersionNames: List<String>) {
-    /** Writes the [api] as JSON to the [outputFile] */
-    fun print(api: Api, outputFile: File) {
+/** Handles converting an [Api] to a JSON version history file. */
+internal class ApiJsonPrinter : ApiPrinter {
+    override fun print(api: Api, writer: PrintWriter) {
         val gson = GsonBuilder().disableHtmlEscaping().create()
         val json = api.toJson()
-        val printStream = PrintStream(outputFile)
-        gson.toJson(json, printStream)
+        gson.toJson(json, writer)
     }
 
+    override fun toString() = "JSON"
+
     private fun Api.toJson() = classes.map { it.toJson() }
 
     private fun ApiClass.toJson() =
@@ -46,15 +41,7 @@ internal class ApiJsonPrinter(private val apiVersionNames: List<String>) {
     private fun ApiElement.toJson(elementType: String) =
         mapOf(
             elementType to name,
-            "addedIn" to nameForVersion(since),
-            "deprecatedIn" to
-                if (isDeprecated) {
-                    nameForVersion(deprecatedIn)
-                } else {
-                    null
-                }
+            "addedIn" to since.toString(),
+            "deprecatedIn" to deprecatedIn?.toString(),
         )
-
-    // Indexing is offset by 1 because 0 is not a valid API level
-    private fun nameForVersion(level: Int) = apiVersionNames[level - 1]
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiPrinter.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiPrinter.kt
new file mode 100644
index 000000000..49c0eab7b
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiPrinter.kt
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.apilevels
+
+import java.io.PrintWriter
+
+/** Prints [Api] instances. */
+interface ApiPrinter {
+    /** Writes the [api] to [writer]. */
+    fun print(api: Api, writer: PrintWriter)
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiToExtensionsMap.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiToExtensionsMap.kt
index aa04f221d..c5aad595e 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiToExtensionsMap.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiToExtensionsMap.kt
@@ -15,21 +15,11 @@
  */
 package com.android.tools.metalava.apilevels
 
-import com.android.tools.metalava.SdkIdentifier
+import com.android.tools.metalava.SdkExtension
 import javax.xml.parsers.SAXParserFactory
 import org.xml.sax.Attributes
 import org.xml.sax.helpers.DefaultHandler
 
-/**
- * The base of dessert release independent SDKs.
- *
- * A dessert release independent SDK is one which is not coupled to the Android dessert release
- * numbering. Any SDK greater than or equal to this is not comparable to either each other, or to
- * the Android dessert release. e.g. `1000000` is not the same as, later than, or earlier than
- * SDK 31. Similarly, `1000001` is not the same as, later than, or earlier then `1000000`.
- */
-private const val DESSERT_RELEASE_INDEPENDENT_SDK_BASE = 1000000
-
 /**
  * A filter of classes, fields and methods that are allowed in and extension SDK, and for each item,
  * what extension SDK it first appeared in. Also, a mapping between SDK name and numerical ID.
@@ -37,17 +27,21 @@ private const val DESSERT_RELEASE_INDEPENDENT_SDK_BASE = 1000000
  * Internally, the filters are represented as a tree, where each node in the tree matches a part of
  * a package, class or member name. For example, given the patterns
  *
+ * ```
  * com.example.Foo -> [A] com.example.Foo#someMethod -> [B] com.example.Bar -> [A, C]
+ * ```
  *
  * (anything prefixed with com.example.Foo is allowed and part of the A extension, except for
  * com.example.Foo#someMethod which is part of B; anything prefixed with com.example.Bar is part of
  * both A and C), the internal tree looks like
  *
+ * ```
  * root -> null com -> null example -> null Foo -> [A] someMethod -> [B] Bar -> [A, C]
+ * ```
  */
 class ApiToExtensionsMap
 private constructor(
-    private val sdkIdentifiers: Set<SdkIdentifier>,
+    val availableSdkExtensions: AvailableSdkExtensions,
     private val root: Node,
 ) {
     fun isEmpty(): Boolean = root.children.isEmpty() && root.extensions.isEmpty()
@@ -81,8 +75,6 @@ private constructor(
         return lastSeenExtensions
     }
 
-    fun getSdkIdentifiers(): Set<SdkIdentifier> = sdkIdentifiers.toSet()
-
     /**
      * Construct a `sdks` attribute value
      *
@@ -92,7 +84,9 @@ private constructor(
      *
      * The format of `sdks` is
      *
+     * ```
      * sdks="ext:version[,ext:version[,...]]
+     * ```
      *
      * where <ext> is the numerical ID of the SDK, and <version> is the version in which the API was
      * introduced.
@@ -109,34 +103,33 @@ private constructor(
      *   notFinalizedValue if this symbol has not been finalized in an Android dessert
      * @param notFinalizedValue value used together with the Android SDK ID to indicate that this
      *   symbol has not been finalized at all
-     * @param extensions names of the SDK extensions in which this symbol has been finalized (may be
-     *   non-empty even if extensionsSince is ApiElement.NEVER)
+     * @param shortExtensionNames short names of the SDK extensions in which this symbol has been
+     *   finalized; may be non-empty even if extensionsSince is `null`.
      * @param extensionsSince the version of the SDK extensions in which this API was initially
-     *   introduced (same value for all SDK extensions), or ApiElement.NEVER if this symbol has not
-     *   been finalized in any SDK extension (regardless of the extensions argument)
+     *   introduced (same value for all SDK extensions), or `null` if this symbol has not been
+     *   finalized in any SDK extension (regardless of the [shortExtensionNames] argument)
      * @return an `sdks` value suitable for including verbatim in XML
      */
     fun calculateSdksAttr(
-        androidSince: Int,
-        notFinalizedValue: Int,
-        extensions: List<String>,
-        extensionsSince: Int
+        androidSince: ApiVersion,
+        notFinalizedValue: ApiVersion,
+        shortExtensionNames: List<String>,
+        extensionsSince: ExtVersion?,
     ): String {
         // Special case: symbol not finalized anywhere -> "ANDROID_SDK:next_dessert_int"
-        if (androidSince == notFinalizedValue && extensionsSince == ApiElement.NEVER) {
+        if (androidSince == notFinalizedValue && extensionsSince == null) {
             return "$ANDROID_PLATFORM_SDK_ID:$notFinalizedValue"
         }
 
         val versions = mutableSetOf<String>()
-        // Only include SDK extensions if the symbol has been finalized in at least one
-        if (extensionsSince != ApiElement.NEVER) {
-            for (ext in extensions) {
-                val ident =
-                    sdkIdentifiers.find { it.shortname == ext }
-                        ?: throw IllegalStateException("unknown extension SDK \"$ext\"")
-                assert(ident.id != ANDROID_PLATFORM_SDK_ID) // invariant
-                if (ident.id >= DESSERT_RELEASE_INDEPENDENT_SDK_BASE || ident.id <= androidSince) {
-                    versions.add("${ident.id}:$extensionsSince")
+        // Only include SDK extensions if the symbol has been finalized in at least one extension.
+        if (extensionsSince != null) {
+            for (shortExtensionName in shortExtensionNames) {
+                val sdkExtension = availableSdkExtensions.retrieveSdkExtension(shortExtensionName)
+                // Only add the extension version in which a symbol was added for those SDK
+                // extensions that supersede the Android SDK version.
+                if (sdkExtension.supersedesAndroidSdkVersion(androidSince)) {
+                    versions.add("${sdkExtension.id}:$extensionsSince")
                 }
             }
         }
@@ -196,7 +189,7 @@ private constructor(
          */
         fun fromXml(filterByJar: String, xml: String): ApiToExtensionsMap {
             val root = Node("<root>")
-            val sdkIdentifiers = mutableSetOf<SdkIdentifier>()
+            val sdkExtensions = mutableSetOf<SdkExtension>()
             val allSeenExtensions = mutableSetOf<String>()
 
             val parser = SAXParserFactory.newDefaultInstance().newSAXParser()
@@ -218,8 +211,13 @@ private constructor(
                                     val name = attributes.getStringOrThrow(qualifiedName, "name")
                                     val reference =
                                         attributes.getStringOrThrow(qualifiedName, "reference")
-                                    sdkIdentifiers.add(
-                                        SdkIdentifier(id, shortname, name, reference)
+                                    sdkExtensions.add(
+                                        SdkExtension.fromXmlAttributes(
+                                            id,
+                                            shortname,
+                                            name,
+                                            reference,
+                                        )
                                     )
                                 }
                                 "symbol" -> {
@@ -266,42 +264,16 @@ private constructor(
                 throw IllegalArgumentException("failed to parse xml", e)
             }
 
-            // verify: the predefined Android platform SDK ID is not reused as an extension SDK ID
-            if (sdkIdentifiers.any { it.id == ANDROID_PLATFORM_SDK_ID }) {
-                throw IllegalArgumentException(
-                    "bad SDK definition: the ID $ANDROID_PLATFORM_SDK_ID is reserved for the Android platform SDK"
-                )
-            }
+            val availableSdkExtensions = AvailableSdkExtensions(sdkExtensions)
 
             // verify: all rules refer to declared SDKs
-            val allSdkNames = sdkIdentifiers.map { it.shortname }.toList()
             for (ext in allSeenExtensions) {
-                if (!allSdkNames.contains(ext)) {
+                if (!availableSdkExtensions.containsSdkExtension(ext)) {
                     throw IllegalArgumentException("bad SDK definitions: undefined SDK $ext")
                 }
             }
 
-            // verify: no duplicate SDK IDs
-            if (sdkIdentifiers.size != sdkIdentifiers.distinctBy { it.id }.size) {
-                throw IllegalArgumentException("bad SDK definitions: duplicate SDK IDs")
-            }
-
-            // verify: no duplicate SDK names
-            if (sdkIdentifiers.size != sdkIdentifiers.distinctBy { it.shortname }.size) {
-                throw IllegalArgumentException("bad SDK definitions: duplicate SDK short names")
-            }
-
-            // verify: no duplicate SDK names
-            if (sdkIdentifiers.size != sdkIdentifiers.distinctBy { it.name }.size) {
-                throw IllegalArgumentException("bad SDK definitions: duplicate SDK names")
-            }
-
-            // verify: no duplicate SDK references
-            if (sdkIdentifiers.size != sdkIdentifiers.distinctBy { it.reference }.size) {
-                throw IllegalArgumentException("bad SDK definitions: duplicate SDK references")
-            }
-
-            return ApiToExtensionsMap(sdkIdentifiers, root)
+            return ApiToExtensionsMap(availableSdkExtensions, root)
         }
     }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiVersion.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiVersion.kt
new file mode 100644
index 000000000..e079d2029
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiVersion.kt
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.apilevels
+
+import com.android.tools.metalava.apilevels.ApiVersion.Companion.toString
+import java.util.regex.Pattern
+
+/** Version of an SDK, e.g. Android or AndroidX. */
+data class ApiVersion
+internal constructor(
+    /** The major version. */
+    private val major: Int,
+
+    /**
+     * The optional minor version.
+     *
+     * If it is `null` then neither it nor [patch] or [preReleaseQuality] are included in
+     * [toString]. If it is not `null` then it must be greater than or equal to 0.
+     */
+    private val minor: Int? = null,
+
+    /**
+     * The optional patch version.
+     *
+     * This must only be specified if [minor] is also specified.
+     *
+     * If it is `null` then neither it nor [preReleaseQuality] are included in [toString]. If it is
+     * not `null` then it must be greater than or equal to 0.
+     */
+    private val patch: Int? = null,
+
+    /**
+     * The pre-release quality.
+     *
+     * This must only be specified if [patch] is also specified.
+     *
+     * If it is null then the version is assumed to have been released, and this is not included in
+     * [toString]. Otherwise, the version has not been released and this is included at the end of
+     * [toString], separated from [patch] by `-`.
+     *
+     * Any string is acceptable, but they must adhere to the rule that when the strings are sorted
+     * alphanumerically they appear in order from the lowest quality to the highest quality.
+     */
+    private val preReleaseQuality: String? = null,
+) : Comparable<ApiVersion> {
+
+    // Check constraints.
+    init {
+        require(major >= 0) { "major must be greater than or equal to 0 but was $major" }
+
+        if (minor != null) {
+            require(minor >= 0) { "minor must be greater than or equal to 0 but was $minor" }
+        }
+
+        if (patch != null) {
+            require(minor != null) { "patch ($patch) was specified without also specifying minor" }
+
+            require(patch >= 0) { "patch must be greater than or equal to 0 but was $patch" }
+        }
+
+        if (preReleaseQuality != null) {
+            require(patch != null) {
+                "preReleaseQuality ($preReleaseQuality) was specified without also specifying patch"
+            }
+        }
+    }
+
+    /**
+     * Make sure that this is a valid version.
+     *
+     * A version of "0" is not valid as historically API levels started from 1. However, it is valid
+     * to have a [major] version of "0" as long as a [minor] version has also been provided, e.g.
+     * "0.0" is valid.
+     */
+    val isValid
+        get() = major > 0 || minor != null
+
+    private val text = buildString {
+        append(major)
+        if (minor != null) {
+            append('.')
+            append(minor)
+            if (patch != null) {
+                append('.')
+                append(patch)
+                if (preReleaseQuality != null) {
+                    append('-')
+                    append(preReleaseQuality)
+                }
+            }
+        }
+    }
+
+    override operator fun compareTo(other: ApiVersion) =
+        compareValuesBy(
+            this,
+            other,
+            { it.major },
+            { it.minor },
+            { it.patch },
+            { it.preReleaseQuality == null }, // False (released) sorts above true (pre-release)
+            {
+                it.preReleaseQuality
+            } // Pre-release quality names are in alphabetical order from lower quality to higher
+            // quality.
+        )
+
+    operator fun plus(increment: Int) =
+        ApiVersion(major + increment, minor, patch, preReleaseQuality)
+
+    override fun toString() = text
+
+    companion object {
+        /** Get the [ApiVersion] for [level], which must be greater than 0. */
+        fun fromLevel(level: Int) =
+            if (level > 0) ApiVersion(level)
+            else error("level must be greater than 0 but was $level")
+
+        /** Pattern for acceptable input to [fromString]. */
+        private val VERSION_REGEX = Pattern.compile("""^(\d+)(\.(\d+)(\.(\d+)(-(.+))?)?)?$""")
+
+        /** Index of `major` group in [VERSION_REGEX]. */
+        private const val MAJOR_GROUP = 1
+
+        /** Index of `minor` group in [VERSION_REGEX]. */
+        private const val MINOR_GROUP = 3
+
+        /** Index of `patch` group in [VERSION_REGEX]. */
+        private const val PATCH_GROUP = 5
+
+        /** Index of `pre-release-quality` group in [VERSION_REGEX]. */
+        private const val QUALITY_GROUP = 7
+
+        /**
+         * Get the [ApiVersion] for [text], which must be match
+         * `major(.minor(.patch(-quality)?)?)?`.
+         *
+         * Where `major`, `minor` and `patch` are all non-negative integers and `quality` is a
+         * string chosen such that qualities sort lexicographically from the lowest quality to the
+         * highest quality, e.g. `alpha`, `beta`, `rc` and not `good`, `bad`, `worse`.
+         */
+        fun fromString(text: String): ApiVersion {
+            val matcher = VERSION_REGEX.matcher(text)
+            if (!matcher.matches()) {
+                error("Can not parse version: $text")
+            }
+
+            val major = matcher.group(MAJOR_GROUP).toInt()
+            val minor = matcher.group(MINOR_GROUP)?.toInt()
+            val patch = matcher.group(PATCH_GROUP)?.toInt()
+            val quality = matcher.group(QUALITY_GROUP)
+
+            return ApiVersion(major, minor, patch, quality)
+        }
+
+        /**
+         * The lowest [ApiVersion], used as the default value when higher versions override lower
+         * ones.
+         */
+        val LOWEST = ApiVersion(0)
+
+        /**
+         * The highest [ApiVersion], used as the default value when lower versions override higher
+         * ones.
+         */
+        val HIGHEST = ApiVersion(Int.MAX_VALUE)
+    }
+}
+
+/** Version of an SDK extension. */
+@JvmInline
+value class ExtVersion internal constructor(val level: Int) : Comparable<ExtVersion> {
+    /** Make sure that this is a valid version. */
+    val isValid
+        get() = level > 0
+
+    override fun toString() = level.toString()
+
+    override operator fun compareTo(other: ExtVersion) = level.compareTo(other.level)
+
+    companion object {
+        /** Get the [ExtVersion] for [level], which must be greater than 0. */
+        fun fromLevel(level: Int) =
+            if (level > 0) ExtVersion(level)
+            else error("level must be greater than 0 but was $level")
+    }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiXmlPrinter.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiXmlPrinter.kt
new file mode 100644
index 000000000..4905dbd5e
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/ApiXmlPrinter.kt
@@ -0,0 +1,235 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.apilevels
+
+import java.io.PrintWriter
+
+/**
+ * Printer that will write an XML representation of an [Api] instance.
+ *
+ * @param availableSdkExtensions the optional set of [AvailableSdkExtensions].
+ * @param firstApiLevel the first API level which the file contains, used to populate the `<api
+ *   min="..."...>` attribute.
+ * @param allVersions the list of all the versions in order, from earliest to latest.
+ */
+class ApiXmlPrinter(
+    private val availableSdkExtensions: AvailableSdkExtensions?,
+    private val firstApiLevel: Int,
+    allVersions: List<ApiVersion>,
+) : ApiPrinter {
+    /**
+     * Map from version to the next version. This is used to compute the version in which an API
+     * element was removed by finding the version after the version it was last present in.
+     */
+    private val versionToNext = allVersions.zipWithNext().toMap()
+
+    override fun print(api: Api, writer: PrintWriter) {
+        writer.println("<?xml version=\"1.0\" encoding=\"utf-8\"?>")
+        api.print(writer, availableSdkExtensions)
+    }
+
+    override fun toString() = "XML"
+
+    /**
+     * Prints the whole API definition to a writer.
+     *
+     * @param writer the writer to which the XML elements will be written.
+     */
+    private fun Api.print(writer: PrintWriter, availableSdkExtensions: AvailableSdkExtensions?) {
+        writer.print("<api version=\"3\"")
+        if (firstApiLevel > 1) {
+            writer.print(" min=\"$firstApiLevel\"")
+        }
+        writer.println(">")
+        if (availableSdkExtensions != null) {
+            for (sdkExtension in availableSdkExtensions.sdkExtensions) {
+                writer.println(
+                    String.format(
+                        "\t<sdk id=\"%d\" shortname=\"%s\" name=\"%s\" reference=\"%s\"/>",
+                        sdkExtension.id,
+                        sdkExtension.shortname,
+                        sdkExtension.name,
+                        sdkExtension.reference,
+                    )
+                )
+            }
+        }
+        print(classes, "class", "\t", writer)
+        printClosingTag("api", "", writer)
+    }
+
+    /**
+     * Prints homogeneous XML elements to a writer. Each element is printed on a separate line.
+     * Attributes with values matching the parent API element are omitted.
+     *
+     * @param elements the elements to print
+     * @param tag the tag of the XML elements
+     * @param indent the whitespace prefix to insert before each XML element
+     * @param writer the writer to which the XML elements will be written.
+     */
+    private fun ParentApiElement.print(
+        elements: Collection<ApiElement>,
+        tag: String?,
+        indent: String,
+        writer: PrintWriter,
+    ) {
+        for (element in elements.sorted()) {
+            element.print(tag, this, indent, writer)
+        }
+    }
+
+    /**
+     * Prints an XML representation of the element to a writer terminated by a line break.
+     * Attributes with values matching the parent API element are omitted.
+     *
+     * @param tag the tag of the XML element
+     * @param parentApiElement the parent API element
+     * @param indent the whitespace prefix to insert before the XML element
+     * @param writer the writer to which the XML element will be written.
+     */
+    private fun ApiElement.print(
+        tag: String?,
+        parentApiElement: ParentApiElement,
+        indent: String,
+        writer: PrintWriter
+    ) {
+        if (this is ApiClass) printClass(tag, parentApiElement, indent, writer)
+        else print(tag, true, parentApiElement, indent, writer)
+    }
+
+    private fun ApiClass.printClass(
+        tag: String?,
+        parentApiElement: ParentApiElement,
+        indent: String,
+        writer: PrintWriter
+    ) {
+        if (alwaysHidden) {
+            return
+        }
+        print(tag, false, parentApiElement, indent, writer)
+        val innerIndent = indent + '\t'
+        print(superClasses, "extends", innerIndent, writer)
+        print(interfaces, "implements", innerIndent, writer)
+        print(methods, "method", innerIndent, writer)
+        print(fields, "field", innerIndent, writer)
+        printClosingTag(tag, indent, writer)
+    }
+
+    /**
+     * Prints an XML representation of the element to a writer terminated by a line break.
+     * Attributes with values matching the parent API element are omitted.
+     *
+     * @param tag the tag of the XML element
+     * @param closeTag if true the XML element is terminated by "/>", otherwise the closing tag of
+     *   the element is not printed
+     * @param parentApiElement the parent API element
+     * @param indent the whitespace prefix to insert before the XML element
+     * @param writer the writer to which the XML element will be written.
+     * @see printClosingTag
+     */
+    private fun ApiElement.print(
+        tag: String?,
+        closeTag: Boolean,
+        parentApiElement: ParentApiElement,
+        indent: String?,
+        writer: PrintWriter
+    ) {
+        writer.print(indent)
+        writer.print('<')
+        writer.print(tag)
+        writer.print(" name=\"")
+        writer.print(encodeAttribute(name))
+        if (!isEmpty(mainlineModule) && !isEmpty(sdks)) {
+            writer.print("\" module=\"")
+            writer.print(encodeAttribute(mainlineModule!!))
+        }
+        if (since > parentApiElement.since) {
+            writer.print("\" since=\"")
+            writer.print(since)
+        }
+        if (!isEmpty(sdks) && sdks != parentApiElement.sdks) {
+            writer.print("\" sdks=\"")
+            writer.print(sdks)
+        }
+        if (deprecatedIn != null && deprecatedIn != parentApiElement.deprecatedIn) {
+            writer.print("\" deprecated=\"")
+            writer.print(deprecatedIn)
+        }
+        if (lastPresentIn < parentApiElement.lastPresentIn) {
+            val removedFrom =
+                versionToNext[lastPresentIn]
+                    ?: error("could not find next version for $lastPresentIn")
+            writer.print("\" removed=\"")
+            writer.print(removedFrom)
+        }
+        writer.print('"')
+        if (closeTag) {
+            writer.print('/')
+        }
+        writer.println('>')
+    }
+
+    companion object {
+        /**
+         * Prints a closing tag of an XML element terminated by a line break.
+         *
+         * @param tag the tag of the element
+         * @param indent the whitespace prefix to insert before the closing tag
+         * @param writer the writer to which the XML element will be written.
+         */
+        private fun printClosingTag(tag: String?, indent: String?, writer: PrintWriter) {
+            writer.print(indent)
+            writer.print("</")
+            writer.print(tag)
+            writer.println('>')
+        }
+
+        private fun encodeAttribute(attribute: String): String {
+            return buildString {
+                val n = attribute.length
+                // &, ", ' and < are illegal in attributes; see
+                // http://www.w3.org/TR/REC-xml/#NT-AttValue
+                // (' legal in a " string and " is legal in a ' string but here we'll stay on the
+                // safe
+                // side).
+                for (i in 0 until n) {
+                    when (val c = attribute[i]) {
+                        '"' -> {
+                            append("&quot;") // $NON-NLS-1$
+                        }
+                        '<' -> {
+                            append("&lt;") // $NON-NLS-1$
+                        }
+                        '\'' -> {
+                            append("&apos;") // $NON-NLS-1$
+                        }
+                        '&' -> {
+                            append("&amp;") // $NON-NLS-1$
+                        }
+                        else -> {
+                            append(c)
+                        }
+                    }
+                }
+            }
+        }
+
+        private fun isEmpty(s: String?): Boolean {
+            return s.isNullOrEmpty()
+        }
+    }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/AvailableSdkExtensions.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/AvailableSdkExtensions.kt
new file mode 100644
index 000000000..fbc88d4c1
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/AvailableSdkExtensions.kt
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.apilevels
+
+import com.android.tools.metalava.SdkExtension
+import com.android.tools.metalava.apilevels.ApiToExtensionsMap.Companion.ANDROID_PLATFORM_SDK_ID
+
+/** The set of available SDK extensions. */
+class AvailableSdkExtensions(internal val sdkExtensions: Set<SdkExtension>) {
+
+    init {
+        // verify: the predefined Android platform SDK ID is not reused as an extension SDK ID
+        if (sdkExtensions.any { it.id == ANDROID_PLATFORM_SDK_ID }) {
+            throw IllegalArgumentException(
+                "bad SDK definition: the ID $ANDROID_PLATFORM_SDK_ID is reserved for the Android platform SDK"
+            )
+        }
+
+        // verify: no duplicate SDK IDs
+        if (sdkExtensions.size != sdkExtensions.distinctBy { it.id }.size) {
+            throw IllegalArgumentException("bad SDK definitions: duplicate SDK IDs")
+        }
+
+        // verify: no duplicate SDK names
+        if (sdkExtensions.size != sdkExtensions.distinctBy { it.shortname }.size) {
+            throw IllegalArgumentException("bad SDK definitions: duplicate SDK short names")
+        }
+
+        // verify: no duplicate SDK names
+        if (sdkExtensions.size != sdkExtensions.distinctBy { it.name }.size) {
+            throw IllegalArgumentException("bad SDK definitions: duplicate SDK names")
+        }
+
+        // verify: no duplicate SDK references
+        if (sdkExtensions.size != sdkExtensions.distinctBy { it.reference }.size) {
+            throw IllegalArgumentException("bad SDK definitions: duplicate SDK references")
+        }
+    }
+
+    private val shortToSdkExtension = sdkExtensions.associateBy { it.shortname }
+
+    /** Check to see if this contains an SDK extension with [shortExtensionName]. */
+    fun containsSdkExtension(shortExtensionName: String) = shortExtensionName in shortToSdkExtension
+
+    /**
+     * Retrieve the SDK extension appropriate for the [shortExtensionName], throwing an exception if
+     * it could not be found.
+     */
+    fun retrieveSdkExtension(shortExtensionName: String): SdkExtension {
+        return shortToSdkExtension[shortExtensionName]
+            ?: throw IllegalStateException("unknown extension SDK \"$shortExtensionName\"")
+    }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/ExtensionSdkJarReader.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/ExtensionSdkJarReader.kt
index fa6a8eff9..88a06c56d 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/ExtensionSdkJarReader.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/ExtensionSdkJarReader.kt
@@ -19,7 +19,7 @@ import com.android.SdkConstants
 import com.android.SdkConstants.PLATFORM_WINDOWS
 import java.io.File
 
-class ExtensionSdkJarReader() {
+class ExtensionSdkJarReader {
 
     companion object {
         private val REGEX_JAR_PATH = run {
@@ -36,10 +36,7 @@ class ExtensionSdkJarReader() {
          * @return a mapping SDK jar file -> list of VersionAndPath objects, sorted from earliest to
          *   last version
          */
-        fun findExtensionSdkJarFiles(
-            root: File,
-            skipVersionsGreaterThan: Int?
-        ): Map<String, List<VersionAndPath>> {
+        fun findExtensionSdkJarFiles(root: File): Map<String, List<VersionAndPath>> {
             val map = mutableMapOf<String, MutableList<VersionAndPath>>()
             root
                 .walk()
@@ -49,13 +46,6 @@ class ExtensionSdkJarReader() {
                         Triple(groups[2]!!.value, groups[1]!!.value.toInt(), file)
                     }
                 }
-                .filter {
-                    if (skipVersionsGreaterThan != null) {
-                        it.second <= skipVersionsGreaterThan
-                    } else {
-                        true
-                    }
-                }
                 .sortedBy { it.second }
                 .forEach {
                     map.getOrPut(it.first) { mutableListOf() }
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/GenerateApiVersionsFromVersionedApisConfig.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/GenerateApiVersionsFromVersionedApisConfig.kt
new file mode 100644
index 000000000..86074b0cb
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/GenerateApiVersionsFromVersionedApisConfig.kt
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.apilevels
+
+import java.io.File
+
+/**
+ * Properties for the [ApiGenerator.generateFromVersionedApis] method that come from command line
+ * options.
+ */
+data class GenerateApiVersionsFromVersionedApisConfig(
+    /** A list of versioned APIs, ordered from the oldest API version to newest. */
+    val versionedApis: List<VersionedApi>,
+
+    /** The api versions file that will be generated. */
+    val outputFile: File,
+
+    /** The [ApiPrinter] to use to write the API versions to [outputFile]. */
+    val printer: ApiPrinter,
+)
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/GenerateXmlConfig.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/GenerateXmlConfig.kt
new file mode 100644
index 000000000..736fb5044
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/GenerateXmlConfig.kt
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.apilevels
+
+import com.android.tools.metalava.apilevels.ApiGenerator.SdkExtensionsArguments
+import java.io.File
+
+/** Properties for the [ApiGenerator.generateXml] method that come from comment line options. */
+data class GenerateXmlConfig(
+    /**
+     * The list of jar files from which the API levels file will be populated. One for each API
+     * level, indexed by API level, starting from 1. The 0th element plus any element less than
+     * [firstApiLevel] is a placeholder that is an invalid file and should not be used.
+     */
+    val apiLevels: List<File>,
+
+    /** The first API level to include the API levels file. */
+    val firstApiLevel: Int,
+
+    /**
+     * The current version.
+     *
+     * If there is no corresponding element in [apiLevels] for this then the API defined in the
+     * sources will be added to the API levels file for this API level unless
+     * [isDeveloperPreviewBuild] is `true`.
+     */
+    val currentSdkVersion: ApiVersion,
+
+    /**
+     * True if the [currentSdkVersion] level is for a developer preview build.
+     *
+     * If this is `true` then the API defined in the sources will be added to the API levels file
+     * with an API level of [currentSdkVersion]` - 1`.
+     */
+    val isDeveloperPreviewBuild: Boolean,
+
+    /** The API levels file that will be generated. */
+    val outputFile: File,
+
+    /**
+     * Optional SDK extensions arguments.
+     *
+     * If provided then SDK extension information will be included in the API levels file.
+     */
+    val sdkExtensionsArguments: SdkExtensionsArguments?,
+
+    /**
+     * If `true` then any references to undefined classes will be removed from super class and
+     * interface lists; otherwise any such references will be treated as an error.
+     *
+     * An undefined class is one that is not defined within any of the API versions loaded.
+     */
+    val removeMissingClasses: Boolean,
+)
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/JarReaderUtils.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/JarReaderUtils.kt
index 63f0b1595..1f0e35b61 100644
--- a/metalava/src/main/java/com/android/tools/metalava/apilevels/JarReaderUtils.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/JarReaderUtils.kt
@@ -25,16 +25,26 @@ import org.objectweb.asm.tree.ClassNode
 import org.objectweb.asm.tree.FieldNode
 import org.objectweb.asm.tree.MethodNode
 
-fun Api.readAndroidJar(apiLevel: Int, jar: File) {
-    update(apiLevel)
-    readJar(apiLevel, jar)
+fun Api.readAndroidJar(sdkVersion: ApiVersion, jar: File) {
+    update(sdkVersion)
+    val updater = ApiElement.Updater.forApiVersion(sdkVersion)
+    readJar(jar, updater)
 }
 
-fun Api.readExtensionJar(extensionVersion: Int, module: String, jar: File, nextApiLevel: Int) {
-    readJar(nextApiLevel, jar, extensionVersion, module)
+fun Api.readExtensionJar(
+    extVersion: ExtVersion,
+    module: String,
+    jar: File,
+    nextSdkVersion: ApiVersion
+) {
+    val updater = ApiElement.Updater.forExtVersion(nextSdkVersion, extVersion, module)
+    readJar(jar, updater)
 }
 
-fun Api.readJar(apiLevel: Int, jar: File, extensionVersion: Int? = null, module: String? = null) {
+private fun Api.readJar(
+    jar: File,
+    updater: ApiElement.Updater,
+) {
     val fis = FileInputStream(jar)
     ZipInputStream(fis).use { zis ->
         var entry = zis.nextEntry
@@ -50,24 +60,22 @@ fun Api.readJar(apiLevel: Int, jar: File, extensionVersion: Int? = null, module:
 
             val classDeprecated = isDeprecated(classNode.access)
             val theClass =
-                addClass(
+                updateClass(
                     classNode.name,
-                    apiLevel,
+                    updater,
                     classDeprecated,
                 )
-            extensionVersion?.let { theClass.updateExtension(extensionVersion) }
-            module?.let { theClass.updateMainlineModule(module) }
 
-            theClass.updateHidden(apiLevel, (classNode.access and Opcodes.ACC_PUBLIC) == 0)
+            theClass.updateHidden((classNode.access and Opcodes.ACC_PUBLIC) == 0)
 
             // super class
             if (classNode.superName != null) {
-                theClass.addSuperClass(classNode.superName, apiLevel)
+                theClass.updateSuperClass(classNode.superName, updater)
             }
 
             // interfaces
             for (interfaceName in classNode.interfaces) {
-                theClass.addInterface(interfaceName, apiLevel)
+                theClass.updateInterface(interfaceName, updater)
             }
 
             // fields
@@ -77,13 +85,11 @@ fun Api.readJar(apiLevel: Int, jar: File, extensionVersion: Int? = null, module:
                     continue
                 }
                 if (!fieldNode.name.startsWith("this\$") && fieldNode.name != "\$VALUES") {
-                    val apiField =
-                        theClass.addField(
-                            fieldNode.name,
-                            apiLevel,
-                            classDeprecated || isDeprecated(fieldNode.access),
-                        )
-                    extensionVersion?.let { apiField.updateExtension(extensionVersion) }
+                    theClass.updateField(
+                        fieldNode.name,
+                        updater,
+                        classDeprecated || isDeprecated(fieldNode.access),
+                    )
                 }
             }
 
@@ -94,13 +100,11 @@ fun Api.readJar(apiLevel: Int, jar: File, extensionVersion: Int? = null, module:
                     continue
                 }
                 if (methodNode.name != "<clinit>") {
-                    val apiMethod =
-                        theClass.addMethod(
-                            methodNode.name + methodNode.desc,
-                            apiLevel,
-                            classDeprecated || isDeprecated(methodNode.access),
-                        )
-                    extensionVersion?.let { apiMethod.updateExtension(extensionVersion) }
+                    theClass.updateMethod(
+                        methodNode.name + methodNode.desc,
+                        updater,
+                        classDeprecated || isDeprecated(methodNode.access),
+                    )
                 }
             }
 
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedApi.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedApi.kt
new file mode 100644
index 000000000..41eb91a80
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedApi.kt
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.apilevels
+
+/**
+ * Represents a specific [ApiVersion] of an API.
+ *
+ * Supports updating [Api] with information from the [apiVersion] of the API that is defined in
+ * * the signature [file].
+ */
+interface VersionedApi {
+    /** Update [api] with information from this version of the API. */
+    fun updateApi(api: Api)
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedJarApi.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedJarApi.kt
new file mode 100644
index 000000000..e4844b442
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedJarApi.kt
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.apilevels
+
+import java.io.File
+
+/**
+ * Supports updating [Api] with information from the [sdkVersion] of the API that is defined in
+ * [jar].
+ */
+class VersionedJarApi(
+    private val jar: File,
+    private val sdkVersion: ApiVersion,
+) : VersionedApi {
+    override fun updateApi(api: Api) {
+        api.readAndroidJar(sdkVersion, jar)
+    }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedSignatureApi.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedSignatureApi.kt
new file mode 100644
index 000000000..e3166a567
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedSignatureApi.kt
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.apilevels
+
+import com.android.tools.metalava.cli.common.SignatureFileLoader
+import com.android.tools.metalava.model.CodebaseFragment
+import com.android.tools.metalava.model.snapshot.NonFilteringDelegatingVisitor
+import com.android.tools.metalava.model.text.SignatureFile
+import java.io.File
+
+/**
+ * Supports updating [Api] with information from the [apiVersion] of the API that is defined in the
+ * signature [file].
+ */
+class VersionedSignatureApi(
+    private val signatureFileLoader: SignatureFileLoader,
+    private val file: File,
+    private val apiVersion: ApiVersion,
+) : VersionedApi {
+    override fun updateApi(api: Api) {
+        val codebase = signatureFileLoader.load(SignatureFile.fromFiles(file))
+        val codebaseFragment = CodebaseFragment.create(codebase, ::NonFilteringDelegatingVisitor)
+        addApisFromCodebase(api, apiVersion, codebaseFragment, false)
+    }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedSourceApi.kt b/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedSourceApi.kt
new file mode 100644
index 000000000..78d3d4977
--- /dev/null
+++ b/metalava/src/main/java/com/android/tools/metalava/apilevels/VersionedSourceApi.kt
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.apilevels
+
+import com.android.tools.metalava.model.CodebaseFragment
+
+/**
+ * Supports updating an [Api] with information from the [apiVersion] of the API that is defined by
+ * the [codebaseFragment] of the sources.
+ */
+class VersionedSourceApi(
+    private val codebaseFragment: CodebaseFragment,
+    private val apiVersion: ApiVersion,
+) : VersionedApi {
+    override fun updateApi(api: Api) {
+        addApisFromCodebase(api, apiVersion, codebaseFragment, useInternalNames = false)
+    }
+}
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/common/MetalavaOptions.kt b/metalava/src/main/java/com/android/tools/metalava/cli/common/MetalavaOptions.kt
index 3a6b17ead..31b0f9072 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/common/MetalavaOptions.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/common/MetalavaOptions.kt
@@ -49,6 +49,11 @@ fun RawArgument.existingFile(): ProcessedArgument<File, File> {
     return fileConversion(::stringToExistingFile)
 }
 
+/** Convert the option to a [File] that represents an existing directory. */
+fun RawOption.existingDir(): NullableOption<File, File> {
+    return fileConversion(::stringToExistingDir)
+}
+
 /** Convert the argument to a [File] that represents an existing directory. */
 fun RawArgument.existingDir(): ProcessedArgument<File, File> {
     return fileConversion(::stringToExistingDir)
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/common/PreviouslyReleasedApi.kt b/metalava/src/main/java/com/android/tools/metalava/cli/common/PreviouslyReleasedApi.kt
index fdcac5895..4afbd1955 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/common/PreviouslyReleasedApi.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/common/PreviouslyReleasedApi.kt
@@ -18,23 +18,26 @@ package com.android.tools.metalava.cli.common
 
 import com.android.SdkConstants
 import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.api.surface.ApiVariantType
 import com.android.tools.metalava.model.text.SignatureFile
 import java.io.File
 
 /** A previously released API. */
 sealed interface PreviouslyReleasedApi {
 
-    /** The set of files defining the previously released API. */
-    val files: List<File>
-
     /** The last signature file, if any, defining the previously released API. */
     val lastSignatureFile: File?
 
     /** Load the files into a list of [Codebase]s. */
-    fun load(
-        jarLoader: (File) -> Codebase,
-        signatureFileLoader: (List<SignatureFile>) -> Codebase,
-    ): Codebase
+    fun load(signatureFileLoader: (List<SignatureFile>) -> Codebase): Codebase
+
+    /**
+     * Combine this with [other] and return the result.
+     *
+     * This simply involves creating another [PreviouslyReleasedApi] that contains all the signature
+     * files from this plus all the signature files from [other].
+     */
+    fun combine(other: PreviouslyReleasedApi): PreviouslyReleasedApi
 
     override fun toString(): String
 
@@ -43,55 +46,31 @@ sealed interface PreviouslyReleasedApi {
          * Create an optional [PreviouslyReleasedApi] instance from the list of [files] passed to
          * the option [optionName].
          *
-         * If [files] is empty then this returns `null`. If [files] contains a mixture of jar and
-         * non-jar files (assumed to be signature files) then it is an error. Otherwise, this will
-         * return a [JarBasedApi] or [SignatureBasedApi] for a list of jar files and a list of
-         * signature files respectively.
+         * If [files] is empty then this returns `null`. If [files] contains any `.jar` files then
+         * it is an error. Otherwise, this will assume all the files are signature files and return
+         * [SignatureBasedApi] that wraps a list of [SignatureFile]s. files.
          */
         internal fun optionalPreviouslyReleasedApi(
             optionName: String,
             files: List<File>,
-            onlyUseLastForCurrentApiSurface: Boolean = true
-        ) =
+            onlyUseLastForMainApiSurface: Boolean = true,
+            apiVariantType: ApiVariantType = ApiVariantType.CORE,
+        ): PreviouslyReleasedApi? =
             if (files.isEmpty()) null
             else {
-                // Partition the files into jar and non-jar files, the latter are assumed to be
-                // signature files.
-                val (jarFiles, signatureFiles) =
-                    files.partition { it.path.endsWith(SdkConstants.DOT_JAR) }
-                when {
-                    jarFiles.isEmpty() ->
-                        SignatureBasedApi.fromFiles(signatureFiles, onlyUseLastForCurrentApiSurface)
-                    signatureFiles.isEmpty() ->
-                        if (jarFiles.size > 1)
-                            throw IllegalStateException(
-                                "$optionName: Cannot have more than one jar file, found: ${jarFiles.joinToString()}"
-                            )
-                        else JarBasedApi(jarFiles[0])
-                    else ->
-                        throw IllegalStateException(
-                            "$optionName: Cannot mix jar files (e.g. ${jarFiles.first()}) and signature files (e.g. ${signatureFiles.first()})"
-                        )
-                }
-            }
-    }
-}
-
-/** A previously released API defined by jar files. */
-data class JarBasedApi(val file: File) : PreviouslyReleasedApi {
-
-    override val files: List<File> = listOf(file)
-
-    /** This does not have any signature files, so it always returns `null`. */
-    override val lastSignatureFile: File? = null
-
-    override fun load(
-        jarLoader: (File) -> Codebase,
-        signatureFileLoader: (List<SignatureFile>) -> Codebase,
-    ) = jarLoader(file)
+                // Extract the jar files, if any.
+                val jarFiles = files.filter { it.path.endsWith(SdkConstants.DOT_JAR) }
+                if (jarFiles.isNotEmpty())
+                    error(
+                        "$optionName: Can no longer check compatibility against jar files like ${jarFiles.joinToString()} please use equivalent signature files"
+                    )
 
-    override fun toString(): String {
-        return file.toString()
+                SignatureBasedApi.fromFiles(
+                    files,
+                    onlyUseLastForMainApiSurface,
+                    apiVariantType,
+                )
+            }
     }
 }
 
@@ -104,15 +83,15 @@ data class JarBasedApi(val file: File) : PreviouslyReleasedApi {
  */
 data class SignatureBasedApi(val signatureFiles: List<SignatureFile>) : PreviouslyReleasedApi {
 
-    override val files: List<File> = signatureFiles.map { it.file }
-
     override val lastSignatureFile = signatureFiles.last().file
 
     override fun load(
-        jarLoader: (File) -> Codebase,
         signatureFileLoader: (List<SignatureFile>) -> Codebase,
     ) = signatureFileLoader(signatureFiles)
 
+    override fun combine(other: PreviouslyReleasedApi) =
+        SignatureBasedApi(signatureFiles + (other as SignatureBasedApi).signatureFiles)
+
     override fun toString(): String {
         return signatureFiles.joinToString(",") { it.file.path }
     }
@@ -120,18 +99,19 @@ data class SignatureBasedApi(val signatureFiles: List<SignatureFile>) : Previous
     companion object {
         fun fromFiles(
             files: List<File>,
-            onlyUseLastForCurrentApiSurface: Boolean = true
+            onlyUseLastForMainApiSurface: Boolean = true,
+            apiVariantType: ApiVariantType = ApiVariantType.CORE,
         ): SignatureBasedApi {
             val lastIndex = files.size - 1
             return SignatureBasedApi(
-                files.mapIndexed { index, file ->
-                    SignatureFile(
-                        file,
-                        // The last file is assumed to be for the current API surface.
-                        forCurrentApiSurface =
-                            !onlyUseLastForCurrentApiSurface || index == lastIndex,
-                    )
-                }
+                SignatureFile.fromFiles(
+                    files,
+                    apiVariantTypeChooser = { apiVariantType },
+                    forMainApiSurfacePredicate = { index, _ ->
+                        // The last file is assumed to be for the main API surface.
+                        !onlyUseLastForMainApiSurface || index == lastIndex
+                    },
+                )
             )
         }
     }
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/common/SignatureFileLoader.kt b/metalava/src/main/java/com/android/tools/metalava/cli/common/SignatureFileLoader.kt
index d5bac08c2..f2bde5637 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/common/SignatureFileLoader.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/common/SignatureFileLoader.kt
@@ -16,7 +16,6 @@
 
 package com.android.tools.metalava.cli.common
 
-import com.android.tools.metalava.model.AnnotationManager
 import com.android.tools.metalava.model.ClassResolver
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.text.ApiFile
@@ -24,31 +23,31 @@ import com.android.tools.metalava.model.text.ApiParseException
 import com.android.tools.metalava.model.text.FileFormat
 import com.android.tools.metalava.model.text.SignatureFile
 
+/** Supports loading [SignatureFile]s into a [Codebase] using an optional [ClassResolver]. */
+interface SignatureFileLoader {
+    /** Load [signatureFiles] into a [Codebase] using the optional [classResolver]. */
+    fun load(signatureFiles: List<SignatureFile>, classResolver: ClassResolver? = null): Codebase
+}
+
 /**
  * Helper object to load signature files and rethrow any [ApiParseException] as a
  * [MetalavaCliException].
  */
-class SignatureFileLoader(
-    private val annotationManager: AnnotationManager,
+class DefaultSignatureFileLoader(
+    private val codebaseConfig: Codebase.Config,
     private val formatForLegacyFiles: FileFormat? = null,
-) {
-    fun load(
-        file: SignatureFile,
-        classResolver: ClassResolver? = null,
-    ): Codebase {
-        return loadFiles(listOf(file), classResolver)
-    }
+) : SignatureFileLoader {
 
-    fun loadFiles(
-        files: List<SignatureFile>,
-        classResolver: ClassResolver? = null,
+    override fun load(
+        signatureFiles: List<SignatureFile>,
+        classResolver: ClassResolver?,
     ): Codebase {
-        require(files.isNotEmpty()) { "files must not be empty" }
+        require(signatureFiles.isNotEmpty()) { "files must not be empty" }
 
         try {
             return ApiFile.parseApi(
-                signatureFiles = files,
-                annotationManager = annotationManager,
+                signatureFiles = signatureFiles,
+                codebaseConfig = codebaseConfig,
                 classResolver = classResolver,
                 formatForLegacyFiles = formatForLegacyFiles,
             )
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/common/SourceOptions.kt b/metalava/src/main/java/com/android/tools/metalava/cli/common/SourceOptions.kt
index cad9b0ece..37f3f6c1c 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/common/SourceOptions.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/common/SourceOptions.kt
@@ -17,13 +17,17 @@
 package com.android.tools.metalava.cli.common
 
 import com.android.SdkConstants
+import com.android.tools.metalava.model.PackageFilter
 import com.github.ajalt.clikt.parameters.groups.OptionGroup
+import com.github.ajalt.clikt.parameters.options.convert
 import com.github.ajalt.clikt.parameters.options.option
 import java.io.File
 
 const val ARG_COMMON_SOURCE_PATH = "--common-source-path"
 const val ARG_SOURCE_PATH = "--source-path"
 
+const val ARG_STUB_PACKAGES = "--stub-packages"
+
 /** The name of the group, can be used in help text to refer to the options in this group. */
 const val SOURCE_OPTIONS_GROUP = "Sources"
 
@@ -89,4 +93,21 @@ class SourceOptions :
                 stringToExistingDir(it)
             }
         }
+
+    val apiPackages by
+        option(
+                ARG_STUB_PACKAGES,
+                metavar = "<package-list>",
+                help =
+                    """
+                        List of packages (separated by ${File.pathSeparator}) which will be used to
+                        filter out irrelevant classes. If specified, only classes in these packages
+                        will be included in signature files, stubs, etc.. This is not limited to
+                        just the stubs; the $ARG_STUB_PACKAGES name is historical.
+
+                        See `metalava help package-filters` for more information.
+                    """
+                        .trimIndent()
+            )
+            .convert { PackageFilter.parse(it) }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/common/TestEnvironment.kt b/metalava/src/main/java/com/android/tools/metalava/cli/common/TestEnvironment.kt
index 8e918eaa6..141c0ff58 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/common/TestEnvironment.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/common/TestEnvironment.kt
@@ -16,6 +16,8 @@
 
 package com.android.tools.metalava.cli.common
 
+import com.android.tools.metalava.Options
+import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.ModelOptions
 import com.android.tools.metalava.model.source.SourceModelProvider
 
@@ -36,4 +38,25 @@ class TestEnvironment(
     val skipEmitPackages: List<String>,
     val sourceModelProvider: SourceModelProvider,
     val modelOptions: ModelOptions,
+
+    /**
+     * An optional lambda that is called on the [CheckerContext] after the analysis phase has
+     * completed.
+     *
+     * This is set by tests to check the state of the objects referenced from [CheckerContext] like
+     * [Codebase] and [Options] that are not easily verifiable through other means.
+     */
+    val postAnalysisChecker: CheckerFunction? = null,
+)
+
+/**
+ * Encapsulates some internal state of the main metalava command for checking in
+ * [TestEnvironment.postAnalysisChecker] lambda.
+ */
+class CheckerContext(
+    val options: Options,
+    val codebase: Codebase,
 )
+
+/** Alias for a lambda that is invoked on [CheckerContext] to check its state as part of a test. */
+typealias CheckerFunction = CheckerContext.() -> Unit
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/compatibility/CompatibilityCheckOptions.kt b/metalava/src/main/java/com/android/tools/metalava/cli/compatibility/CompatibilityCheckOptions.kt
index 7a717caf2..1888436c8 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/compatibility/CompatibilityCheckOptions.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/compatibility/CompatibilityCheckOptions.kt
@@ -16,17 +16,17 @@
 
 package com.android.tools.metalava.cli.compatibility
 
-import com.android.tools.metalava.ApiType
 import com.android.tools.metalava.SignatureFileCache
 import com.android.tools.metalava.cli.common.BaselineOptionsMixin
 import com.android.tools.metalava.cli.common.CommonBaselineOptions
 import com.android.tools.metalava.cli.common.ExecutionEnvironment
-import com.android.tools.metalava.cli.common.JarBasedApi
 import com.android.tools.metalava.cli.common.PreviouslyReleasedApi
 import com.android.tools.metalava.cli.common.allowStructuredOptionName
 import com.android.tools.metalava.cli.common.existingFile
 import com.android.tools.metalava.cli.common.map
 import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.api.surface.ApiVariantType
+import com.android.tools.metalava.model.visitors.ApiType
 import com.github.ajalt.clikt.parameters.groups.OptionGroup
 import com.github.ajalt.clikt.parameters.options.multiple
 import com.github.ajalt.clikt.parameters.options.option
@@ -170,20 +170,14 @@ class CompatibilityCheckOptions(
             internal fun optionalCheckRequest(files: List<File>, apiType: ApiType) =
                 PreviouslyReleasedApi.optionalPreviouslyReleasedApi(
                         checkCompatibilityOptionForApiType(apiType),
-                        files
+                        files,
+                        apiVariantType =
+                            when (apiType) {
+                                ApiType.REMOVED -> ApiVariantType.REMOVED
+                                else -> ApiVariantType.CORE
+                            },
                     )
-                    ?.let { previouslyReleasedApi ->
-                        // It makes no sense to supply a jar file for the removed API because the
-                        // removed API is only a tiny fraction and incomplete part of an API
-                        // surface, so it could never be guaranteed to be able to compile into a jar
-                        // file.
-                        if (apiType == ApiType.REMOVED && previouslyReleasedApi is JarBasedApi) {
-                            throw IllegalStateException(
-                                "$ARG_CHECK_COMPATIBILITY_REMOVED_RELEASED: Cannot specify jar files for removed API but found ${previouslyReleasedApi.file}"
-                            )
-                        }
-                        CheckRequest(previouslyReleasedApi, apiType)
-                    }
+                    ?.let { previouslyReleasedApi -> CheckRequest(previouslyReleasedApi, apiType) }
 
             private fun checkCompatibilityOptionForApiType(apiType: ApiType) =
                 "--check-compatibility:${apiType.flagName}:released"
@@ -202,20 +196,13 @@ class CompatibilityCheckOptions(
         lazy(LazyThreadSafetyMode.NONE) { listOfNotNull(checkReleasedApi, checkReleasedRemoved) }
 
     /**
-     * The list of [Codebase]s corresponding to [compatibilityChecks].
+     * The optional Codebase corresponding to [compatibilityChecks].
      *
-     * This is used to provide the previously released API needed for `--revert-annotation`. It does
-     * not support jar files.
+     * This is used to provide the previously released API needed for `--revert-annotation`.
      */
-    fun previouslyReleasedCodebases(signatureFileCache: SignatureFileCache): List<Codebase> =
-        compatibilityChecks.map {
-            it.previouslyReleasedApi.load(
-                {
-                    throw IllegalStateException(
-                        "Unexpected file $it: jar files do not work with --revert-annotation"
-                    )
-                },
-                { signatureFileCache.load(it) }
-            )
-        }
+    fun previouslyReleasedCodebase(signatureFileCache: SignatureFileCache): Codebase? =
+        compatibilityChecks
+            .map { it.previouslyReleasedApi }
+            .reduceOrNull { p1, p2 -> p1.combine(p2) }
+            ?.load({ signatureFileCache.load(it) })
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/help/HelpCommand.kt b/metalava/src/main/java/com/android/tools/metalava/cli/help/HelpCommand.kt
index c3cbe982a..8595ee145 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/help/HelpCommand.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/help/HelpCommand.kt
@@ -16,7 +16,7 @@
 
 package com.android.tools.metalava.cli.help
 
-import com.android.tools.metalava.ARG_STUB_PACKAGES
+import com.android.tools.metalava.cli.common.ARG_STUB_PACKAGES
 import com.android.tools.metalava.cli.common.MetalavaHelpFormatter
 import com.android.tools.metalava.cli.common.stdout
 import com.android.tools.metalava.cli.common.terminal
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/internal/RewriteAnnotations.kt b/metalava/src/main/java/com/android/tools/metalava/cli/internal/RewriteAnnotations.kt
index 178f0a6dd..f0f30da4e 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/internal/RewriteAnnotations.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/internal/RewriteAnnotations.kt
@@ -17,14 +17,14 @@
 package com.android.tools.metalava.cli.internal
 
 import com.android.SdkConstants
-import com.android.tools.metalava.ANDROID_FLAGGED_API
-import com.android.tools.metalava.ANDROID_NONNULL
-import com.android.tools.metalava.ANDROID_NULLABLE
 import com.android.tools.metalava.ANDROID_SDK_CONSTANT
-import com.android.tools.metalava.RECENTLY_NONNULL
-import com.android.tools.metalava.RECENTLY_NULLABLE
+import com.android.tools.metalava.model.ANDROID_FLAGGED_API
+import com.android.tools.metalava.model.ANDROID_NONNULL
+import com.android.tools.metalava.model.ANDROID_NULLABLE
 import com.android.tools.metalava.model.AnnotationRetention
 import com.android.tools.metalava.model.Codebase
+import com.android.tools.metalava.model.RECENTLY_NONNULL
+import com.android.tools.metalava.model.RECENTLY_NULLABLE
 import java.io.File
 import kotlin.text.Charsets.UTF_8
 
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/signature/MergeSignaturesCommand.kt b/metalava/src/main/java/com/android/tools/metalava/cli/signature/MergeSignaturesCommand.kt
index e9e2c1848..96a91a984 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/signature/MergeSignaturesCommand.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/signature/MergeSignaturesCommand.kt
@@ -16,7 +16,6 @@
 
 package com.android.tools.metalava.cli.signature
 
-import com.android.tools.metalava.ApiType
 import com.android.tools.metalava.OptionsDelegate
 import com.android.tools.metalava.SignatureWriter
 import com.android.tools.metalava.cli.common.MetalavaCliException
@@ -29,7 +28,8 @@ import com.android.tools.metalava.createReportFile
 import com.android.tools.metalava.model.text.ApiFile
 import com.android.tools.metalava.model.text.ApiParseException
 import com.android.tools.metalava.model.text.SignatureFile
-import com.android.tools.metalava.model.visitors.ApiVisitor
+import com.android.tools.metalava.model.visitors.ApiPredicate
+import com.android.tools.metalava.model.visitors.ApiType
 import com.github.ajalt.clikt.parameters.arguments.argument
 import com.github.ajalt.clikt.parameters.arguments.multiple
 import com.github.ajalt.clikt.parameters.groups.provideDelegate
@@ -99,7 +99,7 @@ class MergeSignaturesCommand :
                     apiType = ApiType.ALL,
                     preFiltered = true,
                     showUnannotated = false,
-                    apiVisitorConfig = ApiVisitor.Config()
+                    apiPredicateConfig = ApiPredicate.Config(),
                 )
             }
         } catch (e: ApiParseException) {
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureToDexCommand.kt b/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureToDexCommand.kt
index a9cacf201..3da8420a5 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureToDexCommand.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureToDexCommand.kt
@@ -16,17 +16,17 @@
 
 package com.android.tools.metalava.cli.signature
 
-import com.android.tools.metalava.ApiType
 import com.android.tools.metalava.OptionsDelegate
+import com.android.tools.metalava.cli.common.DefaultSignatureFileLoader
 import com.android.tools.metalava.cli.common.MetalavaSubCommand
-import com.android.tools.metalava.cli.common.SignatureFileLoader
 import com.android.tools.metalava.cli.common.existingFile
 import com.android.tools.metalava.cli.common.newFile
 import com.android.tools.metalava.cli.common.progressTracker
 import com.android.tools.metalava.createReportFile
-import com.android.tools.metalava.model.noOpAnnotationManager
+import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.text.SignatureFile
-import com.android.tools.metalava.model.visitors.ApiVisitor
+import com.android.tools.metalava.model.visitors.ApiPredicate
+import com.android.tools.metalava.model.visitors.ApiType
 import com.android.tools.metalava.model.visitors.FilteringApiVisitor
 import com.github.ajalt.clikt.parameters.arguments.argument
 import com.github.ajalt.clikt.parameters.arguments.multiple
@@ -61,14 +61,13 @@ class SignatureToDexCommand :
         // property.
         OptionsDelegate.disallowAccess()
 
-        val signatureFileLoader = SignatureFileLoader(annotationManager = noOpAnnotationManager)
-        val signatureApi = signatureFileLoader.loadFiles(SignatureFile.fromFiles(apiFiles))
+        val codebaseConfig = Codebase.Config.NOOP
+        val signatureFileLoader = DefaultSignatureFileLoader(codebaseConfig)
+        val signatureApi = signatureFileLoader.load(SignatureFile.fromFiles(apiFiles))
 
-        val apiVisitorConfig = ApiVisitor.Config()
-        val apiPredicateConfig = apiVisitorConfig.apiPredicateConfig
+        val apiPredicateConfig = ApiPredicate.Config()
         val apiType = ApiType.ALL
-        val apiEmit = apiType.getEmitFilter(apiPredicateConfig)
-        val apiReference = apiType.getReferenceFilter(apiPredicateConfig)
+        val apiFilters = apiType.getApiFilters(apiPredicateConfig)
 
         createReportFile(progressTracker, signatureApi, outFile, "DEX API") { printWriter ->
             DexApiWriter(
@@ -78,10 +77,8 @@ class SignatureToDexCommand :
                     FilteringApiVisitor(
                         dexApiWriter,
                         inlineInheritedFields = true,
-                        filterEmit = apiEmit,
-                        filterReference = apiReference,
+                        apiFilters = apiFilters,
                         preFiltered = signatureApi.preFiltered,
-                        config = apiVisitorConfig,
                     )
                 }
         }
diff --git a/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureToJDiffCommand.kt b/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureToJDiffCommand.kt
index 86d38ee08..f8c8cb86d 100644
--- a/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureToJDiffCommand.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/cli/signature/SignatureToJDiffCommand.kt
@@ -16,14 +16,12 @@
 
 package com.android.tools.metalava.cli.signature
 
-import com.android.tools.metalava.ApiType
 import com.android.tools.metalava.CodebaseComparator
 import com.android.tools.metalava.ComparisonVisitor
-import com.android.tools.metalava.DefaultAnnotationManager
 import com.android.tools.metalava.JDiffXmlWriter
 import com.android.tools.metalava.OptionsDelegate
+import com.android.tools.metalava.cli.common.DefaultSignatureFileLoader
 import com.android.tools.metalava.cli.common.MetalavaSubCommand
-import com.android.tools.metalava.cli.common.SignatureFileLoader
 import com.android.tools.metalava.cli.common.existingFile
 import com.android.tools.metalava.cli.common.newFile
 import com.android.tools.metalava.cli.common.progressTracker
@@ -35,10 +33,13 @@ import com.android.tools.metalava.model.FieldItem
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.PropertyItem
+import com.android.tools.metalava.model.annotation.DefaultAnnotationManager
 import com.android.tools.metalava.model.text.FileFormat
 import com.android.tools.metalava.model.text.SignatureFile
 import com.android.tools.metalava.model.text.TextCodebaseBuilder
-import com.android.tools.metalava.model.visitors.ApiVisitor
+import com.android.tools.metalava.model.visitors.ApiFilters
+import com.android.tools.metalava.model.visitors.ApiPredicate
+import com.android.tools.metalava.model.visitors.ApiType
 import com.github.ajalt.clikt.parameters.arguments.argument
 import com.github.ajalt.clikt.parameters.options.convert
 import com.github.ajalt.clikt.parameters.options.flag
@@ -131,29 +132,33 @@ class SignatureToJDiffCommand :
         OptionsDelegate.disallowAccess()
 
         val annotationManager = DefaultAnnotationManager()
-        val signatureFileLoader =
-            SignatureFileLoader(
+        val codebaseConfig =
+            Codebase.Config(
                 annotationManager = annotationManager,
+            )
+        val signatureFileLoader =
+            DefaultSignatureFileLoader(
+                codebaseConfig = codebaseConfig,
                 formatForLegacyFiles = formatForLegacyFiles,
             )
 
-        val signatureApi = signatureFileLoader.load(SignatureFile.fromFile(apiFile))
+        val signatureApi = signatureFileLoader.load(SignatureFile.fromFiles(apiFile))
 
-        val apiVisitorConfig = ApiVisitor.Config()
-        val apiPredicateConfig = apiVisitorConfig.apiPredicateConfig
+        val apiPredicateConfig = ApiPredicate.Config()
         val apiType = ApiType.ALL
         val apiEmit = apiType.getEmitFilter(apiPredicateConfig)
         val strip = strip
         val apiReference =
             if (strip) apiType.getEmitFilter(apiPredicateConfig)
             else apiType.getReferenceFilter(apiPredicateConfig)
+        val apiFilters = ApiFilters(emit = apiEmit, reference = apiReference)
         val baseFile = baseApiFile
 
         val outputApi =
             if (baseFile != null) {
                 // Convert base on a diff
-                val baseApi = signatureFileLoader.load(SignatureFile.fromFile(baseFile))
-                computeDelta(baseFile, baseApi, signatureApi, apiVisitorConfig)
+                val baseApi = signatureFileLoader.load(SignatureFile.fromFiles(baseFile))
+                computeDelta(baseFile, baseApi, signatureApi, apiPredicateConfig)
             } else {
                 signatureApi
             }
@@ -166,8 +171,7 @@ class SignatureToJDiffCommand :
                     apiName = apiName,
                 )
                 .createFilteringVisitor(
-                    filterEmit = apiEmit,
-                    filterReference = apiReference,
+                    apiFilters = apiFilters,
                     preFiltered = signatureApi.preFiltered && !strip,
                     showUnannotated = false,
                     // Historically, the super class type has not been filtered.
@@ -199,44 +203,44 @@ private fun computeDelta(
     baseFile: File,
     baseApi: Codebase,
     signatureApi: Codebase,
-    apiVisitorConfig: ApiVisitor.Config,
+    apiPredicateConfig: ApiPredicate.Config,
 ): Codebase {
     // Compute just the delta
     return TextCodebaseBuilder.build(
         location = baseFile,
         description = "Delta between $baseApi and $signatureApi",
-        annotationManager = signatureApi.annotationManager,
+        codebaseConfig = signatureApi.config,
     ) {
-        CodebaseComparator(apiVisitorConfig = apiVisitorConfig)
+        CodebaseComparator()
             .compare(
                 object : ComparisonVisitor() {
-                    override fun added(new: PackageItem) {
+                    override fun addedPackageItem(new: PackageItem) {
                         addPackage(new)
                     }
 
-                    override fun added(new: ClassItem) {
+                    override fun addedClassItem(new: ClassItem) {
                         addClass(new)
                     }
 
-                    override fun added(new: ConstructorItem) {
+                    override fun addedConstructorItem(new: ConstructorItem) {
                         addConstructor(new)
                     }
 
-                    override fun added(new: MethodItem) {
+                    override fun addedMethodItem(new: MethodItem) {
                         addMethod(new)
                     }
 
-                    override fun added(new: FieldItem) {
+                    override fun addedFieldItem(new: FieldItem) {
                         addField(new)
                     }
 
-                    override fun added(new: PropertyItem) {
+                    override fun addedPropertyItem(new: PropertyItem) {
                         addProperty(new)
                     }
                 },
                 baseApi,
                 signatureApi,
-                ApiType.ALL.getReferenceFilter(apiVisitorConfig.apiPredicateConfig)
+                ApiType.ALL.getReferenceFilter(apiPredicateConfig)
             )
     }
 }
diff --git a/metalava/src/main/java/com/android/tools/metalava/compatibility/CompatibilityCheck.kt b/metalava/src/main/java/com/android/tools/metalava/compatibility/CompatibilityCheck.kt
index e42d51c7c..22e4ec226 100644
--- a/metalava/src/main/java/com/android/tools/metalava/compatibility/CompatibilityCheck.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/compatibility/CompatibilityCheck.kt
@@ -16,19 +16,19 @@
 
 package com.android.tools.metalava.compatibility
 
-import com.android.tools.metalava.ANDROID_SYSTEM_API
-import com.android.tools.metalava.ANDROID_TEST_API
-import com.android.tools.metalava.ApiType
 import com.android.tools.metalava.CodebaseComparator
 import com.android.tools.metalava.ComparisonVisitor
 import com.android.tools.metalava.JVM_DEFAULT_WITH_COMPATIBILITY
 import com.android.tools.metalava.cli.common.MetalavaCliException
+import com.android.tools.metalava.model.ANDROID_SYSTEM_API
+import com.android.tools.metalava.model.ANDROID_TEST_API
 import com.android.tools.metalava.model.ArrayTypeItem
 import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassOrigin
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.FilterPredicate
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.Item.Companion.describe
 import com.android.tools.metalava.model.ItemLanguage
@@ -41,6 +41,7 @@ import com.android.tools.metalava.model.SelectableItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeNullability
 import com.android.tools.metalava.model.VariableTypeItem
+import com.android.tools.metalava.model.visitors.ApiType
 import com.android.tools.metalava.options
 import com.android.tools.metalava.reporter.FileLocation
 import com.android.tools.metalava.reporter.IssueConfiguration
@@ -49,14 +50,13 @@ import com.android.tools.metalava.reporter.Issues.Issue
 import com.android.tools.metalava.reporter.Reporter
 import com.android.tools.metalava.reporter.Severity
 import com.intellij.psi.PsiField
-import java.util.function.Predicate
 
 /**
  * Compares the current API with a previous version and makes sure the changes are compatible. For
  * example, you can make a previously nullable parameter non null, but not vice versa.
  */
 class CompatibilityCheck(
-    val filterReference: Predicate<Item>,
+    val filterReference: FilterPredicate,
     private val apiType: ApiType,
     private val reporter: Reporter,
     private val issueConfiguration: IssueConfiguration,
@@ -172,7 +172,7 @@ class CompatibilityCheck(
         }
     }
 
-    override fun compare(old: Item, new: Item) {
+    override fun compareItems(old: Item, new: Item) {
         val oldModifiers = old.modifiers
         val newModifiers = new.modifiers
         if (oldModifiers.isOperator() && !newModifiers.isOperator()) {
@@ -221,7 +221,7 @@ class CompatibilityCheck(
         compareItemNullability(old, new)
     }
 
-    override fun compare(old: ParameterItem, new: ParameterItem) {
+    override fun compareParameterItems(old: ParameterItem, new: ParameterItem) {
         val prevName = old.publicName()
         val newName = new.publicName()
         if (prevName != null) {
@@ -266,7 +266,7 @@ class CompatibilityCheck(
         }
     }
 
-    override fun compare(old: ClassItem, new: ClassItem) {
+    override fun compareClassItems(old: ClassItem, new: ClassItem) {
         val oldModifiers = old.modifiers
         val newModifiers = new.modifiers
 
@@ -481,7 +481,7 @@ class CompatibilityCheck(
         }
     }
 
-    override fun compare(old: CallableItem, new: CallableItem) {
+    override fun compareCallableItems(old: CallableItem, new: CallableItem) {
         val oldModifiers = old.modifiers
         val newModifiers = new.modifiers
 
@@ -542,7 +542,7 @@ class CompatibilityCheck(
         }
     }
 
-    override fun compare(old: MethodItem, new: MethodItem) {
+    override fun compareMethodItems(old: MethodItem, new: MethodItem) {
         val oldModifiers = old.modifiers
         val newModifiers = new.modifiers
 
@@ -714,7 +714,7 @@ class CompatibilityCheck(
         }
     }
 
-    override fun compare(old: FieldItem, new: FieldItem) {
+    override fun compareFieldItems(old: FieldItem, new: FieldItem) {
         val oldModifiers = old.modifiers
         val newModifiers = new.modifiers
 
@@ -847,7 +847,7 @@ class CompatibilityCheck(
         report(issue, item, message)
     }
 
-    private fun handleRemoved(issue: Issue, item: Item) {
+    private fun handleRemoved(issue: Issue, item: SelectableItem) {
         if (!item.emit) {
             // It's a stub; this can happen when analyzing partial APIs
             // such as a signature file for a library referencing types
@@ -862,11 +862,11 @@ class CompatibilityCheck(
         )
     }
 
-    override fun added(new: PackageItem) {
+    override fun addedPackageItem(new: PackageItem) {
         handleAdded(Issues.ADDED_PACKAGE, new)
     }
 
-    override fun added(new: ClassItem) {
+    override fun addedClassItem(new: ClassItem) {
         val error =
             if (new.isInterface()) {
                 Issues.ADDED_INTERFACE
@@ -876,7 +876,7 @@ class CompatibilityCheck(
         handleAdded(error, new)
     }
 
-    override fun added(new: CallableItem) {
+    override fun addedCallableItem(new: CallableItem) {
         if (new is MethodItem) {
             // *Overriding* methods from super classes that are outside the
             // API is OK (e.g. overriding toString() from java.lang.Object)
@@ -941,15 +941,15 @@ class CompatibilityCheck(
         }
     }
 
-    override fun added(new: FieldItem) {
+    override fun addedFieldItem(new: FieldItem) {
         handleAdded(Issues.ADDED_FIELD, new)
     }
 
-    override fun removed(old: PackageItem, from: Item?) {
+    override fun removedPackageItem(old: PackageItem, from: PackageItem?) {
         handleRemoved(Issues.REMOVED_PACKAGE, old)
     }
 
-    override fun removed(old: ClassItem, from: Item?) {
+    override fun removedClassItem(old: ClassItem, from: SelectableItem) {
         val error =
             when {
                 old.isInterface() -> Issues.REMOVED_INTERFACE
@@ -960,13 +960,13 @@ class CompatibilityCheck(
         handleRemoved(error, old)
     }
 
-    override fun removed(old: CallableItem, from: ClassItem?) {
+    override fun removedCallableItem(old: CallableItem, from: ClassItem) {
         // See if there's a member from inherited class
         val inherited =
             if (old is MethodItem) {
                 // This can also return self, specially handled below
                 from
-                    ?.findMethod(
+                    .findMethod(
                         old,
                         includeSuperClasses = true,
                         includeInterfaces = from.isInterface()
@@ -1000,9 +1000,9 @@ class CompatibilityCheck(
     private fun MethodItem.treatAsRemoved(possibleMatch: MethodItem) =
         !showability.revertUnstableApi() && (isHiddenOrRemoved() || this != possibleMatch)
 
-    override fun removed(old: FieldItem, from: ClassItem?) {
+    override fun removedFieldItem(old: FieldItem, from: ClassItem) {
         val inherited =
-            from?.findField(
+            from.findField(
                 old.name(),
                 includeSuperClasses = true,
                 includeInterfaces = from.isInterface()
@@ -1074,10 +1074,7 @@ class CompatibilityCheck(
                 }
             val newFullCodebase = MergedCodebase(listOf(newCodebase))
 
-            CodebaseComparator(
-                    apiVisitorConfig = @Suppress("DEPRECATION") options.apiVisitorConfig,
-                )
-                .compare(checker, oldFullCodebase, newFullCodebase, filter)
+            CodebaseComparator().compare(checker, oldFullCodebase, newFullCodebase, filter)
 
             val message =
                 "Found compatibility problems checking " +
diff --git a/metalava/src/main/java/com/android/tools/metalava/doc/DocAnalyzer.kt b/metalava/src/main/java/com/android/tools/metalava/doc/DocAnalyzer.kt
index e880566b9..e4737a93f 100644
--- a/metalava/src/main/java/com/android/tools/metalava/doc/DocAnalyzer.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/doc/DocAnalyzer.kt
@@ -21,8 +21,8 @@ import com.android.tools.lint.checks.ApiLookup
 import com.android.tools.lint.detector.api.ApiConstraint
 import com.android.tools.lint.detector.api.editDistance
 import com.android.tools.metalava.PROGRAM_NAME
-import com.android.tools.metalava.SdkIdentifier
-import com.android.tools.metalava.apilevels.ApiToExtensionsMap
+import com.android.tools.metalava.SdkExtension
+import com.android.tools.metalava.apilevels.ApiToExtensionsMap.Companion.ANDROID_PLATFORM_SDK_ID
 import com.android.tools.metalava.cli.common.ExecutionEnvironment
 import com.android.tools.metalava.model.ANDROIDX_ANNOTATION_PREFIX
 import com.android.tools.metalava.model.ANNOTATION_ATTR_VALUE
@@ -39,11 +39,12 @@ import com.android.tools.metalava.model.MemberItem
 import com.android.tools.metalava.model.MethodItem
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.ParameterItem
+import com.android.tools.metalava.model.SelectableItem
 import com.android.tools.metalava.model.getAttributeValue
 import com.android.tools.metalava.model.getCallableParameterDescriptorUsingDots
 import com.android.tools.metalava.model.psi.containsLinkTags
+import com.android.tools.metalava.model.visitors.ApiPredicate
 import com.android.tools.metalava.model.visitors.ApiVisitor
-import com.android.tools.metalava.options
 import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.reporter.Reporter
 import java.io.File
@@ -58,6 +59,15 @@ private const val DEFAULT_ENFORCEMENT = "android.content.pm.PackageManager#hasSy
 
 private const val CARRIER_PRIVILEGES_MARKER = "carrier privileges"
 
+/** Lambda that when given an API level will return a string label for it. */
+typealias ApiLevelLabelProvider = (Int) -> String
+
+/**
+ * Lambda that when given an API level will return `true` if it can be referenced from within the
+ * documentation and `false` if it cannot.
+ */
+typealias ApiLevelFilter = (Int) -> Boolean
+
 /**
  * Walk over the API and apply tweaks to the documentation, such as
  * - Looking for annotations and converting them to auxiliary tags that will be processed by the
@@ -74,10 +84,16 @@ class DocAnalyzer(
     /** The codebase to analyze */
     private val codebase: Codebase,
     private val reporter: Reporter,
-) {
 
-    private val apiVisitorConfig = @Suppress("DEPRECATION") options.apiVisitorConfig
+    /** Provides a string label for each API level. */
+    private val apiLevelLabelProvider: ApiLevelLabelProvider,
 
+    /** Filter that determines whether an API level should be mentioned in the documentation. */
+    private val apiLevelFilter: ApiLevelFilter,
+
+    /** Selects [Item]s whose documentation will be analyzed and/or enhanced. */
+    private val apiPredicateConfig: ApiPredicate.Config,
+) {
     /** Computes the visible part of the API from all the available code in the codebase */
     fun enhance() {
         // Apply options for packages that should be hidden
@@ -106,7 +122,7 @@ class DocAnalyzer(
         // like an unreasonable burden.
 
         codebase.accept(
-            object : ApiVisitor(config = apiVisitorConfig) {
+            object : ApiVisitor(apiPredicateConfig = apiPredicateConfig) {
                 override fun visitItem(item: Item) {
                     val annotations = item.modifiers.annotations()
                     if (annotations.isEmpty()) {
@@ -201,7 +217,10 @@ class DocAnalyzer(
                         "androidx.annotation.StringDef" -> handleTypeDef(annotation, item)
                         "android.annotation.RequiresFeature" ->
                             handleRequiresFeature(annotation, item)
-                        "androidx.annotation.RequiresApi" -> handleRequiresApi(annotation, item)
+                        "androidx.annotation.RequiresApi" ->
+                            // The RequiresApi annotation can only be applied to SelectableItems,
+                            // i.e. not ParameterItems, so ignore it on them.
+                            if (item is SelectableItem) handleRequiresApi(annotation, item)
                         "android.provider.Column" -> handleColumn(annotation, item)
                         "kotlin.Deprecated" -> handleKotlinDeprecation(annotation, item)
                     }
@@ -217,7 +236,7 @@ class DocAnalyzer(
                         if (depth == 20) { // Temp debugging
                             throw StackOverflowError(
                                 "Unbounded recursion, processing annotation ${annotation.toSource()} " +
-                                    "in $item in ${item.sourceFile()} "
+                                    "in $item at ${annotation.fileLocation} "
                             )
                         } else if (nested.qualifiedName !in visitedClasses) {
                             handleAnnotation(nested, item, depth + 1, visitedClasses)
@@ -512,7 +531,11 @@ class DocAnalyzer(
                     appendDocumentation(doc, item, false)
                 }
 
-                private fun handleRequiresApi(annotation: AnnotationItem, item: Item) {
+                /**
+                 * Handle `RequiresApi` annotations which can only be applied to classes, methods,
+                 * constructors, fields and/or properties, i.e. not parameters.
+                 */
+                private fun handleRequiresApi(annotation: AnnotationItem, item: SelectableItem) {
                     val level = run {
                         val api =
                             annotation.findAttribute("api")?.leafValues()?.firstOrNull()?.value()
@@ -676,8 +699,20 @@ class DocAnalyzer(
 
     private fun tweakGrammar() {
         codebase.accept(
-            object : ApiVisitor(config = apiVisitorConfig) {
-                override fun visitItem(item: Item) {
+            object :
+                ApiVisitor(
+                    // Do not visit [ParameterItem]s as they do not have their own summary line that
+                    // could become truncated.
+                    visitParameterItems = false,
+                    apiPredicateConfig = apiPredicateConfig,
+                ) {
+                /**
+                 * Work around an issue with JavaDoc summary truncation.
+                 *
+                 * This is not called for [ParameterItem]s as they do not have their own summary
+                 * line that could become truncated.
+                 */
+                override fun visitSelectableItem(item: SelectableItem) {
                     item.documentation.workAroundJavaDocSummaryTruncationIssue()
                 }
             }
@@ -696,7 +731,9 @@ class DocAnalyzer(
         codebase.accept(
             object :
                 ApiVisitor(
-                    config = apiVisitorConfig,
+                    // Only SelectableItems have documentation associated with them.
+                    visitParameterItems = false,
+                    apiPredicateConfig = apiPredicateConfig,
                 ) {
 
                 override fun visitCallable(callable: CallableItem) {
@@ -751,39 +788,32 @@ class DocAnalyzer(
         }
     }
 
-    @Suppress("DEPRECATION")
-    private fun addApiLevelDocumentation(level: Int, item: Item) {
+    /**
+     * Add API level documentation to the [item].
+     *
+     * This only applies to classes and class members, i.e. not parameters.
+     */
+    private fun addApiLevelDocumentation(level: Int, item: SelectableItem) {
         if (level > 0) {
             if (item.originallyHidden) {
                 // @SystemApi, @TestApi etc -- don't apply API levels here since we don't have
                 // accurate historical data
                 return
             }
-            if (
-                !options.isDeveloperPreviewBuild() &&
-                    options.currentApiLevel != -1 &&
-                    level > options.currentApiLevel
-            ) {
-                // api-versions.xml currently assigns api+1 to APIs that have not yet been finalized
-                // in a dessert (only in an extension), but for release builds, we don't want to
-                // include a "future" SDK_INT
+
+            // Check to see whether an API level should not be included in the documentation.
+            if (!apiLevelFilter(level)) {
                 return
             }
 
-            val currentCodeName = options.currentCodeName
-            val code: String =
-                if (currentCodeName != null && level > options.currentApiLevel) {
-                    currentCodeName
-                } else {
-                    level.toString()
-                }
+            val apiLevelLabel = apiLevelLabelProvider(level)
 
             // Also add @since tag, unless already manually entered.
             // TODO: Override it everywhere in case the existing doc is wrong (we know
             // better), and at least for OpenJDK sources we *should* since the since tags
             // are talking about language levels rather than API levels!
             if (!item.documentation.contains("@apiSince")) {
-                item.appendDocumentation(code, "@apiSince")
+                item.appendDocumentation(apiLevelLabel, "@apiSince")
             } else {
                 reporter.report(
                     Issues.FORBIDDEN_TAG,
@@ -795,7 +825,15 @@ class DocAnalyzer(
         }
     }
 
-    private fun addApiExtensionsDocumentation(sdkExtSince: List<SdkAndVersion>, item: Item) {
+    /**
+     * Add API extension documentation to the [item].
+     *
+     * This only applies to classes and class members, i.e. not parameters.
+     *
+     * @param sdkExtSince the first non Android SDK entry in the `sdks` attribute associated with
+     *   [item].
+     */
+    private fun addApiExtensionsDocumentation(sdkExtSince: SdkAndVersion, item: SelectableItem) {
         if (item.documentation.contains("@sdkExtSince")) {
             reporter.report(
                 Issues.FORBIDDEN_TAG,
@@ -804,32 +842,26 @@ class DocAnalyzer(
                     "manually; it's computed and injected at build time by $PROGRAM_NAME"
             )
         }
-        // Don't emit an @sdkExtSince for every item in sdkExtSince; instead, limit output to the
-        // first non-Android SDK listed for the symbol in sdk-extensions-info.txt (the Android SDK
-        // is already covered by @apiSince and doesn't have to be repeated)
-        sdkExtSince
-            .find { it.sdk != ApiToExtensionsMap.ANDROID_PLATFORM_SDK_ID }
-            ?.let { item.appendDocumentation("${it.name} ${it.version}", "@sdkExtSince") }
+
+        item.appendDocumentation("${sdkExtSince.name} ${sdkExtSince.version}", "@sdkExtSince")
     }
 
-    @Suppress("DEPRECATION")
-    private fun addDeprecatedDocumentation(level: Int, item: Item) {
+    /**
+     * Add deprecated documentation to the [item].
+     *
+     * This only applies to classes and class members, i.e. not parameters.
+     */
+    private fun addDeprecatedDocumentation(level: Int, item: SelectableItem) {
         if (level > 0) {
             if (item.originallyHidden) {
                 // @SystemApi, @TestApi etc -- don't apply API levels here since we don't have
                 // accurate historical data
                 return
             }
-            val currentCodeName = options.currentCodeName
-            val code: String =
-                if (currentCodeName != null && level > options.currentApiLevel) {
-                    currentCodeName
-                } else {
-                    level.toString()
-                }
+            val apiLevelLabel = apiLevelLabelProvider(level)
 
             if (!item.documentation.contains("@deprecatedSince")) {
-                item.appendDocumentation(code, "@deprecatedSince")
+                item.appendDocumentation(apiLevelLabel, "@deprecatedSince")
             } else {
                 reporter.report(
                     Issues.FORBIDDEN_TAG,
@@ -948,7 +980,7 @@ fun getApiLookup(
     val prev = System.getProperty(xmlPathProperty)
     try {
         System.setProperty(xmlPathProperty, xmlFile.path)
-        return ApiLookup.get(client) ?: error("ApiLookup creation failed")
+        return ApiLookup.get(client, null) ?: error("ApiLookup creation failed")
     } finally {
         if (prev != null) {
             System.setProperty(xmlPathProperty, xmlFile.path)
@@ -967,21 +999,12 @@ fun getApiLookup(
  *
  * The symbols are Strings on the format "com.pkg.Foo#MethodOrField", with no method signature.
  */
-private fun createSymbolToSdkExtSinceMap(xmlFile: File): Map<String, List<SdkAndVersion>> {
-    data class OuterClass(val name: String, val idAndVersionList: List<IdAndVersion>?)
-
-    val sdkIdentifiers =
-        mutableMapOf(
-            ApiToExtensionsMap.ANDROID_PLATFORM_SDK_ID to
-                SdkIdentifier(
-                    ApiToExtensionsMap.ANDROID_PLATFORM_SDK_ID,
-                    "Android",
-                    "Android",
-                    "null"
-                )
-        )
+private fun createSymbolToSdkExtSinceMap(xmlFile: File): Map<String, SdkAndVersion> {
+    data class OuterClass(val name: String, val idAndVersion: IdAndVersion?)
+
+    val sdkExtensionsById = mutableMapOf<Int, SdkExtension>()
     var lastSeenClass: OuterClass? = null
-    val elementToIdAndVersionMap = mutableMapOf<String, List<IdAndVersion>>()
+    val elementToIdAndVersionMap = mutableMapOf<String, IdAndVersion>()
     val memberTags = listOf("class", "method", "field")
     val parser = SAXParserFactory.newDefaultInstance().newSAXParser()
     parser.parse(
@@ -1008,22 +1031,33 @@ private fun createSymbolToSdkExtSinceMap(xmlFile: File): Map<String, List<SdkAnd
                     val reference: String =
                         attributes.getValue("reference")
                             ?: throw IllegalArgumentException("<sdk>: missing reference attribute")
-                    sdkIdentifiers[id] = SdkIdentifier(id, shortname, name, reference)
+                    sdkExtensionsById[id] =
+                        SdkExtension.fromXmlAttributes(
+                            id,
+                            shortname,
+                            name,
+                            reference,
+                        )
                 } else if (memberTags.contains(qualifiedName)) {
                     val name: String =
                         attributes.getValue("name")
                             ?: throw IllegalArgumentException(
                                 "<$qualifiedName>: missing name attribute"
                             )
-                    val idAndVersionList: List<IdAndVersion>? =
-                        attributes
-                            .getValue("sdks")
+                    val sdksList = attributes.getValue("sdks")
+                    val idAndVersion =
+                        sdksList
                             ?.split(",")
-                            ?.map {
+                            // Get the first pair of sdk-id:version where sdk-id is not 0. If no
+                            // such pair exists then use `null`.
+                            ?.firstNotNullOfOrNull {
                                 val (sdk, version) = it.split(":")
-                                IdAndVersion(sdk.toInt(), version.toInt())
+                                val id = sdk.toInt()
+                                // Ignore any references to the Android Platform SDK as they are
+                                // handled by ApiLookup.
+                                if (id == ANDROID_PLATFORM_SDK_ID) null
+                                else IdAndVersion(id, version.toInt())
                             }
-                            ?.toList()
 
                     // Populate elementToIdAndVersionMap. The keys constructed here are derived from
                     // api-versions.xml; when used elsewhere in DocAnalyzer, the keys will be
@@ -1039,12 +1073,9 @@ private fun createSymbolToSdkExtSinceMap(xmlFile: File): Map<String, List<SdkAnd
                     when (qualifiedName) {
                         "class" -> {
                             lastSeenClass =
-                                OuterClass(
-                                    name.replace('/', '.').replace('$', '.'),
-                                    idAndVersionList
-                                )
-                            if (idAndVersionList != null) {
-                                elementToIdAndVersionMap[lastSeenClass!!.name] = idAndVersionList
+                                OuterClass(name.replace('/', '.').replace('$', '.'), idAndVersion)
+                            if (idAndVersion != null) {
+                                elementToIdAndVersionMap[lastSeenClass!!.name] = idAndVersion
                             }
                         }
                         "method",
@@ -1061,11 +1092,12 @@ private fun createSymbolToSdkExtSinceMap(xmlFile: File): Map<String, List<SdkAnd
                                     name.substringBefore('(')
                                 }
                             val element = "${lastSeenClass!!.name}#$shortName"
-                            if (idAndVersionList != null) {
-                                elementToIdAndVersionMap[element] = idAndVersionList
-                            } else if (lastSeenClass!!.idAndVersionList != null) {
-                                elementToIdAndVersionMap[element] =
-                                    lastSeenClass!!.idAndVersionList!!
+                            if (idAndVersion != null) {
+                                elementToIdAndVersionMap[element] = idAndVersion
+                            } else if (sdksList == null && lastSeenClass!!.idAndVersion != null) {
+                                // The method/field does not have an `sdks` attribute so fall back
+                                // to the idAndVersion from the containing class.
+                                elementToIdAndVersionMap[element] = lastSeenClass!!.idAndVersion!!
                             }
                         }
                     }
@@ -1080,16 +1112,16 @@ private fun createSymbolToSdkExtSinceMap(xmlFile: File): Map<String, List<SdkAnd
         }
     )
 
-    val elementToSdkExtSinceMap = mutableMapOf<String, List<SdkAndVersion>>()
+    val elementToSdkExtSinceMap = mutableMapOf<String, SdkAndVersion>()
     for (entry in elementToIdAndVersionMap.entries) {
         elementToSdkExtSinceMap[entry.key] =
-            entry.value.map {
+            entry.value.let {
                 val name =
-                    sdkIdentifiers[it.first]?.name
+                    sdkExtensionsById[it.first]?.name
                         ?: throw IllegalArgumentException(
                             "SDK reference to unknown <sdk> with id ${it.first}"
                         )
-                SdkAndVersion(it.first, name, it.second)
+                SdkAndVersion(name, it.second)
             }
     }
     return elementToSdkExtSinceMap
@@ -1097,4 +1129,4 @@ private fun createSymbolToSdkExtSinceMap(xmlFile: File): Map<String, List<SdkAnd
 
 private typealias IdAndVersion = Pair<Int, Int>
 
-private data class SdkAndVersion(val sdk: Int, val name: String, val version: Int)
+private data class SdkAndVersion(val name: String, val version: Int)
diff --git a/metalava/src/main/java/com/android/tools/metalava/lint/ApiLint.kt b/metalava/src/main/java/com/android/tools/metalava/lint/ApiLint.kt
index 9b06056b7..9bb42fd46 100644
--- a/metalava/src/main/java/com/android/tools/metalava/lint/ApiLint.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/lint/ApiLint.kt
@@ -17,8 +17,6 @@
 package com.android.tools.metalava.lint
 
 import com.android.sdklib.SdkVersionInfo
-import com.android.tools.metalava.ANDROID_FLAGGED_API
-import com.android.tools.metalava.ApiType
 import com.android.tools.metalava.KotlinInteropChecks
 import com.android.tools.metalava.lint.ResourceType.AAPT
 import com.android.tools.metalava.lint.ResourceType.ANIM
@@ -51,6 +49,8 @@ import com.android.tools.metalava.lint.ResourceType.STYLE_ITEM
 import com.android.tools.metalava.lint.ResourceType.TRANSITION
 import com.android.tools.metalava.lint.ResourceType.XML
 import com.android.tools.metalava.manifest.Manifest
+import com.android.tools.metalava.manifest.SetMinSdkVersion
+import com.android.tools.metalava.model.ANDROID_FLAGGED_API
 import com.android.tools.metalava.model.AnnotationItem
 import com.android.tools.metalava.model.ArrayTypeItem
 import com.android.tools.metalava.model.CallableItem
@@ -59,6 +59,7 @@ import com.android.tools.metalava.model.ClassTypeItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.ConstructorItem
 import com.android.tools.metalava.model.FieldItem
+import com.android.tools.metalava.model.FilterPredicate
 import com.android.tools.metalava.model.InheritableItem
 import com.android.tools.metalava.model.Item
 import com.android.tools.metalava.model.JAVA_LANG_DEPRECATED
@@ -70,12 +71,15 @@ import com.android.tools.metalava.model.MultipleTypeVisitor
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.ParameterItem
 import com.android.tools.metalava.model.PrimitiveTypeItem
-import com.android.tools.metalava.model.SetMinSdkVersion
+import com.android.tools.metalava.model.SelectableItem
 import com.android.tools.metalava.model.TypeItem
 import com.android.tools.metalava.model.TypeNullability
+import com.android.tools.metalava.model.TypeStringConfiguration
 import com.android.tools.metalava.model.VariableTypeItem
 import com.android.tools.metalava.model.findAnnotation
 import com.android.tools.metalava.model.hasAnnotation
+import com.android.tools.metalava.model.visitors.ApiPredicate
+import com.android.tools.metalava.model.visitors.ApiType
 import com.android.tools.metalava.model.visitors.ApiVisitor
 import com.android.tools.metalava.options
 import com.android.tools.metalava.reporter.FileLocation
@@ -181,7 +185,6 @@ import com.android.tools.metalava.reporter.Reporter
 import com.android.tools.metalava.reporter.Severity
 import java.io.StringWriter
 import java.util.Locale
-import java.util.function.Predicate
 import org.jetbrains.kotlin.util.capitalizeDecapitalize.toUpperCaseAsciiOnly
 
 /**
@@ -194,21 +197,19 @@ private constructor(
     private val oldCodebase: Codebase?,
     reporter: Reporter,
     private val manifest: Manifest,
-    config: Config,
+    apiPredicateConfig: ApiPredicate.Config,
 ) :
     ApiVisitor(
+        // ApiLint does not visit ParameterItems.
+        visitParameterItems = false,
         // We don't use ApiType's eliding emitFilter here, because lint checks should run
         // even when the signatures match that of a super method exactly (notably the ones checking
         // that nullability overrides are consistent).
-        filterEmit = ApiType.PUBLIC_API.getNonElidingFilter(config.apiPredicateConfig),
-        filterReference = ApiType.PUBLIC_API.getReferenceFilter(config.apiPredicateConfig),
-        config = config,
-        // Sort by source order such that warnings follow source line number order.
-        callableComparator = CallableItem.sourceOrderComparator,
+        apiFilters = ApiType.PUBLIC_API.getNonElidingApiFilters(apiPredicateConfig),
     ) {
 
     /** Predicate that checks if the item appears in the signature file. */
-    private val elidingFilterEmit = ApiType.PUBLIC_API.getEmitFilter(config.apiPredicateConfig)
+    private val elidingFilterEmit = ApiType.PUBLIC_API.getEmitFilter(apiPredicateConfig)
 
     /** [Reporter] that filters out items that are not relevant for the current API surface. */
     inner class FilteringReporter(private val delegate: Reporter) : Reporter by delegate {
@@ -242,9 +243,23 @@ private constructor(
                     return false
                 }
 
+                // Get the Item to check if it is part of the API. If it is not then there is no
+                // point in reporting the issue.
+                val testItem =
+                    when (item) {
+                        is ParameterItem ->
+                            // The parameter will only be included in the API if and only if its
+                            // containing callable is so check that.
+                            item.containingCallable()
+                        is SelectableItem -> item
+                        else ->
+                            // This should not happen as all Items are either a SelectableItem or a
+                            // ParameterItem
+                            error("Unknown item $item")
+                    }
+
                 // With show annotations we might be flagging API that is filtered out: hide these
-                // here
-                val testItem = if (item is ParameterItem) item.containingCallable() else item
+                // here by checking to see if the item is part of the API.
                 if (!filterEmit.test(testItem)) {
                     return false
                 }
@@ -360,6 +375,7 @@ private constructor(
         reporter.withContext(cls) {
             checkClass(cls, methods, constructors, allCallables, fields, superClass, interfaces)
         }
+        kotlinInterop.checkClass(cls)
     }
 
     override fun visitCallable(callable: CallableItem) {
@@ -1797,7 +1813,7 @@ private constructor(
         }
     }
 
-    private fun checkExceptions(callable: CallableItem, filterReference: Predicate<Item>) {
+    private fun checkExceptions(callable: CallableItem, filterReference: FilterPredicate) {
         for (throwableType in callable.filteredThrowsTypes(filterReference)) {
             // Get the throwable class, which for a type parameter will be the lower bound. A
             // method that throws a type parameter is treated as if it throws its lower bound, so
@@ -1908,12 +1924,12 @@ private constructor(
         }
     }
 
-    private fun checkHasFlaggedApi(item: Item) {
+    private fun checkHasFlaggedApi(item: SelectableItem) {
         // Cannot flag an implicit constructor.
         if (item is ConstructorItem && item.isImplicitConstructor()) return
 
-        fun itemOrAnyContainingClasses(predicate: Predicate<Item>): Boolean {
-            var it: Item? = item
+        fun itemOrAnyContainingClasses(predicate: FilterPredicate): Boolean {
+            var it: SelectableItem? = item
             while (it != null) {
                 if (predicate.test(it)) {
                     return true
@@ -1940,7 +1956,7 @@ private constructor(
      * Check whether an `@FlaggedApi` annotation is required on a new [Item], i.e. one that has not
      * previously been released.
      */
-    private fun checkFlaggedApiOnNewApi(item: Item) {
+    private fun checkFlaggedApiOnNewApi(item: SelectableItem) {
         val elidedField =
             if (item is FieldItem) {
                 val inheritedFrom = item.inheritedFrom
@@ -3270,8 +3286,8 @@ private constructor(
         setter: MethodItem
     ) {
         if (getterType.modifiers.nullability != setterType.modifiers.nullability) {
-            val getterTypeString = getterType.toTypeString(kotlinStyleNulls = true)
-            val setterTypeString = setterType.toTypeString(kotlinStyleNulls = true)
+            val getterTypeString = getterType.toTypeString(KOTLIN_NULLS_TYPE_STRING_CONFIGURATION)
+            val setterTypeString = setterType.toTypeString(KOTLIN_NULLS_TYPE_STRING_CONFIGURATION)
             report(
                 Issues.GETTER_SETTER_NULLABILITY,
                 getter,
@@ -3318,6 +3334,9 @@ private constructor(
     }
 
     companion object {
+        /** [TypeStringConfiguration] for use in [checkAccessorNullabilityMatches] */
+        private val KOTLIN_NULLS_TYPE_STRING_CONFIGURATION =
+            TypeStringConfiguration(kotlinStyleNulls = true)
 
         /**
          * Check the supplied [codebase] to see if it adheres to the API lint rules enforced by this
@@ -3331,9 +3350,9 @@ private constructor(
             oldCodebase: Codebase?,
             reporter: Reporter,
             manifest: Manifest,
-            config: Config,
+            apiPredicateConfig: ApiPredicate.Config,
         ) {
-            val apiLint = ApiLint(codebase, oldCodebase, reporter, manifest, config)
+            val apiLint = ApiLint(codebase, oldCodebase, reporter, manifest, apiPredicateConfig)
             apiLint.check()
         }
 
diff --git a/metalava/src/main/java/com/android/tools/metalava/manifest/Manifest.kt b/metalava/src/main/java/com/android/tools/metalava/manifest/Manifest.kt
index dcdb9e4ca..65dcf2070 100644
--- a/metalava/src/main/java/com/android/tools/metalava/manifest/Manifest.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/manifest/Manifest.kt
@@ -17,9 +17,6 @@
 package com.android.tools.metalava.manifest
 
 import com.android.SdkConstants
-import com.android.tools.metalava.model.MinSdkVersion
-import com.android.tools.metalava.model.SetMinSdkVersion
-import com.android.tools.metalava.model.UnsetMinSdkVersion
 import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.reporter.Reporter
 import com.android.tools.metalava.xml.parseDocument
@@ -118,3 +115,9 @@ class Manifest(private val manifest: File?, private val reporter: Reporter?) {
         return manifest.toString()
     }
 }
+
+sealed class MinSdkVersion
+
+data class SetMinSdkVersion(val value: Int) : MinSdkVersion()
+
+object UnsetMinSdkVersion : MinSdkVersion()
diff --git a/metalava/src/main/java/com/android/tools/metalava/stub/JavaStubWriter.kt b/metalava/src/main/java/com/android/tools/metalava/stub/JavaStubWriter.kt
index 349caa146..e2b987163 100644
--- a/metalava/src/main/java/com/android/tools/metalava/stub/JavaStubWriter.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/stub/JavaStubWriter.kt
@@ -16,7 +16,6 @@
 
 package com.android.tools.metalava.stub
 
-import com.android.tools.metalava.actualItem
 import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ClassTypeItem
@@ -53,7 +52,7 @@ internal class JavaStubWriter(
                 // All the classes referenced in the stubs are fully qualified, so no imports are
                 // needed. However, in some cases for javadoc, replacement with fully qualified name
                 // fails, and thus we need to include imports for the stubs to compile.
-                cls.getSourceFile()?.getImports()?.let {
+                cls.sourceFile()?.getImports()?.let {
                     for (item in it) {
                         if (item.isMember) {
                             writer.println("import static ${item.pattern};")
@@ -122,7 +121,7 @@ internal class JavaStubWriter(
     }
 
     private fun appendModifiers(item: Item) {
-        modifierListWriter.write(item.actualItem)
+        modifierListWriter.write(item)
     }
 
     private fun generateSuperClassDeclaration(cls: ClassItem) {
@@ -307,7 +306,7 @@ internal class JavaStubWriter(
         generateTypeParameterList(typeList = method.typeParameterList, addSpace = true)
 
         val returnType = method.returnType()
-        writer.print(returnType.toTypeString(annotations = false))
+        writer.print(returnType.toTypeString())
 
         writer.print(' ')
         writer.print(method.name())
@@ -322,7 +321,7 @@ internal class JavaStubWriter(
             }
         }
 
-        if (ModifierListWriter.requiresMethodBodyInStubs(method.actualItem)) {
+        if (ModifierListWriter.requiresMethodBodyInStubs(method)) {
             writer.print(" { ")
             writeThrowStub()
             writer.println(" }")
@@ -341,11 +340,11 @@ internal class JavaStubWriter(
 
         appendDocumentation(field, writer, config)
         appendModifiers(field)
-        writer.print(field.type().toTypeString(annotations = false))
+        writer.print(field.type().toTypeString())
         writer.print(' ')
         writer.print(field.name())
         val needsInitialization =
-            field.actualItem.modifiers.isFinal() &&
+            field.modifiers.isFinal() &&
                 field.initialValue(true) == null &&
                 field.containingClass().isClass()
         field.writeValueWithSemicolon(
@@ -374,7 +373,7 @@ internal class JavaStubWriter(
                 writer.print(", ")
             }
             appendModifiers(parameter)
-            writer.print(parameter.type().toTypeString(annotations = false))
+            writer.print(parameter.type().toTypeString())
             writer.print(' ')
             val name = parameter.publicName() ?: parameter.name()
             writer.print(name)
diff --git a/metalava/src/main/java/com/android/tools/metalava/stub/StubConstructorManager.kt b/metalava/src/main/java/com/android/tools/metalava/stub/StubConstructorManager.kt
index 5350adeb0..8f1514f2a 100644
--- a/metalava/src/main/java/com/android/tools/metalava/stub/StubConstructorManager.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/stub/StubConstructorManager.kt
@@ -16,13 +16,13 @@
 
 package com.android.tools.metalava.stub
 
+import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.ConstructorItem
-import com.android.tools.metalava.model.Item
+import com.android.tools.metalava.model.FilterPredicate
 import com.android.tools.metalava.model.PackageList
 import com.android.tools.metalava.model.VisibilityLevel
-import java.util.function.Predicate
 
 class StubConstructorManager(codebase: Codebase) {
 
@@ -58,7 +58,7 @@ class StubConstructorManager(codebase: Codebase) {
         }
     }
 
-    fun addConstructors(filter: Predicate<Item>) {
+    fun addConstructors(filter: FilterPredicate) {
         // Let's say we have
         //  class GrandParent { public GrandParent(int) {} }
         //  class Parent {  Parent(int) {} }
@@ -104,7 +104,7 @@ class StubConstructorManager(codebase: Codebase) {
      */
     private fun addConstructors(
         cls: ClassItem,
-        filter: Predicate<Item>,
+        filter: FilterPredicate,
     ): StubConstructors {
 
         // Don't add constructors to interfaces, enums, annotations, etc
@@ -156,30 +156,25 @@ class StubConstructorManager(codebase: Codebase) {
 
         val superDefaultConstructor = superClassConstructors?.stubConstructor
 
-        // Find default constructor, if one doesn't exist
+        // Find constructor subclasses should delegate to, creating one if necessary. If the stub
+        // will contain a no-args constructor then that is represented as `null` to allow it to be
+        // optimized below.
         val filteredConstructors = cls.filteredConstructors(filter).toList()
         val stubConstructor =
             if (filteredConstructors.isNotEmpty()) {
-                // Try to pick the constructor, select first by fewest throwables,
-                // then fewest parameters, then based on order in listFilter.test(cls)
-                filteredConstructors.reduce { first, second -> pickBest(first, second) }
-            } else if (
-                cls.constructors().isNotEmpty() ||
-                    // For text based codebase, stub constructor needs to be generated even if
-                    // cls.constructors() is empty, so that public default constructor is not
-                    // created.
-                    cls.codebase.preFiltered
-            ) {
-
-                // No accessible constructors are available so a package private constructor is
-                // created. Technically, the stub now has a constructor that isn't available at
-                // runtime, but apps creating subclasses inside the android.* package is not
-                // supported.
-                cls.createDefaultConstructor(VisibilityLevel.PACKAGE_PRIVATE)
+                // Pick the best constructor. If that is a no-args constructor then represent that
+                // as `null`.
+                pickBest(filteredConstructors).takeUnless { it.parameters().isEmpty() }
             } else {
-                null
+                // No accessible constructors are available (not even a default implicit
+                // constructor) so a package private constructor is needed. Technically, this will
+                // result in the stub class having a constructor that isn't available at runtime,
+                // but creating subclasses in API packages is not supported.
+                cls.createDefaultConstructor(VisibilityLevel.PACKAGE_PRIVATE)
             }
 
+        // If neither the constructors in this class nor its subclasses need to add a `super(...)`
+        // call then use a shared object.
         if (stubConstructor == null && superDefaultConstructor == null) {
             return StubConstructors.EMPTY
         }
@@ -194,20 +189,44 @@ class StubConstructorManager(codebase: Codebase) {
             }
     }
 
-    private fun pickBest(current: ConstructorItem, next: ConstructorItem): ConstructorItem {
-        val currentThrowsCount = current.throwsTypes().size
-        val nextThrowsCount = next.throwsTypes().size
-
-        return if (currentThrowsCount < nextThrowsCount) {
-            current
-        } else if (currentThrowsCount > nextThrowsCount) {
-            next
-        } else {
-            val currentParameterCount = current.parameters().size
-            val nextParameterCount = next.parameters().size
-            if (currentParameterCount <= nextParameterCount) {
-                current
-            } else next
+    companion object {
+        /**
+         * Comparator to pick the best [ConstructorItem] to which derived stub classes will
+         * delegate.
+         *
+         * Uses the following rules:
+         * 1. Fewest throwables as they have to be propagated down to constructors that delegate to
+         *    it.
+         * 2. Fewest parameters to reduce the size of the `super(...)` call.
+         * 3. Shortest erased parameter types as that should reduce the size of the `super(...)`
+         *    call.
+         * 4. Total ordering defined by [CallableItem.comparator] to ensure consistent behavior.
+         *
+         * Returns less than zero if the first [ConstructorItem] passed to `compare(c1, c2)` is the
+         * best option, more if the second [ConstructorItem] is the best option and zero if they are
+         * the same.
+         */
+        private val bestStubConstructorComparator: Comparator<ConstructorItem> =
+            Comparator.comparingInt<ConstructorItem?>({ it.throwsTypes().size })
+                .thenComparingInt({ it.parameters().size })
+                .thenComparingInt({
+                    it.parameters().sumOf { it.type().toErasedTypeString().length }
+                })
+                .thenComparing(CallableItem.comparator)
+    }
+
+    /**
+     * Pick the best [ConstructorItem] to which derived stub classes will delegate.
+     *
+     * Selects the first [ConstructorItem] in [constructors] which compares less to or equal to all
+     * the other [ConstructorItem]s in the list when compared using [bestStubConstructorComparator].
+     * That defines a total order so the result is independent of the order of [constructors].
+     */
+    private fun pickBest(constructors: List<ConstructorItem>): ConstructorItem {
+        // Try to pick the best constructor to which derived stub classes can delegate.
+        return constructors.reduce { first, second ->
+            val result = bestStubConstructorComparator.compare(first, second)
+            if (result <= 0) first else second
         }
     }
 
diff --git a/metalava/src/main/java/com/android/tools/metalava/stub/StubWriter.kt b/metalava/src/main/java/com/android/tools/metalava/stub/StubWriter.kt
index 275933ba1..45f48a83f 100644
--- a/metalava/src/main/java/com/android/tools/metalava/stub/StubWriter.kt
+++ b/metalava/src/main/java/com/android/tools/metalava/stub/StubWriter.kt
@@ -16,9 +16,6 @@
 
 package com.android.tools.metalava.stub
 
-import com.android.tools.metalava.ApiPredicate
-import com.android.tools.metalava.FilterPredicate
-import com.android.tools.metalava.actualItem
 import com.android.tools.metalava.model.CallableItem
 import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.ConstructorItem
@@ -32,9 +29,11 @@ import com.android.tools.metalava.model.ModifierListWriter
 import com.android.tools.metalava.model.PackageItem
 import com.android.tools.metalava.model.item.ResourceFile
 import com.android.tools.metalava.model.psi.trimDocIndent
-import com.android.tools.metalava.model.removeDeprecatedSection
+import com.android.tools.metalava.model.visitors.ApiFilters
+import com.android.tools.metalava.model.visitors.ApiPredicate
 import com.android.tools.metalava.model.visitors.ApiVisitor
 import com.android.tools.metalava.model.visitors.FilteringApiVisitor
+import com.android.tools.metalava.model.visitors.MatchOverridingMethodPredicate
 import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.reporter.Reporter
 import java.io.BufferedWriter
@@ -217,7 +216,7 @@ internal class StubWriter(
                 }
 
             // Copyright statements from the original file?
-            cls.getSourceFile()?.getHeaderComments()?.let { textWriter.println(it) }
+            cls.sourceFile()?.getHeaderComments()?.let { textWriter.println(it) }
         }
         stubWriter?.visitClass(cls)
 
@@ -271,14 +270,20 @@ fun createFilteringVisitorForStubs(
     delegate: DelegatedVisitor,
     docStubs: Boolean,
     preFiltered: Boolean,
-    apiVisitorConfig: ApiVisitor.Config,
+    apiPredicateConfig: ApiPredicate.Config,
+    ignoreEmit: Boolean = false,
 ): ItemVisitor {
     val filterReference =
         ApiPredicate(
             includeDocOnly = docStubs,
-            config = apiVisitorConfig.apiPredicateConfig.copy(ignoreShown = true),
+            config = apiPredicateConfig.copy(ignoreShown = true),
+        )
+    val filterEmit = MatchOverridingMethodPredicate(filterReference)
+    val apiFilters =
+        ApiFilters(
+            emit = filterEmit,
+            reference = filterReference,
         )
-    val filterEmit = FilterPredicate(filterReference)
     return FilteringApiVisitor(
         delegate = delegate,
         inlineInheritedFields = true,
@@ -287,10 +292,9 @@ fun createFilteringVisitorForStubs(
         // consistent order will prevent churn in the generated stubs caused by changes to Metalava
         // itself or changes to the order of methods in the sources.
         callableComparator = CallableItem.comparator,
-        filterEmit = filterEmit,
-        filterReference = filterReference,
+        apiFilters = apiFilters,
         preFiltered = preFiltered,
-        config = apiVisitorConfig,
+        ignoreEmit = ignoreEmit,
     )
 }
 
@@ -300,35 +304,8 @@ internal fun appendDocumentation(item: Item, writer: PrintWriter, config: StubWr
         val text = documentation.fullyQualifiedDocumentation()
         if (text.isNotBlank()) {
             val trimmed = trimDocIndent(text)
-            val output = revertDocumentationDeprecationChange(item, trimmed)
-            writer.println(output)
+            writer.println(trimmed)
             writer.println()
         }
     }
 }
-
-/**
- * Revert the documentation change that accompanied a deprecation change.
- *
- * Deprecating an API requires adding an `@Deprecated` annotation and an `@deprecated` Javadoc tag
- * with text that explains why it is being deprecated and what will replace it. When the deprecation
- * change is being reverted then this will remove the `@deprecated` tag and its associated text to
- * avoid warnings when compiling and misleading information being written into the Javadoc.
- */
-fun revertDocumentationDeprecationChange(currentItem: Item, docs: String): String {
-    val actualItem = currentItem.actualItem
-    // The documentation does not need to be reverted if...
-    if (
-        // the current item is not being reverted
-        currentItem === actualItem
-        // or if the current item and the actual item have the same deprecation setting
-        ||
-            currentItem.effectivelyDeprecated == actualItem.effectivelyDeprecated
-            // or if the actual item is deprecated
-            ||
-            actualItem.effectivelyDeprecated
-    )
-        return docs
-
-    return removeDeprecatedSection(docs)
-}
diff --git a/metalava/src/test/java/com/android/tools/metalava/AnnotationFilterTest.kt b/metalava/src/test/java/com/android/tools/metalava/AnnotationFilterTest.kt
index ad3bf7e9d..f7b28cd43 100644
--- a/metalava/src/test/java/com/android/tools/metalava/AnnotationFilterTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/AnnotationFilterTest.kt
@@ -16,6 +16,8 @@
 
 package com.android.tools.metalava
 
+import com.android.tools.metalava.model.annotation.AnnotationFilter
+import com.android.tools.metalava.model.annotation.AnnotationFilterBuilder
 import org.junit.Assert.assertEquals
 import org.junit.AssumptionViolatedException
 import org.junit.Test
diff --git a/metalava/src/test/java/com/android/tools/metalava/ApiAnalyzerTest.kt b/metalava/src/test/java/com/android/tools/metalava/ApiAnalyzerTest.kt
index e0a5d9a26..b6de08671 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ApiAnalyzerTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ApiAnalyzerTest.kt
@@ -509,42 +509,6 @@ class ApiAnalyzerTest : DriverTest() {
         )
     }
 
-    @Test
-    fun `Test deprecated status not propagated to removed items`() {
-        check(
-            sourceFiles =
-                arrayOf(
-                    java(
-                        """
-                            package test.pkg;
-
-                            /**
-                             * @deprecated
-                             * @removed
-                             */
-                            public class Concrete {
-                                public void bar() {}
-                            }
-                        """
-                    ),
-                ),
-            format = FileFormat.V2,
-            api = """
-                    // Signature format: 2.0
-                """,
-            removedApi =
-                """
-                    // Signature format: 2.0
-                    package test.pkg {
-                      @Deprecated public class Concrete {
-                        ctor public Concrete();
-                        method public void bar();
-                      }
-                    }
-                """,
-        )
-    }
-
     @RequiresCapabilities(Capability.KOTLIN)
     @Test
     fun `Test warnings for usage of hidden interface type`() {
diff --git a/metalava/src/test/java/com/android/tools/metalava/ApiFileTest.kt b/metalava/src/test/java/com/android/tools/metalava/ApiFileTest.kt
index 93928c48a..f20aa6724 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ApiFileTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ApiFileTest.kt
@@ -103,6 +103,7 @@ class ApiFileTest : DriverTest() {
                   }
                   public static final class Foo.Companion {
                     method public void sayHello();
+                    property public static final int answer;
                   }
                 }
                 """,
@@ -413,11 +414,13 @@ class ApiFileTest : DriverTest() {
                     method public void setProperty2(@Nullable String);
                     property @NonNull public final String property1;
                     property @Nullable public final String property2;
+                    property public final int someField2;
                     field @NonNull public static final test.pkg.Kotlin.Companion Companion;
                     field public static final int MY_CONST = 42; // 0x2a
                     field public int someField2;
                   }
                   public static final class Kotlin.Companion {
+                    property public static final int MY_CONST;
                   }
                   public final class KotlinKt {
                     method @NonNull public static inline operator String component1(@NonNull String);
@@ -566,7 +569,7 @@ class ApiFileTest : DriverTest() {
                         var readOnlyVar = false
                             internal set
                         // This property should have no public setter
-                        public var readOnlyVarWithPublicModifer = false
+                        public var readOnlyVarWithPublicModifier = false
                             internal set
                     }
                     """
@@ -579,9 +582,9 @@ class ApiFileTest : DriverTest() {
                   public final class MyClass {
                     ctor public MyClass();
                     method public boolean getReadOnlyVar();
-                    method public boolean getReadOnlyVarWithPublicModifer();
+                    method public boolean getReadOnlyVarWithPublicModifier();
                     property public final boolean readOnlyVar;
-                    property public final boolean readOnlyVarWithPublicModifer;
+                    property public final boolean readOnlyVarWithPublicModifier;
                   }
                 }
                 """
@@ -1396,6 +1399,7 @@ class ApiFileTest : DriverTest() {
                     ctor public SimpleClass();
                     method public int getNonJvmField();
                     method public void setNonJvmField(int);
+                    property public final int jvmField;
                     property public final int nonJvmField;
                     field public int jvmField;
                   }
@@ -4403,7 +4407,7 @@ class ApiFileTest : DriverTest() {
                     ctor public KotlinClass(@IntRange(from=2L) int differentParam);
                     method public int getParam();
                     method public void myMethod(@IntRange(from=3L) int methodParam);
-                    property public final int param;
+                    property @IntRange(from=1L) public final int param;
                   }
                 }
             """
@@ -4775,8 +4779,8 @@ class ApiFileTest : DriverTest() {
                     inline class Dp(val value: Float) : Comparable<Dp> {
                         inline operator fun plus(other: Dp) = Dp(value = this.value + other.value)
                         inline operator fun minus(other: Dp) = Dp(value = this.value - other.value)
-                        // Not tracked due to https://youtrack.jetbrains.com/issue/KTIJ-11559
                         val someBits
+                            // Not tracked due to https://youtrack.jetbrains.com/issue/KTIJ-11559
                             get() = value.toInt() and 0x00ff
                         fun doSomething() {}
                     }
@@ -4793,6 +4797,7 @@ class ApiFileTest : DriverTest() {
                     method public float getValue();
                     method public inline operator float minus(float other);
                     method public inline operator float plus(float other);
+                    property public final int someBits;
                     property public final float value;
                   }
                 }
@@ -4834,7 +4839,6 @@ class ApiFileTest : DriverTest() {
                     ctor public Dp(float value);
                     method public int compareTo(float other);
                     method public void doSomething();
-                    method public int getSomeBits();
                     method public float getValue();
                     method public inline operator float minus(float other);
                     method public inline operator float plus(float other);
@@ -5144,6 +5148,7 @@ class ApiFileTest : DriverTest() {
                 package test.pkg {
                   @RestrictTo({androidx.annotation.RestrictTo.Scope.LIBRARY}) public final class TestKt {
                     method public static void bar();
+                    property public static final String CONST;
                     field public static final String CONST = "Hello";
                   }
                 }
@@ -5299,6 +5304,9 @@ class ApiFileTest : DriverTest() {
                     field public static final int SP = 2; // 0x2
                   }
                   public static final class Dimension.Companion {
+                    property public static final int DP;
+                    property public static final int PX;
+                    property public static final int SP;
                     field public static final int DP = 0; // 0x0
                     field public static final int PX = 1; // 0x1
                     field public static final int SP = 2; // 0x2
@@ -5481,11 +5489,13 @@ class ApiFileTest : DriverTest() {
                   @kotlin.annotation.Repeatable public @interface RequiresExtension {
                     method public abstract int extension();
                     method public abstract int version();
-                    property public abstract int extension;
-                    property public abstract int version;
+                    property @IntRange(from=1L) public abstract int extension;
+                    property @IntRange(from=1L) public abstract int version;
                   }
                   @kotlin.annotation.Repeatable public static @interface RequiresExtension.Container {
                     method public abstract test.pkg.RequiresExtension[] value();
+                    property @IntRange(from=1L) public abstract int extension;
+                    property @IntRange(from=1L) public abstract int version;
                   }
                 }
             """
@@ -5670,6 +5680,8 @@ class ApiFileTest : DriverTest() {
                         package test.pkg
 
                         fun String.bar(): Unit {}
+
+                        val nonConstVal = 3
                     """
                     ),
                     kotlin(
@@ -5681,6 +5693,8 @@ class ApiFileTest : DriverTest() {
                         package test.pkg
 
                         fun String.baz(): Unit {}
+
+                        const val constVal = 4
                     """
                     )
                 ),
@@ -5692,6 +5706,10 @@ class ApiFileTest : DriverTest() {
                   public final class Foo {
                     method public static void bar(String);
                     method public static void baz(String);
+                    method public static int getNonConstVal();
+                    property public static final int constVal;
+                    property public static final int nonConstVal;
+                    field public static final int constVal = 4; // 0x4
                   }
                 }
             """
diff --git a/metalava/src/test/java/com/android/tools/metalava/ApiLevelsGenerationOptionsTest.kt b/metalava/src/test/java/com/android/tools/metalava/ApiLevelsGenerationOptionsTest.kt
new file mode 100644
index 000000000..d5cf672b8
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/ApiLevelsGenerationOptionsTest.kt
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava
+
+import com.android.tools.metalava.cli.common.BaseOptionGroupTest
+import com.google.common.truth.Truth.assertThat
+import org.junit.Test
+
+val API_LEVELS_GENERATION_OPTIONS_HELP =
+    """
+Api Levels Generation:
+
+  Options controlling the API levels file, e.g. `api-versions.xml` file.
+
+  --generate-api-levels <xmlfile>            Reads android.jar SDK files and generates an XML file recording the API
+                                             level for each class, method and field
+  --remove-missing-class-references-in-api-levels
+                                             Removes references to missing classes when generating the API levels XML
+                                             file. This can happen when generating the XML file for the non-updatable
+                                             portions of the module-lib sdk, as those non-updatable portions can
+                                             reference classes that are part of an updatable apex.
+  --first-version <numeric-version>          Sets the first API level to generate an API database from. (default: 1)
+  --current-version <numeric-version>        Sets the current API level of the current source code. Must be greater than
+                                             or equal to 27.
+  --current-codename <version-codename>      Sets the code name for the current source code.
+  --android-jar-pattern <android-jar-pattern>
+                                             Pattern to use to locate Android JAR files. Each pattern must contain a %
+                                             character that will be replaced with each API level that is being included
+                                             and if the result is an existing jar file then it will be taken as the
+                                             definition of the API at that level.
+  --sdk-extensions-root <sdk-jar-root>       Points to root of prebuilt extension SDK jars, if any. This directory is
+                                             expected to contain snapshots of historical extension SDK versions in the
+                                             form of stub jars. The paths should be on the format
+                                             \"<int>/public/<module-name>.jar\", where <int> corresponds to the
+                                             extension SDK version, and <module-name> to the name of the mainline
+                                             module.
+  --sdk-extensions-info <sdk-info-file>      Points to map of extension SDK APIs to include, if any. The file is a plain
+                                             text file and describes, per extension SDK, what APIs from that extension
+                                             to include in the file created via --generate-api-levels. The format of
+                                             each line is one of the following: \"<module-name> <pattern> <ext-name>
+                                             [<ext-name> [...]]\", where <module-name> is the name of the mainline
+                                             module this line refers to, <pattern> is a common Java name prefix of the
+                                             APIs this line refers to, and <ext-name> is a list of extension SDK names
+                                             in which these SDKs first appeared, or \"<ext-name> <ext-id> <type>\",
+                                             where <ext-name> is the name of an SDK, <ext-id> its numerical ID and
+                                             <type> is one of \"platform\" (the Android platform SDK), \"platform-ext\"
+                                             (an extension to the Android platform SDK), \"standalone\" (a separate
+                                             SDK). Fields are separated by whitespace. A mainline module may be listed
+                                             multiple times. The special pattern \"*\" refers to all APIs in the given
+                                             mainline module. Lines beginning with # are comments.
+  --generate-api-version-history <output-file>
+                                             Reads API signature files and generates a JSON or XML file depending on the
+                                             extension, which must be one of `json` or `xml` respectively. The JSON file
+                                             will record the API version in which each class, method, and field. was
+                                             added in and (if applicable) deprecated in. The XML file will include that
+                                             information and more but will be optimized to exclude information from
+                                             class members which is the same as the containing class.
+  --api-version-signature-files <files>      An ordered list of text API signature files. The oldest API version should
+                                             be first, the newest last. This should not include a signature file for the
+                                             current API version, which will be parsed from the provided source files.
+                                             Not required to generate API version JSON if the current version is the
+                                             only version.
+  --api-version-names <api-versions>         An ordered list of strings with the names to use for the API versions from
+                                             --api-version-signature-files, and the name of the current API version.
+                                             Required for --generate-api-version-history.
+    """
+        .trimIndent()
+
+class ApiLevelsGenerationOptionsTest :
+    BaseOptionGroupTest<ApiLevelsGenerationOptions>(
+        API_LEVELS_GENERATION_OPTIONS_HELP,
+    ) {
+    override fun createOptions() = ApiLevelsGenerationOptions()
+
+    @Test
+    fun `sdkJarRoot without sdkInfoFile`() {
+        val file = temporaryFolder.newFolder("sdk-jar-root")
+        runTest(ARG_SDK_JAR_ROOT, file.path) {
+            assertThat(stderr)
+                .isEqualTo("--sdk-extensions-root and --sdk-extensions-info must both be supplied")
+        }
+    }
+
+    @Test
+    fun `sdkInfoFile without sdkJarRoot`() {
+        val file = temporaryFolder.newFile("sdk-info-file.xml")
+        runTest(ARG_SDK_INFO_FILE, file.path) {
+            assertThat(stderr)
+                .isEqualTo("--sdk-extensions-root and --sdk-extensions-info must both be supplied")
+        }
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/ApiSurfacesTest.kt b/metalava/src/test/java/com/android/tools/metalava/ApiSurfacesTest.kt
new file mode 100644
index 000000000..2dd863c81
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/ApiSurfacesTest.kt
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava
+
+import com.android.tools.metalava.model.ANDROID_SYSTEM_API
+import com.android.tools.metalava.model.ANDROID_TEST_API
+import com.android.tools.metalava.model.api.surface.ApiSurfaces
+import com.android.tools.metalava.testing.java
+import kotlin.test.assertNotNull
+import kotlin.test.assertNull
+import kotlin.test.assertSame
+import org.junit.Test
+
+class ApiSurfacesTest : DriverTest() {
+
+    /** Encapsulate the data to check in the lambda supplied to [checkApiSurfaces], */
+    private class ApiSurfacesContext(val apiSurfaces: ApiSurfaces)
+
+    /**
+     * Check the API surfaces that are configured based off the [arguments].
+     *
+     * @param arguments the command line arguments to supply.
+     * @param checker the lambda that is invoked on [ApiSurfacesContext] and which checks its
+     *   [ApiSurfacesContext.apiSurfaces] property to make sure that the [ApiSurfaces] were
+     *   configured as expected.
+     */
+    private fun checkApiSurfaces(
+        vararg arguments: String,
+        checker: ApiSurfacesContext.() -> Unit,
+    ) {
+        check(
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            public class Foo {
+                            }
+                        """
+                    ),
+                ),
+            extraArguments = arguments,
+            postAnalysisChecker = {
+                val apiSurfaces = options.apiSurfaces
+                val context = ApiSurfacesContext(apiSurfaces)
+                context.checker()
+            },
+        )
+    }
+
+    private fun ApiSurfaces.assertBaseWasNotCreated() {
+        assertNull(base, message = "base")
+        assertNull(main.extends, message = "main.extends")
+    }
+
+    private fun ApiSurfaces.assertBaseWasCreated() {
+        assertNotNull(base, message = "base")
+        assertSame(base, main.extends, message = "main.extends")
+    }
+
+    @Test
+    fun `Test generating public API does not need to track the base API surface`() {
+        checkApiSurfaces {
+            // The public API surface does not extend another API surface so there is no need to
+            // track the base API surface.
+            apiSurfaces.assertBaseWasNotCreated()
+        }
+    }
+
+    /**
+     * This is equivalent to the restricted API surface in AndroidX. That is effectively an
+     * extension of the public (unannotated API) but unlike Android it does not just write the delta
+     * to the `*restricted.txt` signature files it writes the whole API. It does that by specifying
+     * `--show-unannotated` (to include the public API) alongside the `--show-annotation` (to
+     * include the restricted extensions).
+     */
+    @Test
+    fun `Test generating system + public API does not need to track the base API surface`() {
+        checkApiSurfaces(
+            // Do not make system a delta on top of public by including public APIs.
+            ARG_SHOW_UNANNOTATED,
+            // Include system APIs.
+            ARG_SHOW_ANNOTATION,
+            ANDROID_SYSTEM_API,
+        ) {
+            // The system API surface that includes public does not extend public so there is no
+            // need to track the base API surface.
+            apiSurfaces.assertBaseWasNotCreated()
+        }
+    }
+
+    @Test
+    fun `Test generating system API as delta on public does need to track the base API surface`() {
+        checkApiSurfaces(
+            // Include system API only, no ARG_SHOW_UNANNOTATED means no public API.
+            ARG_SHOW_ANNOTATION,
+            ANDROID_SYSTEM_API,
+        ) {
+            // The system API surface that extends public does need to track the base API surface.
+            apiSurfaces.assertBaseWasCreated()
+        }
+    }
+
+    @Test
+    fun `Test generating test API as delta on system does need to track the base API surface`() {
+        checkApiSurfaces(
+            // Include test APIs only, no ARG_SHOW_UNANNOTATED means no public API.
+            ARG_SHOW_ANNOTATION,
+            ANDROID_TEST_API,
+            // Include system APIs only for stubs which always have to be complete.
+            ARG_SHOW_FOR_STUB_PURPOSES_ANNOTATION,
+            ANDROID_SYSTEM_API,
+        ) {
+            apiSurfaces.assertBaseWasCreated()
+        }
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/ComparisonVisitorTest.kt b/metalava/src/test/java/com/android/tools/metalava/ComparisonVisitorTest.kt
index 16db60926..92ce1e3a0 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ComparisonVisitorTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ComparisonVisitorTest.kt
@@ -22,10 +22,8 @@ import com.android.tools.metalava.model.ClassItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.MergedCodebase
 import com.android.tools.metalava.model.MethodItem
-import com.android.tools.metalava.model.noOpAnnotationManager
 import com.android.tools.metalava.model.text.ApiFile
 import com.android.tools.metalava.model.text.SignatureFile
-import com.android.tools.metalava.model.visitors.ApiVisitor
 import com.android.tools.metalava.testing.TemporaryFolderOwner
 import com.android.tools.metalava.testing.signature
 import org.junit.Assert.assertEquals
@@ -38,24 +36,22 @@ class ComparisonVisitorTest : TemporaryFolderOwner, Assertions {
 
     @Test
     fun `prefer first's real children even when first is only implied`() {
-        val new =
-            MergedCodebase(
-                listOf(
-                    ApiFile.parseApi(
-                        "first.txt",
-                        """
+        val newSignatureFiles =
+            listOf(
+                SignatureFile.fromText(
+                    "first.txt",
+                    """
                         // Signature format: 2.0
                         package pkg {
                             public class Outer.Inner {
                                 method public TypeInFirst foobar();
                             }
                         }
-                        """
-                            .trimIndent()
-                    ),
-                    ApiFile.parseApi(
-                        "second.txt",
-                        """
+                    """
+                ),
+                SignatureFile.fromText(
+                    "second.txt",
+                    """
                         // Signature format: 2.0
                         package pkg {
                             public class Outer {
@@ -64,34 +60,34 @@ class ComparisonVisitorTest : TemporaryFolderOwner, Assertions {
                                 method public TypeInSecond foobar();
                             }
                         }
-                        """
-                            .trimIndent()
-                    )
-                )
+                    """
+                ),
             )
-        val old =
+        val new =
             MergedCodebase(
-                listOf(
-                    ApiFile.parseApi(
-                        "old.txt",
-                        """
-                        // Signature format: 2.0
-                        package pkg {
-                            public class Outer {
-                            }
-                            public class Outer.Inner {
-                            }
+                // Parse each signature file on its own.
+                newSignatureFiles.map { ApiFile.parseApi(listOf(it)) }
+            )
+
+        val oldSignatureFile =
+            SignatureFile.fromText(
+                "old.txt",
+                """
+                    // Signature format: 2.0
+                    package pkg {
+                        public class Outer {
+                        }
+                        public class Outer.Inner {
                         }
-                        """
-                            .trimIndent()
-                    ),
-                )
+                    }
+                """
             )
+        val old = MergedCodebase(listOf(ApiFile.parseApi(listOf(oldSignatureFile))))
         var methodType: String? = null
-        CodebaseComparator(ApiVisitor.Config())
+        CodebaseComparator()
             .compare(
                 object : ComparisonVisitor() {
-                    override fun added(new: MethodItem) {
+                    override fun addedMethodItem(new: MethodItem) {
                         methodType = new.type().toSimpleType()
                     }
                 },
@@ -105,8 +101,8 @@ class ComparisonVisitorTest : TemporaryFolderOwner, Assertions {
     fun `Test make sure that method with emit=false is ignored during comparison`() {
 
         fun TestFile.readCodebase(): Codebase {
-            val signatureFile = SignatureFile(createFile(temporaryFolder.root))
-            return ApiFile.parseApi(signatureFile, noOpAnnotationManager)
+            val signatureFiles = SignatureFile.fromFiles(createFile(temporaryFolder.root))
+            return ApiFile.parseApi(signatureFiles, Codebase.Config.NOOP)
         }
 
         val signatureFile =
@@ -134,18 +130,18 @@ class ComparisonVisitorTest : TemporaryFolderOwner, Assertions {
 
         // Compare the two.
         val differences = mutableListOf<String>()
-        CodebaseComparator(ApiVisitor.Config())
+        CodebaseComparator()
             .compare(
                 object : ComparisonVisitor() {
-                    override fun compare(old: MethodItem, new: MethodItem) {
+                    override fun compareMethodItems(old: MethodItem, new: MethodItem) {
                         differences += "$old was changed"
                     }
 
-                    override fun added(new: MethodItem) {
+                    override fun addedMethodItem(new: MethodItem) {
                         differences += "$new was added"
                     }
 
-                    override fun removed(old: MethodItem, from: ClassItem?) {
+                    override fun removedMethodItem(old: MethodItem, from: ClassItem) {
                         differences += "$old was removed"
                     }
                 },
diff --git a/metalava/src/test/java/com/android/tools/metalava/DeprecatedTestCase.kt b/metalava/src/test/java/com/android/tools/metalava/DeprecatedTest.kt
similarity index 95%
rename from metalava/src/test/java/com/android/tools/metalava/DeprecatedTestCase.kt
rename to metalava/src/test/java/com/android/tools/metalava/DeprecatedTest.kt
index a4d786b27..a748bb508 100644
--- a/metalava/src/test/java/com/android/tools/metalava/DeprecatedTestCase.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/DeprecatedTest.kt
@@ -20,7 +20,7 @@ import com.android.tools.metalava.testing.java
 import org.junit.Test
 
 /** Test some inconsistent behavior around deprecated status. */
-class DeprecatedTestCase : DriverTest() {
+class DeprecatedTest : DriverTest() {
 
     @Test
     fun `Test deprecated not written out for parameter unless explicitly deprecated`() {
@@ -274,16 +274,16 @@ class DeprecatedTestCase : DriverTest() {
                     // Signature format: 5.0
                     package test.pkg {
                       @Deprecated public class Foo {
-                        ctor public Foo();
+                        ctor @Deprecated public Foo();
                         method @Deprecated public void deprecatedMethod();
-                        method public void method(int);
-                        field public static final int CONSTANT = 1; // 0x1
+                        method @Deprecated public void method(int);
+                        field @Deprecated public static final int CONSTANT = 1; // 0x1
                       }
-                      public static class Foo.Nested {
-                        ctor public Foo.Nested();
+                      @Deprecated public static class Foo.Nested {
+                        ctor @Deprecated public Foo.Nested();
                         method @Deprecated public void deprecatedNestedMethod();
-                        method public void nestedMethod(int);
-                        field public static final int NESTED_CONSTANT = 1; // 0x1
+                        method @Deprecated public void nestedMethod(int);
+                        field @Deprecated public static final int NESTED_CONSTANT = 1; // 0x1
                       }
                     }
                 """,
diff --git a/metalava/src/test/java/com/android/tools/metalava/DriverTest.kt b/metalava/src/test/java/com/android/tools/metalava/DriverTest.kt
index a361abc34..161f51fe8 100644
--- a/metalava/src/test/java/com/android/tools/metalava/DriverTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/DriverTest.kt
@@ -37,6 +37,8 @@ import com.android.tools.metalava.cli.common.ARG_QUIET
 import com.android.tools.metalava.cli.common.ARG_REPEAT_ERRORS_MAX
 import com.android.tools.metalava.cli.common.ARG_SOURCE_PATH
 import com.android.tools.metalava.cli.common.ARG_VERBOSE
+import com.android.tools.metalava.cli.common.CheckerContext
+import com.android.tools.metalava.cli.common.CheckerFunction
 import com.android.tools.metalava.cli.common.ExecutionEnvironment
 import com.android.tools.metalava.cli.common.TestEnvironment
 import com.android.tools.metalava.cli.compatibility.ARG_API_COMPAT_ANNOTATION
@@ -51,6 +53,7 @@ import com.android.tools.metalava.cli.lint.ARG_BASELINE_API_LINT
 import com.android.tools.metalava.cli.lint.ARG_ERROR_MESSAGE_API_LINT
 import com.android.tools.metalava.cli.lint.ARG_UPDATE_BASELINE_API_LINT
 import com.android.tools.metalava.cli.signature.ARG_FORMAT
+import com.android.tools.metalava.model.Assertions
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.psi.PsiModelOptions
 import com.android.tools.metalava.model.source.SourceModelProvider
@@ -94,7 +97,8 @@ import org.junit.rules.TemporaryFolder
 import org.junit.runner.RunWith
 
 @RunWith(DriverTestRunner::class)
-abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, TemporaryFolderOwner {
+abstract class DriverTest :
+    CodebaseCreatorConfigAware<SourceModelProvider>, TemporaryFolderOwner, Assertions {
     @get:Rule override val temporaryFolder = TemporaryFolder()
 
     @get:Rule val errorCollector = ErrorCollector()
@@ -464,7 +468,7 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
         /** If using [showAnnotations], whether to include unannotated */
         showUnannotated: Boolean = false,
         /** Additional arguments to supply */
-        extraArguments: Array<String> = emptyArray(),
+        extraArguments: Array<out String> = emptyArray(),
         /** Expected output (stdout and stderr combined). If null, don't check. */
         expectedOutput: String? = null,
         /** Expected fail message and state, if any */
@@ -482,7 +486,12 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
         includeSystemApiAnnotations: Boolean = false,
         /** Whether we should warn about super classes that are stripped because they are hidden */
         includeStrippedSuperclassWarnings: Boolean = false,
-        /** Apply level to XML */
+        /**
+         * Apply level to XML.
+         *
+         * This can either be the name of a file or the contents of the XML file. In the latter case
+         * the contents are trimmed and written to a file.
+         */
         applyApiLevelsXml: String? = null,
         /** Corresponds to SDK constants file broadcast_actions.txt */
         sdkBroadcastActions: String? = null,
@@ -538,6 +547,15 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
         projectDescription: TestFile? = null,
         /** [ARG_REPEAT_ERRORS_MAX] */
         repeatErrorsMax: Int = 0,
+        /**
+         * Called on a [CheckerContext] after the analysis phase in the metalava main command.
+         *
+         * This allows testing of the internal state of the metalava main command. Ideally, tests
+         * should not use this as it makes the tests more fragile and can increase the cost of
+         * refactoring. However, it is often the only way to verify the effects of changes that
+         * start to add a new feature but which does not yet have any effect on the output.
+         */
+        postAnalysisChecker: CheckerFunction? = null,
     ) {
         // Ensure different API clients don't interfere with each other
         try {
@@ -896,7 +914,6 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
                 emptyArray()
             }
 
-        val applyApiLevelsXmlFile: File?
         val applyApiLevelsXmlArgs =
             if (applyApiLevelsXml != null) {
                 ApiLookup::class
@@ -904,8 +921,10 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
                     .getDeclaredMethod("dispose")
                     .apply { isAccessible = true }
                     .invoke(null)
-                applyApiLevelsXmlFile = temporaryFolder.newFile("api-versions.xml")
-                applyApiLevelsXmlFile?.writeText(applyApiLevelsXml.trimIndent())
+                val applyApiLevelsXmlFile =
+                    useExistingFileOrCreateNewFile(project, applyApiLevelsXml, "api-versions.xml") {
+                        it.trimIndent()
+                    }
                 arrayOf(ARG_APPLY_API_LEVELS, applyApiLevelsXmlFile.path)
             } else {
                 emptyArray()
@@ -1094,6 +1113,7 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
                 skipEmitPackages = skipEmitPackages,
                 sourceModelProvider = codebaseCreatorConfig.creator,
                 modelOptions = codebaseCreatorConfig.modelOptions,
+                postAnalysisChecker = postAnalysisChecker,
             )
 
         val actualOutput =
@@ -1134,7 +1154,7 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
             )
             assertSignatureFilesMatch(api, apiFile.readText(), expectedFormat = format)
             // Make sure we can read back the files we write
-            ApiFile.parseApi(SignatureFile.fromFile(apiFile), options.annotationManager)
+            ApiFile.parseApi(SignatureFile.fromFiles(apiFile), options.codebaseConfig)
         }
 
         baselineCheck.apply()
@@ -1152,7 +1172,7 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
                 expectedFormat = format
             )
             // Make sure we can read back the files we write
-            ApiFile.parseApi(SignatureFile.fromFile(removedApiFile), options.annotationManager)
+            ApiFile.parseApi(SignatureFile.fromFiles(removedApiFile), options.codebaseConfig)
         }
 
         if (proguard != null && proguardFile != null) {
@@ -1372,7 +1392,7 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
         }
 
         /**
-         * Get an optional signature API [File] from either a file path or its contents.
+         * Get a signature API [File] from either a file path or its contents.
          *
          * @param project the directory in which to create a new file.
          * @param fileOrFileContents either a path to an existing file or the contents of the
@@ -1382,16 +1402,34 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
          */
         private fun useExistingSignatureFileOrCreateNewFile(
             project: File,
-            fileOrFileContents: String?,
+            fileOrFileContents: String,
             newBasename: String
         ) =
-            fileOrFileContents?.let {
-                val maybeFile = File(fileOrFileContents)
+            useExistingFileOrCreateNewFile(project, fileOrFileContents, newBasename) {
+                prepareSignatureFileForTest(it, FileFormat.V2)
+            }
+
+        /**
+         * Get an optional [File] from either a file path or its contents.
+         *
+         * @param project the directory in which to create a new file.
+         * @param fileOrFileContents either a path to an existing file or the contents of the file.
+         *   If the latter the [transformer] will be applied to [fileOrFileContents] and written to
+         *   a new file created within [project].
+         * @param newBasename the basename of a new file created.
+         */
+        private fun useExistingFileOrCreateNewFile(
+            project: File,
+            fileOrFileContents: String,
+            newBasename: String,
+            transformer: (String) -> String,
+        ) =
+            File(fileOrFileContents).let { maybeFile ->
                 if (maybeFile.isFile) {
                     maybeFile
                 } else {
                     val file = findNonExistentFile(project, newBasename)
-                    file.writeSignatureText(fileOrFileContents)
+                    file.writeText(transformer(fileOrFileContents))
                     file
                 }
             }
@@ -1415,9 +1453,7 @@ abstract class DriverTest : CodebaseCreatorConfigAware<SourceModelProvider>, Tem
         ): Array<String> {
             if (isEmpty()) return emptyArray()
 
-            val paths = mapNotNull {
-                useExistingSignatureFileOrCreateNewFile(project, it, baseName)?.path
-            }
+            val paths = map { useExistingSignatureFileOrCreateNewFile(project, it, baseName).path }
 
             // For each path in the list generate an option with the path as the value.
             return paths.flatMap { listOf(optionName, it) }.toTypedArray()
@@ -1818,46 +1854,7 @@ val systemServiceSource: TestFile =
         )
         .indented()
 
-val systemApiSource: TestFile =
-    java(
-            """
-    package android.annotation;
-    import static java.lang.annotation.ElementType.*;
-    import java.lang.annotation.*;
-    @Target({TYPE, FIELD, METHOD, CONSTRUCTOR, ANNOTATION_TYPE, PACKAGE})
-    @Retention(RetentionPolicy.SOURCE)
-    public @interface SystemApi {
-        enum Client {
-            /**
-             * Specifies that the intended clients of a SystemApi are privileged apps.
-             * This is the default value for {@link #client}.
-             */
-            PRIVILEGED_APPS,
-
-            /**
-             * Specifies that the intended clients of a SystemApi are used by classes in
-             * <pre>BOOTCLASSPATH</pre> in mainline modules. Mainline modules can also expose
-             * this type of system APIs too when they're used only by the non-updatable
-             * platform code.
-             */
-            MODULE_LIBRARIES,
-
-            /**
-             * Specifies that the system API is available only in the system server process.
-             * Use this to expose APIs from code loaded by the system server process <em>but</em>
-             * not in <pre>BOOTCLASSPATH</pre>.
-             */
-            SYSTEM_SERVER
-        }
-
-        /**
-         * The intended client of this SystemAPI.
-         */
-        Client client() default android.annotation.SystemApi.Client.PRIVILEGED_APPS;
-    }
-    """
-        )
-        .indented()
+val systemApiSource = KnownSourceFiles.systemApiSource
 
 val testApiSource: TestFile =
     java(
diff --git a/metalava/src/test/java/com/android/tools/metalava/FlaggedApiEdgeCasesTest.kt b/metalava/src/test/java/com/android/tools/metalava/FlaggedApiEdgeCasesTest.kt
new file mode 100644
index 000000000..b88e34f2b
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/FlaggedApiEdgeCasesTest.kt
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava
+
+import com.android.tools.metalava.cli.common.ARG_STUB_PACKAGES
+import com.android.tools.metalava.model.ANDROID_FLAGGED_API
+import com.android.tools.metalava.testing.java
+import org.junit.Test
+
+/** Edge case tests of [ANDROID_FLAGGED_API] that cannot be tested in [FlaggedApiTest]. */
+class FlaggedApiEdgeCasesTest : DriverTest() {
+    @Test
+    fun `Test override flagged method from source path no previously released API`() {
+        check(
+            extraArguments =
+                arrayOf(
+                    // Revert all FlaggedApi annotations.
+                    ARG_REVERT_ANNOTATION,
+                    ANDROID_FLAGGED_API,
+                    // Ignore any classes other than test.pkg.
+                    ARG_STUB_PACKAGES,
+                    "test.pkg*"
+                ),
+            sourceFiles =
+                arrayOf(
+                    // A class that will be ignored during the initial codebase creation. However,
+                    // as it is referenced from test.pkg.Test class below it will be loaded in later
+                    // and that will result in it having an origin of ClassOrigin.SOURCE_PATH
+                    // instead of ClassOrigin.COMMAND_LINE like test.pkg.Test.
+                    java(
+                        """
+                            package other.pkg;
+
+                            public abstract class Other {
+                                @$ANDROID_FLAGGED_API("flag.name")
+                                public abstract void method();
+                            }
+                        """
+                    ),
+                    java(
+                        """
+                            package test.pkg;
+
+                            public final class Test extends other.pkg.Other {
+                                private Test() {}
+                                // Overrides the flagged method in other.pkg.Other. The flagged
+                                // status of the overridden method should be ignored because the
+                                // containing class is not contributing to this API and there is no
+                                // previously released API provided so reverting will result in this
+                                // method being removed.
+                                @Override public void method() {}
+                            }
+                        """
+                    ),
+                ),
+            stubFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public final class Test extends other.pkg.Other {
+                            Test() { throw new RuntimeException("Stub!"); }
+                            public void method() { throw new RuntimeException("Stub!"); }
+                            }
+                        """
+                    )
+                ),
+        )
+    }
+
+    @Test
+    fun `Test override flagged method from source path with previously released API`() {
+        check(
+            extraArguments =
+                arrayOf(
+                    // Revert all FlaggedApi annotations.
+                    ARG_REVERT_ANNOTATION,
+                    ANDROID_FLAGGED_API,
+                    // Ignore any classes other than test.pkg.
+                    ARG_STUB_PACKAGES,
+                    "test.pkg*"
+                ),
+            sourceFiles =
+                arrayOf(
+                    // A class that will be ignored during the initial codebase creation. However,
+                    // as it is referenced from test.pkg.Test class below it will be loaded in later
+                    // and that will result in it having an origin of ClassOrigin.SOURCE_PATH
+                    // instead of ClassOrigin.COMMAND_LINE like test.pkg.Test.
+                    java(
+                        """
+                            package other.pkg;
+
+                            public abstract class Other {
+                                @$ANDROID_FLAGGED_API("flag.name")
+                                public abstract void method();
+                            }
+                        """
+                    ),
+                    java(
+                        """
+                            package test.pkg;
+
+                            public final class Test extends other.pkg.Other {
+                                private Test() {}
+                                // Overrides the flagged method in other.pkg.Other. The flagged
+                                // status of the overridden method should not be ignored because
+                                // while the containing class is not contributing to this API a
+                                // previously released API is provided so reverting will result in
+                                // the correct behavior.
+                                @Override public void method() {}
+                            }
+                        """
+                    ),
+                ),
+            checkCompatibilityApiReleased =
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public class Test extends other.pkg.Other {
+                      }
+                    }
+                """,
+            stubFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public final class Test extends other.pkg.Other {
+                            Test() { throw new RuntimeException("Stub!"); }
+                            }
+                        """
+                    )
+                ),
+        )
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/FlaggedApiTest.kt b/metalava/src/test/java/com/android/tools/metalava/FlaggedApiTest.kt
index 83b15e777..0bf9e90b9 100644
--- a/metalava/src/test/java/com/android/tools/metalava/FlaggedApiTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/FlaggedApiTest.kt
@@ -18,6 +18,7 @@ package com.android.tools.metalava
 
 import com.android.tools.lint.checks.infrastructure.TestFile
 import com.android.tools.metalava.cli.common.ARG_HIDE
+import com.android.tools.metalava.model.ANDROID_FLAGGED_API
 import com.android.tools.metalava.model.text.FileFormat
 import com.android.tools.metalava.reporter.Issues
 import com.android.tools.metalava.testing.KnownSourceFiles
diff --git a/metalava/src/test/java/com/android/tools/metalava/JavadocTest.kt b/metalava/src/test/java/com/android/tools/metalava/JavadocTest.kt
index 1e0233da7..e6ba6c69e 100644
--- a/metalava/src/test/java/com/android/tools/metalava/JavadocTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/JavadocTest.kt
@@ -157,8 +157,8 @@ class JavadocTest : DriverTest() {
                     import test.pkg2.OtherClass;
                     /**
                      *  Blah blah {@link test.pkg2.OtherClass OtherClass} blah blah.
-                     *  Referencing <b>field</b> {@link test.pkg2.OtherClass#foo OtherClass#foo},
-                     *  and referencing method {@link test.pkg2.OtherClass#bar(int,boolean) OtherClass#bar(int,
+                     *  Referencing <b>field</b> {@link test.pkg2.OtherClass#foo OtherClass.foo},
+                     *  and referencing method {@link test.pkg2.OtherClass#bar(int,boolean) OtherClass.bar(int,
                      *   boolean)}.
                      *  And relative method reference {@link #baz()}.
                      *  And relative field reference {@link #importance}.
@@ -176,8 +176,8 @@ class JavadocTest : DriverTest() {
                     public SomeClass() { throw new RuntimeException("Stub!"); }
                     /**
                      * My method.
-                     * @param focus The focus to find. One of {@link test.pkg2.OtherClass#FOCUS_INPUT OtherClass#FOCUS_INPUT} or
-                     *         {@link test.pkg2.OtherClass#FOCUS_ACCESSIBILITY OtherClass#FOCUS_ACCESSIBILITY}.
+                     * @param focus The focus to find. One of {@link test.pkg2.OtherClass#FOCUS_INPUT OtherClass.FOCUS_INPUT} or
+                     *         {@link test.pkg2.OtherClass#FOCUS_ACCESSIBILITY OtherClass.FOCUS_ACCESSIBILITY}.
                      * @throws java.io.IOException when blah blah blah
                      * @throws {@link java.lang.RuntimeException RuntimeException} when blah blah blah
                      */
@@ -366,8 +366,8 @@ class JavadocTest : DriverTest() {
                 import test.pkg2.OtherClass;
                 /**
                  *  Blah blah {@link test.pkg2.OtherClass OtherClass} blah blah.
-                 *  Referencing <b>field</b> {@link test.pkg2.OtherClass#foo OtherClass#foo},
-                 *  and referencing method {@link test.pkg2.OtherClass#bar(int,boolean) OtherClass#bar(int,
+                 *  Referencing <b>field</b> {@link test.pkg2.OtherClass#foo OtherClass.foo},
+                 *  and referencing method {@link test.pkg2.OtherClass#bar(int,boolean) OtherClass.bar(int,
                  *   boolean)}.
                  *  And relative method reference {@link #baz()}.
                  *  And relative field reference {@link #importance}.
@@ -385,8 +385,8 @@ class JavadocTest : DriverTest() {
                 public SomeClass() { throw new RuntimeException("Stub!"); }
                 /**
                  * My method.
-                 * @param focus The focus to find. One of {@link test.pkg2.OtherClass#FOCUS_INPUT OtherClass#FOCUS_INPUT} or
-                 *         {@link test.pkg2.OtherClass#FOCUS_ACCESSIBILITY OtherClass#FOCUS_ACCESSIBILITY}.
+                 * @param focus The focus to find. One of {@link test.pkg2.OtherClass#FOCUS_INPUT OtherClass.FOCUS_INPUT} or
+                 *         {@link test.pkg2.OtherClass#FOCUS_ACCESSIBILITY OtherClass.FOCUS_ACCESSIBILITY}.
                  * @throws java.io.IOException when blah blah blah
                  * @throws {@link java.lang.RuntimeException} when blah blah blah
                  */
@@ -873,16 +873,16 @@ class JavadocTest : DriverTest() {
                 package test.pkg1;
                 import test.pkg2.MyChild;
                 /**
-                 * Reference to {@link test.pkg2.MyChild#CONSTANT1 MyChild#CONSTANT1},
-                 * {@link test.pkg2.MyChild#CONSTANT2 MyChild#CONSTANT2}, and
-                 * {@link test.pkg2.MyChild#myMethod MyChild#myMethod}.
+                 * Reference to {@link test.pkg2.MyChild#CONSTANT1 MyChild.CONSTANT1},
+                 * {@link test.pkg2.MyChild#CONSTANT2 MyChild.CONSTANT2}, and
+                 * {@link test.pkg2.MyChild#myMethod MyChild.myMethod}.
                  * <p>
                  * Absolute reference:
                  * {@link test.pkg2.MyChild#CONSTANT1 MyChild.CONSTANT1}
                  * <p>
                  * Inner class reference:
-                 * {@link test.pkg1.Test.TestInner#CONSTANT3 Test.TestInner#CONSTANT3}, again
-                 * {@link test.pkg1.Test.TestInner#CONSTANT3 TestInner#CONSTANT3}
+                 * {@link test.pkg1.Test.TestInner#CONSTANT3 Test.TestInner.CONSTANT3}, again
+                 * {@link test.pkg1.Test.TestInner#CONSTANT3 TestInner.CONSTANT3}
                  *
                  * @see test.pkg2.MyChild#myMethod
                  */
@@ -899,52 +899,6 @@ class JavadocTest : DriverTest() {
         )
     }
 
-    @Test
-    fun `Handle @attr references`() {
-        checkStubs(
-            docStubs = true,
-            warnings = "",
-            sourceFiles =
-                arrayOf(
-                    java(
-                        """
-                    package test.pkg1;
-
-                    @SuppressWarnings("all")
-                    public class Test {
-                        /**
-                         * Returns the drawable that will be drawn between each item in the list.
-                         *
-                         * @return the current drawable drawn between list elements
-                         * This value may be {@code null}.
-                         * @attr ref R.styleable#ListView_divider
-                         */
-                        public Object getFoo() {
-                            return null;
-                        }
-                    }
-                    """
-                    )
-                ),
-            source =
-                """
-                package test.pkg1;
-                @SuppressWarnings({"unchecked", "deprecation", "all"})
-                public class Test {
-                public Test() { throw new RuntimeException("Stub!"); }
-                /**
-                 * Returns the drawable that will be drawn between each item in the list.
-                 *
-                 * @return the current drawable drawn between list elements
-                 * This value may be {@code null}.
-                 * @attr ref android.R.styleable#ListView_divider
-                 */
-                public java.lang.Object getFoo() { throw new RuntimeException("Stub!"); }
-                }
-                """
-        )
-    }
-
     @Test
     fun `Rewrite parameter list`() {
         checkStubs(
@@ -996,13 +950,13 @@ class JavadocTest : DriverTest() {
                 package test.pkg1;
                 import test.pkg2.OtherClass2;
                 /**
-                 * Reference to {@link test.pkg2.OtherClass1#myMethod(test.pkg2.OtherClass2,int name,test.pkg2.OtherClass2[]) OtherClass1#myMethod(OtherClass2, int name, OtherClass2[])},
+                 * Reference to {@link test.pkg2.OtherClass1#myMethod(test.pkg2.OtherClass2,int name,test.pkg2.OtherClass2[]) OtherClass1.myMethod(OtherClass2, int name, OtherClass2[])},
                  */
                 @SuppressWarnings({"unchecked", "deprecation", "all"})
                 public class Test<E extends test.pkg2.OtherClass2> {
                 public Test() { throw new RuntimeException("Stub!"); }
                 /**
-                 * Reference to {@link test.pkg2.OtherClass1#myMethod(E,int,test.pkg2.OtherClass2[]) OtherClass1#myMethod(E, int, OtherClass2 [])},
+                 * Reference to {@link test.pkg2.OtherClass1#myMethod(E,int,test.pkg2.OtherClass2[]) OtherClass1.myMethod(E, int, OtherClass2 [])},
                  */
                 public void test() { throw new RuntimeException("Stub!"); }
                 }
@@ -1102,7 +1056,7 @@ class JavadocTest : DriverTest() {
                 public Test() { throw new RuntimeException("Stub!"); }
                 /**
                  * Reference to {@link SomethingMissing} and
-                 * {@link java.lang.String#randomMethod String#randomMethod}.
+                 * {@link java.lang.String#randomMethod String.randomMethod}.
                  *
                  * @see OtherMissing
                  */
@@ -1181,8 +1135,8 @@ class JavadocTest : DriverTest() {
                      * @param right New right inset in pixels
                      * @param bottom New bottom inset in pixels
                      * @return A modified copy of this WindowInsets
-                     * @deprecated use {@link android.view.WindowInsets.Builder#Builder(android.view.WindowInsets) Builder#Builder(WindowInsets)} with
-                     *             {@link android.view.WindowInsets.Builder#setSystemWindowInsets(android.graphics.Insets) Builder#setSystemWindowInsets(Insets)} instead.
+                     * @deprecated use {@link android.view.WindowInsets.Builder#Builder(android.view.WindowInsets) Builder.Builder(WindowInsets)} with
+                     *             {@link android.view.WindowInsets.Builder#setSystemWindowInsets(android.graphics.Insets) Builder.setSystemWindowInsets(Insets)} instead.
                      */
                     @Deprecated
                     public android.view.WindowInsets replaceSystemWindowInsets(int left, int top, int right, int bottom) { throw new RuntimeException("Stub!"); }
diff --git a/metalava/src/test/java/com/android/tools/metalava/KeepFileTest.kt b/metalava/src/test/java/com/android/tools/metalava/KeepFileTest.kt
index 4e83a3db9..5b3f33a1f 100644
--- a/metalava/src/test/java/com/android/tools/metalava/KeepFileTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/KeepFileTest.kt
@@ -49,8 +49,8 @@ class KeepFileTest : DriverTest() {
                     @SuppressWarnings("ALL")
                     public interface MyInterface2<T extends Number>
                             extends MyBaseInterface {
-                        class TtsSpan<C extends MyInterface<?>> { }
-                        abstract class Range<T extends Comparable<? super T>> {
+                        public class TtsSpan<C extends MyInterface<?>> { }
+                        public abstract class Range<T extends Comparable<? super T>> {
                             protected String myString;
                         }
                     }
diff --git a/metalava/src/test/java/com/android/tools/metalava/KotlinInteropChecksTest.kt b/metalava/src/test/java/com/android/tools/metalava/KotlinInteropChecksTest.kt
index 01eb9c30a..68ac297a5 100644
--- a/metalava/src/test/java/com/android/tools/metalava/KotlinInteropChecksTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/KotlinInteropChecksTest.kt
@@ -366,4 +366,45 @@ class KotlinInteropChecksTest : DriverTest() {
                 )
         )
     }
+
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `Check value classes are banned`() {
+        check(
+            apiLint = "",
+            expectedIssues =
+                """
+                    src/test/pkg/Container.kt:4: error: Value classes should not be public in APIs targeting Java clients. [ValueClassDefinition]
+                    src/test/pkg/PublicValueClass.kt:3: error: Value classes should not be public in APIs targeting Java clients. [ValueClassDefinition]
+                """,
+            expectedFail = DefaultLintErrorMessage,
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        """
+                            package test.pkg
+                            @JvmInline
+                            value class PublicValueClass(val value: Int)
+                        """
+                    ),
+                    kotlin(
+                        """
+                            package test.pkg
+                            class Container {
+                                @JvmInline
+                                value class PublicNestedValueClass(val value: Int)
+                            }
+                        """
+                    ),
+                    kotlin(
+                        """
+                            package test.pkg
+                            // This is okay, it isn't public API.
+                            @JvmInline
+                            internal value class InternalValueClass(val value: Int)
+                        """
+                    )
+                ),
+        )
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/MainCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/MainCommandTest.kt
index 200fc2494..423966cbe 100644
--- a/metalava/src/test/java/com/android/tools/metalava/MainCommandTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/MainCommandTest.kt
@@ -67,8 +67,6 @@ Options:
                                              min_sdk_version. (default: no manifest)
   --migrate-nullness <api file>              Compare nullness information with the previous stable API and mark newly
                                              annotated APIs as under migration.
-  --hide-sdk-extensions-newer-than INT       Ignore SDK extensions version INT and above. Used to exclude finalized but
-                                             not yet released SDK extensions.
   --typedefs-in-signatures [none|ref|inline]
                                              Whether to include typedef annotations in signature files.
 
@@ -109,6 +107,8 @@ $SIGNATURE_FORMAT_OPTIONS_HELP
 
 $STUB_GENERATION_OPTIONS_HELP
 
+$API_LEVELS_GENERATION_OPTIONS_HELP
+
 Arguments:
   flags                                      See below.
 
@@ -161,12 +161,6 @@ API sources:
                                              Use the given API level
 --jdk-home <dir>
                                              If set, add the Java APIs from the given JDK to the classpath
---stub-packages <package-list>
-                                             List of packages (separated by :) which will be used to filter out
-                                             irrelevant code. If specified, only code in these packages will be included
-                                             in signature files, stubs, etc. (This is not limited to just the stubs; the
-                                             name is historical.) You can also use ".*" at the end to match subpackages,
-                                             so `foo.*` will match both `foo` and `foo.bar`.
 --subtract-api <api file>
                                              Subtracts the API in the given signature or jar file from the current API
                                              being emitted via --api, --stubs, --doc-stubs, etc. Note that the
@@ -229,66 +223,6 @@ Injecting API Levels:
                                              information into the documentation
 
 
-Extracting API Levels:
---generate-api-levels <xmlfile>
-                                             Reads android.jar SDK files and generates an XML file recording the API
-                                             level for each class, method and field
---remove-missing-class-references-in-api-levels
-                                             Removes references to missing classes when generating the API levels XML
-                                             file. This can happen when generating the XML file for the non-updatable
-                                             portions of the module-lib sdk, as those non-updatable portions can
-                                             reference classes that are part of an updatable apex.
---android-jar-pattern <pattern>
-                                             Patterns to use to locate Android JAR files. The default is
-                                             ${"$"}ANDROID_HOME/platforms/android-%/android.jar.
---first-version
-                                             Sets the first API level to generate an API database from; usually 1
---current-version
-                                             Sets the current API level of the current source code
---current-codename
-                                             Sets the code name for the current source code
---current-jar
-                                             Points to the current API jar, if any
---sdk-extensions-root
-                                             Points to root of prebuilt extension SDK jars, if any. This directory is
-                                             expected to contain snapshots of historical extension SDK versions in the
-                                             form of stub jars. The paths should be on the format
-                                             "<int>/public/<module-name>.jar", where <int> corresponds to the extension
-                                             SDK version, and <module-name> to the name of the mainline module.
---sdk-extensions-info
-                                             Points to map of extension SDK APIs to include, if any. The file is a plain
-                                             text file and describes, per extension SDK, what APIs from that extension
-                                             to include in the file created via --generate-api-levels. The format of
-                                             each line is one of the following: "<module-name> <pattern> <ext-name>
-                                             [<ext-name> [...]]", where <module-name> is the name of the mainline module
-                                             this line refers to, <pattern> is a common Java name prefix of the APIs
-                                             this line refers to, and <ext-name> is a list of extension SDK names in
-                                             which these SDKs first appeared, or "<ext-name> <ext-id> <type>", where
-                                             <ext-name> is the name of an SDK, <ext-id> its numerical ID and <type> is
-                                             one of "platform" (the Android platform SDK), "platform-ext" (an extension
-                                             to the Android platform SDK), "standalone" (a separate SDK). Fields are
-                                             separated by whitespace. A mainline module may be listed multiple times.
-                                             The special pattern "*" refers to all APIs in the given mainline module.
-                                             Lines beginning with # are comments.
-
-
-Generating API version history:
---generate-api-version-history <jsonfile>
-                                             Reads API signature files and generates a JSON file recording the API
-                                             version each class, method, and field was added in and (if applicable)
-                                             deprecated in. Required to generate API version JSON.
---api-version-signature-files <files>
-                                             An ordered list of text API signature files. The oldest API version should
-                                             be first, the newest last. This should not include a signature file for the
-                                             current API version, which will be parsed from the provided source files.
-                                             Not required to generate API version JSON if the current version is the
-                                             only version.
---api-version-names <strings>
-                                             An ordered list of strings with the names to use for the API versions from
-                                             --api-version-signature-files, and the name of the current API version.
-                                             Required to generate API version JSON.
-
-
 Environment Variables:
 METALAVA_DUMP_ARGV
                                              Set to true to have metalava emit all the arguments it was invoked with.
@@ -327,11 +261,6 @@ $EXPECTED_HELP
 
     @Test
     fun `Test deprecated lowercase matching in issue configuration options`() {
-        // Temporarily set [options] as it is needed by the [ReporterOptions.reporter] when
-        // reporting [Issues.DEPRECATED_OPTION].
-        @Suppress("DEPRECATION")
-        options = Options()
-
         commandTest {
             args +=
                 listOf(
diff --git a/metalava/src/test/java/com/android/tools/metalava/MarkPackagesAsRecentTest.kt b/metalava/src/test/java/com/android/tools/metalava/MarkPackagesAsRecentTest.kt
index 31ca2b4ee..75578e456 100644
--- a/metalava/src/test/java/com/android/tools/metalava/MarkPackagesAsRecentTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/MarkPackagesAsRecentTest.kt
@@ -1,3 +1,19 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.android.tools.metalava
 
 import com.android.tools.metalava.testing.java
diff --git a/metalava/src/test/java/com/android/tools/metalava/ParameterizedSelectedApiVariantsTest.kt b/metalava/src/test/java/com/android/tools/metalava/ParameterizedSelectedApiVariantsTest.kt
new file mode 100644
index 000000000..f6305ab8f
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/ParameterizedSelectedApiVariantsTest.kt
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava
+
+import com.android.tools.metalava.model.ANDROID_SYSTEM_API
+import com.android.tools.metalava.model.api.surface.ApiVariantType
+import com.android.tools.metalava.model.testing.surfaces.SelectedApiVariantsTestData
+import com.android.tools.metalava.model.testing.surfaces.selectedApiVariantsTestData
+import com.android.tools.metalava.model.text.apiVariantTypeForTestSignatureFile
+import com.android.tools.metalava.testing.createFiles
+import org.junit.Test
+import org.junit.runners.Parameterized
+
+class ParameterizedSelectedApiVariantsTest : DriverTest() {
+
+    @Parameterized.Parameter(0) lateinit var testData: SelectedApiVariantsTestData
+
+    companion object {
+        @JvmStatic @Parameterized.Parameters fun params() = selectedApiVariantsTestData
+    }
+
+    @Test
+    fun `Test previously released codebases`() {
+        // Split the released and removed files into separate lists to pass to the
+        // --check-compatibility:... options.
+        val (previouslyReleasedApi, previouslyRemovedApi) =
+            testData.signatureFiles
+                .createFiles(temporaryFolder.newFolder())
+                .map { it.path }
+                .partition { apiVariantTypeForTestSignatureFile(it) != ApiVariantType.REMOVED }
+
+        // If the test needs a base ApiSurface then add --show-annotation SystemApi to create one.
+        val extraArguments =
+            if (testData.needsBase) arrayOf(ARG_SHOW_ANNOTATION, ANDROID_SYSTEM_API)
+            else emptyArray()
+
+        check(
+            extraArguments = extraArguments,
+            // Although this test is only check the selectedApiVariants state it must provide source
+            // files as otherwise the compatibility check will fail as it will compare the API
+            // loaded from the signature files against an empty Codebase and report that items have
+            // been removed from the API.
+            sourceFiles = testData.javaSourceFiles.toTypedArray(),
+            checkCompatibilityApiReleasedList = previouslyReleasedApi,
+            checkCompatibilityRemovedApiReleasedList = previouslyRemovedApi,
+        ) {
+            val previouslyReleasedCodebase = options.previouslyReleasedCodebase!!
+            previouslyReleasedCodebase.assertSelectedApiVariants(
+                testData.expectedSelectedApiVariants
+            )
+        }
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/PostAnalysisCheckerTest.kt b/metalava/src/test/java/com/android/tools/metalava/PostAnalysisCheckerTest.kt
new file mode 100644
index 000000000..d10f41281
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/PostAnalysisCheckerTest.kt
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava
+
+import com.android.tools.metalava.cli.common.TestEnvironment
+import com.android.tools.metalava.testing.java
+import kotlin.test.assertEquals
+import kotlin.test.assertIs
+import kotlin.test.assertTrue
+import kotlin.test.fail
+import org.junit.Assert.assertThrows
+import org.junit.Test
+
+/** Verify the behavior of the [TestEnvironment.postAnalysisChecker]. */
+class PostAnalysisCheckerTest : DriverTest() {
+
+    @Test
+    fun `Test post analysis check test failure fails the check method`() {
+        val exception =
+            assertThrows(AssertionError::class.java) {
+                check(
+                    sourceFiles =
+                        arrayOf(
+                            java(
+                                """
+                                package test.pkg;
+                                public class Foo {
+                                }
+                            """
+                            ),
+                        ),
+                ) {
+                    fail("Check failure")
+                }
+            }
+
+        assertIs<AssertionError>(exception)
+        assertEquals("Check failure", exception.message)
+    }
+
+    @Test
+    fun `Test post analysis check test passes`() {
+        check(
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            public class Foo {
+                            }
+                        """
+                    ),
+                ),
+        ) {
+            // Check that the options is provided.
+            assertTrue(options.showUnannotated, message = "options.showUnannotated")
+
+            // Check that the codebase is provided.
+            assertEquals(
+                1,
+                codebase.getTopLevelClassesFromSource().count(),
+                message = "top level classes count"
+            )
+        }
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/ProjectDescriptionTest.kt b/metalava/src/test/java/com/android/tools/metalava/ProjectDescriptionTest.kt
index ba34a1843..608ffcd74 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ProjectDescriptionTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ProjectDescriptionTest.kt
@@ -18,6 +18,7 @@ package com.android.tools.metalava
 
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.RequiresCapabilities
+import com.android.tools.metalava.testing.getAndroidJar
 import com.android.tools.metalava.testing.java
 import com.android.tools.metalava.testing.kotlin
 import com.android.tools.metalava.testing.xml
@@ -96,6 +97,7 @@ class ProjectDescriptionTest : DriverTest() {
                           <module name="app" android="true" library="false">
                             <src file="androidMain/src/some/pkg/Foo.kt" />
                             <src file="androidMain/src/test/Bar.java" />
+                            <classpath file="${getAndroidJar()}"/>
                           </module>
                         </project>
                     """
diff --git a/metalava/src/test/java/com/android/tools/metalava/ShowAnnotationTest.kt b/metalava/src/test/java/com/android/tools/metalava/ShowAnnotationTest.kt
index 2148bd189..203e690e5 100644
--- a/metalava/src/test/java/com/android/tools/metalava/ShowAnnotationTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/ShowAnnotationTest.kt
@@ -1,3 +1,19 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package com.android.tools.metalava
 
 import com.android.tools.lint.checks.infrastructure.TestFiles.base64gzip
diff --git a/metalava/src/test/java/com/android/tools/metalava/SignatureInputOutputTest.kt b/metalava/src/test/java/com/android/tools/metalava/SignatureInputOutputTest.kt
index e6edc50a1..4f672fdb0 100644
--- a/metalava/src/test/java/com/android/tools/metalava/SignatureInputOutputTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/SignatureInputOutputTest.kt
@@ -21,17 +21,34 @@ import com.android.tools.metalava.model.Assertions
 import com.android.tools.metalava.model.ClassTypeItem
 import com.android.tools.metalava.model.Codebase
 import com.android.tools.metalava.model.PrimitiveTypeItem
+import com.android.tools.metalava.model.StripJavaLangPrefix
 import com.android.tools.metalava.model.VisibilityLevel
 import com.android.tools.metalava.model.text.ApiFile
 import com.android.tools.metalava.model.text.FileFormat
+import com.android.tools.metalava.model.text.SignatureFile
 import com.android.tools.metalava.model.text.assertSignatureFilesMatch
-import com.android.tools.metalava.model.visitors.ApiVisitor
+import com.android.tools.metalava.model.visitors.ApiPredicate
+import com.android.tools.metalava.model.visitors.ApiType
 import com.google.common.truth.Truth.assertThat
 import java.io.PrintWriter
 import java.io.StringWriter
 import org.junit.Test
 
+/**
+ * Tests [SignatureWriter] and [ApiFile] by round tripping a signature file and make sure that it
+ * matches the original.
+ */
 class SignatureInputOutputTest : Assertions {
+
+    /**
+     * Context against which test code is run.
+     *
+     * Used as it is easier to extend, simpler and more consistent to use than passing a parameter
+     * which requires specifying the parameter name on every use and changing every lambda if new
+     * information is passed.
+     */
+    private data class CodebaseContext(val codebase: Codebase)
+
     /**
      * Parses the API (without a header line, the header from [fileFormat] will be added) from the
      * [signature], runs the [codebaseTest] on the parsed codebase, and then writes the codebase
@@ -42,12 +59,13 @@ class SignatureInputOutputTest : Assertions {
     private fun runInputOutputTest(
         signature: String,
         fileFormat: FileFormat,
-        codebaseTest: (Codebase) -> Unit
+        codebaseTest: CodebaseContext.() -> Unit = {},
     ) {
         val fullSignature = fileFormat.header() + signature
-        val codebase = ApiFile.parseApi("test", fullSignature)
+        val signatureFile = SignatureFile.fromText("test", fullSignature)
+        val codebase = ApiFile.parseApi(listOf(signatureFile))
 
-        codebaseTest(codebase)
+        CodebaseContext(codebase).codebaseTest()
 
         val output =
             StringWriter().use { stringWriter ->
@@ -66,7 +84,7 @@ class SignatureInputOutputTest : Assertions {
                             apiType = ApiType.ALL,
                             preFiltered = true,
                             showUnannotated = false,
-                            apiVisitorConfig = ApiVisitor.Config()
+                            apiPredicateConfig = ApiPredicate.Config()
                         )
 
                     codebase.accept(visitor)
@@ -89,7 +107,7 @@ class SignatureInputOutputTest : Assertions {
             """
                 .trimIndent()
 
-        runInputOutputTest(api, kotlinStyleFormat) { codebase ->
+        runInputOutputTest(api, kotlinStyleFormat) {
             val foo = codebase.assertClass("test.pkg.Foo")
             assertThat(foo.constructors()).hasSize(1)
             val ctor = foo.constructors().single()
@@ -108,7 +126,7 @@ class SignatureInputOutputTest : Assertions {
                 }
             """
                 .trimIndent()
-        runInputOutputTest(api, kotlinStyleFormat) { codebase ->
+        runInputOutputTest(api, kotlinStyleFormat) {
             val foo = codebase.assertClass("test.pkg.Foo")
             assertThat(foo.properties()).hasSize(1)
 
@@ -130,7 +148,7 @@ class SignatureInputOutputTest : Assertions {
                 }
             """
                 .trimIndent()
-        runInputOutputTest(api, kotlinStyleFormat) { codebase ->
+        runInputOutputTest(api, kotlinStyleFormat) {
             val foo = codebase.assertClass("test.pkg.Foo")
             assertThat(foo.fields()).hasSize(1)
 
@@ -153,7 +171,7 @@ class SignatureInputOutputTest : Assertions {
                 }
             """
                 .trimIndent()
-        runInputOutputTest(api, kotlinStyleFormat) { codebase ->
+        runInputOutputTest(api, kotlinStyleFormat) {
             val foo = codebase.assertClass("test.pkg.Foo")
             assertThat(foo.fields()).hasSize(1)
 
@@ -177,7 +195,7 @@ class SignatureInputOutputTest : Assertions {
                 }
             """
                 .trimIndent()
-        runInputOutputTest(api, kotlinStyleFormat) { codebase ->
+        runInputOutputTest(api, kotlinStyleFormat) {
             val foo = codebase.assertClass("test.pkg.Foo")
             assertThat(foo.methods()).hasSize(1)
 
@@ -200,7 +218,7 @@ class SignatureInputOutputTest : Assertions {
                 }
             """
                 .trimIndent()
-        runInputOutputTest(api, kotlinStyleFormat) { codebase ->
+        runInputOutputTest(api, kotlinStyleFormat) {
             val foo = codebase.assertClass("test.pkg.Foo")
             assertThat(foo.methods()).hasSize(1)
 
@@ -228,7 +246,7 @@ class SignatureInputOutputTest : Assertions {
                 }
             """
                 .trimIndent()
-        runInputOutputTest(api, kotlinStyleFormat) { codebase ->
+        runInputOutputTest(api, kotlinStyleFormat) {
             val foo = codebase.assertClass("test.pkg.Foo")
             assertThat(foo.methods()).hasSize(1)
 
@@ -255,7 +273,7 @@ class SignatureInputOutputTest : Assertions {
                 }
             """
                 .trimIndent()
-        runInputOutputTest(api, kotlinStyleFormat) { codebase ->
+        runInputOutputTest(api, kotlinStyleFormat) {
             val foo = codebase.assertClass("test.pkg.Foo")
             val method = foo.methods().single()
 
@@ -279,7 +297,7 @@ class SignatureInputOutputTest : Assertions {
                 }
             """
                 .trimIndent()
-        runInputOutputTest(api, kotlinStyleFormat) { codebase ->
+        runInputOutputTest(api, kotlinStyleFormat) {
             val foo = codebase.assertClass("test.pkg.Foo")
             val method = foo.methods().single()
 
@@ -307,7 +325,7 @@ class SignatureInputOutputTest : Assertions {
                 }
             """
                 .trimIndent()
-        runInputOutputTest(api, format) { codebase ->
+        runInputOutputTest(api, format) {
             val foo = codebase.assertClass("test.pkg.Foo")
             val method = foo.methods().single()
 
@@ -335,7 +353,7 @@ class SignatureInputOutputTest : Assertions {
                 }
             """
                 .trimIndent()
-        runInputOutputTest(api, kotlinStyleFormat) { codebase ->
+        runInputOutputTest(api, kotlinStyleFormat) {
             val foo = codebase.assertClass("test.pkg.Foo")
             val method = foo.methods().single()
 
@@ -362,7 +380,7 @@ class SignatureInputOutputTest : Assertions {
                 }
             """
                     .trimIndent()
-        runInputOutputTest(api, kotlinStyleFormat) { codebase ->
+        runInputOutputTest(api, kotlinStyleFormat) {
             val foo = codebase.assertClass("test.pkg.Foo")
             val method = foo.methods().single()
 
@@ -386,7 +404,7 @@ class SignatureInputOutputTest : Assertions {
                 }
             """
                 .trimIndent()
-        runInputOutputTest(api, kotlinStyleFormat) { codebase ->
+        runInputOutputTest(api, kotlinStyleFormat) {
             val foo = codebase.assertClass("test.pkg.Foo")
             val method = foo.methods().single()
 
@@ -410,7 +428,7 @@ class SignatureInputOutputTest : Assertions {
                 }
             """
                 .trimIndent()
-        runInputOutputTest(api, kotlinStyleFormat) { codebase ->
+        runInputOutputTest(api, kotlinStyleFormat) {
             val foo = codebase.assertClass("test.pkg.Foo")
             val method = foo.methods().single()
 
@@ -452,7 +470,7 @@ class SignatureInputOutputTest : Assertions {
                 }
             """
                 .trimIndent()
-        runInputOutputTest(api, kotlinStyleFormat) { codebase ->
+        runInputOutputTest(api, kotlinStyleFormat) {
             val foo = codebase.assertClass("test.pkg.Foo")
             val method = foo.methods().single()
 
@@ -495,7 +513,7 @@ class SignatureInputOutputTest : Assertions {
                 }
             """
                 .trimIndent()
-        runInputOutputTest(api, format) { codebase ->
+        runInputOutputTest(api, format) {
             val method = codebase.assertClass("test.pkg.MyTest").methods().single()
             // Return type has platform nullability
             assertThat(method.returnType().modifiers.isPlatformNullability).isTrue()
@@ -530,7 +548,7 @@ class SignatureInputOutputTest : Assertions {
                 }
             """
                 .trimIndent()
-        runInputOutputTest(api, format) { codebase ->
+        runInputOutputTest(api, format) {
             val fooClass = codebase.assertClass("test.pkg.Foo")
             val superClassType = fooClass.superClassType()
             assertThat(superClassType!!.modifiers.annotations.map { it.qualifiedName })
@@ -551,7 +569,7 @@ class SignatureInputOutputTest : Assertions {
                 }
             """
                 .trimIndent()
-        runInputOutputTest(api, kotlinStyleFormat) {}
+        runInputOutputTest(api, kotlinStyleFormat)
     }
 
     @Test
@@ -564,7 +582,86 @@ class SignatureInputOutputTest : Assertions {
                 }
             """
                 .trimIndent()
-        runInputOutputTest(api, kotlinStyleFormat) {}
+        runInputOutputTest(api, kotlinStyleFormat)
+    }
+
+    /**
+     * Make sure that despite the `java.lang.` prefix being stripped from various types when writing
+     * the signature file that they have the correct type when the [Codebase] is loaded.
+     */
+    private fun checkStrippedCodebaseTypes(codebase: Codebase) {
+        val fooClass = codebase.assertClass("test.pkg.Foo")
+        val superTypes = listOfNotNull(fooClass.superClassType()) + fooClass.interfaceTypes()
+        assertThat(superTypes.joinToString { it.toTypeString() })
+            .isEqualTo(
+                "java.util.AbstractList<java.lang.String>, java.lang.Comparable<java.lang.String>, kotlin.collections.List<java.lang.String>"
+            )
+
+        val fooMethod = fooClass.methods().single()
+        assertThat(fooMethod.returnType().toTypeString()).isEqualTo("java.lang.String")
+        assertThat(fooMethod.parameters().single().type().toTypeString())
+            .isEqualTo("java.lang.String...")
+        assertThat(fooMethod.throwsTypes().single().toTypeString()).isEqualTo("java.lang.Exception")
+    }
+
+    @Test
+    fun `Test strip-java-lang-prefix=never`() {
+        val api =
+            """
+                // Signature format: 2.0
+                package test.pkg {
+                  public class Foo extends java.util.AbstractList<java.lang.String> implements java.lang.Comparable<java.lang.String> kotlin.collections.List<java.lang.String> {
+                    method public java.lang.String foo(java.lang.String...) throws java.lang.Exception;
+                  }
+                }
+            """
+                .trimIndent()
+        runInputOutputTest(
+            api,
+            FileFormat.V2.copy(specifiedStripJavaLangPrefix = StripJavaLangPrefix.NEVER)
+        ) {
+            checkStrippedCodebaseTypes(codebase)
+        }
+    }
+
+    @Test
+    fun `Test strip-java-lang-prefix=legacy`() {
+        val api =
+            """
+                // Signature format: 2.0
+                package test.pkg {
+                  public class Foo extends java.util.AbstractList<java.lang.String> implements java.lang.Comparable<java.lang.String> kotlin.collections.List<java.lang.String> {
+                    method public String foo(java.lang.String...) throws java.lang.Exception;
+                  }
+                }
+            """
+                .trimIndent()
+        runInputOutputTest(
+            api,
+            FileFormat.V2.copy(specifiedStripJavaLangPrefix = StripJavaLangPrefix.LEGACY)
+        ) {
+            checkStrippedCodebaseTypes(codebase)
+        }
+    }
+
+    @Test
+    fun `Test strip-java-lang-prefix=always`() {
+        val api =
+            """
+                // Signature format: 2.0
+                package test.pkg {
+                  public abstract class Foo extends java.util.AbstractList<String> implements Comparable<String> kotlin.collections.List<String> {
+                    method public String foo(String...) throws Exception;
+                  }
+                }
+            """
+                .trimIndent()
+        runInputOutputTest(
+            api,
+            FileFormat.V2.copy(specifiedStripJavaLangPrefix = StripJavaLangPrefix.ALWAYS)
+        ) {
+            checkStrippedCodebaseTypes(codebase)
+        }
     }
 
     companion object {
diff --git a/metalava/src/test/java/com/android/tools/metalava/UastTestBase.kt b/metalava/src/test/java/com/android/tools/metalava/UastTestBase.kt
index abf8a1b39..751475f16 100644
--- a/metalava/src/test/java/com/android/tools/metalava/UastTestBase.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/UastTestBase.kt
@@ -215,7 +215,7 @@ abstract class UastTestBase : DriverTest() {
                     method public test.pkg.Foo copy(@test.pkg.MyAnnotation int p1, String p2);
                     method public int getP1();
                     method public String getP2();
-                    property public final int p1;
+                    property @test.pkg.MyAnnotation public final int p1;
                     property public final String p2;
                   }
                   @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME) public @interface MyAnnotation {
@@ -230,6 +230,9 @@ abstract class UastTestBase : DriverTest() {
         // https://youtrack.jetbrains.com/issue/KT-57546
         // https://youtrack.jetbrains.com/issue/KT-57577
         val mod = if (isK2) "" else " final"
+        // https://youtrack.jetbrains.com/issue/KT-72078
+        val horizontalType = if (isK2) "test.pkg.Alignment.Horizontal" else "int"
+        val verticalType = if (isK2) "test.pkg.Alignment.Vertical" else "int"
         check(
             sourceFiles =
                 arrayOf(
@@ -284,7 +287,7 @@ abstract class UastTestBase : DriverTest() {
                 """
                 package test.pkg {
                   public final class Alignment {
-                    ctor public Alignment(int horizontal, int vertical);
+                    ctor public Alignment($horizontalType horizontal, $verticalType vertical);
                     method public int getHorizontal();
                     method public int getVertical();
                     property public$mod int horizontal;
@@ -1036,6 +1039,9 @@ abstract class UastTestBase : DriverTest() {
                     field public static final int NO_ERROR = -1; // 0xffffffff
                   }
                   public static final class RemoteAuthClient.Companion {
+                    property public static final int ERROR_PHONE_UNAVAILABLE;
+                    property public static final int ERROR_UNSUPPORTED;
+                    property public static final int NO_ERROR;
                   }
                   @kotlin.annotation.Retention(kotlin.annotation.AnnotationRetention.SOURCE) @test.pkg.MyIntDef({test.pkg.RemoteAuthClient.NO_ERROR, test.pkg.RemoteAuthClient.ERROR_UNSUPPORTED, test.pkg.RemoteAuthClient.ERROR_PHONE_UNAVAILABLE}) public static @interface RemoteAuthClient.Companion.ErrorCode {
                   }
@@ -1103,7 +1109,7 @@ abstract class UastTestBase : DriverTest() {
                         method @Deprecated public void setPOld_accessors_deprecatedOnSetter(String?);
                         property public final String? pNew_accessors;
                         property @Deprecated public String? pOld_accessors_deprecatedOnGetter;
-                        property public String? pOld_accessors_deprecatedOnProperty;
+                        property @Deprecated public String? pOld_accessors_deprecatedOnProperty;
                         property public final String? pOld_accessors_deprecatedOnSetter;
                       }
                       public final class Test_getter {
@@ -1118,7 +1124,7 @@ abstract class UastTestBase : DriverTest() {
                         method @Deprecated public void setPOld_getter_deprecatedOnSetter(String?);
                         property public final String? pNew_getter;
                         property @Deprecated public String? pOld_getter_deprecatedOnGetter;
-                        property public String? pOld_getter_deprecatedOnProperty;
+                        property @Deprecated public String? pOld_getter_deprecatedOnProperty;
                         property public final String? pOld_getter_deprecatedOnSetter;
                       }
                       public final class Test_noAccessor {
@@ -1183,6 +1189,10 @@ abstract class UastTestBase : DriverTest() {
                         property @Deprecated @test.pkg.MyAnnotation @test.pkg.MyAnnotation public int pOld_deprecatedOnProperty_myAnnoOnBoth;
                         property @Deprecated @test.pkg.MyAnnotation public int pOld_deprecatedOnProperty_myAnnoOnGetter;
                         property @Deprecated @test.pkg.MyAnnotation public int pOld_deprecatedOnProperty_myAnnoOnSetter;
+                        property public int pOld_deprecatedOnSetter;
+                        property public int pOld_deprecatedOnSetter_myAnnoOnBoth;
+                        property public int pOld_deprecatedOnSetter_myAnnoOnGetter;
+                        property public int pOld_deprecatedOnSetter_myAnnoOnSetter;
                       }
                       public final class Test_accessors {
                         ctor public Test_accessors();
@@ -1194,7 +1204,8 @@ abstract class UastTestBase : DriverTest() {
                         method @Deprecated public void setPOld_accessors_deprecatedOnSetter(String?);
                         property public final String? pNew_accessors;
                         property @Deprecated public String? pOld_accessors_deprecatedOnGetter;
-                        property public String? pOld_accessors_deprecatedOnProperty;
+                        property @Deprecated public String? pOld_accessors_deprecatedOnProperty;
+                        property public final String? pOld_accessors_deprecatedOnSetter;
                       }
                       public final class Test_getter {
                         ctor public Test_getter();
@@ -1206,7 +1217,8 @@ abstract class UastTestBase : DriverTest() {
                         method @Deprecated public void setPOld_getter_deprecatedOnSetter(String?);
                         property public final String? pNew_getter;
                         property @Deprecated public String? pOld_getter_deprecatedOnGetter;
-                        property public String? pOld_getter_deprecatedOnProperty;
+                        property @Deprecated public String? pOld_getter_deprecatedOnProperty;
+                        property public final String? pOld_getter_deprecatedOnSetter;
                       }
                       public final class Test_noAccessor {
                         ctor public Test_noAccessor();
@@ -1219,6 +1231,7 @@ abstract class UastTestBase : DriverTest() {
                         property public final String pNew_noAccessor;
                         property @Deprecated public String pOld_noAccessor_deprecatedOnGetter;
                         property @Deprecated public String pOld_noAccessor_deprecatedOnProperty;
+                        property public final String pOld_noAccessor_deprecatedOnSetter;
                       }
                       public final class Test_setter {
                         ctor public Test_setter();
@@ -1231,6 +1244,7 @@ abstract class UastTestBase : DriverTest() {
                         property public final String? pNew_setter;
                         property @Deprecated public String? pOld_setter_deprecatedOnGetter;
                         property @Deprecated public String? pOld_setter_deprecatedOnProperty;
+                        property public final String? pOld_setter_deprecatedOnSetter;
                       }
                     }
                 """
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiGeneratorIntegrationTestBase.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiGeneratorIntegrationTestBase.kt
index d282e6da2..b21f4bdbd 100644
--- a/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiGeneratorIntegrationTestBase.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiGeneratorIntegrationTestBase.kt
@@ -20,23 +20,90 @@ import com.android.sdklib.SdkVersionInfo
 import com.android.tools.lint.detector.api.ApiConstraint
 import com.android.tools.metalava.DriverTest
 import java.io.File
+import java.util.regex.Pattern
 import org.junit.Assert
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertTrue
+import org.junit.Before
 import org.junit.BeforeClass
 
 abstract class ApiGeneratorIntegrationTestBase : DriverTest() {
+
+    val androidPublicJarsPattern = "${platformJars.path}/%/public/android.jar"
+
+    protected fun createSdkExtensionInfoFile(): File {
+        val file = File.createTempFile("filter", "txt")
+        file.deleteOnExit()
+        file.writeText(
+            """
+                <sdk-extensions-info>
+                <!-- SDK definitions -->
+                <sdk shortname="R" name="R Extensions" id="30" reference="android/os/Build${'$'}VERSION_CODES${'$'}R" />
+                <sdk shortname="S" name="S Extensions" id="31" reference="android/os/Build${'$'}VERSION_CODES${'$'}S" />
+                <sdk shortname="T" name="T Extensions" id="33" reference="android/os/Build${'$'}VERSION_CODES${'$'}T" />
+
+                <!-- Rules -->
+                <symbol jar="art.module.public.api" pattern="*" sdks="R" />
+                <symbol jar="conscrypt.module.intra.core.api " pattern="" sdks="R" />
+                <symbol jar="conscrypt.module.platform.api" pattern="*" sdks="R" />
+                <symbol jar="conscrypt.module.public.api" pattern="*" sdks="R" />
+                <symbol jar="framework-mediaprovider" pattern="*" sdks="R" />
+                <symbol jar="framework-mediaprovider" pattern="android.provider.MediaStore#canManageMedia" sdks="T" />
+                <symbol jar="framework-permission-s" pattern="*" sdks="R" />
+                <symbol jar="framework-permission" pattern="*" sdks="R" />
+                <symbol jar="framework-sdkextensions" pattern="*" sdks="R" />
+                <symbol jar="framework-scheduling" pattern="*" sdks="R" />
+                <symbol jar="framework-statsd" pattern="*" sdks="R" />
+                <symbol jar="framework-tethering" pattern="*" sdks="R" />
+                <symbol jar="legacy.art.module.platform.api" pattern="*" sdks="R" />
+                <symbol jar="service-media-s" pattern="*" sdks="R" />
+                <symbol jar="service-permission" pattern="*" sdks="R" />
+
+                <!-- use framework-permissions-s to test the order of multiple SDKs is respected -->
+                <symbol jar="android.net.ipsec.ike" pattern="android.net.eap.EapAkaInfo" sdks="R,S,T" />
+                <symbol jar="android.net.ipsec.ike" pattern="android.net.eap.EapInfo" sdks="T,S,R" />
+                <symbol jar="android.net.ipsec.ike" pattern="*" sdks="R" />
+
+                <!-- framework-connectivity: only android.net.CaptivePortal should have the 'sdks' attribute -->
+                <symbol jar="framework-connectivity" pattern="android.net.CaptivePortalData" sdks="R" />
+
+                <!-- framework-media explicitly omitted: nothing in this module should have the 'sdks' attribute -->
+                </sdk-extensions-info>
+            """
+                .trimIndent()
+        )
+        return file
+    }
+
+    /**
+     * Extracts the section for the class with [internalName] and compares it against [expected].
+     *
+     * Before comparing it will replace tabs with 4 spaces and trim any indent.
+     */
+    fun String.checkClass(internalName: String, expected: String) {
+        val pattern =
+            Pattern.compile(
+                "^\\s*<class name=\"${internalName}\".*?</class>",
+                Pattern.DOTALL or Pattern.MULTILINE
+            )
+        val matcher = pattern.matcher(this)
+        assertTrue("could not find entry for $internalName", matcher.find())
+        val extract = matcher.group().replace("\t", "    ")
+        assertEquals(expected.trimIndent(), extract.trimIndent())
+    }
+
     companion object {
-        // As per ApiConstraint that uses a bit vector, API has to be between 1..61.
-        internal const val MAGIC_VERSION_INT = 57 // [SdkVersionInfo.MAX_LEVEL] - 4
+        // A version higher than SdkVersionInfo.HIGHEST_KNOWN_API.
+        // 57 was chosen because previously ApiConstraint used a bit vector requiring that an API
+        // version had to be between 1..61.
+        internal const val MAGIC_VERSION_INT = 57
         internal const val MAGIC_VERSION_STR = MAGIC_VERSION_INT.toString()
+        private val ABOVE_HIGHEST_API = ApiConstraint.above(SdkVersionInfo.HIGHEST_KNOWN_API)
 
         @JvmStatic
         @BeforeClass
         fun beforeClass() {
-            assert(MAGIC_VERSION_INT > SdkVersionInfo.HIGHEST_KNOWN_API)
-            // Trigger <clinit> of [SdkApiConstraint] to call `isValidApiLevel` in its companion
-            ApiConstraint.UNKNOWN
-            // This checks if MAGIC_VERSION_INT is not bigger than [SdkVersionInfo.MAX_LEVEL]
-            assert(ApiConstraint.SdkApiConstraint.isValidApiLevel(MAGIC_VERSION_INT))
+            assert(ABOVE_HIGHEST_API.includes(MAGIC_VERSION_INT))
         }
 
         internal val oldSdkJars by
@@ -66,4 +133,16 @@ abstract class ApiGeneratorIntegrationTestBase : DriverTest() {
                 }
             }
     }
+
+    /** The output file into which the API version history will be written. */
+    protected lateinit var output: File
+
+    /** The path of [output]. */
+    protected lateinit var outputPath: String
+
+    @Before
+    fun setUp() {
+        output = temporaryFolder.newFile("api-info.xml")
+        outputPath = output.path
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiGeneratorTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiGeneratorTest.kt
index bea69bb1d..9b4a885bb 100644
--- a/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiGeneratorTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiGeneratorTest.kt
@@ -35,15 +35,45 @@ import com.google.common.truth.Truth.assertThat
 import com.google.gson.GsonBuilder
 import com.google.gson.JsonElement
 import java.io.File
-import kotlin.text.Charsets.UTF_8
 import org.junit.Assert.assertEquals
 import org.junit.Assert.assertNotNull
 import org.junit.Assert.assertTrue
 import org.junit.Assert.fail
 import org.junit.Test
 
+// Constants to avoid having to quote $ in expected XML contents.
+const val VERSION_CODES = "${'\$'}VERSION_CODES"
+const val R = "${'\$'}R"
+const val S = "${'\$'}S"
+
 class ApiGeneratorTest : DriverTest() {
 
+    /** Check this `api-versions.xml` file has the correct content. */
+    private fun File.checkApiVersionsXmlContent(expectedContent: String) {
+        assertTrue("$this was expected to be a plain file but is not", isFile)
+        val xml = readText()
+
+        // The generated XML is indented using tabs which do not work well in a raw string as
+        // editors can replace them with normal spaces. So, this replaces all tabs with 4 spaces.
+        val indentedWithSpaces = xml.replace("\t", "    ").trim()
+        assertEquals(expectedContent.trimIndent(), indentedWithSpaces)
+    }
+
+    /** Check this `api-versions.json` file has the correct content. */
+    private fun File.checkApiVersionsJsonContent(expectedContent: String) {
+        assertTrue("$this was expected to be a plain file but is not", isFile)
+        val json = readText()
+
+        // Read output and reprint with pretty printing enabled to make test failures easier to read
+        val gson = GsonBuilder().disableHtmlEscaping().setPrettyPrinting().create()
+        val outputJson = gson.fromJson(json, JsonElement::class.java)
+        val prettyOutput = gson.toJson(outputJson)
+
+        assertEquals(expectedContent.trimIndent(), prettyOutput)
+    }
+
+    // TODO(b/378479241): Fix this test to make it more realistic by including definitions of the
+    //  current API or stopping it from including the current API.
     @Test
     fun `Generate API for test prebuilts`() {
         val testPrebuiltsRoot = File(System.getenv("METALAVA_TEST_PREBUILTS_SDK_ROOT"))
@@ -71,6 +101,10 @@ class ApiGeneratorTest : DriverTest() {
                     ARG_CURRENT_CODENAME,
                     "Foo"
                 ),
+            // Apply the api-versions.xml file that is being generated by this.
+            applyApiLevelsXml = apiVersionsXml.path,
+            // Do not prevent java.lang.Object from being included in the API.
+            skipEmitPackages = emptyList(),
             sourceFiles =
                 arrayOf(
                     java(
@@ -85,143 +119,108 @@ class ApiGeneratorTest : DriverTest() {
                         public void methodNotFinalized() { throw new RuntimeException("Stub!"); }
                     }
                     """
-                    )
-                )
-        )
-
-        assertTrue(apiVersionsXml.isFile)
-        val xml = apiVersionsXml.readText(UTF_8)
-
-        val expected =
-            """
-            <?xml version="1.0" encoding="utf-8"?>
-            <api version="3" min="30">
-                <sdk id="30" shortname="R-ext" name="R Extensions" reference="android/os/Build${'$'}VERSION_CODES${'$'}R"/>
-                <sdk id="31" shortname="S-ext" name="S Extensions" reference="android/os/Build${'$'}VERSION_CODES${'$'}S"/>
-                <class name="android/test/ClassAddedAndDeprecatedInApi30" since="30" deprecated="30">
-                <extends name="java/lang/Object"/>
-                <method name="&lt;init>(F)V"/>
-                <method name="&lt;init>(I)V"/>
-                <method name="methodExplicitlyDeprecated()V"/>
-                <method name="methodImplicitlyDeprecated()V"/>
-                <field name="FIELD_EXPLICITLY_DEPRECATED"/>
-                <field name="FIELD_IMPLICITLY_DEPRECATED"/>
-                </class>
-                <class name="android/test/ClassAddedInApi30" since="30">
-                    <extends name="java/lang/Object"/>
-                    <method name="methodAddedInApi30()V"/>
-                    <method name="methodAddedInApi31()V" since="31"/>
-                </class>
-                <class name="android/test/ClassAddedInApi31AndExt2" module="framework-ext" since="31" sdks="30:2,31:2,0:31">
-                    <extends name="java/lang/Object"/>
-                    <method name="methodAddedInApi31AndExt2()V"/>
-                    <method name="methodAddedInExt3()V" since="33" sdks="30:3,31:3"/>
-                    <method name="methodNotFinalized()V" since="33" sdks="0:33"/>
-                    <field name="FIELD_ADDED_IN_API_31_AND_EXT_2"/>
-                    <field name="FIELD_ADDED_IN_EXT_3" since="33" sdks="30:3,31:3"/>
-                </class>
-                <class name="android/test/ClassAddedInExt1" module="framework-ext" since="31" sdks="30:1,31:1,0:31">
-                    <extends name="java/lang/Object"/>
-                    <method name="methodAddedInApi31AndExt2()V" sdks="30:2,31:2,0:31"/>
-                    <method name="methodAddedInExt1()V"/>
-                    <method name="methodAddedInExt3()V" since="33" sdks="30:3,31:3"/>
-                    <field name="FIELD_ADDED_IN_API_31_AND_EXT_2" sdks="30:2,31:2,0:31"/>
-                    <field name="FIELD_ADDED_IN_EXT_1"/>
-                    <field name="FIELD_ADDED_IN_EXT_3" since="33" sdks="30:3,31:3"/>
-                </class>
-                <class name="android/test/ClassAddedInExt3" module="framework-ext" since="33" sdks="30:3,31:3">
-                    <extends name="java/lang/Object"/>
-                    <method name="methodAddedInExt3()V"/>
-                    <field name="FIELD_ADDED_IN_EXT_3"/>
-                </class>
-                <class name="java/lang/Object" since="30">
-                    <method name="&lt;init>()V"/>
-                </class>
-            </api>
-        """
-
-        fun String.trimEachLine(): String =
-            lines().map { it.trim() }.filter { it.isNotEmpty() }.joinToString("\n")
-
-        assertEquals(expected.trimEachLine(), xml.trimEachLine())
-    }
-
-    @Test
-    fun `Generate API for test prebuilts skip SDK extensions 3+`() {
-        val testPrebuiltsRoot = File(System.getenv("METALAVA_TEST_PREBUILTS_SDK_ROOT"))
-        if (!testPrebuiltsRoot.isDirectory) {
-            fail("test prebuilts not found: $testPrebuiltsRoot")
-        }
-
-        val apiVersionsXml = temporaryFolder.newFile("api-versions.xml")
-
-        check(
-            extraArguments =
+                    ),
+                    java(
+                        """
+                            package java.lang;
+                            public class Object {
+                            }
+                        """
+                    ),
+                ),
+            docStubs = true,
+            stubFiles =
                 arrayOf(
-                    ARG_GENERATE_API_LEVELS,
-                    apiVersionsXml.path,
-                    ARG_ANDROID_JAR_PATTERN,
-                    "${testPrebuiltsRoot.path}/%/public/android.jar",
-                    ARG_SDK_JAR_ROOT,
-                    "${testPrebuiltsRoot.path}/extensions",
-                    ARG_SDK_INFO_FILE,
-                    "${testPrebuiltsRoot.path}/sdk-extensions-info.xml",
-                    ARG_FIRST_VERSION,
-                    "30",
-                    ARG_CURRENT_VERSION,
-                    "32",
-                    ARG_CURRENT_CODENAME,
-                    "Foo",
-                    "--hide-sdk-extensions-newer-than",
-                    "2",
+                    java(
+                        """
+                            package android.test;
+                            /**
+                             * @apiSince 31
+                             * @sdkExtSince R Extensions 2
+                             */
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public class ClassAddedInApi31AndExt2 {
+                            ClassAddedInApi31AndExt2() { throw new RuntimeException("Stub!"); }
+                            /**
+                             * @apiSince 31
+                             * @sdkExtSince R Extensions 2
+                             */
+                            public void methodAddedInApi31AndExt2() { throw new RuntimeException("Stub!"); }
+                            /** @sdkExtSince R Extensions 3 */
+                            public void methodAddedInExt3() { throw new RuntimeException("Stub!"); }
+                            /** @apiSince Foo */
+                            public void methodNotFinalized() { throw new RuntimeException("Stub!"); }
+                            /**
+                             * @apiSince 31
+                             * @sdkExtSince R Extensions 2
+                             */
+                            public static final int FIELD_ADDED_IN_API_31_AND_EXT_2 = 1; // 0x1
+                            /** @sdkExtSince R Extensions 3 */
+                            public static final int FIELD_ADDED_IN_EXT_3 = 2; // 0x2
+                            }
+                        """
+                    ),
                 ),
         )
 
-        assertTrue(apiVersionsXml.isFile)
-        val xml = apiVersionsXml.readText(UTF_8)
-
         val expected =
             """
-            <?xml version="1.0" encoding="utf-8"?>
-            <api version="3" min="30">
-                <sdk id="30" shortname="R-ext" name="R Extensions" reference="android/os/Build${'$'}VERSION_CODES${'$'}R"/>
-                <sdk id="31" shortname="S-ext" name="S Extensions" reference="android/os/Build${'$'}VERSION_CODES${'$'}S"/>
-                <class name="android/test/ClassAddedAndDeprecatedInApi30" since="30" deprecated="30">
-                <extends name="java/lang/Object"/>
-                <method name="&lt;init>(F)V"/>
-                <method name="&lt;init>(I)V"/>
-                <method name="methodExplicitlyDeprecated()V"/>
-                <method name="methodImplicitlyDeprecated()V"/>
-                <field name="FIELD_EXPLICITLY_DEPRECATED"/>
-                <field name="FIELD_IMPLICITLY_DEPRECATED"/>
-                </class>
-                <class name="android/test/ClassAddedInApi30" since="30">
-                    <extends name="java/lang/Object"/>
-                    <method name="methodAddedInApi30()V"/>
-                    <method name="methodAddedInApi31()V" since="31"/>
-                </class>
-                <class name="android/test/ClassAddedInApi31AndExt2" module="framework-ext" since="31" sdks="30:2,31:2,0:31">
-                    <extends name="java/lang/Object"/>
-                    <method name="methodAddedInApi31AndExt2()V"/>
-                    <field name="FIELD_ADDED_IN_API_31_AND_EXT_2"/>
-                </class>
-                <class name="android/test/ClassAddedInExt1" module="framework-ext" since="31" sdks="30:1,31:1,0:31">
-                    <extends name="java/lang/Object"/>
-                    <method name="methodAddedInApi31AndExt2()V" sdks="30:2,31:2,0:31"/>
-                    <method name="methodAddedInExt1()V"/>
-                    <field name="FIELD_ADDED_IN_API_31_AND_EXT_2" sdks="30:2,31:2,0:31"/>
-                    <field name="FIELD_ADDED_IN_EXT_1"/>
-                </class>
-                <class name="java/lang/Object" since="30">
-                    <method name="&lt;init>()V"/>
-                </class>
-            </api>
-        """
-
-        fun String.trimEachLine(): String =
-            lines().map { it.trim() }.filter { it.isNotEmpty() }.joinToString("\n")
+                <?xml version="1.0" encoding="utf-8"?>
+                <api version="3" min="30">
+                    <sdk id="30" shortname="R-ext" name="R Extensions" reference="android/os/Build$VERSION_CODES$R"/>
+                    <sdk id="31" shortname="S-ext" name="S Extensions" reference="android/os/Build$VERSION_CODES$S"/>
+                    <class name="android/test/ClassAddedAndDeprecatedInApi30" since="30" deprecated="30" removed="33">
+                        <extends name="java/lang/Object"/>
+                        <method name="&lt;init>(F)V"/>
+                        <method name="&lt;init>(I)V"/>
+                        <method name="methodExplicitlyDeprecated()V"/>
+                        <method name="methodImplicitlyDeprecated()V"/>
+                        <field name="FIELD_EXPLICITLY_DEPRECATED"/>
+                        <field name="FIELD_IMPLICITLY_DEPRECATED"/>
+                    </class>
+                    <class name="android/test/ClassAddedInApi30" module="framework-ext" since="30" sdks="30:2,0:30">
+                        <extends name="android/test/MarkerSuperClass" since="33" sdks="30:2,31:2"/>
+                        <extends name="java/lang/Object" removed="33"/>
+                        <implements name="android/test/MarkerInterface" since="33" sdks="30:2,31:2"/>
+                        <method name="methodAddedInApi30()V"/>
+                        <method name="methodAddedInApi31()V" since="31" sdks="30:2,31:2,0:31"/>
+                    </class>
+                    <class name="android/test/ClassAddedInApi31AndExt2" module="framework-ext" since="31" sdks="30:2,31:2,0:31">
+                        <extends name="java/lang/Object"/>
+                        <method name="methodAddedInApi31AndExt2()V"/>
+                        <method name="methodAddedInExt3()V" since="33" sdks="30:3,31:3"/>
+                        <method name="methodNotFinalized()V" since="33" sdks="0:33"/>
+                        <field name="FIELD_ADDED_IN_API_31_AND_EXT_2"/>
+                        <field name="FIELD_ADDED_IN_EXT_3" since="33" sdks="30:3,31:3"/>
+                    </class>
+                    <class name="android/test/ClassAddedInExt1" module="framework-ext" since="31" sdks="30:1,31:1,0:31">
+                        <extends name="java/lang/Object"/>
+                        <method name="methodAddedInApi31AndExt2()V" sdks="30:2,31:2,0:31"/>
+                        <method name="methodAddedInExt1()V"/>
+                        <method name="methodAddedInExt3()V" since="33" sdks="30:3,31:3"/>
+                        <field name="FIELD_ADDED_IN_API_31_AND_EXT_2" sdks="30:2,31:2,0:31"/>
+                        <field name="FIELD_ADDED_IN_EXT_1"/>
+                        <field name="FIELD_ADDED_IN_EXT_3" since="33" sdks="30:3,31:3"/>
+                    </class>
+                    <class name="android/test/ClassAddedInExt3" module="framework-ext" since="33" sdks="30:3,31:3">
+                        <extends name="java/lang/Object"/>
+                        <method name="methodAddedInExt3()V"/>
+                        <field name="FIELD_ADDED_IN_EXT_3"/>
+                    </class>
+                    <class name="android/test/MarkerInterface" module="framework-ext" since="33" sdks="30:2,31:2">
+                        <extends name="java/lang/Object"/>
+                    </class>
+                    <class name="android/test/MarkerSuperClass" module="framework-ext" since="33" sdks="30:2,31:2">
+                        <extends name="java/lang/Object"/>
+                        <method name="&lt;init>()V"/>
+                    </class>
+                    <class name="java/lang/Object" since="30">
+                        <method name="&lt;init>()V"/>
+                    </class>
+                </api>
+            """
 
-        assertEquals(expected.trimEachLine(), xml.trimEachLine())
+        apiVersionsXml.checkApiVersionsXmlContent(expected)
     }
 
     @Test
@@ -253,9 +252,6 @@ class ApiGeneratorTest : DriverTest() {
                 )
         )
 
-        assertTrue(apiVersionsXml.isFile)
-        val xml = apiVersionsXml.readText(UTF_8)
-
         val expected =
             """
             <?xml version="1.0" encoding="utf-8"?>
@@ -266,10 +262,7 @@ class ApiGeneratorTest : DriverTest() {
             </api>
         """
 
-        fun String.trimEachLine(): String =
-            lines().map { it.trim() }.filter { it.isNotEmpty() }.joinToString("\n")
-
-        assertEquals(expected.trimEachLine(), xml.trimEachLine())
+        apiVersionsXml.checkApiVersionsXmlContent(expected)
     }
 
     @Test
@@ -326,7 +319,7 @@ class ApiGeneratorTest : DriverTest() {
     }
 
     @Test
-    fun `Create API levels from signature files`() {
+    fun `Create JSON and XML API versions from signature files`() {
         val pastVersions =
             listOf(
                 createTextFile(
@@ -393,28 +386,24 @@ class ApiGeneratorTest : DriverTest() {
                 }
             """
 
-        val output = temporaryFolder.newFile("api-info.json")
+        val apiVersionsJson = temporaryFolder.newFile("api-info.json")
+
+        fun createExtraArguments(output: File) =
+            arrayOf(
+                ARG_GENERATE_API_VERSION_HISTORY,
+                output.path,
+                ARG_API_VERSION_SIGNATURE_FILES,
+                pastVersions.joinToString(":") { it.absolutePath },
+                ARG_API_VERSION_NAMES,
+                listOf("1.1.0", "1.2.0", "1.3.0", "1.4.0").joinToString(" "),
+            )
 
         check(
             signatureSource = currentVersion,
-            extraArguments =
-                arrayOf(
-                    ARG_GENERATE_API_VERSION_HISTORY,
-                    output.path,
-                    ARG_API_VERSION_SIGNATURE_FILES,
-                    pastVersions.joinToString(":") { it.absolutePath },
-                    ARG_API_VERSION_NAMES,
-                    listOf("1.1.0", "1.2.0", "1.3.0", "1.4.0").joinToString(" "),
-                )
+            extraArguments = createExtraArguments(apiVersionsJson),
         )
 
-        assertTrue(output.isFile)
-
-        // Read output and reprint with pretty printing enabled to make test failures easier to read
-        val gson = GsonBuilder().disableHtmlEscaping().setPrettyPrinting().create()
-        val outputJson = gson.fromJson(output.readText(), JsonElement::class.java)
-        val prettyOutput = gson.toJson(outputJson)
-        assertEquals(
+        apiVersionsJson.checkApiVersionsJsonContent(
             """
                 [
                   {
@@ -464,8 +453,95 @@ class ApiGeneratorTest : DriverTest() {
                   }
                 ]
             """
-                .trimIndent(),
-            prettyOutput
+        )
+
+        val apiVersionsXml = temporaryFolder.newFile("api-versions.xml")
+
+        check(
+            signatureSource = currentVersion,
+            extraArguments = createExtraArguments(apiVersionsXml),
+        )
+
+        apiVersionsXml.checkApiVersionsXmlContent(
+            """
+                <?xml version="1.0" encoding="utf-8"?>
+                <api version="3">
+                    <class name="test.pkg.Foo" since="1.1.0">
+                        <extends name="java.lang.Object"/>
+                        <method name="methodV1&lt;T extends java.lang.String>(T)" deprecated="1.3.0"/>
+                        <method name="methodV2&lt;T>(java.lang.String)" since="1.2.0" removed="1.4.0"/>
+                        <method name="methodV2&lt;T>(java.lang.String,int)" since="1.2.0" deprecated="1.2.0" removed="1.3.0"/>
+                        <method name="methodV3()" since="1.3.0"/>
+                        <method name="methodV4()" since="1.4.0"/>
+                        <field name="fieldV1"/>
+                        <field name="fieldV2" since="1.2.0"/>
+                    </class>
+                    <class name="test.pkg.Foo.Bar" since="1.1.0" deprecated="1.3.0">
+                        <extends name="java.lang.Object"/>
+                    </class>
+                </api>
+            """
+        )
+    }
+
+    @Test
+    fun `Ensure class missing in current codebase is marked as removed`() {
+        val pastVersions =
+            listOf(
+                createTextFile(
+                    "1.1.0",
+                    """
+                        // Signature format: 2.0
+                        package test.pkg {
+                          public class Bar {
+                            field public int barField;
+                          }
+                          public class Foo extends test.pkg.Bar {
+                            field public int fooField;
+                          }
+                        }
+                    """
+                ),
+            )
+        val currentVersion =
+            """
+                // Signature format: 2.0
+                package test.pkg {
+                  public class Foo {
+                  }
+                }
+            """
+
+        val apiVersionsXml = temporaryFolder.newFile("api-versions.xml")
+
+        check(
+            signatureSource = currentVersion,
+            extraArguments =
+                arrayOf(
+                    ARG_GENERATE_API_VERSION_HISTORY,
+                    apiVersionsXml.path,
+                    ARG_API_VERSION_SIGNATURE_FILES,
+                    pastVersions.joinToString(":") { it.absolutePath },
+                    ARG_API_VERSION_NAMES,
+                    listOf("1.1.0", "1.2.0").joinToString(" "),
+                ),
+        )
+
+        apiVersionsXml.checkApiVersionsXmlContent(
+            """
+                <?xml version="1.0" encoding="utf-8"?>
+                <api version="3">
+                    <class name="test.pkg.Bar" since="1.1.0" removed="1.2.0">
+                        <extends name="java.lang.Object"/>
+                        <field name="barField"/>
+                    </class>
+                    <class name="test.pkg.Foo" since="1.1.0">
+                        <extends name="java.lang.Object" since="1.2.0"/>
+                        <extends name="test.pkg.Bar" removed="1.2.0"/>
+                        <field name="fooField" removed="1.2.0"/>
+                    </class>
+                </api>
+            """
         )
     }
 
@@ -515,18 +591,18 @@ class ApiGeneratorTest : DriverTest() {
                     ARG_GENERATE_API_VERSION_HISTORY,
                     output.path,
                     ARG_API_VERSION_NAMES,
-                    "0.0.0"
+                    "0.0.0-alpha01"
                 )
         )
 
         val expectedJson =
-            "[{\"class\":\"test.pkg.Foo\",\"addedIn\":\"0.0.0\",\"methods\":[{\"method\":\"foo(java.lang.String)\",\"addedIn\":\"0.0.0\"}],\"fields\":[]}]"
+            "[{\"class\":\"test.pkg.Foo\",\"addedIn\":\"0.0.0-alpha01\",\"methods\":[{\"method\":\"foo(java.lang.String)\",\"addedIn\":\"0.0.0-alpha01\"}],\"fields\":[]}]"
         assertEquals(expectedJson, output.readText())
     }
 
     @Test
     fun `API levels using source as current version does not include inherited methods excluded from signatures`() {
-        val output = temporaryFolder.newFile("api-info.json")
+        val apiVersionsJson = temporaryFolder.newFile("api-info.json")
 
         val pastVersions =
             listOf(
@@ -574,7 +650,7 @@ class ApiGeneratorTest : DriverTest() {
             extraArguments =
                 arrayOf(
                     ARG_GENERATE_API_VERSION_HISTORY,
-                    output.path,
+                    apiVersionsJson.path,
                     ARG_API_VERSION_SIGNATURE_FILES,
                     pastVersions.joinToString(":") { it.absolutePath },
                     ARG_API_VERSION_NAMES,
@@ -582,13 +658,7 @@ class ApiGeneratorTest : DriverTest() {
                 )
         )
 
-        assertTrue(output.isFile)
-
-        // Read output and reprint with pretty printing enabled to make test failures easier to read
-        val gson = GsonBuilder().disableHtmlEscaping().setPrettyPrinting().create()
-        val outputJson = gson.fromJson(output.readText(), JsonElement::class.java)
-        val prettyOutput = gson.toJson(outputJson)
-        assertEquals(
+        apiVersionsJson.checkApiVersionsJsonContent(
             """
                 [
                   {
@@ -619,14 +689,12 @@ class ApiGeneratorTest : DriverTest() {
                   }
                 ]
             """
-                .trimIndent(),
-            prettyOutput
         )
     }
 
     @Test
     fun `APIs annotated with suppress-compatibility-meta-annotations appear in output`() {
-        val output = temporaryFolder.newFile("api-info.json")
+        val apiVersionsJson = temporaryFolder.newFile("api-info.json")
 
         val pastVersions =
             listOf(
@@ -664,7 +732,7 @@ class ApiGeneratorTest : DriverTest() {
             extraArguments =
                 arrayOf(
                     ARG_GENERATE_API_VERSION_HISTORY,
-                    output.path,
+                    apiVersionsJson.path,
                     ARG_API_VERSION_SIGNATURE_FILES,
                     pastVersions.joinToString(":") { it.absolutePath },
                     ARG_API_VERSION_NAMES,
@@ -672,13 +740,7 @@ class ApiGeneratorTest : DriverTest() {
                 )
         )
 
-        assertTrue(output.isFile)
-
-        // Read output and reprint with pretty printing enabled to make test failures easier to read
-        val gson = GsonBuilder().disableHtmlEscaping().setPrettyPrinting().create()
-        val outputJson = gson.fromJson(output.readText(), JsonElement::class.java)
-        val prettyOutput = gson.toJson(outputJson)
-        assertEquals(
+        apiVersionsJson.checkApiVersionsJsonContent(
             """
                 [
                   {
@@ -706,8 +768,6 @@ class ApiGeneratorTest : DriverTest() {
                   }
                 ]
             """
-                .trimIndent(),
-            prettyOutput
         )
     }
 
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiToExtensionsMapTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiToExtensionsMapTest.kt
index d7821a321..8139504aa 100644
--- a/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiToExtensionsMapTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiToExtensionsMapTest.kt
@@ -23,6 +23,13 @@ import kotlin.test.assertTrue
 import org.junit.Assert
 
 class ApiToExtensionsMapTest {
+
+    /** Get an SDK version for [level]. */
+    private fun sdkVersion(level: Int) = ApiVersion.fromLevel(level)
+
+    /** Get an extension version for [level]. */
+    private fun extensionVersion(level: Int) = ExtVersion.fromLevel(level)
+
     @Test
     fun `empty input`() {
         val xml =
@@ -80,8 +87,11 @@ class ApiToExtensionsMapTest {
         assertEquals(map.getExtensions("com.foo.Bar\$Inner"), listOf("A"))
         assertEquals(map.getExtensions("com.foo.Bar\$Inner\$InnerInner"), listOf("A"))
 
-        val clazz = ApiClass("com/foo/Bar", 1, false)
-        val method = ApiElement("method(Ljava.lang.String;I)V", 2, false)
+        val sdk1 = sdkVersion(1)
+        val sdk2 = sdkVersion(2)
+
+        val clazz = ApiClass("com/foo/Bar").apply { update(sdk1, false) }
+        val method = ApiElement("method(Ljava.lang.String;I)V").apply { update(sdk2, false) }
         assertEquals(map.getExtensions(clazz), listOf("A"))
         assertEquals(map.getExtensions(clazz, method), listOf("A"))
 
@@ -372,34 +382,51 @@ class ApiToExtensionsMapTest {
                 .trimIndent()
         val filter = ApiToExtensionsMap.fromXml("mod", xml)
 
-        Assert.assertEquals("0:34", filter.calculateSdksAttr(34, 34, listOf(), ApiElement.NEVER))
+        val sdk21 = sdkVersion(21)
+        val sdk30 = sdkVersion(30)
+        val sdk31 = sdkVersion(31)
+        val sdk32 = sdkVersion(32)
+        val sdk33 = sdkVersion(33)
+        val sdk34 = sdkVersion(34)
+        val ext4 = extensionVersion(4)
 
-        Assert.assertEquals("30:4", filter.calculateSdksAttr(34, 34, listOf("R"), 4))
+        Assert.assertEquals("0:34", filter.calculateSdksAttr(sdk34, sdk34, listOf(), null))
 
-        Assert.assertEquals("30:4,31:4", filter.calculateSdksAttr(34, 34, listOf("R", "S"), 4))
+        Assert.assertEquals("30:4", filter.calculateSdksAttr(sdk34, sdk34, listOf("R"), ext4))
 
-        Assert.assertEquals("30:4,31:4,0:33", filter.calculateSdksAttr(33, 34, listOf("R", "S"), 4))
+        Assert.assertEquals(
+            "30:4,31:4",
+            filter.calculateSdksAttr(sdk34, sdk34, listOf("R", "S"), ext4)
+        )
+
+        Assert.assertEquals(
+            "30:4,31:4,0:33",
+            filter.calculateSdksAttr(sdk33, sdk34, listOf("R", "S"), ext4)
+        )
 
         Assert.assertEquals(
             "30:4,31:4,1000000:4,0:33",
-            filter.calculateSdksAttr(33, 34, listOf("R", "S", "FOO"), 4)
+            filter.calculateSdksAttr(sdk33, sdk34, listOf("R", "S", "FOO"), ext4)
         )
 
         Assert.assertEquals(
             "30:4,31:4,1000000:4,1000001:4,0:33",
-            filter.calculateSdksAttr(33, 34, listOf("R", "S", "FOO", "BAR"), 4)
+            filter.calculateSdksAttr(sdk33, sdk34, listOf("R", "S", "FOO", "BAR"), ext4)
         )
 
         // Make sure that if it was released in dessert released R (30) that it is reported as being
         // in both the extension SDK included in R (30:4) and in R itself (0:30) but not in S or T.
-        Assert.assertEquals("30:4,0:30", filter.calculateSdksAttr(30, 34, listOf("R", "S"), 4))
+        Assert.assertEquals(
+            "30:4,0:30",
+            filter.calculateSdksAttr(sdk30, sdk34, listOf("R", "S"), ext4)
+        )
 
         // Make sure that if it was released in dessert released S (31) that it is reported as being
         // in both the extension SDK included in R (30:4), S (31:4) and in S itself (0:30) but not
         // in T.
         Assert.assertEquals(
             "30:4,31:4,0:31",
-            filter.calculateSdksAttr(31, 34, listOf("R", "S", "T"), 4)
+            filter.calculateSdksAttr(sdk31, sdk34, listOf("R", "S", "T"), ext4)
         )
 
         // Make sure that if it was released in dessert released S+ (32) that it is reported as
@@ -407,18 +434,18 @@ class ApiToExtensionsMapTest {
         // not in T.
         Assert.assertEquals(
             "30:4,31:4,0:32",
-            filter.calculateSdksAttr(32, 34, listOf("R", "S", "T"), 4)
+            filter.calculateSdksAttr(sdk32, sdk34, listOf("R", "S", "T"), ext4)
         )
 
         // Make sure that if it was released in dessert released T (33) that it is reported as being
         // in both the extension SDK included in R (30:4), S (31:4), T (33:4) and T itself.
         Assert.assertEquals(
             "30:4,31:4,33:4,0:33",
-            filter.calculateSdksAttr(33, 34, listOf("R", "S", "T"), 4)
+            filter.calculateSdksAttr(sdk33, sdk34, listOf("R", "S", "T"), ext4)
         )
 
         // Make sure that if it was released in dessert release before R (21) that it is not
         // reported as being in any sdks; it will just have `since="21"`.
-        Assert.assertEquals("", filter.calculateSdksAttr(21, 34, listOf("R", "S"), 4))
+        Assert.assertEquals("", filter.calculateSdksAttr(sdk21, sdk34, listOf("R", "S"), ext4))
     }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiVersionConstraintTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiVersionConstraintTest.kt
new file mode 100644
index 000000000..4a69f06ac
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiVersionConstraintTest.kt
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.apilevels
+
+import com.google.common.truth.Truth.assertThat
+import org.junit.Assert.assertThrows
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.junit.runners.Parameterized
+
+/** Verifies the constraints on [ApiVersion] properties. */
+@RunWith(Parameterized::class)
+class ApiVersionConstraintTest {
+
+    data class TestData(
+        val name: String,
+        val major: Int,
+        val minor: Int? = null,
+        val patch: Int? = null,
+        val preReleaseQuality: String? = null,
+        val expectedError: String,
+    ) {
+        override fun toString() = name
+    }
+
+    @Parameterized.Parameter(0) lateinit var testData: TestData
+
+    companion object {
+        @JvmStatic
+        @Parameterized.Parameters(name = "{0}")
+        fun params() =
+            listOf(
+                TestData(
+                    name = "invalid major",
+                    major = -1,
+                    expectedError = "major must be greater than or equal to 0 but was -1",
+                ),
+                TestData(
+                    name = "invalid minor",
+                    major = 0,
+                    minor = -2,
+                    expectedError = "minor must be greater than or equal to 0 but was -2",
+                ),
+                TestData(
+                    name = "missing minor",
+                    major = 0,
+                    patch = 0,
+                    expectedError = "patch (0) was specified without also specifying minor",
+                ),
+                TestData(
+                    name = "invalid patch",
+                    major = 0,
+                    minor = 1,
+                    patch = -3,
+                    expectedError = "patch must be greater than or equal to 0 but was -3",
+                ),
+                TestData(
+                    name = "missing patch",
+                    major = 0,
+                    preReleaseQuality = "alpha01",
+                    expectedError =
+                        "preReleaseQuality (alpha01) was specified without also specifying patch",
+                ),
+            )
+    }
+
+    @Test
+    fun testConstraints() {
+        val exception =
+            assertThrows(IllegalArgumentException::class.java) {
+                ApiVersion(
+                    testData.major,
+                    testData.minor,
+                    testData.patch,
+                    testData.preReleaseQuality,
+                )
+            }
+
+        assertThat(exception.message).isEqualTo(testData.expectedError)
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiVersionTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiVersionTest.kt
new file mode 100644
index 000000000..c885653d9
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/ApiVersionTest.kt
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.apilevels
+
+import com.google.common.truth.Truth.assertThat
+import org.junit.Test
+
+class ApiVersionTest {
+    @Test
+    fun `Test sorting`() {
+        val versions =
+            listOf(
+                ApiVersion.fromString("10.0"),
+                ApiVersion.fromString("10.0.1"),
+                ApiVersion.fromString("10"),
+                ApiVersion.fromString("10.0.1-beta"),
+                ApiVersion.fromString("1"),
+                ApiVersion.fromString("10.0.1-alpha"),
+                ApiVersion.fromString("5"),
+            )
+
+        assertThat(versions.sorted())
+            .isEqualTo(
+                listOf(
+                    ApiVersion.fromString("1"),
+                    ApiVersion.fromString("5"),
+                    ApiVersion.fromString("10"),
+                    ApiVersion.fromString("10.0"),
+                    ApiVersion.fromString("10.0.1-alpha"),
+                    ApiVersion.fromString("10.0.1-beta"),
+                    ApiVersion.fromString("10.0.1"),
+                )
+            )
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/CorrectApiLevelForNonReleaseTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/CorrectApiLevelForNonReleaseTest.kt
index 4692b8b21..9863b2fbd 100644
--- a/metalava/src/test/java/com/android/tools/metalava/apilevels/CorrectApiLevelForNonReleaseTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/CorrectApiLevelForNonReleaseTest.kt
@@ -22,7 +22,6 @@ import com.android.tools.metalava.ARG_CURRENT_VERSION
 import com.android.tools.metalava.ARG_GENERATE_API_LEVELS
 import com.android.tools.metalava.doc.getApiLookup
 import com.android.tools.metalava.testing.java
-import java.io.File
 import org.junit.Assert.assertEquals
 import org.junit.Assert.assertTrue
 import org.junit.Test
@@ -31,10 +30,6 @@ class CorrectApiLevelForNonReleaseTest : ApiGeneratorIntegrationTestBase() {
 
     @Test
     fun `Correct API Level for non-release`() {
-        val output = File.createTempFile("api-info", "xml")
-        output.deleteOnExit()
-        val outputPath = output.path
-
         check(
             extraArguments =
                 arrayOf(
@@ -43,7 +38,7 @@ class CorrectApiLevelForNonReleaseTest : ApiGeneratorIntegrationTestBase() {
                     ARG_ANDROID_JAR_PATTERN,
                     "${oldSdkJars.path}/android-%/android.jar",
                     ARG_ANDROID_JAR_PATTERN,
-                    "${platformJars.path}/%/public/android.jar",
+                    androidPublicJarsPattern,
                     ARG_CURRENT_CODENAME,
                     "ZZZ", // not just Z, but very ZZZ
                     ARG_CURRENT_VERSION,
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/CorrectApiLevelForReleaseTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/CorrectApiLevelForReleaseTest.kt
index b966d1dea..c37495bd4 100644
--- a/metalava/src/test/java/com/android/tools/metalava/apilevels/CorrectApiLevelForReleaseTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/CorrectApiLevelForReleaseTest.kt
@@ -22,7 +22,6 @@ import com.android.tools.metalava.ARG_CURRENT_VERSION
 import com.android.tools.metalava.ARG_GENERATE_API_LEVELS
 import com.android.tools.metalava.doc.getApiLookup
 import com.android.tools.metalava.testing.java
-import java.io.File
 import org.junit.Assert.assertEquals
 import org.junit.Assert.assertTrue
 import org.junit.Test
@@ -31,10 +30,6 @@ class CorrectApiLevelForReleaseTest : ApiGeneratorIntegrationTestBase() {
 
     @Test
     fun `Correct API Level for release`() {
-        val output = File.createTempFile("api-info", "xml")
-        output.deleteOnExit()
-        val outputPath = output.path
-
         check(
             extraArguments =
                 arrayOf(
@@ -43,7 +38,7 @@ class CorrectApiLevelForReleaseTest : ApiGeneratorIntegrationTestBase() {
                     ARG_ANDROID_JAR_PATTERN,
                     "${oldSdkJars.path}/android-%/android.jar",
                     ARG_ANDROID_JAR_PATTERN,
-                    "${platformJars.path}/%/public/android.jar",
+                    androidPublicJarsPattern,
                     ARG_CURRENT_CODENAME,
                     "REL",
                     ARG_CURRENT_VERSION,
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtVersionTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtVersionTest.kt
new file mode 100644
index 000000000..275dc451c
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtVersionTest.kt
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.apilevels
+
+import com.google.common.truth.Truth.assertThat
+import org.junit.Test
+
+class ExtVersionTest {
+    @Test
+    fun `Test sorting`() {
+        val versions =
+            listOf(
+                ExtVersion.fromLevel(10),
+                ExtVersion.fromLevel(1),
+                ExtVersion.fromLevel(5),
+            )
+
+        assertThat(versions.sorted())
+            .isEqualTo(
+                listOf(
+                    ExtVersion.fromLevel(1),
+                    ExtVersion.fromLevel(5),
+                    ExtVersion.fromLevel(10),
+                )
+            )
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtensionSdkJarReaderTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtensionSdkJarReaderTest.kt
index 72d796129..490a09c6a 100644
--- a/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtensionSdkJarReaderTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtensionSdkJarReaderTest.kt
@@ -16,104 +16,54 @@
 
 package com.android.tools.metalava.apilevels
 
+import com.android.tools.metalava.testing.TemporaryFolderOwner
 import java.io.File
-import java.io.FileNotFoundException
-import java.nio.file.Files
 import kotlin.test.Test
 import org.junit.Assert.assertEquals
+import org.junit.Rule
+import org.junit.rules.TemporaryFolder
 
-class ExtensionSdkJarReaderTest {
-    @Test
-    fun `Verify findExtensionSdkJarFiles`() {
-        TemporaryDirectoryHierarchy(
-                listOf(
-                    "1/public/foo.jar",
-                    "1/public/bar.jar",
-                    "2/public/foo.jar",
-                    "2/public/bar.jar",
-                    "2/public/baz.jar",
-                )
-            )
-            .use {
-                val root = it.root
-                val expected =
-                    mapOf(
-                        "foo" to
-                            listOf(
-                                VersionAndPath(1, File(root, "1/public/foo.jar")),
-                                VersionAndPath(2, File(root, "2/public/foo.jar"))
-                            ),
-                        "bar" to
-                            listOf(
-                                VersionAndPath(1, File(root, "1/public/bar.jar")),
-                                VersionAndPath(2, File(root, "2/public/bar.jar"))
-                            ),
-                        "baz" to listOf(VersionAndPath(2, File(root, "2/public/baz.jar"))),
-                    )
-                val actual = ExtensionSdkJarReader.findExtensionSdkJarFiles(root, null)
-                assertEquals(expected, actual)
-            }
-    }
-
-    @Test
-    fun `Verify findExtensionSdkJarFiles exclude unreleased`() {
-        TemporaryDirectoryHierarchy(
-                listOf(
-                    "1/public/foo.jar",
-                    "2/public/foo.jar",
-                    "3/public/foo.jar",
-                    "4/public/foo.jar",
-                )
-            )
-            .use {
-                val root = it.root
-                val expected =
-                    mapOf(
-                        "foo" to
-                            listOf(
-                                VersionAndPath(1, File(root, "1/public/foo.jar")),
-                                VersionAndPath(2, File(root, "2/public/foo.jar"))
-                            )
-                    )
-                val actual = ExtensionSdkJarReader.findExtensionSdkJarFiles(root, 2)
-                assertEquals(expected, actual)
-            }
-    }
-}
+class ExtensionSdkJarReaderTest : TemporaryFolderOwner {
 
-private class TemporaryDirectoryHierarchy(filenames: List<String>) : AutoCloseable {
-    val root: File
+    /** Provides access to temporary files. */
+    @get:Rule override val temporaryFolder = TemporaryFolder()
 
-    init {
-        root = Files.createTempDirectory("metalava").toFile()
-        for (file in filenames.map { File(root, it) }) {
-            createDirectoryRecursively(file.parentFile)
+    private fun createDirectoryHierarchy(vararg paths: String): File {
+        val root = temporaryFolder.newFolder("metalava")
+        for (path in paths) {
+            val file = root.resolve(path)
+            file.parentFile.mkdirs()
             file.createNewFile()
         }
+        return root
     }
 
-    override fun close() {
-        deleteDirectoryRecursively(root)
-    }
-
-    companion object {
-        private fun createDirectoryRecursively(file: File) {
-            val parent = file.parentFile ?: throw FileNotFoundException("$file has no parent")
-            if (!parent.exists()) {
-                createDirectoryRecursively(parent)
-            }
-            file.mkdir()
-        }
+    @Test
+    fun `Verify findExtensionSdkJarFiles`() {
+        val root =
+            createDirectoryHierarchy(
+                "1/public/foo.jar",
+                "1/public/bar.jar",
+                "2/public/foo.jar",
+                "2/public/bar.jar",
+                "2/public/baz.jar",
+            )
 
-        private fun deleteDirectoryRecursively(root: File) {
-            for (file in root.listFiles()) {
-                if (file.isDirectory()) {
-                    deleteDirectoryRecursively(file)
-                } else {
-                    file.delete()
-                }
-            }
-            root.delete()
-        }
+        val expected =
+            mapOf(
+                "foo" to
+                    listOf(
+                        VersionAndPath(1, File(root, "1/public/foo.jar")),
+                        VersionAndPath(2, File(root, "2/public/foo.jar"))
+                    ),
+                "bar" to
+                    listOf(
+                        VersionAndPath(1, File(root, "1/public/bar.jar")),
+                        VersionAndPath(2, File(root, "2/public/bar.jar"))
+                    ),
+                "baz" to listOf(VersionAndPath(2, File(root, "2/public/baz.jar"))),
+            )
+        val actual = ExtensionSdkJarReader.findExtensionSdkJarFiles(root)
+        assertEquals(expected, actual)
     }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtractPublicApiLevelsTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtractPublicApiLevelsTest.kt
index 47c5e43e6..613eab221 100644
--- a/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtractPublicApiLevelsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtractPublicApiLevelsTest.kt
@@ -20,20 +20,21 @@ import com.android.tools.metalava.ARG_ANDROID_JAR_PATTERN
 import com.android.tools.metalava.ARG_CURRENT_CODENAME
 import com.android.tools.metalava.ARG_CURRENT_VERSION
 import com.android.tools.metalava.ARG_GENERATE_API_LEVELS
+import com.android.tools.metalava.ARG_SDK_INFO_FILE
+import com.android.tools.metalava.ARG_SDK_JAR_ROOT
 import com.android.tools.metalava.doc.getApiLookup
 import com.android.tools.metalava.testing.java
-import java.io.File
 import org.junit.Assert.assertEquals
 import org.junit.Assert.assertFalse
 import org.junit.Assert.assertTrue
 import org.junit.Test
 
 class ExtractPublicApiLevelsTest : ApiGeneratorIntegrationTestBase() {
+    // TODO(b/378479241): Fix this test to make it more realistic by including definitions of the
+    //  current API or stopping it from including the current API.
     @Test
     fun `Extract API levels`() {
-        val output = File.createTempFile("api-info", "xml")
-        output.deleteOnExit()
-        val outputPath = output.path
+        val currentVersion = 35
 
         check(
             extraArguments =
@@ -43,11 +44,15 @@ class ExtractPublicApiLevelsTest : ApiGeneratorIntegrationTestBase() {
                     ARG_ANDROID_JAR_PATTERN,
                     "${oldSdkJars.path}/android-%/android.jar",
                     ARG_ANDROID_JAR_PATTERN,
-                    "${platformJars.path}/%/public/android.jar",
+                    androidPublicJarsPattern,
+                    ARG_SDK_JAR_ROOT,
+                    extensionSdkJars.path,
+                    ARG_SDK_INFO_FILE,
+                    createSdkExtensionInfoFile().path,
                     ARG_CURRENT_CODENAME,
                     "Z",
                     ARG_CURRENT_VERSION,
-                    MAGIC_VERSION_STR // not real api level of Z
+                    currentVersion.toString() // not real api level of Z
                 ),
             sourceFiles =
                 arrayOf(
@@ -63,8 +68,14 @@ class ExtractPublicApiLevelsTest : ApiGeneratorIntegrationTestBase() {
 
         assertTrue(output.isFile)
 
-        val xml = output.readText(Charsets.UTF_8)
-        val nextVersion = MAGIC_VERSION_INT + 1
+        val xml =
+            output
+                .readText(Charsets.UTF_8)
+                // As this only provides a single MyTest class in the current codebase which is of
+                // version 36, the api-versions.xml generator will assume that all the other classes
+                // it has seen have been removed. That is not true so remove those attributes.
+                .replace(" removed=\"36\"", "")
+        val nextVersion = currentVersion + 1
         assertTrue(xml.contains("<class name=\"android/Manifest\$permission\" since=\"1\">"))
         assertTrue(
             xml.contains(
@@ -97,5 +108,18 @@ class ExtractPublicApiLevelsTest : ApiGeneratorIntegrationTestBase() {
         val methodVersion =
             apiLookup.getMethodVersion("android/icu/util/CopticCalendar", "computeTime", "()")
         assertEquals(24, methodVersion)
+
+        // Verify historical backfill by checking the section for android/os/ext/SdkExtensions
+        xml.checkClass(
+            "android/os/ext/SdkExtensions",
+            """
+                <class name="android/os/ext/SdkExtensions" since="30">
+                    <extends name="java/lang/Object"/>
+                    <method name="getAllExtensionVersions()Ljava/util/Map;" since="31"/>
+                    <method name="getExtensionVersion(I)I"/>
+                    <field name="AD_SERVICES" since="34" sdks="30:4,0:34"/>
+                </class>
+            """
+        )
     }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtractSystemApiLevelsTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtractSystemApiLevelsTest.kt
index 6a24dde85..22aa6cf55 100644
--- a/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtractSystemApiLevelsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/ExtractSystemApiLevelsTest.kt
@@ -23,65 +23,14 @@ import com.android.tools.metalava.ARG_GENERATE_API_LEVELS
 import com.android.tools.metalava.ARG_SDK_INFO_FILE
 import com.android.tools.metalava.ARG_SDK_JAR_ROOT
 import com.android.tools.metalava.doc.getApiLookup
-import com.android.tools.metalava.doc.minApiLevel
-import java.io.File
 import org.junit.Assert.assertEquals
-import org.junit.Assert.assertFalse
 import org.junit.Assert.assertTrue
 import org.junit.Test
 
 class ExtractSystemApiLevelsTest : ApiGeneratorIntegrationTestBase() {
     @Test
     fun `Extract System API`() {
-        // These are the wrong jar paths but this test doesn't actually care what the
-        // content of the jar files, just checking the logic of starting the database
-        // at some higher number than 1
-        val androidJarPattern = "${platformJars.path}/%/public/android.jar"
-
-        val filter = File.createTempFile("filter", "txt")
-        filter.deleteOnExit()
-        filter.writeText(
-            """
-                <sdk-extensions-info>
-                <!-- SDK definitions -->
-                <sdk shortname="R" name="R Extensions" id="30" reference="android/os/Build${'$'}VERSION_CODES${'$'}R" />
-                <sdk shortname="S" name="S Extensions" id="31" reference="android/os/Build${'$'}VERSION_CODES${'$'}S" />
-                <sdk shortname="T" name="T Extensions" id="33" reference="android/os/Build${'$'}VERSION_CODES${'$'}T" />
-
-                <!-- Rules -->
-                <symbol jar="art.module.public.api" pattern="*" sdks="R" />
-                <symbol jar="conscrypt.module.intra.core.api " pattern="" sdks="R" />
-                <symbol jar="conscrypt.module.platform.api" pattern="*" sdks="R" />
-                <symbol jar="conscrypt.module.public.api" pattern="*" sdks="R" />
-                <symbol jar="framework-mediaprovider" pattern="*" sdks="R" />
-                <symbol jar="framework-mediaprovider" pattern="android.provider.MediaStore#canManageMedia" sdks="T" />
-                <symbol jar="framework-permission-s" pattern="*" sdks="R" />
-                <symbol jar="framework-permission" pattern="*" sdks="R" />
-                <symbol jar="framework-sdkextensions" pattern="*" sdks="R" />
-                <symbol jar="framework-scheduling" pattern="*" sdks="R" />
-                <symbol jar="framework-statsd" pattern="*" sdks="R" />
-                <symbol jar="framework-tethering" pattern="*" sdks="R" />
-                <symbol jar="legacy.art.module.platform.api" pattern="*" sdks="R" />
-                <symbol jar="service-media-s" pattern="*" sdks="R" />
-                <symbol jar="service-permission" pattern="*" sdks="R" />
-
-                <!-- use framework-permissions-s to test the order of multiple SDKs is respected -->
-                <symbol jar="android.net.ipsec.ike" pattern="android.net.eap.EapAkaInfo" sdks="R,S,T" />
-                <symbol jar="android.net.ipsec.ike" pattern="android.net.eap.EapInfo" sdks="T,S,R" />
-                <symbol jar="android.net.ipsec.ike" pattern="*" sdks="R" />
-
-                <!-- framework-connectivity: only android.net.CaptivePortal should have the 'sdks' attribute -->
-                <symbol jar="framework-connectivity" pattern="android.net.CaptivePortalData" sdks="R" />
-
-                <!-- framework-media explicitly omitted: nothing in this module should have the 'sdks' attribute -->
-                </sdk-extensions-info>
-            """
-                .trimIndent()
-        )
-
-        val output = File.createTempFile("api-info", "xml")
-        output.deleteOnExit()
-        val outputPath = output.path
+        val androidJarPattern = "${platformJars.path}/%/system/android.jar"
 
         check(
             extraArguments =
@@ -91,9 +40,9 @@ class ExtractSystemApiLevelsTest : ApiGeneratorIntegrationTestBase() {
                     ARG_ANDROID_JAR_PATTERN,
                     androidJarPattern,
                     ARG_SDK_JAR_ROOT,
-                    "$extensionSdkJars",
+                    extensionSdkJars.path,
                     ARG_SDK_INFO_FILE,
-                    filter.path,
+                    createSdkExtensionInfoFile().path,
                     ARG_FIRST_VERSION,
                     "21",
                     ARG_CURRENT_VERSION,
@@ -168,7 +117,7 @@ class ExtractSystemApiLevelsTest : ApiGeneratorIntegrationTestBase() {
         // has the module/sdks attributes
         assertTrue(
             xml.contains(
-                "<class name=\"android/net/CaptivePortalData\" module=\"framework-connectivity\" since=\"34\" sdks=\"30:1\">"
+                "<class name=\"android/net/CaptivePortalData\" module=\"framework-connectivity\" since=\"30\" sdks=\"30:1,0:30\">"
             )
         )
         assertTrue(
@@ -189,28 +138,17 @@ class ExtractSystemApiLevelsTest : ApiGeneratorIntegrationTestBase() {
             )
         )
 
-        // Verify historical backfill
-        assertEquals(30, apiLookup.getClassVersions("android/os/ext/SdkExtensions").minApiLevel())
-        assertEquals(
-            30,
-            apiLookup
-                .getMethodVersions("android/os/ext/SdkExtensions", "getExtensionVersion", "(I)I")
-                .minApiLevel()
-        )
-        assertEquals(
-            31,
-            apiLookup
-                .getMethodVersions(
-                    "android/os/ext/SdkExtensions",
-                    "getAllExtensionVersions",
-                    "()Ljava/util/Map;"
-                )
-                .minApiLevel()
+        // Verify historical backfill by checking the section for android/os/ext/SdkExtensions
+        xml.checkClass(
+            "android/os/ext/SdkExtensions",
+            """
+                <class name="android/os/ext/SdkExtensions" since="30">
+                    <extends name="java/lang/Object"/>
+                    <method name="getAllExtensionVersions()Ljava/util/Map;" since="31"/>
+                    <method name="getExtensionVersion(I)I"/>
+                    <field name="AD_SERVICES" since="34" sdks="30:4"/>
+                </class>
+            """
         )
-
-        // Verify there's no extension versions listed for SdkExtensions
-        val sdkExtClassLine =
-            xml.lines().first { it.contains("<class name=\"android/os/ext/SdkExtensions\"") }
-        assertFalse(sdkExtClassLine.contains("sdks="))
     }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/InternalDescTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/InternalDescTest.kt
index 01ea6d80b..55831212e 100644
--- a/metalava/src/test/java/com/android/tools/metalava/apilevels/InternalDescTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/InternalDescTest.kt
@@ -18,6 +18,7 @@ package com.android.tools.metalava.apilevels
 
 import com.android.tools.metalava.model.Assertions
 import com.android.tools.metalava.model.text.ApiFile
+import com.android.tools.metalava.model.text.SignatureFile
 import kotlin.test.assertEquals
 import org.junit.Test
 
@@ -25,18 +26,21 @@ class InternalDescTest : Assertions {
 
     @Test
     fun `MethodItem internalDesc (psi)`() {
-        val signature =
-            """
-                // Signature format: 2.0
-                package test.pkg {
-                  public class Test {
-                    ctor public Test();
-                    method public abstract boolean foo(test.pkg.Test, int...);
-                    method public abstract void bar(test.pkg.Test... tests);
-                  }
-                }
-             """
-        ApiFile.parseApi("test", signature.trimIndent()).let {
+        val signatureFile =
+            SignatureFile.fromText(
+                "test",
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public class Test {
+                        ctor public Test();
+                        method public abstract boolean foo(test.pkg.Test, int...);
+                        method public abstract void bar(test.pkg.Test... tests);
+                      }
+                    }
+                 """
+            )
+        ApiFile.parseApi(listOf(signatureFile)).let {
             val testClass = it.assertClass("test.pkg.Test")
             val actual = buildString {
                 testClass.methods().forEach {
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/ParameterizedApiVersionTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/ParameterizedApiVersionTest.kt
new file mode 100644
index 000000000..794d752ca
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/ParameterizedApiVersionTest.kt
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.apilevels
+
+import com.google.common.truth.Truth.assertThat
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.junit.runners.Parameterized
+
+@RunWith(Parameterized::class)
+class ParameterizedApiVersionTest {
+
+    data class TestData(
+        val input: String,
+        val expectedValid: Boolean = true,
+        val expectedString: String = input,
+        val expectedIncremented: String,
+    ) {
+        override fun toString() = input
+    }
+
+    @Parameterized.Parameter(0) lateinit var testData: TestData
+
+    companion object {
+        @JvmStatic
+        @Parameterized.Parameters(name = "{0}")
+        fun params() =
+            listOf(
+                TestData(
+                    input = "0",
+                    expectedValid = false,
+                    expectedIncremented = "1",
+                ),
+                TestData(
+                    input = "1",
+                    expectedIncremented = "2",
+                ),
+                TestData(
+                    input = "01",
+                    expectedString = "1",
+                    expectedIncremented = "2",
+                ),
+                TestData(
+                    input = "0.0",
+                    expectedIncremented = "1.0",
+                ),
+                TestData(
+                    input = "0.00",
+                    expectedString = "0.0",
+                    expectedIncremented = "1.0",
+                ),
+                TestData(
+                    input = "0.0.0",
+                    expectedIncremented = "1.0.0",
+                ),
+                TestData(
+                    input = "0.1",
+                    expectedIncremented = "1.1",
+                ),
+                TestData(
+                    input = "1.0",
+                    expectedIncremented = "2.0",
+                ),
+                TestData(
+                    input = "1.0.0",
+                    expectedIncremented = "2.0.0",
+                ),
+                TestData(
+                    input = "1.2.3-good",
+                    expectedIncremented = "2.2.3-good",
+                ),
+            )
+    }
+
+    /** Get an [ApiVersion] from [text]. */
+    private fun getSdkVersionFromString(text: String) = ApiVersion.fromString(text)
+
+    @Test
+    fun test() {
+        val version = getSdkVersionFromString(testData.input)
+
+        assertThat(version.isValid).isEqualTo(testData.expectedValid)
+        assertThat(version.toString()).isEqualTo(testData.expectedString)
+
+        val incrementedVersion = version + 1
+        val expectedIncrementedVersion = getSdkVersionFromString(testData.expectedIncremented)
+        assertThat(incrementedVersion).isEqualTo(expectedIncrementedVersion)
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/apilevels/ParameterizedExtVersionTest.kt b/metalava/src/test/java/com/android/tools/metalava/apilevels/ParameterizedExtVersionTest.kt
new file mode 100644
index 000000000..cb5806f21
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/apilevels/ParameterizedExtVersionTest.kt
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.apilevels
+
+import com.google.common.truth.Truth.assertThat
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.junit.runners.Parameterized
+
+@RunWith(Parameterized::class)
+class ParameterizedExtVersionTest {
+
+    data class TestData(
+        val input: String,
+        val expectedValid: Boolean = true,
+        val expectedString: String = input,
+    ) {
+        override fun toString() = input
+    }
+
+    @Parameterized.Parameter(0) lateinit var testData: TestData
+
+    companion object {
+        @JvmStatic
+        @Parameterized.Parameters(name = "{0}")
+        fun params() =
+            listOf(
+                TestData(
+                    input = "0",
+                    expectedValid = false,
+                ),
+                TestData(
+                    input = "1",
+                ),
+                TestData(
+                    input = "01",
+                    expectedString = "1",
+                ),
+            )
+    }
+
+    /** Get an [ExtVersion] from [text]. */
+    private fun getExtVersionFromString(text: String) = ExtVersion(text.toInt())
+
+    @Test
+    fun test() {
+        val version = getExtVersionFromString(testData.input)
+
+        assertThat(version.isValid).isEqualTo(testData.expectedValid)
+        assertThat(version.toString()).isEqualTo(testData.expectedString)
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/common/PreviouslyReleasedApiTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/common/PreviouslyReleasedApiTest.kt
index 8974157ff..5835a9902 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/common/PreviouslyReleasedApiTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/common/PreviouslyReleasedApiTest.kt
@@ -64,9 +64,14 @@ class PreviouslyReleasedApiTest : TemporaryFolderOwner {
     @Test
     fun `check jar file`() {
         val jarFile = fakeJar("some.jar")
-        val previouslyReleasedApi =
-            PreviouslyReleasedApi.optionalPreviouslyReleasedApi(OPTION_NAME, listOf(jarFile))
-        assertThat(previouslyReleasedApi).isEqualTo(JarBasedApi(jarFile))
+        val exception =
+            assertThrows(IllegalStateException::class.java) {
+                PreviouslyReleasedApi.optionalPreviouslyReleasedApi(OPTION_NAME, listOf(jarFile))
+            }
+        assertThat(exception.message)
+            .isEqualTo(
+                "$OPTION_NAME: Can no longer check compatibility against jar files like $jarFile please use equivalent signature files"
+            )
     }
 
     @Test
@@ -82,7 +87,7 @@ class PreviouslyReleasedApiTest : TemporaryFolderOwner {
             }
         assertThat(exception.message)
             .isEqualTo(
-                "$OPTION_NAME: Cannot have more than one jar file, found: $jarFile1, $jarFile2"
+                "$OPTION_NAME: Can no longer check compatibility against jar files like $jarFile1, $jarFile2 please use equivalent signature files"
             )
     }
 
@@ -102,7 +107,7 @@ class PreviouslyReleasedApiTest : TemporaryFolderOwner {
 
         assertThat(exception.message)
             .isEqualTo(
-                "$OPTION_NAME: Cannot mix jar files (e.g. $jarFile) and signature files (e.g. $signatureFile)"
+                "$OPTION_NAME: Can no longer check compatibility against jar files like $jarFile please use equivalent signature files"
             )
     }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/common/SourceOptionsTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/common/SourceOptionsTest.kt
index 845672591..8f8deaed4 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/common/SourceOptionsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/common/SourceOptionsTest.kt
@@ -28,6 +28,12 @@ Sources:
                                              well as common business logic are defined.
   --source-path <path>                       A : separated list of directories containing source files (organized in a
                                              standard Java package hierarchy).
+  --stub-packages <package-list>             List of packages (separated by :) which will be used to filter out
+                                             irrelevant classes. If specified, only classes in these packages will be
+                                             included in signature files, stubs, etc.. This is not limited to just the
+                                             stubs; the --stub-packages name is historical.
+
+                                             See `metalava help package-filters` for more information.
     """
         .trimIndent()
 
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/compatibility/CompatibilityCheckOptionsTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/compatibility/CompatibilityCheckOptionsTest.kt
index 6e56b3d36..4f7d66170 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/compatibility/CompatibilityCheckOptionsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/compatibility/CompatibilityCheckOptionsTest.kt
@@ -16,12 +16,10 @@
 
 package com.android.tools.metalava.cli.compatibility
 
-import com.android.tools.metalava.ApiType
-import com.android.tools.metalava.SignatureFileCache
 import com.android.tools.metalava.cli.common.BaseOptionGroupTest
-import com.android.tools.metalava.cli.common.JarBasedApi
 import com.android.tools.metalava.cli.common.SignatureBasedApi
-import com.android.tools.metalava.model.noOpAnnotationManager
+import com.android.tools.metalava.model.api.surface.ApiVariantType
+import com.android.tools.metalava.model.visitors.ApiType
 import com.android.tools.metalava.testing.signature
 import com.android.tools.metalava.testing.source
 import com.google.common.truth.Truth.assertThat
@@ -129,7 +127,11 @@ class CompatibilityCheckOptionsTest :
                 .isEqualTo(
                     listOf(
                         CompatibilityCheckOptions.CheckRequest(
-                            previouslyReleasedApi = SignatureBasedApi.fromFiles(listOf(file)),
+                            previouslyReleasedApi =
+                                SignatureBasedApi.fromFiles(
+                                    listOf(file),
+                                    apiVariantType = ApiVariantType.REMOVED,
+                                ),
                             apiType = ApiType.REMOVED,
                         ),
                     )
@@ -146,17 +148,17 @@ class CompatibilityCheckOptionsTest :
     @Test
     fun `check compatibility api released from jar`() {
         val jarFile = fakeJar()
-        runTest(ARG_CHECK_COMPATIBILITY_API_RELEASED, jarFile.path) {
-            assertThat(options.compatibilityChecks)
-                .isEqualTo(
-                    listOf(
-                        CompatibilityCheckOptions.CheckRequest(
-                            previouslyReleasedApi = JarBasedApi(jarFile),
-                            apiType = ApiType.PUBLIC_API,
-                        ),
-                    )
-                )
-        }
+        val exception =
+            assertThrows(IllegalStateException::class.java) {
+                runTest(ARG_CHECK_COMPATIBILITY_API_RELEASED, jarFile.path) {
+                    options.compatibilityChecks
+                }
+            }
+
+        assertThat(exception.message)
+            .isEqualTo(
+                "$ARG_CHECK_COMPATIBILITY_API_RELEASED: Can no longer check compatibility against jar files like $jarFile please use equivalent signature files"
+            )
     }
 
     @Test
@@ -179,7 +181,7 @@ class CompatibilityCheckOptionsTest :
 
         assertThat(exception.message)
             .isEqualTo(
-                "--check-compatibility:api:released: Cannot mix jar files (e.g. $jarFile) and signature files (e.g. $signatureFile)"
+                "$ARG_CHECK_COMPATIBILITY_API_RELEASED: Can no longer check compatibility against jar files like $jarFile please use equivalent signature files"
             )
     }
 
@@ -195,36 +197,10 @@ class CompatibilityCheckOptionsTest :
             }
         assertThat(exception.message)
             .isEqualTo(
-                "--check-compatibility:removed:released: Cannot specify jar files for removed API but found $jarFile"
+                "$ARG_CHECK_COMPATIBILITY_REMOVED_RELEASED: Can no longer check compatibility against jar files like $jarFile please use equivalent signature files"
             )
     }
 
-    @Test
-    fun `check compatibility api released jar is not supported for --revert-annotation`() {
-        val jarFile = fakeJar()
-        runTest(ARG_CHECK_COMPATIBILITY_API_RELEASED, jarFile.path) {
-            assertThat(options.compatibilityChecks)
-                .isEqualTo(
-                    listOf(
-                        CompatibilityCheckOptions.CheckRequest(
-                            previouslyReleasedApi = JarBasedApi(jarFile),
-                            apiType = ApiType.PUBLIC_API,
-                        ),
-                    )
-                )
-
-            val exception =
-                assertThrows(IllegalStateException::class.java) {
-                    options.previouslyReleasedCodebases(SignatureFileCache(noOpAnnotationManager))
-                }
-
-            assertThat(exception.message)
-                .isEqualTo(
-                    "Unexpected file $jarFile: jar files do not work with --revert-annotation"
-                )
-        }
-    }
-
     @Test
     fun `api compat annotations multiple values`() {
         runTest(
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/help/IssuesCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/help/IssuesCommandTest.kt
index 9e949d63e..025b64e1a 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/help/IssuesCommandTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/help/IssuesCommandTest.kt
@@ -227,6 +227,7 @@ Available Issues                             |  Category                |   Defa
   UseParcelFileDescriptor                    |  api_lint                |   error
   UserHandle                                 |  api_lint                |   warning
   UserHandleName                             |  api_lint                |   warning
+  ValueClassDefinition                       |  api_lint                |   error
   VarargRemoval                              |  compatibility           |   error
   VisiblySynchronized                        |  api_lint                |   error
 """
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureFormatOptionsTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureFormatOptionsTest.kt
index 91776cea6..d7d305f1a 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureFormatOptionsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureFormatOptionsTest.kt
@@ -39,7 +39,8 @@ Signature Format Output:
 
                                              A comma separated list of `<property>=<value>` assignments where
                                              `<property>` is one of the following: 'add-additional-overrides',
-                                             'overloaded-method-order', 'sort-whole-extends-list'.
+                                             'overloaded-method-order', 'sort-whole-extends-list',
+                                             'strip-java-lang-prefix'.
 
                                              See `metalava help signature-file-formats` for more information on the
                                              properties.
diff --git a/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureToJDiffCommandTest.kt b/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureToJDiffCommandTest.kt
index 88db018e9..a207d1704 100644
--- a/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureToJDiffCommandTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/cli/signature/SignatureToJDiffCommandTest.kt
@@ -710,6 +710,120 @@ $signatureToJdiffHelp
                 """
         }
     }
+
+    @Test
+    fun `Test for adding new interface`() {
+        jdiffConversionTest {
+            api =
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public interface Existing {
+                        method public void foo();
+                      }
+
+                      public interface New {
+                        method public void bar();
+                      }
+                    }
+                """
+
+            baseApi =
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public interface Existing {
+                        method public void foo();
+                      }
+                    }
+                """
+
+            expectedXml =
+                """
+                    <api name="api" xmlns:metalava="http://www.android.com/metalava/">
+                    <package name="test.pkg"
+                    >
+                    <interface name="New"
+                     abstract="true"
+                     static="false"
+                     final="false"
+                     deprecated="not deprecated"
+                     visibility="public"
+                    >
+                    <method name="bar"
+                     return="void"
+                     abstract="true"
+                     native="false"
+                     synchronized="false"
+                     static="false"
+                     final="false"
+                     deprecated="not deprecated"
+                     visibility="public"
+                    >
+                    </method>
+                    </interface>
+                    </package>
+                    </api>
+                """
+        }
+    }
+
+    @Test
+    fun `Test for adding new nested interface`() {
+        jdiffConversionTest {
+            api =
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public interface Existing {
+                        method public void foo();
+                      }
+
+                      public interface Existing.New {
+                        method public void bar();
+                      }
+                    }
+                """
+
+            baseApi =
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public interface Existing {
+                        method public void foo();
+                      }
+                    }
+                """
+
+            expectedXml =
+                """
+                    <api name="api" xmlns:metalava="http://www.android.com/metalava/">
+                    <package name="test.pkg"
+                    >
+                    <interface name="Existing.New"
+                     abstract="true"
+                     static="false"
+                     final="false"
+                     deprecated="not deprecated"
+                     visibility="public"
+                    >
+                    <method name="bar"
+                     return="void"
+                     abstract="true"
+                     native="false"
+                     synchronized="false"
+                     static="false"
+                     final="false"
+                     deprecated="not deprecated"
+                     visibility="public"
+                    >
+                    </method>
+                    </interface>
+                    </package>
+                    </api>
+                """
+        }
+    }
 }
 
 fun BaseCommandTest<SignatureToJDiffCommand>.jdiffConversionTest(body: JDiffTestConfig.() -> Unit) {
diff --git a/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckAndroidApisTest.kt b/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckAndroidApisTest.kt
index 377f1143b..3d0841d6f 100644
--- a/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckAndroidApisTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckAndroidApisTest.kt
@@ -19,9 +19,7 @@ package com.android.tools.metalava.compatibility
 import com.android.tools.metalava.DriverTest
 import com.android.tools.metalava.cli.common.ARG_HIDE
 import com.android.tools.metalava.cli.common.ARG_WARNING
-import com.android.tools.metalava.testing.getAndroidJar
-import java.io.File
-import org.junit.Assert.assertTrue
+import com.android.tools.metalava.testing.getAndroidTxt
 import org.junit.AssumptionViolatedException
 import org.junit.Test
 
@@ -69,8 +67,8 @@ abstract class CompatibilityCheckAndroidApisTest(
                 ApiLevelCheck(
                     5,
                     """
-                warning: Method android.view.Surface.lockCanvas added thrown exception java.lang.IllegalArgumentException [ChangedThrows]
-                """,
+                        load-api.txt:14736: warning: Method android.view.Surface.lockCanvas added thrown exception java.lang.IllegalArgumentException [ChangedThrows]
+                    """,
                     hide(
                         DEFAULT_HIDDEN_ISSUES_STRING,
                         "AddedAbstractMethod",
@@ -79,10 +77,10 @@ abstract class CompatibilityCheckAndroidApisTest(
                 ApiLevelCheck(
                     6,
                     """
-                warning: Method android.accounts.AbstractAccountAuthenticator.confirmCredentials added thrown exception android.accounts.NetworkErrorException [ChangedThrows]
-                warning: Method android.accounts.AbstractAccountAuthenticator.updateCredentials added thrown exception android.accounts.NetworkErrorException [ChangedThrows]
-                warning: Field android.view.WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL has changed value from 2008 to 2014 [ChangedValue]
-                """,
+                        load-api.txt:1321: warning: Method android.accounts.AbstractAccountAuthenticator.confirmCredentials added thrown exception android.accounts.NetworkErrorException [ChangedThrows]
+                        load-api.txt:1328: warning: Method android.accounts.AbstractAccountAuthenticator.updateCredentials added thrown exception android.accounts.NetworkErrorException [ChangedThrows]
+                        load-api.txt:15728: warning: Field android.view.WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL has changed value from 2008 to 2014 [ChangedValue]
+                    """,
                     hide(
                         DEFAULT_HIDDEN_ISSUES_STRING,
                     ) +
@@ -94,8 +92,8 @@ abstract class CompatibilityCheckAndroidApisTest(
                 ApiLevelCheck(
                     7,
                     """
-                error: Removed field android.view.ViewGroup.FLAG_USE_CHILD_DRAWING_ORDER [RemovedField]
-                """,
+                        released-api.txt:15404: error: Removed field android.view.ViewGroup.FLAG_USE_CHILD_DRAWING_ORDER [RemovedField]
+                    """,
                     hide(
                         "AddedClass",
                         "AddedField",
@@ -108,32 +106,32 @@ abstract class CompatibilityCheckAndroidApisTest(
                 ApiLevelCheck(
                     8,
                     """
-                warning: Class javax.xml.XMLConstants added 'final' qualifier [AddedFinal]
-                warning: Constructor android.net.SSLCertificateSocketFactory no longer throws exception java.security.KeyManagementException [ChangedThrows]
-                warning: Constructor android.net.SSLCertificateSocketFactory no longer throws exception java.security.NoSuchAlgorithmException [ChangedThrows]
-                warning: Constructor java.nio.charset.Charset no longer throws exception java.nio.charset.IllegalCharsetNameException [ChangedThrows]
-                warning: Method android.content.ComponentName.clone no longer throws exception java.lang.CloneNotSupportedException [ChangedThrows]
-                warning: Method android.gesture.Gesture.clone no longer throws exception java.lang.CloneNotSupportedException [ChangedThrows]
-                warning: Method android.gesture.GesturePoint.clone no longer throws exception java.lang.CloneNotSupportedException [ChangedThrows]
-                warning: Method android.gesture.GestureStroke.clone no longer throws exception java.lang.CloneNotSupportedException [ChangedThrows]
-                warning: Method java.nio.charset.Charset.forName no longer throws exception java.nio.charset.IllegalCharsetNameException [ChangedThrows]
-                warning: Method java.nio.charset.Charset.forName no longer throws exception java.nio.charset.UnsupportedCharsetException [ChangedThrows]
-                warning: Method java.nio.charset.Charset.isSupported no longer throws exception java.nio.charset.IllegalCharsetNameException [ChangedThrows]
-                warning: Method java.util.regex.Matcher.appendReplacement no longer throws exception java.lang.IllegalStateException [ChangedThrows]
-                warning: Method java.util.regex.Matcher.start no longer throws exception java.lang.IllegalStateException [ChangedThrows]
-                warning: Method java.util.regex.Pattern.compile no longer throws exception java.util.regex.PatternSyntaxException [ChangedThrows]
-                warning: Method javax.xml.parsers.DocumentBuilder.isXIncludeAware no longer throws exception java.lang.UnsupportedOperationException [ChangedThrows]
-                warning: Method javax.xml.parsers.DocumentBuilderFactory.newInstance no longer throws exception javax.xml.parsers.FactoryConfigurationError [ChangedThrows]
-                warning: Method javax.xml.parsers.SAXParser.isXIncludeAware no longer throws exception java.lang.UnsupportedOperationException [ChangedThrows]
-                warning: Method javax.xml.parsers.SAXParserFactory.newInstance no longer throws exception javax.xml.parsers.FactoryConfigurationError [ChangedThrows]
-                warning: Method org.w3c.dom.Element.getAttributeNS added thrown exception org.w3c.dom.DOMException [ChangedThrows]
-                warning: Method org.w3c.dom.Element.getAttributeNodeNS added thrown exception org.w3c.dom.DOMException [ChangedThrows]
-                warning: Method org.w3c.dom.Element.getElementsByTagNameNS added thrown exception org.w3c.dom.DOMException [ChangedThrows]
-                warning: Method org.w3c.dom.Element.hasAttributeNS added thrown exception org.w3c.dom.DOMException [ChangedThrows]
-                warning: Method org.w3c.dom.NamedNodeMap.getNamedItemNS added thrown exception org.w3c.dom.DOMException [ChangedThrows]
-                error: Method android.content.ComponentName.clone has changed return type from java.lang.Object to android.content.ComponentName [ChangedType]
-                error: Removed constructor javax.xml.XMLConstants() [RemovedMethod]
-                """,
+                        load-api.txt:2901: warning: Method android.content.ComponentName.clone no longer throws exception java.lang.CloneNotSupportedException [ChangedThrows]
+                        load-api.txt:2901: error: Method android.content.ComponentName.clone has changed return type from java.lang.Object to android.content.ComponentName [ChangedType]
+                        load-api.txt:5169: warning: Method android.gesture.Gesture.clone no longer throws exception java.lang.CloneNotSupportedException [ChangedThrows]
+                        load-api.txt:5281: warning: Method android.gesture.GesturePoint.clone no longer throws exception java.lang.CloneNotSupportedException [ChangedThrows]
+                        load-api.txt:5313: warning: Method android.gesture.GestureStroke.clone no longer throws exception java.lang.CloneNotSupportedException [ChangedThrows]
+                        load-api.txt:8395: warning: Constructor android.net.SSLCertificateSocketFactory no longer throws exception java.security.KeyManagementException [ChangedThrows]
+                        load-api.txt:8395: warning: Constructor android.net.SSLCertificateSocketFactory no longer throws exception java.security.NoSuchAlgorithmException [ChangedThrows]
+                        load-api.txt:24974: warning: Constructor java.nio.charset.Charset no longer throws exception java.nio.charset.IllegalCharsetNameException [ChangedThrows]
+                        load-api.txt:24987: warning: Method java.nio.charset.Charset.forName no longer throws exception java.nio.charset.IllegalCharsetNameException [ChangedThrows]
+                        load-api.txt:24987: warning: Method java.nio.charset.Charset.forName no longer throws exception java.nio.charset.UnsupportedCharsetException [ChangedThrows]
+                        load-api.txt:24990: warning: Method java.nio.charset.Charset.isSupported no longer throws exception java.nio.charset.IllegalCharsetNameException [ChangedThrows]
+                        load-api.txt:30437: warning: Method java.util.regex.Matcher.appendReplacement no longer throws exception java.lang.IllegalStateException [ChangedThrows]
+                        load-api.txt:30462: warning: Method java.util.regex.Matcher.start no longer throws exception java.lang.IllegalStateException [ChangedThrows]
+                        load-api.txt:30471: warning: Method java.util.regex.Pattern.compile no longer throws exception java.util.regex.PatternSyntaxException [ChangedThrows]
+                        load-api.txt:32652: warning: Class javax.xml.XMLConstants added 'final' qualifier [AddedFinal]
+                        load-api.txt:32849: warning: Method javax.xml.parsers.DocumentBuilder.isXIncludeAware no longer throws exception java.lang.UnsupportedOperationException [ChangedThrows]
+                        load-api.txt:32874: warning: Method javax.xml.parsers.DocumentBuilderFactory.newInstance no longer throws exception javax.xml.parsers.FactoryConfigurationError [ChangedThrows]
+                        load-api.txt:32908: warning: Method javax.xml.parsers.SAXParser.isXIncludeAware no longer throws exception java.lang.UnsupportedOperationException [ChangedThrows]
+                        load-api.txt:32930: warning: Method javax.xml.parsers.SAXParserFactory.newInstance no longer throws exception javax.xml.parsers.FactoryConfigurationError [ChangedThrows]
+                        load-api.txt:37246: warning: Method org.w3c.dom.Element.getAttributeNS added thrown exception org.w3c.dom.DOMException [ChangedThrows]
+                        load-api.txt:37248: warning: Method org.w3c.dom.Element.getAttributeNodeNS added thrown exception org.w3c.dom.DOMException [ChangedThrows]
+                        load-api.txt:37250: warning: Method org.w3c.dom.Element.getElementsByTagNameNS added thrown exception org.w3c.dom.DOMException [ChangedThrows]
+                        load-api.txt:37254: warning: Method org.w3c.dom.Element.hasAttributeNS added thrown exception org.w3c.dom.DOMException [ChangedThrows]
+                        load-api.txt:37290: warning: Method org.w3c.dom.NamedNodeMap.getNamedItemNS added thrown exception org.w3c.dom.DOMException [ChangedThrows]
+                        released-api.txt:31151: error: Removed constructor javax.xml.XMLConstants() [RemovedMethod]
+                    """,
                     hide(
                         DEFAULT_HIDDEN_ISSUES_STRING,
                         "AddedAbstractMethod",
@@ -146,12 +144,12 @@ abstract class CompatibilityCheckAndroidApisTest(
                 ApiLevelCheck(
                     18,
                     """
-                error: Added method android.content.pm.PackageManager.getPackagesHoldingPermissions(String[],int) [AddedAbstractMethod]
-                error: Added method android.widget.MediaController.MediaPlayerControl.getAudioSessionId() [AddedAbstractMethod]
-                error: Removed class android.renderscript.Program [RemovedClass]
-                error: Removed class android.renderscript.ProgramStore [RemovedClass]
-                error: Removed field android.os.Process.BLUETOOTH_GID [RemovedField]
-                """,
+                        load-api.txt:6911: error: Added method android.content.pm.PackageManager.getPackagesHoldingPermissions(String[],int) [AddedAbstractMethod]
+                        load-api.txt:29748: error: Added method android.widget.MediaController.MediaPlayerControl.getAudioSessionId() [AddedAbstractMethod]
+                        released-api.txt:16415: error: Removed field android.os.Process.BLUETOOTH_GID [RemovedField]
+                        released-api.txt:19682: error: Removed class android.renderscript.Program [RemovedClass]
+                        released-api.txt:19764: error: Removed class android.renderscript.ProgramStore [RemovedClass]
+                    """,
                     hide(
                         "AddedClass",
                         "AddedField",
@@ -169,20 +167,20 @@ abstract class CompatibilityCheckAndroidApisTest(
                 ApiLevelCheck(
                     19,
                     """
-                warning: Field android.view.animation.Transformation.TYPE_ALPHA has added 'final' qualifier [AddedFinal]
-                warning: Field android.view.animation.Transformation.TYPE_BOTH has added 'final' qualifier [AddedFinal]
-                warning: Field android.view.animation.Transformation.TYPE_IDENTITY has added 'final' qualifier [AddedFinal]
-                warning: Field android.view.animation.Transformation.TYPE_MATRIX has added 'final' qualifier [AddedFinal]
-                warning: Method java.nio.CharBuffer.subSequence has changed return type from java.lang.CharSequence to java.nio.CharBuffer [ChangedType]
-                warning: Field android.view.animation.Transformation.TYPE_ALPHA has changed value from nothing/not constant to 1 [ChangedValue]
-                warning: Field android.view.animation.Transformation.TYPE_BOTH has changed value from nothing/not constant to 3 [ChangedValue]
-                warning: Field android.view.animation.Transformation.TYPE_IDENTITY has changed value from nothing/not constant to 0 [ChangedValue]
-                warning: Field android.view.animation.Transformation.TYPE_MATRIX has changed value from nothing/not constant to 2 [ChangedValue]
-                error: Removed method android.os.Debug.MemoryInfo.getOtherLabel(int) [RemovedMethod]
-                error: Removed method android.os.Debug.MemoryInfo.getOtherPrivateDirty(int) [RemovedMethod]
-                error: Removed method android.os.Debug.MemoryInfo.getOtherPss(int) [RemovedMethod]
-                error: Removed method android.os.Debug.MemoryInfo.getOtherSharedDirty(int) [RemovedMethod]
-                """,
+                        load-api.txt:29411: warning: Field android.view.animation.Transformation.TYPE_ALPHA has added 'final' qualifier [AddedFinal]
+                        load-api.txt:29411: warning: Field android.view.animation.Transformation.TYPE_ALPHA has changed value from nothing/not constant to 1 [ChangedValue]
+                        load-api.txt:29412: warning: Field android.view.animation.Transformation.TYPE_BOTH has added 'final' qualifier [AddedFinal]
+                        load-api.txt:29412: warning: Field android.view.animation.Transformation.TYPE_BOTH has changed value from nothing/not constant to 3 [ChangedValue]
+                        load-api.txt:29413: warning: Field android.view.animation.Transformation.TYPE_IDENTITY has added 'final' qualifier [AddedFinal]
+                        load-api.txt:29413: warning: Field android.view.animation.Transformation.TYPE_IDENTITY has changed value from nothing/not constant to 0 [ChangedValue]
+                        load-api.txt:29414: warning: Field android.view.animation.Transformation.TYPE_MATRIX has added 'final' qualifier [AddedFinal]
+                        load-api.txt:29414: warning: Field android.view.animation.Transformation.TYPE_MATRIX has changed value from nothing/not constant to 2 [ChangedValue]
+                        load-api.txt:37262: warning: Method java.nio.CharBuffer.subSequence has changed return type from java.lang.CharSequence to java.nio.CharBuffer [ChangedType]
+                        released-api.txt:16987: error: Removed method android.os.Debug.MemoryInfo.getOtherLabel(int) [RemovedMethod]
+                        released-api.txt:16988: error: Removed method android.os.Debug.MemoryInfo.getOtherPrivateDirty(int) [RemovedMethod]
+                        released-api.txt:16989: error: Removed method android.os.Debug.MemoryInfo.getOtherPss(int) [RemovedMethod]
+                        released-api.txt:16990: error: Removed method android.os.Debug.MemoryInfo.getOtherSharedDirty(int) [RemovedMethod]
+                    """,
                     // The last warning above is not right; seems to be a PSI jar loading bug. It
                     // returns the wrong return type!
                     hide(
@@ -198,10 +196,10 @@ abstract class CompatibilityCheckAndroidApisTest(
                 ApiLevelCheck(
                     20,
                     """
-                warning: Field org.xmlpull.v1.XmlPullParserFactory.features has changed type from java.util.HashMap to java.util.HashMap<java.lang.String,java.lang.Boolean> [ChangedType]
-                warning: Method org.json.JSONObject.keys has changed return type from java.util.Iterator to java.util.Iterator<java.lang.String> [ChangedType]
-                error: Removed method android.util.TypedValue.complexToDimensionNoisy(int,android.util.DisplayMetrics) [RemovedMethod]
-                """,
+                        load-api.txt:51013: warning: Method org.json.JSONObject.keys has changed return type from java.util.Iterator to java.util.Iterator<java.lang.String> [ChangedType]
+                        load-api.txt:52005: warning: Field org.xmlpull.v1.XmlPullParserFactory.features has changed type from java.util.HashMap to java.util.HashMap<java.lang.String,java.lang.Boolean> [ChangedType]
+                        released-api.txt:26150: error: Removed method android.util.TypedValue.complexToDimensionNoisy(int,android.util.DisplayMetrics) [RemovedMethod]
+                    """,
                     hide(
                         DEFAULT_HIDDEN_ISSUES_STRING,
                         "AddedAbstractMethod",
@@ -213,9 +211,9 @@ abstract class CompatibilityCheckAndroidApisTest(
                 ApiLevelCheck(
                     26,
                     """
-                warning: Field android.app.ActivityManager.RunningAppProcessInfo.IMPORTANCE_PERCEPTIBLE has changed value from 130 to 230 [ChangedValue]
-                warning: Field android.content.pm.PermissionInfo.PROTECTION_MASK_FLAGS has changed value from 4080 to 65520 [ChangedValue]
-                """,
+                        load-api.txt:3941: warning: Field android.app.ActivityManager.RunningAppProcessInfo.IMPORTANCE_PERCEPTIBLE has changed value from 130 to 230 [ChangedValue]
+                        load-api.txt:10849: warning: Field android.content.pm.PermissionInfo.PROTECTION_MASK_FLAGS has changed value from 4080 to 65520 [ChangedValue]
+                    """,
                     hide(
                         "AddedAbstractMethod",
                         "AddedClass",
@@ -278,44 +276,17 @@ abstract class CompatibilityCheckAndroidApisTest(
                 else ""
             val extraArgs = apiLevelCheck.extraArgs.toTypedArray()
 
-            val current = getAndroidJar(apiLevel)
-            val previous = getAndroidJar(apiLevel - 1)
-            val previousApi = previous.path
-
-            // PSI based check
+            val current = getAndroidTxt(apiLevel)
+            val previous = getAndroidTxt(apiLevel - 1)
 
             check(
                 extraArguments = extraArgs,
                 expectedIssues = expectedIssues,
                 expectedFail = expectedFail,
-                checkCompatibilityApiReleased = previousApi,
-                apiJar = current,
+                checkCompatibilityApiReleased = previous.readText(),
+                signatureSource = current.readText(),
                 skipEmitPackages = emptyList(),
             )
-
-            // Signature based check
-            if (apiLevel >= 21) {
-                // Check signature file checks. We have .txt files for API level 14 and up, but
-                // there are a
-                // BUNCH of problems in older signature files that make the comparisons not work --
-                // missing type variables in class declarations, missing generics in method
-                // signatures, etc.
-                val signatureFile =
-                    File("../../../prebuilts/sdk/${apiLevel - 1}/public/api/android.txt")
-                assertTrue(
-                    "Couldn't find $signatureFile: Check that pwd (${File("").absolutePath}) for test is correct",
-                    signatureFile.isFile
-                )
-
-                check(
-                    extraArguments = extraArgs,
-                    expectedIssues = expectedIssues,
-                    expectedFail = expectedFail,
-                    checkCompatibilityApiReleased = signatureFile.path,
-                    apiJar = current,
-                    skipEmitPackages = emptyList(),
-                )
-            }
         }
     }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckTest.kt b/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckTest.kt
index 3caf9f008..75cfa2e7d 100644
--- a/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/compatibility/CompatibilityCheckTest.kt
@@ -17,7 +17,6 @@
 package com.android.tools.metalava.compatibility
 
 import com.android.tools.lint.checks.infrastructure.TestFiles.base64gzip
-import com.android.tools.metalava.ANDROID_SYSTEM_API
 import com.android.tools.metalava.ARG_SHOW_ANNOTATION
 import com.android.tools.metalava.ARG_SHOW_UNANNOTATED
 import com.android.tools.metalava.DriverTest
@@ -25,6 +24,7 @@ import com.android.tools.metalava.androidxNonNullSource
 import com.android.tools.metalava.androidxNullableSource
 import com.android.tools.metalava.cli.common.ARG_ERROR_CATEGORY
 import com.android.tools.metalava.cli.common.ARG_HIDE
+import com.android.tools.metalava.model.ANDROID_SYSTEM_API
 import com.android.tools.metalava.model.provider.Capability
 import com.android.tools.metalava.model.testing.RequiresCapabilities
 import com.android.tools.metalava.model.text.ApiClassResolution
diff --git a/metalava/src/test/java/com/android/tools/metalava/compatibility/FastPathTest.kt b/metalava/src/test/java/com/android/tools/metalava/compatibility/FastPathTest.kt
index c806db46a..5def09671 100644
--- a/metalava/src/test/java/com/android/tools/metalava/compatibility/FastPathTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/compatibility/FastPathTest.kt
@@ -18,11 +18,11 @@ package com.android.tools.metalava.compatibility
 
 import com.android.tools.lint.checks.infrastructure.TestFile
 import com.android.tools.lint.checks.infrastructure.TestFiles
-import com.android.tools.metalava.ApiType
 import com.android.tools.metalava.DriverTest
 import com.android.tools.metalava.fastPathCheckResult
 import com.android.tools.metalava.model.text.FileFormat
 import com.android.tools.metalava.model.text.stripBlankLines
+import com.android.tools.metalava.model.visitors.ApiType
 import com.android.tools.metalava.testing.getAndroidJar
 import com.android.tools.metalava.testing.java
 import org.junit.Assert
diff --git a/metalava/src/test/java/com/android/tools/metalava/compatibility/MultipleCompatibilityFilesTest.kt b/metalava/src/test/java/com/android/tools/metalava/compatibility/MultipleCompatibilityFilesTest.kt
index b522ee005..f0de9e46d 100644
--- a/metalava/src/test/java/com/android/tools/metalava/compatibility/MultipleCompatibilityFilesTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/compatibility/MultipleCompatibilityFilesTest.kt
@@ -16,7 +16,9 @@
 
 package com.android.tools.metalava.compatibility
 
+import com.android.tools.metalava.ARG_SHOW_ANNOTATION
 import com.android.tools.metalava.DriverTest
+import com.android.tools.metalava.model.ANDROID_SYSTEM_API
 import org.junit.Test
 
 class MultipleCompatibilityFilesTest : DriverTest() {
@@ -108,6 +110,7 @@ class MultipleCompatibilityFilesTest : DriverTest() {
     @Test
     fun `Test current system vs multiple released compatibility files`() {
         check(
+            extraArguments = arrayOf(ARG_SHOW_ANNOTATION, ANDROID_SYSTEM_API),
             checkCompatibilityApiReleasedList =
                 listOf(previouslyReleasedPublicApi, previouslyReleasedSystemApiDelta),
             signatureSource = currentCompleteSystemApi,
@@ -121,6 +124,7 @@ class MultipleCompatibilityFilesTest : DriverTest() {
     @Test
     fun `Test current system vs multiple released compatibility files (invalid first)`() {
         check(
+            extraArguments = arrayOf(ARG_SHOW_ANNOTATION, ANDROID_SYSTEM_API),
             checkCompatibilityApiReleasedList =
                 listOf("Invalid Signature File", previouslyReleasedSystemApiDelta),
             signatureSource = currentCompleteSystemApi,
@@ -134,6 +138,7 @@ class MultipleCompatibilityFilesTest : DriverTest() {
     @Test
     fun `Test current public vs multiple removed compatibility files (invalid first)`() {
         check(
+            extraArguments = arrayOf(ARG_SHOW_ANNOTATION, ANDROID_SYSTEM_API),
             checkCompatibilityRemovedApiReleasedList =
                 listOf("Invalid Signature File", previouslyReleasedPublicApi),
             signatureSource = currentCompletePublicApi,
diff --git a/metalava/src/test/java/com/android/tools/metalava/doc/DocAnalyzerTest.kt b/metalava/src/test/java/com/android/tools/metalava/doc/DocAnalyzerTest.kt
index 8228fe689..575dcd017 100644
--- a/metalava/src/test/java/com/android/tools/metalava/doc/DocAnalyzerTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/doc/DocAnalyzerTest.kt
@@ -921,6 +921,62 @@ class DocAnalyzerTest : DriverTest() {
         )
     }
 
+    @Test
+    fun `Api levels current codename but no current version`() {
+        check(
+            extraArguments =
+                arrayOf(
+                    ARG_CURRENT_CODENAME,
+                    "Z",
+                ),
+            includeSystemApiAnnotations = true,
+            sourceFiles =
+                arrayOf(
+                    java(
+                        """
+                            package android.pkg;
+                            public class Test {
+                               public static final String UNIT_TEST_1 = "unit.test.1";
+                               public static final String UNIT_TEST_2 = "unit.test.2";
+                            }
+                        """
+                    ),
+                ),
+            applyApiLevelsXml =
+                """
+                    <?xml version="1.0" encoding="utf-8"?>
+                    <api version="2">
+                        <class name="android/pkg/Test" since="1">
+                            <field name="UNIT_TEST_1" since="24" deprecated="30"/>
+                            <field name="UNIT_TEST_2" since="36"/>
+                        </class>
+                    </api>
+                """,
+            checkCompilation = true,
+            docStubs = true,
+            stubFiles =
+                arrayOf(
+                    java(
+                        """
+                            package android.pkg;
+                            /** @apiSince 1 */
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public class Test {
+                            public Test() { throw new RuntimeException("Stub!"); }
+                            /**
+                             * @apiSince 24
+                             * @deprecatedSince 30
+                             */
+                            public static final java.lang.String UNIT_TEST_1 = "unit.test.1";
+                            /** @apiSince 36 */
+                            public static final java.lang.String UNIT_TEST_2 = "unit.test.2";
+                            }
+                        """
+                    )
+                )
+        )
+    }
+
     @Test
     fun `No api levels on SystemApi only elements`() {
         // @SystemApi, @TestApi etc cannot get api versions since we don't have
diff --git a/metalava/src/test/java/com/android/tools/metalava/stub/StubsConstructorSelectionTest.kt b/metalava/src/test/java/com/android/tools/metalava/stub/StubsConstructorSelectionTest.kt
new file mode 100644
index 000000000..f255ea1f6
--- /dev/null
+++ b/metalava/src/test/java/com/android/tools/metalava/stub/StubsConstructorSelectionTest.kt
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tools.metalava.stub
+
+import com.android.tools.metalava.testing.java
+import org.junit.Test
+import org.junit.runners.Parameterized
+
+/** Tests which constructors are selected for use by derived stub classes. */
+class StubsConstructorSelectionTest : AbstractStubsTest() {
+
+    @Parameterized.Parameter(0) lateinit var params: TestParams
+
+    data class TestParams(
+        /** Name of the test. */
+        val name: String,
+
+        /** List of parameters for each input constructor. */
+        val parameters: List<String>,
+
+        /** The arguments to the super call in the input child class. */
+        val inputSuperArgs: String,
+
+        /** The arguments to the super call in the output child stub class. */
+        val outputSuperArgs: String,
+    ) {
+        override fun toString() = name
+
+        /** The superCall in the output child stub class. */
+        val outputSuperCall = if (outputSuperArgs.isEmpty()) "" else "super($outputSuperArgs); "
+    }
+
+    companion object {
+        @JvmStatic @Parameterized.Parameters fun params() = params
+
+        private val params =
+            listOf(
+                    TestParams(
+                        name = "different parameter count including empty",
+                        parameters = listOf("", "int i"),
+                        inputSuperArgs = "",
+                        // Choose the constructor with the fewest number of parameters, i.e. 0.
+                        outputSuperArgs = "",
+                    ),
+                    TestParams(
+                        name = "different parameter count",
+                        parameters = listOf("String s, Number r", "int i"),
+                        inputSuperArgs = "",
+                        // Choose the constructor with the fewest number of parameters, i.e. 1.
+                        outputSuperArgs = "0",
+                    ),
+                    TestParams(
+                        name = "same number of parameters different types",
+                        parameters = listOf("Number b", "Short i"),
+                        inputSuperArgs = "",
+                        // Choose the constructor with the shortest types, i.e. `Short`.
+                        outputSuperArgs = "(java.lang.Short)null",
+                    ),
+                    TestParams(
+                        name = "same number of parameters and same type length",
+                        parameters = listOf("java.util.Map m", "java.util.Set s"),
+                        inputSuperArgs = "(java.util.Set)null",
+                        // Choose the constructor that comes earliest in the parent class.
+                        outputSuperArgs = "(java.util.Map)null",
+                    ),
+                )
+                .flatMap {
+                    // Run the test forwards and backwards, they should be the same.
+                    listOf(
+                        it.copy(name = "${it.name} - forward"),
+                        it.copy(
+                            name = "${it.name} - backward",
+                            parameters = it.parameters.reversed(),
+                        ),
+                    )
+                }
+    }
+
+    @Test
+    fun `Stub constructor selection`() {
+        checkStubs(
+            sourceFiles =
+                arrayOf(
+                    java(
+                        buildString {
+                            append("package test.pkg;")
+                            append("public class Parent {")
+                            params.parameters.joinTo(this, "\n") { "public Parent($it) {}" }
+                            append("}")
+                        }
+                    ),
+                    java(
+                        """
+                            package test.pkg;
+                            public class Child extends Parent {
+                                public Child() {super(${params.inputSuperArgs});}
+                            }
+                        """
+                    ),
+                ),
+            stubFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public class Child extends test.pkg.Parent {
+                            public Child() { ${params.outputSuperCall}throw new RuntimeException("Stub!"); }
+                            }
+                        """
+                    ),
+                )
+        )
+    }
+}
diff --git a/metalava/src/test/java/com/android/tools/metalava/stub/StubsConstructorTest.kt b/metalava/src/test/java/com/android/tools/metalava/stub/StubsConstructorTest.kt
index 99dc5e593..a1088ab4e 100644
--- a/metalava/src/test/java/com/android/tools/metalava/stub/StubsConstructorTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/stub/StubsConstructorTest.kt
@@ -16,8 +16,11 @@
 
 package com.android.tools.metalava.stub
 
+import com.android.tools.metalava.model.provider.Capability
+import com.android.tools.metalava.model.testing.RequiresCapabilities
 import com.android.tools.metalava.model.text.FileFormat
 import com.android.tools.metalava.testing.java
+import com.android.tools.metalava.testing.kotlin
 import org.junit.Test
 
 @SuppressWarnings("ALL")
@@ -923,4 +926,47 @@ class StubsConstructorTest : AbstractStubsTest() {
                 )
         )
     }
+
+    @RequiresCapabilities(Capability.KOTLIN)
+    @Test
+    fun `File facade constructor`() {
+        check(
+            format = FileFormat.V2,
+            sourceFiles =
+                arrayOf(
+                    kotlin(
+                        "test/pkg/Constants.kt",
+                        """
+                            package test.pkg
+
+                            const val CONSTANT = "CONSTANT"
+                        """
+                    ),
+                ),
+            api =
+                """
+                    // Signature format: 2.0
+                    package test.pkg {
+                      public final class ConstantsKt {
+                        property public static final String CONSTANT;
+                        field @NonNull public static final String CONSTANT = "CONSTANT";
+                      }
+                    }
+                """,
+            stubPaths = arrayOf("test/pkg/ConstantsKt.java"),
+            stubFiles =
+                arrayOf(
+                    java(
+                        """
+                            package test.pkg;
+                            @SuppressWarnings({"unchecked", "deprecation", "all"})
+                            public final class ConstantsKt {
+                            ConstantsKt() { throw new RuntimeException("Stub!"); }
+                            @android.annotation.NonNull public static final java.lang.String CONSTANT = "CONSTANT";
+                            }
+                        """
+                    )
+                )
+        )
+    }
 }
diff --git a/metalava/src/test/java/com/android/tools/metalava/stub/StubsTest.kt b/metalava/src/test/java/com/android/tools/metalava/stub/StubsTest.kt
index d40d69036..9a6f9aeff 100644
--- a/metalava/src/test/java/com/android/tools/metalava/stub/StubsTest.kt
+++ b/metalava/src/test/java/com/android/tools/metalava/stub/StubsTest.kt
@@ -1405,6 +1405,7 @@ class StubsTest : AbstractStubsTest() {
                     package android.util;
                     @SuppressWarnings({"unchecked", "deprecation", "all"})
                     public final class ArrayMapKt {
+                    ArrayMapKt() { throw new RuntimeException("Stub!"); }
                     /**
                      * @deprecated Use android.Manifest.permission.ACCESS_FINE_LOCATION instead
                      */
diff --git a/metalava/src/test/resources/source-model-provider-baseline.txt b/metalava/src/test/resources/source-model-provider-baseline.txt
index a6dafa86f..2648e1287 100644
--- a/metalava/src/test/resources/source-model-provider-baseline.txt
+++ b/metalava/src/test/resources/source-model-provider-baseline.txt
@@ -70,7 +70,6 @@ com.android.tools.metalava.Java9LanguageFeaturesTest
 com.android.tools.metalava.JavadocTest
   Check references to inherited field constants[turbine]
   Ensure references to classes in JavaDoc of hidden members do not affect imports[turbine]
-  Handle @attr references[turbine]
   Javadoc link to innerclass constructor[turbine]
   Relative documentation links in stubs[turbine]
   Rewrite parameter list 2[turbine]
@@ -138,20 +137,6 @@ com.android.tools.metalava.UnhideApisTest
 com.android.tools.metalava.apilevels.ApiGeneratorTest
   APIs annotated with suppress-compatibility-meta-annotations appear in output[turbine]
 
-com.android.tools.metalava.compatibility.CheckAndroidApisShard1Test
-  Test All Android API levels[turbine,4 to 5]
-  Test All Android API levels[turbine,5 to 6]
-  Test All Android API levels[turbine,6 to 7]
-  Test All Android API levels[turbine,7 to 8]
-
-com.android.tools.metalava.compatibility.CheckAndroidApisShard2Test
-  Test All Android API levels[turbine,17 to 18]
-  Test All Android API levels[turbine,18 to 19]
-  Test All Android API levels[turbine,19 to 20]
-
-com.android.tools.metalava.compatibility.CheckAndroidApisShard3Test
-  Test All Android API levels[turbine,25 to 26]
-
 com.android.tools.metalava.compatibility.CompatibilityCheckTest
   Conversion from AutoCloseable to Closeable is not API-breaking[turbine]
   Conversion from MutableCollection to AbstractMutableCollection is not API-breaking[turbine]
diff --git a/metalava/src/testdata/prebuilts-sdk-test/30/ClassAddedInApi30.java b/metalava/src/testdata/prebuilts-sdk-test/30/ClassAddedInApi30.java
index 50ea924b1..7385ba148 100644
--- a/metalava/src/testdata/prebuilts-sdk-test/30/ClassAddedInApi30.java
+++ b/metalava/src/testdata/prebuilts-sdk-test/30/ClassAddedInApi30.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package android.test;
 
 public class ClassAddedInApi30 {
diff --git a/metalava/src/testdata/prebuilts-sdk-test/30/Object.java b/metalava/src/testdata/prebuilts-sdk-test/30/Object.java
index a673c1a1f..86ad2a18d 100644
--- a/metalava/src/testdata/prebuilts-sdk-test/30/Object.java
+++ b/metalava/src/testdata/prebuilts-sdk-test/30/Object.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package java.lang;
 
 public class Object {
diff --git a/metalava/src/testdata/prebuilts-sdk-test/31/ClassAddedInApi30.java b/metalava/src/testdata/prebuilts-sdk-test/31/ClassAddedInApi30.java
index 9cb67032d..ec077e7a7 100644
--- a/metalava/src/testdata/prebuilts-sdk-test/31/ClassAddedInApi30.java
+++ b/metalava/src/testdata/prebuilts-sdk-test/31/ClassAddedInApi30.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package android.test;
 
 public class ClassAddedInApi30 {
diff --git a/metalava/src/testdata/prebuilts-sdk-test/31/ClassAddedInApi31AndExt2.java b/metalava/src/testdata/prebuilts-sdk-test/31/ClassAddedInApi31AndExt2.java
index 772b83075..487acb45c 100644
--- a/metalava/src/testdata/prebuilts-sdk-test/31/ClassAddedInApi31AndExt2.java
+++ b/metalava/src/testdata/prebuilts-sdk-test/31/ClassAddedInApi31AndExt2.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package android.test;
 
 public class ClassAddedInApi31AndExt2 {
diff --git a/metalava/src/testdata/prebuilts-sdk-test/31/ClassAddedInExt1.java b/metalava/src/testdata/prebuilts-sdk-test/31/ClassAddedInExt1.java
index cb9c864e5..3171fe897 100644
--- a/metalava/src/testdata/prebuilts-sdk-test/31/ClassAddedInExt1.java
+++ b/metalava/src/testdata/prebuilts-sdk-test/31/ClassAddedInExt1.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package android.test;
 
 public class ClassAddedInExt1 {
diff --git a/metalava/src/testdata/prebuilts-sdk-test/31/Object.java b/metalava/src/testdata/prebuilts-sdk-test/31/Object.java
index a673c1a1f..86ad2a18d 100644
--- a/metalava/src/testdata/prebuilts-sdk-test/31/Object.java
+++ b/metalava/src/testdata/prebuilts-sdk-test/31/Object.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package java.lang;
 
 public class Object {
diff --git a/metalava/src/testdata/prebuilts-sdk-test/extensions/1/ClassAddedInExt1.java b/metalava/src/testdata/prebuilts-sdk-test/extensions/1/ClassAddedInExt1.java
index aef7e0ae6..04fe709c7 100644
--- a/metalava/src/testdata/prebuilts-sdk-test/extensions/1/ClassAddedInExt1.java
+++ b/metalava/src/testdata/prebuilts-sdk-test/extensions/1/ClassAddedInExt1.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package android.test;
 
 public class ClassAddedInExt1 {
diff --git a/metalava/src/testdata/prebuilts-sdk-test/extensions/2/ClassAddedInApi30.java b/metalava/src/testdata/prebuilts-sdk-test/extensions/2/ClassAddedInApi30.java
new file mode 100644
index 000000000..754af1c5d
--- /dev/null
+++ b/metalava/src/testdata/prebuilts-sdk-test/extensions/2/ClassAddedInApi30.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.test;
+
+public class ClassAddedInApi30 extends MarkerSuperClass implements MarkerInterface {
+    private ClassAddedInApi30() {}
+    public void methodAddedInApi30() { throw new RuntimeException("Stub!"); }
+    public void methodAddedInApi31() { throw new RuntimeException("Stub!"); }
+}
diff --git a/metalava/src/testdata/prebuilts-sdk-test/extensions/2/MarkerInterface.java b/metalava/src/testdata/prebuilts-sdk-test/extensions/2/MarkerInterface.java
new file mode 100644
index 000000000..44baf3a2d
--- /dev/null
+++ b/metalava/src/testdata/prebuilts-sdk-test/extensions/2/MarkerInterface.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.test;
+
+public interface MarkerInterface {
+}
diff --git a/metalava/src/testdata/prebuilts-sdk-test/extensions/2/MarkerSuperClass.java b/metalava/src/testdata/prebuilts-sdk-test/extensions/2/MarkerSuperClass.java
new file mode 100644
index 000000000..1c2f1cb2f
--- /dev/null
+++ b/metalava/src/testdata/prebuilts-sdk-test/extensions/2/MarkerSuperClass.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.test;
+
+public class MarkerSuperClass {
+}
diff --git a/metalava/src/testdata/prebuilts-sdk-test/extensions/3/ClassAddedInApi31AndExt2.java b/metalava/src/testdata/prebuilts-sdk-test/extensions/3/ClassAddedInApi31AndExt2.java
index fa31b8e5e..d4608ef1d 100644
--- a/metalava/src/testdata/prebuilts-sdk-test/extensions/3/ClassAddedInApi31AndExt2.java
+++ b/metalava/src/testdata/prebuilts-sdk-test/extensions/3/ClassAddedInApi31AndExt2.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package android.test;
 
 public class ClassAddedInApi31AndExt2 {
diff --git a/metalava/src/testdata/prebuilts-sdk-test/extensions/3/ClassAddedInExt1.java b/metalava/src/testdata/prebuilts-sdk-test/extensions/3/ClassAddedInExt1.java
index c5798d6c2..5fd72c2a0 100644
--- a/metalava/src/testdata/prebuilts-sdk-test/extensions/3/ClassAddedInExt1.java
+++ b/metalava/src/testdata/prebuilts-sdk-test/extensions/3/ClassAddedInExt1.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package android.test;
 
 public class ClassAddedInExt1 {
diff --git a/metalava/src/testdata/prebuilts-sdk-test/extensions/3/ClassAddedInExt3.java b/metalava/src/testdata/prebuilts-sdk-test/extensions/3/ClassAddedInExt3.java
index 31b58ec39..18365d473 100644
--- a/metalava/src/testdata/prebuilts-sdk-test/extensions/3/ClassAddedInExt3.java
+++ b/metalava/src/testdata/prebuilts-sdk-test/extensions/3/ClassAddedInExt3.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package android.test;
 
 public class ClassAddedInExt3 {
diff --git a/scripts/gather-android-metalava-artifacts.py b/scripts/gather-android-metalava-artifacts.py
index 188c13a6f..ee3d9b234 100755
--- a/scripts/gather-android-metalava-artifacts.py
+++ b/scripts/gather-android-metalava-artifacts.py
@@ -87,6 +87,8 @@ def default_api_version_files():
         "out/soong/lint/api_versions_system.xml",
         "out/soong/lint/api_versions_module_lib.xml",
         "out/soong/lint/api_versions_system_server.xml",
+        "out/target/common/obj/PACKAGING/api_versions_module_lib_complete_generated-api-versions.xml",
+        "out/target/common/obj/PACKAGING/api_versions_system_server_complete_generated-api-versions.xml",
     ]
 
 
@@ -109,9 +111,9 @@ def default_jdiff_files():
         "out/soong/.intermediates/cts/tests/signature/api/cts-android-test-runner-current-api-gz/gen/android-test-runner-current.api.gz",
         "out/soong/.intermediates/cts/tests/signature/api/cts-apache-http-legacy-current-api-gz/gen/apache-http-legacy-current.api.gz",
         "out/soong/.intermediates/cts/tests/signature/api/cts-car-system-current-api-gz/gen/car-system-current.api.gz",
-        "out/soong/.intermediates/cts/tests/signature/api/cts-current-api-gz/gen/current.api.gz",
-        "out/soong/.intermediates/cts/tests/signature/api/cts-system-current-api-gz/gen/system-current.api.gz",
-        "out/soong/.intermediates/cts/tests/signature/api/cts-system-removed-api-gz/gen/system-removed.api.gz",
+        "out/soong/.intermediates/cts/tests/signature/api/cts-current-api-gz/android_common/gen/current.api.gz",
+        "out/soong/.intermediates/cts/tests/signature/api/cts-system-current-api-gz/android_common/gen/system-current.api.gz",
+        "out/soong/.intermediates/cts/tests/signature/api/cts-system-removed-api-gz/android_common/gen/system-removed.api.gz",
 
     ]
 
diff --git a/stub-annotations/src/main/java/androidx/annotation/Discouraged.java b/stub-annotations/src/main/java/androidx/annotation/Discouraged.java
index dd5f190b3..0c64ea677 100644
--- a/stub-annotations/src/main/java/androidx/annotation/Discouraged.java
+++ b/stub-annotations/src/main/java/androidx/annotation/Discouraged.java
@@ -21,13 +21,13 @@ import static java.lang.annotation.ElementType.FIELD;
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.ElementType.PARAMETER;
 import static java.lang.annotation.ElementType.TYPE;
-import static java.lang.annotation.RetentionPolicy.SOURCE;
+import static java.lang.annotation.RetentionPolicy.CLASS;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
 /** Stub only annotation. Do not use directly. */
-@Retention(SOURCE)
+@Retention(CLASS)
 @Target({CONSTRUCTOR, FIELD, METHOD, PARAMETER, TYPE})
 public @interface Discouraged {
     /**
```

